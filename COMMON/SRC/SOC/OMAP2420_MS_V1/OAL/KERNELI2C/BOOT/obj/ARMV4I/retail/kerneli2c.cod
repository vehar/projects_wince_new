; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\OAL\KERNELI2C\kerneli2c.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|gpLowTrans| %	0x4

  00000			 AREA	 |.data|, DATA
|gCurClockDivisor| DCD 0xf

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|KERNELI2C_OEMInit|
	IMPORT	|OALPAtoVA|

  00004			 AREA	 |.bss|, NOINIT
|gpPRCMRegs| %	0x4
|gpI2CRegs| %	0x4
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\oal\kerneli2c\kerneli2c.c

  00000			 AREA	 |.pdata|, PDATA
|$T45820| DCD	|$LN7@KERNELI2C_|
	DCD	0x40007802
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KERNELI2C_OEMInit| PROC

; 33   : {

  00000		 |$LN7@KERNELI2C_|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45817|

; 34   :     // get uncached register addresses
; 35   :     gpI2CRegs = (OMAP2420_I2C_REGS *)OALPAtoUA(OMAP2420_I2C1_REGS_PA);

  00008	e3a01000	 mov         r1, #0
  0000c	e3a00312	 mov         r0, #0x12, 6
  00010	e3800807	 orr         r0, r0, #7, 16
  00014	eb000000	 bl          OALPAtoVA
  00018	e58d0000	 str         r0, [sp]
  0001c	e59d2000	 ldr         r2, [sp]
  00020	e59f31b0	 ldr         r3, [pc, #0x1B0]
  00024	e5832000	 str         r2, [r3]

; 36   :     gpPRCMRegs = (OMAP2420_PRCM_REGS *)OALPAtoUA(OMAP2420_PRCM_REGS_PA);

  00028	e3a01000	 mov         r1, #0
  0002c	e3a00312	 mov         r0, #0x12, 6
  00030	e3800902	 orr         r0, r0, #2, 18
  00034	eb000000	 bl          OALPAtoVA
  00038	e58d0004	 str         r0, [sp, #4]
  0003c	e59d2004	 ldr         r2, [sp, #4]
  00040	e59f318c	 ldr         r3, [pc, #0x18C]
  00044	e5832000	 str         r2, [r3]

; 37   : 
; 38   :     // turn on the clocks - we are inside oeminit so don't need to use kerneliocontrol
; 39   :     gpPRCMRegs->ulCM_FCLKEN1_CORE |= PRCM_FCLKEN1_CORE_EN_I2C1;

  00048	e59f3184	 ldr         r3, [pc, #0x184]
  0004c	e5933000	 ldr         r3, [r3]
  00050	e2833c02	 add         r3, r3, #2, 24
  00054	e5933000	 ldr         r3, [r3]
  00058	e3832702	 orr         r2, r3, #2, 14
  0005c	e59f3170	 ldr         r3, [pc, #0x170]
  00060	e5933000	 ldr         r3, [r3]
  00064	e2833c02	 add         r3, r3, #2, 24
  00068	e5832000	 str         r2, [r3]

; 40   :     gpPRCMRegs->ulCM_ICLKEN1_CORE |= PRCM_ICLKEN1_CORE_EN_I2C1;

  0006c	e59f3160	 ldr         r3, [pc, #0x160]
  00070	e5933000	 ldr         r3, [r3]
  00074	e2833e21	 add         r3, r3, #0x21, 28
  00078	e5933000	 ldr         r3, [r3]
  0007c	e3832702	 orr         r2, r3, #2, 14
  00080	e59f314c	 ldr         r3, [pc, #0x14C]
  00084	e5933000	 ldr         r3, [r3]
  00088	e2833e21	 add         r3, r3, #0x21, 28
  0008c	e5832000	 str         r2, [r3]

; 41   : 
; 42   :     // Reset the I2C controller
; 43   :     gpI2CRegs->I2C_SYSC = I2C_SYSC_SRST;

  00090	e59f3140	 ldr         r3, [pc, #0x140]
  00094	e5933000	 ldr         r3, [r3]
  00098	e2832020	 add         r2, r3, #0x20
  0009c	e3a03002	 mov         r3, #2
  000a0	e1c230b0	 strh        r3, [r2]

; 44   : 
; 45   :     // Set base clock as 12MHz & L/H period
; 46   :     gpI2CRegs->I2C_PSC = 0;

  000a4	e59f312c	 ldr         r3, [pc, #0x12C]
  000a8	e5933000	 ldr         r3, [r3]
  000ac	e2832030	 add         r2, r3, #0x30
  000b0	e3a03000	 mov         r3, #0
  000b4	e1c230b0	 strh        r3, [r2]

; 47   : 
; 48   :     // Set default L/H periods
; 49   :     gpI2CRegs->I2C_SCLL = (UINT16)gCurClockDivisor;

  000b8	e59f311c	 ldr         r3, [pc, #0x11C]
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e1a02803	 mov         r2, r3, lsl #16
  000c4	e1a02822	 mov         r2, r2, lsr #16
  000c8	e59f3108	 ldr         r3, [pc, #0x108]
  000cc	e5933000	 ldr         r3, [r3]
  000d0	e2833034	 add         r3, r3, #0x34
  000d4	e1c320b0	 strh        r2, [r3]

; 50   :     gpI2CRegs->I2C_SCLH = (UINT16)gCurClockDivisor;

  000d8	e59f30fc	 ldr         r3, [pc, #0xFC]
  000dc	e5933000	 ldr         r3, [r3]
  000e0	e1a02803	 mov         r2, r3, lsl #16
  000e4	e1a02822	 mov         r2, r2, lsr #16
  000e8	e59f30e8	 ldr         r3, [pc, #0xE8]
  000ec	e5933000	 ldr         r3, [r3]
  000f0	e2833038	 add         r3, r3, #0x38
  000f4	e1c320b0	 strh        r2, [r3]

; 51   : 
; 52   : 	//Write the OWN Address
; 53   :     gpI2CRegs->I2C_OA = 0x0E;

  000f8	e59f30d8	 ldr         r3, [pc, #0xD8]
  000fc	e5933000	 ldr         r3, [r3]
  00100	e2832028	 add         r2, r3, #0x28
  00104	e3a0300e	 mov         r3, #0xE
  00108	e1c230b0	 strh        r3, [r2]

; 54   : 
; 55   :     // Enable the I2C
; 56   :     gpI2CRegs->I2C_CON = I2C_CON_EN;

  0010c	e59f30c4	 ldr         r3, [pc, #0xC4]
  00110	e5933000	 ldr         r3, [r3]
  00114	e2832024	 add         r2, r3, #0x24
  00118	e3a03902	 mov         r3, #2, 18
  0011c	e1c230b0	 strh        r3, [r2]
  00120		 |$LN2@KERNELI2C_|

; 57   : 
; 58   :     // Wait until resetting is done
; 59   :     while (((gpI2CRegs->I2C_SYSS) & I2C_SYSS_RDONE) == 0);

  00120	e59f30b0	 ldr         r3, [pc, #0xB0]
  00124	e5933000	 ldr         r3, [r3]
  00128	e2833010	 add         r3, r3, #0x10
  0012c	e1d330b0	 ldrh        r3, [r3]
  00130	e3130001	 tst         r3, #1
  00134	1a000000	 bne         |$LN1@KERNELI2C_|
  00138	eafffff8	 b           |$LN2@KERNELI2C_|
  0013c		 |$LN1@KERNELI2C_|

; 60   : 
; 61   : 	// Clear number of bytes in the data payload
; 62   : 	gpI2CRegs->I2C_CNT = 0;

  0013c	e59f3094	 ldr         r3, [pc, #0x94]
  00140	e5933000	 ldr         r3, [r3]
  00144	e2832018	 add         r2, r3, #0x18
  00148	e3a03000	 mov         r3, #0
  0014c	e1c230b0	 strh        r3, [r2]

; 63   : 
; 64   :     // Clear all interrupts
; 65   :     gpI2CRegs->I2C_STAT = 0x3F;

  00150	e59f3080	 ldr         r3, [pc, #0x80]
  00154	e5933000	 ldr         r3, [r3]
  00158	e2832008	 add         r2, r3, #8
  0015c	e3a0303f	 mov         r3, #0x3F
  00160	e1c230b0	 strh        r3, [r2]

; 66   : 
; 67   :     // Disable all interrupts
; 68   :     gpI2CRegs->I2C_IE = 0x00;

  00164	e59f306c	 ldr         r3, [pc, #0x6C]
  00168	e5933000	 ldr         r3, [r3]
  0016c	e2832004	 add         r2, r3, #4
  00170	e3a03000	 mov         r3, #0
  00174	e1c230b0	 strh        r3, [r2]

; 69   : 
; 70   :     // now turn off the clocks - we are inside oeminit so don't need to use kernelIOControl
; 71   :     gpPRCMRegs->ulCM_FCLKEN1_CORE &= ~PRCM_FCLKEN1_CORE_EN_I2C1;

  00178	e59f3054	 ldr         r3, [pc, #0x54]
  0017c	e5933000	 ldr         r3, [r3]
  00180	e2833c02	 add         r3, r3, #2, 24
  00184	e5932000	 ldr         r2, [r3]
  00188	e3e03702	 mvn         r3, #2, 14
  0018c	e0022003	 and         r2, r2, r3
  00190	e59f303c	 ldr         r3, [pc, #0x3C]
  00194	e5933000	 ldr         r3, [r3]
  00198	e2833c02	 add         r3, r3, #2, 24
  0019c	e5832000	 str         r2, [r3]

; 72   :     gpPRCMRegs->ulCM_ICLKEN1_CORE &= ~PRCM_ICLKEN1_CORE_EN_I2C1;

  001a0	e59f302c	 ldr         r3, [pc, #0x2C]
  001a4	e5933000	 ldr         r3, [r3]
  001a8	e2833e21	 add         r3, r3, #0x21, 28
  001ac	e5932000	 ldr         r2, [r3]
  001b0	e3e03702	 mvn         r3, #2, 14
  001b4	e0022003	 and         r2, r2, r3
  001b8	e59f3014	 ldr         r3, [pc, #0x14]
  001bc	e5933000	 ldr         r3, [r3]
  001c0	e2833e21	 add         r3, r3, #0x21, 28
  001c4	e5832000	 str         r2, [r3]

; 73   : }

  001c8	e28dd008	 add         sp, sp, #8
  001cc	e49de004	 ldr         lr, [sp], #4
  001d0	e12fff1e	 bx          lr
  001d4		 |$LN8@KERNELI2C_|
  001d4		 |$LN9@KERNELI2C_|
  001d4	00000000	 DCD         |gpPRCMRegs|
  001d8		 |$LN10@KERNELI2C_|
  001d8	00000000	 DCD         |gpI2CRegs|
  001dc		 |$LN11@KERNELI2C_|
  001dc	00000000	 DCD         |gCurClockDivisor|
  001e0		 |$M45818|

			 ENDP  ; |KERNELI2C_OEMInit|

	EXPORT	|KERNELI2C_HalPostInit|

  00000			 AREA	 |.pdata|, PDATA
|$T45831| DCD	|$LN5@KERNELI2C_@2|
	DCD	0x40000100
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KERNELI2C_HalPostInit| PROC

; 76   : {

  00000		 |$LN5@KERNELI2C_@2|
  00000		 |$M45828|

; 77   : #ifndef BOOTLOADER
; 78   :     InitializeCriticalSection(&gSec);
; 79   : #endif
; 80   : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45829|

			 ENDP  ; |KERNELI2C_HalPostInit|


  00000			 AREA	 |.pdata|, PDATA
|$T45839| DCD	|$LN14@ValidateTr|
	DCD	0x40007204
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ValidateTransaction| PROC

; 83   : {

  00000		 |$LN14@ValidateTr|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M45836|

; 84   :     DWORD i;
; 85   : 
; 86   :     if (pTrans->mErrorCode)

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e283306c	 add         r3, r3, #0x6C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e3530000	 cmp         r3, #0
  00020	0a000002	 beq         |$LN9@ValidateTr|

; 87   :         return FALSE;

  00024	e3a03000	 mov         r3, #0
  00028	e58d3004	 str         r3, [sp, #4]
  0002c	ea000061	 b           |$LN10@ValidateTr|
  00030		 |$LN9@ValidateTr|

; 88   :     for(i=0;i<I2CTRANS_MAX_STREAMED_TRANSACTIONS;i++)

  00030	e3a03000	 mov         r3, #0
  00034	e58d3000	 str         r3, [sp]
  00038	ea000002	 b           |$LN8@ValidateTr|
  0003c		 |$LN7@ValidateTr|
  0003c	e59d3000	 ldr         r3, [sp]
  00040	e2833001	 add         r3, r3, #1
  00044	e58d3000	 str         r3, [sp]
  00048		 |$LN8@ValidateTr|
  00048	e59d3000	 ldr         r3, [sp]
  0004c	e3530008	 cmp         r3, #8
  00050	2a000056	 bcs         |$LN6@ValidateTr|

; 89   :     {
; 90   :         if (!pTrans->mOpCode[i])

  00054	e59d3010	 ldr         r3, [sp, #0x10]
  00058	e283100c	 add         r1, r3, #0xC
  0005c	e59d2000	 ldr         r2, [sp]
  00060	e3a03004	 mov         r3, #4
  00064	e0030392	 mul         r3, r2, r3
  00068	e0813003	 add         r3, r1, r3
  0006c	e5933000	 ldr         r3, [r3]
  00070	e3530000	 cmp         r3, #0
  00074	1a000000	 bne         |$LN5@ValidateTr|

; 91   :             break;

  00078	ea00004c	 b           |$LN6@ValidateTr|
  0007c		 |$LN5@ValidateTr|

; 92   :         if (((pTrans->mOpCode[i] & I2C_OPCODE_MASK) != I2C_OPCODE_READ) &&
; 93   :             ((pTrans->mOpCode[i] & I2C_OPCODE_MASK) != I2C_OPCODE_WRITE))

  0007c	e59d3010	 ldr         r3, [sp, #0x10]
  00080	e283100c	 add         r1, r3, #0xC
  00084	e59d2000	 ldr         r2, [sp]
  00088	e3a03004	 mov         r3, #4
  0008c	e0030392	 mul         r3, r2, r3
  00090	e0813003	 add         r3, r1, r3
  00094	e5933000	 ldr         r3, [r3]
  00098	e2033003	 and         r3, r3, #3
  0009c	e3530001	 cmp         r3, #1
  000a0	0a000010	 beq         |$LN4@ValidateTr|
  000a4	e59d3010	 ldr         r3, [sp, #0x10]
  000a8	e283100c	 add         r1, r3, #0xC
  000ac	e59d2000	 ldr         r2, [sp]
  000b0	e3a03004	 mov         r3, #4
  000b4	e0030392	 mul         r3, r2, r3
  000b8	e0813003	 add         r3, r1, r3
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e2033003	 and         r3, r3, #3
  000c4	e3530002	 cmp         r3, #2
  000c8	0a000006	 beq         |$LN4@ValidateTr|

; 94   :         {
; 95   :             /* invalid opcode specified */
; 96   :             pTrans->mErrorCode = KERNELI2C_ERR_INVALIDOPCODE;

  000cc	e59d3010	 ldr         r3, [sp, #0x10]
  000d0	e283206c	 add         r2, r3, #0x6C
  000d4	e3e03009	 mvn         r3, #9
  000d8	e5823000	 str         r3, [r2]

; 97   :             return FALSE;

  000dc	e3a03000	 mov         r3, #0
  000e0	e58d3004	 str         r3, [sp, #4]
  000e4	ea000033	 b           |$LN10@ValidateTr|
  000e8		 |$LN4@ValidateTr|

; 98   :         }
; 99   :         if (!pTrans->mTransLen[i])

  000e8	e59d3010	 ldr         r3, [sp, #0x10]
  000ec	e283104c	 add         r1, r3, #0x4C
  000f0	e59d2000	 ldr         r2, [sp]
  000f4	e3a03004	 mov         r3, #4
  000f8	e0030392	 mul         r3, r2, r3
  000fc	e0813003	 add         r3, r1, r3
  00100	e5933000	 ldr         r3, [r3]
  00104	e3530000	 cmp         r3, #0
  00108	1a000006	 bne         |$LN3@ValidateTr|

; 100  :         {
; 101  :             /* transfer length is invalid */
; 102  :             pTrans->mErrorCode = KERNELI2C_ERR_INVALIDOPLENGTH;

  0010c	e59d3010	 ldr         r3, [sp, #0x10]
  00110	e283206c	 add         r2, r3, #0x6C
  00114	e3e03013	 mvn         r3, #0x13
  00118	e5823000	 str         r3, [r2]

; 103  :             return FALSE;

  0011c	e3a03000	 mov         r3, #0
  00120	e58d3004	 str         r3, [sp, #4]
  00124	ea000023	 b           |$LN10@ValidateTr|
  00128		 |$LN3@ValidateTr|

; 104  :         }
; 105  :         if ((pTrans->mBufferOffset[i]>=I2CTRANS_BUFFER_BYTES) ||
; 106  :             (pTrans->mBufferOffset[i]+pTrans->mTransLen[i]>I2CTRANS_BUFFER_BYTES))

  00128	e59d3010	 ldr         r3, [sp, #0x10]
  0012c	e283102c	 add         r1, r3, #0x2C
  00130	e59d2000	 ldr         r2, [sp]
  00134	e3a03004	 mov         r3, #4
  00138	e0030392	 mul         r3, r2, r3
  0013c	e0813003	 add         r3, r1, r3
  00140	e5933000	 ldr         r3, [r3]
  00144	e3530c01	 cmp         r3, #1, 24
  00148	2a000010	 bcs         |$LN1@ValidateTr|
  0014c	e59d3010	 ldr         r3, [sp, #0x10]
  00150	e283102c	 add         r1, r3, #0x2C
  00154	e59d2000	 ldr         r2, [sp]
  00158	e3a03004	 mov         r3, #4
  0015c	e0030392	 mul         r3, r2, r3
  00160	e0810003	 add         r0, r1, r3
  00164	e59d3010	 ldr         r3, [sp, #0x10]
  00168	e283104c	 add         r1, r3, #0x4C
  0016c	e59d2000	 ldr         r2, [sp]
  00170	e3a03004	 mov         r3, #4
  00174	e0030392	 mul         r3, r2, r3
  00178	e0813003	 add         r3, r1, r3
  0017c	e5902000	 ldr         r2, [r0]
  00180	e5933000	 ldr         r3, [r3]
  00184	e0823003	 add         r3, r2, r3
  00188	e3530c01	 cmp         r3, #1, 24
  0018c	9a000006	 bls         |$LN2@ValidateTr|
  00190		 |$LN1@ValidateTr|

; 107  :         {
; 108  :             /* at least part of transfer is outside range of transfer buffer */
; 109  :             pTrans->mErrorCode = KERNELI2C_ERR_OPBUFFERINVALID;

  00190	e59d3010	 ldr         r3, [sp, #0x10]
  00194	e283206c	 add         r2, r3, #0x6C
  00198	e3e0301d	 mvn         r3, #0x1D
  0019c	e5823000	 str         r3, [r2]

; 110  :             return FALSE;

  001a0	e3a03000	 mov         r3, #0
  001a4	e58d3004	 str         r3, [sp, #4]
  001a8	ea000002	 b           |$LN10@ValidateTr|
  001ac		 |$LN2@ValidateTr|

; 111  :         }
; 112  :     }

  001ac	eaffffa2	 b           |$LN7@ValidateTr|
  001b0		 |$LN6@ValidateTr|

; 113  :     return TRUE;

  001b0	e3a03001	 mov         r3, #1
  001b4	e58d3004	 str         r3, [sp, #4]
  001b8		 |$LN10@ValidateTr|

; 114  : }

  001b8	e59d0004	 ldr         r0, [sp, #4]
  001bc	e28dd008	 add         sp, sp, #8
  001c0	e89d6000	 ldmia       sp, {sp, lr}
  001c4	e12fff1e	 bx          lr
  001c8		 |$M45837|

			 ENDP  ; |ValidateTransaction|


  0000c			 AREA	 |.bss|, NOINIT
|gBytesLeft| %	0x4
|gCurI2CaddrSize| % 0x4
|gCurI2Caddr| %	0x4

  00000			 AREA	 |.pdata|, PDATA
|$T45846| DCD	|$LN10@INTSOFF_I2|
	DCD	0x40005004
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |INTSOFF_I2CTRANS_STARTOP| PROC

; 122  : {

  00000		 |$LN10@INTSOFF_I2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M45843|

; 123  :     DWORD regOut;
; 124  :     OMAP2420_I2C_REGS *pChkReg = (OMAP2420_I2C_REGS *)OALPAtoUA(OMAP2420_I2C1_REGS_PA);

  00010	e3a01000	 mov         r1, #0
  00014	e3a00312	 mov         r0, #0x12, 6
  00018	e3800807	 orr         r0, r0, #7, 16
  0001c	eb000000	 bl          OALPAtoVA
  00020	e58d0008	 str         r0, [sp, #8]
  00024	e59d3008	 ldr         r3, [sp, #8]
  00028	e58d3000	 str         r3, [sp]

; 125  : 
; 126  :     /* ensure enabled */
; 127  :     if (!(gpI2CRegs->I2C_CON & I2C_CON_EN))

  0002c	e59f30fc	 ldr         r3, [pc, #0xFC]
  00030	e5933000	 ldr         r3, [r3]
  00034	e2833024	 add         r3, r3, #0x24
  00038	e1d330b0	 ldrh        r3, [r3]
  0003c	e3130902	 tst         r3, #2, 18
  00040	1a000010	 bne         |$LN5@INTSOFF_I2|

; 128  :     {
; 129  :         /* i2c is not enabled. reenable/reset.  must happen here */
; 130  :         gpI2CRegs->I2C_CON = I2C_CON_EN | I2C_CON_MST;

  00044	e59f30e4	 ldr         r3, [pc, #0xE4]
  00048	e5933000	 ldr         r3, [r3]
  0004c	e2832024	 add         r2, r3, #0x24
  00050	e3a03b21	 mov         r3, #0x21, 22
  00054	e1c230b0	 strh        r3, [r2]
  00058		 |$LN4@INTSOFF_I2|

; 131  :         while (!(gpI2CRegs->I2C_SYSS & I2C_SYSS_RDONE));

  00058	e59f30d0	 ldr         r3, [pc, #0xD0]
  0005c	e5933000	 ldr         r3, [r3]
  00060	e2833010	 add         r3, r3, #0x10
  00064	e1d330b0	 ldrh        r3, [r3]
  00068	e3130001	 tst         r3, #1
  0006c	1a000000	 bne         |$LN3@INTSOFF_I2|
  00070	eafffff8	 b           |$LN4@INTSOFF_I2|
  00074		 |$LN3@INTSOFF_I2|

; 132  :         gpI2CRegs->I2C_STAT = 0x3F;

  00074	e59f30b4	 ldr         r3, [pc, #0xB4]
  00078	e5933000	 ldr         r3, [r3]
  0007c	e2832008	 add         r2, r3, #8
  00080	e3a0303f	 mov         r3, #0x3F
  00084	e1c230b0	 strh        r3, [r2]
  00088		 |$LN5@INTSOFF_I2|

; 133  :     }
; 134  : 
; 135  :     /* set slave address */
; 136  :     gpI2CRegs->I2C_SA = (UINT16)gCurI2Caddr;

  00088	e59f30ac	 ldr         r3, [pc, #0xAC]
  0008c	e5933000	 ldr         r3, [r3]
  00090	e1a02803	 mov         r2, r3, lsl #16
  00094	e1a02822	 mov         r2, r2, lsr #16
  00098	e59f3090	 ldr         r3, [pc, #0x90]
  0009c	e5933000	 ldr         r3, [r3]
  000a0	e283302c	 add         r3, r3, #0x2C
  000a4	e1c320b0	 strh        r2, [r3]

; 137  :     regOut = I2C_CON_EN | I2C_CON_MST | I2C_CON_STP | I2C_CON_STT;

  000a8	e3a03b21	 mov         r3, #0x21, 22
  000ac	e3833003	 orr         r3, r3, #3
  000b0	e58d3004	 str         r3, [sp, #4]

; 138  :     if (isWrite)

  000b4	e59d3014	 ldr         r3, [sp, #0x14]
  000b8	e3530000	 cmp         r3, #0
  000bc	0a000002	 beq         |$LN2@INTSOFF_I2|

; 139  :         regOut |= I2C_CON_TRX;

  000c0	e59d3004	 ldr         r3, [sp, #4]
  000c4	e3833c02	 orr         r3, r3, #2, 24
  000c8	e58d3004	 str         r3, [sp, #4]
  000cc		 |$LN2@INTSOFF_I2|

; 140  :     if (gCurI2CaddrSize>7)

  000cc	e59f3064	 ldr         r3, [pc, #0x64]
  000d0	e5933000	 ldr         r3, [r3]
  000d4	e3530007	 cmp         r3, #7
  000d8	9a000002	 bls         |$LN1@INTSOFF_I2|

; 141  :         regOut |= I2C_CON_XA;

  000dc	e59d3004	 ldr         r3, [sp, #4]
  000e0	e3833c01	 orr         r3, r3, #1, 24
  000e4	e58d3004	 str         r3, [sp, #4]
  000e8		 |$LN1@INTSOFF_I2|

; 142  : 
; 143  :     gpI2CRegs->I2C_CNT = (UINT16)gBytesLeft;

  000e8	e59f3044	 ldr         r3, [pc, #0x44]
  000ec	e5933000	 ldr         r3, [r3]
  000f0	e1a02803	 mov         r2, r3, lsl #16
  000f4	e1a02822	 mov         r2, r2, lsr #16
  000f8	e59f3030	 ldr         r3, [pc, #0x30]
  000fc	e5933000	 ldr         r3, [r3]
  00100	e2833018	 add         r3, r3, #0x18
  00104	e1c320b0	 strh        r2, [r3]

; 144  :     gpI2CRegs->I2C_CON = (UINT16)regOut;

  00108	e59d3004	 ldr         r3, [sp, #4]
  0010c	e1a02803	 mov         r2, r3, lsl #16
  00110	e1a02822	 mov         r2, r2, lsr #16
  00114	e59f3014	 ldr         r3, [pc, #0x14]
  00118	e5933000	 ldr         r3, [r3]
  0011c	e2833024	 add         r3, r3, #0x24
  00120	e1c320b0	 strh        r2, [r3]

; 145  : }

  00124	e28dd00c	 add         sp, sp, #0xC
  00128	e89d6000	 ldmia       sp, {sp, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN11@INTSOFF_I2|
  00130		 |$LN12@INTSOFF_I2|
  00130	00000000	 DCD         |gpI2CRegs|
  00134		 |$LN13@INTSOFF_I2|
  00134	00000000	 DCD         |gBytesLeft|
  00138		 |$LN14@INTSOFF_I2|
  00138	00000000	 DCD         |gCurI2CaddrSize|
  0013c		 |$LN15@INTSOFF_I2|
  0013c	00000000	 DCD         |gCurI2Caddr|
  00140		 |$M45844|

			 ENDP  ; |INTSOFF_I2CTRANS_STARTOP|


  00018			 AREA	 |.bss|, NOINIT
|gpData| %	0x4

  00000			 AREA	 |.pdata|, PDATA
|$T45858| DCD	|$LN10@INTSOFF_I2@2|
	DCD	0x40006b02
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |INTSOFF_I2CTRANS_UPDATEREAD| PROC

; 148  : {

  00000		 |$LN10@INTSOFF_I2@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45855|

; 149  :     UINT16 stat;
; 150  :     OMAP2420_I2C_REGS *pChkReg = (OMAP2420_I2C_REGS *)OALPAtoUA(OMAP2420_I2C1_REGS_PA);

  00008	e3a01000	 mov         r1, #0
  0000c	e3a00312	 mov         r0, #0x12, 6
  00010	e3800807	 orr         r0, r0, #7, 16
  00014	eb000000	 bl          OALPAtoVA
  00018	e58d0008	 str         r0, [sp, #8]
  0001c	e59d3008	 ldr         r3, [sp, #8]
  00020	e58d3000	 str         r3, [sp]

; 151  : 
; 152  :     stat = gpI2CRegs->I2C_STAT;

  00024	e59f3174	 ldr         r3, [pc, #0x174]
  00028	e5933000	 ldr         r3, [r3]
  0002c	e2833008	 add         r3, r3, #8
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e1cd30b4	 strh        r3, [sp, #4]

; 153  :     if (!(stat & (I2C_STAT_NACK | I2C_STAT_AL | I2C_STAT_RRDY)))

  00038	e1dd30b4	 ldrh        r3, [sp, #4]
  0003c	e313000b	 tst         r3, #0xB
  00040	1a000000	 bne         |$LN5@INTSOFF_I2@2|

; 154  :         return;

  00044	ea000052	 b           |$LN6@INTSOFF_I2@2|
  00048		 |$LN5@INTSOFF_I2@2|

; 155  : 
; 156  :     /* clear status (except for receive ready) */
; 157  :     gpI2CRegs->I2C_STAT = (I2C_STAT_NACK | I2C_STAT_AL | I2C_STAT_XRDY);

  00048	e59f3150	 ldr         r3, [pc, #0x150]
  0004c	e5933000	 ldr         r3, [r3]
  00050	e2832008	 add         r2, r3, #8
  00054	e3a03013	 mov         r3, #0x13
  00058	e1c230b0	 strh        r3, [r2]

; 158  : 
; 159  :     if (stat & (I2C_STAT_NACK | I2C_STAT_AL))

  0005c	e1dd30b4	 ldrh        r3, [sp, #4]
  00060	e3130003	 tst         r3, #3
  00064	0a00000f	 beq         |$LN4@INTSOFF_I2@2|

; 160  :     {
; 161  :         /* error.  if it's a nack we need to reset the controller */
; 162  :         if (stat & I2C_STAT_NACK)

  00068	e1dd30b4	 ldrh        r3, [sp, #4]
  0006c	e3130002	 tst         r3, #2
  00070	0a000009	 beq         |$LN3@INTSOFF_I2@2|

; 163  :         {
; 164  :             gpI2CRegs->I2C_SYSC = (UINT16)I2C_SYSC_SRST;

  00074	e59f3124	 ldr         r3, [pc, #0x124]
  00078	e5933000	 ldr         r3, [r3]
  0007c	e2832020	 add         r2, r3, #0x20
  00080	e3a03002	 mov         r3, #2
  00084	e1c230b0	 strh        r3, [r2]

; 165  :             gpI2CRegs->I2C_CON = 0;

  00088	e59f3110	 ldr         r3, [pc, #0x110]
  0008c	e5933000	 ldr         r3, [r3]
  00090	e2832024	 add         r2, r3, #0x24
  00094	e3a03000	 mov         r3, #0
  00098	e1c230b0	 strh        r3, [r2]
  0009c		 |$LN3@INTSOFF_I2@2|

; 166  :         }
; 167  : 
; 168  :         /* restart the operation with what is left */
; 169  :         INTSOFF_I2CTRANS_STARTOP(FALSE);

  0009c	e3a00000	 mov         r0, #0
  000a0	eb000000	 bl          INTSOFF_I2CTRANS_STARTOP

; 170  :         return;

  000a4	ea00003a	 b           |$LN6@INTSOFF_I2@2|
  000a8		 |$LN4@INTSOFF_I2@2|

; 171  :     }
; 172  : 
; 173  :     /* received character came in ok (stat & I2C_STAT_RRDY) */
; 174  :     if (gBytesLeft > 1)

  000a8	e59f30f4	 ldr         r3, [pc, #0xF4]
  000ac	e5933000	 ldr         r3, [r3]
  000b0	e3530001	 cmp         r3, #1
  000b4	9a000021	 bls         |$LN2@INTSOFF_I2@2|

; 175  :     {
; 176  :         stat = gpI2CRegs->I2C_DATA;

  000b8	e59f30e0	 ldr         r3, [pc, #0xE0]
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e283301c	 add         r3, r3, #0x1C
  000c4	e1d330b0	 ldrh        r3, [r3]
  000c8	e1cd30b4	 strh        r3, [sp, #4]

; 177  :         *(gpData++) = (UCHAR)(stat & 0xFF);

  000cc	e1dd30b4	 ldrh        r3, [sp, #4]
  000d0	e20330ff	 and         r3, r3, #0xFF
  000d4	e20320ff	 and         r2, r3, #0xFF
  000d8	e59f30c8	 ldr         r3, [pc, #0xC8]
  000dc	e5933000	 ldr         r3, [r3]
  000e0	e5c32000	 strb        r2, [r3]
  000e4	e59f30bc	 ldr         r3, [pc, #0xBC]
  000e8	e5933000	 ldr         r3, [r3]
  000ec	e2832001	 add         r2, r3, #1
  000f0	e59f30b0	 ldr         r3, [pc, #0xB0]
  000f4	e5832000	 str         r2, [r3]

; 178  :         *(gpData++) = (UCHAR)((stat & 0xFF00)>>8);

  000f8	e1dd30b4	 ldrh        r3, [sp, #4]
  000fc	e2033cff	 and         r3, r3, #0xFF, 24
  00100	e1a03443	 mov         r3, r3, asr #8
  00104	e20320ff	 and         r2, r3, #0xFF
  00108	e59f3098	 ldr         r3, [pc, #0x98]
  0010c	e5933000	 ldr         r3, [r3]
  00110	e5c32000	 strb        r2, [r3]
  00114	e59f308c	 ldr         r3, [pc, #0x8C]
  00118	e5933000	 ldr         r3, [r3]
  0011c	e2832001	 add         r2, r3, #1
  00120	e59f3080	 ldr         r3, [pc, #0x80]
  00124	e5832000	 str         r2, [r3]

; 179  :         gBytesLeft -= 2;

  00128	e59f3074	 ldr         r3, [pc, #0x74]
  0012c	e5933000	 ldr         r3, [r3]
  00130	e2432002	 sub         r2, r3, #2
  00134	e59f3068	 ldr         r3, [pc, #0x68]
  00138	e5832000	 str         r2, [r3]

; 180  :     }
; 181  :     else

  0013c	ea00000f	 b           |$LN1@INTSOFF_I2@2|
  00140		 |$LN2@INTSOFF_I2@2|

; 182  :     {
; 183  :         *(gpData++) = (UCHAR)gpI2CRegs->I2C_DATA;

  00140	e59f3058	 ldr         r3, [pc, #0x58]
  00144	e5933000	 ldr         r3, [r3]
  00148	e283301c	 add         r3, r3, #0x1C
  0014c	e1d330b0	 ldrh        r3, [r3]
  00150	e20320ff	 and         r2, r3, #0xFF
  00154	e59f304c	 ldr         r3, [pc, #0x4C]
  00158	e5933000	 ldr         r3, [r3]
  0015c	e5c32000	 strb        r2, [r3]
  00160	e59f3040	 ldr         r3, [pc, #0x40]
  00164	e5933000	 ldr         r3, [r3]
  00168	e2832001	 add         r2, r3, #1
  0016c	e59f3034	 ldr         r3, [pc, #0x34]
  00170	e5832000	 str         r2, [r3]

; 184  :         gBytesLeft = 0;

  00174	e59f2028	 ldr         r2, [pc, #0x28]
  00178	e3a03000	 mov         r3, #0
  0017c	e5823000	 str         r3, [r2]
  00180		 |$LN1@INTSOFF_I2@2|

; 185  :     }
; 186  : 
; 187  :     /* clear receive status so next char can come in */
; 188  :     gpI2CRegs->I2C_STAT = I2C_STAT_RRDY;

  00180	e59f3018	 ldr         r3, [pc, #0x18]
  00184	e5933000	 ldr         r3, [r3]
  00188	e2832008	 add         r2, r3, #8
  0018c	e3a03008	 mov         r3, #8
  00190	e1c230b0	 strh        r3, [r2]
  00194		 |$LN6@INTSOFF_I2@2|

; 189  : }

  00194	e28dd00c	 add         sp, sp, #0xC
  00198	e49de004	 ldr         lr, [sp], #4
  0019c	e12fff1e	 bx          lr
  001a0		 |$LN11@INTSOFF_I2@2|
  001a0		 |$LN12@INTSOFF_I2@2|
  001a0	00000000	 DCD         |gpI2CRegs|
  001a4		 |$LN13@INTSOFF_I2@2|
  001a4	00000000	 DCD         |gBytesLeft|
  001a8		 |$LN14@INTSOFF_I2@2|
  001a8	00000000	 DCD         |gpData|
  001ac		 |$M45856|

			 ENDP  ; |INTSOFF_I2CTRANS_UPDATEREAD|


  00000			 AREA	 |.pdata|, PDATA
|$T45869| DCD	|$LN10@INTSOFF_I2@3|
	DCD	0x40006a02
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |INTSOFF_I2CTRANS_UPDATEWRITE| PROC

; 192  : {

  00000		 |$LN10@INTSOFF_I2@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45866|

; 193  :     OMAP2420_I2C_REGS *pChkReg = (OMAP2420_I2C_REGS *)OALPAtoUA(OMAP2420_I2C1_REGS_PA);

  00008	e3a01000	 mov         r1, #0
  0000c	e3a00312	 mov         r0, #0x12, 6
  00010	e3800807	 orr         r0, r0, #7, 16
  00014	eb000000	 bl          OALPAtoVA
  00018	e58d0008	 str         r0, [sp, #8]
  0001c	e59d3008	 ldr         r3, [sp, #8]
  00020	e58d3000	 str         r3, [sp]

; 194  :     UINT16 stat = gpI2CRegs->I2C_STAT;

  00024	e59f3170	 ldr         r3, [pc, #0x170]
  00028	e5933000	 ldr         r3, [r3]
  0002c	e2833008	 add         r3, r3, #8
  00030	e1d330b0	 ldrh        r3, [r3]
  00034	e1cd30b4	 strh        r3, [sp, #4]

; 195  :     if (!(stat & (I2C_STAT_NACK | I2C_STAT_AL | I2C_STAT_XRDY)))

  00038	e1dd30b4	 ldrh        r3, [sp, #4]
  0003c	e3130013	 tst         r3, #0x13
  00040	1a000000	 bne         |$LN5@INTSOFF_I2@3|

; 196  :         return;

  00044	ea000051	 b           |$LN6@INTSOFF_I2@3|
  00048		 |$LN5@INTSOFF_I2@3|

; 197  : 
; 198  :     /* clear status (except for transmit ready) */
; 199  :     gpI2CRegs->I2C_STAT = (I2C_STAT_NACK | I2C_STAT_AL | I2C_STAT_RRDY);

  00048	e59f314c	 ldr         r3, [pc, #0x14C]
  0004c	e5933000	 ldr         r3, [r3]
  00050	e2832008	 add         r2, r3, #8
  00054	e3a0300b	 mov         r3, #0xB
  00058	e1c230b0	 strh        r3, [r2]

; 200  : 
; 201  :     if (stat & (I2C_STAT_NACK | I2C_STAT_AL))

  0005c	e1dd30b4	 ldrh        r3, [sp, #4]
  00060	e3130003	 tst         r3, #3
  00064	0a00000f	 beq         |$LN4@INTSOFF_I2@3|

; 202  :     {
; 203  :         /* error.  if it's a nack we need to reset the controller */
; 204  :         if (stat & I2C_STAT_NACK)

  00068	e1dd30b4	 ldrh        r3, [sp, #4]
  0006c	e3130002	 tst         r3, #2
  00070	0a000009	 beq         |$LN3@INTSOFF_I2@3|

; 205  :         {
; 206  :             gpI2CRegs->I2C_SYSC = I2C_SYSC_SRST;

  00074	e59f3120	 ldr         r3, [pc, #0x120]
  00078	e5933000	 ldr         r3, [r3]
  0007c	e2832020	 add         r2, r3, #0x20
  00080	e3a03002	 mov         r3, #2
  00084	e1c230b0	 strh        r3, [r2]

; 207  :             gpI2CRegs->I2C_CON = 0;

  00088	e59f310c	 ldr         r3, [pc, #0x10C]
  0008c	e5933000	 ldr         r3, [r3]
  00090	e2832024	 add         r2, r3, #0x24
  00094	e3a03000	 mov         r3, #0
  00098	e1c230b0	 strh        r3, [r2]
  0009c		 |$LN3@INTSOFF_I2@3|

; 208  :         }
; 209  : 
; 210  :         /* restart the operation with what is left */
; 211  :         INTSOFF_I2CTRANS_STARTOP(FALSE);

  0009c	e3a00000	 mov         r0, #0
  000a0	eb000000	 bl          INTSOFF_I2CTRANS_STARTOP

; 212  :         return;

  000a4	ea000039	 b           |$LN6@INTSOFF_I2@3|
  000a8		 |$LN4@INTSOFF_I2@3|

; 213  :     }
; 214  : 
; 215  :     /* ready for transmit. load register then issue xmit */
; 216  :     if (gBytesLeft > 1)

  000a8	e59f30f0	 ldr         r3, [pc, #0xF0]
  000ac	e5933000	 ldr         r3, [r3]
  000b0	e3530001	 cmp         r3, #1
  000b4	9a000021	 bls         |$LN2@INTSOFF_I2@3|

; 217  :     {
; 218  :         stat = (USHORT)(*(gpData++));

  000b8	e59f30e4	 ldr         r3, [pc, #0xE4]
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e5d33000	 ldrb        r3, [r3]
  000c4	e1cd30b4	 strh        r3, [sp, #4]
  000c8	e59f30d4	 ldr         r3, [pc, #0xD4]
  000cc	e5933000	 ldr         r3, [r3]
  000d0	e2832001	 add         r2, r3, #1
  000d4	e59f30c8	 ldr         r3, [pc, #0xC8]
  000d8	e5832000	 str         r2, [r3]

; 219  :         stat |= ((USHORT)(*(gpData++)))<<8;

  000dc	e59f30c0	 ldr         r3, [pc, #0xC0]
  000e0	e5933000	 ldr         r3, [r3]
  000e4	e5d33000	 ldrb        r3, [r3]
  000e8	e1a02403	 mov         r2, r3, lsl #8
  000ec	e1dd30b4	 ldrh        r3, [sp, #4]
  000f0	e1833002	 orr         r3, r3, r2
  000f4	e1a03803	 mov         r3, r3, lsl #16
  000f8	e1a03823	 mov         r3, r3, lsr #16
  000fc	e1cd30b4	 strh        r3, [sp, #4]
  00100	e59f309c	 ldr         r3, [pc, #0x9C]
  00104	e5933000	 ldr         r3, [r3]
  00108	e2832001	 add         r2, r3, #1
  0010c	e59f3090	 ldr         r3, [pc, #0x90]
  00110	e5832000	 str         r2, [r3]

; 220  :         gpI2CRegs->I2C_DATA = stat;

  00114	e59f3080	 ldr         r3, [pc, #0x80]
  00118	e5933000	 ldr         r3, [r3]
  0011c	e283201c	 add         r2, r3, #0x1C
  00120	e1dd30b4	 ldrh        r3, [sp, #4]
  00124	e1c230b0	 strh        r3, [r2]

; 221  :         gBytesLeft -= 2;

  00128	e59f3070	 ldr         r3, [pc, #0x70]
  0012c	e5933000	 ldr         r3, [r3]
  00130	e2432002	 sub         r2, r3, #2
  00134	e59f3064	 ldr         r3, [pc, #0x64]
  00138	e5832000	 str         r2, [r3]

; 222  :     }
; 223  :     else

  0013c	ea00000e	 b           |$LN1@INTSOFF_I2@3|
  00140		 |$LN2@INTSOFF_I2@3|

; 224  :     {
; 225  :         gpI2CRegs->I2C_DATA = *(gpData++);

  00140	e59f3054	 ldr         r3, [pc, #0x54]
  00144	e5933000	 ldr         r3, [r3]
  00148	e283201c	 add         r2, r3, #0x1C
  0014c	e59f3050	 ldr         r3, [pc, #0x50]
  00150	e5933000	 ldr         r3, [r3]
  00154	e5d33000	 ldrb        r3, [r3]
  00158	e1c230b0	 strh        r3, [r2]
  0015c	e59f3040	 ldr         r3, [pc, #0x40]
  00160	e5933000	 ldr         r3, [r3]
  00164	e2832001	 add         r2, r3, #1
  00168	e59f3034	 ldr         r3, [pc, #0x34]
  0016c	e5832000	 str         r2, [r3]

; 226  :         gBytesLeft = 0;

  00170	e59f2028	 ldr         r2, [pc, #0x28]
  00174	e3a03000	 mov         r3, #0
  00178	e5823000	 str         r3, [r2]
  0017c		 |$LN1@INTSOFF_I2@3|

; 227  :     }
; 228  : 
; 229  :     /* clear transmit status so next char can go out */
; 230  :     gpI2CRegs->I2C_STAT = I2C_STAT_XRDY;

  0017c	e59f3018	 ldr         r3, [pc, #0x18]
  00180	e5933000	 ldr         r3, [r3]
  00184	e2832008	 add         r2, r3, #8
  00188	e3a03010	 mov         r3, #0x10
  0018c	e1c230b0	 strh        r3, [r2]
  00190		 |$LN6@INTSOFF_I2@3|

; 231  : }

  00190	e28dd00c	 add         sp, sp, #0xC
  00194	e49de004	 ldr         lr, [sp], #4
  00198	e12fff1e	 bx          lr
  0019c		 |$LN11@INTSOFF_I2@3|
  0019c		 |$LN12@INTSOFF_I2@3|
  0019c	00000000	 DCD         |gpI2CRegs|
  001a0		 |$LN13@INTSOFF_I2@3|
  001a0	00000000	 DCD         |gBytesLeft|
  001a4		 |$LN14@INTSOFF_I2@3|
  001a4	00000000	 DCD         |gpData|
  001a8		 |$M45867|

			 ENDP  ; |INTSOFF_I2CTRANS_UPDATEWRITE|

	EXPORT	|??_C@_1DC@FKIPCFIC@?$AA?$CK?$AA?$CK?$AA?$CK?$AAE?$AAR?$AAR?$AA?3?$AA?5?$AAI?$AA2?$AAC?$AA?9?$AAB?$AAU?$AAS?$AA?5?$AAA?$AAB?$AAO?$AAR?$AAT?$AA?4?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|OALGetTickCount|

  0001c			 AREA	 |.bss|, NOINIT
|gTimeOutTick| % 0x4

  00000			 AREA	 |.pdata|, PDATA
|$T45882| DCD	|$LN35@ResumeTran|
	DCD	0x40013304

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@FKIPCFIC@?$AA?$CK?$AA?$CK?$AA?$CK?$AAE?$AAR?$AAR?$AA?3?$AA?5?$AAI?$AA2?$AAC?$AA?9?$AAB?$AAU?$AAS?$AA?5?$AAA?$AAB?$AAO?$AAR?$AAT?$AA?4?$AA?$AN?$AA?6?$AA?$AA@| DCB "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "E", 0x0, "R", 0x0, "R", 0x0, ":"
	DCB	0x0, " ", 0x0, "I", 0x0, "2", 0x0, "C", 0x0, "-", 0x0, "B"
	DCB	0x0, "U", 0x0, "S", 0x0, " ", 0x0, "A", 0x0, "B", 0x0, "O"
	DCB	0x0, "R", 0x0, "T", 0x0, ".", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ResumeTrans| PROC

; 244  : {

  00000		 |$LN35@ResumeTran|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M45879|
  00010		 |$LN28@ResumeTran|

; 245  :     DWORD op;
; 246  : 
; 247  :     /* wait for bus not to be busy (finish any outstanding requests) */
; 248  :     while (gpI2CRegs->I2C_STAT & I2C_STAT_BB);

  00010	e59f34a4	 ldr         r3, [pc, #0x4A4]
  00014	e5933000	 ldr         r3, [r3]
  00018	e2833008	 add         r3, r3, #8
  0001c	e1d330b0	 ldrh        r3, [r3]
  00020	e3130a01	 tst         r3, #1, 20
  00024	0a000000	 beq         |$LN27@ResumeTran|
  00028	eafffff8	 b           |$LN28@ResumeTran|
  0002c		 |$LN27@ResumeTran|
  0002c		 |$LN26@ResumeTran|

; 249  : 
; 250  :     /* pTrans is the currently executing transfer and bus activity for it needs to be
; 251  :        completed before another transfer can be done.  the target bus address is in
; 252  :        gCurI2Caddr,gCurI2Csize */
; 253  : 
; 254  :     do {
; 255  :         if (!pTrans->mOpCode[pTrans->mReserved1])

  0002c	e59d301c	 ldr         r3, [sp, #0x1C]
  00030	e283100c	 add         r1, r3, #0xC
  00034	e59d301c	 ldr         r3, [sp, #0x1C]
  00038	e5932000	 ldr         r2, [r3]
  0003c	e3a03004	 mov         r3, #4
  00040	e0030392	 mul         r3, r2, r3
  00044	e0813003	 add         r3, r1, r3
  00048	e5933000	 ldr         r3, [r3]
  0004c	e3530000	 cmp         r3, #0
  00050	1a000000	 bne         |$LN23@ResumeTran|

; 256  :             break;

  00054	ea000112	 b           |$LN24@ResumeTran|
  00058		 |$LN23@ResumeTran|

; 257  :         /* POINT A --------------------------*/
; 258  : 
; 259  :         op = pTrans->mOpCode[pTrans->mReserved1];

  00058	e59d301c	 ldr         r3, [sp, #0x1C]
  0005c	e283100c	 add         r1, r3, #0xC
  00060	e59d301c	 ldr         r3, [sp, #0x1C]
  00064	e5932000	 ldr         r2, [r3]
  00068	e3a03004	 mov         r3, #4
  0006c	e0030392	 mul         r3, r2, r3
  00070	e0813003	 add         r3, r1, r3
  00074	e5933000	 ldr         r3, [r3]
  00078	e58d3000	 str         r3, [sp]

; 260  :         /* if the high priority came in between point a and point b, then pTrans->mReserved1
; 261  :            will be invalid, but pTrans->mReserved2 will be set to I2CSTATE_OPDONE here, and 
; 262  :            all that will happen is a break (default) */
; 263  :         switch(pTrans->mReserved2)

  0007c	e59d301c	 ldr         r3, [sp, #0x1C]
  00080	e2833004	 add         r3, r3, #4
  00084	e5933000	 ldr         r3, [r3]
  00088	e58d3004	 str         r3, [sp, #4]
  0008c	e59d3004	 ldr         r3, [sp, #4]
  00090	e3530000	 cmp         r3, #0
  00094	0a000009	 beq         |$LN20@ResumeTran|
  00098	e59d3004	 ldr         r3, [sp, #4]
  0009c	e3530001	 cmp         r3, #1
  000a0	0a000047	 beq         |$LN16@ResumeTran|
  000a4	e59d3004	 ldr         r3, [sp, #4]
  000a8	e3530002	 cmp         r3, #2
  000ac	0a00006b	 beq         |$LN15@ResumeTran|
  000b0	e59d3004	 ldr         r3, [sp, #4]
  000b4	e3530003	 cmp         r3, #3
  000b8	0a00007d	 beq         |$LN11@ResumeTran|
  000bc	ea0000ee	 b           |$LN1@ResumeTran|
  000c0		 |$LN20@ResumeTran|

; 264  :         {
; 265  :         case I2CSTATE_CLKSETUP:
; 266  :             /* turn on the module functional clock */
; 267  :             gpPRCMRegs->ulCM_FCLKEN1_CORE |= PRCM_FCLKEN1_CORE_EN_I2C1;

  000c0	e59f33e8	 ldr         r3, [pc, #0x3E8]
  000c4	e5933000	 ldr         r3, [r3]
  000c8	e2833c02	 add         r3, r3, #2, 24
  000cc	e5933000	 ldr         r3, [r3]
  000d0	e3832702	 orr         r2, r3, #2, 14
  000d4	e59f33d4	 ldr         r3, [pc, #0x3D4]
  000d8	e5933000	 ldr         r3, [r3]
  000dc	e2833c02	 add         r3, r3, #2, 24
  000e0	e5832000	 str         r2, [r3]

; 268  :             gpPRCMRegs->ulCM_ICLKEN1_CORE |= PRCM_ICLKEN1_CORE_EN_I2C1;

  000e4	e59f33c4	 ldr         r3, [pc, #0x3C4]
  000e8	e5933000	 ldr         r3, [r3]
  000ec	e2833e21	 add         r3, r3, #0x21, 28
  000f0	e5933000	 ldr         r3, [r3]
  000f4	e3832702	 orr         r2, r3, #2, 14
  000f8	e59f33b0	 ldr         r3, [pc, #0x3B0]
  000fc	e5933000	 ldr         r3, [r3]
  00100	e2833e21	 add         r3, r3, #0x21, 28
  00104	e5832000	 str         r2, [r3]

; 269  :             /* check current clock setting of i2c and make sure it matches pTrans */
; 270  :             if (pTrans->mClk_HL_Divisor!=gCurClockDivisor)

  00108	e59d301c	 ldr         r3, [sp, #0x1C]
  0010c	e2833008	 add         r3, r3, #8
  00110	e5932000	 ldr         r2, [r3]
  00114	e59f33ac	 ldr         r3, [pc, #0x3AC]
  00118	e5933000	 ldr         r3, [r3]
  0011c	e1520003	 cmp         r2, r3
  00120	0a000022	 beq         |$LN19@ResumeTran|

; 271  :             {
; 272  :                 if (!pTrans->mClk_HL_Divisor)

  00124	e59d301c	 ldr         r3, [sp, #0x1C]
  00128	e2833008	 add         r3, r3, #8
  0012c	e5933000	 ldr         r3, [r3]
  00130	e3530000	 cmp         r3, #0
  00134	1a000003	 bne         |$LN18@ResumeTran|

; 273  :                     gCurClockDivisor = I2C_CLOCK_DEFAULT;

  00138	e59f2388	 ldr         r2, [pc, #0x388]
  0013c	e3a0300f	 mov         r3, #0xF
  00140	e5823000	 str         r3, [r2]

; 274  :                 else

  00144	ea000004	 b           |$LN17@ResumeTran|
  00148		 |$LN18@ResumeTran|

; 275  :                     gCurClockDivisor = pTrans->mClk_HL_Divisor;            

  00148	e59d301c	 ldr         r3, [sp, #0x1C]
  0014c	e2833008	 add         r3, r3, #8
  00150	e5932000	 ldr         r2, [r3]
  00154	e59f336c	 ldr         r3, [pc, #0x36C]
  00158	e5832000	 str         r2, [r3]
  0015c		 |$LN17@ResumeTran|

; 276  :                 gpI2CRegs->I2C_PSC = 0;

  0015c	e59f3358	 ldr         r3, [pc, #0x358]
  00160	e5933000	 ldr         r3, [r3]
  00164	e2832030	 add         r2, r3, #0x30
  00168	e3a03000	 mov         r3, #0
  0016c	e1c230b0	 strh        r3, [r2]

; 277  :                 gpI2CRegs->I2C_SCLL = (UINT16)gCurClockDivisor;

  00170	e59f3350	 ldr         r3, [pc, #0x350]
  00174	e5933000	 ldr         r3, [r3]
  00178	e1a02803	 mov         r2, r3, lsl #16
  0017c	e1a02822	 mov         r2, r2, lsr #16
  00180	e59f3334	 ldr         r3, [pc, #0x334]
  00184	e5933000	 ldr         r3, [r3]
  00188	e2833034	 add         r3, r3, #0x34
  0018c	e1c320b0	 strh        r2, [r3]

; 278  :                 gpI2CRegs->I2C_SCLH = (UINT16)gCurClockDivisor;

  00190	e59f3330	 ldr         r3, [pc, #0x330]
  00194	e5933000	 ldr         r3, [r3]
  00198	e1a02803	 mov         r2, r3, lsl #16
  0019c	e1a02822	 mov         r2, r2, lsr #16
  001a0	e59f3314	 ldr         r3, [pc, #0x314]
  001a4	e5933000	 ldr         r3, [r3]
  001a8	e2833038	 add         r3, r3, #0x38
  001ac	e1c320b0	 strh        r2, [r3]
  001b0		 |$LN19@ResumeTran|

; 279  :             }
; 280  :             pTrans->mReserved2 = I2CSTATE_OPSTART;

  001b0	e59d301c	 ldr         r3, [sp, #0x1C]
  001b4	e2832004	 add         r2, r3, #4
  001b8	e3a03001	 mov         r3, #1
  001bc	e5823000	 str         r3, [r2]

; 281  :             break;

  001c0	ea0000ad	 b           |$LN21@ResumeTran|
  001c4		 |$LN16@ResumeTran|

; 282  :         case I2CSTATE_OPSTART:
; 283  :             gBytesLeft = pTrans->mTransLen[pTrans->mReserved1];

  001c4	e59d301c	 ldr         r3, [sp, #0x1C]
  001c8	e283104c	 add         r1, r3, #0x4C
  001cc	e59d301c	 ldr         r3, [sp, #0x1C]
  001d0	e5932000	 ldr         r2, [r3]
  001d4	e3a03004	 mov         r3, #4
  001d8	e0030392	 mul         r3, r2, r3
  001dc	e0813003	 add         r3, r1, r3
  001e0	e5932000	 ldr         r2, [r3]
  001e4	e59f32d4	 ldr         r3, [pc, #0x2D4]
  001e8	e5832000	 str         r2, [r3]

; 284  :             gpData = &pTrans->mBuffer[pTrans->mBufferOffset[pTrans->mReserved1]];

  001ec	e59d301c	 ldr         r3, [sp, #0x1C]
  001f0	e2830070	 add         r0, r3, #0x70
  001f4	e59d301c	 ldr         r3, [sp, #0x1C]
  001f8	e283102c	 add         r1, r3, #0x2C
  001fc	e59d301c	 ldr         r3, [sp, #0x1C]
  00200	e5932000	 ldr         r2, [r3]
  00204	e3a03004	 mov         r3, #4
  00208	e0030392	 mul         r3, r2, r3
  0020c	e0813003	 add         r3, r1, r3
  00210	e5933000	 ldr         r3, [r3]
  00214	e0802003	 add         r2, r0, r3
  00218	e59f32a4	 ldr         r3, [pc, #0x2A4]
  0021c	e5832000	 str         r2, [r3]

; 285  :             INTSOFF_I2CTRANS_STARTOP(((op & I2C_OPCODE_MASK)==I2C_OPCODE_WRITE)?TRUE:FALSE);

  00220	e59d3000	 ldr         r3, [sp]
  00224	e2033003	 and         r3, r3, #3
  00228	e3530002	 cmp         r3, #2
  0022c	1a000002	 bne         |$LN31@ResumeTran|
  00230	e3a03001	 mov         r3, #1
  00234	e58d3008	 str         r3, [sp, #8]
  00238	ea000001	 b           |$LN32@ResumeTran|
  0023c		 |$LN31@ResumeTran|
  0023c	e3a03000	 mov         r3, #0
  00240	e58d3008	 str         r3, [sp, #8]
  00244		 |$LN32@ResumeTran|
  00244	e59d0008	 ldr         r0, [sp, #8]
  00248	eb000000	 bl          INTSOFF_I2CTRANS_STARTOP

; 286  :             pTrans->mReserved2 = I2CSTATE_OPUPDATE;

  0024c	e59d301c	 ldr         r3, [sp, #0x1C]
  00250	e2832004	 add         r2, r3, #4
  00254	e3a03002	 mov         r3, #2
  00258	e5823000	 str         r3, [r2]

; 287  :             break;

  0025c	ea000086	 b           |$LN21@ResumeTran|
  00260		 |$LN15@ResumeTran|

; 288  :         case I2CSTATE_OPUPDATE:
; 289  :             if ((op & I2C_OPCODE_MASK)==I2C_OPCODE_READ)

  00260	e59d3000	 ldr         r3, [sp]
  00264	e2033003	 and         r3, r3, #3
  00268	e3530001	 cmp         r3, #1
  0026c	1a000001	 bne         |$LN14@ResumeTran|

; 290  :                 INTSOFF_I2CTRANS_UPDATEREAD();

  00270	eb000000	 bl          INTSOFF_I2CTRANS_UPDATEREAD

; 291  :             else

  00274	ea000000	 b           |$LN13@ResumeTran|
  00278		 |$LN14@ResumeTran|

; 292  :                 INTSOFF_I2CTRANS_UPDATEWRITE();

  00278	eb000000	 bl          INTSOFF_I2CTRANS_UPDATEWRITE
  0027c		 |$LN13@ResumeTran|

; 293  :             if (!gBytesLeft)

  0027c	e59f323c	 ldr         r3, [pc, #0x23C]
  00280	e5933000	 ldr         r3, [r3]
  00284	e3530000	 cmp         r3, #0
  00288	1a000008	 bne         |$LN12@ResumeTran|

; 294  :             {
; 295  :                 pTrans->mReserved2 = I2CSTATE_OPEND;

  0028c	e59d301c	 ldr         r3, [sp, #0x1C]
  00290	e2832004	 add         r2, r3, #4
  00294	e3a03003	 mov         r3, #3
  00298	e5823000	 str         r3, [r2]

; 296  :                 gTimeOutTick = OALGetTickCount();

  0029c	eb000000	 bl          OALGetTickCount
  002a0	e58d000c	 str         r0, [sp, #0xC]
  002a4	e59d200c	 ldr         r2, [sp, #0xC]
  002a8	e59f3208	 ldr         r3, [pc, #0x208]
  002ac	e5832000	 str         r2, [r3]
  002b0		 |$LN12@ResumeTran|

; 297  :             }
; 298  :             break;

  002b0	ea000071	 b           |$LN21@ResumeTran|
  002b4		 |$LN11@ResumeTran|

; 299  :         case I2CSTATE_OPEND:
; 300  :             if (!(gpI2CRegs->I2C_STAT & I2C_STAT_BB))

  002b4	e59f3200	 ldr         r3, [pc, #0x200]
  002b8	e5933000	 ldr         r3, [r3]
  002bc	e2833008	 add         r3, r3, #8
  002c0	e1d330b0	 ldrh        r3, [r3]
  002c4	e3130a01	 tst         r3, #1, 20
  002c8	1a000030	 bne         |$LN10@ResumeTran|

; 301  :             {
; 302  :                 /* bus is no longer  busy (transaction completed) */
; 303  :                 pTrans->mReserved1++;

  002cc	e59d301c	 ldr         r3, [sp, #0x1C]
  002d0	e5933000	 ldr         r3, [r3]
  002d4	e2832001	 add         r2, r3, #1
  002d8	e59d301c	 ldr         r3, [sp, #0x1C]
  002dc	e5832000	 str         r2, [r3]

; 304  :                 if ((pTrans->mReserved1==I2CTRANS_MAX_STREAMED_TRANSACTIONS) || 
; 305  :                     (!pTrans->mOpCode[pTrans->mReserved1]))

  002e0	e59d301c	 ldr         r3, [sp, #0x1C]
  002e4	e5933000	 ldr         r3, [r3]
  002e8	e3530008	 cmp         r3, #8
  002ec	0a000009	 beq         |$LN8@ResumeTran|
  002f0	e59d301c	 ldr         r3, [sp, #0x1C]
  002f4	e283100c	 add         r1, r3, #0xC
  002f8	e59d301c	 ldr         r3, [sp, #0x1C]
  002fc	e5932000	 ldr         r2, [r3]
  00300	e3a03004	 mov         r3, #4
  00304	e0030392	 mul         r3, r2, r3
  00308	e0813003	 add         r3, r1, r3
  0030c	e5933000	 ldr         r3, [r3]
  00310	e3530000	 cmp         r3, #0
  00314	1a000018	 bne         |$LN9@ResumeTran|
  00318		 |$LN8@ResumeTran|

; 306  :                 {
; 307  :                     /* end of this op.  turn off the module functional clocks */
; 308  :                     gpPRCMRegs->ulCM_FCLKEN1_CORE &= ~PRCM_FCLKEN1_CORE_EN_I2C1;

  00318	e59f3190	 ldr         r3, [pc, #0x190]
  0031c	e5933000	 ldr         r3, [r3]
  00320	e2833c02	 add         r3, r3, #2, 24
  00324	e5932000	 ldr         r2, [r3]
  00328	e3e03702	 mvn         r3, #2, 14
  0032c	e0022003	 and         r2, r2, r3
  00330	e59f3178	 ldr         r3, [pc, #0x178]
  00334	e5933000	 ldr         r3, [r3]
  00338	e2833c02	 add         r3, r3, #2, 24
  0033c	e5832000	 str         r2, [r3]

; 309  :                     gpPRCMRegs->ulCM_ICLKEN1_CORE &= ~PRCM_ICLKEN1_CORE_EN_I2C1;

  00340	e59f3168	 ldr         r3, [pc, #0x168]
  00344	e5933000	 ldr         r3, [r3]
  00348	e2833e21	 add         r3, r3, #0x21, 28
  0034c	e5932000	 ldr         r2, [r3]
  00350	e3e03702	 mvn         r3, #2, 14
  00354	e0022003	 and         r2, r2, r3
  00358	e59f3150	 ldr         r3, [pc, #0x150]
  0035c	e5933000	 ldr         r3, [r3]
  00360	e2833e21	 add         r3, r3, #0x21, 28
  00364	e5832000	 str         r2, [r3]

; 310  :                     pTrans->mReserved2 = I2CSTATE_OPDONE;

  00368	e59d301c	 ldr         r3, [sp, #0x1C]
  0036c	e2832004	 add         r2, r3, #4
  00370	e3a03004	 mov         r3, #4
  00374	e5823000	 str         r3, [r2]

; 311  :                 }
; 312  :                 else

  00378	ea000003	 b           |$LN7@ResumeTran|
  0037c		 |$LN9@ResumeTran|

; 313  :                     pTrans->mReserved2 = I2CSTATE_OPSTART;

  0037c	e59d301c	 ldr         r3, [sp, #0x1C]
  00380	e2832004	 add         r2, r3, #4
  00384	e3a03001	 mov         r3, #1
  00388	e5823000	 str         r3, [r2]
  0038c		 |$LN7@ResumeTran|

; 314  :             }
; 315  :             else if ((OALGetTickCount()-gTimeOutTick)>I2C_OPEND_TIMEOUT)

  0038c	ea00003a	 b           |$LN6@ResumeTran|
  00390		 |$LN10@ResumeTran|
  00390	eb000000	 bl          OALGetTickCount
  00394	e58d0010	 str         r0, [sp, #0x10]
  00398	e59d2010	 ldr         r2, [sp, #0x10]
  0039c	e59f3114	 ldr         r3, [pc, #0x114]
  003a0	e5933000	 ldr         r3, [r3]
  003a4	e0423003	 sub         r3, r2, r3
  003a8	e35300fa	 cmp         r3, #0xFA
  003ac	9a000032	 bls         |$LN5@ResumeTran|

; 316  :             {
; 317  :                 /* abort */
; 318  :                 OALMSG(1, (TEXT("***ERR: I2C-BUS ABORT.\r\n")));

  003b0	e59f00fc	 ldr         r0, [pc, #0xFC]
  003b4	eb000000	 bl          NKDbgPrintfW
  003b8		 |$LN4@ResumeTran|

; 319  :                 while (pTrans->mOpCode[pTrans->mReserved1])

  003b8	e59d301c	 ldr         r3, [sp, #0x1C]
  003bc	e283100c	 add         r1, r3, #0xC
  003c0	e59d301c	 ldr         r3, [sp, #0x1C]
  003c4	e5932000	 ldr         r2, [r3]
  003c8	e3a03004	 mov         r3, #4
  003cc	e0030392	 mul         r3, r2, r3
  003d0	e0813003	 add         r3, r1, r3
  003d4	e5933000	 ldr         r3, [r3]
  003d8	e3530000	 cmp         r3, #0
  003dc	0a00000a	 beq         |$LN3@ResumeTran|

; 320  :                 {
; 321  :                     pTrans->mReserved1++;

  003e0	e59d301c	 ldr         r3, [sp, #0x1C]
  003e4	e5933000	 ldr         r3, [r3]
  003e8	e2832001	 add         r2, r3, #1
  003ec	e59d301c	 ldr         r3, [sp, #0x1C]
  003f0	e5832000	 str         r2, [r3]

; 322  :                     if (pTrans->mReserved1==I2CTRANS_MAX_STREAMED_TRANSACTIONS)

  003f4	e59d301c	 ldr         r3, [sp, #0x1C]
  003f8	e5933000	 ldr         r3, [r3]
  003fc	e3530008	 cmp         r3, #8
  00400	1a000000	 bne         |$LN2@ResumeTran|

; 323  :                         break;

  00404	ea000000	 b           |$LN3@ResumeTran|
  00408		 |$LN2@ResumeTran|

; 324  :                 }

  00408	eaffffea	 b           |$LN4@ResumeTran|
  0040c		 |$LN3@ResumeTran|

; 325  :                 /* aborted this op.  turn off the module functional clocks */
; 326  :                 gpPRCMRegs->ulCM_FCLKEN1_CORE &= ~PRCM_FCLKEN1_CORE_EN_I2C1;

  0040c	e59f309c	 ldr         r3, [pc, #0x9C]
  00410	e5933000	 ldr         r3, [r3]
  00414	e2833c02	 add         r3, r3, #2, 24
  00418	e5932000	 ldr         r2, [r3]
  0041c	e3e03702	 mvn         r3, #2, 14
  00420	e0022003	 and         r2, r2, r3
  00424	e59f3084	 ldr         r3, [pc, #0x84]
  00428	e5933000	 ldr         r3, [r3]
  0042c	e2833c02	 add         r3, r3, #2, 24
  00430	e5832000	 str         r2, [r3]

; 327  :                 gpPRCMRegs->ulCM_ICLKEN1_CORE &= ~PRCM_ICLKEN1_CORE_EN_I2C1;

  00434	e59f3074	 ldr         r3, [pc, #0x74]
  00438	e5933000	 ldr         r3, [r3]
  0043c	e2833e21	 add         r3, r3, #0x21, 28
  00440	e5932000	 ldr         r2, [r3]
  00444	e3e03702	 mvn         r3, #2, 14
  00448	e0022003	 and         r2, r2, r3
  0044c	e59f305c	 ldr         r3, [pc, #0x5C]
  00450	e5933000	 ldr         r3, [r3]
  00454	e2833e21	 add         r3, r3, #0x21, 28
  00458	e5832000	 str         r2, [r3]

; 328  :                 pTrans->mReserved2 = I2CSTATE_OPDONE;

  0045c	e59d301c	 ldr         r3, [sp, #0x1C]
  00460	e2832004	 add         r2, r3, #4
  00464	e3a03004	 mov         r3, #4
  00468	e5823000	 str         r3, [r2]

; 329  :                 pTrans->mErrorCode = (DWORD)-2;

  0046c	e59d301c	 ldr         r3, [sp, #0x1C]
  00470	e283206c	 add         r2, r3, #0x6C
  00474	e3e03001	 mvn         r3, #1
  00478	e5823000	 str         r3, [r2]
  0047c		 |$LN5@ResumeTran|
  0047c		 |$LN6@ResumeTran|
  0047c		 |$LN1@ResumeTran|
  0047c		 |$LN21@ResumeTran|

; 330  :             }
; 331  :             break;
; 332  :         default:
; 333  :             break;
; 334  :         }
; 335  : 
; 336  :     } while (pTrans->mOpCode[pTrans->mReserved1]);

  0047c	e59d301c	 ldr         r3, [sp, #0x1C]
  00480	e283100c	 add         r1, r3, #0xC
  00484	e59d301c	 ldr         r3, [sp, #0x1C]
  00488	e5932000	 ldr         r2, [r3]
  0048c	e3a03004	 mov         r3, #4
  00490	e0030392	 mul         r3, r2, r3
  00494	e0813003	 add         r3, r1, r3
  00498	e5933000	 ldr         r3, [r3]
  0049c	e3530000	 cmp         r3, #0
  004a0	1afffee1	 bne         |$LN26@ResumeTran|
  004a4		 |$LN24@ResumeTran|

; 337  : }

  004a4	e28dd014	 add         sp, sp, #0x14
  004a8	e89d6000	 ldmia       sp, {sp, lr}
  004ac	e12fff1e	 bx          lr
  004b0		 |$LN36@ResumeTran|
  004b0		 |$LN37@ResumeTran|
  004b0	00000000	 DCD         |gpPRCMRegs|
  004b4		 |$LN38@ResumeTran|
  004b4	00000000	 DCD         |??_C@_1DC@FKIPCFIC@?$AA?$CK?$AA?$CK?$AA?$CK?$AAE?$AAR?$AAR?$AA?3?$AA?5?$AAI?$AA2?$AAC?$AA?9?$AAB?$AAU?$AAS?$AA?5?$AAA?$AAB?$AAO?$AAR?$AAT?$AA?4?$AA?$AN?$AA?6?$AA?$AA@|
  004b8		 |$LN39@ResumeTran|
  004b8	00000000	 DCD         |gTimeOutTick|
  004bc		 |$LN40@ResumeTran|
  004bc	00000000	 DCD         |gpI2CRegs|
  004c0		 |$LN41@ResumeTran|
  004c0	00000000	 DCD         |gBytesLeft|
  004c4		 |$LN42@ResumeTran|
  004c4	00000000	 DCD         |gpData|
  004c8		 |$LN43@ResumeTran|
  004c8	00000000	 DCD         |gCurClockDivisor|
  004cc		 |$M45880|

			 ENDP  ; |ResumeTrans|

	EXPORT	|KERNELI2C_NonPreemptibleSubmit|

  00000			 AREA	 |.pdata|, PDATA
|$T45897| DCD	|$LN15@KERNELI2C_@3|
	DCD	0x40005e04
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KERNELI2C_NonPreemptibleSubmit| PROC

; 341  : {

  00000		 |$LN15@KERNELI2C_@3|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M45894|

; 342  :     BOOL saveInts;
; 343  : 
; 344  :     /* always validate the i2c transaction first */
; 345  :     pTrans->mErrorCode = 0;

  00010	e59d301c	 ldr         r3, [sp, #0x1C]
  00014	e283206c	 add         r2, r3, #0x6C
  00018	e3a03000	 mov         r3, #0
  0001c	e5823000	 str         r3, [r2]

; 346  :     if (!ValidateTransaction(pTrans))

  00020	e59d001c	 ldr         r0, [sp, #0x1C]
  00024	eb000000	 bl          ValidateTransaction
  00028	e58d0004	 str         r0, [sp, #4]
  0002c	e59d3004	 ldr         r3, [sp, #4]
  00030	e3530000	 cmp         r3, #0
  00034	1a000000	 bne         |$LN10@KERNELI2C_@3|

; 347  :         return;

  00038	ea000048	 b           |$LN11@KERNELI2C_@3|
  0003c		 |$LN10@KERNELI2C_@3|

; 348  :     if (((addrSize!=7) && (addrSize!=10)) || (!i2cAddr))

  0003c	e59d3018	 ldr         r3, [sp, #0x18]
  00040	e3530007	 cmp         r3, #7
  00044	0a000002	 beq         |$LN7@KERNELI2C_@3|
  00048	e59d3018	 ldr         r3, [sp, #0x18]
  0004c	e353000a	 cmp         r3, #0xA
  00050	1a000002	 bne         |$LN8@KERNELI2C_@3|
  00054		 |$LN7@KERNELI2C_@3|
  00054	e59d3014	 ldr         r3, [sp, #0x14]
  00058	e3530000	 cmp         r3, #0
  0005c	1a00000d	 bne         |$LN9@KERNELI2C_@3|
  00060		 |$LN8@KERNELI2C_@3|

; 349  :     {
; 350  :         if ((i2cAddr) && (!addrSize))

  00060	e59d3014	 ldr         r3, [sp, #0x14]
  00064	e3530000	 cmp         r3, #0
  00068	0a000005	 beq         |$LN6@KERNELI2C_@3|
  0006c	e59d3018	 ldr         r3, [sp, #0x18]
  00070	e3530000	 cmp         r3, #0
  00074	1a000002	 bne         |$LN6@KERNELI2C_@3|

; 351  :             addrSize = 7;

  00078	e3a03007	 mov         r3, #7
  0007c	e58d3018	 str         r3, [sp, #0x18]

; 352  :         else

  00080	ea000004	 b           |$LN5@KERNELI2C_@3|
  00084		 |$LN6@KERNELI2C_@3|

; 353  :         {
; 354  :             /* invalid address or address size */
; 355  :             pTrans->mErrorCode = KERNELI2C_ERR_INVALIDADDR;

  00084	e59d301c	 ldr         r3, [sp, #0x1C]
  00088	e283206c	 add         r2, r3, #0x6C
  0008c	e3e03027	 mvn         r3, #0x27
  00090	e5823000	 str         r3, [r2]

; 356  :             return;

  00094	ea000031	 b           |$LN11@KERNELI2C_@3|
  00098		 |$LN5@KERNELI2C_@3|
  00098		 |$LN9@KERNELI2C_@3|

; 357  :         }
; 358  :     }
; 359  : 
; 360  :     /* set current operation index and state for that operation */
; 361  :     pTrans->mReserved1 = 0;

  00098	e59d201c	 ldr         r2, [sp, #0x1C]
  0009c	e3a03000	 mov         r3, #0
  000a0	e5823000	 str         r3, [r2]

; 362  :     pTrans->mReserved2 = I2CSTATE_CLKSETUP;

  000a4	e59d301c	 ldr         r3, [sp, #0x1C]
  000a8	e2832004	 add         r2, r3, #4
  000ac	e3a03000	 mov         r3, #0
  000b0	e5823000	 str         r3, [r2]

; 363  : 
; 364  :     if (!inISR)

  000b4	e59d3010	 ldr         r3, [sp, #0x10]
  000b8	e3530000	 cmp         r3, #0
  000bc	1a00000c	 bne         |$LN4@KERNELI2C_@3|

; 365  :     {
; 366  :         /* latch in the lower priority transaction now */
; 367  :         saveInts = INTERRUPTS_ENABLE(FALSE);

  000c0	e3a03000	 mov         r3, #0
  000c4	e58d3000	 str         r3, [sp]

; 368  :         gCurI2Caddr = i2cAddr;

  000c8	e59d2014	 ldr         r2, [sp, #0x14]
  000cc	e59f309c	 ldr         r3, [pc, #0x9C]
  000d0	e5832000	 str         r2, [r3]

; 369  :         gCurI2CaddrSize = addrSize;

  000d4	e59d2018	 ldr         r2, [sp, #0x18]
  000d8	e59f308c	 ldr         r3, [pc, #0x8C]
  000dc	e5832000	 str         r2, [r3]

; 370  :         gpLowTrans = pTrans;

  000e0	e59d201c	 ldr         r2, [sp, #0x1C]
  000e4	e59f3088	 ldr         r3, [pc, #0x88]
  000e8	e5832000	 str         r2, [r3]

; 371  :         INTERRUPTS_ENABLE(saveInts);
; 372  :         pTrans = NULL;

  000ec	e3a03000	 mov         r3, #0
  000f0	e58d301c	 str         r3, [sp, #0x1C]
  000f4		 |$LN4@KERNELI2C_@3|

; 373  :     }
; 374  :     else
; 375  :     {
; 376  :         OALMSG(0/*1*/, (TEXT("ki2c-NONPREEMPT()\r\n")));
; 377  :     }
; 378  : 
; 379  :     /* work on gpLowTrans until it is done - if we're executing in an isr then
; 380  :        that transaction is currently in progress and we need to finish it first */
; 381  :     if (gpLowTrans)

  000f4	e59f3078	 ldr         r3, [pc, #0x78]
  000f8	e5933000	 ldr         r3, [r3]
  000fc	e3530000	 cmp         r3, #0
  00100	0a000005	 beq         |$LN2@KERNELI2C_@3|

; 382  :     {
; 383  :         ResumeTrans(gpLowTrans);

  00104	e59f3068	 ldr         r3, [pc, #0x68]
  00108	e5930000	 ldr         r0, [r3]
  0010c	eb000000	 bl          ResumeTrans

; 384  :         gpLowTrans = NULL;

  00110	e59f205c	 ldr         r2, [pc, #0x5C]
  00114	e3a03000	 mov         r3, #0
  00118	e5823000	 str         r3, [r2]
  0011c		 |$LN2@KERNELI2C_@3|

; 385  :     }
; 386  : 
; 387  :     /* if pTrans is not NULL, do that one now - its the isr transaction */
; 388  :     if (pTrans)

  0011c	e59d301c	 ldr         r3, [sp, #0x1C]
  00120	e3530000	 cmp         r3, #0
  00124	0a00000d	 beq         |$LN1@KERNELI2C_@3|

; 389  :     {
; 390  :         gCurI2Caddr = i2cAddr;

  00128	e59d2014	 ldr         r2, [sp, #0x14]
  0012c	e59f303c	 ldr         r3, [pc, #0x3C]
  00130	e5832000	 str         r2, [r3]

; 391  :         gCurI2CaddrSize = addrSize;

  00134	e59d2018	 ldr         r2, [sp, #0x18]
  00138	e59f302c	 ldr         r3, [pc, #0x2C]
  0013c	e5832000	 str         r2, [r3]

; 392  :         ResumeTrans(pTrans);

  00140	e59d001c	 ldr         r0, [sp, #0x1C]
  00144	eb000000	 bl          ResumeTrans

; 393  :         gCurI2Caddr = 0;

  00148	e59f2020	 ldr         r2, [pc, #0x20]
  0014c	e3a03000	 mov         r3, #0
  00150	e5823000	 str         r3, [r2]

; 394  :         gCurI2CaddrSize = 0;

  00154	e59f2010	 ldr         r2, [pc, #0x10]
  00158	e3a03000	 mov         r3, #0
  0015c	e5823000	 str         r3, [r2]
  00160		 |$LN1@KERNELI2C_@3|
  00160		 |$LN11@KERNELI2C_@3|

; 395  :     }
; 396  : }

  00160	e28dd008	 add         sp, sp, #8
  00164	e89d6000	 ldmia       sp, {sp, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$LN16@KERNELI2C_@3|
  0016c		 |$LN17@KERNELI2C_@3|
  0016c	00000000	 DCD         |gCurI2CaddrSize|
  00170		 |$LN18@KERNELI2C_@3|
  00170	00000000	 DCD         |gCurI2Caddr|
  00174		 |$LN19@KERNELI2C_@3|
  00174	00000000	 DCD         |gpLowTrans|
  00178		 |$M45895|

			 ENDP  ; |KERNELI2C_NonPreemptibleSubmit|

	EXPORT	|KERNELI2C_PreemptibleSubmit|

  00000			 AREA	 |.pdata|, PDATA
|$T45908| DCD	|$LN5@KERNELI2C_@4|
	DCD	0x40000a03
; Function compile flags: /Odsp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KERNELI2C_PreemptibleSubmit| PROC

; 399  : {

  00000		 |$LN5@KERNELI2C_@4|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M45905|

; 400  :     /* this is for KERNEL calls that need to use I2C while they are preemptible */
; 401  :     /* DRIVERS should use the I2C driver to make calls */
; 402  : #ifndef BOOTLOADER
; 403  :     EnterCriticalSection(&gSec);
; 404  : #endif
; 405  :     KERNELI2C_NonPreemptibleSubmit(FALSE, i2cAddr, addrSize, pTrans);

  0000c	e59d3010	 ldr         r3, [sp, #0x10]
  00010	e59d200c	 ldr         r2, [sp, #0xC]
  00014	e59d1008	 ldr         r1, [sp, #8]
  00018	e3a00000	 mov         r0, #0
  0001c	eb000000	 bl          KERNELI2C_NonPreemptibleSubmit

; 406  : #ifndef BOOTLOADER
; 407  :     LeaveCriticalSection(&gSec);
; 408  : #endif
; 409  : }

  00020	e89d6000	 ldmia       sp, {sp, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M45906|

			 ENDP  ; |KERNELI2C_PreemptibleSubmit|

	END
