; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\OAL\TIMER\TIMER32K\timer.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
	 COMMON	|g_oalTimer|, 0x28


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALTimerIntrHandler|
	IMPORT	|OEMWriteDebugLED|
	IMPORT	|g_pNKGlobal|

  00000			 AREA	 |.bss|, NOINIT
|g_pTimerRegs| % 0x4
|g_pTimerRegs| % 0x4
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\oal\timer\timer32k\timer.c

  00000			 AREA	 |.pdata|, PDATA
|$T45688| DCD	|$LN6@OALTimerIn|
	DCD	0x40002a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerIntrHandler| PROC

; 169  : {

  00000		 |$LN6@OALTimerIn|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45685|

; 170  :     UINT32 sysIntr = SYSINTR_NOP;
; 171  : 
; 172  : #ifdef OAL_ILTIMING
; 173  :     if (g_oalILT.active) {
; 174  :             g_oalILT.isrTime1 = OALTimerCountsSinceSysTick();
; 175  :     }        
; 176  : #endif
; 177  : 
; 178  :     //Acknowledge the current timer interrupt and 
; 179  :     //clear the status for next timer interrupt
; 180  :     SETREG32(&g_pTimerRegs->TISR,0x2);

  00004	e59f3098	 ldr         r3, [pc, #0x98]

; 181  : 
; 182  :     // Update the millisecond and high resolution counters
; 183  :     g_oalTimer.curCounts += g_oalTimer.actualCountsPerSysTick;

  00008	e59fe090	 ldr         lr, [pc, #0x90]

; 184  :     CurMSec = (UINT32)((g_oalTimer.curCounts*1000)>>15);

  0000c	e3a08ffa	 mov         r8, #0xFA, 30
  00010	e5932000	 ldr         r2, [r3]
  00014	e59f5080	 ldr         r5, [pc, #0x80]
  00018	e3a07ffa	 mov         r7, #0xFA, 30
  0001c	e5923018	 ldr         r3, [r2, #0x18]

; 185  : 
; 186  :     // Update LED display (bits 0&1)
; 187  :     OALLED(LED_IDX_TIMERSPIN, CurMSec >> 10);

  00020	e3a00000	 mov         r0, #0
  00024	e3a06000	 mov         r6, #0
  00028	e3833002	 orr         r3, r3, #2
  0002c	e5823018	 str         r3, [r2, #0x18]
  00030	e59e1020	 ldr         r1, [lr, #0x20]
  00034	e59e3018	 ldr         r3, [lr, #0x18]
  00038	e59e2024	 ldr         r2, [lr, #0x24]
  0003c	e5954000	 ldr         r4, [r5]
  00040	e0913003	 adds        r3, r1, r3
  00044	e2a22000	 adc         r2, r2, #0
  00048	e58e3020	 str         r3, [lr, #0x20]
  0004c	e58e2024	 str         r2, [lr, #0x24]
  00050	e59e2020	 ldr         r2, [lr, #0x20]
  00054	e59e1024	 ldr         r1, [lr, #0x24]
  00058	e083e892	 umull       lr, r3, r2, r8
  0005c	e0233791	 mla         r3, r1, r7, r3
  00060	e1a03883	 mov         r3, r3, lsl #17
  00064	e18337ae	 orr         r3, r3, lr, lsr #15
  00068	e58430c8	 str         r3, [r4, #0xC8]
  0006c	e5953000	 ldr         r3, [r5]
  00070	e59330c8	 ldr         r3, [r3, #0xC8]
  00074	e1a01523	 mov         r1, r3, lsr #10
  00078	eb000000	 bl          OEMWriteDebugLED

; 188  :       
; 189  :     // Reschedule?
; 190  :     if ((int)(CurMSec - dwReschedTime) >= 0) sysIntr = SYSINTR_RESCHED;

  0007c	e5953000	 ldr         r3, [r5]
  00080	e59320c8	 ldr         r2, [r3, #0xC8]
  00084	e59330c4	 ldr         r3, [r3, #0xC4]
  00088	e0523003	 subs        r3, r2, r3
  0008c	53a06001	 movpl       r6, #1

; 191  : 
; 192  : #ifdef OAL_ILTIMING
; 193  :     if (g_oalILT.active) {
; 194  :         if (--g_oalILT.counter == 0) {
; 195  :             sysIntr = SYSINTR_TIMING;
; 196  :             g_oalILT.counter = g_oalILT.counterSet;
; 197  :             g_oalILT.isrTime2 = OALTimerCountsSinceSysTick();
; 198  :         }
; 199  :     }
; 200  : #endif
; 201  :     // Done    
; 202  :     return sysIntr;
; 203  : }

  00090	e1a00006	 mov         r0, r6
  00094	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN7@OALTimerIn|
  0009c		 |$LN8@OALTimerIn|
  0009c	00000000	 DCD         |g_pNKGlobal|
  000a0		 |$LN9@OALTimerIn|
  000a0	00000000	 DCD         |g_oalTimer|
  000a4		 |$LN10@OALTimerIn|
  000a4	00000000	 DCD         |g_pTimerRegs|
  000a8		 |$M45686|

			 ENDP  ; |OALTimerIntrHandler|

	EXPORT	|OALTimerCountsSinceSysTick|

  00000			 AREA	 |.pdata|, PDATA
|$T45701| DCD	|$LN5@OALTimerCo|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerCountsSinceSysTick| PROC

; 212  : {

  00000		 |$LN5@OALTimerCo|
  00000		 |$M45698|

; 213  :     // Calc value.
; 214  :     return (INREG32(&g_pTimerRegs->TCRR) - INREG32(&g_pTimerRegs->TLDR));

  00000	e59f3010	 ldr         r3, [pc, #0x10]
  00004	e5933000	 ldr         r3, [r3]
  00008	e593202c	 ldr         r2, [r3, #0x2C]
  0000c	e5933028	 ldr         r3, [r3, #0x28]
  00010	e0430002	 sub         r0, r3, r2

; 215  : }

  00014	e12fff1e	 bx          lr
  00018		 |$LN6@OALTimerCo|
  00018		 |$LN7@OALTimerCo|
  00018	00000000	 DCD         |g_pTimerRegs|
  0001c		 |$M45699|

			 ENDP  ; |OALTimerCountsSinceSysTick|

	EXPORT	|OEMIdle|

  00000			 AREA	 |.pdata|, PDATA
|$T45710| DCD	|$LN5@OEMIdle|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMIdle| PROC

; 224  : {

  00000		 |$LN5@OEMIdle|
  00000		 |$M45707|

; 225  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45708|

			 ENDP  ; |OEMIdle|

	EXPORT	|OEMGetTickCount|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T45727| DCD	|$LN13@OEMGetTick|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMGetTickCount| PROC

; 237  : {

  00000		 |$LN13@OEMGetTick|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45724|

; 238  :     UINT32 count;
; 239  :     INT32 offset;
; 240  : 
; 241  :     if (g_oalTimer.actualMSecPerSysTick == 1) {

  00004	e59f1060	 ldr         r1, [pc, #0x60]
  00008	e5913014	 ldr         r3, [r1, #0x14]
  0000c	e3530001	 cmp         r3, #1

; 242  :         // Return CurMSec if the system tick is 1 ms.
; 243  :         count = CurMSec;

  00010	059f304c	 ldreq       r3, [pc, #0x4C]
  00014	05933000	 ldreq       r3, [r3]
  00018	059300c8	 ldreq       r0, [r3, #0xC8]

; 261  :     }
; 262  : 
; 263  :     return count;
; 264  : }

  0001c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00020	012fff1e	 bxeq        lr

; 244  :     }  else {

  00024	e59f303c	 ldr         r3, [pc, #0x3C]
  00028	e59f2034	 ldr         r2, [pc, #0x34]
  0002c	e5930000	 ldr         r0, [r3]
  00030	e5925000	 ldr         r5, [r2]
  00034		 |$LL3@OEMGetTick|

; 245  :         // System timer tick period exceeds 1 ms. 
; 246  :         //
; 247  :         // This code adjusts the accuracy of the returned value to the nearest
; 248  :         // MSec when the system tick exceeds 1 ms. The following code checks if 
; 249  :         // a system timer interrupt occurred between reading the CurMSec value 
; 250  :         // and the call to fetch the HiResTicksSinceSysTick. If so, the value of
; 251  :         // CurMSec and Offset is re-read, with the certainty that a system timer
; 252  :         // interrupt will not occur again.
; 253  :         do {
; 254  :             count = CurMSec;

  00034	e59540c8	 ldr         r4, [r5, #0xC8]

; 255  :             offset = OALTimerCountsSinceSysTick();

  00038	e590202c	 ldr         r2, [r0, #0x2C]
  0003c	e590e028	 ldr         lr, [r0, #0x28]

; 256  :         } 
; 257  :         while (count != CurMSec);

  00040	e59530c8	 ldr         r3, [r5, #0xC8]
  00044	e1540003	 cmp         r4, r3
  00048	1afffff9	 bne         |$LL3@OEMGetTick|

; 258  : 
; 259  :         // Adjust the MSec value with the contribution from HiRes counter.
; 260  :         count += offset/g_oalTimer.countsPerMSec;

  0004c	e5910000	 ldr         r0, [r1]
  00050	e04e1002	 sub         r1, lr, r2
  00054	eb000000	 bl          __rt_udiv
  00058	e0840000	 add         r0, r4, r0

; 261  :     }
; 262  : 
; 263  :     return count;
; 264  : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN14@OEMGetTick|
  00064		 |$LN15@OEMGetTick|
  00064	00000000	 DCD         |g_pNKGlobal|
  00068		 |$LN16@OEMGetTick|
  00068	00000000	 DCD         |g_pTimerRegs|
  0006c		 |$LN17@OEMGetTick|
  0006c	00000000	 DCD         |g_oalTimer|
  00070		 |$M45725|

			 ENDP  ; |OEMGetTickCount|

	EXPORT	|OALTimerQueryPerformanceFrequency|

  00000			 AREA	 |.pdata|, PDATA
|$T45741| DCD	|$LN6@OALTimerQu|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerQueryPerformanceFrequency| PROC

; 276  : {

  00000		 |$LN6@OALTimerQu|
  00000		 |$M45738|
  00000	e3500000	 cmp         r0, #0

; 277  :     if (!pFrequency) return FALSE;

  00004	03a00000	 moveq       r0, #0

; 278  : 
; 279  :     pFrequency->HighPart = 0;

  00008	13a03000	 movne       r3, #0

; 280  :     pFrequency->LowPart = 32768; // 32k timer frequency

  0000c	13a02902	 movne       r2, #2, 18
  00010	1880000c	 stmneia     r0, {r2, r3}

; 281  :     return TRUE;

  00014	13a00001	 movne       r0, #1

; 282  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M45739|

			 ENDP  ; |OALTimerQueryPerformanceFrequency|

	EXPORT	|OALTimerQueryPerformanceCounter|

  00000			 AREA	 |.pdata|, PDATA
|$T45758| DCD	|$LN12@OALTimerQu@2|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerQueryPerformanceCounter| PROC

; 293  : {

  00000		 |$LN12@OALTimerQu@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45755|
  00004	e3500000	 cmp         r0, #0

; 294  :     UINT64 base;
; 295  :     INT32 offset;
; 296  : 
; 297  :     if (!pCounter) return FALSE;

  00008	03a00000	 moveq       r0, #0

; 313  : }

  0000c	08bd40f0	 ldmeqia     sp!, {r4 - r7, lr}
  00010	012fff1e	 bxeq        lr

; 294  :     UINT64 base;
; 295  :     INT32 offset;
; 296  : 
; 297  :     if (!pCounter) return FALSE;

  00014	e59f304c	 ldr         r3, [pc, #0x4C]
  00018	e59f4044	 ldr         r4, [pc, #0x44]
  0001c	e5935000	 ldr         r5, [r3]
  00020		 |$LL3@OALTimerQu@2|

; 298  :  
; 299  :     // Make sure CurTicks is the same before and after read of counter
; 300  :     // to avoid for possible rollover. Note that this is probably not necessary
; 301  :     // because TimerTicksSinceBeat will return negative value when it happen.
; 302  :     // We must be careful about signed/unsigned arithmetic.
; 303  :     
; 304  :     do {
; 305  :        base = g_oalTimer.curCounts;

  00020	e5946020	 ldr         r6, [r4, #0x20]
  00024	e594e024	 ldr         lr, [r4, #0x24]

; 306  :        offset = OALTimerCountsSinceSysTick();

  00028	e5951028	 ldr         r1, [r5, #0x28]
  0002c	e595302c	 ldr         r3, [r5, #0x2C]

; 307  :     } while (base != g_oalTimer.curCounts);

  00030	e5942020	 ldr         r2, [r4, #0x20]
  00034	e5947024	 ldr         r7, [r4, #0x24]
  00038	e0413003	 sub         r3, r1, r3
  0003c	e1560002	 cmp         r6, r2
  00040	1afffff6	 bne         |$LL3@OALTimerQu@2|
  00044	e15e0007	 cmp         lr, r7
  00048	1afffff4	 bne         |$LL3@OALTimerQu@2|

; 308  : 
; 309  :     // Update the counter
; 310  :     pCounter->QuadPart = (ULONGLONG)((INT64)base + offset);

  0004c	e0932006	 adds        r2, r3, r6
  00050	e0ae3fc3	 adc         r3, lr, r3, asr #31
  00054	e880000c	 stmia       r0, {r2, r3}

; 311  : 
; 312  :     return TRUE;

  00058	e3a00001	 mov         r0, #1

; 313  : }

  0005c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN13@OALTimerQu@2|
  00064		 |$LN14@OALTimerQu@2|
  00064	00000000	 DCD         |g_oalTimer|
  00068		 |$LN15@OALTimerQu@2|
  00068	00000000	 DCD         |g_pTimerRegs|
  0006c		 |$M45756|

			 ENDP  ; |OALTimerQueryPerformanceCounter|

	EXPORT	|OALTimerInit|
	EXPORT	|??_C@_1DG@MBLBIFGK@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?4?$AA?4?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OEMInterruptEnable|
	IMPORT	|OALPAtoVA|
	IMPORT	|OALIntrRequestSysIntr|
	IMPORT	|g_pOemGlobal|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|
	IMPORT	|g_oalTimerIrq|

  00008			 AREA	 |.bss|, NOINIT
|g_pPRCMRegs| %	0x4

  00000			 AREA	 |.pdata|, PDATA
|$T45781| DCD	|$LN13@OALTimerIn@2|
	DCD	0x40007f01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DG@MBLBIFGK@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?4?$AA?4?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ".", 0x0, ".", 0x0, "(", 0x0, "r", 0x0, "c", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, " "
	DCB	0x0, "e", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "s"
	DCB	0x0, "y", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, " "
	DCB	0x0, "t", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerInit| PROC

; 61   : ) {

  00000		 |$LN13@OALTimerIn@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45778|
  00004	e1a05000	 mov         r5, r0

; 62   :     BOOL rc = FALSE;
; 63   :     UINT32 sysIntr;
; 64   : 
; 65   :     OALMSG(OAL_TIMER&&OAL_FUNC, (
; 66   :         L"+OALTimerInit(%d, %d, %d)\r\n", msecPerSysTick, countsPerMSec,
; 67   :         countsMargin
; 68   :     ));

  00008	e59f71e8	 ldr         r7, [pc, #0x1E8]
  0000c	e3a08000	 mov         r8, #0
  00010	e5973440	 ldr         r3, [r7, #0x440]
  00014	e3130b02	 tst         r3, #2, 22
  00018	13130004	 tstne       r3, #4
  0001c	159f01d0	 ldrne       r0, [pc, #0x1D0]
  00020	11a03002	 movne       r3, r2
  00024	11a02001	 movne       r2, r1
  00028	11a01005	 movne       r1, r5
  0002c	1b000000	 blne        NKDbgPrintfW

; 69   : 
; 70   :     // Initialize high resolution timer function pointers
; 71   :     pQueryPerformanceFrequency = OALTimerQueryPerformanceFrequency;

  00030	e59f11b8	 ldr         r1, [pc, #0x1B8]
  00034	e59f21b0	 ldr         r2, [pc, #0x1B0]

; 72   :     pQueryPerformanceCounter   = OALTimerQueryPerformanceCounter;

  00038	e59fe1a8	 ldr         lr, [pc, #0x1A8]
  0003c	e5913000	 ldr         r3, [r1]

; 73   : 
; 74   :     // Ignore two last passed arguments 
; 75   :     countsPerMSec = OMAP2420_GPTIMER1_COUNTS_PER_1MS;
; 76   :     countsMargin = 2;
; 77   :     
; 78   :     // 32 bit counter
; 79   :     g_oalTimer.maxPeriodMSec = 0xFFFFFFFF/countsPerMSec;

  00040	e59f919c	 ldr         r9, [pc, #0x19C]
  00044	e3e0033e	 mvn         r0, #0x3E, 6
  00048	e5832034	 str         r2, [r3, #0x34]
  0004c	e5913000	 ldr         r3, [r1]

; 80   : 
; 81   :     // System tick period must be smaller than counter maximal period.
; 82   :     // This reduction will be usual when variable tick is used.
; 83   :     if (msecPerSysTick > g_oalTimer.maxPeriodMSec) {

  00050	e375037e	 cmn         r5, #0x7E, 6

; 84   :         msecPerSysTick = g_oalTimer.maxPeriodMSec;
; 85   :     }
; 86   : 
; 87   :     // Initialize timer state structure
; 88   :     g_oalTimer.countsPerMSec = countsPerMSec;
; 89   :     g_oalTimer.countsMargin = countsMargin;
; 90   :     g_oalTimer.msecPerSysTick = msecPerSysTick;
; 91   :     g_oalTimer.countsPerSysTick = g_oalTimer.countsPerMSec * msecPerSysTick;
; 92   :     g_oalTimer.actualMSecPerSysTick = g_oalTimer.msecPerSysTick;
; 93   :     g_oalTimer.actualCountsPerSysTick = g_oalTimer.countsPerSysTick;
; 94   : 
; 95   :     // Set kernel exported globals to initial values
; 96   :     idleconv = 2;

  00054	e59f4184	 ldr         r4, [pc, #0x184]
  00058	e583e030	 str         lr, [r3, #0x30]
  0005c	e3a03020	 mov         r3, #0x20
  00060	e5890008	 str         r0, [r9, #8]
  00064	e5893000	 str         r3, [r9]
  00068	e3a03002	 mov         r3, #2
  0006c	81a05000	 movhi       r5, r0
  00070	e5893004	 str         r3, [r9, #4]
  00074	e1a03285	 mov         r3, r5, lsl #5
  00078	e5942000	 ldr         r2, [r4]
  0007c	e589500c	 str         r5, [r9, #0xC]
  00080	e5893010	 str         r3, [r9, #0x10]
  00084	e5895014	 str         r5, [r9, #0x14]
  00088	e5893018	 str         r3, [r9, #0x18]
  0008c	e3a03002	 mov         r3, #2
  00090	e58230d8	 str         r3, [r2, #0xD8]

; 97   :     curridlelow = 0;

  00094	e5943000	 ldr         r3, [r4]
  00098	e3a0b000	 mov         r11, #0

; 98   :     curridlehigh = 0;
; 99   : 
; 100  :     // Set global variable to tell interrupt module about timer used
; 101  :     g_oalTimerIrq = IRQ_GPT1; 

  0009c	e59f1138	 ldr         r1, [pc, #0x138]
  000a0	e583b0d0	 str         r11, [r3, #0xD0]
  000a4	e5943000	 ldr         r3, [r4]
  000a8	e3a00025	 mov         r0, #0x25

; 102  : 
; 103  :     // Request SYSINTR for timer IRQ, it is done to reserve it...
; 104  :     sysIntr = OALIntrRequestSysIntr(1, &g_oalTimerIrq, OAL_INTR_FORCE_STATIC);

  000ac	e3a02004	 mov         r2, #4
  000b0	e583b0d4	 str         r11, [r3, #0xD4]
  000b4	e5810000	 str         r0, [r1]
  000b8	e3a00001	 mov         r0, #1
  000bc	eb000000	 bl          OALIntrRequestSysIntr
  000c0	e3a0a312	 mov         r10, #0x12, 6
  000c4	e1a06000	 mov         r6, r0

; 105  :     
; 106  :     // Hardware Setup
; 107  :     g_pPRCMRegs  = OALPAtoUA(OMAP2420_PRCM_REGS_PA);

  000c8	e38a0902	 orr         r0, r10, #2, 18
  000cc	e3a01000	 mov         r1, #0
  000d0	eb000000	 bl          OALPAtoVA
  000d4	e59f50fc	 ldr         r5, [pc, #0xFC]

; 108  :     g_pTimerRegs = OALPAtoUA(OMAP2420_GPTIMER1_REGS_PA);

  000d8	e3a01000	 mov         r1, #0
  000dc	e5850004	 str         r0, [r5, #4]
  000e0	e38a090a	 orr         r0, r10, #0xA, 18
  000e4	eb000000	 bl          OALPAtoVA
  000e8	e1a02000	 mov         r2, r0

; 109  :     
; 110  :     OUTREG32(&g_pTimerRegs->TCLR, 0x00000000);

  000ec	e582b024	 str         r11, [r2, #0x24]

; 111  :     CurMSec = 0;

  000f0	e5943000	 ldr         r3, [r4]

; 112  : 
; 113  :     // Select non posted mode
; 114  :     CLRREG32(&g_pTimerRegs->TSICR, 0x4);
; 115  :     
; 116  :     // Enable global wakeup feature and smart idle 
; 117  :     //  Set clock activity - FCLK can be  switched off, L4 interface clock is maintained during wkup.
; 118  :     OUTREG32(&g_pTimerRegs->TIOCP_CFG, 0x00000214);

  000f4	e3a01f85	 mov         r1, #0x85, 30

; 119  :     
; 120  :     // Enable overflow wakeup
; 121  :     OUTREG32(&g_pTimerRegs->TWER, 0x00000002);
; 122  :     
; 123  :     //Clear Interrupt
; 124  :     SETREG32(&g_pTimerRegs->TISR, 0x2);
; 125  : 
; 126  :     // Enabled overflow interrupt
; 127  :     SETREG32(&g_pTimerRegs->TIER, 0x2);
; 128  :     
; 129  :     //OALMSG(TRUE, (L"Timer Load Value is %x\r\n",g_oalTimer.countsPerSysTick));
; 130  :     //  Set the load register value.
; 131  :     OUTREG32(&g_pTimerRegs->TLDR, (0xFFFFFFFF - g_oalTimer.countsPerSysTick+1));
; 132  :     
; 133  :     //  Trigger a counter reload by writing    
; 134  :     OUTREG32(&g_pTimerRegs->TTGR, 0xFFFFFFFF);
; 135  :    
; 136  :     //  Start the timer.  Also set for auto reload
; 137  :     SETREG32(&g_pTimerRegs->TCLR, 0x00000003);
; 138  : 
; 139  :     // Setup Timer clock
; 140  :     CLRREG32(&g_pPRCMRegs->ulCM_CLKSEL_WKUP, 0x3);

  000f8	e5950004	 ldr         r0, [r5, #4]
  000fc	e583b0c8	 str         r11, [r3, #0xC8]
  00100	e5923040	 ldr         r3, [r2, #0x40]
  00104	e3c33004	 bic         r3, r3, #4
  00108	e5823040	 str         r3, [r2, #0x40]
  0010c	e3a03002	 mov         r3, #2
  00110	e5821010	 str         r1, [r2, #0x10]
  00114	e5823020	 str         r3, [r2, #0x20]
  00118	e5923018	 ldr         r3, [r2, #0x18]
  0011c	e3e01000	 mvn         r1, #0
  00120	e3833002	 orr         r3, r3, #2
  00124	e5823018	 str         r3, [r2, #0x18]
  00128	e592301c	 ldr         r3, [r2, #0x1C]
  0012c	e3833002	 orr         r3, r3, #2
  00130	e582301c	 str         r3, [r2, #0x1C]
  00134	e5993010	 ldr         r3, [r9, #0x10]
  00138	e2633000	 rsb         r3, r3, #0
  0013c	e582302c	 str         r3, [r2, #0x2C]
  00140	e5821030	 str         r1, [r2, #0x30]
  00144	e5923024	 ldr         r3, [r2, #0x24]

; 141  :     
; 142  :     // Enable the functional and interface  clocks for the GPT 1. 
; 143  :     SETREG32(&g_pPRCMRegs->ulCM_ICLKEN_WKUP, 0x1);

  00148	e5852000	 str         r2, [r5]

; 144  :     SETREG32(&g_pPRCMRegs->ulCM_FCLKEN_WKUP, 0x1);
; 145  : 
; 146  :     // Enable System Tick interrupt
; 147  :     if (!OEMInterruptEnable(sysIntr, NULL, 0)) {

  0014c	e3a01000	 mov         r1, #0
  00150	e3833003	 orr         r3, r3, #3
  00154	e5823024	 str         r3, [r2, #0x24]
  00158	e5903440	 ldr         r3, [r0, #0x440]
  0015c	e3a02000	 mov         r2, #0
  00160	e3c33003	 bic         r3, r3, #3
  00164	e5803440	 str         r3, [r0, #0x440]
  00168	e5903410	 ldr         r3, [r0, #0x410]
  0016c	e3833001	 orr         r3, r3, #1
  00170	e5803410	 str         r3, [r0, #0x410]
  00174	e5903400	 ldr         r3, [r0, #0x400]
  00178	e3833001	 orr         r3, r3, #1
  0017c	e5803400	 str         r3, [r0, #0x400]
  00180	e1a00006	 mov         r0, r6
  00184	eb000000	 bl          OEMInterruptEnable

; 148  :         OALMSG(OAL_ERROR, (
; 149  :             L"ERROR: OALTimerInit: Interrupt enable for system timer failed"
; 150  :         ));

  00188	e5973440	 ldr         r3, [r7, #0x440]
  0018c	e3500000	 cmp         r0, #0
  00190	1a000005	 bne         |$LN1@OALTimerIn@2|
  00194	e3130001	 tst         r3, #1
  00198	0a000004	 beq         |$cleanUp$45606|
  0019c	e59f0030	 ldr         r0, [pc, #0x30]
  001a0	eb000000	 bl          NKDbgPrintfW

; 151  :         goto cleanUp;

  001a4	e5973440	 ldr         r3, [r7, #0x440]
  001a8	ea000000	 b           |$cleanUp$45606|
  001ac		 |$LN1@OALTimerIn@2|

; 152  :     }
; 153  : 
; 154  :     rc = TRUE;

  001ac	e3a08001	 mov         r8, #1
  001b0		 |$cleanUp$45606|

; 155  :     
; 156  : cleanUp:
; 157  :     OALMSG(OAL_TIMER && OAL_FUNC, (L"-OALTimerInit..(rc = %d)\r\n", rc));

  001b0	e3130b02	 tst         r3, #2, 22
  001b4	13130004	 tstne       r3, #4
  001b8	159f0010	 ldrne       r0, [pc, #0x10]
  001bc	11a01008	 movne       r1, r8
  001c0	1b000000	 blne        NKDbgPrintfW

; 158  :     return rc;
; 159  : }

  001c4	e1a00008	 mov         r0, r8
  001c8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001cc	e12fff1e	 bx          lr
  001d0		 |$LN14@OALTimerIn@2|
  001d0		 |$LN15@OALTimerIn@2|
  001d0	00000000	 DCD         |??_C@_1DG@MBLBIFGK@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?4?$AA?4?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  001d4		 |$LN16@OALTimerIn@2|
  001d4	00000000	 DCD         |??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@|
  001d8		 |$LN17@OALTimerIn@2|
  001d8	00000000	 DCD         |g_pTimerRegs|
  001dc		 |$LN18@OALTimerIn@2|
  001dc	00000000	 DCD         |g_oalTimerIrq|
  001e0		 |$LN19@OALTimerIn@2|
  001e0	00000000	 DCD         |g_pNKGlobal|
  001e4		 |$LN20@OALTimerIn@2|
  001e4	00000000	 DCD         |g_oalTimer|
  001e8		 |$LN21@OALTimerIn@2|
  001e8	00000000	 DCD         |OALTimerQueryPerformanceCounter|
  001ec		 |$LN22@OALTimerIn@2|
  001ec	00000000	 DCD         |OALTimerQueryPerformanceFrequency|
  001f0		 |$LN23@OALTimerIn@2|
  001f0	00000000	 DCD         |g_pOemGlobal|
  001f4		 |$LN24@OALTimerIn@2|
  001f4	00000000	 DCD         |??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  001f8		 |$LN25@OALTimerIn@2|
  001f8	00000000	 DCD         |dpCurSettings|
  001fc		 |$M45779|

			 ENDP  ; |OALTimerInit|

	END
