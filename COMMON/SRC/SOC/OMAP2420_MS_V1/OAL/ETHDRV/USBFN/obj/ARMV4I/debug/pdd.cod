; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\OAL\ETHDRV\USBFN\pdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
	 COMMON	|dpCurSettings|, 0x444

	 COMMON	|g_usbfnpdd|, 0x128


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|InterruptThread|
	EXPORT	|??_C@_1HG@NNOMIKIA@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T47330| DCD	|$LN21@InterruptT|
	DCD	0x40004a01
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\oal\ethdrv\usbfn\pdd.c

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@NNOMIKIA@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, "T"
	DCB	0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, ":"
	DCB	0x0, " ", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, " ", 0x0, "s"
	DCB	0x0, "o", 0x0, "u", 0x0, "r", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "%", 0x0, "x", 0x0, " ", 0x0, "e", 0x0, "n", 0x0, "a"
	DCB	0x0, "b", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "%"
	DCB	0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InterruptThread| PROC

; 500  : {

  00000		 |$LN21@InterruptT|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M47327|
  00004	e1a07000	 mov         r7, r0

; 501  :     USBFN_PDD *pPdd = pPddContext;
; 502  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00008	e5978008	 ldr         r8, [r7, #8]
  0000c	e59f9110	 ldr         r9, [pc, #0x110]
  00010	e3a0b000	 mov         r11, #0
  00014	e3a0a008	 mov         r10, #8
  00018		 |$LL11@InterruptT|
  00018	e5993440	 ldr         r3, [r9, #0x440]

; 503  :     DWORD source, ep;
; 504  :     while (TRUE) {
; 505  :         BOOL fInterrupt = FALSE;
; 506  :     
; 507  :         // Get interrupt source
; 508  :         source = INREG32(&pUSBDRegs->IRQ_SRC);

  0001c	e5984030	 ldr         r4, [r8, #0x30]
  00020	e3a05000	 mov         r5, #0

; 509  : 
; 510  :         OALMSG(OAL_ETHER&&OAL_FUNC, (
; 511  :             L"UsbFnPdd!InterruptThread: Interrupt source %x enabled %x\r\n", source));

  00024	e3130a02	 tst         r3, #2, 20
  00028	0a000004	 beq         |$LN14@InterruptT|
  0002c	e3130004	 tst         r3, #4
  00030	0a000002	 beq         |$LN14@InterruptT|
  00034	e59f00e4	 ldr         r0, [pc, #0xE4]
  00038	e1a01004	 mov         r1, r4
  0003c	eb000000	 bl          NKDbgPrintfW
  00040		 |$LN14@InterruptT|

; 512  :         // Device state
; 513  :         if ((source & USBD_INT_DS_CHG) != 0 || pPdd->fakeDsChange) {

  00040	e2146008	 ands        r6, r4, #8
  00044	1a000002	 bne         |$LN8@InterruptT|
  00048	e5973124	 ldr         r3, [r7, #0x124]
  0004c	e3530000	 cmp         r3, #0
  00050	0a000005	 beq         |$LN9@InterruptT|
  00054		 |$LN8@InterruptT|

; 514  :             // Handle device state change
; 515  :             DevStatEvent(pPdd);

  00054	e1a00007	 mov         r0, r7
  00058	eb000000	 bl          DevStatEvent

; 516  :             // Clear fake DsChange flag
; 517  :             pPdd->fakeDsChange = FALSE;
; 518  :             if (( source & USBD_INT_DS_CHG) != 0 ) 

  0005c	e3560000	 cmp         r6, #0
  00060	e587b124	 str         r11, [r7, #0x124]

; 519  :                 OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_DS_CHG);

  00064	1588a030	 strne       r10, [r8, #0x30]

; 520  :    	     fInterrupt = TRUE;

  00068	e3a05001	 mov         r5, #1
  0006c		 |$LN9@InterruptT|

; 521  :         }
; 522  : 
; 523  :         // EP0 RX interrupt
; 524  :         if ((source & USBD_INT_EP0_RX) != 0) {

  0006c	e3140002	 tst         r4, #2
  00070	0a000005	 beq         |$LN6@InterruptT|

; 525  :             // Clear source bit
; 526  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP0_RX);
; 527  :             // Issue next Rx transfer
; 528  :             IssueRxTransfer(pPdd, 0);

  00074	e3a03002	 mov         r3, #2
  00078	e3a01000	 mov         r1, #0
  0007c	e1a00007	 mov         r0, r7
  00080	e5883030	 str         r3, [r8, #0x30]
  00084	eb000000	 bl          IssueRxTransfer

; 529  :             fInterrupt = TRUE;

  00088	e3a05001	 mov         r5, #1
  0008c		 |$LN6@InterruptT|

; 530  :         }
; 531  : 
; 532  :         // EP0 TX interrupt
; 533  :         if ((source & USBD_INT_EP0_TX) != 0) {

  0008c	e3140001	 tst         r4, #1
  00090	0a000005	 beq         |$LN5@InterruptT|

; 534  :             // Clear source bit
; 535  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP0_TX);
; 536  :             // Issue next Tx transfer
; 537  :             IssueTxTransfer(pPdd, 0);

  00094	e3a03001	 mov         r3, #1
  00098	e3a01000	 mov         r1, #0
  0009c	e1a00007	 mov         r0, r7
  000a0	e5883030	 str         r3, [r8, #0x30]
  000a4	eb000000	 bl          IssueTxTransfer

; 538  :             fInterrupt = TRUE;

  000a8	e3a05001	 mov         r5, #1
  000ac		 |$LN5@InterruptT|

; 539  :         }
; 540  : 
; 541  :         // EPn RX interrupt
; 542  :         if ((source & USBD_INT_EP_RX) != 0) {

  000ac	e3140020	 tst         r4, #0x20
  000b0	0a000007	 beq         |$LN4@InterruptT|

; 543  :             // Get EP number
; 544  :             ep = (INREG32(&pUSBDRegs->EP_STAT) >> 8) & USBD_EP_NUM;

  000b4	e5983034	 ldr         r3, [r8, #0x34]

; 545  :             // Clear source bit
; 546  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP_RX);
; 547  :             // Handle event
; 548  :             IssueRxTransfer(pPdd, ep);

  000b8	e3a02020	 mov         r2, #0x20
  000bc	e1a00007	 mov         r0, r7
  000c0	e1a03a03	 mov         r3, r3, lsl #20
  000c4	e1a01e23	 mov         r1, r3, lsr #28
  000c8	e5882030	 str         r2, [r8, #0x30]
  000cc	eb000000	 bl          IssueRxTransfer

; 549  :             fInterrupt = TRUE;

  000d0	e3a05001	 mov         r5, #1
  000d4		 |$LN4@InterruptT|

; 550  :         }
; 551  : 
; 552  :         // EPn TX interrupt
; 553  :         if ((source & USBD_INT_EP_TX) != 0) {

  000d4	e3140010	 tst         r4, #0x10
  000d8	0a000006	 beq         |$LN3@InterruptT|

; 554  :             // Get EP number
; 555  :             ep = INREG32(&pUSBDRegs->EP_STAT) & USBD_EP_NUM;

  000dc	e5983034	 ldr         r3, [r8, #0x34]

; 556  :             // Clear source bit
; 557  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP_TX);
; 558  :             // Handle event
; 559  :             IssueTxTransfer(pPdd, ep);

  000e0	e3a02010	 mov         r2, #0x10
  000e4	e1a00007	 mov         r0, r7
  000e8	e203100f	 and         r1, r3, #0xF
  000ec	e5882030	 str         r2, [r8, #0x30]
  000f0	eb000000	 bl          IssueTxTransfer

; 560  :             fInterrupt = TRUE;

  000f4	e3a05001	 mov         r5, #1
  000f8		 |$LN3@InterruptT|

; 561  :         }
; 562  : 
; 563  :         // Setup Packet
; 564  :         if ((source & USBD_INT_SETUP) != 0) {

  000f8	e3140004	 tst         r4, #4
  000fc	0a000002	 beq         |$LN2@InterruptT|

; 565  :             // Reading setup FIFO clears interrupt
; 566  :             SetupEvent(pPdd);

  00100	e1a00007	 mov         r0, r7
  00104	eb000000	 bl          SetupEvent

; 567  :             fInterrupt = TRUE;
; 568  :         }
; 569  : 
; 570  :         if( !fInterrupt )

  00108	eaffffc2	 b           |$LL11@InterruptT|
  0010c		 |$LN2@InterruptT|
  0010c	e3550000	 cmp         r5, #0
  00110	1affffc0	 bne         |$LL11@InterruptT|

; 571  :         {
; 572  :             break;
; 573  :         }
; 574  :     }
; 575  :    return ERROR_SUCCESS;

  00114	e3a00000	 mov         r0, #0

; 576  : }

  00118	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN22@InterruptT|
  00120		 |$LN23@InterruptT|
  00120	00000000	 DCD         |??_C@_1HG@NNOMIKIA@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr@|
  00124		 |$LN24@InterruptT|
  00124	00000000	 DCD         |dpCurSettings|
  00128		 |$M47328|

			 ENDP  ; |InterruptThread|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_1EO@NECIJIIB@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA3?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@NFJNGFJM@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA2?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@NHEDGCLL@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA1?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@NGPGJPKG@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| [ DATA ] ; `string'
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00008			 AREA	 |.pdata|, PDATA
|$T47358| DCD	|$LN24@SetupEvent|
	DCD	0xc0006502

  00000			 AREA	 |.xdata|, DATA
|$T47354| DCD	0xffffffec

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@NECIJIIB@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA3?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, " ", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "u", 0x0, "p", 0x0, "E", 0x0, "v", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, "(", 0x0, ")", 0x0, " ", 0x0, "-"
	DCB	0x0, " ", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a", 0x0, "["
	DCB	0x0, "3", 0x0, "]", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@NFJNGFJM@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA2?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, " ", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "u", 0x0, "p", 0x0, "E", 0x0, "v", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, "(", 0x0, ")", 0x0, " ", 0x0, "-"
	DCB	0x0, " ", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a", 0x0, "["
	DCB	0x0, "2", 0x0, "]", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@NHEDGCLL@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA1?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, " ", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "u", 0x0, "p", 0x0, "E", 0x0, "v", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, "(", 0x0, ")", 0x0, " ", 0x0, "-"
	DCB	0x0, " ", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a", 0x0, "["
	DCB	0x0, "1", 0x0, "]", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@NGPGJPKG@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@| DCB "U"
	DCB	0x0, "S", 0x0, "B", 0x0, "D", 0x0, " ", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "u", 0x0, "p", 0x0, "E", 0x0, "v", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, "(", 0x0, ")", 0x0, " ", 0x0, "-"
	DCB	0x0, " ", 0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a", 0x0, "["
	DCB	0x0, "0", 0x0, "]", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogtp

  00128			 AREA	 |.text|, CODE, ARM

  00128	00000000	 DCD         |__GSHandlerCheck|
  0012c	00000000	 DCD         |$T47354|

  00130		 |SetupEvent| PROC

; 126  : {

  00130		 |$LN24@SetupEvent|
  00130	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00134	e24dd00c	 sub         sp, sp, #0xC
  00138		 |$M47355|
  00138	e1a06000	 mov         r6, r0
  0013c	e59f317c	 ldr         r3, [pc, #0x17C]
  00140	e5933000	 ldr         r3, [r3]
  00144	e58d3008	 str         r3, [sp, #8]

; 127  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00148	e5964008	 ldr         r4, [r6, #8]
  0014c	e3a02040	 mov         r2, #0x40
  00150	e3a01000	 mov         r1, #0
  00154		 |$LL8@SetupEvent|

; 128  :     WORD data[4];
; 129  :     USB_DEVICE_REQUEST *pSetup = (USB_DEVICE_REQUEST*)data;
; 130  : 
; 131  :     do {
; 132  : 
; 133  :         // Select setup FIFO (this clears USBD_INT_SETUP flag)
; 134  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SETUP);

  00154	e5842004	 str         r2, [r4, #4]

; 135  : 
; 136  :         // Read setup data
; 137  :         data[0] = (WORD)INREG32(&pUSBDRegs->DATA);

  00158	e5943008	 ldr         r3, [r4, #8]
  0015c	e1cd30b0	 strh        r3, [sp]

; 138  :         data[1] = (WORD)INREG32(&pUSBDRegs->DATA);

  00160	e5943008	 ldr         r3, [r4, #8]
  00164	e1cd30b2	 strh        r3, [sp, #2]

; 139  :         data[2] = (WORD)INREG32(&pUSBDRegs->DATA);

  00168	e5943008	 ldr         r3, [r4, #8]
  0016c	e1cd30b4	 strh        r3, [sp, #4]

; 140  :         data[3] = (WORD)INREG32(&pUSBDRegs->DATA);

  00170	e5943008	 ldr         r3, [r4, #8]
  00174	e1cd30b6	 strh        r3, [sp, #6]

; 141  : 
; 142  :         // Deselect setup FIFO
; 143  :         OUTREG32(&pUSBDRegs->EP_NUM, 0);

  00178	e5841004	 str         r1, [r4, #4]

; 144  : 
; 145  :     } while ((INREG32(&pUSBDRegs->IRQ_SRC) & USBD_INT_SETUP) != 0);

  0017c	e5943030	 ldr         r3, [r4, #0x30]
  00180	e3130004	 tst         r3, #4
  00184	1afffff2	 bne         |$LL8@SetupEvent|

; 146  : 
; 147  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"USBD SetupEvent() - data[0] = 0x%04X\r\n", data[0]));

  00188	e59f512c	 ldr         r5, [pc, #0x12C]
  0018c	e5953440	 ldr         r3, [r5, #0x440]
  00190	e3130a02	 tst         r3, #2, 20
  00194	0a000005	 beq         |$LN11@SetupEvent|
  00198	e3130004	 tst         r3, #4
  0019c	0a000003	 beq         |$LN11@SetupEvent|
  001a0	e1dd10b0	 ldrh        r1, [sp]
  001a4	e59f010c	 ldr         r0, [pc, #0x10C]
  001a8	eb000000	 bl          NKDbgPrintfW
  001ac	e5953440	 ldr         r3, [r5, #0x440]
  001b0		 |$LN11@SetupEvent|

; 148  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"USBD SetupEvent() - data[1] = 0x%04X\r\n", data[1]));

  001b0	e3130a02	 tst         r3, #2, 20
  001b4	0a000005	 beq         |$LN13@SetupEvent|
  001b8	e3130004	 tst         r3, #4
  001bc	0a000003	 beq         |$LN13@SetupEvent|
  001c0	e1dd10b2	 ldrh        r1, [sp, #2]
  001c4	e59f00e8	 ldr         r0, [pc, #0xE8]
  001c8	eb000000	 bl          NKDbgPrintfW
  001cc	e5953440	 ldr         r3, [r5, #0x440]
  001d0		 |$LN13@SetupEvent|

; 149  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"USBD SetupEvent() - data[2] = 0x%04X\r\n", data[2]));

  001d0	e3130a02	 tst         r3, #2, 20
  001d4	0a000005	 beq         |$LN15@SetupEvent|
  001d8	e3130004	 tst         r3, #4
  001dc	0a000003	 beq         |$LN15@SetupEvent|
  001e0	e1dd10b4	 ldrh        r1, [sp, #4]
  001e4	e59f00c4	 ldr         r0, [pc, #0xC4]
  001e8	eb000000	 bl          NKDbgPrintfW
  001ec	e5953440	 ldr         r3, [r5, #0x440]
  001f0		 |$LN15@SetupEvent|

; 150  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"USBD SetupEvent() - data[3] = 0x%04X\r\n", data[3]));

  001f0	e3130a02	 tst         r3, #2, 20
  001f4	0a000004	 beq         |$LN17@SetupEvent|
  001f8	e3130004	 tst         r3, #4
  001fc	0a000002	 beq         |$LN17@SetupEvent|
  00200	e1dd10b6	 ldrh        r1, [sp, #6]
  00204	e59f00a0	 ldr         r0, [pc, #0xA0]
  00208	eb000000	 bl          NKDbgPrintfW
  0020c		 |$LN17@SetupEvent|

; 151  : 
; 152  :     // Save setup packet direction & size for later use
; 153  :     pPdd->setupDirRx = (pSetup->bmRequestType & 0x80) == 0;

  0020c	e5dd1000	 ldrb        r1, [sp]

; 154  :     pPdd->setupCount = pSetup->wLength;

  00210	e1dd30b6	 ldrh        r3, [sp, #6]
  00214	e3110080	 tst         r1, #0x80
  00218	03a02001	 moveq       r2, #1
  0021c	13a02000	 movne       r2, #0
  00220	e5862018	 str         r2, [r6, #0x18]

; 155  : 
; 156  :     // MDD doesn't call PDD back on configure message
; 157  :     if (
; 158  :         pSetup->bmRequestType == 0 &&
; 159  :         pSetup->bRequest == USB_REQUEST_SET_CONFIGURATION
; 160  :     ) {

  00224	e3510000	 cmp         r1, #0
  00228	e1c631bc	 strh        r3, [r6, #0x1C]
  0022c	1a000013	 bne         |$LN1@SetupEvent|
  00230	e5dd3001	 ldrb        r3, [sp, #1]
  00234	e3530009	 cmp         r3, #9
  00238	1a000010	 bne         |$LN1@SetupEvent|

; 161  :         if (pSetup->wValue != 0) {

  0023c	e1dd30b2	 ldrh        r3, [sp, #2]
  00240	e3530000	 cmp         r3, #0
  00244	0a00000b	 beq         |$LN4@SetupEvent|

; 162  :             // Move device to configured state
; 163  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_DEV_CFG);

  00248	e3a03008	 mov         r3, #8
  0024c	e584301c	 str         r3, [r4, #0x1C]

; 164  :             // Set self powered flag
; 165  :             if (pPdd->selfPowered) {

  00250	e5963014	 ldr         r3, [r6, #0x14]
  00254	e3530000	 cmp         r3, #0

; 166  :                 SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_SELF_PWR);

  00258	e5943018	 ldr         r3, [r4, #0x18]
  0025c	0a000002	 beq         |$LN3@SetupEvent|
  00260	e3833004	 orr         r3, r3, #4
  00264	e5843018	 str         r3, [r4, #0x18]

; 167  :             } else {

  00268	ea000004	 b           |$LN1@SetupEvent|
  0026c		 |$LN3@SetupEvent|

; 168  :                 CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_SELF_PWR);

  0026c	e3c33004	 bic         r3, r3, #4
  00270	e5843018	 str         r3, [r4, #0x18]

; 169  :             }
; 170  :         } else {

  00274	ea000001	 b           |$LN1@SetupEvent|
  00278		 |$LN4@SetupEvent|

; 171  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);

  00278	e3a03004	 mov         r3, #4
  0027c	e584301c	 str         r3, [r4, #0x1C]
  00280		 |$LN1@SetupEvent|

; 172  :         }
; 173  :     }
; 174  : 
; 175  :     // Let MDD process message
; 176  :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SETUP_PACKET, (DWORD)data);

  00280	e5960000	 ldr         r0, [r6]
  00284	e5963004	 ldr         r3, [r6, #4]
  00288	e28d2000	 add         r2, sp, #0
  0028c	e3a01004	 mov         r1, #4
  00290	e1a0e00f	 mov         lr, pc
  00294	e12fff13	 bx          r3
  00298	e59d0008	 ldr         r0, [sp, #8]
  0029c	eb000000	 bl          __security_check_cookie

; 177  : }

  002a0	e28dd00c	 add         sp, sp, #0xC
  002a4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  002a8	e12fff1e	 bx          lr
  002ac		 |$LN25@SetupEvent|
  002ac		 |$LN26@SetupEvent|
  002ac	00000000	 DCD         |??_C@_1EO@NECIJIIB@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA3?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@|
  002b0		 |$LN27@SetupEvent|
  002b0	00000000	 DCD         |??_C@_1EO@NFJNGFJM@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA2?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@|
  002b4		 |$LN28@SetupEvent|
  002b4	00000000	 DCD         |??_C@_1EO@NHEDGCLL@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA1?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@|
  002b8		 |$LN29@SetupEvent|
  002b8	00000000	 DCD         |??_C@_1EO@NGPGJPKG@?$AAU?$AAS?$AAB?$AAD?$AA?5?$AAS?$AAe?$AAt?$AAu?$AAp?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$CI?$AA?$CJ?$AA?5?$AA?9?$AA?5?$AAd?$AAa?$AAt?$AAa?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx@|
  002bc		 |$LN30@SetupEvent|
  002bc	00000000	 DCD         |dpCurSettings|
  002c0		 |$LN31@SetupEvent|
  002c0	00000000	 DCD         |__security_cookie|
  002c4		 |$M47356|

			 ENDP  ; |SetupEvent|

	EXPORT	|??_C@_1HM@LNNMMNAI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| [ DATA ] ; `string'

  00010			 AREA	 |.pdata|, PDATA
|$T47393| DCD	|$LN27@IssueTxTra|
	DCD	0x40006d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@LNNMMNAI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "I", 0x0, "s", 0x0, "s", 0x0, "u"
	DCB	0x0, "e", 0x0, "T", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, " ", 0x0, "p", 0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n"
	DCB	0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, " ", 0x0, "(", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  002c4			 AREA	 |.text|, CODE, ARM

  002c4		 |IssueTxTransfer| PROC

; 187  : {

  002c4		 |$LN27@IssueTxTra|
  002c4	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  002c8	e24dd008	 sub         sp, sp, #8
  002cc		 |$M47390|
  002cc	e1a06001	 mov         r6, r1
  002d0	e1a08000	 mov         r8, r0

; 188  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 189  :     STransfer *pTransfer;
; 190  :     BOOL complete = FALSE;
; 191  :     DWORD epNum, stat, space, count, remain;
; 192  :     UCHAR *pBuffer;
; 193  :     WORD data;
; 194  : 
; 195  :     // Get active transfer
; 196  :     pTransfer = pPdd->ep[endPoint].pTransfer;
; 197  : 
; 198  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 199  :         L"UsbFnPdd!IssueTxTransfer: EP %d pTransfer 0x%x (%d, %d, %d)\r\n",
; 200  :         endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 201  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 202  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 203  :     ));

  002d4	e59f3198	 ldr         r3, [pc, #0x198]
  002d8	e0889206	 add         r9, r8, r6, lsl #4
  002dc	e5987008	 ldr         r7, [r8, #8]
  002e0	e5933440	 ldr         r3, [r3, #0x440]
  002e4	e5994030	 ldr         r4, [r9, #0x30]
  002e8	e3a0a000	 mov         r10, #0
  002ec	e3130a02	 tst         r3, #2, 20
  002f0	0a000010	 beq         |$LN13@IssueTxTra|
  002f4	e3130004	 tst         r3, #4
  002f8	0a00000e	 beq         |$LN13@IssueTxTra|
  002fc	e3540000	 cmp         r4, #0
  00300	0a000003	 beq         |$LN14@IssueTxTra|
  00304	e594e014	 ldr         lr, [r4, #0x14]
  00308	e5945010	 ldr         r5, [r4, #0x10]
  0030c	e594300c	 ldr         r3, [r4, #0xC]
  00310	ea000002	 b           |$LN19@IssueTxTra|
  00314		 |$LN14@IssueTxTra|
  00314	e3e0e000	 mvn         lr, #0
  00318	e3a05000	 mov         r5, #0
  0031c	e3a03000	 mov         r3, #0
  00320		 |$LN19@IssueTxTra|
  00320	e59f0148	 ldr         r0, [pc, #0x148]
  00324	e1a02004	 mov         r2, r4
  00328	e1a01006	 mov         r1, r6
  0032c	e58de004	 str         lr, [sp, #4]
  00330	e58d5000	 str         r5, [sp]
  00334	eb000000	 bl          NKDbgPrintfW
  00338		 |$LN13@IssueTxTra|

; 204  : 
; 205  :     // Select EP
; 206  :     epNum = (USBD_EP_NUM & endPoint) | USBD_EP_NUM_DIRIN;

  00338	e206300f	 and         r3, r6, #0xF
  0033c	e383b010	 orr         r11, r3, #0x10

; 207  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00340	e38b3020	 orr         r3, r11, #0x20
  00344	e5873004	 str         r3, [r7, #4]

; 208  : 
; 209  :     // Get EP status
; 210  :     stat = INREG32(&pUSBDRegs->STAT_FLG);

  00348	e5973010	 ldr         r3, [r7, #0x10]

; 211  : 
; 212  :     // Depending on EP status
; 213  :     if ((stat & USBD_STAT_STALL) != 0) {

  0034c	e3a0e000	 mov         lr, #0
  00350	e3130020	 tst         r3, #0x20
  00354	0a000002	 beq         |$LN10@IssueTxTra|

; 214  :         // We issued stall, remove it...
; 215  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT);

  00358	e3a03080	 mov         r3, #0x80
  0035c	e587300c	 str         r3, [r7, #0xC]

; 216  :         // We are done
; 217  :         goto clean;

  00360	ea000035	 b           |$clean$46682|
  00364		 |$LN10@IssueTxTra|

; 218  :     }
; 219  : 
; 220  :     // When transfer is NULL it is handshake ACK
; 221  :     if (pTransfer == NULL) goto clean;

  00364	e3540000	 cmp         r4, #0
  00368	0a000033	 beq         |$clean$46682|

; 222  : 
; 223  :     // Is this final interrupt of transfer? 
; 224  :     if (
; 225  :         pTransfer->cbTransferred == pTransfer->cbBuffer && 
; 226  :         !pPdd->ep[endPoint].zeroLength
; 227  :     ) {

  0036c	e5941010	 ldr         r1, [r4, #0x10]
  00370	e594200c	 ldr         r2, [r4, #0xC]
  00374	e1510002	 cmp         r1, r2
  00378	1a000005	 bne         |$LN8@IssueTxTra|
  0037c	e599302c	 ldr         r3, [r9, #0x2C]
  00380	e3530000	 cmp         r3, #0
  00384	1a000002	 bne         |$LN8@IssueTxTra|

; 228  :         pTransfer->dwUsbError = UFN_NO_ERROR;

  00388	e584e014	 str         lr, [r4, #0x14]

; 229  :         complete = TRUE;

  0038c	e3a0a001	 mov         r10, #1

; 230  :         goto clean;

  00390	ea000029	 b           |$clean$46682|
  00394		 |$LN8@IssueTxTra|

; 231  :     }
; 232  : 
; 233  :     pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  00394	e5943004	 ldr         r3, [r4, #4]

; 234  :     space = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 235  : 
; 236  :     if (endPoint != 0) {

  00398	e3560000	 cmp         r6, #0
  0039c	e0420001	 sub         r0, r2, r1
  003a0	e0835001	 add         r5, r3, r1

; 237  :         // Non Zero Endpoint: No zero length padding needed.
; 238  :         pPdd->ep[endPoint].zeroLength = FALSE;

  003a4	1589e02c	 strne       lr, [r9, #0x2C]
  003a8	1a000008	 bne         |$LN6@IssueTxTra|

; 239  :     } else {
; 240  :         // Zero endpoint: Zero length padding needed if last
; 241  :         // packet is maxPacketSize.
; 242  :         pPdd->ep[endPoint].zeroLength = (
; 243  :             space == pPdd->ep[endPoint].maxPacketSize && 
; 244  :             pPdd->setupCount > pTransfer->cbBuffer
; 245  :         );

  003ac	e1d832b4	 ldrh        r3, [r8, #0x24]
  003b0	e1500003	 cmp         r0, r3
  003b4	1a000003	 bne         |$LN21@IssueTxTra|
  003b8	e1d831bc	 ldrh        r3, [r8, #0x1C]
  003bc	e1530002	 cmp         r3, r2
  003c0	83a03001	 movhi       r3, #1
  003c4	8a000000	 bhi         |$LN22@IssueTxTra|
  003c8		 |$LN21@IssueTxTra|
  003c8	e3a03000	 mov         r3, #0
  003cc		 |$LN22@IssueTxTra|
  003cc	e588302c	 str         r3, [r8, #0x2C]
  003d0		 |$LN6@IssueTxTra|

; 246  :     }        
; 247  : 
; 248  :     // How many bytes we can send just now?
; 249  :     count = pPdd->ep[endPoint].maxPacketSize;

  003d0	e1d912b4	 ldrh        r1, [r9, #0x24]

; 250  :     if (count > space) count = space;

  003d4	e1510000	 cmp         r1, r0
  003d8	81a01000	 movhi       r1, r0

; 251  : 
; 252  :     // Write data to FIFO
; 253  :     remain = count;
; 254  :     while (remain > 1) {

  003dc	e3510001	 cmp         r1, #1
  003e0	9a00000b	 bls         |$LN3@IssueTxTra|
  003e4	e2413002	 sub         r3, r1, #2
  003e8	e1a030a3	 mov         r3, r3, lsr #1
  003ec	e283e001	 add         lr, r3, #1
  003f0		 |$LL4@IssueTxTra|

; 255  :         data = (pBuffer[1] << 8) | pBuffer[0];
; 256  :         OUTREG16((UINT16*)&pUSBDRegs->DATA, data);

  003f0	e5d52001	 ldrb        r2, [r5, #1]
  003f4	e4d53002	 ldrb        r3, [r5], #2

; 257  :         pBuffer += 2;
; 258  :         space -= 2;

  003f8	e2400002	 sub         r0, r0, #2

; 259  :         remain -= 2;

  003fc	e2411002	 sub         r1, r1, #2
  00400	e25ee001	 subs        lr, lr, #1
  00404	e1833402	 orr         r3, r3, r2, lsl #8
  00408	e1c730b8	 strh        r3, [r7, #8]
  0040c	1afffff7	 bne         |$LL4@IssueTxTra|
  00410	e3a0e000	 mov         lr, #0
  00414		 |$LN3@IssueTxTra|

; 260  :     }
; 261  :     if (remain > 0) {

  00414	e3510000	 cmp         r1, #0
  00418	0a000002	 beq         |$LN2@IssueTxTra|

; 262  :         OUTREG8((UINT8*)&pUSBDRegs->DATA, *pBuffer);

  0041c	e5d53000	 ldrb        r3, [r5]

; 263  :         pBuffer += 1;
; 264  :         space -= 1;

  00420	e2400001	 sub         r0, r0, #1
  00424	e5c73008	 strb        r3, [r7, #8]
  00428		 |$LN2@IssueTxTra|

; 265  :         remain -= 1;
; 266  :     }
; 267  : 
; 268  :     // Enable FIFO
; 269  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00428	e3a03004	 mov         r3, #4
  0042c	e587300c	 str         r3, [r7, #0xC]

; 270  : 
; 271  :     // We transfered some data
; 272  :     pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  00430	e594300c	 ldr         r3, [r4, #0xC]
  00434	e0433000	 sub         r3, r3, r0
  00438	e5843010	 str         r3, [r4, #0x10]
  0043c		 |$clean$46682|

; 273  : 
; 274  : clean:
; 275  : 
; 276  :     // Deselect EP
; 277  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  0043c	e587b004	 str         r11, [r7, #4]

; 278  : 
; 279  :     // If transaction is complete we should tell MDD
; 280  :     if (complete) {

  00440	e35a0000	 cmp         r10, #0
  00444	0a000006	 beq         |$LN1@IssueTxTra|

; 281  :         pPdd->ep[endPoint].pTransfer = NULL;

  00448	e589e030	 str         lr, [r9, #0x30]

; 282  :         pPdd->pfnNotify(
; 283  :             pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 284  :         );

  0044c	e5980000	 ldr         r0, [r8]
  00450	e5983004	 ldr         r3, [r8, #4]
  00454	e1a02004	 mov         r2, r4
  00458	e3a01064	 mov         r1, #0x64
  0045c	e1a0e00f	 mov         lr, pc
  00460	e12fff13	 bx          r3
  00464		 |$LN1@IssueTxTra|

; 285  :     }
; 286  : }

  00464	e28dd008	 add         sp, sp, #8
  00468	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0046c	e12fff1e	 bx          lr
  00470		 |$LN28@IssueTxTra|
  00470		 |$LN29@IssueTxTra|
  00470	00000000	 DCD         |??_C@_1HM@LNNMMNAI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@|
  00474		 |$LN30@IssueTxTra|
  00474	00000000	 DCD         |dpCurSettings|
  00478		 |$M47391|

			 ENDP  ; |IssueTxTransfer|

	EXPORT	|??_C@_1HM@BCFIOLEH@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| [ DATA ] ; `string'

  00018			 AREA	 |.pdata|, PDATA
|$T47426| DCD	|$LN30@IssueRxTra|
	DCD	0x40007002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@BCFIOLEH@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "I", 0x0, "s", 0x0, "s", 0x0, "u"
	DCB	0x0, "e", 0x0, "R", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, " ", 0x0, "p", 0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n"
	DCB	0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, " ", 0x0, "(", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00478			 AREA	 |.text|, CODE, ARM

  00478		 |IssueRxTransfer| PROC

; 296  : {

  00478		 |$LN30@IssueRxTra|
  00478	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0047c	e24dd00c	 sub         sp, sp, #0xC
  00480		 |$M47423|
  00480	e1a06001	 mov         r6, r1
  00484	e1a08000	 mov         r8, r0

; 297  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 298  :     STransfer *pTransfer;
; 299  :     BOOL complete = FALSE;
; 300  :     DWORD epNum, stat, space, count, remain, maxSize;
; 301  :     UCHAR *pBuffer;
; 302  :     WORD data;
; 303  : 
; 304  :     // Get active transfer
; 305  :     pTransfer = pPdd->ep[endPoint].pTransfer;
; 306  : 
; 307  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 308  :         L"UsbFnPdd!IssueRxTransfer: EP %d pTransfer 0x%x (%d, %d, %d)\r\n",
; 309  :         endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 310  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 311  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 312  :     ));

  00488	e59f31a4	 ldr         r3, [pc, #0x1A4]
  0048c	e088e206	 add         lr, r8, r6, lsl #4
  00490	e5987008	 ldr         r7, [r8, #8]
  00494	e5933440	 ldr         r3, [r3, #0x440]
  00498	e59e4030	 ldr         r4, [lr, #0x30]
  0049c	e58de008	 str         lr, [sp, #8]
  004a0	e3130a02	 tst         r3, #2, 20
  004a4	e3a0a000	 mov         r10, #0
  004a8	0a000011	 beq         |$LN18@IssueRxTra|
  004ac	e3130004	 tst         r3, #4
  004b0	0a00000f	 beq         |$LN18@IssueRxTra|
  004b4	e3540000	 cmp         r4, #0
  004b8	0a000003	 beq         |$LN19@IssueRxTra|
  004bc	e594e014	 ldr         lr, [r4, #0x14]
  004c0	e5945010	 ldr         r5, [r4, #0x10]
  004c4	e594300c	 ldr         r3, [r4, #0xC]
  004c8	ea000002	 b           |$LN24@IssueRxTra|
  004cc		 |$LN19@IssueRxTra|
  004cc	e3e0e000	 mvn         lr, #0
  004d0	e3a05000	 mov         r5, #0
  004d4	e3a03000	 mov         r3, #0
  004d8		 |$LN24@IssueRxTra|
  004d8	e59f0150	 ldr         r0, [pc, #0x150]
  004dc	e1a02004	 mov         r2, r4
  004e0	e1a01006	 mov         r1, r6
  004e4	e58de004	 str         lr, [sp, #4]
  004e8	e58d5000	 str         r5, [sp]
  004ec	eb000000	 bl          NKDbgPrintfW
  004f0	e088e206	 add         lr, r8, r6, lsl #4
  004f4		 |$LN18@IssueRxTra|

; 313  : 
; 314  :     // Select EP
; 315  :     epNum = USBD_EP_NUM & endPoint;

  004f4	e206b00f	 and         r11, r6, #0xF

; 316  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  004f8	e38b3020	 orr         r3, r11, #0x20
  004fc	e5873004	 str         r3, [r7, #4]

; 317  : 
; 318  :     // Get EP status
; 319  :     stat = INREG32(&pUSBDRegs->STAT_FLG);

  00500	e5973010	 ldr         r3, [r7, #0x10]

; 320  : 
; 321  :     // Depending on EP status
; 322  :     if ((stat & USBD_STAT_STALL) != 0) {

  00504	e3a02000	 mov         r2, #0
  00508	e3130020	 tst         r3, #0x20
  0050c	0a000002	 beq         |$LN15@IssueRxTra|

; 323  :         // We issued stall, remove it...
; 324  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT);

  00510	e3a03080	 mov         r3, #0x80
  00514	e587300c	 str         r3, [r7, #0xC]

; 325  :         // We are done
; 326  :         goto clean;

  00518	ea000037	 b           |$clean$46735|
  0051c		 |$LN15@IssueRxTra|

; 327  :     }
; 328  : 
; 329  :     // When transfer is NULL it is handshake ACK
; 330  :     if (pTransfer == NULL) goto clean;

  0051c	e3540000	 cmp         r4, #0
  00520	0a000035	 beq         |$clean$46735|

; 331  : 
; 332  :     // Get maxPacketSize
; 333  :     maxSize = pPdd->ep[endPoint].maxPacketSize;
; 334  : 
; 335  :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;
; 336  :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 337  : 
; 338  :         // Get EP status flag
; 339  :         stat = INREG32(&pUSBDRegs->STAT_FLG);

  00524	e5970010	 ldr         r0, [r7, #0x10]
  00528	e5941010	 ldr         r1, [r4, #0x10]
  0052c	e5943004	 ldr         r3, [r4, #4]
  00530	e594200c	 ldr         r2, [r4, #0xC]

; 340  : 
; 341  :         // Get number of bytes in FIFO
; 342  :         if ((stat & USBD_STAT_FIFO_EMPTY) != 0) {

  00534	e3100002	 tst         r0, #2
  00538	e1de92b4	 ldrh        r9, [lr, #0x24]
  0053c	e0836001	 add         r6, r3, r1

; 343  :             count = 0;

  00540	13a05000	 movne       r5, #0
  00544	e0421001	 sub         r1, r2, r1
  00548	1a000006	 bne         |$LN10@IssueRxTra|

; 344  :         } else if ((stat & USBD_STAT_FIFO_FULL) != 0) {

  0054c	e3100001	 tst         r0, #1

; 345  :             count = maxSize;

  00550	11a05009	 movne       r5, r9
  00554	1a000003	 bne         |$LN10@IssueRxTra|

; 346  :         } else {
; 347  :             count = INREG32(&pUSBDRegs->RXFSTAT) & USBD_RFXSTAT_COUNT;

  00558	e5972014	 ldr         r2, [r7, #0x14]
  0055c	e3a03c03	 mov         r3, #3, 24
  00560	e38330ff	 orr         r3, r3, #0xFF
  00564	e0025003	 and         r5, r2, r3
  00568		 |$LN10@IssueRxTra|

; 348  :         }
; 349  : 
; 350  :         // Read data
; 351  :         remain = count;

  00568	e1a00005	 mov         r0, r5

; 352  :         while (remain > 1) {

  0056c	e3550001	 cmp         r5, #1
  00570	9a00000e	 bls         |$LN8@IssueRxTra|
  00574	e2453002	 sub         r3, r5, #2
  00578	e1a030a3	 mov         r3, r3, lsr #1
  0057c	e283e001	 add         lr, r3, #1
  00580		 |$LL9@IssueRxTra|

; 353  :             data = (WORD)INREG32(&pUSBDRegs->DATA);

  00580	e5972008	 ldr         r2, [r7, #8]

; 354  :             if (space > 1) {

  00584	e3510001	 cmp         r1, #1
  00588	9a000004	 bls         |$LN7@IssueRxTra|

; 355  :                 pBuffer[0] = (UCHAR)data;
; 356  :                 pBuffer[1] = (UCHAR)(data >> 8);

  0058c	e1a03422	 mov         r3, r2, lsr #8
  00590	e5c63001	 strb        r3, [r6, #1]
  00594	e5c62000	 strb        r2, [r6]

; 357  :                 pBuffer += 2;

  00598	e2866002	 add         r6, r6, #2

; 358  :                 space -= 2;

  0059c	e2411002	 sub         r1, r1, #2
  005a0		 |$LN7@IssueRxTra|

; 359  :             }
; 360  :             remain -= 2;

  005a0	e2400002	 sub         r0, r0, #2
  005a4	e25ee001	 subs        lr, lr, #1
  005a8	1afffff4	 bne         |$LL9@IssueRxTra|

; 297  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 298  :     STransfer *pTransfer;
; 299  :     BOOL complete = FALSE;
; 300  :     DWORD epNum, stat, space, count, remain, maxSize;
; 301  :     UCHAR *pBuffer;
; 302  :     WORD data;
; 303  : 
; 304  :     // Get active transfer
; 305  :     pTransfer = pPdd->ep[endPoint].pTransfer;
; 306  : 
; 307  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 308  :         L"UsbFnPdd!IssueRxTransfer: EP %d pTransfer 0x%x (%d, %d, %d)\r\n",
; 309  :         endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 310  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 311  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 312  :     ));

  005ac	e59de008	 ldr         lr, [sp, #8]
  005b0		 |$LN8@IssueRxTra|

; 361  :         }
; 362  :         if (remain > 0) {

  005b0	e3500000	 cmp         r0, #0

; 363  :             data = (WORD)INREG32(&pUSBDRegs->DATA);

  005b4	15973008	 ldrne       r3, [r7, #8]

; 364  :             if (space > 0) {

  005b8	13510000	 cmpne       r1, #0

; 365  :                 *pBuffer = (UCHAR)data;
; 366  :                 pBuffer += 1;
; 367  :                 space -= 1;

  005bc	12411001	 subne       r1, r1, #1
  005c0	15c63000	 strneb      r3, [r6]

; 368  :             }
; 369  :             remain -= 1;
; 370  :         }
; 371  : 
; 372  :         // We transfered some data
; 373  :         pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  005c4	e594200c	 ldr         r2, [r4, #0xC]
  005c8	e0423001	 sub         r3, r2, r1
  005cc	e5843010	 str         r3, [r4, #0x10]

; 374  : 
; 375  :         // Is this end of transfer?
; 376  :         if (
; 377  :             pTransfer->cbTransferred == pTransfer->cbBuffer || count < maxSize
; 378  :         ) {

  005d0	e1530002	 cmp         r3, r2
  005d4	0a000005	 beq         |$LN3@IssueRxTra|
  005d8	e1550009	 cmp         r5, r9
  005dc	3a000003	 bcc         |$LN3@IssueRxTra|

; 383  :         } else {
; 384  :             // No, enable FIFO for next packet
; 385  :             OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  005e0	e3a03004	 mov         r3, #4
  005e4	e587300c	 str         r3, [r7, #0xC]
  005e8	e3a02000	 mov         r2, #0
  005ec	ea000002	 b           |$clean$46735|
  005f0		 |$LN3@IssueRxTra|

; 379  :             // Yes, set return code
; 380  :             pTransfer->dwUsbError = UFN_NO_ERROR;

  005f0	e3a02000	 mov         r2, #0
  005f4	e5842014	 str         r2, [r4, #0x14]

; 381  :             // And complete flag
; 382  :             complete = TRUE;

  005f8	e3a0a001	 mov         r10, #1
  005fc		 |$clean$46735|

; 386  :         }
; 387  : 
; 388  : clean:
; 389  : 
; 390  :     // Deselect EP
; 391  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  005fc	e587b004	 str         r11, [r7, #4]

; 392  : 
; 393  :     // If transaction is complete we should tell MDD
; 394  :     if (complete) {

  00600	e35a0000	 cmp         r10, #0
  00604	0a000006	 beq         |$LN1@IssueRxTra|

; 395  :         pPdd->ep[endPoint].pTransfer = NULL;

  00608	e58e2030	 str         r2, [lr, #0x30]

; 396  :         pPdd->pfnNotify(
; 397  :             pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 398  :         );

  0060c	e5980000	 ldr         r0, [r8]
  00610	e5983004	 ldr         r3, [r8, #4]
  00614	e1a02004	 mov         r2, r4
  00618	e3a01064	 mov         r1, #0x64
  0061c	e1a0e00f	 mov         lr, pc
  00620	e12fff13	 bx          r3
  00624		 |$LN1@IssueRxTra|

; 399  :     }
; 400  : }

  00624	e28dd00c	 add         sp, sp, #0xC
  00628	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0062c	e12fff1e	 bx          lr
  00630		 |$LN31@IssueRxTra|
  00630		 |$LN32@IssueRxTra|
  00630	00000000	 DCD         |??_C@_1HM@BCFIOLEH@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@|
  00634		 |$LN33@IssueRxTra|
  00634	00000000	 DCD         |dpCurSettings|
  00638		 |$M47424|

			 ENDP  ; |IssueRxTransfer|

	EXPORT	|??_C@_1GI@OPBGFKOJ@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAD?$AAe?$AAv?$AAS?$AAt?$AAa?$AAt?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?3?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAs?$AAt@| [ DATA ] ; `string'

  00020			 AREA	 |.pdata|, PDATA
|$T47441| DCD	|$LN16@DevStatEve|
	DCD	0x40005c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@OPBGFKOJ@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAD?$AAe?$AAv?$AAS?$AAt?$AAa?$AAt?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?3?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAs?$AAt@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "E", 0x0, "v", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "D", 0x0, "e"
	DCB	0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "x", 0x0, ",", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "g", 0x0, "e", 0x0, " ", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  00638			 AREA	 |.text|, CODE, ARM

  00638		 |DevStatEvent| PROC

; 409  : {

  00638		 |$LN16@DevStatEve|
  00638	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0063c		 |$M47438|
  0063c	e1a04000	 mov         r4, r0

; 410  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00640	e5947008	 ldr         r7, [r4, #8]

; 411  :     DWORD state, change;
; 412  : 
; 413  :     // Get device state & change
; 414  :     state = INREG32(&pUSBDRegs->DEVSTAT);
; 415  :     change = state ^ pPdd->devState;
; 416  : 
; 417  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 418  :         L"UsbFnPdd!DevStatEvent: Device state %x, change %x\r\n",
; 419  :         state, change
; 420  :     ));

  00644	e59f3158	 ldr         r3, [pc, #0x158]
  00648	e5942010	 ldr         r2, [r4, #0x10]
  0064c	e5975020	 ldr         r5, [r7, #0x20]
  00650	e5933440	 ldr         r3, [r3, #0x440]
  00654	e0226005	 eor         r6, r2, r5
  00658	e3130a02	 tst         r3, #2, 20
  0065c	0a000005	 beq         |$LN11@DevStatEve|
  00660	e3130004	 tst         r3, #4
  00664	0a000003	 beq         |$LN11@DevStatEve|
  00668	e59f0130	 ldr         r0, [pc, #0x130]
  0066c	e1a02006	 mov         r2, r6
  00670	e1a01005	 mov         r1, r5
  00674	eb000000	 bl          NKDbgPrintfW
  00678		 |$LN11@DevStatEve|

; 421  : 
; 422  : #ifdef USE_OLD_CABLE_DETECT_METHOD
; 423  :     // Attach/deattach
; 424  :     if ((change & USBD_DEVSTAT_ATT) != 0) {
; 425  :         if ((state & USBD_DEVSTAT_ATT) != 0) {
; 426  :             // TODO: Call bus driver (OTG?) to move HW from deep sleep
; 427  :             // Let MDD process change
; 428  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);
; 429  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED, BS_FULL_SPEED);
; 430  :         } else {
; 431  :             // Clear source bit
; 432  :             // We are not configured anymore
; 433  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);
; 434  :             // TODO: Call bus driver (OTG?) to move HW to deep sleep
; 435  :             // Let MDD process change
; 436  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);
; 437  :             // Don't process other changes (we are disconnected)
; 438  :             goto clean;
; 439  :         }
; 440  :     }
; 441  : #endif // USE_OLD_CABLE_DETECT_METHOD
; 442  : 
; 443  :     // Reset
; 444  :     if ((change & (USBD_DEVSTAT_USB_RESET|USBD_DEVSTAT_DEF)) != 0) {

  00678	e3160022	 tst         r6, #0x22
  0067c	0a00001e	 beq         |$LN8@DevStatEve|

; 445  :         if ((state & USBD_DEVSTAT_USB_RESET) == 0) {

  00680	e3150020	 tst         r5, #0x20
  00684	1a000017	 bne         |$LN7@DevStatEve|

; 446  :             // OTG may not detect attach/detach events correctly on some platforms
; 447  :             // Simulate a attach/detach event to clear any previous state on reset
; 448  :             // Let MDD process change
; 449  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  00688	e5940000	 ldr         r0, [r4]
  0068c	e5943004	 ldr         r3, [r4, #4]
  00690	e3a02000	 mov         r2, #0
  00694	e3a01001	 mov         r1, #1
  00698	e1a0e00f	 mov         lr, pc
  0069c	e12fff13	 bx          r3

; 450  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);

  006a0	e5940000	 ldr         r0, [r4]
  006a4	e5943004	 ldr         r3, [r4, #4]
  006a8	e3a02001	 mov         r2, #1
  006ac	e3a01001	 mov         r1, #1
  006b0	e1a0e00f	 mov         lr, pc
  006b4	e12fff13	 bx          r3

; 451  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED, BS_FULL_SPEED);

  006b8	e5940000	 ldr         r0, [r4]
  006bc	e5943004	 ldr         r3, [r4, #4]
  006c0	e3a02001	 mov         r2, #1
  006c4	e3a01003	 mov         r1, #3
  006c8	e1a0e00f	 mov         lr, pc
  006cc	e12fff13	 bx          r3

; 452  :             // Tell MDD about reset...
; 453  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESET);

  006d0	e5940000	 ldr         r0, [r4]
  006d4	e5943004	 ldr         r3, [r4, #4]
  006d8	e3a02002	 mov         r2, #2
  006dc	e3a01001	 mov         r1, #1
  006e0	e1a0e00f	 mov         lr, pc
  006e4	e12fff13	 bx          r3
  006e8		 |$LN7@DevStatEve|

; 454  :         }
; 455  :         // Enable interrupts
; 456  :         OUTREG32(&pUSBDRegs->IRQ_EN, USBD_IRQ_MASK);

  006e8	e3a03039	 mov         r3, #0x39
  006ec	e5873028	 str         r3, [r7, #0x28]

; 484  :         }
; 485  :     }
; 486  : 
; 487  : clean:
; 488  :     // Save device state for next interrupt
; 489  :     pPdd->devState = state;

  006f0	e5845010	 str         r5, [r4, #0x10]
  006f4		 |$clean$46782|

; 490  : }

  006f4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  006f8	e12fff1e	 bx          lr
  006fc		 |$LN8@DevStatEve|

; 457  :         // In the middle of a reset don't process other changes
; 458  :         goto clean;
; 459  :     }
; 460  : 
; 461  :     // Suspend/resume
; 462  :     if ((change & USBD_DEVSTAT_SUS) != 0) {

  006fc	e3160010	 tst         r6, #0x10
  00700	0a00000c	 beq         |$LN4@DevStatEve|

; 463  :         if ((state & USBD_DEVSTAT_SUS) != 0) {
; 464  :             // Let MDD process change
; 465  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_SUSPEND);

  00704	e5940000	 ldr         r0, [r4]
  00708	e5943004	 ldr         r3, [r4, #4]
  0070c	e3150010	 tst         r5, #0x10
  00710	e3a01001	 mov         r1, #1
  00714	0a000004	 beq         |$LN5@DevStatEve|
  00718	e3a02003	 mov         r2, #3
  0071c	e1a0e00f	 mov         lr, pc
  00720	e12fff13	 bx          r3

; 466  :             // Read device status
; 467  :             INREG32(&pUSBDRegs->DEVSTAT);

  00724	e5973020	 ldr         r3, [r7, #0x20]

; 468  :         } else {

  00728	ea000002	 b           |$LN4@DevStatEve|
  0072c		 |$LN5@DevStatEve|

; 469  :             // Let MDD process change
; 470  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESUME);

  0072c	e3a02004	 mov         r2, #4
  00730	e1a0e00f	 mov         lr, pc
  00734	e12fff13	 bx          r3
  00738		 |$LN4@DevStatEve|

; 471  :         }
; 472  :     }
; 473  : 
; 474  : 
; 475  :     // Addressed
; 476  :     if ((change & USBD_DEVSTAT_ADD) != 0) {

  00738	e3160004	 tst         r6, #4
  0073c	0a000014	 beq         |$LN13@DevStatEve|

; 477  :         if ((state & USBD_DEVSTAT_ADD) != 0) {
; 478  :             // Let MDD process change
; 479  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SET_ADDRESS, 1);

  00740	e5940000	 ldr         r0, [r4]
  00744	e5943004	 ldr         r3, [r4, #4]
  00748	e3150004	 tst         r5, #4
  0074c	0a000006	 beq         |$LN2@DevStatEve|
  00750	e3a02001	 mov         r2, #1
  00754	e3a01006	 mov         r1, #6
  00758	e1a0e00f	 mov         lr, pc
  0075c	e12fff13	 bx          r3

; 484  :         }
; 485  :     }
; 486  : 
; 487  : clean:
; 488  :     // Save device state for next interrupt
; 489  :     pPdd->devState = state;

  00760	e5845010	 str         r5, [r4, #0x10]
  00764		 |$clean_1$46782|

; 490  : }

  00764	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00768	e12fff1e	 bx          lr
  0076c		 |$LN2@DevStatEve|

; 480  :         } else {
; 481  :             // Let MDD process change
; 482  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_CONFIGURED, 0 );

  0076c	e3a02000	 mov         r2, #0
  00770	e3a01002	 mov         r1, #2
  00774	e1a0e00f	 mov         lr, pc
  00778	e12fff13	 bx          r3

; 483  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SET_ADDRESS,0 );

  0077c	e5940000	 ldr         r0, [r4]
  00780	e5943004	 ldr         r3, [r4, #4]
  00784	e3a02000	 mov         r2, #0
  00788	e3a01006	 mov         r1, #6
  0078c	e1a0e00f	 mov         lr, pc
  00790	e12fff13	 bx          r3
  00794		 |$LN13@DevStatEve|

; 484  :         }
; 485  :     }
; 486  : 
; 487  : clean:
; 488  :     // Save device state for next interrupt
; 489  :     pPdd->devState = state;

  00794	e5845010	 str         r5, [r4, #0x10]
  00798		 |$clean_2$46782|

; 490  : }

  00798	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0079c	e12fff1e	 bx          lr
  007a0		 |$LN17@DevStatEve|
  007a0		 |$LN18@DevStatEve|
  007a0	00000000	 DCD         |??_C@_1GI@OPBGFKOJ@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAD?$AAe?$AAv?$AAS?$AAt?$AAa?$AAt?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?3?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAs?$AAt@|
  007a4		 |$LN19@DevStatEve|
  007a4	00000000	 DCD         |dpCurSettings|
  007a8		 |$M47439|

			 ENDP  ; |DevStatEvent|

	EXPORT	|UfnPdd_IssueTransfer|

  00028			 AREA	 |.pdata|, PDATA
|$T47460| DCD	|$LN11@UfnPdd_Iss|
	DCD	0x40002401
; Function compile flags: /Ogtp

  007a8			 AREA	 |.text|, CODE, ARM

  007a8		 |UfnPdd_IssueTransfer| PROC

; 582  : ) {

  007a8		 |$LN11@UfnPdd_Iss|
  007a8	e92d4030	 stmdb       sp!, {r4, r5, lr}
  007ac		 |$M47457|

; 583  :     USBFN_PDD *pPdd = pPddContext;
; 584  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 585  :     DWORD epNum;
; 586  : 
; 587  :     // Save transfer for interrupt thread
; 588  :     pPdd->ep[endPoint].pTransfer = pTransfer;

  007ac	e5904008	 ldr         r4, [r0, #8]
  007b0	e080e201	 add         lr, r0, r1, lsl #4
  007b4	e58e2030	 str         r2, [lr, #0x30]

; 589  :     // Sync Length with buffer
; 590  :      if (pTransfer->pvBuffer == NULL) pTransfer->cbBuffer = 0;

  007b8	e5923004	 ldr         r3, [r2, #4]
  007bc	e3a05000	 mov         r5, #0
  007c0	e3530000	 cmp         r3, #0

; 591  : 
; 592  :     // Depending on direction
; 593  :     if (TRANSFER_IS_IN(pTransfer)) {

  007c4	e5923000	 ldr         r3, [r2]
  007c8	0582500c	 streq       r5, [r2, #0xC]
  007cc	e3130080	 tst         r3, #0x80
  007d0	0a00000e	 beq         |$LN2@UfnPdd_Iss|

; 594  :         pPdd->ep[endPoint].zeroLength = (pTransfer->cbBuffer == 0);

  007d4	e592300c	 ldr         r3, [r2, #0xC]
  007d8	e3530000	 cmp         r3, #0
  007dc	1a000005	 bne         |$LN6@UfnPdd_Iss|
  007e0	e3a03001	 mov         r3, #1

; 595  :         IssueTxTransfer(pPdd, endPoint);

  007e4	e58e302c	 str         r3, [lr, #0x2C]
  007e8	eb000000	 bl          IssueTxTransfer

; 605  :     }
; 606  :     return ERROR_SUCCESS;

  007ec	e3a00000	 mov         r0, #0

; 607  : }

  007f0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  007f4	e12fff1e	 bx          lr
  007f8		 |$LN6@UfnPdd_Iss|

; 594  :         pPdd->ep[endPoint].zeroLength = (pTransfer->cbBuffer == 0);

  007f8	e3a03000	 mov         r3, #0

; 595  :         IssueTxTransfer(pPdd, endPoint);

  007fc	e58e302c	 str         r3, [lr, #0x2C]
  00800	eb000000	 bl          IssueTxTransfer

; 605  :     }
; 606  :     return ERROR_SUCCESS;

  00804	e3a00000	 mov         r0, #0

; 607  : }

  00808	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0080c	e12fff1e	 bx          lr
  00810		 |$LN2@UfnPdd_Iss|

; 596  :     } else {
; 597  :         pPdd->ep[endPoint].zeroLength = FALSE;
; 598  :         // Select EP
; 599  :         epNum = USBD_EP_NUM & endPoint;

  00810	e201200f	 and         r2, r1, #0xF

; 600  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00814	e3823020	 orr         r3, r2, #0x20
  00818	e58e502c	 str         r5, [lr, #0x2C]
  0081c	e5843004	 str         r3, [r4, #4]

; 601  :         // Enable EP FIFO
; 602  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00820	e3a03004	 mov         r3, #4
  00824	e584300c	 str         r3, [r4, #0xC]

; 603  :         // Deselect EP
; 604  :         OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00828	e5842004	 str         r2, [r4, #4]

; 605  :     }
; 606  :     return ERROR_SUCCESS;

  0082c	e3a00000	 mov         r0, #0

; 607  : }

  00830	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00834	e12fff1e	 bx          lr
  00838		 |$M47458|

			 ENDP  ; |UfnPdd_IssueTransfer|

	EXPORT	|UfnPdd_AbortTransfer|

  00030			 AREA	 |.pdata|, PDATA
|$T47472| DCD	|$LN6@UfnPdd_Abo|
	DCD	0x40001a01
; Function compile flags: /Ogtp

  00838			 AREA	 |.text|, CODE, ARM

  00838		 |UfnPdd_AbortTransfer| PROC

; 613  : ) {

  00838		 |$LN6@UfnPdd_Abo|
  00838	e92d4030	 stmdb       sp!, {r4, r5, lr}
  0083c		 |$M47469|
  0083c	e1a04000	 mov         r4, r0

; 614  :     USBFN_PDD *pPdd = pPddContext;
; 615  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 616  :     DWORD epNum;
; 617  : 
; 618  :     // Select EP
; 619  :     epNum = USBD_EP_NUM & endPoint;
; 620  :     if (TRANSFER_IS_IN(pTransfer)) epNum |= USBD_EP_NUM_DIRIN;

  00840	e5923000	 ldr         r3, [r2]
  00844	e5940008	 ldr         r0, [r4, #8]
  00848	e201e00f	 and         lr, r1, #0xF
  0084c	e3130080	 tst         r3, #0x80
  00850	138ee010	 orrne       lr, lr, #0x10

; 621  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00854	e38e3020	 orr         r3, lr, #0x20
  00858	e5803004	 str         r3, [r0, #4]

; 622  : 
; 623  :     // Clear EP
; 624  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);

  0085c	e3a03002	 mov         r3, #2
  00860	e580300c	 str         r3, [r0, #0xC]

; 625  : 
; 626  :     // Deselect EP
; 627  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 628  : 
; 629  :     // Finish transfer
; 630  :     pPdd->ep[endPoint].pTransfer = NULL;

  00864	e0843201	 add         r3, r4, r1, lsl #4
  00868	e3a01000	 mov         r1, #0
  0086c	e3a05c01	 mov         r5, #1, 24
  00870	e580e004	 str         lr, [r0, #4]
  00874	e5831030	 str         r1, [r3, #0x30]

; 631  :     pTransfer->dwUsbError = UFN_CANCELED_ERROR;

  00878	e3853001	 orr         r3, r5, #1
  0087c	e5823014	 str         r3, [r2, #0x14]

; 632  :     pPdd->pfnNotify(
; 633  :         pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 634  :     );

  00880	e5940000	 ldr         r0, [r4]
  00884	e5943004	 ldr         r3, [r4, #4]
  00888	e3a01064	 mov         r1, #0x64
  0088c	e1a0e00f	 mov         lr, pc
  00890	e12fff13	 bx          r3

; 635  : 
; 636  :     // Done
; 637  :     return ERROR_SUCCESS;

  00894	e3a00000	 mov         r0, #0

; 638  : }

  00898	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0089c	e12fff1e	 bx          lr
  008a0		 |$M47470|

			 ENDP  ; |UfnPdd_AbortTransfer|

	EXPORT	|UfnPdd_StallEndpoint|
	EXPORT	|??_C@_0CH@DMHGJEEN@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CKRead?5USBD?9?$DOSYSCON_2?9?9@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@FFFNHHBF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAa?$AAl?$AAl?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|KITLOutputDebugString|

  00038			 AREA	 |.pdata|, PDATA
|$T47487| DCD	|$LN11@UfnPdd_Sta|
	DCD	0x40002401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_0CH@DMHGJEEN@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CKRead?5USBD?9?$DOSYSCON_2?9?9@| DCB "*"
	DCB	"**********Read USBD->SYSCON_2---=%x", 0xd, 0xa, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@FFFNHHBF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAa?$AAl?$AAl?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o"
	DCB	0x0, "i", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  008a0			 AREA	 |.text|, CODE, ARM

  008a0		 |UfnPdd_StallEndpoint| PROC

; 647  : {

  008a0		 |$LN11@UfnPdd_Sta|
  008a0	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  008a4		 |$M47484|
  008a4	e1a04001	 mov         r4, r1
  008a8	e1a06000	 mov         r6, r0

; 648  :     USBFN_PDD *pPdd = pPddContext;
; 649  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 650  :     DWORD epNum;
; 651  : 
; 652  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 653  :         L"UsbFnPdd_StallEndpoint %d\r\n", endPoint
; 654  :     ));

  008ac	e59f3078	 ldr         r3, [pc, #0x78]
  008b0	e5965008	 ldr         r5, [r6, #8]
  008b4	e5933440	 ldr         r3, [r3, #0x440]
  008b8	e3130a02	 tst         r3, #2, 20
  008bc	13130004	 tstne       r3, #4
  008c0	159f0060	 ldrne       r0, [pc, #0x60]
  008c4	1b000000	 blne        NKDbgPrintfW

; 655  : 
; 656  :     if (endPoint == 0) {

  008c8	e3540000	 cmp         r4, #0
  008cc	1a000007	 bne         |$LN3@UfnPdd_Sta|

; 657  :         // Stall next EP0 transaction
; 658  :        OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_STALL_CMD);

  008d0	e3a03020	 mov         r3, #0x20

; 659  :        EdbgOutputDebugString("***********Read USBD->SYSCON_2---=%x\r\n", INREG32(&pUSBDRegs->SYSCON2));                     // 0080 - Endpoint 0 configuration

  008d4	e59f0048	 ldr         r0, [pc, #0x48]
  008d8	e585301c	 str         r3, [r5, #0x1C]
  008dc	e595101c	 ldr         r1, [r5, #0x1C]
  008e0	eb000000	 bl          KITLOutputDebugString

; 666  :         
; 667  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 668  : 
; 669  :         // Halt EP
; 670  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_SET_HALT);
; 671  : 
; 672  :         // Deselect EP
; 673  :         OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 674  :     }
; 675  : 
; 676  :     // Done
; 677  :     return ERROR_SUCCESS;

  008e4	e3a00000	 mov         r0, #0

; 678  : }

  008e8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  008ec	e12fff1e	 bx          lr
  008f0		 |$LN3@UfnPdd_Sta|

; 660  : 
; 661  :     } else {
; 662  : 
; 663  :         // Select EP
; 664  :         epNum = USBD_EP_NUM & endPoint;
; 665  :         if (!pPdd->ep[endPoint].dirRx) epNum |= USBD_EP_NUM_DIRIN;

  008f0	e0863204	 add         r3, r6, r4, lsl #4
  008f4	e5933028	 ldr         r3, [r3, #0x28]
  008f8	e204200f	 and         r2, r4, #0xF

; 666  :         
; 667  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 668  : 
; 669  :         // Halt EP
; 670  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_SET_HALT);
; 671  : 
; 672  :         // Deselect EP
; 673  :         OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 674  :     }
; 675  : 
; 676  :     // Done
; 677  :     return ERROR_SUCCESS;

  008fc	e3a00000	 mov         r0, #0
  00900	e3530000	 cmp         r3, #0
  00904	03822010	 orreq       r2, r2, #0x10
  00908	e3823020	 orr         r3, r2, #0x20
  0090c	e5853004	 str         r3, [r5, #4]
  00910	e3a03040	 mov         r3, #0x40
  00914	e585300c	 str         r3, [r5, #0xC]
  00918	e5852004	 str         r2, [r5, #4]

; 678  : }

  0091c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00920	e12fff1e	 bx          lr
  00924		 |$LN12@UfnPdd_Sta|
  00924		 |$LN13@UfnPdd_Sta|
  00924	00000000	 DCD         |??_C@_0CH@DMHGJEEN@?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CK?$CKRead?5USBD?9?$DOSYSCON_2?9?9@|
  00928		 |$LN14@UfnPdd_Sta|
  00928	00000000	 DCD         |??_C@_1DI@FFFNHHBF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAa?$AAl?$AAl?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  0092c		 |$LN15@UfnPdd_Sta|
  0092c	00000000	 DCD         |dpCurSettings|
  00930		 |$M47485|

			 ENDP  ; |UfnPdd_StallEndpoint|

	EXPORT	|UfnPdd_ClearEndpointStall|
	EXPORT	|??_C@_1DI@EBJLFADF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00040			 AREA	 |.pdata|, PDATA
|$T47508| DCD	|$LN10@UfnPdd_Cle|
	DCD	0x40001e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@EBJLFADF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "C", 0x0, "l", 0x0, "e", 0x0, "a"
	DCB	0x0, "r", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o"
	DCB	0x0, "i", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  00930			 AREA	 |.text|, CODE, ARM

  00930		 |UfnPdd_ClearEndpointStall| PROC

; 687  : {

  00930		 |$LN10@UfnPdd_Cle|
  00930	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00934		 |$M47505|
  00934	e1a04001	 mov         r4, r1
  00938	e1a06000	 mov         r6, r0

; 688  :     DWORD rc = ERROR_INVALID_FUNCTION;
; 689  :     USBFN_PDD *pPdd = pPddContext;
; 690  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 691  :     DWORD epNum;
; 692  : 
; 693  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 694  :         L"UsbFnPdd_ClearEndpoint %d\r\n", endPoint
; 695  :     ));

  0093c	e59f3060	 ldr         r3, [pc, #0x60]
  00940	e5965008	 ldr         r5, [r6, #8]
  00944	e5933440	 ldr         r3, [r3, #0x440]
  00948	e3130a02	 tst         r3, #2, 20
  0094c	13130004	 tstne       r3, #4
  00950	159f0048	 ldrne       r0, [pc, #0x48]
  00954	1b000000	 blne        NKDbgPrintfW

; 696  : 
; 697  :     // Endpoint can't be zero
; 698  :     if (endPoint == 0) goto clean;

  00958	e3540000	 cmp         r4, #0
  0095c	0a00000c	 beq         |$LN7@UfnPdd_Cle|

; 699  :     
; 700  :     // Select EP
; 701  :     epNum = USBD_EP_NUM & endPoint;
; 702  :     if (!pPdd->ep[endPoint].dirRx) epNum |= USBD_EP_NUM_DIRIN;

  00960	e0863204	 add         r3, r6, r4, lsl #4
  00964	e5933028	 ldr         r3, [r3, #0x28]
  00968	e204200f	 and         r2, r4, #0xF

; 703  : 
; 704  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 705  : 
; 706  :     // Reset endpoint - clear halt isn't sufficient
; 707  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_RESET_EP);
; 708  : 
; 709  :     // Deselect EP
; 710  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 711  : 
; 712  :     // Done
; 713  :     rc = ERROR_SUCCESS;

  0096c	e3a00000	 mov         r0, #0
  00970	e3530000	 cmp         r3, #0
  00974	03822010	 orreq       r2, r2, #0x10
  00978	e3823020	 orr         r3, r2, #0x20
  0097c	e5853004	 str         r3, [r5, #4]
  00980	e3a03001	 mov         r3, #1
  00984	e585300c	 str         r3, [r5, #0xC]
  00988	e5852004	 str         r2, [r5, #4]

; 714  : 
; 715  : clean:
; 716  :     return rc;
; 717  : }

  0098c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00990	e12fff1e	 bx          lr
  00994		 |$LN7@UfnPdd_Cle|
  00994	e3a00001	 mov         r0, #1
  00998		 |$clean$46904|
  00998	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0099c	e12fff1e	 bx          lr
  009a0		 |$LN11@UfnPdd_Cle|
  009a0		 |$LN12@UfnPdd_Cle|
  009a0	00000000	 DCD         |??_C@_1DI@EBJLFADF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  009a4		 |$LN13@UfnPdd_Cle|
  009a4	00000000	 DCD         |dpCurSettings|
  009a8		 |$M47506|

			 ENDP  ; |UfnPdd_ClearEndpointStall|

	EXPORT	|UfnPdd_IsEndpointHalted|
	EXPORT	|??_C@_1DO@MLIBPKBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAH?$AAa?$AAl?$AAt?$AAe?$AAd?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00048			 AREA	 |.pdata|, PDATA
|$T47531| DCD	|$LN12@UfnPdd_IsE|
	DCD	0x40002801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@MLIBPKBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAH?$AAa?$AAl?$AAt?$AAe?$AAd?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "I", 0x0, "s", 0x0, "E", 0x0, "n"
	DCB	0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t"
	DCB	0x0, "H", 0x0, "a", 0x0, "l", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogtp

  009a8			 AREA	 |.text|, CODE, ARM

  009a8		 |UfnPdd_IsEndpointHalted| PROC

; 725  : ) {

  009a8		 |$LN12@UfnPdd_IsE|
  009a8	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  009ac		 |$M47528|
  009ac	e1a07002	 mov         r7, r2
  009b0	e1a04001	 mov         r4, r1
  009b4	e1a06000	 mov         r6, r0

; 726  :     DWORD rc = ERROR_INVALID_FUNCTION;
; 727  :     USBFN_PDD *pPdd = pPddContext;
; 728  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 729  :     DWORD epNum;
; 730  : 
; 731  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 732  :         L"UsbFnPdd_IsEndpointHalted %d\r\n", endPoint
; 733  :     ));

  009b8	e59f3084	 ldr         r3, [pc, #0x84]
  009bc	e5965008	 ldr         r5, [r6, #8]
  009c0	e5933440	 ldr         r3, [r3, #0x440]
  009c4	e3130a02	 tst         r3, #2, 20
  009c8	13130004	 tstne       r3, #4
  009cc	159f006c	 ldrne       r0, [pc, #0x6C]
  009d0	1b000000	 blne        NKDbgPrintfW

; 734  : 
; 735  :     // Endpoint can't be zero
; 736  :     if (endPoint == 0) goto clean;

  009d4	e3540000	 cmp         r4, #0
  009d8	0a000015	 beq         |$LN9@UfnPdd_IsE|

; 737  :     
; 738  : 
; 739  :     // Select EP
; 740  :     epNum = USBD_EP_NUM & endPoint;
; 741  :     if (!pPdd->ep[endPoint].dirRx) epNum |= USBD_EP_NUM_DIRIN;

  009dc	e0863204	 add         r3, r6, r4, lsl #4
  009e0	e5933028	 ldr         r3, [r3, #0x28]
  009e4	e204200f	 and         r2, r4, #0xF
  009e8	e3530000	 cmp         r3, #0
  009ec	03822010	 orreq       r2, r2, #0x10

; 742  : 
; 743  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  009f0	e3823020	 orr         r3, r2, #0x20
  009f4	e5853004	 str         r3, [r5, #4]

; 744  : 
; 745  :     // Is EP halted?
; 746  :     *pHalted = (INREG32(&pUSBDRegs->STAT_FLG) & USBD_STAT_HALTED) != 0;

  009f8	e5953010	 ldr         r3, [r5, #0x10]
  009fc	e3130040	 tst         r3, #0x40
  00a00	0a000005	 beq         |$LN7@UfnPdd_IsE|
  00a04	e3a03001	 mov         r3, #1
  00a08	e5873000	 str         r3, [r7]

; 747  : 
; 748  :     // Deselect EP
; 749  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00a0c	e5852004	 str         r2, [r5, #4]

; 750  : 
; 751  :     // Done
; 752  :     rc = ERROR_SUCCESS;

  00a10	e3a00000	 mov         r0, #0

; 753  :     
; 754  : clean:
; 755  :     return rc;
; 756  : }

  00a14	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00a18	e12fff1e	 bx          lr
  00a1c		 |$LN7@UfnPdd_IsE|

; 744  : 
; 745  :     // Is EP halted?
; 746  :     *pHalted = (INREG32(&pUSBDRegs->STAT_FLG) & USBD_STAT_HALTED) != 0;

  00a1c	e3a03000	 mov         r3, #0
  00a20	e5873000	 str         r3, [r7]

; 747  : 
; 748  :     // Deselect EP
; 749  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00a24	e5852004	 str         r2, [r5, #4]

; 750  : 
; 751  :     // Done
; 752  :     rc = ERROR_SUCCESS;

  00a28	e3a00000	 mov         r0, #0

; 753  :     
; 754  : clean:
; 755  :     return rc;
; 756  : }

  00a2c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00a30	e12fff1e	 bx          lr
  00a34		 |$LN9@UfnPdd_IsE|
  00a34	e3a00001	 mov         r0, #1
  00a38		 |$clean$46927|
  00a38	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00a3c	e12fff1e	 bx          lr
  00a40		 |$LN13@UfnPdd_IsE|
  00a40		 |$LN14@UfnPdd_IsE|
  00a40	00000000	 DCD         |??_C@_1DO@MLIBPKBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAH?$AAa?$AAl?$AAt?$AAe?$AAd?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00a44		 |$LN15@UfnPdd_IsE|
  00a44	00000000	 DCD         |dpCurSettings|
  00a48		 |$M47529|

			 ENDP  ; |UfnPdd_IsEndpointHalted|

	EXPORT	|UfnPdd_SendControlStatusHandshake|
	EXPORT	|??_C@_1GM@CFMOOMGC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAn?$AAd?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAH?$AAa?$AAn?$AAd?$AAh?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@| [ DATA ] ; `string'

  00050			 AREA	 |.pdata|, PDATA
|$T47550| DCD	|$LN11@UfnPdd_Sen|
	DCD	0x40002401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@CFMOOMGC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAn?$AAd?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAH?$AAa?$AAn?$AAd?$AAh?$AAa@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "S", 0x0, "e", 0x0, "n", 0x0, "d"
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o"
	DCB	0x0, "l", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "u"
	DCB	0x0, "s", 0x0, "H", 0x0, "a", 0x0, "n", 0x0, "d", 0x0, "h"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " ", 0x0, "("
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "%"
	DCB	0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@| DCB "O", 0x0, "U", 0x0, "T", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@| DCB "I", 0x0, "N", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogtp

  00a48			 AREA	 |.text|, CODE, ARM

  00a48		 |UfnPdd_SendControlStatusHandshake| PROC

; 766  : ) {

  00a48		 |$LN11@UfnPdd_Sen|
  00a48	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00a4c		 |$M47547|

; 767  :     USBFN_PDD *pPdd = pPddContext;
; 768  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 769  :     DWORD epNum, stat;
; 770  : 
; 771  :     // Select EP
; 772  :     epNum = USBD_EP_NUM & endPoint;
; 773  :     if (pPdd->setupDirRx) epNum |= USBD_EP_NUM_DIRIN;

  00a4c	e5903018	 ldr         r3, [r0, #0x18]
  00a50	e5905008	 ldr         r5, [r0, #8]
  00a54	e201400f	 and         r4, r1, #0xF
  00a58	e3530000	 cmp         r3, #0

; 774  : 
; 775  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 776  : 
; 777  :     // Get actual status
; 778  :     stat = INREG32(&pUSBDRegs->STAT_FLG);
; 779  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 780  :         L"UsbFnPdd_SendControlStatusHandhake: %d %s (stat %x)\r\n",
; 781  :         endPoint, pPdd->setupDirRx ? L"IN" : L"OUT", stat
; 782  :     ));

  00a5c	e59f2070	 ldr         r2, [pc, #0x70]
  00a60	13844010	 orrne       r4, r4, #0x10
  00a64	e3843020	 orr         r3, r4, #0x20
  00a68	e5853004	 str         r3, [r5, #4]
  00a6c	e5923440	 ldr         r3, [r2, #0x440]
  00a70	e5956010	 ldr         r6, [r5, #0x10]
  00a74	e3130a02	 tst         r3, #2, 20
  00a78	0a000008	 beq         |$LN5@UfnPdd_Sen|
  00a7c	e3130004	 tst         r3, #4
  00a80	0a000006	 beq         |$LN5@UfnPdd_Sen|
  00a84	e5903018	 ldr         r3, [r0, #0x18]
  00a88	e59f0040	 ldr         r0, [pc, #0x40]
  00a8c	e3530000	 cmp         r3, #0
  00a90	159f2034	 ldrne       r2, [pc, #0x34]
  00a94	059f202c	 ldreq       r2, [pc, #0x2C]
  00a98	e1a03006	 mov         r3, r6
  00a9c	eb000000	 bl          NKDbgPrintfW
  00aa0		 |$LN5@UfnPdd_Sen|

; 783  : 
; 784  :     // Don't send handshake when EP is stall
; 785  :     if ((stat & USBD_STAT_STALL) == 0) {

  00aa0	e3160020	 tst         r6, #0x20
  00aa4	1a000003	 bne         |$LN1@UfnPdd_Sen|

; 786  :         // Clear & enable FIFO
; 787  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);

  00aa8	e3a03002	 mov         r3, #2
  00aac	e585300c	 str         r3, [r5, #0xC]

; 788  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00ab0	e3a03004	 mov         r3, #4
  00ab4	e585300c	 str         r3, [r5, #0xC]
  00ab8		 |$LN1@UfnPdd_Sen|

; 789  :     }
; 790  : 
; 791  :     // Deselect EP
; 792  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00ab8	e5854004	 str         r4, [r5, #4]

; 793  :     return ERROR_SUCCESS;

  00abc	e3a00000	 mov         r0, #0

; 794  : }

  00ac0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00ac4	e12fff1e	 bx          lr
  00ac8		 |$LN12@UfnPdd_Sen|
  00ac8		 |$LN13@UfnPdd_Sen|
  00ac8	00000000	 DCD         |??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@|
  00acc		 |$LN14@UfnPdd_Sen|
  00acc	00000000	 DCD         |??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@|
  00ad0		 |$LN15@UfnPdd_Sen|
  00ad0	00000000	 DCD         |??_C@_1GM@CFMOOMGC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAn?$AAd?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAH?$AAa?$AAn?$AAd?$AAh?$AAa@|
  00ad4		 |$LN16@UfnPdd_Sen|
  00ad4	00000000	 DCD         |dpCurSettings|
  00ad8		 |$M47548|

			 ENDP  ; |UfnPdd_SendControlStatusHandshake|

	EXPORT	|UfnPdd_InitiateRemoteWakeup|
	EXPORT	|??_C@_1EA@KNMJPPBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAt?$AAe?$AAR?$AAe?$AAm?$AAo?$AAt?$AAe?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00058			 AREA	 |.pdata|, PDATA
|$T47566| DCD	|$LN7@UfnPdd_Ini|
	DCD	0x40001001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@KNMJPPBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAt?$AAe?$AAR?$AAe?$AAm?$AAo?$AAt?$AAe?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "i", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, "R", 0x0, "e"
	DCB	0x0, "m", 0x0, "o", 0x0, "t", 0x0, "e", 0x0, "W", 0x0, "a"
	DCB	0x0, "k", 0x0, "e", 0x0, "u", 0x0, "p", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00ad8			 AREA	 |.text|, CODE, ARM

  00ad8		 |UfnPdd_InitiateRemoteWakeup| PROC

; 801  : {

  00ad8		 |$LN7@UfnPdd_Ini|
  00ad8	e92d4010	 stmdb       sp!, {r4, lr}
  00adc		 |$M47563|

; 802  :     USBFN_PDD *pPdd = pPddContext;
; 803  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 804  : 
; 805  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"UsbFnPdd_InitiateRemoteWakeup\r\n"));

  00adc	e59f3030	 ldr         r3, [pc, #0x30]
  00ae0	e5904008	 ldr         r4, [r0, #8]
  00ae4	e5933440	 ldr         r3, [r3, #0x440]
  00ae8	e3130a02	 tst         r3, #2, 20
  00aec	13130004	 tstne       r3, #4
  00af0	159f0018	 ldrne       r0, [pc, #0x18]
  00af4	1b000000	 blne        NKDbgPrintfW

; 806  :     SETREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_RMT_WKP);

  00af8	e594301c	 ldr         r3, [r4, #0x1C]

; 807  :     return ERROR_SUCCESS;

  00afc	e3a00000	 mov         r0, #0
  00b00	e3833040	 orr         r3, r3, #0x40
  00b04	e584301c	 str         r3, [r4, #0x1C]

; 808  : }

  00b08	e8bd4010	 ldmia       sp!, {r4, lr}
  00b0c	e12fff1e	 bx          lr
  00b10		 |$LN8@UfnPdd_Ini|
  00b10		 |$LN9@UfnPdd_Ini|
  00b10	00000000	 DCD         |??_C@_1EA@KNMJPPBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAt?$AAe?$AAR?$AAe?$AAm?$AAo?$AAt?$AAe?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AA?$AN?$AA?6?$AA?$AA@|
  00b14		 |$LN10@UfnPdd_Ini|
  00b14	00000000	 DCD         |dpCurSettings|
  00b18		 |$M47564|

			 ENDP  ; |UfnPdd_InitiateRemoteWakeup|

	EXPORT	|UfnPdd_PowerDown|

  00060			 AREA	 |.pdata|, PDATA
|$T47574| DCD	|$LN5@UfnPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogtp

  00b18			 AREA	 |.text|, CODE, ARM

  00b18		 |UfnPdd_PowerDown| PROC

; 815  : {

  00b18		 |$LN5@UfnPdd_Pow|
  00b18		 |$M47571|

; 816  : }

  00b18	e12fff1e	 bx          lr
  00b1c		 |$M47572|

			 ENDP  ; |UfnPdd_PowerDown|

	EXPORT	|UfnPdd_PowerUp|

  00068			 AREA	 |.pdata|, PDATA
|$T47579| DCD	|$LN5@UfnPdd_Pow@2|
	DCD	0x40000100
; Function compile flags: /Ogtp

  00b1c			 AREA	 |.text|, CODE, ARM

  00b1c		 |UfnPdd_PowerUp| PROC

; 823  : {

  00b1c		 |$LN5@UfnPdd_Pow@2|
  00b1c		 |$M47576|

; 824  : }

  00b1c	e12fff1e	 bx          lr
  00b20		 |$M47577|

			 ENDP  ; |UfnPdd_PowerUp|

	EXPORT	|UfnPdd_IOControl|

  00070			 AREA	 |.pdata|, PDATA
|$T47590| DCD	|$LN13@UfnPdd_IOC|
	DCD	0x40001400
; Function compile flags: /Ogtp

  00b20			 AREA	 |.text|, CODE, ARM

  00b20		 |UfnPdd_IOControl| PROC

; 833  : ) {

  00b20		 |$LN13@UfnPdd_IOC|
  00b20		 |$M47587|
  00b20	e3a03822	 mov         r3, #0x22, 16

; 834  :     DWORD rc = ERROR_INVALID_PARAMETER;
; 835  :     USBFN_PDD *pPdd = pPddContext;
; 836  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 837  :     UFN_PDD_INFO *pInfo;
; 838  : 
; 839  :     switch (code) {

  00b24	e3833f65	 orr         r3, r3, #0x65, 30
  00b28	e1520003	 cmp         r2, r3
  00b2c	e3a00057	 mov         r0, #0x57
  00b30	1a00000d	 bne         |$LN3@UfnPdd_IOC|

; 840  :     case IOCTL_UFN_GET_PDD_INFO:
; 841  :         if (source != BUS_IOCTL) break;

  00b34	e3510000	 cmp         r1, #0
  00b38	1a00000b	 bne         |$LN3@UfnPdd_IOC|

; 842  :         if (pOutBuffer == NULL || outSize < sizeof(UFN_PDD_INFO)) break;

  00b3c	e59d2004	 ldr         r2, [sp, #4]
  00b40	e3520000	 cmp         r2, #0
  00b44	0a000008	 beq         |$LN3@UfnPdd_IOC|
  00b48	e59d3008	 ldr         r3, [sp, #8]
  00b4c	e353000c	 cmp         r3, #0xC
  00b50	3a000005	 bcc         |$LN3@UfnPdd_IOC|

; 843  :         pInfo = (UFN_PDD_INFO*)pOutBuffer;
; 844  :         pInfo->InterfaceType = Internal;
; 845  :         pInfo->BusNumber = 0;
; 846  :         pInfo->dwAlignment = sizeof(DWORD);

  00b54	e3a03004	 mov         r3, #4
  00b58	e3a01000	 mov         r1, #0
  00b5c	e5823008	 str         r3, [r2, #8]
  00b60	e5821000	 str         r1, [r2]
  00b64	e5821004	 str         r1, [r2, #4]

; 847  :         rc = ERROR_SUCCESS;

  00b68	e3a00000	 mov         r0, #0
  00b6c		 |$LN3@UfnPdd_IOC|

; 848  :         break;
; 849  :     case IOCTL_BUS_GET_POWER_STATE:
; 850  :         break;
; 851  : 
; 852  :     case IOCTL_BUS_SET_POWER_STATE:
; 853  :         break;
; 854  :     }
; 855  :     
; 856  :     return rc;
; 857  : }

  00b6c	e12fff1e	 bx          lr
  00b70		 |$M47588|

			 ENDP  ; |UfnPdd_IOControl|

	EXPORT	|UfnPdd_Deinit|

  00078			 AREA	 |.pdata|, PDATA
|$T47600| DCD	|$LN7@UfnPdd_Dei|
	DCD	0x40000600
; Function compile flags: /Ogtp

  00b70			 AREA	 |.text|, CODE, ARM

  00b70		 |UfnPdd_Deinit| PROC

; 864  : {

  00b70		 |$LN7@UfnPdd_Dei|
  00b70		 |$M47597|

; 865  :     USBFN_PDD *pPdd = pPddContext;
; 866  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 867  : 
; 868  :     // Unmap USBD controller registers
; 869  :     if (pPdd->pUSBDRegs != NULL) {

  00b70	e5903008	 ldr         r3, [r0, #8]
  00b74	e3530000	 cmp         r3, #0

; 870  :         pPdd->pUSBDRegs = NULL;

  00b78	13a03000	 movne       r3, #0
  00b7c	15803008	 strne       r3, [r0, #8]

; 871  :     }
; 872  : 
; 873  :     // Done
; 874  :     return ERROR_SUCCESS;

  00b80	e3a00000	 mov         r0, #0

; 875  : }

  00b84	e12fff1e	 bx          lr
  00b88		 |$M47598|

			 ENDP  ; |UfnPdd_Deinit|

	EXPORT	|UfnPdd_DeregisterDevice|

  00080			 AREA	 |.pdata|, PDATA
|$T47611| DCD	|$LN10@UfnPdd_Der|
	DCD	0x40000c00
; Function compile flags: /Ogtp

  00b88			 AREA	 |.text|, CODE, ARM

  00b88		 |UfnPdd_DeregisterDevice| PROC

; 885  : {

  00b88		 |$LN10@UfnPdd_Der|
  00b88		 |$M47608|

; 886  :     USBFN_PDD *pPdd = pPddContext;
; 887  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00b88	e5903008	 ldr         r3, [r0, #8]

; 888  :     DWORD ep;
; 889  : 
; 890  :     // Disable all RX, TX EPs
; 891  :     OUTREG32(&pUSBDRegs->EP0, 0);

  00b8c	e3a01000	 mov         r1, #0
  00b90	e3a0200e	 mov         r2, #0xE
  00b94	e5831080	 str         r1, [r3, #0x80]
  00b98	e2833088	 add         r3, r3, #0x88
  00b9c		 |$LL3@UfnPdd_Der|

; 892  :     for (ep = 1; ep < USBD_NONZERO_EP_COUNT; ep++) {
; 893  :         OUTREG32(&pUSBDRegs->EP_RX[ep], 0);

  00b9c	e5831000	 str         r1, [r3]

; 894  :         OUTREG32(&pUSBDRegs->EP_TX[ep], 0);

  00ba0	e5831040	 str         r1, [r3, #0x40]
  00ba4	e2833004	 add         r3, r3, #4
  00ba8	e2522001	 subs        r2, r2, #1
  00bac	1afffffa	 bne         |$LL3@UfnPdd_Der|

; 895  :     }
; 896  : 
; 897  :     return ERROR_SUCCESS;

  00bb0	e3a00000	 mov         r0, #0

; 898  : }

  00bb4	e12fff1e	 bx          lr
  00bb8		 |$M47609|

			 ENDP  ; |UfnPdd_DeregisterDevice|

	EXPORT	|UfnPdd_Stop|
	EXPORT	|??_C@_1BM@ELBPNMDN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAo?$AAp?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|DisconnectHardware|

  00088			 AREA	 |.pdata|, PDATA
|$T47622| DCD	|$LN7@UfnPdd_Sto|
	DCD	0x40001101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@ELBPNMDN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAo?$AAp?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "S", 0x0, "t", 0x0, "o", 0x0, "p", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00bb8			 AREA	 |.text|, CODE, ARM

  00bb8		 |UfnPdd_Stop| PROC

; 909  : {

  00bb8		 |$LN7@UfnPdd_Sto|
  00bb8	e92d4010	 stmdb       sp!, {r4, lr}
  00bbc		 |$M47619|

; 910  :     USBFN_PDD *pPdd = pPddContext;
; 911  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 912  : 
; 913  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"UfnPdd_Stop\r\n"));

  00bbc	e59f3034	 ldr         r3, [pc, #0x34]
  00bc0	e5904008	 ldr         r4, [r0, #8]
  00bc4	e5933440	 ldr         r3, [r3, #0x440]
  00bc8	e3130a02	 tst         r3, #2, 20
  00bcc	13130004	 tstne       r3, #4
  00bd0	159f001c	 ldrne       r0, [pc, #0x1C]
  00bd4	1b000000	 blne        NKDbgPrintfW

; 914  : 
; 915  :     // Deattach device
; 916  :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  00bd8	e5943018	 ldr         r3, [r4, #0x18]
  00bdc	e3c33001	 bic         r3, r3, #1
  00be0	e5843018	 str         r3, [r4, #0x18]

; 917  :     DisconnectHardware();

  00be4	eb000000	 bl          DisconnectHardware

; 918  : 
; 919  :     // Disable USB device PLL clock
; 920  :     // ClkRelease(pPdd->hClk, 1); @todo
; 921  : 
; 922  :     // Done
; 923  :     return ERROR_SUCCESS;

  00be8	e3a00000	 mov         r0, #0

; 924  : }

  00bec	e8bd4010	 ldmia       sp!, {r4, lr}
  00bf0	e12fff1e	 bx          lr
  00bf4		 |$LN8@UfnPdd_Sto|
  00bf4		 |$LN9@UfnPdd_Sto|
  00bf4	00000000	 DCD         |??_C@_1BM@ELBPNMDN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAo?$AAp?$AA?$AN?$AA?6?$AA?$AA@|
  00bf8		 |$LN10@UfnPdd_Sto|
  00bf8	00000000	 DCD         |dpCurSettings|
  00bfc		 |$M47620|

			 ENDP  ; |UfnPdd_Stop|

	EXPORT	|UfnPdd_DeinitEndpoint|
	EXPORT	|??_C@_1DI@DNFBFJFI@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00090			 AREA	 |.pdata|, PDATA
|$T47638| DCD	|$LN7@UfnPdd_Dei@2|
	DCD	0x40001401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@DNFBFJFI@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "E", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i"
	DCB	0x0, "n", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  00bfc			 AREA	 |.text|, CODE, ARM

  00bfc		 |UfnPdd_DeinitEndpoint| PROC

; 934  : {

  00bfc		 |$LN7@UfnPdd_Dei@2|
  00bfc	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00c00		 |$M47635|
  00c00	e1a04001	 mov         r4, r1

; 935  :     USBFN_PDD *pPdd = pPddContext;
; 936  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 937  :     DWORD epNum;
; 938  : 
; 939  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"UfnPdd_DeinitEndpoint: %d\r\n", endPoint));

  00c04	e59f303c	 ldr         r3, [pc, #0x3C]
  00c08	e5905008	 ldr         r5, [r0, #8]
  00c0c	e5933440	 ldr         r3, [r3, #0x440]
  00c10	e3130a02	 tst         r3, #2, 20
  00c14	13130004	 tstne       r3, #4
  00c18	159f0024	 ldrne       r0, [pc, #0x24]
  00c1c	1b000000	 blne        NKDbgPrintfW

; 940  : 
; 941  :     // Select EP
; 942  :     epNum = USBD_EP_NUM & endPoint;

  00c20	e204200f	 and         r2, r4, #0xF

; 943  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00c24	e3823020	 orr         r3, r2, #0x20
  00c28	e5853004	 str         r3, [r5, #4]

; 944  : 
; 945  :     // Clear EP
; 946  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);

  00c2c	e3a03002	 mov         r3, #2
  00c30	e585300c	 str         r3, [r5, #0xC]

; 947  : 
; 948  :     // Deselect EP
; 949  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00c34	e5852004	 str         r2, [r5, #4]

; 950  : 
; 951  :     // Done
; 952  :     return ERROR_SUCCESS;

  00c38	e3a00000	 mov         r0, #0

; 953  : }

  00c3c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00c40	e12fff1e	 bx          lr
  00c44		 |$LN8@UfnPdd_Dei@2|
  00c44		 |$LN9@UfnPdd_Dei@2|
  00c44	00000000	 DCD         |??_C@_1DI@DNFBFJFI@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00c48		 |$LN10@UfnPdd_Dei@2|
  00c48	00000000	 DCD         |dpCurSettings|
  00c4c		 |$M47636|

			 ENDP  ; |UfnPdd_DeinitEndpoint|

	EXPORT	|UfnPdd_InitEndpoint|
	EXPORT	|??_C@_1DE@CLEBGKIE@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00098			 AREA	 |.pdata|, PDATA
|$T47655| DCD	|$LN9@UfnPdd_Ini@2|
	DCD	0x40000c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@CLEBGKIE@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "E", 0x0, "n"
	DCB	0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00c4c			 AREA	 |.text|, CODE, ARM

  00c4c		 |UfnPdd_InitEndpoint| PROC

; 967  : ) {

  00c4c		 |$LN9@UfnPdd_Ini@2|
  00c4c	e52de004	 str         lr, [sp, #-4]!
  00c50		 |$M47652|

; 968  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 969  :         L"UfnPdd_InitEndpoint: %d\r\n", endPoint
; 970  :     ));

  00c50	e59f3020	 ldr         r3, [pc, #0x20]
  00c54	e5933440	 ldr         r3, [r3, #0x440]
  00c58	e3130a02	 tst         r3, #2, 20
  00c5c	13130004	 tstne       r3, #4
  00c60	159f000c	 ldrne       r0, [pc, #0xC]
  00c64	1b000000	 blne        NKDbgPrintfW

; 971  :     return ERROR_SUCCESS;

  00c68	e3a00000	 mov         r0, #0

; 972  : }

  00c6c	e49de004	 ldr         lr, [sp], #4
  00c70	e12fff1e	 bx          lr
  00c74		 |$LN10@UfnPdd_Ini@2|
  00c74		 |$LN11@UfnPdd_Ini@2|
  00c74	00000000	 DCD         |??_C@_1DE@CLEBGKIE@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00c78		 |$LN12@UfnPdd_Ini@2|
  00c78	00000000	 DCD         |dpCurSettings|
  00c7c		 |$M47653|

			 ENDP  ; |UfnPdd_InitEndpoint|

	EXPORT	|UfnPdd_SetAddress|
	EXPORT	|??_C@_1DA@IMJLDCBL@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAt?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  000a0			 AREA	 |.pdata|, PDATA
|$T47672| DCD	|$LN9@UfnPdd_Set|
	DCD	0x40000c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@IMJLDCBL@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAt?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "S", 0x0, "e", 0x0, "t", 0x0, "A", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogtp

  00c7c			 AREA	 |.text|, CODE, ARM

  00c7c		 |UfnPdd_SetAddress| PROC

; 982  : {

  00c7c		 |$LN9@UfnPdd_Set|
  00c7c	e52de004	 str         lr, [sp, #-4]!
  00c80		 |$M47669|

; 983  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 984  :         L"UfnPdd_SetAddress: %d\r\n", address
; 985  :     ));

  00c80	e59f3020	 ldr         r3, [pc, #0x20]
  00c84	e5933440	 ldr         r3, [r3, #0x440]
  00c88	e3130a02	 tst         r3, #2, 20
  00c8c	13130004	 tstne       r3, #4
  00c90	159f000c	 ldrne       r0, [pc, #0xC]
  00c94	1b000000	 blne        NKDbgPrintfW

; 986  :     return ERROR_SUCCESS;

  00c98	e3a00000	 mov         r0, #0

; 987  : }

  00c9c	e49de004	 ldr         lr, [sp], #4
  00ca0	e12fff1e	 bx          lr
  00ca4		 |$LN10@UfnPdd_Set|
  00ca4		 |$LN11@UfnPdd_Set|
  00ca4	00000000	 DCD         |??_C@_1DA@IMJLDCBL@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAt?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00ca8		 |$LN12@UfnPdd_Set|
  00ca8	00000000	 DCD         |dpCurSettings|
  00cac		 |$M47670|

			 ENDP  ; |UfnPdd_SetAddress|

	EXPORT	|UfnPdd_Start|
	IMPORT	|OALStall|

  000a8			 AREA	 |.pdata|, PDATA
|$T47684| DCD	|$LN5@UfnPdd_Sta@2|
	DCD	0x40001001
; Function compile flags: /Ogtp

  00cac			 AREA	 |.text|, CODE, ARM

  00cac		 |UfnPdd_Start| PROC

; 997  : {

  00cac		 |$LN5@UfnPdd_Sta@2|
  00cac	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00cb0		 |$M47681|
  00cb0	e1a05000	 mov         r5, r0
  00cb4	e3a03c27	 mov         r3, #0x27, 24

; 998  :     USBFN_PDD *pPdd = pPddContext;
; 999  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1000 : 
; 1001 :     // Disconnect hardware
; 1002 :     //????DisconnectHardware();
; 1003 : 
; 1004 :     // Wait for while
; 1005 :     OALStall(10000);

  00cb8	e5954008	 ldr         r4, [r5, #8]
  00cbc	e3830010	 orr         r0, r3, #0x10
  00cc0	eb000000	 bl          OALStall

; 1006 : 
; 1007 :     // Enable interrupts
; 1008 :     OUTREG32(&pUSBDRegs->IRQ_EN, USBD_IRQ_MASK);

  00cc4	e3a03039	 mov         r3, #0x39
  00cc8	e5843028	 str         r3, [r4, #0x28]

; 1009 : 
; 1010 :     // Attach device to bus (it has no effect when OTG controller is used)
; 1011 :     SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN|USBD_SYSCON1_SELF_PWR);

  00ccc	e5943018	 ldr         r3, [r4, #0x18]

; 1012 : 	
; 1013 :     //?????ConnectHardware();
; 1014 : 
; 1015 :     // Set fake device change flag which on first interrupt force
; 1016 :     // device state change handler even if it isn't indicated by hardware
; 1017 :     pPdd->fakeDsChange = TRUE;

  00cd0	e3a02001	 mov         r2, #1

; 1018 : 
; 1019 :     // Done
; 1020 :     return ERROR_SUCCESS;

  00cd4	e3a00000	 mov         r0, #0
  00cd8	e3833005	 orr         r3, r3, #5
  00cdc	e5843018	 str         r3, [r4, #0x18]
  00ce0	e5852124	 str         r2, [r5, #0x124]

; 1021 : }

  00ce4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00ce8	e12fff1e	 bx          lr
  00cec		 |$M47682|

			 ENDP  ; |UfnPdd_Start|

	EXPORT	|UfnPdd_RegisterDevice|
	EXPORT	|??_C@_1FI@PHBINKHD@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@HDDLEHKG@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAE@| [ DATA ] ; `string'

  000b0			 AREA	 |.pdata|, PDATA
|$T47718| DCD	|$LN35@UfnPdd_Reg|
	DCD	0x4000ac02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@PHBINKHD@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAE@| DCB "+"
	DCB	0x0, "U", 0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, ":"
	DCB	0x0, ":", 0x0, " ", 0x0, "U", 0x0, "f", 0x0, "n", 0x0, "P"
	DCB	0x0, "d", 0x0, "d", 0x0, "_", 0x0, "R", 0x0, "e", 0x0, "g"
	DCB	0x0, "i", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "E", 0x0, "P", 0x0, "_", 0x0, "T", 0x0, "X", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@HDDLEHKG@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAE@| DCB "+"
	DCB	0x0, "U", 0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, ":"
	DCB	0x0, ":", 0x0, " ", 0x0, "U", 0x0, "f", 0x0, "n", 0x0, "P"
	DCB	0x0, "d", 0x0, "d", 0x0, "_", 0x0, "R", 0x0, "e", 0x0, "g"
	DCB	0x0, "i", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "D"
	DCB	0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "E", 0x0, "P", 0x0, "_", 0x0, "R", 0x0, "X", 0x0, " "
	DCB	0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00cec			 AREA	 |.text|, CODE, ARM

  00cec		 |UfnPdd_RegisterDevice| PROC

; 1042 : ) {

  00cec		 |$LN35@UfnPdd_Reg|
  00cec	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00cf0	e24dd00c	 sub         sp, sp, #0xC
  00cf4		 |$M47715|
  00cf4	e1a05000	 mov         r5, r0
  00cf8	e58d5008	 str         r5, [sp, #8]

; 1043 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1044 :     USBFN_PDD *pPdd = pPddContext;
; 1045 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1046 :     UFN_INTERFACE *pIFC;
; 1047 :     UFN_ENDPOINT *pEP;
; 1048 :     DWORD offset, ep, cfg;
; 1049 :     DWORD ifc, epx;
; 1050 : 
; 1051 : 
; 1052 :     // Remember self powered flag
; 1053 :     pPdd->selfPowered = (pFullSpeedConfig->Descriptor.bmAttributes & 0x20) != 0;

  00cfc	e59d6034	 ldr         r6, [sp, #0x34]
  00d00	e595a008	 ldr         r10, [r5, #8]

; 1054 : 
; 1055 :     // Unlock configuration
; 1056 :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_CFG_LOCK);
; 1057 : 
; 1058 :     // Configure EP0
; 1059 :     offset = 8;
; 1060 :     cfg  = Log2(pFullSpeedDeviceDesc->bMaxPacketSize0 >> 3) << 12;

  00d04	e59d4030	 ldr         r4, [sp, #0x30]
  00d08	e5d6300b	 ldrb        r3, [r6, #0xB]
  00d0c	e3130020	 tst         r3, #0x20
  00d10	13a03001	 movne       r3, #1
  00d14	03a03000	 moveq       r3, #0
  00d18	e5853014	 str         r3, [r5, #0x14]
  00d1c	e59a3018	 ldr         r3, [r10, #0x18]
  00d20	e3c33c01	 bic         r3, r3, #1, 24
  00d24	e58a3018	 str         r3, [r10, #0x18]
  00d28	e5d43007	 ldrb        r3, [r4, #7]
  00d2c	e1a001a3	 mov         r0, r3, lsr #3
  00d30	eb000000	 bl          Log2
  00d34	e1a03600	 mov         r3, r0, lsl #12

; 1061 :     cfg |= offset >> 3;

  00d38	e3833001	 orr         r3, r3, #1

; 1062 :     OUTREG32(&pUSBDRegs->EP0, cfg);

  00d3c	e58a3080	 str         r3, [r10, #0x80]

; 1063 :     pPdd->ep[0].maxPacketSize = pFullSpeedDeviceDesc->bMaxPacketSize0;

  00d40	e5d43007	 ldrb        r3, [r4, #7]

; 1064 :     offset += pFullSpeedDeviceDesc->bMaxPacketSize0;
; 1065 : 
; 1066 :     // Configure Rx EPs
; 1067 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++) {

  00d44	e3a01000	 mov         r1, #0
  00d48	e58d1000	 str         r1, [sp]
  00d4c	e1c532b4	 strh        r3, [r5, #0x24]
  00d50	e5d43007	 ldrb        r3, [r4, #7]
  00d54	e5d62008	 ldrb        r2, [r6, #8]
  00d58	e2835008	 add         r5, r3, #8
  00d5c	e3520000	 cmp         r2, #0
  00d60	0a00003f	 beq         |$LN18@UfnPdd_Reg|
  00d64	e3a0b000	 mov         r11, #0
  00d68	e58db004	 str         r11, [sp, #4]
  00d6c	e3a00001	 mov         r0, #1
  00d70		 |$LL20@UfnPdd_Reg|

; 1068 :         // For each endpoint in interface
; 1069 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00d70	e5963018	 ldr         r3, [r6, #0x18]

; 1070 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++) {

  00d74	e3a08000	 mov         r8, #0
  00d78	e08b9003	 add         r9, r11, r3
  00d7c	e5d93008	 ldrb        r3, [r9, #8]
  00d80	e3530000	 cmp         r3, #0
  00d84	0a00002f	 beq         |$LN19@UfnPdd_Reg|
  00d88	e59db008	 ldr         r11, [sp, #8]
  00d8c	e3a07000	 mov         r7, #0
  00d90		 |$LL17@UfnPdd_Reg|

; 1071 :             pEP = &pIFC->pEndpoints[epx];

  00d90	e5993018	 ldr         r3, [r9, #0x18]
  00d94	e0874003	 add         r4, r7, r3

; 1072 :             // If it is Tx EP skip it
; 1073 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) != 0) continue;

  00d98	e5d42006	 ldrb        r2, [r4, #6]
  00d9c	e3120080	 tst         r2, #0x80
  00da0	1a000020	 bne         |$LN16@UfnPdd_Reg|

; 1074 :             // Get EP address
; 1075 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 1076 :             // Save max packet size & direction
; 1077 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  00da4	e5d41008	 ldrb        r1, [r4, #8]
  00da8	e5d43009	 ldrb        r3, [r4, #9]
  00dac	e202600f	 and         r6, r2, #0xF
  00db0	e08b2206	 add         r2, r11, r6, lsl #4
  00db4	e1813403	 orr         r3, r1, r3, lsl #8
  00db8	e1c232b4	 strh        r3, [r2, #0x24]

; 1078 :             pPdd->ep[ep].dirRx = TRUE;

  00dbc	e5820028	 str         r0, [r2, #0x28]

; 1079 :             // Create EP config
; 1080 :             cfg  = USBD_EP_VALID;
; 1081 :             cfg |= Log2(pEP->Descriptor.wMaxPacketSize >> 3) << 12;

  00dc0	e5d42008	 ldrb        r2, [r4, #8]
  00dc4	e5d43009	 ldrb        r3, [r4, #9]
  00dc8	e1823403	 orr         r3, r2, r3, lsl #8
  00dcc	e1a001a3	 mov         r0, r3, lsr #3
  00dd0	eb000000	 bl          Log2

; 1082 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01) {

  00dd4	e5d43007	 ldrb        r3, [r4, #7]
  00dd8	e3802008	 orr         r2, r0, #8
  00ddc	e1a01602	 mov         r1, r2, lsl #12
  00de0	e2033003	 and         r3, r3, #3
  00de4	e3530001	 cmp         r3, #1

; 1083 :                 cfg |= USBD_EP_ISO;

  00de8	03811b02	 orreq       r1, r1, #2, 22

; 1084 :             }
; 1085 :             cfg |= offset >> 3;
; 1086 :             
; 1087 :             if (ep > 0)

  00dec	e3560000	 cmp         r6, #0
  00df0	0a000004	 beq         |$LN12@UfnPdd_Reg|

; 1088 :             OUTREG32(&pUSBDRegs->EP_RX[ep - 1], cfg);

  00df4	e2863020	 add         r3, r6, #0x20
  00df8	e08a2103	 add         r2, r10, r3, lsl #2
  00dfc	e18131a5	 orr         r3, r1, r5, lsr #3
  00e00	e5823000	 str         r3, [r2]

; 1089 :             else

  00e04	ea000002	 b           |$LN11@UfnPdd_Reg|
  00e08		 |$LN12@UfnPdd_Reg|

; 1090 :                 OALMSG(1, (L"+USBFN:: UfnPdd_RegisterDevice EP_RX = %d\r\n", ep - 1));

  00e08	e59f0188	 ldr         r0, [pc, #0x188]
  00e0c	e2461001	 sub         r1, r6, #1
  00e10	eb000000	 bl          NKDbgPrintfW
  00e14		 |$LN11@UfnPdd_Reg|

; 1091 :             
; 1092 :             // Update offset
; 1093 :             offset += pEP->Descriptor.wMaxPacketSize;

  00e14	e5d42008	 ldrb        r2, [r4, #8]
  00e18	e5d43009	 ldrb        r3, [r4, #9]
  00e1c	e3a00001	 mov         r0, #1
  00e20	e1823403	 orr         r3, r2, r3, lsl #8
  00e24	e0855003	 add         r5, r5, r3
  00e28		 |$LN16@UfnPdd_Reg|
  00e28	e5d93008	 ldrb        r3, [r9, #8]
  00e2c	e2888001	 add         r8, r8, #1
  00e30	e2877014	 add         r7, r7, #0x14
  00e34	e1580003	 cmp         r8, r3
  00e38	3affffd4	 bcc         |$LL17@UfnPdd_Reg|
  00e3c	e59db004	 ldr         r11, [sp, #4]
  00e40	e59d1000	 ldr         r1, [sp]
  00e44	e59d6034	 ldr         r6, [sp, #0x34]
  00e48		 |$LN19@UfnPdd_Reg|
  00e48	e5d63008	 ldrb        r3, [r6, #8]
  00e4c	e2811001	 add         r1, r1, #1
  00e50	e28bb01c	 add         r11, r11, #0x1C
  00e54	e1510003	 cmp         r1, r3
  00e58	e58d1000	 str         r1, [sp]
  00e5c	e58db004	 str         r11, [sp, #4]
  00e60	3affffc2	 bcc         |$LL20@UfnPdd_Reg|
  00e64		 |$LN18@UfnPdd_Reg|

; 1094 :         }
; 1095 :     }
; 1096 : 
; 1097 :     // Configure Tx EPs
; 1098 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++) {

  00e64	e5d63008	 ldrb        r3, [r6, #8]
  00e68	e3a0b000	 mov         r11, #0
  00e6c	e58db004	 str         r11, [sp, #4]
  00e70	e3530000	 cmp         r3, #0
  00e74	0a00003f	 beq         |$LN8@UfnPdd_Reg|
  00e78	e3a02000	 mov         r2, #0
  00e7c	e58d2000	 str         r2, [sp]
  00e80	e3a00000	 mov         r0, #0
  00e84		 |$LL10@UfnPdd_Reg|

; 1099 :         // For each endpoint in interface
; 1100 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00e84	e5963018	 ldr         r3, [r6, #0x18]

; 1101 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++) {

  00e88	e3a08000	 mov         r8, #0
  00e8c	e0829003	 add         r9, r2, r3
  00e90	e5d93008	 ldrb        r3, [r9, #8]
  00e94	e3530000	 cmp         r3, #0
  00e98	0a00002f	 beq         |$LN9@UfnPdd_Reg|
  00e9c	e59db008	 ldr         r11, [sp, #8]
  00ea0	e3a07000	 mov         r7, #0
  00ea4		 |$LL7@UfnPdd_Reg|

; 1102 :             pEP = &pIFC->pEndpoints[epx];

  00ea4	e5993018	 ldr         r3, [r9, #0x18]
  00ea8	e0874003	 add         r4, r7, r3

; 1103 :             // If it is Rx EP skip it
; 1104 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) == 0) continue;

  00eac	e5d42006	 ldrb        r2, [r4, #6]
  00eb0	e3120080	 tst         r2, #0x80
  00eb4	0a000020	 beq         |$LN6@UfnPdd_Reg|

; 1105 :             // Get EP address
; 1106 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 1107 :             // Save max packet size & direction
; 1108 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  00eb8	e5d41008	 ldrb        r1, [r4, #8]
  00ebc	e5d43009	 ldrb        r3, [r4, #9]
  00ec0	e202600f	 and         r6, r2, #0xF
  00ec4	e08b2206	 add         r2, r11, r6, lsl #4
  00ec8	e1813403	 orr         r3, r1, r3, lsl #8
  00ecc	e1c232b4	 strh        r3, [r2, #0x24]

; 1109 :             pPdd->ep[ep].dirRx = FALSE;

  00ed0	e5820028	 str         r0, [r2, #0x28]

; 1110 :             // Create EP config
; 1111 :             cfg  = USBD_EP_VALID;
; 1112 :             cfg |= Log2(pEP->Descriptor.wMaxPacketSize >> 3) << 12;

  00ed4	e5d42008	 ldrb        r2, [r4, #8]
  00ed8	e5d43009	 ldrb        r3, [r4, #9]
  00edc	e1823403	 orr         r3, r2, r3, lsl #8
  00ee0	e1a001a3	 mov         r0, r3, lsr #3
  00ee4	eb000000	 bl          Log2

; 1113 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01) {

  00ee8	e5d43007	 ldrb        r3, [r4, #7]
  00eec	e3802008	 orr         r2, r0, #8
  00ef0	e1a01602	 mov         r1, r2, lsl #12
  00ef4	e2033003	 and         r3, r3, #3
  00ef8	e3530001	 cmp         r3, #1

; 1114 :                 cfg |= USBD_EP_ISO;

  00efc	03811b02	 orreq       r1, r1, #2, 22

; 1115 :             }
; 1116 :             cfg |= offset >> 3;
; 1117 :             
; 1118 :             if (ep > 0)

  00f00	e3560000	 cmp         r6, #0
  00f04	0a000004	 beq         |$LN2@UfnPdd_Reg|

; 1119 :                 OUTREG32(&pUSBDRegs->EP_TX[ep - 1], cfg);

  00f08	e2863030	 add         r3, r6, #0x30
  00f0c	e08a2103	 add         r2, r10, r3, lsl #2
  00f10	e18131a5	 orr         r3, r1, r5, lsr #3
  00f14	e5823000	 str         r3, [r2]

; 1120 :             else

  00f18	ea000002	 b           |$LN1@UfnPdd_Reg|
  00f1c		 |$LN2@UfnPdd_Reg|

; 1121 :                 OALMSG(1, (L"+USBFN:: UfnPdd_RegisterDevice EP_TX = %d\r\n", ep - 1));

  00f1c	e59f0070	 ldr         r0, [pc, #0x70]
  00f20	e2461001	 sub         r1, r6, #1
  00f24	eb000000	 bl          NKDbgPrintfW
  00f28		 |$LN1@UfnPdd_Reg|

; 1122 :             // Update offset
; 1123 :             offset += pEP->Descriptor.wMaxPacketSize;

  00f28	e5d42008	 ldrb        r2, [r4, #8]
  00f2c	e5d43009	 ldrb        r3, [r4, #9]
  00f30	e3a00000	 mov         r0, #0
  00f34	e1823403	 orr         r3, r2, r3, lsl #8
  00f38	e0855003	 add         r5, r5, r3
  00f3c		 |$LN6@UfnPdd_Reg|
  00f3c	e5d93008	 ldrb        r3, [r9, #8]
  00f40	e2888001	 add         r8, r8, #1
  00f44	e2877014	 add         r7, r7, #0x14
  00f48	e1580003	 cmp         r8, r3
  00f4c	3affffd4	 bcc         |$LL7@UfnPdd_Reg|
  00f50	e59db004	 ldr         r11, [sp, #4]
  00f54	e59d2000	 ldr         r2, [sp]
  00f58	e59d6034	 ldr         r6, [sp, #0x34]
  00f5c		 |$LN9@UfnPdd_Reg|
  00f5c	e5d63008	 ldrb        r3, [r6, #8]
  00f60	e28bb001	 add         r11, r11, #1
  00f64	e282201c	 add         r2, r2, #0x1C
  00f68	e15b0003	 cmp         r11, r3
  00f6c	e58db004	 str         r11, [sp, #4]
  00f70	e58d2000	 str         r2, [sp]
  00f74	3affffc2	 bcc         |$LL10@UfnPdd_Reg|
  00f78		 |$LN8@UfnPdd_Reg|

; 1124 :         }
; 1125 :     }
; 1126 : 
; 1127 :     // Lock configuration
; 1128 :     SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_CFG_LOCK);

  00f78	e59a3018	 ldr         r3, [r10, #0x18]

; 1129 : 
; 1130 :     // Done
; 1131 :     return ERROR_SUCCESS;

  00f7c	e3a00000	 mov         r0, #0
  00f80	e3833c01	 orr         r3, r3, #1, 24
  00f84	e58a3018	 str         r3, [r10, #0x18]

; 1132 : }

  00f88	e28dd00c	 add         sp, sp, #0xC
  00f8c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00f90	e12fff1e	 bx          lr
  00f94		 |$LN36@UfnPdd_Reg|
  00f94		 |$LN37@UfnPdd_Reg|
  00f94	00000000	 DCD         |??_C@_1FI@PHBINKHD@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAE@|
  00f98		 |$LN38@UfnPdd_Reg|
  00f98	00000000	 DCD         |??_C@_1FI@HDDLEHKG@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAE@|
  00f9c		 |$M47716|

			 ENDP  ; |UfnPdd_RegisterDevice|


  000b8			 AREA	 |.pdata|, PDATA
|$T47737| DCD	|$LN12@Log2|
	DCD	0x40000900
; Function compile flags: /Ogtp

  00f9c			 AREA	 |.text|, CODE, ARM

  00f9c		 |Log2|	 PROC

; 109  : {

  00f9c		 |$LN12@Log2|
  00f9c		 |$M47734|
  00f9c	e1b03000	 movs        r3, r0

; 110  :     DWORD rc = 0;

  00fa0	e3a00000	 mov         r0, #0

; 111  :     while (value != 0) {

  00fa4	0a000004	 beq         |$LN1@Log2|
  00fa8		 |$LL3@Log2|

; 112  :         value >>= 1;

  00fa8	e1b030a3	 movs        r3, r3, lsr #1

; 113  :         rc++;

  00fac	e2800001	 add         r0, r0, #1
  00fb0	1afffffc	 bne         |$LL3@Log2|

; 114  :     }
; 115  :     if (rc > 0) rc--;

  00fb4	e3500000	 cmp         r0, #0
  00fb8	12400001	 subne       r0, r0, #1
  00fbc		 |$LN1@Log2|

; 116  :     return rc;
; 117  : }

  00fbc	e12fff1e	 bx          lr
  00fc0		 |$M47735|

			 ENDP  ; |Log2|

	EXPORT	|UfnPdd_IsEndpointSupportable|
	EXPORT	|??_C@_1JI@KCBMDACI@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@| [ DATA ] ; `string'

  000c0			 AREA	 |.pdata|, PDATA
|$T47752| DCD	|$LN11@UfnPdd_IsE@2|
	DCD	0x40002401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JI@KCBMDACI@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "O"
	DCB	0x0, "M", 0x0, "A", 0x0, "P", 0x0, "2", 0x0, "4", 0x0, "2"
	DCB	0x0, "0", 0x0, "_", 0x0, "M", 0x0, "S", 0x0, "_", 0x0, "V"
	DCB	0x0, "1", 0x0, "\\", 0x0, "O", 0x0, "A", 0x0, "L", 0x0, "\\"
	DCB	0x0, "E", 0x0, "T", 0x0, "H", 0x0, "D", 0x0, "R", 0x0, "V"
	DCB	0x0, "\\", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N"
	DCB	0x0, "\\", 0x0, ".", 0x0, "\\", 0x0, "p", 0x0, "d", 0x0, "d"
	DCB	0x0, ".", 0x0, "c", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@| DCB "%"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "D", 0x0, "E", 0x0, "B"
	DCB	0x0, "U", 0x0, "G", 0x0, "C", 0x0, "H", 0x0, "K", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "i", 0x0, "n", 0x0, " ", 0x0, "f", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " "
	DCB	0x0, "a", 0x0, "t", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogtp

  00fc0			 AREA	 |.text|, CODE, ARM

  00fc0		 |UfnPdd_IsEndpointSupportable| PROC

; 1148 : ) {

  00fc0		 |$LN11@UfnPdd_IsE@2|
  00fc0	e92d4010	 stmdb       sp!, {r4, lr}
  00fc4		 |$M47749|
  00fc4	e1a04003	 mov         r4, r3
  00fc8	e3510000	 cmp         r1, #0

; 1149 :     USBFN_PDD *pPdd = pPddContext;
; 1150 : 
; 1151 :     // Update maximal packet size for EP0
; 1152 :     if (endPoint == 0) {

  00fcc	1a000019	 bne         |$LN8@UfnPdd_IsE@2|

; 1153 :         DEBUGCHK(pEPDesc->wMaxPacketSize <= 64);

  00fd0	e5d4e004	 ldrb        lr, [r4, #4]
  00fd4	e5d42005	 ldrb        r2, [r4, #5]
  00fd8	e18e2402	 orr         r2, lr, r2, lsl #8
  00fdc	e3520040	 cmp         r2, #0x40
  00fe0	9a000006	 bls         |$LN5@UfnPdd_IsE@2|
  00fe4	e59f2060	 ldr         r2, [pc, #0x60]
  00fe8	e59f1058	 ldr         r1, [pc, #0x58]
  00fec	e59f0050	 ldr         r0, [pc, #0x50]
  00ff0	e3a03b01	 mov         r3, #1, 22
  00ff4	e3833081	 orr         r3, r3, #0x81
  00ff8	eb000000	 bl          NKDbgPrintfW
  00ffc	e6000010	 __debugbreak_ce
  01000		 |$LN5@UfnPdd_IsE@2|

; 1154 :         DEBUGCHK(pEPDesc->bmAttributes == USB_ENDPOINT_TYPE_CONTROL);

  01000	e5d4e003	 ldrb        lr, [r4, #3]
  01004	e35e0000	 cmp         lr, #0
  01008	0a000006	 beq         |$LN7@UfnPdd_IsE@2|
  0100c	e59f2038	 ldr         r2, [pc, #0x38]
  01010	e59f1030	 ldr         r1, [pc, #0x30]
  01014	e59f0028	 ldr         r0, [pc, #0x28]
  01018	e3a03b01	 mov         r3, #1, 22
  0101c	e3833082	 orr         r3, r3, #0x82
  01020	eb000000	 bl          NKDbgPrintfW
  01024	e6000010	 __debugbreak_ce
  01028		 |$LN7@UfnPdd_IsE@2|

; 1155 :         pEPDesc->wMaxPacketSize = 64;

  01028	e3a03040	 mov         r3, #0x40
  0102c	e3a02000	 mov         r2, #0
  01030	e5c43004	 strb        r3, [r4, #4]
  01034	e5c42005	 strb        r2, [r4, #5]
  01038		 |$LN8@UfnPdd_IsE@2|

; 1156 : 
; 1157 :     }
; 1158 : 
; 1159 :     // Done
; 1160 :     return ERROR_SUCCESS;

  01038	e3a00000	 mov         r0, #0

; 1161 : }

  0103c	e8bd4010	 ldmia       sp!, {r4, lr}
  01040	e12fff1e	 bx          lr
  01044		 |$LN12@UfnPdd_IsE@2|
  01044		 |$LN13@UfnPdd_IsE@2|
  01044	00000000	 DCD         |??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@|
  01048		 |$LN14@UfnPdd_IsE@2|
  01048	00000000	 DCD         |dpCurSettings|
  0104c		 |$LN15@UfnPdd_IsE@2|
  0104c	00000000	 DCD         |??_C@_1JI@KCBMDACI@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  01050		 |$M47750|

			 ENDP  ; |UfnPdd_IsEndpointSupportable|

	EXPORT	|UfnPdd_IsConfigurationSupportable|

  000c8			 AREA	 |.pdata|, PDATA
|$T47782| DCD	|$LN22@UfnPdd_IsC|
	DCD	0x40004901
; Function compile flags: /Ogtp

  01050			 AREA	 |.text|, CODE, ARM

  01050		 |UfnPdd_IsConfigurationSupportable| PROC

; 1177 : ) {

  01050		 |$LN22@UfnPdd_IsC|
  01050	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  01054		 |$M47779|
  01054	e1a08002	 mov         r8, r2

; 1178 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1179 :     USBFN_PDD *pPdd = pPddContext;
; 1180 :     UFN_INTERFACE *pIFC;
; 1181 :     UFN_ENDPOINT *pEP;
; 1182 :     WORD ifc, epx, count;
; 1183 :     WORD offset, size;
; 1184 : 
; 1185 : 
; 1186 :     // TODO: Update self power bit & maxPower
; 1187 : 
; 1188 :     // We must start with offset 8 + 64 (config plus EP0 size)
; 1189 :     offset = 8 + 64;
; 1190 :     // Clear number of end points
; 1191 :     count = 0;
; 1192 : 
; 1193 :     // For each interface in configuration
; 1194 :     for (ifc = 0; ifc < pConfig->Descriptor.bNumInterfaces; ifc++) {

  01058	e5d83008	 ldrb        r3, [r8, #8]
  0105c	e3a07048	 mov         r7, #0x48
  01060	e3a09000	 mov         r9, #0
  01064	e3530000	 cmp         r3, #0
  01068	e3a0e000	 mov         lr, #0
  0106c	0a000036	 beq         |$LN9@UfnPdd_IsC|
  01070	e3a0a000	 mov         r10, #0
  01074	e3a0201c	 mov         r2, #0x1C
  01078	e3a0b001	 mov         r11, #1
  0107c		 |$LL11@UfnPdd_IsC|

; 1195 :         // For each endpoint in interface
; 1196 :         pIFC = &pConfig->pInterfaces[ifc];

  0107c	e5983018	 ldr         r3, [r8, #0x18]

; 1197 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++) {

  01080	e3a00000	 mov         r0, #0
  01084	e025329e	 mla         r5, lr, r2, r3
  01088	e5d53008	 ldrb        r3, [r5, #8]
  0108c	e3530000	 cmp         r3, #0
  01090	0a000021	 beq         |$LN6@UfnPdd_IsC|
  01094	e3a06000	 mov         r6, #0
  01098		 |$LL8@UfnPdd_IsC|

; 1198 :             pEP = &pIFC->pEndpoints[epx];

  01098	e5952018	 ldr         r2, [r5, #0x18]
  0109c	e0803100	 add         r3, r0, r0, lsl #2
  010a0	e0824103	 add         r4, r2, r3, lsl #2

; 1199 :             // We support maximal sizes 8, 16, 32 and 64 bytes for non-ISO
; 1200 :             size = pEP->Descriptor.wMaxPacketSize;

  010a4	e5d42008	 ldrb        r2, [r4, #8]
  010a8	e5d43009	 ldrb        r3, [r4, #9]
  010ac	e1820403	 orr         r0, r2, r3, lsl #8

; 1201 :             // First round size to supported sizes
; 1202 :             size = 1 << Log2(size);

  010b0	eb000000	 bl          Log2

; 1203 :             // Is it ISO end point?
; 1204 :             if ((pEP->Descriptor.bmAttributes & 0x03) != 0x01) {

  010b4	e5d42007	 ldrb        r2, [r4, #7]
  010b8	e1a0301b	 mov         r3, r11, lsl r0
  010bc	e2022003	 and         r2, r2, #3
  010c0	e1a00803	 mov         r0, r3, lsl #16
  010c4	e1a00820	 mov         r0, r0, lsr #16
  010c8	e3520001	 cmp         r2, #1
  010cc	0a000003	 beq         |$LN5@UfnPdd_IsC|

; 1205 :                 // Non-ISO, max size is 64 bytes
; 1206 :                 if (size > 64) size = 64;

  010d0	e3500040	 cmp         r0, #0x40
  010d4	9a000003	 bls         |$LN2@UfnPdd_IsC|
  010d8	e3a00040	 mov         r0, #0x40

; 1207 :             } else {

  010dc	ea000001	 b           |$LN2@UfnPdd_IsC|
  010e0		 |$LN5@UfnPdd_IsC|

; 1208 :                 // ISO edpoint, maximal size is 512 bytes
; 1209 :                 if (size > 512) size = 512;

  010e0	e3500c02	 cmp         r0, #2, 24
  010e4	83a00c02	 movhi       r0, #2, 24
  010e8		 |$LN2@UfnPdd_IsC|

; 1210 :             }
; 1211 :             // Update EP size
; 1212 :             pEP->Descriptor.wMaxPacketSize = size;

  010e8	e1a03420	 mov         r3, r0, lsr #8
  010ec	e5c43009	 strb        r3, [r4, #9]
  010f0	e2863001	 add         r3, r6, #1
  010f4	e5c40008	 strb        r0, [r4, #8]
  010f8	e5d51008	 ldrb        r1, [r5, #8]

; 1213 :             // Calculate total buffer size
; 1214 :             offset += size;

  010fc	e0802007	 add         r2, r0, r7
  01100	e1a00803	 mov         r0, r3, lsl #16
  01104	e1a00820	 mov         r0, r0, lsr #16
  01108	e1a07802	 mov         r7, r2, lsl #16
  0110c	e1500001	 cmp         r0, r1
  01110	e1a06000	 mov         r6, r0
  01114	e1a07827	 mov         r7, r7, lsr #16
  01118	3affffde	 bcc         |$LL8@UfnPdd_IsC|
  0111c		 |$LN6@UfnPdd_IsC|

; 1215 :         }
; 1216 :         // Add number of end points to total count
; 1217 :         count += pIFC->Descriptor.bNumEndpoints;

  0111c	e5d52008	 ldrb        r2, [r5, #8]
  01120	e5d81008	 ldrb        r1, [r8, #8]
  01124	e28a3001	 add         r3, r10, #1
  01128	e0822009	 add         r2, r2, r9
  0112c	e1a0e803	 mov         lr, r3, lsl #16
  01130	e1a09802	 mov         r9, r2, lsl #16
  01134	e1a0e82e	 mov         lr, lr, lsr #16
  01138	e1a09829	 mov         r9, r9, lsr #16
  0113c	e1a0a00e	 mov         r10, lr
  01140	e15e0001	 cmp         lr, r1
  01144	e3a0201c	 mov         r2, #0x1C
  01148	3affffcb	 bcc         |$LL11@UfnPdd_IsC|
  0114c		 |$LN9@UfnPdd_IsC|

; 1218 :     }
; 1219 : 
; 1220 :     // Can we support this configuration?
; 1221 :     if (count < USBD_EP_COUNT && offset <= 2048) rc = ERROR_SUCCESS;

  0114c	e3590010	 cmp         r9, #0x10
  01150	2a000004	 bcs         |$LN18@UfnPdd_IsC|
  01154	e3570b02	 cmp         r7, #2, 22
  01158	8a000002	 bhi         |$LN18@UfnPdd_IsC|
  0115c	e3a00000	 mov         r0, #0

; 1222 : 
; 1223 :     // Done
; 1224 :     return rc;
; 1225 : }

  01160	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  01164	e12fff1e	 bx          lr
  01168		 |$LN18@UfnPdd_IsC|
  01168	e3a00057	 mov         r0, #0x57
  0116c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  01170	e12fff1e	 bx          lr
  01174		 |$M47780|

			 ENDP  ; |UfnPdd_IsConfigurationSupportable|

	EXPORT	|UfnPdd_Init|
	EXPORT	|??_C@_1CI@PLGKOIKJ@?$AA?9?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@JFIJHLAK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@KOBDIJLJ@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OALPAtoVA|
	IMPORT	|memset|

  000d0			 AREA	 |.pdata|, PDATA
|$T47806| DCD	|$LN20@UfnPdd_Ini@3|
	DCD	0x40008302

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@PLGKOIKJ@?$AA?9?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "U", 0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, ":"
	DCB	0x0, ":", 0x0, " ", 0x0, "P", 0x0, "D", 0x0, "D", 0x0, " "
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@JFIJHLAK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d"
	DCB	0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, ":"
	DCB	0x0, " ", 0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r"
	DCB	0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, " ", 0x0, "m", 0x0, "a"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@KOBDIJLJ@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "U", 0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N", 0x0, ":"
	DCB	0x0, ":", 0x0, " ", 0x0, "P", 0x0, "D", 0x0, "D", 0x0, " "
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  01174			 AREA	 |.text|, CODE, ARM

  01174		 |UfnPdd_Init| PROC

; 1238 : {

  01174		 |$LN20@UfnPdd_Ini@3|
  01174	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  01178	e24dd00c	 sub         sp, sp, #0xC
  0117c		 |$M47803|
  0117c	e58d3000	 str         r3, [sp]
  01180	e1a03001	 mov         r3, r1
  01184	e58d3004	 str         r3, [sp, #4]
  01188	e58d2008	 str         r2, [sp, #8]

; 1239 :     DWORD rc;
; 1240 :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"+USBFN:: PDD Init\r\n"));

  0118c	e59f5188	 ldr         r5, [pc, #0x188]
  01190	e5950440	 ldr         r0, [r5, #0x440]
  01194	e3100a02	 tst         r0, #2, 20
  01198	13100004	 tstne       r0, #4
  0119c	159f01d8	 ldrne       r0, [pc, #0x1D8]
  011a0	1b000000	 blne        NKDbgPrintfW

; 1241 :     {
; 1242 :         USBFN_PDD *pPdd;
; 1243 :         OMAP2420_USBD_REGS *pUSBDRegs;
; 1244 :         DWORD ep;
; 1245 :     
; 1246 :         rc = ERROR_INVALID_PARAMETER;
; 1247 :     
; 1248 :         // Allocate and initialize the OHCD object.
; 1249 :         pPdd = &g_usbfnpdd;
; 1250 : 
; 1251 :         if (pPdd == NULL) goto clean;
; 1252 :     
; 1253 :         // Clear the allocated object.
; 1254 :         memset(pPdd, 0, sizeof(USBFN_PDD));

  011a4	e59f617c	 ldr         r6, [pc, #0x17C]
  011a8	e3a02f4a	 mov         r2, #0x4A, 30
  011ac	e3a01000	 mov         r1, #0
  011b0	e1a00006	 mov         r0, r6
  011b4	e3a04057	 mov         r4, #0x57
  011b8	eb000000	 bl          memset

; 1255 :     
; 1256 :         // Map the USB OHCI registers
; 1257 :         pUSBDRegs = (OMAP2420_USBD_REGS*)OALPAtoUA( OMAP2420_USBD_REGS_PA );

  011bc	e59f01b4	 ldr         r0, [pc, #0x1B4]
  011c0	e3a01000	 mov         r1, #0
  011c4	eb000000	 bl          OALPAtoVA
  011c8	e3500000	 cmp         r0, #0

; 1258 :     
; 1259 :         if (pUSBDRegs == NULL) {

  011cc	1a000006	 bne         |$LN4@UfnPdd_Ini@3|

; 1260 :             OALMSG(OAL_ERROR, (
; 1261 :                 L"ERROR: UfnPdd_Init: Controller registers mapping failed\r\n"
; 1262 :             ));

  011d0	e5952440	 ldr         r2, [r5, #0x440]
  011d4	e3120001	 tst         r2, #1
  011d8	0a000046	 beq         |$clean$47241|
  011dc	e59f0190	 ldr         r0, [pc, #0x190]
  011e0	eb000000	 bl          NKDbgPrintfW

; 1263 :             goto clean;

  011e4	e5952440	 ldr         r2, [r5, #0x440]
  011e8	ea000042	 b           |$clean$47241|
  011ec		 |$LN4@UfnPdd_Ini@3|

; 1264 :         }
; 1265 :         
; 1266 :         pPdd->pUSBDRegs = pUSBDRegs;
; 1267 :     
; 1268 :         // Clear USB Interrupt enable registers
; 1269 :         OUTREG32(&pUSBDRegs->IRQ_EN, 0x0000);

  011ec	e3a01000	 mov         r1, #0
  011f0	e5860008	 str         r0, [r6, #8]
  011f4	e5801028	 str         r1, [r0, #0x28]

; 1270 :         OUTREG32(&pUSBDRegs->DMA_IRQ_EN, 0x0000);
; 1271 :     
; 1272 :         // Reset all interrupts
; 1273 :         OUTREG32(&pUSBDRegs->IRQ_SRC, 0xFFFFFFFF);

  011f8	e3e03000	 mvn         r3, #0
  011fc	e580102c	 str         r1, [r0, #0x2C]
  01200	e5803030	 str         r3, [r0, #0x30]

; 1274 :     
; 1275 :         // Disable all RX, TX EPs
; 1276 :         OUTREG32(&pUSBDRegs->EP0, 0);

  01204	e5801080	 str         r1, [r0, #0x80]
  01208	e2803084	 add         r3, r0, #0x84
  0120c	e3a0200f	 mov         r2, #0xF
  01210		 |$LL3@UfnPdd_Ini@3|

; 1277 :         for (ep = 0; ep < USBD_NONZERO_EP_COUNT; ep++) {
; 1278 :             OUTREG32(&pUSBDRegs->EP_RX[ep], 0);

  01210	e5831000	 str         r1, [r3]

; 1279 :             OUTREG32(&pUSBDRegs->EP_TX[ep], 0);

  01214	e5831040	 str         r1, [r3, #0x40]
  01218	e2833004	 add         r3, r3, #4
  0121c	e2522001	 subs        r2, r2, #1
  01220	1afffffa	 bne         |$LL3@UfnPdd_Ini@3|

; 1280 :         }
; 1281 :     
; 1282 :         //OUTREG32(&pUSBDRegs->SYSCON1, 0);
; 1283 :     
; 1284 :         // Set PDD interface
; 1285 :         pPddIfc->dwVersion = UFN_PDD_INTERFACE_VERSION;
; 1286 :         pPddIfc->dwCapabilities = UFN_PDD_CAPS_SUPPORTS_FULL_SPEED;
; 1287 :         pPddIfc->dwEndpointCount = USBD_EP_COUNT;
; 1288 :         pPddIfc->pvPddContext = pPdd;
; 1289 :         pPddIfc->pfnDeinit = UfnPdd_Deinit;
; 1290 :         pPddIfc->pfnIsConfigurationSupportable = UfnPdd_IsConfigurationSupportable;
; 1291 :         pPddIfc->pfnIsEndpointSupportable = UfnPdd_IsEndpointSupportable;
; 1292 :         pPddIfc->pfnInitEndpoint = UfnPdd_InitEndpoint;
; 1293 :         pPddIfc->pfnRegisterDevice = UfnPdd_RegisterDevice;
; 1294 :         pPddIfc->pfnDeregisterDevice = UfnPdd_DeregisterDevice;
; 1295 :         pPddIfc->pfnStart = UfnPdd_Start;
; 1296 :         pPddIfc->pfnStop = UfnPdd_Stop;
; 1297 :         pPddIfc->pfnIssueTransfer = UfnPdd_IssueTransfer;
; 1298 :         pPddIfc->pfnAbortTransfer = UfnPdd_AbortTransfer;
; 1299 :         pPddIfc->pfnDeinitEndpoint = UfnPdd_DeinitEndpoint;
; 1300 :         pPddIfc->pfnStallEndpoint = UfnPdd_StallEndpoint;
; 1301 :         pPddIfc->pfnClearEndpointStall = UfnPdd_ClearEndpointStall;
; 1302 :         pPddIfc->pfnSendControlStatusHandshake = UfnPdd_SendControlStatusHandshake;
; 1303 :         pPddIfc->pfnSetAddress = UfnPdd_SetAddress;
; 1304 :         pPddIfc->pfnIsEndpointHalted = UfnPdd_IsEndpointHalted;
; 1305 :         pPddIfc->pfnInitiateRemoteWakeup = UfnPdd_InitiateRemoteWakeup;
; 1306 :         pPddIfc->pfnPowerDown = UfnPdd_PowerDown;
; 1307 :         pPddIfc->pfnPowerUp = UfnPdd_PowerUp;
; 1308 :         pPddIfc->pfnIOControl = UfnPdd_IOControl;

  01224	e59f3144	 ldr         r3, [pc, #0x144]
  01228	e59d2000	 ldr         r2, [sp]
  0122c	e59f1138	 ldr         r1, [pc, #0x138]
  01230	e59f0130	 ldr         r0, [pc, #0x130]
  01234	e5823010	 str         r3, [r2, #0x10]
  01238	e59f2124	 ldr         r2, [pc, #0x124]
  0123c	e59d3000	 ldr         r3, [sp]
  01240	e59fe118	 ldr         lr, [pc, #0x118]
  01244	e59f4110	 ldr         r4, [pc, #0x110]
  01248	e5832014	 str         r2, [r3, #0x14]
  0124c	e1a02003	 mov         r2, r3
  01250	e59f3100	 ldr         r3, [pc, #0x100]
  01254	e59f50f8	 ldr         r5, [pc, #0xF8]
  01258	e59f60f0	 ldr         r6, [pc, #0xF0]
  0125c	e5823044	 str         r3, [r2, #0x44]
  01260	e59f30e4	 ldr         r3, [pc, #0xE4]
  01264	e59f70dc	 ldr         r7, [pc, #0xDC]
  01268	e59f80d4	 ldr         r8, [pc, #0xD4]
  0126c	e5823048	 str         r3, [r2, #0x48]
  01270	e59f30c8	 ldr         r3, [pc, #0xC8]
  01274	e59f90c0	 ldr         r9, [pc, #0xC0]
  01278	e59fa0b8	 ldr         r10, [pc, #0xB8]
  0127c	e582304c	 str         r3, [r2, #0x4C]
  01280	e59f30ac	 ldr         r3, [pc, #0xAC]
  01284	e59fb0a4	 ldr         r11, [pc, #0xA4]
  01288	e5821018	 str         r1, [r2, #0x18]
  0128c	e5823050	 str         r3, [r2, #0x50]
  01290	e59f3094	 ldr         r3, [pc, #0x94]
  01294	e59f108c	 ldr         r1, [pc, #0x8C]
  01298	e282c01c	 add         r12, r2, #0x1C
  0129c	e88c4001	 stmia       r12, {r0, lr}
  012a0	e5823054	 str         r3, [r2, #0x54]
  012a4	e59f3078	 ldr         r3, [pc, #0x78]
  012a8	e282c024	 add         r12, r2, #0x24
  012ac	e88c0ff0	 stmia       r12, {r4 - r11}

; 1309 :     
; 1310 :         // Save MDD context & notify function
; 1311 :         pPdd->pMddContext = pMddContext;
; 1312 :         pPdd->pfnNotify = pMddIfc->pfnNotify;
; 1313 :     
; 1314 :         // Done
; 1315 :         rc = ERROR_SUCCESS;

  012b0	e3a04000	 mov         r4, #0
  012b4	e5823058	 str         r3, [r2, #0x58]
  012b8	e59f3060	 ldr         r3, [pc, #0x60]
  012bc	e582100c	 str         r1, [r2, #0xC]
  012c0	e582305c	 str         r3, [r2, #0x5C]
  012c4	e3a03806	 mov         r3, #6, 16
  012c8	e5823000	 str         r3, [r2]
  012cc	e3a03001	 mov         r3, #1
  012d0	e5823004	 str         r3, [r2, #4]
  012d4	e3a03010	 mov         r3, #0x10
  012d8	e5823008	 str         r3, [r2, #8]
  012dc	e59d3004	 ldr         r3, [sp, #4]
  012e0	e59f2034	 ldr         r2, [pc, #0x34]
  012e4	e5813000	 str         r3, [r1]
  012e8	e59d3008	 ldr         r3, [sp, #8]
  012ec	e5922440	 ldr         r2, [r2, #0x440]
  012f0	e5933004	 ldr         r3, [r3, #4]
  012f4	e5813004	 str         r3, [r1, #4]
  012f8		 |$clean$47241|

; 1316 : 
; 1317 :     }
; 1318 : 
; 1319 : clean:
; 1320 :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"-USBFN:: PDD Init\r\n"));

  012f8	e3120a02	 tst         r2, #2, 20
  012fc	13120004	 tstne       r2, #4
  01300	159f0010	 ldrne       r0, [pc, #0x10]
  01304	1b000000	 blne        NKDbgPrintfW

; 1321 :     return rc;
; 1322 : }

  01308	e1a00004	 mov         r0, r4
  0130c	e28dd00c	 add         sp, sp, #0xC
  01310	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  01314	e12fff1e	 bx          lr
  01318		 |$LN21@UfnPdd_Ini@3|
  01318		 |$LN22@UfnPdd_Ini@3|
  01318	00000000	 DCD         |??_C@_1CI@PLGKOIKJ@?$AA?9?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  0131c		 |$LN23@UfnPdd_Ini@3|
  0131c	00000000	 DCD         |dpCurSettings|
  01320		 |$LN24@UfnPdd_Ini@3|
  01320	00000000	 DCD         |UfnPdd_IOControl|
  01324		 |$LN25@UfnPdd_Ini@3|
  01324	00000000	 DCD         |UfnPdd_PowerUp|
  01328		 |$LN26@UfnPdd_Ini@3|
  01328	00000000	 DCD         |g_usbfnpdd|
  0132c		 |$LN27@UfnPdd_Ini@3|
  0132c	00000000	 DCD         |UfnPdd_PowerDown|
  01330		 |$LN28@UfnPdd_Ini@3|
  01330	00000000	 DCD         |UfnPdd_ClearEndpointStall|
  01334		 |$LN29@UfnPdd_Ini@3|
  01334	00000000	 DCD         |UfnPdd_InitiateRemoteWakeup|
  01338		 |$LN30@UfnPdd_Ini@3|
  01338	00000000	 DCD         |UfnPdd_StallEndpoint|
  0133c		 |$LN31@UfnPdd_Ini@3|
  0133c	00000000	 DCD         |UfnPdd_DeinitEndpoint|
  01340		 |$LN32@UfnPdd_Ini@3|
  01340	00000000	 DCD         |UfnPdd_IsEndpointHalted|
  01344		 |$LN33@UfnPdd_Ini@3|
  01344	00000000	 DCD         |UfnPdd_AbortTransfer|
  01348		 |$LN34@UfnPdd_Ini@3|
  01348	00000000	 DCD         |UfnPdd_IssueTransfer|
  0134c		 |$LN35@UfnPdd_Ini@3|
  0134c	00000000	 DCD         |UfnPdd_SetAddress|
  01350		 |$LN36@UfnPdd_Ini@3|
  01350	00000000	 DCD         |UfnPdd_Stop|
  01354		 |$LN37@UfnPdd_Ini@3|
  01354	00000000	 DCD         |UfnPdd_Start|
  01358		 |$LN38@UfnPdd_Ini@3|
  01358	00000000	 DCD         |UfnPdd_SendControlStatusHandshake|
  0135c		 |$LN39@UfnPdd_Ini@3|
  0135c	00000000	 DCD         |UfnPdd_DeregisterDevice|
  01360		 |$LN40@UfnPdd_Ini@3|
  01360	00000000	 DCD         |UfnPdd_RegisterDevice|
  01364		 |$LN41@UfnPdd_Ini@3|
  01364	00000000	 DCD         |UfnPdd_IsConfigurationSupportable|
  01368		 |$LN42@UfnPdd_Ini@3|
  01368	00000000	 DCD         |UfnPdd_InitEndpoint|
  0136c		 |$LN43@UfnPdd_Ini@3|
  0136c	00000000	 DCD         |UfnPdd_IsEndpointSupportable|
  01370		 |$LN44@UfnPdd_Ini@3|
  01370	00000000	 DCD         |UfnPdd_Deinit|
  01374		 |$LN45@UfnPdd_Ini@3|
  01374	00000000	 DCD         |??_C@_1HE@JFIJHLAK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr@|
  01378		 |$LN46@UfnPdd_Ini@3|
  01378	4805e200	 DCD         0x4805e200
  0137c		 |$LN47@UfnPdd_Ini@3|
  0137c	00000000	 DCD         |??_C@_1CI@KOBDIJLJ@?$AA?$CL?$AAU?$AAS?$AAB?$AAF?$AAN?$AA?3?$AA?3?$AA?5?$AAP?$AAD?$AAD?$AA?5?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  01380		 |$M47804|

			 ENDP  ; |UfnPdd_Init|

	EXPORT	|UfnPdd_DllEntry|

  000d8			 AREA	 |.pdata|, PDATA
|$T47840| DCD	|$LN5@UfnPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogtp

  01380			 AREA	 |.text|, CODE, ARM

  01380		 |UfnPdd_DllEntry| PROC

; 1328 : ) {

  01380		 |$LN5@UfnPdd_Dll|
  01380		 |$M47837|

; 1329 :     return TRUE;

  01380	e3a00001	 mov         r0, #1

; 1330 : }

  01384	e12fff1e	 bx          lr
  01388		 |$M47838|

			 ENDP  ; |UfnPdd_DllEntry|

	END
