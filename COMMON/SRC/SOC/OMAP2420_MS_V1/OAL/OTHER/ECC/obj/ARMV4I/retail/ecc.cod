; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\OAL\OTHER\ECC\ecc.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|?i@?1??ECC_IsDataValid@@9@9| % 0x1			; `ECC_IsDataValid'::`2'::i

  00000			 AREA	 |.rdata|, DATA, READONLY
|ByteToNumberOfOnes| DCB 0x0
	DCB	0x1
	DCB	0x1
	DCB	0x2
	DCB	0x1
	DCB	0x2
	DCB	0x2
	DCB	0x3
	DCB	0x1
	DCB	0x2
	DCB	0x2
	DCB	0x3
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x1
	DCB	0x2
	DCB	0x2
	DCB	0x3
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x1
	DCB	0x2
	DCB	0x2
	DCB	0x3
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x1
	DCB	0x2
	DCB	0x2
	DCB	0x3
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x5
	DCB	0x6
	DCB	0x6
	DCB	0x7
	DCB	0x1
	DCB	0x2
	DCB	0x2
	DCB	0x3
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x5
	DCB	0x6
	DCB	0x6
	DCB	0x7
	DCB	0x2
	DCB	0x3
	DCB	0x3
	DCB	0x4
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x5
	DCB	0x6
	DCB	0x6
	DCB	0x7
	DCB	0x3
	DCB	0x4
	DCB	0x4
	DCB	0x5
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x5
	DCB	0x6
	DCB	0x6
	DCB	0x7
	DCB	0x4
	DCB	0x5
	DCB	0x5
	DCB	0x6
	DCB	0x5
	DCB	0x6
	DCB	0x6
	DCB	0x7
	DCB	0x5
	DCB	0x6
	DCB	0x6
	DCB	0x7
	DCB	0x6
	DCB	0x7
	DCB	0x7
	DCB	0x8
	EXPORT	|ECC_CorrectData|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\oal\other\ecc\ecc.c

  00000			 AREA	 |.pdata|, PDATA
|$T39057| DCD	|$LN21@ECC_Correc|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ECC_CorrectData| PROC

; 72   : {

  00000		 |$LN21@ECC_Correc|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M39054|
  00008	e3500000	 cmp         r0, #0

; 73   :     DWORD i, numOnes, byteLocation, bitLocation;
; 74   :     BYTE xorECC[ECC_BUFF_LEN];
; 75   : 
; 76   :     //----- 1. Check the parameters -----
; 77   :     if ((pData == NULL) || (pExistingECC == NULL)) {

  0000c	0a000025	 beq         |$LN12@ECC_Correc|
  00010	e3520000	 cmp         r2, #0
  00014	0a000023	 beq         |$LN12@ECC_Correc|

; 79   :     }
; 80   : 
; 81   :     //----- 2. First, determine if this is a single-bit, correctable, error ----
; 82   :     //         NOTE: To answer this question, the two ECC values are XOR'd 
; 83   :     //               together and the total # of 1 bits is counted, which 
; 84   :     //               then tell us if we can correct the erroneous single-bit 
; 85   :     //               transition in the data.
; 86   :     numOnes = 0;
; 87   :     for (i = 0; i < ECC_BUFF_LEN; i++) {

  00018	e28d3000	 add         r3, sp, #0
  0001c	e59f6094	 ldr         r6, [pc, #0x94]
  00020	e0435002	 sub         r5, r3, r2
  00024	e3a0e000	 mov         lr, #0
  00028	e3a04003	 mov         r4, #3
  0002c		 |$LL11@ECC_Correc|

; 88   :         xorECC[i] = pExistingECC[i] ^ pExistingECC[i+ECC_BUFF_LEN];

  0002c	e5d21003	 ldrb        r1, [r2, #3]
  00030	e5d23000	 ldrb        r3, [r2]
  00034	e2544001	 subs        r4, r4, #1
  00038	e0213003	 eor         r3, r1, r3
  0003c	e20330ff	 and         r3, r3, #0xFF

; 89   :         numOnes += CountNumberOfOnes(xorECC[i]);

  00040	e7d31006	 ldrb        r1, [r3, +r6]
  00044	e7c53002	 strb        r3, [r5, +r2]
  00048	e2822001	 add         r2, r2, #1
  0004c	e08ee001	 add         lr, lr, r1
  00050	1afffff5	 bne         |$LL11@ECC_Correc|

; 90   :     }
; 91   : 
; 92   :     switch (numOnes) {

  00054	e35e0000	 cmp         lr, #0
  00058	0a000010	 beq         |$LN6@ECC_Correc|
  0005c	e35e0001	 cmp         lr, #1
  00060	0a000010	 beq         |$LN12@ECC_Correc|
  00064	e35e000c	 cmp         lr, #0xC

; 95   : 
; 96   :     case ECC_ERROR:                     // Existing ECC value has gone bad!
; 97   :         return FALSE;
; 98   : 
; 99   :     case CORRECTABLE_ERROR:             // Single-bit error
; 100  :         break;
; 101  : 
; 102  :     default:                            // More than a single-bit error
; 103  :         return FALSE;

  00068	1a00000e	 bne         |$LN12@ECC_Correc|

; 104  :     }
; 105  :         
; 106  :     //----- 3. Compute the location of the single-bit error -----
; 107  :     byteLocation = ((xorECC[2]&0xf0)<<1) | ((xorECC[1]&0xf8)>>3);

  0006c	e5dd3002	 ldrb        r3, [sp, #2]
  00070	e5dd2001	 ldrb        r2, [sp, #1]

; 108  :     bitLocation  = xorECC[1] & 0x7;
; 109  : 
; 110  :     //----- 4. Correct the single-bit error -----
; 111  :     if (pData[byteLocation] & (0x01 << bitLocation)) {

  00074	e3a0e001	 mov         lr, #1
  00078	e20330f0	 and         r3, r3, #0xF0
  0007c	e1a03083	 mov         r3, r3, lsl #1
  00080	e18311a2	 orr         r1, r3, r2, lsr #3
  00084	e7f10000	 ldrb        r0, [r1, +r0]!
  00088	e2023007	 and         r3, r2, #7
  0008c	e1a0331e	 mov         r3, lr, lsl r3
  00090	e1100003	 tst         r0, r3

; 112  :         pData[byteLocation] &= ~(0x01 << bitLocation);      // 0->1 error

  00094	11c03003	 bicne       r3, r0, r3

; 113  :     } else {
; 114  :         pData[byteLocation] |= (0x01 <<  bitLocation);      // 1->0 error

  00098	01803003	 orreq       r3, r0, r3
  0009c	e5c13000	 strb        r3, [r1]
  000a0		 |$LN6@ECC_Correc|

; 93   :     case NO_DATA_ERROR:                 // Data doesn't contain an error
; 94   :         return TRUE;

  000a0	e3a00001	 mov         r0, #1
  000a4	ea000000	 b           |$LN14@ECC_Correc|
  000a8		 |$LN12@ECC_Correc|

; 78   :         return FALSE;

  000a8	e3a00000	 mov         r0, #0
  000ac		 |$LN14@ECC_Correc|

; 115  :     }
; 116  : 
; 117  :     return TRUE;
; 118  : }

  000ac	e28dd004	 add         sp, sp, #4
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN22@ECC_Correc|
  000b8		 |$LN23@ECC_Correc|
  000b8	00000000	 DCD         |ByteToNumberOfOnes|
  000bc		 |$M39055|

			 ENDP  ; |ECC_CorrectData|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|ECC_ComputeECC|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T39086| DCD	|$LN19@ECC_Comput|
	DCD	0xc0004502

  00000			 AREA	 |.xdata|, DATA
|$T39082| DCD	0xffffffe4
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T39082|

  00008		 |ECC_ComputeECC| PROC

; 128  : {

  00008		 |$LN19@ECC_Comput|
  00008	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M39083|
  00010	e1a04002	 mov         r4, r2
  00014	e59f30fc	 ldr         r3, [pc, #0xFC]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3008	 str         r3, [sp, #8]

; 129  :     ULONG   i;
; 130  :     ULONG   paritc = 0;
; 131  :     BYTE    parity_bit;
; 132  :     BYTE    bitmask[6] = {0x55, 0xaa, 0x33, 0xcc, 0xf, 0xf0};

  00020	e3a01033	 mov         r1, #0x33
  00024	e3a0e0cc	 mov         lr, #0xCC
  00028	e3a060f0	 mov         r6, #0xF0
  0002c	e3a03055	 mov         r3, #0x55
  00030	e3a020aa	 mov         r2, #0xAA
  00034	e3a0500f	 mov         r5, #0xF

; 133  :     ULONG   ulEcc;
; 134  :     
; 135  :     ulEcc = 0;
; 136  :     for ( i = 0; i < 512; i++) {

  00038	e59f70d4	 ldr         r7, [pc, #0xD4]
  0003c	e5cd1002	 strb        r1, [sp, #2]
  00040	e5cde003	 strb        lr, [sp, #3]
  00044	e5cd6005	 strb        r6, [sp, #5]
  00048	e3a06000	 mov         r6, #0
  0004c	e3a0e000	 mov         lr, #0
  00050	e3a01000	 mov         r1, #0
  00054	e5cd3000	 strb        r3, [sp]
  00058	e5cd2001	 strb        r2, [sp, #1]
  0005c	e5cd5004	 strb        r5, [sp, #4]
  00060		 |$LL9@ECC_Comput|

; 137  :         paritc = paritc ^ pData[i];

  00060	e7d13000	 ldrb        r3, [r1, +r0]

; 138  :         if ((CountNumberOfOnes(pData[i] ) & 1) != 0) {

  00064	e7d32007	 ldrb        r2, [r3, +r7]
  00068	e0236006	 eor         r6, r3, r6
  0006c	e3120001	 tst         r2, #1

; 139  :             ulEcc = ulEcc ^ i;

  00070	1021e00e	 eorne       lr, r1, lr
  00074	e2811001	 add         r1, r1, #1
  00078	e3510c02	 cmp         r1, #2, 24
  0007c	3afffff7	 bcc         |$LL9@ECC_Comput|

; 140  :         }
; 141  :     }
; 142  : 
; 143  :     pECC[1] = (BYTE)(ulEcc << 3);
; 144  :     pECC[2] = (BYTE)(ulEcc >> 1) & 0xf0;

  00080	e1a030ae	 mov         r3, lr, lsr #1
  00084	e20320f0	 and         r2, r3, #0xF0
  00088	e1a0118e	 mov         r1, lr, lsl #3
  0008c	e5c42002	 strb        r2, [r4, #2]
  00090	e5c41001	 strb        r1, [r4, #1]

; 145  : 
; 146  :     if ((CountNumberOfOnes( paritc ) & 1) != 0) {

  00094	e7d63007	 ldrb        r3, [r6, +r7]

; 147  :         // Invert copied bits
; 148  :         pECC[0] = pECC[1] ^ 0xf8;
; 149  :         pECC[2] |= (((~pECC[2]) >> 4) & 0x0f) ;
; 150  :     } else {
; 151  :         pECC[0] = pECC[1];
; 152  :         pECC[2] |= (pECC[2] >> 4);
; 153  :     }
; 154  : 
; 155  :     for (i = 0; i < 6; i++) {

  00098	e3a05000	 mov         r5, #0
  0009c	e28d8000	 add         r8, sp, #0
  000a0	e3130001	 tst         r3, #1
  000a4	11e03002	 mvnne       r3, r2
  000a8	11a03243	 movne       r3, r3, asr #4
  000ac	1203300f	 andne       r3, r3, #0xF
  000b0	11833002	 orrne       r3, r3, r2
  000b4	122120f8	 eorne       r2, r1, #0xF8
  000b8	01823222	 orreq       r3, r2, r2, lsr #4
  000bc	15c42000	 strneb      r2, [r4]
  000c0	e5c43002	 strb        r3, [r4, #2]
  000c4	05c41000	 streqb      r1, [r4]
  000c8		 |$LL3@ECC_Comput|

; 156  :         parity_bit = CountNumberOfOnes(paritc & bitmask[i]) & 1;
; 157  :         parity_bit <<= (i >> 1);
; 158  :         pECC[(i & 1)] |= parity_bit;

  000c8	e7d53008	 ldrb        r3, [r5, +r8]
  000cc	e205e001	 and         lr, r5, #1
  000d0	e7fe0004	 ldrb        r0, [lr, +r4]!
  000d4	e0033006	 and         r3, r3, r6
  000d8	e7d31007	 ldrb        r1, [r3, +r7]
  000dc	e1a030a5	 mov         r3, r5, lsr #1
  000e0	e20320ff	 and         r2, r3, #0xFF
  000e4	e2013001	 and         r3, r1, #1
  000e8	e1803213	 orr         r3, r0, r3, lsl r2
  000ec	e2855001	 add         r5, r5, #1
  000f0	e5ce3000	 strb        r3, [lr]
  000f4	e3550006	 cmp         r5, #6
  000f8	3afffff2	 bcc         |$LL3@ECC_Comput|

; 159  :     }
; 160  :     return( TRUE );

  000fc	e59d0008	 ldr         r0, [sp, #8]
  00100	eb000000	 bl          __security_check_cookie
  00104	e3a00001	 mov         r0, #1

; 161  : }

  00108	e28dd00c	 add         sp, sp, #0xC
  0010c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00110	e12fff1e	 bx          lr
  00114		 |$LN20@ECC_Comput|
  00114		 |$LN21@ECC_Comput|
  00114	00000000	 DCD         |ByteToNumberOfOnes|
  00118		 |$LN22@ECC_Comput|
  00118	00000000	 DCD         |__security_cookie|
  0011c		 |$M39084|

			 ENDP  ; |ECC_ComputeECC|

	EXPORT	|ECC_IsDataValid|

  00001			 AREA	 |.bss|, NOINIT
|?newECC@?1??ECC_IsDataValid@@9@9| % 0x3		; `ECC_IsDataValid'::`2'::newECC
|?newECC@?1??ECC_IsDataValid@@9@9| % 0x3		; `ECC_IsDataValid'::`2'::newECC

  00000			 AREA	 |.pdata|, PDATA
|$T39106| DCD	|$LN14@ECC_IsData|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ECC_IsDataValid| PROC

; 178  : {

  00000		 |$LN14@ECC_IsData|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39103|
  00004	e1a05002	 mov         r5, r2

; 179  : 	static UCHAR i = 0;
; 180  : 	static UCHAR newECC[ECC_BUFF_LEN];
; 181  : 
; 182  : 
; 183  :     //----- 0. Compare ECC buf lengths
; 184  :     if( dwECCBuffLen != ECC_BUFF_LEN )

  00008	e3530003	 cmp         r3, #3

; 185  :     {
; 186  :         return FALSE;

  0000c	1a000013	 bne         |$LN10@ECC_IsData|

; 187  :     }
; 188  : 
; 189  : 	//----- 1. Compute the new ECC information for the data -----
; 190  : 	//         NOTE: We assume that the input data buffer is a sector (512 bytes)
; 191  : 	if(!ECC_ComputeECC(pData, dwDataBuffLen, newECC, ECC_BUFF_LEN))

  00010	e59f4054	 ldr         r4, [pc, #0x54]
  00014	e3a03003	 mov         r3, #3
  00018	e1a02004	 mov         r2, r4
  0001c	eb000000	 bl          ECC_ComputeECC
  00020	e3500000	 cmp         r0, #0

; 192  : 	{
; 193  : 		return FALSE;

  00024	0a00000d	 beq         |$LN10@ECC_IsData|

; 194  : 	}
; 195  : 
; 196  : 	//----- 2. Compare the generated ECC info with the existing ECC info  -----
; 197  : 	//         NOTE: The data is valid if XORing all the ECC info together equals zero
; 198  : 	for(i=0; i<ECC_BUFF_LEN; i++)

  00028	e3a01000	 mov         r1, #0
  0002c	e5c41003	 strb        r1, [r4, #3]
  00030		 |$LL4@ECC_IsData|

; 199  : 	{
; 200  : 		if((newECC[i] != *(pExistingECC+i)))

  00030	e7d12005	 ldrb        r2, [r1, +r5]
  00034	e7d13004	 ldrb        r3, [r1, +r4]
  00038	e1530002	 cmp         r3, r2
  0003c	1a000007	 bne         |$LN10@ECC_IsData|
  00040	e2813001	 add         r3, r1, #1
  00044	e20310ff	 and         r1, r3, #0xFF
  00048	e5c41003	 strb        r1, [r4, #3]
  0004c	e3510003	 cmp         r1, #3
  00050	3afffff6	 bcc         |$LL4@ECC_IsData|

; 203  : 		}
; 204  : 	}
; 205  : 
; 206  : 	return TRUE;	

  00054	e3a00001	 mov         r0, #1

; 207  : }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN10@ECC_IsData|

; 201  : 		{
; 202  : 			return FALSE;

  00060	e3a00000	 mov         r0, #0

; 207  : }

  00064	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN15@ECC_IsData|
  0006c		 |$LN16@ECC_IsData|
  0006c	00000000	 DCD         |?newECC@?1??ECC_IsDataValid@@9@9|
  00070		 |$M39104|

			 ENDP  ; |ECC_IsDataValid|

	END
