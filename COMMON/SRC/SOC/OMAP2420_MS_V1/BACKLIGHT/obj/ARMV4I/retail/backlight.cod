; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\BACKLIGHT\backlight.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
	 COMMON	|DEVICE_IFC_I2C_GUID|, 0x10

	EXPORT	|I2COpen|
	IMPORT	|LocalFree|
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43042| DCD	|$LN8@I2COpen|
	DCD	0x40002e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2COpen| PROC

; 86   : {

  00000		 |$LN8@I2COpen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43039|

; 87   :     HANDLE hDevice;
; 88   :     DEVICE_CONTEXT_I2C *pContext = NULL;
; 89   : 
; 90   :     hDevice = CreateFile(devicename, 0, 0, NULL, 0, 0, NULL);

  00008	e3a06000	 mov         r6, #0
  0000c	e3a03000	 mov         r3, #0
  00010	e3a02000	 mov         r2, #0
  00014	e3a01000	 mov         r1, #0
  00018	e58d6008	 str         r6, [sp, #8]
  0001c	e58d6004	 str         r6, [sp, #4]
  00020	e58d6000	 str         r6, [sp]
  00024	e3a04000	 mov         r4, #0
  00028	eb000000	 bl          CreateFileW
  0002c	e1a05000	 mov         r5, r0

; 91   :     if (hDevice == INVALID_HANDLE_VALUE) goto clean;

  00030	e3750001	 cmn         r5, #1
  00034	0a00001a	 beq         |$clean$42746|

; 92   : 
; 93   :     // Allocate memory for our handler...
; 94   :     if ((pContext = (DEVICE_CONTEXT_I2C *)LocalAlloc(
; 95   :         LPTR, sizeof(DEVICE_CONTEXT_I2C)
; 96   :     )) == NULL) {

  00038	e3a01010	 mov         r1, #0x10
  0003c	e3a00040	 mov         r0, #0x40
  00040	eb000000	 bl          LocalAlloc
  00044	e1b04000	 movs        r4, r0

; 97   :         CloseHandle(hDevice);

  00048	e1a00005	 mov         r0, r5
  0004c	1a000001	 bne         |$LN2@I2COpen|
  00050	eb000000	 bl          CloseHandle

; 98   :         goto clean;

  00054	ea000012	 b           |$clean$42746|
  00058		 |$LN2@I2COpen|

; 99   :     }
; 100  : 
; 101  :     // Get function pointers, fail when IOCTL isn't supported...
; 102  :     if (!DeviceIoControl(
; 103  :         hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_I2C_GUID,
; 104  :         sizeof(DEVICE_IFC_I2C_GUID), &pContext->ifc, sizeof(DEVICE_IFC_I2C),
; 105  :         NULL, NULL
; 106  :     )) {

  00058	e59f2054	 ldr         r2, [pc, #0x54]
  0005c	e3a03822	 mov         r3, #0x22, 16
  00060	e3831b01	 orr         r1, r3, #1, 22
  00064	e3a0e00c	 mov         lr, #0xC
  00068	e3a03010	 mov         r3, #0x10
  0006c	e58d600c	 str         r6, [sp, #0xC]
  00070	e58d6008	 str         r6, [sp, #8]
  00074	e58de004	 str         lr, [sp, #4]
  00078	e58d4000	 str         r4, [sp]
  0007c	eb000000	 bl          DeviceIoControl
  00080	e3500000	 cmp         r0, #0
  00084	1a000005	 bne         |$LN1@I2COpen|

; 107  :         CloseHandle(hDevice);

  00088	e1a00005	 mov         r0, r5
  0008c	eb000000	 bl          CloseHandle

; 108  :         LocalFree(pContext);

  00090	e1a00004	 mov         r0, r4
  00094	eb000000	 bl          LocalFree

; 109  :         pContext = NULL;

  00098	e3a04000	 mov         r4, #0

; 110  :         goto clean;

  0009c	ea000000	 b           |$clean$42746|
  000a0		 |$LN1@I2COpen|

; 111  :     }
; 112  : 
; 113  :     // Save device handle
; 114  :     pContext->hDevice = hDevice;

  000a0	e584500c	 str         r5, [r4, #0xC]
  000a4		 |$clean$42746|

; 115  : 
; 116  : clean:
; 117  :     return pContext;
; 118  : }

  000a4	e1a00004	 mov         r0, r4
  000a8	e28dd010	 add         sp, sp, #0x10
  000ac	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN9@I2COpen|
  000b4		 |$LN10@I2COpen|
  000b4	00000000	 DCD         |DEVICE_IFC_I2C_GUID|
  000b8		 |$M43040|

			 ENDP  ; |I2COpen|

	EXPORT	|I2CClose|

  00000			 AREA	 |.pdata|, PDATA
|$T43052| DCD	|$LN7@I2CClose|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2CClose| PROC

; 121  : {

  00000		 |$LN7@I2CClose|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43049|
  00004	e1b04000	 movs        r4, r0

; 122  :     DEVICE_CONTEXT_I2C *pContext = (DEVICE_CONTEXT_I2C *)hContext;
; 123  : 
; 124  :     if ( (pContext != NULL) && (pContext->hDevice != INVALID_HANDLE_VALUE) )

  00008	0a000004	 beq         |$LN1@I2CClose|
  0000c	e594000c	 ldr         r0, [r4, #0xC]
  00010	e3700001	 cmn         r0, #1

; 125  :         CloseHandle(pContext->hDevice);

  00014	1b000000	 blne        CloseHandle

; 126  : 
; 127  :     if (pContext != NULL)
; 128  :         LocalFree(pContext);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          LocalFree
  00020		 |$LN1@I2CClose|

; 129  : }

  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43050|

			 ENDP  ; |I2CClose|

	EXPORT	|I2CSetSlaveAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T43064| DCD	|$LN5@I2CSetSlav|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2CSetSlaveAddress| PROC

; 132  : {

  00000		 |$LN5@I2CSetSlav|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43061|
  00004	e1a03000	 mov         r3, r0

; 133  :     DEVICE_CONTEXT_I2C *pContext = (DEVICE_CONTEXT_I2C *)hContext;
; 134  :     return pContext->ifc.pfnSetSlaveAddress(pContext->ifc.context, size, address);

  00008	e5930000	 ldr         r0, [r3]
  0000c	e5933004	 ldr         r3, [r3, #4]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 135  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M43062|

			 ENDP  ; |I2CSetSlaveAddress|

	EXPORT	|I2CTransact|

  00000			 AREA	 |.pdata|, PDATA
|$T43075| DCD	|$LN5@I2CTransac|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2CTransact| PROC

; 138  : {

  00000		 |$LN5@I2CTransac|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43072|
  00004	e1a03000	 mov         r3, r0

; 139  :     DEVICE_CONTEXT_I2C *pContext = (DEVICE_CONTEXT_I2C *)hContext;
; 140  :     return pContext->ifc.pfnTransact(pContext->ifc.context, pTrans);

  00008	e5930000	 ldr         r0, [r3]
  0000c	e5933008	 ldr         r3, [r3, #8]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 141  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M43073|

			 ENDP  ; |I2CTransact|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|BKL_SetState|
	EXPORT	|??_C@_1M@LCEEOPDH@?$AAI?$AA2?$AAC?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T43114| DCD	|$LN25@BKL_SetSta|
	DCD	0xc0004d02

  00000			 AREA	 |.xdata|, DATA
|$T43110| DCD	0xffffffec

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@LCEEOPDH@?$AAI?$AA2?$AAC?$AA1?$AA?3?$AA?$AA@| DCB "I", 0x0, "2", 0x0
	DCB	"C", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\backlight\backlight.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43110|

  00008		 |BKL_SetState| PROC

; 90   : {

  00008		 |$LN25@BKL_SetSta|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24ddf5d	 sub         sp, sp, #0x5D, 30
  00010		 |$M43111|
  00010	e1a06000	 mov         r6, r0
  00014	e59f311c	 ldr         r3, [pc, #0x11C]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3170	 str         r3, [sp, #0x170]

; 91   :     HANDLE hI2C = NULL ;
; 92   :     BOOL retVal = FALSE;
; 93   :     I2CTRANS sI2C_Transaction;
; 94   : 
; 95   :     DEBUGMSG(ZONE_FUNCTION, (L"+BKL_SetState(%d)\r\n", bEnable));
; 96   : 
; 97   :     // open I2C bus
; 98   :     hI2C = I2COpen(I2C_DEVICE_NAME);

  00020	e59f010c	 ldr         r0, [pc, #0x10C]
  00024	e3a05000	 mov         r5, #0
  00028	eb000000	 bl          I2COpen
  0002c	e1b04000	 movs        r4, r0

; 99   : 
; 100  :     if (hI2C == NULL) {

  00030	0a000039	 beq         |$LN18@BKL_SetSta|

; 101  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BKL_SetState: "
; 102  :             L"Failed open I2C device\r\n"
; 103  :         ));
; 104  :         goto cleanUp;
; 105  :     }
; 106  : 
; 107  :     if (!I2CSetSlaveAddress( hI2C, I2C_BACKLIGHT_ADDRSIZE, I2C_BACKLIGHT_ADDRESS) )

  00034	e5940000	 ldr         r0, [r4]
  00038	e5943004	 ldr         r3, [r4, #4]
  0003c	e3a02020	 mov         r2, #0x20
  00040	e3a01007	 mov         r1, #7
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3
  0004c	e3500000	 cmp         r0, #0
  00050	0a00002c	 beq         |$cleanUp$42811|

; 108  :     {
; 109  : 
; 110  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BKL_SetState: "
; 111  :             L"Failed to set backlight I2C address\r\n"
; 112  :         ));
; 113  :         goto cleanUp;
; 114  :     }
; 115  : 
; 116  :     // Initialize I2C Transaction Structure
; 117  :     ZeroMemory(&sI2C_Transaction, sizeof(sI2C_Transaction));

  00054	e3a02e17	 mov         r2, #0x17, 28
  00058	e3a01000	 mov         r1, #0
  0005c	e28d0000	 add         r0, sp, #0
  00060	eb000000	 bl          memset

; 118  : 
; 119  :     // Set up an I2C Transaction to read the initial values
; 120  :     // of the lines controlled by this I2C Device
; 121  :     sI2C_Transaction.mClk_HL_Divisor  = I2C_CLOCK_DEFAULT;

  00064	e3a0300f	 mov         r3, #0xF

; 122  :     sI2C_Transaction.mOpCode[0]       = I2C_OPCODE_READ;

  00068	e3a02001	 mov         r2, #1

; 123  :     sI2C_Transaction.mTransLen[0]     = 1;

  0006c	e3a01001	 mov         r1, #1

; 124  :     sI2C_Transaction.mBufferOffset[0] = 0;

  00070	e3a00000	 mov         r0, #0
  00074	e58d3008	 str         r3, [sp, #8]
  00078	e58d200c	 str         r2, [sp, #0xC]
  0007c	e58d104c	 str         r1, [sp, #0x4C]
  00080	e58d002c	 str         r0, [sp, #0x2C]

; 125  : 
; 126  :     // Perform the I2C Read
; 127  :     I2CTransact(hI2C, &sI2C_Transaction);

  00084	e5940000	 ldr         r0, [r4]
  00088	e5943008	 ldr         r3, [r4, #8]
  0008c	e28d1000	 add         r1, sp, #0
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff13	 bx          r3

; 128  : 
; 129  :     if (sI2C_Transaction.mErrorCode != 0)

  00098	e59d306c	 ldr         r3, [sp, #0x6C]
  0009c	e3530000	 cmp         r3, #0
  000a0	1a000018	 bne         |$cleanUp$42811|

; 130  :     {
; 131  :         DEBUGMSG(ZONE_ERROR, (L"BKL_SetState() - "
; 132  :             L"ERROR: I2C Read Transaction Failed with Error 0x%08X\r\n", sI2C_Transaction.mErrorCode
; 133  :         ));
; 134  :     }
; 135  :     else
; 136  :     {
; 137  :         // Set or clear the appropriate bit.
; 138  :         if (bEnable)
; 139  :         {
; 140  :             sI2C_Transaction.mBuffer[0] |=  (1 << 5);

  000a4	e5dd3070	 ldrb        r3, [sp, #0x70]
  000a8	e3560000	 cmp         r6, #0

; 141  :         }
; 142  :         else
; 143  :         {
; 144  :             sI2C_Transaction.mBuffer[0] &= ~(1 << 5);
; 145  :         }
; 146  : 
; 147  :         // Set up an I2C Transaction to write the new value
; 148  :         // and verify that it was written correctly.
; 149  :         sI2C_Transaction.mOpCode[0]       = I2C_OPCODE_WRITE;
; 150  :         sI2C_Transaction.mTransLen[0]     = 1;

  000ac	e3a02001	 mov         r2, #1
  000b0	13833020	 orrne       r3, r3, #0x20
  000b4	020330df	 andeq       r3, r3, #0xDF
  000b8	e5cd3070	 strb        r3, [sp, #0x70]
  000bc	e3a03002	 mov         r3, #2

; 151  :         sI2C_Transaction.mBufferOffset[0] = 0;

  000c0	e3a01000	 mov         r1, #0

; 152  :         sI2C_Transaction.mOpCode[1]       = I2C_OPCODE_READ;

  000c4	e3a00001	 mov         r0, #1

; 153  :         sI2C_Transaction.mTransLen[1]     = 1;

  000c8	e3a0e001	 mov         lr, #1

; 154  :         sI2C_Transaction.mBufferOffset[1] = 0;

  000cc	e3a06000	 mov         r6, #0
  000d0	e58d300c	 str         r3, [sp, #0xC]
  000d4	e58d204c	 str         r2, [sp, #0x4C]
  000d8	e58d102c	 str         r1, [sp, #0x2C]
  000dc	e58d0010	 str         r0, [sp, #0x10]
  000e0	e58de050	 str         lr, [sp, #0x50]
  000e4	e58d6030	 str         r6, [sp, #0x30]

; 155  : 
; 156  :         // Perform the Write and Verification Read
; 157  :         I2CTransact(hI2C, &sI2C_Transaction);

  000e8	e5940000	 ldr         r0, [r4]
  000ec	e5943008	 ldr         r3, [r4, #8]
  000f0	e28d1000	 add         r1, sp, #0
  000f4	e1a0e00f	 mov         lr, pc
  000f8	e12fff13	 bx          r3

; 158  : 
; 159  :         if (sI2C_Transaction.mErrorCode != 0)

  000fc	e59d306c	 ldr         r3, [sp, #0x6C]
  00100	e3530000	 cmp         r3, #0

; 160  :         {
; 161  :             DEBUGMSG(ZONE_ERROR, (L"BKL_SetState() - "
; 162  :                 L"ERROR: I2C Write/Verify Transaction Failed with Error 0x%08X\r\n", sI2C_Transaction.mErrorCode
; 163  :             ));
; 164  :         }
; 165  :         else
; 166  :         {
; 167  :             retVal = TRUE;

  00104	03a05001	 moveq       r5, #1
  00108		 |$cleanUp$42811|

; 168  :         }
; 169  :     }
; 170  : 
; 171  : cleanUp:
; 172  :     DEBUGMSG(ZONE_I2C&&ZONE_FUNCTION, (L"-BKL_SetState(retVal = %d)\r\n", retVal));
; 173  : 
; 174  :     if (hI2C)
; 175  :         I2CClose(hI2C);

  00108	e594000c	 ldr         r0, [r4, #0xC]
  0010c	e3700001	 cmn         r0, #1
  00110	1b000000	 blne        CloseHandle
  00114	e1a00004	 mov         r0, r4
  00118	eb000000	 bl          LocalFree
  0011c		 |$LN18@BKL_SetSta|

; 176  : 
; 177  :     return retVal;

  0011c	e59d0170	 ldr         r0, [sp, #0x170]
  00120	eb000000	 bl          __security_check_cookie

; 178  : }

  00124	e1a00005	 mov         r0, r5
  00128	e28ddf5d	 add         sp, sp, #0x5D, 30
  0012c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN26@BKL_SetSta|
  00134		 |$LN27@BKL_SetSta|
  00134	00000000	 DCD         |??_C@_1M@LCEEOPDH@?$AAI?$AA2?$AAC?$AA1?$AA?3?$AA?$AA@|
  00138		 |$LN28@BKL_SetSta|
  00138	00000000	 DCD         |__security_cookie|
  0013c		 |$M43112|

			 ENDP  ; |BKL_SetState|

	EXPORT	|BKL_Deinit|

  00000			 AREA	 |.pdata|, PDATA
|$T43129| DCD	|$LN8@BKL_Deinit|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BKL_Deinit| PROC

; 228  : {

  00000		 |$LN8@BKL_Deinit|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43126|
  00004	e3500000	 cmp         r0, #0

; 229  :     BOOL rc = FALSE;

  00008	e3a01000	 mov         r1, #0

; 230  :     BKL_DEVICE *pDevice = (BKL_DEVICE*)context;
; 231  : 
; 232  :     DEBUGMSG(ZONE_FUNCTION, (L"+BKL_Deinit(0x%08x)\r\n", context));
; 233  : 
; 234  :     // Check if we get correct context
; 235  :     if (pDevice == NULL || pDevice->cookie != BKL_DEVICE_COOKIE) {

  0000c	0a000008	 beq         |$cleanUp$42857|
  00010	e5902000	 ldr         r2, [r0]
  00014	e59f3024	 ldr         r3, [pc, #0x24]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000004	 bne         |$cleanUp$42857|

; 236  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: BKL_Deinit: "
; 237  :             L"Incorrect context parameter\r\n"
; 238  :         ));
; 239  :         goto cleanUp;
; 240  :     }
; 241  : 
; 242  :     // Check for open instances
; 243  :     if (pDevice->instances > 0) {

  00020	e5903004	 ldr         r3, [r0, #4]
  00024	e3530000	 cmp         r3, #0
  00028	ca000001	 bgt         |$cleanUp$42857|

; 244  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: BKL_Deinit: "
; 245  :             L"Deinit with active instance (%d instances active)\r\n",
; 246  :             pDevice->instances
; 247  :         ));
; 248  :         goto cleanUp;
; 249  :     }
; 250  : 
; 251  :     // Free device structure
; 252  :     LocalFree(pDevice);

  0002c	eb000000	 bl          LocalFree

; 253  : 
; 254  :     // Done
; 255  :     rc = TRUE;

  00030	e3a01001	 mov         r1, #1
  00034		 |$cleanUp$42857|

; 256  : 
; 257  : cleanUp:
; 258  :     DEBUGMSG(ZONE_FUNCTION, (L"-BKL_Deinit(rc = %d)\r\n", rc));
; 259  :     return rc;
; 260  : }

  00034	e1a00001	 mov         r0, r1
  00038	e49de004	 ldr         lr, [sp], #4
  0003c	e12fff1e	 bx          lr
  00040		 |$LN9@BKL_Deinit|
  00040		 |$LN10@BKL_Deinit|
  00040	626b6c44	 DCD         0x626b6c44
  00044		 |$M43127|

			 ENDP  ; |BKL_Deinit|

	EXPORT	|BKL_Open|
	IMPORT	|InterlockedIncrement|

  00000			 AREA	 |.pdata|, PDATA
|$T43143| DCD	|$LN8@BKL_Open|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BKL_Open| PROC

; 269  : {

  00000		 |$LN8@BKL_Open|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43140|
  00004	e1b04000	 movs        r4, r0

; 270  :     DWORD rc = (DWORD)NULL;

  00008	e3a06000	 mov         r6, #0

; 271  :     BKL_DEVICE *pDevice = (BKL_DEVICE*)context;
; 272  :     BKL_INSTANCE *pInstance = NULL;
; 273  : 
; 274  :     DEBUGMSG(ZONE_FUNCTION, (
; 275  :         L"+BKL_Open(0x%08x, 0x%08x, 0x%08x\r\n", context, accessCode, shareMode
; 276  :     ));
; 277  : 
; 278  :     // Check if we get correct context
; 279  :     if (pDevice == NULL || pDevice->cookie != BKL_DEVICE_COOKIE) {

  0000c	0a00000d	 beq         |$cleanUp$42881|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f303c	 ldr         r3, [pc, #0x3C]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000009	 bne         |$cleanUp$42881|

; 280  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: BKL_Open: "
; 281  :             L"Incorrect context parameter\r\n"
; 282  :         ));
; 283  :         goto cleanUp;
; 284  :     }
; 285  : 
; 286  :     // Create device structure
; 287  :     pInstance = (BKL_INSTANCE*)LocalAlloc(LPTR, sizeof(BKL_INSTANCE));

  00020	e3a01008	 mov         r1, #8
  00024	e3a00040	 mov         r0, #0x40
  00028	eb000000	 bl          LocalAlloc
  0002c	e1b05000	 movs        r5, r0

; 288  :     if (pInstance == NULL) {

  00030	0a000004	 beq         |$cleanUp$42881|

; 289  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BKL_Open: "
; 290  :             L"Failed allocate BKL instance structure\r\n"
; 291  :         ));
; 292  :         goto cleanUp;
; 293  :     }
; 294  : 
; 295  :     // Set cookie
; 296  :     pInstance->cookie = BKL_INSTANCE_COOKIE;

  00034	e59f3018	 ldr         r3, [pc, #0x18]

; 297  : 
; 298  :     // Save device reference
; 299  :     pInstance->pDevice = pDevice;
; 300  : 
; 301  :     // Increment number of open instances
; 302  :     InterlockedIncrement(&pDevice->instances);

  00038	e2840004	 add         r0, r4, #4
  0003c	e8850018	 stmia       r5, {r3, r4}
  00040	eb000000	 bl          InterlockedIncrement

; 303  : 
; 304  :     // sanity check number of instances
; 305  :     ASSERT(pDevice->instances > 0);
; 306  : 
; 307  :     // Done...
; 308  :     rc = (DWORD)pInstance;

  00044	e1a06005	 mov         r6, r5
  00048		 |$cleanUp$42881|

; 309  : 
; 310  : cleanUp:
; 311  :     DEBUGMSG(ZONE_FUNCTION, (L"-BKL_Open(rc = 0x%08x)\r\n", rc));
; 312  :     return rc;
; 313  : }

  00048	e1a00006	 mov         r0, r6
  0004c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN9@BKL_Open|
  00054		 |$LN10@BKL_Open|
  00054	626b6c49	 DCD         0x626b6c49
  00058		 |$LN11@BKL_Open|
  00058	626b6c44	 DCD         0x626b6c44
  0005c		 |$M43141|

			 ENDP  ; |BKL_Open|

	EXPORT	|BKL_Close|
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T43157| DCD	|$LN7@BKL_Close|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BKL_Close| PROC

; 322  : {

  00000		 |$LN7@BKL_Close|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43154|
  00004	e1b04000	 movs        r4, r0

; 323  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 324  :     BKL_DEVICE *pDevice;
; 325  :     BKL_INSTANCE *pInstance = (BKL_INSTANCE*)context;
; 326  : 
; 327  :     DEBUGMSG(ZONE_FUNCTION, (L"+BKL_Close(0x%08x)\r\n", context));
; 328  : 
; 329  :     // Check if we get correct context
; 330  :     if (pInstance == NULL || pInstance->cookie != BKL_INSTANCE_COOKIE) {

  0000c	0a000009	 beq         |$cleanUp$42903|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3024	 ldr         r3, [pc, #0x24]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000005	 bne         |$cleanUp$42903|

; 331  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: BKL_Read: "
; 332  :             L"Incorrect context paramer\r\n"
; 333  :         ));
; 334  :         goto cleanUp;
; 335  :     }
; 336  : 
; 337  :     // Get device context
; 338  :     pDevice = pInstance->pDevice;
; 339  : 
; 340  :     // sanity check number of instances
; 341  :     ASSERT(pDevice->instances > 0);
; 342  : 
; 343  :     // Decrement number of open instances
; 344  :     InterlockedDecrement(&pDevice->instances);

  00020	e5943004	 ldr         r3, [r4, #4]
  00024	e2830004	 add         r0, r3, #4
  00028	eb000000	 bl          InterlockedDecrement

; 345  : 
; 346  :     // Free instance structure
; 347  :     LocalFree(pInstance);

  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          LocalFree

; 348  : 
; 349  :     // Done...
; 350  :     rc = TRUE;

  00034	e3a00001	 mov         r0, #1
  00038		 |$cleanUp$42903|

; 351  : 
; 352  : cleanUp:
; 353  :     DEBUGMSG(ZONE_FUNCTION, (L"-BKL_Close(rc = %d)\r\n", rc));
; 354  :     return rc;
; 355  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN8@BKL_Close|
  00040		 |$LN9@BKL_Close|
  00040	626b6c49	 DCD         0x626b6c49
  00044		 |$M43155|

			 ENDP  ; |BKL_Close|

	EXPORT	|BKL_IOControl|
	IMPORT	|SetLastError|
	IMPORT	|CeSafeCopyMemory|

  00000			 AREA	 |.pdata|, PDATA
|$T43180| DCD	|$LN31@BKL_IOCont|
	DCD	0x40006b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BKL_IOControl| PROC

; 366  : ) {

  00000		 |$LN31@BKL_IOCont|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd034	 sub         sp, sp, #0x34
  00008		 |$M43177|
  00008	e3500000	 cmp         r0, #0

; 367  :     BOOL rc = FALSE;

  0000c	e3a04000	 mov         r4, #0

; 368  :     BKL_INSTANCE *pInstance = (BKL_INSTANCE*)context;
; 369  :     BKL_DEVICE *pDevice;
; 370  :     POWER_CAPABILITIES powerCap;
; 371  :     CEDEVICE_POWER_STATE powerState;
; 372  : 
; 373  : 
; 374  :     DEBUGMSG(ZONE_FUNCTION, (L"+BKL_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 375  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 376  :     ));
; 377  : 
; 378  :     // Check if we get correct context
; 379  :     if (pInstance == NULL || pInstance->cookie != BKL_INSTANCE_COOKIE) {

  00010	0a00005d	 beq         |$cleanUp$42933|
  00014	e5902000	 ldr         r2, [r0]
  00018	e59f3188	 ldr         r3, [pc, #0x188]
  0001c	e1520003	 cmp         r2, r3
  00020	1a000059	 bne         |$cleanUp$42933|
  00024	e3a03832	 mov         r3, #0x32, 16

; 380  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BKL_IOControl: "
; 381  :             L"Incorrect context paramer\r\n"
; 382  :         ));
; 383  :         goto cleanUp;
; 384  :     }
; 385  : 
; 386  :     // Device structure
; 387  :     pDevice = pInstance->pDevice;
; 388  : 
; 389  :     switch (code) {

  00028	e3833a01	 orr         r3, r3, #1, 20
  0002c	e5905004	 ldr         r5, [r0, #4]
  00030	e1510003	 cmp         r1, r3
  00034	0a00003b	 beq         |$LN21@BKL_IOCont|
  00038	e59f3164	 ldr         r3, [pc, #0x164]
  0003c	e1510003	 cmp         r1, r3
  00040	0a00002b	 beq         |$LN4@BKL_IOCont|
  00044	e59f3154	 ldr         r3, [pc, #0x154]
  00048	e1510003	 cmp         r1, r3
  0004c	0a000004	 beq         |$LN16@BKL_IOCont|
  00050	e59f3144	 ldr         r3, [pc, #0x144]
  00054	e1510003	 cmp         r1, r3
  00058	1a00004b	 bne         |$cleanUp$42933|

; 401  :             SetLastError(ERROR_INVALID_PARAMETER);
; 402  :             break;
; 403  :         }
; 404  :         rc = TRUE;

  0005c	e3a04001	 mov         r4, #1

; 405  :         break;

  00060	ea000049	 b           |$cleanUp$42933|
  00064		 |$LN16@BKL_IOCont|

; 406  : 
; 407  :     // Request a change from one device power state to another.
; 408  :     case IOCTL_POWER_SET:
; 409  :         DEBUGMSG(ZONE_POWER, (L"Backlight: IOCTL_POWER_SET %d\r\n", *(CEDEVICE_POWER_STATE*)pOutBuffer ));
; 410  :         // Check input parameters
; 411  :         if (pOutSize != NULL)

  00064	e59d3050	 ldr         r3, [sp, #0x50]

; 412  :         {
; 413  :             *pOutSize = sizeof(CEDEVICE_POWER_STATE);
; 414  :         }
; 415  :         if (pOutBuffer == NULL || outSize < sizeof(CEDEVICE_POWER_STATE) ||
; 416  :             !CeSafeCopyMemory(&powerState, pOutBuffer, sizeof(powerState)) )

  00068	e59d6048	 ldr         r6, [sp, #0x48]
  0006c	e3a07004	 mov         r7, #4
  00070	e3530000	 cmp         r3, #0
  00074	15837000	 strne       r7, [r3]
  00078	e3560000	 cmp         r6, #0
  0007c	0a000040	 beq         |$LN18@BKL_IOCont|
  00080	e59d304c	 ldr         r3, [sp, #0x4C]
  00084	e3530004	 cmp         r3, #4
  00088	3a00003d	 bcc         |$LN18@BKL_IOCont|
  0008c	e3a02004	 mov         r2, #4
  00090	e1a01006	 mov         r1, r6
  00094	e28d0000	 add         r0, sp, #0
  00098	eb000000	 bl          CeSafeCopyMemory
  0009c	e3500000	 cmp         r0, #0
  000a0	0a000037	 beq         |$LN18@BKL_IOCont|

; 417  :         {
; 418  :             SetLastError(ERROR_INVALID_PARAMETER);
; 419  :             break;
; 420  :         }
; 421  :         // Check for any valid power state.
; 422  :         if (!VALID_DX(powerState))

  000a4	e59d3000	 ldr         r3, [sp]
  000a8	e3530004	 cmp         r3, #4
  000ac	8a000036	 bhi         |$cleanUp$42933|

; 423  :         {
; 424  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: BKL_IOControl: "
; 425  :                 L"Invalid power state 0x%08x\r\n", powerState));
; 426  :             break;
; 427  :         }
; 428  :         switch (powerState)

  000b0	e3530000	 cmp         r3, #0
  000b4	0a000006	 beq         |$LN8@BKL_IOCont|
  000b8	da000009	 ble         |$LN9@BKL_IOCont|
  000bc	e3530004	 cmp         r3, #4
  000c0	ca000007	 bgt         |$LN9@BKL_IOCont|

; 435  :             break;
; 436  :          case D1:
; 437  :          case D2:
; 438  :          case D3:
; 439  :          case D4:
; 440  :             DEBUGMSG(ZONE_POWER, (L"-BKL_IOControl: Backlight OFF\r\n"));
; 441  :             // Switch LCD backlight off
; 442  :             BKL_SetState(FALSE);

  000c4	e3a00000	 mov         r0, #0
  000c8	eb000000	 bl          BKL_SetState

; 443  :             pDevice->ps = D4;

  000cc	e5857008	 str         r7, [r5, #8]

; 444  :             break;

  000d0	ea000003	 b           |$LN9@BKL_IOCont|
  000d4		 |$LN8@BKL_IOCont|

; 429  :         {
; 430  :         case D0:
; 431  :             DEBUGMSG(ZONE_POWER, (L"-BKL_IOControl: Backlight ON\r\n"));
; 432  :             // Switch LCD backlight on
; 433  :             BKL_SetState(TRUE);

  000d4	e3a00001	 mov         r0, #1
  000d8	eb000000	 bl          BKL_SetState

; 434  :             pDevice->ps = D0;

  000dc	e3a03000	 mov         r3, #0
  000e0	e5853008	 str         r3, [r5, #8]
  000e4		 |$LN9@BKL_IOCont|

; 445  :         }
; 446  :         if (!CeSafeCopyMemory(pOutBuffer, &pDevice->ps, sizeof(pDevice->ps))) {

  000e4	e3a02004	 mov         r2, #4
  000e8	e2851008	 add         r1, r5, #8
  000ec	e1a00006	 mov         r0, r6
  000f0	ea00001f	 b           |$LN28@BKL_IOCont|
  000f4		 |$LN4@BKL_IOCont|

; 447  :             SetLastError(ERROR_INVALID_PARAMETER);
; 448  :             break;
; 449  :         }
; 450  :         rc = TRUE;
; 451  :         break;
; 452  : 
; 453  :     // This is to satisfy the CETK test cases
; 454  :     case IOCTL_POWER_QUERY:
; 455  :         rc = TRUE;
; 456  :         break;
; 457  : 
; 458  :     // Return the current device power state.
; 459  :     case IOCTL_POWER_GET:
; 460  :         // Check input parameters
; 461  :         if (pOutSize != NULL) *pOutSize = sizeof(CEDEVICE_POWER_STATE);

  000f4	e59d3050	 ldr         r3, [sp, #0x50]

; 462  :         if (
; 463  :             pOutBuffer == NULL || outSize < sizeof(CEDEVICE_POWER_STATE) ||
; 464  :             !CeSafeCopyMemory(pOutBuffer, &pDevice->ps, sizeof(pDevice->ps))
; 465  :         ) {

  000f8	e59d0048	 ldr         r0, [sp, #0x48]
  000fc	e3530000	 cmp         r3, #0
  00100	13a02004	 movne       r2, #4
  00104	15832000	 strne       r2, [r3]
  00108	e3500000	 cmp         r0, #0
  0010c	0a00001c	 beq         |$LN18@BKL_IOCont|
  00110	e59d304c	 ldr         r3, [sp, #0x4C]
  00114	e3530004	 cmp         r3, #4
  00118	3a000019	 bcc         |$LN18@BKL_IOCont|
  0011c	e3a02004	 mov         r2, #4
  00120	e2851008	 add         r1, r5, #8

; 466  :             SetLastError(ERROR_INVALID_PARAMETER);
; 467  :             break;

  00124	ea000012	 b           |$LN28@BKL_IOCont|
  00128		 |$LN21@BKL_IOCont|

; 390  :     // Return device specific power capabilities.
; 391  :     case IOCTL_POWER_CAPABILITIES:
; 392  :         // Check input parameters
; 393  :         if (pOutSize != NULL) *pOutSize = sizeof(POWER_CAPABILITIES);

  00128	e59d3050	 ldr         r3, [sp, #0x50]

; 394  :         if (pOutBuffer == NULL || outSize < sizeof(POWER_CAPABILITIES)) {

  0012c	e59d5048	 ldr         r5, [sp, #0x48]
  00130	e3530000	 cmp         r3, #0
  00134	13a02030	 movne       r2, #0x30
  00138	15832000	 strne       r2, [r3]
  0013c	e3550000	 cmp         r5, #0
  00140	0a00000f	 beq         |$LN18@BKL_IOCont|
  00144	e59d304c	 ldr         r3, [sp, #0x4C]
  00148	e3530030	 cmp         r3, #0x30
  0014c	3a00000c	 bcc         |$LN18@BKL_IOCont|

; 396  :             break;
; 397  :         }
; 398  :         memset(&powerCap, 0, sizeof(powerCap));

  00150	e3a02030	 mov         r2, #0x30
  00154	e3a01000	 mov         r1, #0
  00158	e28d0004	 add         r0, sp, #4
  0015c	eb000000	 bl          memset

; 399  :         powerCap.DeviceDx = DX_MASK(D0) | DX_MASK(D4);

  00160	e3a03011	 mov         r3, #0x11
  00164	e5cd3004	 strb        r3, [sp, #4]

; 400  :         if (!CeSafeCopyMemory(pOutBuffer, &powerCap, sizeof(powerCap))) {

  00168	e3a02030	 mov         r2, #0x30
  0016c	e28d1004	 add         r1, sp, #4
  00170	e1a00005	 mov         r0, r5
  00174		 |$LN28@BKL_IOCont|
  00174	eb000000	 bl          CeSafeCopyMemory
  00178	e3500000	 cmp         r0, #0

; 401  :             SetLastError(ERROR_INVALID_PARAMETER);
; 402  :             break;
; 403  :         }
; 404  :         rc = TRUE;

  0017c	13a04001	 movne       r4, #1
  00180	1a000001	 bne         |$cleanUp$42933|
  00184		 |$LN18@BKL_IOCont|

; 395  :             SetLastError(ERROR_INVALID_PARAMETER);

  00184	e3a00057	 mov         r0, #0x57
  00188	eb000000	 bl          SetLastError
  0018c		 |$cleanUp$42933|

; 468  :         }
; 469  :         rc = TRUE;
; 470  :         break;
; 471  :     }
; 472  : 
; 473  : cleanUp:
; 474  :     DEBUGMSG(ZONE_FUNCTION, (L"-BKL_IOControl(rc = %d)\r\n", rc));
; 475  :     return rc;
; 476  : }

  0018c	e1a00004	 mov         r0, r4
  00190	e28dd034	 add         sp, sp, #0x34
  00194	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00198	e12fff1e	 bx          lr
  0019c		 |$LN32@BKL_IOCont|
  0019c		 |$LN33@BKL_IOCont|
  0019c	0032100c	 DCD         0x32100c
  001a0		 |$LN34@BKL_IOCont|
  001a0	00321008	 DCD         0x321008
  001a4		 |$LN35@BKL_IOCont|
  001a4	00321004	 DCD         0x321004
  001a8		 |$LN36@BKL_IOCont|
  001a8	626b6c49	 DCD         0x626b6c49
  001ac		 |$M43178|

			 ENDP  ; |BKL_IOControl|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|

  00000			 AREA	 |.pdata|, PDATA
|$T43196| DCD	|$LN8@DllMain|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 485  : {

  00000		 |$LN8@DllMain|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43193|

; 486  :     switch (reason) {

  00004	e3510001	 cmp         r1, #1

; 487  :     case DLL_PROCESS_ATTACH:
; 488  :         DEBUGREGISTER(hDLL);
; 489  :         DisableThreadLibraryCalls((HMODULE)hDLL);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 490  :         break;
; 491  :     }
; 492  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 493  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M43194|

			 ENDP  ; |DllMain|

	EXPORT	|BKL_Init|

  00000			 AREA	 |.pdata|, PDATA
|$T43208| DCD	|$LN8@BKL_Init|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BKL_Init| PROC

; 189  : {

  00000		 |$LN8@BKL_Init|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43205|

; 190  :     DWORD rc = (DWORD)NULL;
; 191  :     BKL_DEVICE *pDevice = NULL;
; 192  :     DEBUGMSG(ZONE_FUNCTION, (
; 193  :         L"+BKL_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 194  :     ));
; 195  : 
; 196  :     // Create device structure
; 197  :     pDevice = (BKL_DEVICE *)LocalAlloc(LPTR, sizeof(BKL_DEVICE));

  00004	e3a0100c	 mov         r1, #0xC
  00008	e3a00040	 mov         r0, #0x40
  0000c	e3a05000	 mov         r5, #0
  00010	eb000000	 bl          LocalAlloc
  00014	e1b04000	 movs        r4, r0

; 198  :     if (pDevice == NULL) {

  00018	0a000007	 beq         |$LN5@BKL_Init|

; 199  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: BKL_Init: "
; 200  :             L"Failed allocate BKL device structure\r\n"
; 201  :         ));
; 202  :         goto cleanUp;
; 203  :     }
; 204  : 
; 205  :     // Set cookie
; 206  :     pDevice->cookie = BKL_DEVICE_COOKIE;

  0001c	e59f302c	 ldr         r3, [pc, #0x2C]

; 207  :     pDevice->ps = D0;

  00020	e3a02000	 mov         r2, #0

; 208  : 
; 209  :     // Switch LCD backlight on
; 210  :     BKL_SetState(TRUE);

  00024	e3a00001	 mov         r0, #1
  00028	e5843000	 str         r3, [r4]
  0002c	e5842008	 str         r2, [r4, #8]
  00030	eb000000	 bl          BKL_SetState

; 211  : 
; 212  :     // Return non-null value
; 213  :     rc = (DWORD)pDevice;

  00034	e1a05004	 mov         r5, r4
  00038		 |$cleanUp$42841|

; 214  : 
; 215  : cleanUp:
; 216  :     if (rc == 0) BKL_Deinit((DWORD)pDevice);

  00038	ea000001	 b           |$LN1@BKL_Init|
  0003c		 |$LN5@BKL_Init|
  0003c	e3a00000	 mov         r0, #0
  00040	eb000000	 bl          BKL_Deinit
  00044		 |$LN1@BKL_Init|

; 217  :     DEBUGMSG(ZONE_FUNCTION, (L"-BKL_Init(rc = %d)\r\n", rc));
; 218  :     return rc;
; 219  : }

  00044	e1a00005	 mov         r0, r5
  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN9@BKL_Init|
  00050		 |$LN10@BKL_Init|
  00050	626b6c44	 DCD         0x626b6c44
  00054		 |$M43206|

			 ENDP  ; |BKL_Init|

	END
