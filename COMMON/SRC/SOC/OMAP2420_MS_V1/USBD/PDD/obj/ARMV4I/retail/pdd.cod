; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\USBD\PDD\pdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|g_deviceRegParams| DCD |??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@|
	DCD	0x3
	DCD	0x1
	DCD	0xc
	DCD	0xc
	DCD	0x0
	DCD	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x65

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| DCB "I", 0x0, "r", 0x0, "q", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| DCB "M", 0x0, "e"
	DCB	0x0, "m", 0x0, "L", 0x0, "e", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "M", 0x0
	DCB	"e", 0x0, "m", 0x0, "B", 0x0, "a", 0x0, "s", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44787| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44784|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44785|

			 ENDP  ; |SetEvent|

; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\usbd\pdd\pdd.c

  00000			 AREA	 |.pdata|, PDATA
|$T44800| DCD	|$LN10@Log2|
	DCD	0x40000900
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Log2|	 PROC

; 160  : {

  00000		 |$LN10@Log2|
  00000		 |$M44797|
  00000	e1b03000	 movs        r3, r0

; 161  :     DWORD rc = 0;

  00004	e3a00000	 mov         r0, #0

; 162  : 
; 163  :     while (value != 0)

  00008	0a000004	 beq         |$LN1@Log2|
  0000c		 |$LL3@Log2|

; 164  :     {
; 165  :         value >>= 1;

  0000c	e1b030a3	 movs        r3, r3, lsr #1

; 166  :         rc++;

  00010	e2800001	 add         r0, r0, #1
  00014	1afffffc	 bne         |$LL3@Log2|

; 167  :     }
; 168  : 
; 169  :     if (rc > 0)

  00018	e3500000	 cmp         r0, #0

; 170  :     {
; 171  :         rc--;

  0001c	12400001	 subne       r0, r0, #1
  00020		 |$LN1@Log2|

; 172  :     }
; 173  : 
; 174  :     return rc;
; 175  : }

  00020	e12fff1e	 bx          lr
  00024		 |$M44798|

			 ENDP  ; |Log2|

	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T44809| DCD	|$LN5@Select|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Select| PROC

; 184  : {

  00000		 |$LN5@Select|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44806|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 185  :     EnterCriticalSection(&pPdd->epCS);

  0000c	e2840054	 add         r0, r4, #0x54
  00010	eb000000	 bl          EnterCriticalSection

; 186  :     ASSERT(InEp++ >= 0);
; 187  :     OUTREG32(&pPdd->pUSBDRegs->EP_NUM, dwVal);

  00014	e5943024	 ldr         r3, [r4, #0x24]
  00018	e5835004	 str         r5, [r3, #4]

; 188  : }

  0001c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M44807|

			 ENDP  ; |Select|


  00000			 AREA	 |.pdata|, PDATA
|$T44820| DCD	|$LN7@SelectSetu|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SelectSetup| PROC

; 192  : {

  00000		 |$LN7@SelectSetu|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44817|
  00004	e1a04000	 mov         r4, r0

; 193  :     // Select setup FIFO (this clears USBD_INT_SETUP flag)
; 194  :     Select(pPdd, USBD_EP_NUM_SETUP);

  00008	e2840054	 add         r0, r4, #0x54
  0000c	eb000000	 bl          EnterCriticalSection
  00010	e5943024	 ldr         r3, [r4, #0x24]
  00014	e3a02040	 mov         r2, #0x40
  00018	e5832004	 str         r2, [r3, #4]

; 195  : }

  0001c	e8bd4010	 ldmia       sp!, {r4, lr}
  00020	e12fff1e	 bx          lr
  00024		 |$M44818|

			 ENDP  ; |SelectSetup|


  00000			 AREA	 |.pdata|, PDATA
|$T44832| DCD	|$LN7@SelectEp|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SelectEp| PROC

; 199  : {

  00000		 |$LN7@SelectEp|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44829|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 200  :     Select(pPdd, USBD_EP_NUM_SEL | epNum);

  0000c	e2840054	 add         r0, r4, #0x54
  00010	eb000000	 bl          EnterCriticalSection
  00014	e5942024	 ldr         r2, [r4, #0x24]
  00018	e3853020	 orr         r3, r5, #0x20
  0001c	e5823004	 str         r3, [r2, #4]

; 201  : }

  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M44830|

			 ENDP  ; |SelectEp|

	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T44841| DCD	|$LN5@Deselect|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |Deselect| PROC

; 205  : {

  00000		 |$LN5@Deselect|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44838|

; 206  :     OUTREG32(&pPdd->pUSBDRegs->EP_NUM, dwValue);

  00004	e5903024	 ldr         r3, [r0, #0x24]

; 207  :     ASSERT(--InEp >= 0);
; 208  :     LeaveCriticalSection(&pPdd->epCS);

  00008	e2800054	 add         r0, r0, #0x54
  0000c	e5831004	 str         r1, [r3, #4]
  00010	eb000000	 bl          LeaveCriticalSection

; 209  : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M44839|

			 ENDP  ; |Deselect|


  00000			 AREA	 |.pdata|, PDATA
|$T44852| DCD	|$LN7@DeselectSe|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DeselectSetup| PROC

; 213  : {

  00000		 |$LN7@DeselectSe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44849|

; 214  :     Deselect(pPdd, 0);

  00004	e5903024	 ldr         r3, [r0, #0x24]
  00008	e3a02000	 mov         r2, #0
  0000c	e2800054	 add         r0, r0, #0x54
  00010	e5832004	 str         r2, [r3, #4]
  00014	eb000000	 bl          LeaveCriticalSection

; 215  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M44850|

			 ENDP  ; |DeselectSetup|


  00000			 AREA	 |.pdata|, PDATA
|$T44864| DCD	|$LN7@DeselectEp|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DeselectEp| PROC

; 219  : {

  00000		 |$LN7@DeselectEp|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44861|

; 220  :     Deselect(pPdd, epNum);

  00004	e5903024	 ldr         r3, [r0, #0x24]
  00008	e2800054	 add         r0, r0, #0x54
  0000c	e5831004	 str         r1, [r3, #4]
  00010	eb000000	 bl          LeaveCriticalSection

; 221  : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M44862|

			 ENDP  ; |DeselectEp|

	EXPORT	|UfnPdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T44871| DCD	|$LN5@UfnPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_PowerDown| PROC

; 236  : {

  00000		 |$LN5@UfnPdd_Pow|
  00000		 |$M44868|

; 237  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44869|

			 ENDP  ; |UfnPdd_PowerDown|

	EXPORT	|UfnPdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T44878| DCD	|$LN5@UfnPdd_Pow@2|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_PowerUp| PROC

; 252  : {

  00000		 |$LN5@UfnPdd_Pow@2|
  00000		 |$M44875|

; 253  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44876|

			 ENDP  ; |UfnPdd_PowerUp|

	EXPORT	|UpdateDevicePower|
	IMPORT	|KernelIoControl|
	IMPORT	|SetDevicePowerState|

  00000			 AREA	 |.pdata|, PDATA
|$T44890| DCD	|$LN23@UpdateDevi|
	DCD	0x40006202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UpdateDevicePower| PROC

; 273  : {

  00000		 |$LN23@UpdateDevi|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M44887|
  00008	e1b04000	 movs        r4, r0

; 274  :     BOOL  bRV    = TRUE;
; 275  :     DWORD regBit = 0x00000001;

  0000c	e3a03001	 mov         r3, #1

; 276  :     DWORD cbRet  = 0x00000000;

  00010	e3a02000	 mov         r2, #0
  00014	e58d300c	 str         r3, [sp, #0xC]
  00018	e58d2008	 str         r2, [sp, #8]
  0001c	e3a05001	 mov         r5, #1

; 277  : 
; 278  : 
; 279  :     if (pPdd != NULL)

  00020	0a000050	 beq         |$LN1@UpdateDevi|

; 280  :     {
; 281  :         DEBUGMSG(ZONE_POWER, (L"USBD UpdateDevicePower() - "
; 282  :             L"Changing Power State from D%u to D%u\r\n", (int)(pPdd->m_CurrentPowerState), (int)(pPdd->m_NewPowerState)));
; 283  : 
; 284  :         switch (pPdd->m_CurrentPowerState)

  00024	e594303c	 ldr         r3, [r4, #0x3C]
  00028	e3530000	 cmp         r3, #0
  0002c	4a00004c	 bmi         |$LN2@UpdateDevi|
  00030	e3530002	 cmp         r3, #2
  00034	da000026	 ble         |$LN14@UpdateDevi|
  00038	e3530004	 cmp         r3, #4
  0003c	ca000048	 bgt         |$LN2@UpdateDevi|

; 305  :                     }
; 306  :                 }
; 307  :                 else
; 308  :                 {
; 309  :                     bRV = FALSE;
; 310  :                 }
; 311  :                 break;
; 312  : 
; 313  :             case D3:
; 314  :             case D4:
; 315  :                 if (SetDevicePowerState(pPdd->hParentBus, pPdd->m_NewPowerState, NULL))

  00040	e5941038	 ldr         r1, [r4, #0x38]
  00044	e5940020	 ldr         r0, [r4, #0x20]
  00048	e3a02000	 mov         r2, #0
  0004c	eb000000	 bl          SetDevicePowerState
  00050	e3500000	 cmp         r0, #0
  00054	0a000042	 beq         |$LN2@UpdateDevi|

; 316  :                 {
; 317  :                     if ((pPdd->m_NewPowerState == D0) || (pPdd->m_NewPowerState == D1) || (pPdd->m_NewPowerState == D2))

  00058	e5943038	 ldr         r3, [r4, #0x38]
  0005c	e3530000	 cmp         r3, #0
  00060	0a000003	 beq         |$LN5@UpdateDevi|
  00064	e3530001	 cmp         r3, #1
  00068	0a000001	 beq         |$LN5@UpdateDevi|
  0006c	e3530002	 cmp         r3, #2
  00070	1a000038	 bne         |$LN20@UpdateDevi|
  00074		 |$LN5@UpdateDevi|

; 318  :                     {
; 319  :                         DEBUGMSG(ZONE_POWER, (L"USBD UpdateDevicePower() - "
; 320  :                             L"Turning the Power On\r\n"));
; 321  : 
; 322  :                         // Turn on the USBD Clocks
; 323  :                         KernelIoControl(IOCTL_ICLK2_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00074	e59f0108	 ldr         r0, [pc, #0x108]
  00078	e28de008	 add         lr, sp, #8
  0007c	e3a06000	 mov         r6, #0
  00080	e3a03000	 mov         r3, #0
  00084	e3a02004	 mov         r2, #4
  00088	e28d100c	 add         r1, sp, #0xC
  0008c	e58de004	 str         lr, [sp, #4]
  00090	e58d6000	 str         r6, [sp]
  00094	eb000000	 bl          KernelIoControl

; 324  :                         KernelIoControl(IOCTL_FCLK2_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00098	e59f00e0	 ldr         r0, [pc, #0xE0]
  0009c	e28de008	 add         lr, sp, #8
  000a0	e3a03000	 mov         r3, #0
  000a4	e3a02004	 mov         r2, #4
  000a8	e28d100c	 add         r1, sp, #0xC
  000ac	e58de004	 str         lr, [sp, #4]
  000b0	e58d6000	 str         r6, [sp]
  000b4	eb000000	 bl          KernelIoControl

; 325  : 
; 326  :                         // Enable the USBD Transceiver
; 327  :                         if (pPdd->pUSBDRegs)

  000b8	e5943024	 ldr         r3, [r4, #0x24]
  000bc	e1b02003	 movs        r2, r3
  000c0	0a000024	 beq         |$LN20@UpdateDevi|

; 328  :                         {
; 329  :                             SETREG32(&pPdd->pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  000c4	e5923018	 ldr         r3, [r2, #0x18]
  000c8	e3833001	 orr         r3, r3, #1
  000cc	e5823018	 str         r3, [r2, #0x18]

; 330  :                         }
; 331  :                     }
; 332  :                 }
; 333  :                 else

  000d0	ea000020	 b           |$LN20@UpdateDevi|
  000d4		 |$LN14@UpdateDevi|

; 285  :         {
; 286  :             case D0:
; 287  :             case D1:
; 288  :             case D2:
; 289  :                 if (SetDevicePowerState(pPdd->hParentBus, pPdd->m_NewPowerState, NULL))

  000d4	e5941038	 ldr         r1, [r4, #0x38]
  000d8	e5940020	 ldr         r0, [r4, #0x20]
  000dc	e3a02000	 mov         r2, #0
  000e0	eb000000	 bl          SetDevicePowerState
  000e4	e3500000	 cmp         r0, #0
  000e8	0a00001d	 beq         |$LN2@UpdateDevi|

; 290  :                 {
; 291  :                     if ((pPdd->m_NewPowerState == D3) || (pPdd->m_NewPowerState == D4))

  000ec	e5943038	 ldr         r3, [r4, #0x38]
  000f0	e3530003	 cmp         r3, #3
  000f4	0a000001	 beq         |$LN11@UpdateDevi|
  000f8	e3530004	 cmp         r3, #4
  000fc	1a000015	 bne         |$LN20@UpdateDevi|
  00100		 |$LN11@UpdateDevi|

; 292  :                     {
; 293  :                         DEBUGMSG(ZONE_POWER, (L"USBD UpdateDevicePower() - "
; 294  :                             L"Turning the Power Off\r\n"));
; 295  : 
; 296  :                         // Disable the USBD Transceiver
; 297  :                         if (pPdd->pUSBDRegs)

  00100	e5943024	 ldr         r3, [r4, #0x24]

; 298  :                         {
; 299  :                             CLRREG32(&pPdd->pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);
; 300  :                         }
; 301  : 
; 302  :                         // Turn off the USBD Clocks
; 303  :                         KernelIoControl(IOCTL_ICLK2_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00104	e59f0070	 ldr         r0, [pc, #0x70]
  00108	e28de008	 add         lr, sp, #8
  0010c	e1b02003	 movs        r2, r3
  00110	15923018	 ldrne       r3, [r2, #0x18]
  00114	e3a06000	 mov         r6, #0
  00118	e28d100c	 add         r1, sp, #0xC
  0011c	13c33001	 bicne       r3, r3, #1
  00120	15823018	 strne       r3, [r2, #0x18]
  00124	e3a03000	 mov         r3, #0
  00128	e3a02004	 mov         r2, #4
  0012c	e58de004	 str         lr, [sp, #4]
  00130	e58d6000	 str         r6, [sp]
  00134	eb000000	 bl          KernelIoControl

; 304  :                         KernelIoControl(IOCTL_FCLK2_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00138	e59f0038	 ldr         r0, [pc, #0x38]
  0013c	e28de008	 add         lr, sp, #8
  00140	e3a03000	 mov         r3, #0
  00144	e3a02004	 mov         r2, #4
  00148	e28d100c	 add         r1, sp, #0xC
  0014c	e58de004	 str         lr, [sp, #4]
  00150	e58d6000	 str         r6, [sp]
  00154	eb000000	 bl          KernelIoControl
  00158		 |$LN20@UpdateDevi|

; 341  :                 break;
; 342  :         }
; 343  : 
; 344  :         if (bRV)
; 345  :         {
; 346  :             pPdd->m_CurrentPowerState = pPdd->m_NewPowerState;

  00158	e5943038	 ldr         r3, [r4, #0x38]
  0015c	e584303c	 str         r3, [r4, #0x3C]
  00160	ea000000	 b           |$LN1@UpdateDevi|
  00164		 |$LN2@UpdateDevi|

; 334  :                 {
; 335  :                     bRV = FALSE;
; 336  :                 }
; 337  :                 break;
; 338  : 
; 339  :             default:
; 340  :                 bRV = FALSE;

  00164	e3a05000	 mov         r5, #0

; 341  :                 break;
; 342  :         }
; 343  : 
; 344  :         if (bRV)
; 345  :         {
; 346  :             pPdd->m_CurrentPowerState = pPdd->m_NewPowerState;

  00168		 |$LN1@UpdateDevi|

; 347  :         }
; 348  :     }
; 349  : 
; 350  :     return bRV;
; 351  : }

  00168	e1a00005	 mov         r0, r5
  0016c	e28dd010	 add         sp, sp, #0x10
  00170	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00174	e12fff1e	 bx          lr
  00178		 |$LN24@UpdateDevi|
  00178		 |$LN25@UpdateDevi|
  00178	00220428	 DCD         0x220428
  0017c		 |$LN26@UpdateDevi|
  0017c	00220418	 DCD         0x220418
  00180		 |$LN27@UpdateDevi|
  00180	00220424	 DCD         0x220424
  00184		 |$LN28@UpdateDevi|
  00184	00220414	 DCD         0x220414
  00188		 |$M44888|

			 ENDP  ; |UpdateDevicePower|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T44935| DCD	|$LN25@SetupEvent|
	DCD	0xc0004402

  00000			 AREA	 |.xdata|, DATA
|$T44931| DCD	0xffffffe8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44931|

  00008		 |SetupEvent| PROC

; 360  : {

  00008		 |$LN25@SetupEvent|
  00008	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M44932|
  00010	e1a05000	 mov         r5, r0
  00014	e59f30f8	 ldr         r3, [pc, #0xF8]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3008	 str         r3, [sp, #8]

; 361  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00020	e5954024	 ldr         r4, [r5, #0x24]
  00024	e3a06040	 mov         r6, #0x40
  00028	e3a07000	 mov         r7, #0
  0002c		 |$LL8@SetupEvent|

; 362  :     DWORD rawFifoData = 0x00000000;
; 363  :     WORD data[4];
; 364  :     USB_DEVICE_REQUEST *pSetup = (USB_DEVICE_REQUEST*)data;
; 365  : 
; 366  : 
; 367  :     do {
; 368  :         // Select setup FIFO (this clears USBD_INT_SETUP flag)
; 369  :         SelectSetup(pPdd);

  0002c	e2850054	 add         r0, r5, #0x54
  00030	eb000000	 bl          EnterCriticalSection
  00034	e5953024	 ldr         r3, [r5, #0x24]

; 370  : 
; 371  :         // Read setup data
; 372  :         rawFifoData = INREG32(&pUSBDRegs->DATA);
; 373  :         data[0]     = (WORD)(rawFifoData & 0x0000FFFF);
; 374  : 
; 375  :         rawFifoData = INREG32(&pUSBDRegs->DATA);
; 376  :         data[1]     = (WORD)(rawFifoData & 0x0000FFFF);
; 377  : 
; 378  :         rawFifoData = INREG32(&pUSBDRegs->DATA);
; 379  :         data[2]     = (WORD)(rawFifoData & 0x0000FFFF);
; 380  : 
; 381  :         rawFifoData = INREG32(&pUSBDRegs->DATA);
; 382  :         data[3]     = (WORD)(rawFifoData & 0x0000FFFF);
; 383  : 
; 384  :         // Deselect setup FIFO
; 385  :         DeselectSetup(pPdd);

  00038	e2850054	 add         r0, r5, #0x54
  0003c	e5836004	 str         r6, [r3, #4]
  00040	e5943008	 ldr         r3, [r4, #8]
  00044	e5952024	 ldr         r2, [r5, #0x24]
  00048	e1cd30b0	 strh        r3, [sp]
  0004c	e5943008	 ldr         r3, [r4, #8]
  00050	e1cd30b2	 strh        r3, [sp, #2]
  00054	e5943008	 ldr         r3, [r4, #8]
  00058	e1cd30b4	 strh        r3, [sp, #4]
  0005c	e5943008	 ldr         r3, [r4, #8]
  00060	e1cd30b6	 strh        r3, [sp, #6]
  00064	e5827004	 str         r7, [r2, #4]
  00068	eb000000	 bl          LeaveCriticalSection

; 386  :     } while ((INREG32(&pUSBDRegs->IRQ_SRC) & USBD_INT_SETUP) != 0);

  0006c	e5943030	 ldr         r3, [r4, #0x30]
  00070	e3130004	 tst         r3, #4
  00074	1affffec	 bne         |$LL8@SetupEvent|

; 387  : /*
; 388  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - data[0] = 0x%04X\r\n", data[0]));
; 389  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - data[1] = 0x%04X\r\n", data[1]));
; 390  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - data[2] = 0x%04X\r\n", data[2]));
; 391  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - data[3] = 0x%04X\r\n", data[3]));
; 392  : 
; 393  :     // Make sure we are interpreting the above data correctly.
; 394  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - pSetup->bmRequestType = 0x%02X\r\n", pSetup->bmRequestType));
; 395  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - pSetup->bRequest      = 0x%02X\r\n", pSetup->bRequest));
; 396  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - pSetup->wValue        = 0x%04X\r\n", pSetup->wValue));
; 397  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - pSetup->wIndex        = 0x%04X\r\n", pSetup->wIndex));
; 398  :     DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - pSetup->wLength       = 0x%04X\r\n", pSetup->wLength));
; 399  : */
; 400  :     // Save setup packet direction & size for later use
; 401  :     pPdd->setupDirRx = (pSetup->bmRequestType & 0x80) == 0;

  00078	e5dd1000	 ldrb        r1, [sp]

; 402  :     pPdd->setupCount = pSetup->wLength;

  0007c	e1dd30b6	 ldrh        r3, [sp, #6]
  00080	e3110080	 tst         r1, #0x80
  00084	03a02001	 moveq       r2, #1
  00088	13a02000	 movne       r2, #0
  0008c	e5852048	 str         r2, [r5, #0x48]

; 403  : 
; 404  :     // MDD doesn't call PDD back on configure message
; 405  :     if ((pSetup->bmRequestType == 0) && (pSetup->bRequest == USB_REQUEST_SET_CONFIGURATION))

  00090	e3510000	 cmp         r1, #0
  00094	e1c534bc	 strh        r3, [r5, #0x4C]
  00098	1a000012	 bne         |$LN1@SetupEvent|
  0009c	e5dd3001	 ldrb        r3, [sp, #1]
  000a0	e3530009	 cmp         r3, #9
  000a4	1a00000f	 bne         |$LN1@SetupEvent|

; 406  :     {
; 407  :         if (pSetup->wValue != 0)

  000a8	e1dd30b2	 ldrh        r3, [sp, #2]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a00000a	 beq         |$LN4@SetupEvent|

; 408  :         {
; 409  :             DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - "
; 410  :                 L"Changing USB Device state to Configured\r\n"));
; 411  : 
; 412  :             // Move device to configured state
; 413  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_DEV_CFG);

  000b4	e3a03008	 mov         r3, #8
  000b8	e584301c	 str         r3, [r4, #0x1C]

; 414  : 
; 415  :             // Set self powered flag
; 416  :             if (pPdd->selfPowered)

  000bc	e5953044	 ldr         r3, [r5, #0x44]
  000c0	e3530000	 cmp         r3, #0

; 417  :             {
; 418  :                 DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - "
; 419  :                     L"USB Device is Self-Powered\r\n"));
; 420  :                 SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_SELF_PWR);

  000c4	e5943018	 ldr         r3, [r4, #0x18]
  000c8	13833004	 orrne       r3, r3, #4

; 421  :             }
; 422  :             else
; 423  :             {
; 424  :                 DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - "
; 425  :                     L"USB Device is NOT Self-Powered\r\n"));
; 426  :                 CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_SELF_PWR);

  000cc	15843018	 strne       r3, [r4, #0x18]
  000d0	1a000004	 bne         |$LN1@SetupEvent|
  000d4	e3c33004	 bic         r3, r3, #4
  000d8	e5843018	 str         r3, [r4, #0x18]

; 427  :             }
; 428  :         }
; 429  :         else

  000dc	ea000001	 b           |$LN1@SetupEvent|
  000e0		 |$LN4@SetupEvent|

; 430  :         {
; 431  :             DEBUGMSG(ZONE_INIT, (L"USBD SetupEvent() - "
; 432  :                 L"Changing USB Device state to Addressed\r\n"));
; 433  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);

  000e0	e3a03004	 mov         r3, #4
  000e4	e584301c	 str         r3, [r4, #0x1C]
  000e8		 |$LN1@SetupEvent|

; 434  :         }
; 435  :     }
; 436  : 
; 437  :     // Let MDD process message
; 438  :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SETUP_PACKET, (DWORD)data);

  000e8	e5950018	 ldr         r0, [r5, #0x18]
  000ec	e595301c	 ldr         r3, [r5, #0x1C]
  000f0	e28d2000	 add         r2, sp, #0
  000f4	e3a01004	 mov         r1, #4
  000f8	e1a0e00f	 mov         lr, pc
  000fc	e12fff13	 bx          r3
  00100	e59d0008	 ldr         r0, [sp, #8]
  00104	eb000000	 bl          __security_check_cookie

; 439  : 
; 440  : }

  00108	e28dd00c	 add         sp, sp, #0xC
  0010c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00110	e12fff1e	 bx          lr
  00114		 |$LN26@SetupEvent|
  00114		 |$LN27@SetupEvent|
  00114	00000000	 DCD         |__security_cookie|
  00118		 |$M44933|

			 ENDP  ; |SetupEvent|

	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T44990| DCD	|$LN42@IssueTxTra|
	DCD	0xc0007805

  00000			 AREA	 |.pdata|, PDATA
|$T44992| DCD	|$LN20@IssueTxTra|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T44988| DCD	0x1
	DCD	|$LN24@IssueTxTra|
	DCD	|$LN25@IssueTxTra|
	DCD	|$LN20@IssueTxTra|
	DCD	|$LN21@IssueTxTra|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T44988|

  00008		 |IssueTxTransfer| PROC

; 450  : {

  00008		 |$LN42@IssueTxTra|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd018	 sub         sp, sp, #0x18
  0001c		 |$LN40@IssueTxTra|
  0001c	e1a09001	 mov         r9, r1
  00020	e58b9004	 str         r9, [r11, #4]
  00024	e1a05000	 mov         r5, r0
  00028	e58b5000	 str         r5, [r11]

; 451  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 452  :     STransfer *pTransfer;
; 453  :     BOOL complete = FALSE;
; 454  :     DWORD stat, space, count, remain;
; 455  :     UCHAR *pBuffer;
; 456  :     DWORD data;
; 457  :     DWORD epNum;
; 458  : 
; 459  :     // Get active transfer
; 460  :     pTransfer = pPdd->ep[endPoint].pTransfer;

  0002c	e085a209	 add         r10, r5, r9, lsl #4
  00030	e59a6074	 ldr         r6, [r10, #0x74]

; 461  : 
; 462  :     DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueTxTransfer() - "
; 463  :         L"EP %d pTransfer 0x%08X (%d, %d, %d)\r\n",
; 464  :                  endPoint,
; 465  :                  pTransfer,
; 466  :                  pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 467  :                  pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 468  :                  pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 469  : 
; 470  :     // Select EP
; 471  :     epNum = (USBD_EP_NUM & endPoint) | USBD_EP_NUM_DIRIN;

  00034	e209300f	 and         r3, r9, #0xF
  00038	e3834010	 orr         r4, r3, #0x10
  0003c	e50b4040	 str         r4, [r11, #-0x40]
  00040	e50b6030	 str         r6, [r11, #-0x30]

; 472  :     SelectEp(pPdd, epNum);

  00044	e2850054	 add         r0, r5, #0x54
  00048	e5958024	 ldr         r8, [r5, #0x24]
  0004c	e3a07000	 mov         r7, #0
  00050	e50b402c	 str         r4, [r11, #-0x2C]
  00054	eb000000	 bl          EnterCriticalSection
  00058	e5952024	 ldr         r2, [r5, #0x24]
  0005c	e3843020	 orr         r3, r4, #0x20

; 473  : 
; 474  : 
; 475  :     // Get EP status
; 476  :     stat = INREG32(&pUSBDRegs->STAT_FLG);

  00060	e5823004	 str         r3, [r2, #4]
  00064	e5983010	 ldr         r3, [r8, #0x10]

; 477  : 
; 478  :     // Depending on EP status
; 479  :     if ((stat & USBD_STAT_STALL) != 0)

  00068	e3130020	 tst         r3, #0x20

; 480  :     {
; 481  :         // We issued stall, remove it...
; 482  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT);

  0006c	13a03080	 movne       r3, #0x80
  00070	1588300c	 strne       r3, [r8, #0xC]

; 477  : 
; 478  :     // Depending on EP status
; 479  :     if ((stat & USBD_STAT_STALL) != 0)

  00074	1a000049	 bne         |$LN38@IssueTxTra|

; 483  :     }
; 484  :     else
; 485  :     {
; 486  :         // When transfer is NULL it is handshake ACK
; 487  :         if (pTransfer != NULL)

  00078	e3560000	 cmp         r6, #0
  0007c	0a000047	 beq         |$LN38@IssueTxTra|

; 488  :         {
; 489  :             // Is this final interrupt of transfer?
; 490  :             if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && (!pPdd->ep[endPoint].fZeroLengthNeeded))

  00080	e5961010	 ldr         r1, [r6, #0x10]
  00084	e596200c	 ldr         r2, [r6, #0xC]
  00088	e1510002	 cmp         r1, r2
  0008c	059a3070	 ldreq       r3, [r10, #0x70]
  00090	03530000	 cmpeq       r3, #0

; 491  :             {
; 492  :                 pTransfer->dwUsbError = UFN_NO_ERROR;

  00094	03a04000	 moveq       r4, #0
  00098	05864014	 streq       r4, [r6, #0x14]

; 493  :                 complete = TRUE;

  0009c	03a07001	 moveq       r7, #1

; 488  :         {
; 489  :             // Is this final interrupt of transfer?
; 490  :             if ((pTransfer->cbTransferred == pTransfer->cbBuffer) && (!pPdd->ep[endPoint].fZeroLengthNeeded))

  000a0	0a00003f	 beq         |$LN39@IssueTxTra|
  000a4		 |$LN24@IssueTxTra|

; 494  :             }
; 495  :             else
; 496  :             {
; 497  :                 __try
; 498  :                 {
; 499  :                     pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  000a4	e5963004	 ldr         r3, [r6, #4]

; 500  :                     space   = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 501  : 
; 502  :                     if (endPoint != 0)

  000a8	e3590000	 cmp         r9, #0
  000ac	e0837001	 add         r7, r3, r1
  000b0	e50b703c	 str         r7, [r11, #-0x3C]
  000b4	e042e001	 sub         lr, r2, r1
  000b8	e50be038	 str         lr, [r11, #-0x38]

; 503  :                     {
; 504  :                         // Non Zero Endpoint: No zero length padding needed.
; 505  :                         pPdd->ep[endPoint].fZeroLengthNeeded  = FALSE;

  000bc	12893007	 addne       r3, r9, #7
  000c0	13a04000	 movne       r4, #0
  000c4	17854203	 strne       r4, [r5, +r3, lsl #4]

; 500  :                     space   = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 501  : 
; 502  :                     if (endPoint != 0)

  000c8	1a000009	 bne         |$LN7@IssueTxTra|

; 506  :                     }
; 507  :                     else
; 508  :                     {
; 509  :                         // Zero endpoint: Zero length padding needed if last packet is maxPacketSize.
; 510  :                         pPdd->ep[endPoint].fZeroLengthNeeded = ((space == pPdd->ep[endPoint].maxPacketSize) && (pPdd->setupCount > pTransfer->cbBuffer));

  000cc	e1d536b8	 ldrh        r3, [r5, #0x68]
  000d0	e15e0003	 cmp         lr, r3
  000d4	1a000003	 bne         |$LN17@IssueTxTra|
  000d8	e1d534bc	 ldrh        r3, [r5, #0x4C]
  000dc	e1530002	 cmp         r3, r2
  000e0	83a03001	 movhi       r3, #1
  000e4	8a000000	 bhi         |$LN18@IssueTxTra|
  000e8		 |$LN17@IssueTxTra|
  000e8	e3a03000	 mov         r3, #0
  000ec		 |$LN18@IssueTxTra|
  000ec	e5853070	 str         r3, [r5, #0x70]
  000f0	e3a04000	 mov         r4, #0
  000f4		 |$LN7@IssueTxTra|

; 511  :                     }
; 512  : 
; 513  :                     // How many bytes we can send just now?
; 514  :                     count = pPdd->ep[endPoint].maxPacketSize;

  000f4	e1da06b8	 ldrh        r0, [r10, #0x68]

; 515  : 
; 516  :                     if (count > space)

  000f8	e150000e	 cmp         r0, lr

; 517  :                     {
; 518  :                         count = space;

  000fc	81a0000e	 movhi       r0, lr

; 519  :                     }
; 520  : 
; 521  :                     // Write data to FIFO
; 522  :                     remain = count;

  00100	e50b0034	 str         r0, [r11, #-0x34]
  00104		 |$LL5@IssueTxTra|

; 523  :                     while (remain > 1)

  00104	e3500001	 cmp         r0, #1
  00108	9a00000b	 bls         |$LN4@IssueTxTra|

; 524  :                     {
; 525  :                         data = (pBuffer[1] << 8) | pBuffer[0];
; 526  :                         OUTREG16((UINT16*)&pUSBDRegs->DATA, data);
; 527  : 
; 528  :                         pBuffer += 2;

  0010c	e1a01007	 mov         r1, r7
  00110	e4d12002	 ldrb        r2, [r1], #2
  00114	e5d73001	 ldrb        r3, [r7, #1]
  00118	e1823403	 orr         r3, r2, r3, lsl #8
  0011c	e1c830b8	 strh        r3, [r8, #8]
  00120	e1a07001	 mov         r7, r1
  00124	e50b703c	 str         r7, [r11, #-0x3C]

; 529  :                         space   -= 2;

  00128	e24ee002	 sub         lr, lr, #2
  0012c	e50be038	 str         lr, [r11, #-0x38]

; 530  :                         remain  -= 2;

  00130	e2400002	 sub         r0, r0, #2
  00134	e50b0034	 str         r0, [r11, #-0x34]

; 531  :                     }

  00138	eafffff1	 b           |$LL5@IssueTxTra|
  0013c		 |$LN4@IssueTxTra|

; 532  : 
; 533  :                     if (remain > 0)

  0013c	e3500000	 cmp         r0, #0

; 534  :                     {
; 535  :                         OUTREG8((UINT8*)&pUSBDRegs->DATA, *pBuffer);
; 536  : 
; 537  :                         pBuffer += 1;

  00140	14d73001	 ldrneb      r3, [r7], #1
  00144	15c83008	 strneb      r3, [r8, #8]
  00148	150b703c	 strne       r7, [r11, #-0x3C]

; 538  :                         space   -= 1;

  0014c	124ee001	 subne       lr, lr, #1
  00150	150be038	 strne       lr, [r11, #-0x38]

; 539  :                         remain  -= 1;

  00154	12403001	 subne       r3, r0, #1
  00158	150b3034	 strne       r3, [r11, #-0x34]

; 540  :                     }
; 541  : 
; 542  :                     DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueTxTransfer() - "
; 543  :                         L"Transfered %d bytes on ep 0x%02X", count, endPoint));
; 544  : 
; 545  :                     // Enable FIFO
; 546  :                     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  0015c	e3a03004	 mov         r3, #4
  00160	e588300c	 str         r3, [r8, #0xC]

; 547  : 
; 548  :                     // We transfered some data
; 549  :                     pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  00164	e596300c	 ldr         r3, [r6, #0xC]
  00168	e043300e	 sub         r3, r3, lr
  0016c	e5863010	 str         r3, [r6, #0x10]
  00170		 |$LN25@IssueTxTra|

; 550  : 
; 551  :                 }

  00170	e3a07000	 mov         r7, #0
  00174	e51b2040	 ldr         r2, [r11, #-0x40]
  00178	ea00000a	 b           |$LN26@IssueTxTra|
  0017c		 |$LN21@IssueTxTra|

; 553  :                 {
; 554  :                     pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  0017c	e51b6030	 ldr         r6, [r11, #-0x30]
  00180	e3a03f41	 mov         r3, #0x41, 30

; 555  :                     complete = TRUE;

  00184	e3a07001	 mov         r7, #1
  00188	e5863014	 str         r3, [r6, #0x14]
  0018c	e59b9004	 ldr         r9, [r11, #4]
  00190	e59b5000	 ldr         r5, [r11]
  00194	e51b202c	 ldr         r2, [r11, #-0x2C]
  00198	e3a04000	 mov         r4, #0
  0019c	ea000001	 b           |$LN26@IssueTxTra|
  001a0		 |$LN38@IssueTxTra|
  001a0	e3a04000	 mov         r4, #0
  001a4		 |$LN39@IssueTxTra|
  001a4	e51b2040	 ldr         r2, [r11, #-0x40]
  001a8		 |$LN26@IssueTxTra|

; 556  :                 }
; 557  :             }
; 558  :         }
; 559  :         else
; 560  :         {
; 561  :             DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueTxTransfer() - "
; 562  :                 L"pTransfer is NULL; HandShake ACK."));
; 563  :         }
; 564  :     }
; 565  : 
; 566  :     // Deselect EP
; 567  :     DeselectEp(pPdd, epNum);

  001a8	e5953024	 ldr         r3, [r5, #0x24]
  001ac	e2850054	 add         r0, r5, #0x54
  001b0	e5832004	 str         r2, [r3, #4]
  001b4	eb000000	 bl          LeaveCriticalSection

; 568  : 
; 569  :     // If transaction is complete we should tell MDD
; 570  :     if (complete)

  001b8	e3570000	 cmp         r7, #0

; 571  :     {
; 572  :         DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueTxTransfer() - "
; 573  :             L"Notifying MDD that transfer is complete."));
; 574  : 
; 575  :         pPdd->ep[endPoint].pTransfer = NULL;

  001bc	10853209	 addne       r3, r5, r9, lsl #4
  001c0	15834074	 strne       r4, [r3, #0x74]

; 576  :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  001c4	15950018	 ldrne       r0, [r5, #0x18]
  001c8	1595301c	 ldrne       r3, [r5, #0x1C]
  001cc	11a02006	 movne       r2, r6
  001d0	13a01064	 movne       r1, #0x64
  001d4	11a0e00f	 movne       lr, pc
  001d8	112fff13	 bxne        r3
  001dc		 |$LN1@IssueTxTra|

; 577  :     }
; 578  : }

  001dc	e24bd028	 sub         sp, r11, #0x28
  001e0	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001e4	e12fff1e	 bx          lr

			 ENDP  ; |IssueTxTransfer|

  001e8		 |$LN20@IssueTxTra|
  001e8		 |$LN41@IssueTxTra|

; 552  :                 __except(EXCEPTION_EXECUTE_HANDLER)

  001e8	e52de004	 str         lr, [sp, #-4]!
  001ec		 |$LN23@IssueTxTra|
  001ec		 |$LN44@IssueTxTra|
  001ec	e3a00001	 mov         r0, #1
  001f0		 |$LN22@IssueTxTra|
  001f0	e49df004	 ldr         pc, [sp], #4
  001f4		 |$LN45@IssueTxTra|
  001f4		 |$LN43@IssueTxTra|

  00000			 AREA	 |.pdata|, PDATA
|$T45042| DCD	|$LN40@IssueRxTra|
	DCD	0xc0007205

  00000			 AREA	 |.pdata|, PDATA
|$T45044| DCD	|$LN21@IssueRxTra|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T45040| DCD	0x1
	DCD	|$LN25@IssueRxTra|
	DCD	|$LN26@IssueRxTra|
	DCD	|$LN21@IssueRxTra|
	DCD	|$LN22@IssueRxTra|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T45040|

  00008		 |IssueRxTransfer| PROC

; 588  : {

  00008		 |$LN40@IssueRxTra|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5ff0	 stmdb       sp!, {r4 - r12, lr}
  00014	e28db028	 add         r11, sp, #0x28
  00018	e24dd018	 sub         sp, sp, #0x18
  0001c		 |$LN38@IssueRxTra|
  0001c	e1a0a001	 mov         r10, r1
  00020	e58ba004	 str         r10, [r11, #4]
  00024	e1a06000	 mov         r6, r0
  00028	e58b6000	 str         r6, [r11]

; 589  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 590  :     STransfer *pTransfer;
; 591  :     BOOL complete = FALSE;
; 592  :     DWORD space, remain;
; 593  :     UCHAR *pBuffer;
; 594  :     DWORD data;
; 595  :     DWORD stat;
; 596  :     DWORD epNum;
; 597  :     DWORD count;
; 598  :     DWORD maxSize;
; 599  : 
; 600  :     // Get active transfer
; 601  :     pTransfer = pPdd->ep[endPoint].pTransfer;

  0002c	e086820a	 add         r8, r6, r10, lsl #4
  00030	e5985074	 ldr         r5, [r8, #0x74]

; 602  : 
; 603  :     DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueRxTransfer() - "
; 604  :         L"EP %d pTransfer 0x%08X (%d, %d, %d)\r\n",
; 605  :                  endPoint,
; 606  :                  pTransfer,
; 607  :                  pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 608  :                  pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 609  :                  pTransfer != NULL ? pTransfer->dwUsbError : -1));
; 610  : 
; 611  :     // Select EP
; 612  :     epNum = USBD_EP_NUM & endPoint;

  00034	e20a900f	 and         r9, r10, #0xF

; 613  :     SelectEp(pPdd, epNum);

  00038	e2860054	 add         r0, r6, #0x54
  0003c	e50b5034	 str         r5, [r11, #-0x34]
  00040	e5964024	 ldr         r4, [r6, #0x24]
  00044	e3a07000	 mov         r7, #0
  00048	e50b902c	 str         r9, [r11, #-0x2C]
  0004c	eb000000	 bl          EnterCriticalSection
  00050	e5962024	 ldr         r2, [r6, #0x24]
  00054	e3893020	 orr         r3, r9, #0x20

; 614  : 
; 615  :     // Get EP status
; 616  :     stat = INREG32(&pUSBDRegs->STAT_FLG);

  00058	e5823004	 str         r3, [r2, #4]
  0005c	e5943010	 ldr         r3, [r4, #0x10]

; 617  : 
; 618  :     // Depending on EP status
; 619  :     if ((stat & USBD_STAT_STALL) != 0)

  00060	e3130020	 tst         r3, #0x20

; 620  :     {
; 621  :         // We issued stall, remove it...
; 622  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT);

  00064	13a03080	 movne       r3, #0x80
  00068	1584300c	 strne       r3, [r4, #0xC]

; 617  : 
; 618  :     // Depending on EP status
; 619  :     if ((stat & USBD_STAT_STALL) != 0)

  0006c	1a000046	 bne         |$LN37@IssueRxTra|

; 623  :     }
; 624  :     else
; 625  :     {
; 626  :         // When transfer is NULL it is handshake ACK
; 627  :         if (pTransfer != NULL)

  00070	e3550000	 cmp         r5, #0
  00074	0a000044	 beq         |$LN37@IssueRxTra|

; 628  :         {
; 629  :             // Get maxPacketSize
; 630  :             maxSize = pPdd->ep[endPoint].maxPacketSize;

  00078	e1d886b8	 ldrh        r8, [r8, #0x68]
  0007c		 |$LN25@IssueRxTra|

; 631  : 
; 632  :             __try
; 633  :             {
; 634  :                 pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  0007c	e5952010	 ldr         r2, [r5, #0x10]
  00080	e5953004	 ldr         r3, [r5, #4]
  00084	e083e002	 add         lr, r3, r2
  00088	e50be040	 str         lr, [r11, #-0x40]

; 635  :                 space = pTransfer->cbBuffer - pTransfer->cbTransferred;

  0008c	e595300c	 ldr         r3, [r5, #0xC]
  00090	e0431002	 sub         r1, r3, r2
  00094	e50b103c	 str         r1, [r11, #-0x3C]

; 636  : 
; 637  :                 // Get EP status flag
; 638  :                 stat = INREG32(&pUSBDRegs->STAT_FLG);

  00098	e5943010	 ldr         r3, [r4, #0x10]

; 639  : 
; 640  :                 // Get number of bytes in FIFO
; 641  :                 if ((stat & USBD_STAT_FIFO_EMPTY) != 0)

  0009c	e3130002	 tst         r3, #2

; 642  :                 {
; 643  :                     count = 0;

  000a0	13a00000	 movne       r0, #0

; 639  : 
; 640  :                 // Get number of bytes in FIFO
; 641  :                 if ((stat & USBD_STAT_FIFO_EMPTY) != 0)

  000a4	1a000005	 bne         |$LN10@IssueRxTra|

; 644  :                 }
; 645  :                 else if ((stat & USBD_STAT_FIFO_FULL) != 0)

  000a8	e3130001	 tst         r3, #1

; 646  :                 {
; 647  :                     count = maxSize;

  000ac	11a00008	 movne       r0, r8

; 648  :                 }
; 649  :                 else
; 650  :                 {
; 651  :                     count = INREG32(&pUSBDRegs->RXFSTAT) & USBD_RFXSTAT_COUNT;

  000b0	05942014	 ldreq       r2, [r4, #0x14]
  000b4	03a03c03	 moveq       r3, #3, 24
  000b8	038330ff	 orreq       r3, r3, #0xFF
  000bc	00020003	 andeq       r0, r2, r3
  000c0		 |$LN10@IssueRxTra|

; 652  :                 }
; 653  : 
; 654  :                 // Read data
; 655  :                 remain = count;

  000c0	e1a02000	 mov         r2, r0
  000c4	e50b0038	 str         r0, [r11, #-0x38]
  000c8		 |$LL9@IssueRxTra|

; 656  :                 while (remain > 1)

  000c8	e3520001	 cmp         r2, #1
  000cc	9a00000b	 bls         |$LN8@IssueRxTra|

; 657  :                 {
; 658  :                     data = (WORD)INREG16(&pUSBDRegs->DATA);

  000d0	e1d430b8	 ldrh        r3, [r4, #8]

; 659  :                     if (space > 1)

  000d4	e3510001	 cmp         r1, #1

; 660  :                     {
; 661  :                         pBuffer[0] = (UCHAR)data;

  000d8	85ce3000	 strhib      r3, [lr]

; 662  :                         pBuffer[1] = (UCHAR)(data >> 8);

  000dc	81a03423	 movhi       r3, r3, lsr #8
  000e0	85ce3001	 strhib      r3, [lr, #1]

; 663  :                         pBuffer += 2;

  000e4	828ee002	 addhi       lr, lr, #2
  000e8	850be040	 strhi       lr, [r11, #-0x40]

; 664  :                         space -= 2;

  000ec	82411002	 subhi       r1, r1, #2
  000f0	850b103c	 strhi       r1, [r11, #-0x3C]

; 665  :                     }
; 666  :                     remain -= 2;

  000f4	e2422002	 sub         r2, r2, #2
  000f8	e50b2038	 str         r2, [r11, #-0x38]

; 667  :                 }

  000fc	eafffff1	 b           |$LL9@IssueRxTra|
  00100		 |$LN8@IssueRxTra|

; 668  : 
; 669  :                 if (remain > 0)

  00100	e3520000	 cmp         r2, #0
  00104	0a000007	 beq         |$LN6@IssueRxTra|

; 670  :                 {
; 671  :                     data = (WORD)INREG16(&pUSBDRegs->DATA);

  00108	e1d430b8	 ldrh        r3, [r4, #8]

; 672  :                     if (space > 0)

  0010c	e3510000	 cmp         r1, #0

; 673  :                     {
; 674  :                         *pBuffer = (UCHAR)data;
; 675  :                         pBuffer += 1;

  00110	14ce3001	 strneb      r3, [lr], #1
  00114	150be040	 strne       lr, [r11, #-0x40]

; 676  :                         space   -= 1;

  00118	12411001	 subne       r1, r1, #1
  0011c	150b103c	 strne       r1, [r11, #-0x3C]

; 677  :                     }
; 678  :                     remain -= 1;

  00120	e2423001	 sub         r3, r2, #1
  00124	e50b3038	 str         r3, [r11, #-0x38]
  00128		 |$LN6@IssueRxTra|

; 679  :                 }
; 680  : 
; 681  :                 // We transfered some data
; 682  :                 pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  00128	e595200c	 ldr         r2, [r5, #0xC]
  0012c	e0423001	 sub         r3, r2, r1
  00130	e5853010	 str         r3, [r5, #0x10]

; 683  : 
; 684  :                 DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueRxTransfer() - "
; 685  :                     L"Transfered %d bytes on ep 0x%02X", pTransfer->cbTransferred, epNum));
; 686  : 
; 687  :                 // Is this end of transfer?
; 688  :                 if ((pTransfer->cbTransferred == pTransfer->cbBuffer) || (count < maxSize))

  00134	e1530002	 cmp         r3, r2
  00138	0a000004	 beq         |$LN3@IssueRxTra|
  0013c	e1500008	 cmp         r0, r8

; 695  :                 }
; 696  :                 else
; 697  :                 {
; 698  :                     // No, enable FIFO for next packet
; 699  :                     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00140	23a03004	 movcs       r3, #4
  00144	2584300c	 strcs       r3, [r4, #0xC]
  00148	23a04000	 movcs       r4, #0

; 683  : 
; 684  :                 DEBUGMSG(ZONE_TRANSFER, (L"USBD IssueRxTransfer() - "
; 685  :                     L"Transfered %d bytes on ep 0x%02X", pTransfer->cbTransferred, epNum));
; 686  : 
; 687  :                 // Is this end of transfer?
; 688  :                 if ((pTransfer->cbTransferred == pTransfer->cbBuffer) || (count < maxSize))

  0014c	2a000003	 bcs         |$LN26@IssueRxTra|
  00150		 |$LN3@IssueRxTra|

; 689  :                 {
; 690  :                     // Yes, set return code
; 691  :                     pTransfer->dwUsbError = UFN_NO_ERROR;

  00150	e3a04000	 mov         r4, #0
  00154	e5854014	 str         r4, [r5, #0x14]

; 692  : 
; 693  :                     // And complete flag
; 694  :                     complete = TRUE;

  00158	e3a07001	 mov         r7, #1
  0015c	e50b7030	 str         r7, [r11, #-0x30]
  00160		 |$LN26@IssueRxTra|

; 700  :                 }
; 701  : 
; 702  :             }

  00160	ea00000a	 b           |$LN27@IssueRxTra|
  00164		 |$LN22@IssueRxTra|

; 704  :             {
; 705  :                 pTransfer->dwUsbError = UFN_CLIENT_BUFFER_ERROR;

  00164	e51b5034	 ldr         r5, [r11, #-0x34]
  00168	e3a03f41	 mov         r3, #0x41, 30

; 706  :                 complete = TRUE;

  0016c	e3a07001	 mov         r7, #1
  00170	e5853014	 str         r3, [r5, #0x14]
  00174	e50b7030	 str         r7, [r11, #-0x30]
  00178	e59ba004	 ldr         r10, [r11, #4]
  0017c	e59b6000	 ldr         r6, [r11]
  00180	e51b902c	 ldr         r9, [r11, #-0x2C]
  00184	e3a04000	 mov         r4, #0
  00188	ea000000	 b           |$LN27@IssueRxTra|
  0018c		 |$LN37@IssueRxTra|
  0018c	e3a04000	 mov         r4, #0
  00190		 |$LN27@IssueRxTra|

; 707  :             }
; 708  :         }
; 709  :     }
; 710  : 
; 711  :     // Deselect EP
; 712  :     Deselect(pPdd, epNum);

  00190	e5963024	 ldr         r3, [r6, #0x24]
  00194	e2860054	 add         r0, r6, #0x54
  00198	e5839004	 str         r9, [r3, #4]
  0019c	eb000000	 bl          LeaveCriticalSection

; 713  : 
; 714  :     // If transaction is complete we should tell MDD
; 715  :     if (complete)

  001a0	e3570000	 cmp         r7, #0

; 716  :     {
; 717  :         pPdd->ep[endPoint].pTransfer = NULL;

  001a4	1086320a	 addne       r3, r6, r10, lsl #4
  001a8	15834074	 strne       r4, [r3, #0x74]

; 718  :         pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  001ac	15960018	 ldrne       r0, [r6, #0x18]
  001b0	1596301c	 ldrne       r3, [r6, #0x1C]
  001b4	11a02005	 movne       r2, r5
  001b8	13a01064	 movne       r1, #0x64
  001bc	11a0e00f	 movne       lr, pc
  001c0	112fff13	 bxne        r3
  001c4		 |$LN1@IssueRxTra|

; 719  :     }
; 720  : }

  001c4	e24bd028	 sub         sp, r11, #0x28
  001c8	e89d6ff0	 ldmia       sp, {r4 - r11, sp, lr}
  001cc	e12fff1e	 bx          lr

			 ENDP  ; |IssueRxTransfer|

  001d0		 |$LN21@IssueRxTra|
  001d0		 |$LN39@IssueRxTra|

; 703  :             __except(EXCEPTION_EXECUTE_HANDLER)

  001d0	e52de004	 str         lr, [sp, #-4]!
  001d4		 |$LN24@IssueRxTra|
  001d4		 |$LN42@IssueRxTra|
  001d4	e3a00001	 mov         r0, #1
  001d8		 |$LN23@IssueRxTra|
  001d8	e49df004	 ldr         pc, [sp], #4
  001dc		 |$LN43@IssueRxTra|
  001dc		 |$LN41@IssueRxTra|

  00000			 AREA	 |.pdata|, PDATA
|$T45059| DCD	|$LN14@DevStatEve|
	DCD	0x40007101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DevStatEvent| PROC

; 730  : {

  00000		 |$LN14@DevStatEve|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45056|
  00004	e1a04000	 mov         r4, r0

; 731  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00008	e5947024	 ldr         r7, [r4, #0x24]

; 732  :     DWORD state, change;
; 733  : 
; 734  : 
; 735  :     DEBUGMSG(ZONE_FUNCTION, (L"USBD DevStatEvent() - START\r\n"));
; 736  : 
; 737  :     // Get Current Device State and compare to Previous Device State
; 738  :     // Store the differences in change.
; 739  :     // Note: (a ^ b) == (a XOR b)
; 740  :     state = INREG32(&pUSBDRegs->DEVSTAT);
; 741  :     change = state ^ pPdd->devState;

  0000c	e5943040	 ldr         r3, [r4, #0x40]
  00010	e5975020	 ldr         r5, [r7, #0x20]
  00014	e0236005	 eor         r6, r3, r5

; 742  : 
; 743  :     DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 744  :         L"Previous Device State = 0x%04X\r\n", pPdd->devState));
; 745  :     DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 746  :         L"Current  Device State = 0x%04X\r\n", state));
; 747  :     DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 748  :         L"Device State Change   = 0x%04X\r\n", change));
; 749  : 
; 750  :     DEBUGMSG(ZONE_PDD, (L"UsbFnPdd!DevStatEvent: "
; 751  :         L"Device State = 0x%04x, change = 0x%04X\r\n", state, change));
; 752  : 
; 753  : #ifdef USE_OLD_CABLE_DETECT_METHOD
; 754  :     // Attach/deattach
; 755  :     if ((change & USBD_DEVSTAT_ATT) != 0)
; 756  :     {
; 757  :         if ((state & USBD_DEVSTAT_ATT) != 0)
; 758  :         {
; 759  :             DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 760  :                 L"Detected Cable Insertion Event!\r\n"));
; 761  : 
; 762  :             // TODO: Call bus driver (OTG?) to move HW from deep sleep
; 763  :             // SetSelfPowerState to D0.
; 764  :             pPdd->m_CurSelfPowerState = D0;
; 765  :             UpdateDevicePower(pPdd);
; 766  : 
; 767  :             // Let MDD process change
; 768  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);
; 769  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED,  BS_FULL_SPEED);
; 770  :         }
; 771  :         else
; 772  :         {
; 773  :             DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 774  :                 L"Detected Cable Removal Event!\r\n"));
; 775  : 
; 776  :             // We are not configured anymore
; 777  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);
; 778  : 
; 779  :             // TODO: Call bus driver (OTG?) to move HW to deep sleep
; 780  :             // Let MDD process change
; 781  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);
; 782  : 
; 783  :             // Don't process other changes (we are disconnected)
; 784  : 
; 785  :             // SetSelfPowerState to D4
; 786  :             pPdd->m_CurSelfPowerState = D4; // Do we need set to D3 as wake up source?
; 787  :             UpdateDevicePower(pPdd);
; 788  : 
; 789  :             goto DevStatClean;
; 790  :         }
; 791  :     }
; 792  : #endif // USE_OLD_CABLE_DETECT_METHOD
; 793  : 
; 794  :     // Reset
; 795  :     if (((change & USBD_DEVSTAT_USB_RESET) != 0) || ((change & USBD_DEVSTAT_DEF) != 0))

  00018	e3160020	 tst         r6, #0x20
  0001c	1a000045	 bne         |$LN8@DevStatEve|
  00020	e3160002	 tst         r6, #2
  00024	1a000043	 bne         |$LN8@DevStatEve|

; 818  : 
; 819  :         // In the middle of a reset don't process other changes
; 820  :         goto DevStatClean;
; 821  :     }
; 822  : 
; 823  :     // Suspend/resume
; 824  :     if ((change & USBD_DEVSTAT_SUS) != 0)

  00028	e3160010	 tst         r6, #0x10
  0002c	0a00002b	 beq         |$LN4@DevStatEve|

; 825  :     {
; 826  :         if ((state & USBD_DEVSTAT_SUS) != 0)

  00030	e3150010	 tst         r5, #0x10
  00034	0a000013	 beq         |$LN5@DevStatEve|

; 827  :         {
; 828  :             DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 829  :                 L"Detected Device Suspend Event!\r\n"));
; 830  : 
; 831  :             // Let MDD process change
; 832  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_SUSPEND);

  00038	e5940018	 ldr         r0, [r4, #0x18]
  0003c	e594301c	 ldr         r3, [r4, #0x1C]
  00040	e3a02003	 mov         r2, #3
  00044	e3a01001	 mov         r1, #1
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff13	 bx          r3

; 833  : 
; 834  :             // Read device status
; 835  :             INREG32(&pUSBDRegs->DEVSTAT);

  00050	e5973020	 ldr         r3, [r7, #0x20]

; 836  : 
; 837  :             // Put the device in the D2 state.
; 838  :             // Note that putting the device in D4 causes an endless loop if
; 839  :             // no USB cable is currently plugged in. The suspend bit is set
; 840  :             // when we get a suspend interrupt; if we turn the power off,
; 841  :             // the suspend bit gets cleared, triggering a resume interrupt.
; 842  :             // If no USB cable is plugged in, then a suspend interrupt gets
; 843  :             // generated since no USB device is present. The suspend interrupt
; 844  :             // then triggers the power off, which clears the suspend bit,
; 845  :             // which triggers the resume interrupt, and we enter an infinite
; 846  :             // loop from which there is no escape.
; 847  :             pPdd->m_NewPowerState = D2;

  00054	e3a02002	 mov         r2, #2

; 848  :             UpdateDevicePower(pPdd);

  00058	e1a00004	 mov         r0, r4
  0005c	e5842038	 str         r2, [r4, #0x38]
  00060	eb000000	 bl          UpdateDevicePower

; 849  : 
; 850  : #ifndef USE_OLD_CABLE_DETECT_METHOD
; 851  : 
; 852  :             // This is a work-around for what is fundamentally a hardware design flaw.
; 853  :             // We can't use the ATT bit in the DEV_STAT register to determine when
; 854  :             // a cable is removed since the ATT bit is always set since we set the
; 855  :             // BSESSVLD bit in the InitializeHardware() function. We are supposed to
; 856  :             // be able to check to see whether a cable is connected to the device
; 857  :             // and set BSESSVLD as appropriate, but the hardware design for the H4
; 858  :             // lacks this functionality.
; 859  :             // As a result, we treat SUSPEND interrupts as if they indicate both a
; 860  :             // suspend and a cable removal.
; 861  : 
; 862  :             DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 863  :                 L"Detected Cable Removal Event!\r\n"));
; 864  : 
; 865  :             // We are not configured anymore
; 866  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);

  00064	e3a03004	 mov         r3, #4
  00068	e587301c	 str         r3, [r7, #0x1C]

; 867  : 
; 868  :             // TODO: Call bus driver (OTG?) to move HW to deep sleep
; 869  :             // Let MDD process change
; 870  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  0006c	e5940018	 ldr         r0, [r4, #0x18]
  00070	e594301c	 ldr         r3, [r4, #0x1C]
  00074	e3a02000	 mov         r2, #0
  00078	e3a01001	 mov         r1, #1
  0007c	e1a0e00f	 mov         lr, pc
  00080	e12fff13	 bx          r3

; 871  : 
; 872  :             // Don't process other changes (we are disconnected)
; 873  :             goto DevStatClean;

  00084	ea00004b	 b           |$DevStatClean$43909|
  00088		 |$LN5@DevStatEve|

; 874  : 
; 875  : #endif // ! USE_OLD_CABLE_DETECT_METHOD
; 876  :         }
; 877  :         else
; 878  :         {
; 879  :             DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 880  :                 L"Detected Device Resume Event!\r\n"));
; 881  : 
; 882  :             pPdd->m_NewPowerState = D0;

  00088	e3a03000	 mov         r3, #0

; 883  :             UpdateDevicePower(pPdd);

  0008c	e1a00004	 mov         r0, r4
  00090	e5843038	 str         r3, [r4, #0x38]
  00094	eb000000	 bl          UpdateDevicePower

; 884  : 
; 885  :             // Let MDD process change
; 886  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESUME);

  00098	e5940018	 ldr         r0, [r4, #0x18]
  0009c	e594301c	 ldr         r3, [r4, #0x1C]
  000a0	e3a02004	 mov         r2, #4
  000a4	e3a01001	 mov         r1, #1
  000a8	e1a0e00f	 mov         lr, pc
  000ac	e12fff13	 bx          r3

; 887  : 
; 888  : #ifndef USE_OLD_CABLE_DETECT_METHOD
; 889  : 
; 890  :             // This is a work-around for what is fundamentally a hardware design flaw.
; 891  :             // We can't use the ATT bit in the DEV_STAT register to determine when
; 892  :             // a cable is inserted since the ATT bit is always set since we set the
; 893  :             // BSESSVLD bit in the InitializeHardware() function. We are supposed to
; 894  :             // be able to check to see whether a cable is connected to the device
; 895  :             // and set BSESSVLD as appropriate, but the hardware design for the H4
; 896  :             // lacks this functionality.
; 897  :             // As a result, we treat RESUME interrupts as if they indicate both a
; 898  :             // resume and a cable insertion.
; 899  : 
; 900  :             DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 901  :                 L"Detected Cable Insertion Event!\r\n"));
; 902  : 
; 903  :             // Let MDD process change
; 904  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);

  000b0	e5940018	 ldr         r0, [r4, #0x18]
  000b4	e594301c	 ldr         r3, [r4, #0x1C]
  000b8	e3a02001	 mov         r2, #1
  000bc	e3a01001	 mov         r1, #1
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff13	 bx          r3

; 905  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED,  BS_FULL_SPEED);

  000c8	e5940018	 ldr         r0, [r4, #0x18]
  000cc	e594301c	 ldr         r3, [r4, #0x1C]
  000d0	e3a02001	 mov         r2, #1
  000d4	e3a01003	 mov         r1, #3
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3
  000e0		 |$LN4@DevStatEve|

; 906  : 
; 907  : #endif // ! USE_OLD_CABLE_DETECT_METHOD
; 908  :         }
; 909  :     }
; 910  : 
; 911  :     // Configured
; 912  :     // if ((change & USBD_DEVSTAT_CFG) != 0)
; 913  :     // {
; 914  :     // }
; 915  : 
; 916  :     // Addressed
; 917  :     if ((change & USBD_DEVSTAT_ADD) != 0)

  000e0	e3160004	 tst         r6, #4
  000e4	0a000033	 beq         |$DevStatClean$43909|

; 918  :     {
; 919  :         DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 920  :             L"Detected Device Address Event!\r\n"));
; 921  : 
; 922  :         if ((state & USBD_DEVSTAT_ADD) != 0)
; 923  :         {
; 924  :             // Let MDD process change
; 925  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SET_ADDRESS, 1);

  000e8	e5940018	 ldr         r0, [r4, #0x18]
  000ec	e594301c	 ldr         r3, [r4, #0x1C]
  000f0	e3150004	 tst         r5, #4
  000f4	0a000004	 beq         |$LN2@DevStatEve|
  000f8	e3a02001	 mov         r2, #1
  000fc	e3a01006	 mov         r1, #6
  00100	e1a0e00f	 mov         lr, pc
  00104	e12fff13	 bx          r3

; 926  :         }
; 927  :         else

  00108	ea00002a	 b           |$DevStatClean$43909|
  0010c		 |$LN2@DevStatEve|

; 928  :         {
; 929  :             // Let MDD process change
; 930  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_CONFIGURED,  0);

  0010c	e3a02000	 mov         r2, #0
  00110	e3a01002	 mov         r1, #2
  00114	e1a0e00f	 mov         lr, pc
  00118	e12fff13	 bx          r3

; 931  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SET_ADDRESS, 0);

  0011c	e5940018	 ldr         r0, [r4, #0x18]
  00120	e594301c	 ldr         r3, [r4, #0x1C]
  00124	e3a02000	 mov         r2, #0
  00128	e3a01006	 mov         r1, #6
  0012c	e1a0e00f	 mov         lr, pc
  00130	e12fff13	 bx          r3
  00134	ea00001f	 b           |$DevStatClean$43909|
  00138		 |$LN8@DevStatEve|

; 796  :     {
; 797  :         DEBUGMSG(ZONE_PDD, (L"USBD DevStatEvent() - "
; 798  :             L"Detected USB Reset Event!\r\n"));
; 799  : 
; 800  :         pPdd->m_NewPowerState = D0;

  00138	e3a03000	 mov         r3, #0

; 801  :         UpdateDevicePower(pPdd);

  0013c	e1a00004	 mov         r0, r4
  00140	e5843038	 str         r3, [r4, #0x38]
  00144	eb000000	 bl          UpdateDevicePower

; 802  : 
; 803  :         if ((state & USBD_DEVSTAT_USB_RESET) == 0)

  00148	e3150020	 tst         r5, #0x20
  0014c	1a000017	 bne         |$LN7@DevStatEve|

; 804  :         {
; 805  :             // OTG may not detect attach/detach events correctly on some platforms
; 806  :             // Simulate a attach/detach event to clear any previous state on reset
; 807  :             // Let MDD process change
; 808  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  00150	e5940018	 ldr         r0, [r4, #0x18]
  00154	e594301c	 ldr         r3, [r4, #0x1C]
  00158	e3a02000	 mov         r2, #0
  0015c	e3a01001	 mov         r1, #1
  00160	e1a0e00f	 mov         lr, pc
  00164	e12fff13	 bx          r3

; 809  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);

  00168	e5940018	 ldr         r0, [r4, #0x18]
  0016c	e594301c	 ldr         r3, [r4, #0x1C]
  00170	e3a02001	 mov         r2, #1
  00174	e3a01001	 mov         r1, #1
  00178	e1a0e00f	 mov         lr, pc
  0017c	e12fff13	 bx          r3

; 810  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED,  BS_FULL_SPEED);

  00180	e5940018	 ldr         r0, [r4, #0x18]
  00184	e594301c	 ldr         r3, [r4, #0x1C]
  00188	e3a02001	 mov         r2, #1
  0018c	e3a01003	 mov         r1, #3
  00190	e1a0e00f	 mov         lr, pc
  00194	e12fff13	 bx          r3

; 811  : 
; 812  :             // Tell MDD about reset...
; 813  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESET);

  00198	e5940018	 ldr         r0, [r4, #0x18]
  0019c	e594301c	 ldr         r3, [r4, #0x1C]
  001a0	e3a02002	 mov         r2, #2
  001a4	e3a01001	 mov         r1, #1
  001a8	e1a0e00f	 mov         lr, pc
  001ac	e12fff13	 bx          r3
  001b0		 |$LN7@DevStatEve|

; 814  :         }
; 815  : 
; 816  :         // Enable interrupts
; 817  :         OUTREG32(&pUSBDRegs->IRQ_EN, USBD_IRQ_MASK);

  001b0	e3a03039	 mov         r3, #0x39
  001b4	e5873028	 str         r3, [r7, #0x28]
  001b8		 |$DevStatClean$43909|

; 932  :         }
; 933  :     }
; 934  : 
; 935  : DevStatClean:
; 936  :     // Save device state for next interrupt
; 937  :     pPdd->devState = state;

  001b8	e5845040	 str         r5, [r4, #0x40]

; 938  : 
; 939  :     DEBUGMSG(ZONE_FUNCTION, (L"USBD DevStatEvent() - END\r\n"));
; 940  : }

  001bc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$M45057|

			 ENDP  ; |DevStatEvent|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|InterruptDone|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T45132| DCD	|$LN46@InterruptT|
	DCD	0xc0008702

  00000			 AREA	 |.xdata|, DATA
|$T45128| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T45128|

  00008		 |InterruptThread| PROC

; 950  : {

  00008		 |$LN46@InterruptT|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M45129|
  00010	e1a04000	 mov         r4, r0
  00014	e59f3204	 ldr         r3, [pc, #0x204]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3008	 str         r3, [sp, #8]

; 951  :     USBFN_PDD *pPdd = pPddContext;
; 952  :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 953  :     DWORD code;
; 954  :     DWORD source;
; 955  :     DWORD ep;
; 956  : 
; 957  :     DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - START\r\n"));
; 958  : 
; 959  :     while (!pPdd->exitIntrThread)

  00020	e5943030	 ldr         r3, [r4, #0x30]
  00024	e5946024	 ldr         r6, [r4, #0x24]
  00028	e3530000	 cmp         r3, #0
  0002c	1a000075	 bne         |$LN42@InterruptT|
  00030	e3a08002	 mov         r8, #2
  00034	e3a0a000	 mov         r10, #0
  00038	e3a09008	 mov         r9, #8
  0003c	e3a0b004	 mov         r11, #4
  00040		 |$LL14@InterruptT|

; 960  :     {
; 961  :         // Wait for interrupt
; 962  :         code = WaitForSingleObject(pPdd->hIntrEvent, INFINITE);

  00040	e594002c	 ldr         r0, [r4, #0x2C]
  00044	e3e01000	 mvn         r1, #0
  00048	eb000000	 bl          WaitForSingleObject
  0004c	e3500000	 cmp         r0, #0

; 963  : 
; 964  :         DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 965  :             L"Interrupt Event Signalled!\r\n"));
; 966  : 
; 967  :         if (code != WAIT_OBJECT_0)

  00050	1a00006c	 bne         |$LN42@InterruptT|

; 968  :         {
; 969  :             break;
; 970  :         }
; 971  : 
; 972  :         // Exit thread when we are told to do so...
; 973  :         if (pPdd->exitIntrThread)

  00054	e5943030	 ldr         r3, [r4, #0x30]
  00058	e3530000	 cmp         r3, #0
  0005c	1a000069	 bne         |$LN42@InterruptT|

; 974  :         {
; 975  :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 976  :                 L"Exiting Thread\r\n"));
; 977  :             break;
; 978  :         }
; 979  : 
; 980  :         if ((pPdd->m_CurrentPowerState == D3) || (pPdd->m_CurrentPowerState == D4))

  00060	e594303c	 ldr         r3, [r4, #0x3C]
  00064	e3530003	 cmp         r3, #3
  00068	0a000001	 beq         |$LN9@InterruptT|
  0006c	e3530004	 cmp         r3, #4
  00070	1a000002	 bne         |$LN10@InterruptT|
  00074		 |$LN9@InterruptT|

; 981  :         {
; 982  :             pPdd->m_NewPowerState = D2;
; 983  :             UpdateDevicePower(pPdd);

  00074	e1a00004	 mov         r0, r4
  00078	e5848038	 str         r8, [r4, #0x38]
  0007c	eb000000	 bl          UpdateDevicePower
  00080		 |$LN10@InterruptT|

; 984  :         }
; 985  : 
; 986  :         // Get interrupt source
; 987  :         source = INREG32(&pUSBDRegs->IRQ_SRC);

  00080	e5965030	 ldr         r5, [r6, #0x30]

; 988  : 
; 989  :         DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 990  :             L"Interrupt Source: 0x%04X\r\n", (source & 0x07BF)));
; 991  : 
; 992  :         // Device state
; 993  :         if ((source & USBD_INT_DS_CHG) != 0 || pPdd->fakeDsChange)

  00084	e2157008	 ands        r7, r5, #8
  00088	1a000002	 bne         |$LN7@InterruptT|
  0008c	e5943168	 ldr         r3, [r4, #0x168]
  00090	e3530000	 cmp         r3, #0
  00094	0a000004	 beq         |$LN6@InterruptT|
  00098		 |$LN7@InterruptT|

; 994  :         {
; 995  :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 996  :                 L"Processing Device Status Change Interrupt\r\n"));
; 997  : 
; 998  :             // Handle device state change
; 999  :             DevStatEvent(pPdd);

  00098	e1a00004	 mov         r0, r4
  0009c	eb000000	 bl          DevStatEvent

; 1000 : 
; 1001 :             // Clear fake DsChange flag
; 1002 :             pPdd->fakeDsChange = FALSE;
; 1003 : 
; 1004 :             if ((source & USBD_INT_DS_CHG) != 0)

  000a0	e3570000	 cmp         r7, #0
  000a4	e584a168	 str         r10, [r4, #0x168]

; 1005 :             {
; 1006 :                 OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_DS_CHG);

  000a8	15869030	 strne       r9, [r6, #0x30]
  000ac		 |$LN6@InterruptT|

; 1007 :             }
; 1008 :         }
; 1009 : 
; 1010 :         // EP0 RX interrupt
; 1011 :         if ((source & USBD_INT_EP0_RX) != 0)

  000ac	e3150002	 tst         r5, #2

; 1012 :         {
; 1013 :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 1014 :                 L"Processing Endpoint 0 RX Interrupt\r\n"));
; 1015 : 
; 1016 :             // Clear source bit
; 1017 :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP0_RX);
; 1018 : 
; 1019 :             // Issue next Rx transfer
; 1020 :             IssueRxTransfer(pPdd, 0);

  000b0	13a01000	 movne       r1, #0
  000b4	11a00004	 movne       r0, r4
  000b8	15868030	 strne       r8, [r6, #0x30]
  000bc	1b000000	 blne        IssueRxTransfer

; 1021 :         }
; 1022 : 
; 1023 :         // EP0 TX interrupt
; 1024 :         if ((source & USBD_INT_EP0_TX) != 0)

  000c0	e3150001	 tst         r5, #1

; 1025 :         {
; 1026 :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 1027 :                 L"Processing Endpoint 0 TX Interrupt\r\n"));
; 1028 : 
; 1029 :             // Clear source bit
; 1030 :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP0_TX);
; 1031 : 
; 1032 :             // Issue next Tx transfer
; 1033 :             IssueTxTransfer(pPdd, 0);

  000c4	13a03001	 movne       r3, #1
  000c8	13a01000	 movne       r1, #0
  000cc	11a00004	 movne       r0, r4
  000d0	15863030	 strne       r3, [r6, #0x30]
  000d4	1b000000	 blne        IssueTxTransfer

; 1034 :         }
; 1035 : 
; 1036 :         // EPn RX interrupt
; 1037 :         if ((source & USBD_INT_EP_RX) != 0)

  000d8	e3150020	 tst         r5, #0x20

; 1038 :         {
; 1039 :             // Get EP number
; 1040 :             ep = (INREG32(&pUSBDRegs->EP_STAT) >> 8) & USBD_EP_NUM;

  000dc	15963034	 ldrne       r3, [r6, #0x34]

; 1041 : 
; 1042 :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 1043 :                 L"Processing Endpoint %d RX Interrupt\r\n", ep));
; 1044 : 
; 1045 :             // Clear source bit
; 1046 :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP_RX);
; 1047 : 
; 1048 :             // Handle event
; 1049 :             IssueRxTransfer(pPdd, ep);

  000e0	13a02020	 movne       r2, #0x20
  000e4	11a00004	 movne       r0, r4
  000e8	11a03a03	 movne       r3, r3, lsl #20
  000ec	11a01e23	 movne       r1, r3, lsr #28
  000f0	15862030	 strne       r2, [r6, #0x30]
  000f4	1b000000	 blne        IssueRxTransfer

; 1050 :         }
; 1051 : 
; 1052 :         // EPn TX interrupt
; 1053 :         if ((source & USBD_INT_EP_TX) != 0)

  000f8	e3150010	 tst         r5, #0x10

; 1054 :         {
; 1055 :             // Get EP number
; 1056 :             ep = INREG32(&pUSBDRegs->EP_STAT) & USBD_EP_NUM;

  000fc	15963034	 ldrne       r3, [r6, #0x34]

; 1057 : 
; 1058 :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 1059 :                 L"Processing Endpoint %d RX Interrupt\r\n", ep));
; 1060 : 
; 1061 :             // Clear source bit
; 1062 :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP_TX);
; 1063 : 
; 1064 :             // Handle event
; 1065 :             IssueTxTransfer(pPdd, ep);

  00100	13a02010	 movne       r2, #0x10
  00104	11a00004	 movne       r0, r4
  00108	1203100f	 andne       r1, r3, #0xF
  0010c	15862030	 strne       r2, [r6, #0x30]
  00110	1b000000	 blne        IssueTxTransfer

; 1066 :         }
; 1067 : 
; 1068 :         // Setup Packet
; 1069 :         if ((source & USBD_INT_SETUP) != 0)

  00114	e3150004	 tst         r5, #4
  00118	0a000035	 beq         |$LN25@InterruptT|

; 1070 :         {
; 1071 :             DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - "
; 1072 :                 L"Processing Setup Interrupt\r\n"));
; 1073 : 
; 1074 :             // Reading setup FIFO clears interrupt
; 1075 :             SetupEvent(pPdd);

  0011c	e5945024	 ldr         r5, [r4, #0x24]
  00120	e3a0b040	 mov         r11, #0x40
  00124		 |$LL24@InterruptT|
  00124	e2840054	 add         r0, r4, #0x54
  00128	eb000000	 bl          EnterCriticalSection
  0012c	e5943024	 ldr         r3, [r4, #0x24]
  00130	e2840054	 add         r0, r4, #0x54
  00134	e583b004	 str         r11, [r3, #4]
  00138	e5953008	 ldr         r3, [r5, #8]
  0013c	e5942024	 ldr         r2, [r4, #0x24]
  00140	e1cd30b0	 strh        r3, [sp]
  00144	e5953008	 ldr         r3, [r5, #8]
  00148	e1cd30b2	 strh        r3, [sp, #2]
  0014c	e5953008	 ldr         r3, [r5, #8]
  00150	e1cd30b4	 strh        r3, [sp, #4]
  00154	e5953008	 ldr         r3, [r5, #8]
  00158	e1cd30b6	 strh        r3, [sp, #6]
  0015c	e582a004	 str         r10, [r2, #4]
  00160	eb000000	 bl          LeaveCriticalSection
  00164	e5953030	 ldr         r3, [r5, #0x30]
  00168	e3130004	 tst         r3, #4
  0016c	1affffec	 bne         |$LL24@InterruptT|
  00170	e5dd1000	 ldrb        r1, [sp]
  00174	e1dd30b6	 ldrh        r3, [sp, #6]
  00178	e3a0b004	 mov         r11, #4
  0017c	e3110080	 tst         r1, #0x80
  00180	03a02001	 moveq       r2, #1
  00184	13a02000	 movne       r2, #0
  00188	e5842048	 str         r2, [r4, #0x48]
  0018c	e3510000	 cmp         r1, #0
  00190	e1c434bc	 strh        r3, [r4, #0x4C]
  00194	1a000010	 bne         |$LN17@InterruptT|
  00198	e5dd3001	 ldrb        r3, [sp, #1]
  0019c	e3530009	 cmp         r3, #9
  001a0	1a00000d	 bne         |$LN17@InterruptT|
  001a4	e1dd30b2	 ldrh        r3, [sp, #2]
  001a8	e3530000	 cmp         r3, #0
  001ac	0a000009	 beq         |$LN20@InterruptT|
  001b0	e585901c	 str         r9, [r5, #0x1C]
  001b4	e5943044	 ldr         r3, [r4, #0x44]
  001b8	e3530000	 cmp         r3, #0
  001bc	e5953018	 ldr         r3, [r5, #0x18]
  001c0	13833004	 orrne       r3, r3, #4
  001c4	15853018	 strne       r3, [r5, #0x18]
  001c8	1a000003	 bne         |$LN17@InterruptT|
  001cc	e3c33004	 bic         r3, r3, #4
  001d0	e5853018	 str         r3, [r5, #0x18]
  001d4	ea000000	 b           |$LN17@InterruptT|
  001d8		 |$LN20@InterruptT|
  001d8	e585b01c	 str         r11, [r5, #0x1C]
  001dc		 |$LN17@InterruptT|
  001dc	e5940018	 ldr         r0, [r4, #0x18]
  001e0	e594301c	 ldr         r3, [r4, #0x1C]
  001e4	e28d2000	 add         r2, sp, #0
  001e8	e3a01004	 mov         r1, #4
  001ec	e1a0e00f	 mov         lr, pc
  001f0	e12fff13	 bx          r3
  001f4		 |$LN25@InterruptT|

; 1076 :         }
; 1077 : 
; 1078 :         // Finish interrupt
; 1079 :         InterruptDone(pPdd->sysIntr);

  001f4	e5940028	 ldr         r0, [r4, #0x28]
  001f8	eb000000	 bl          InterruptDone
  001fc	e5943030	 ldr         r3, [r4, #0x30]
  00200	e3530000	 cmp         r3, #0
  00204	0affff8d	 beq         |$LL14@InterruptT|
  00208		 |$LN42@InterruptT|

; 1080 :     }
; 1081 : 
; 1082 :     DEBUGMSG(ZONE_INTERRUPTS, (L"USBD InterruptThread() - END\r\n"));
; 1083 : 
; 1084 :     return ERROR_SUCCESS;

  00208	e59d0008	 ldr         r0, [sp, #8]
  0020c	eb000000	 bl          __security_check_cookie
  00210	e3a00000	 mov         r0, #0

; 1085 : }

  00214	e28dd00c	 add         sp, sp, #0xC
  00218	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0021c	e12fff1e	 bx          lr
  00220		 |$LN47@InterruptT|
  00220		 |$LN48@InterruptT|
  00220	00000000	 DCD         |__security_cookie|
  00224		 |$M45130|

			 ENDP  ; |InterruptThread|

	EXPORT	|UfnPdd_IssueTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T45167| DCD	|$LN18@UfnPdd_Iss|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IssueTransfer| PROC

; 1094 : {

  00000		 |$LN18@UfnPdd_Iss|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45164|
  00004	e1a05000	 mov         r5, r0

; 1095 :     USBFN_PDD *pPdd = pPddContext;
; 1096 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1097 :     DWORD epNum;
; 1098 : 
; 1099 : 
; 1100 :     // Save transfer for interrupt thread
; 1101 :     pPdd->ep[endPoint].pTransfer = pTransfer;

  00008	e5956024	 ldr         r6, [r5, #0x24]
  0000c	e085e201	 add         lr, r5, r1, lsl #4
  00010	e58e2074	 str         r2, [lr, #0x74]

; 1102 : 
; 1103 :     if (pTransfer->pvBuffer == NULL)

  00014	e5923004	 ldr         r3, [r2, #4]
  00018	e3a04000	 mov         r4, #0
  0001c	e3530000	 cmp         r3, #0

; 1104 :     {
; 1105 :         // Sync Length with buffer.
; 1106 :         pTransfer->cbBuffer = 0;
; 1107 :     }
; 1108 : 
; 1109 :     DEBUGCHK(pTransfer->dwUsbError == UFN_NOT_COMPLETE_ERROR);
; 1110 : 
; 1111 :     // Depending on direction
; 1112 :     if (TRANSFER_IS_IN(pTransfer))

  00020	e5923000	 ldr         r3, [r2]
  00024	0582400c	 streq       r4, [r2, #0xC]
  00028	e3130080	 tst         r3, #0x80
  0002c	0a000007	 beq         |$LN2@UfnPdd_Iss|

; 1113 :     {
; 1114 :         pPdd->ep[endPoint].fZeroLengthNeeded = (pTransfer->cbBuffer==0);

  00030	e592300c	 ldr         r3, [r2, #0xC]

; 1115 :         IssueTxTransfer(pPdd, endPoint);

  00034	e1a00005	 mov         r0, r5
  00038	e3530000	 cmp         r3, #0
  0003c	03a03001	 moveq       r3, #1
  00040	13a03000	 movne       r3, #0
  00044	e58e3070	 str         r3, [lr, #0x70]
  00048	eb000000	 bl          IssueTxTransfer

; 1116 :     }
; 1117 :     else

  0004c	ea00000c	 b           |$LN14@UfnPdd_Iss|
  00050		 |$LN2@UfnPdd_Iss|

; 1118 :     {
; 1119 :         pPdd->ep[endPoint].fZeroLengthNeeded  = FALSE;
; 1120 : 
; 1121 :         // Select EP
; 1122 :         epNum = USBD_EP_NUM & endPoint;
; 1123 :         SelectEp(pPdd, epNum);

  00050	e2850054	 add         r0, r5, #0x54
  00054	e58e4070	 str         r4, [lr, #0x70]
  00058	e201400f	 and         r4, r1, #0xF
  0005c	eb000000	 bl          EnterCriticalSection
  00060	e5952024	 ldr         r2, [r5, #0x24]
  00064	e3843020	 orr         r3, r4, #0x20

; 1124 : 
; 1125 :         // Enable EP FIFO
; 1126 :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);
; 1127 : 
; 1128 :         // Deselect EP
; 1129 :         DeselectEp(pPdd, epNum);

  00068	e2850054	 add         r0, r5, #0x54
  0006c	e5823004	 str         r3, [r2, #4]
  00070	e3a03004	 mov         r3, #4
  00074	e586300c	 str         r3, [r6, #0xC]
  00078	e5953024	 ldr         r3, [r5, #0x24]
  0007c	e5834004	 str         r4, [r3, #4]
  00080	eb000000	 bl          LeaveCriticalSection
  00084		 |$LN14@UfnPdd_Iss|

; 1130 :     }
; 1131 : 
; 1132 :     return ERROR_SUCCESS;

  00084	e3a00000	 mov         r0, #0

; 1133 : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M45165|

			 ENDP  ; |UfnPdd_IssueTransfer|

	EXPORT	|UfnPdd_AbortTransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T45197| DCD	|$LN14@UfnPdd_Abo|
	DCD	0x40002301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_AbortTransfer| PROC

; 1140 : {

  00000		 |$LN14@UfnPdd_Abo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45194|
  00004	e1a06002	 mov         r6, r2
  00008	e1a07001	 mov         r7, r1
  0000c	e1a05000	 mov         r5, r0

; 1141 :     USBFN_PDD *pPdd = pPddContext;
; 1142 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1143 :     DWORD epNum;
; 1144 : 
; 1145 :     // Select EP
; 1146 :     epNum = USBD_EP_NUM & endPoint;
; 1147 : 
; 1148 :     if (TRANSFER_IS_IN(pTransfer))

  00010	e5963000	 ldr         r3, [r6]
  00014	e5958024	 ldr         r8, [r5, #0x24]
  00018	e207400f	 and         r4, r7, #0xF
  0001c	e3130080	 tst         r3, #0x80

; 1149 :     {
; 1150 :         epNum |= USBD_EP_NUM_DIRIN;
; 1151 :     }
; 1152 : 
; 1153 :     SelectEp(pPdd, epNum);

  00020	e2850054	 add         r0, r5, #0x54
  00024	13844010	 orrne       r4, r4, #0x10
  00028	eb000000	 bl          EnterCriticalSection
  0002c	e595e024	 ldr         lr, [r5, #0x24]
  00030	e3843020	 orr         r3, r4, #0x20

; 1154 : 
; 1155 :     // Clear EP
; 1156 :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);
; 1157 : 
; 1158 :     // Deselect EP
; 1159 :     DeselectEp(pPdd, epNum);

  00034	e2850054	 add         r0, r5, #0x54
  00038	e58e3004	 str         r3, [lr, #4]
  0003c	e3a03002	 mov         r3, #2
  00040	e588300c	 str         r3, [r8, #0xC]
  00044	e5953024	 ldr         r3, [r5, #0x24]
  00048	e5834004	 str         r4, [r3, #4]
  0004c	eb000000	 bl          LeaveCriticalSection
  00050	e3a03c01	 mov         r3, #1, 24

; 1160 : 
; 1161 :     // Finish transfer
; 1162 :     pPdd->ep[endPoint].pTransfer = NULL;

  00054	e0852207	 add         r2, r5, r7, lsl #4
  00058	e3a01000	 mov         r1, #0

; 1163 :     pTransfer->dwUsbError = UFN_CANCELED_ERROR;

  0005c	e3833001	 orr         r3, r3, #1
  00060	e5821074	 str         r1, [r2, #0x74]
  00064	e5863014	 str         r3, [r6, #0x14]

; 1164 :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer);

  00068	e5950018	 ldr         r0, [r5, #0x18]
  0006c	e595301c	 ldr         r3, [r5, #0x1C]
  00070	e1a02006	 mov         r2, r6
  00074	e3a01064	 mov         r1, #0x64
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3

; 1165 : 
; 1166 :     // Done
; 1167 :     return ERROR_SUCCESS;

  00080	e3a00000	 mov         r0, #0

; 1168 : }

  00084	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M45195|

			 ENDP  ; |UfnPdd_AbortTransfer|

	EXPORT	|UfnPdd_StallEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T45226| DCD	|$LN16@UfnPdd_Sta|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_StallEndpoint| PROC

; 1177 : {

  00000		 |$LN16@UfnPdd_Sta|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45223|
  00004	e3510000	 cmp         r1, #0
  00008	e1a05000	 mov         r5, r0

; 1178 :     USBFN_PDD *pPdd = pPddContext;
; 1179 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  0000c	e5956024	 ldr         r6, [r5, #0x24]

; 1180 :     DWORD epNum;
; 1181 : 
; 1182 :     DEBUGMSG(ZONE_PDD, (L"UsbFnPdd_StallEndpoint %d\r\n", endPoint));
; 1183 : 
; 1184 :     if (endPoint == 0)
; 1185 :     {
; 1186 :         // Stall next EP0 transaction
; 1187 :         OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_STALL_CMD);

  00010	03a03020	 moveq       r3, #0x20
  00014	0586301c	 streq       r3, [r6, #0x1C]
  00018	0a00000f	 beq         |$LN12@UfnPdd_Sta|

; 1188 : 
; 1189 :     }
; 1190 :     else
; 1191 :     {
; 1192 :         // Select EP
; 1193 :         epNum = USBD_EP_NUM & endPoint;
; 1194 : 
; 1195 :         if (!pPdd->ep[endPoint].dirRx)

  0001c	e0853201	 add         r3, r5, r1, lsl #4
  00020	e593306c	 ldr         r3, [r3, #0x6C]
  00024	e201400f	 and         r4, r1, #0xF

; 1196 :         {
; 1197 :             epNum |= USBD_EP_NUM_DIRIN;
; 1198 :         }
; 1199 : 
; 1200 :         SelectEp(pPdd, epNum);

  00028	e2850054	 add         r0, r5, #0x54
  0002c	e3530000	 cmp         r3, #0
  00030	03844010	 orreq       r4, r4, #0x10
  00034	eb000000	 bl          EnterCriticalSection
  00038	e5952024	 ldr         r2, [r5, #0x24]
  0003c	e3843020	 orr         r3, r4, #0x20

; 1201 : 
; 1202 :         // Halt EP
; 1203 :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_SET_HALT);
; 1204 : 
; 1205 :         // Deselect EP
; 1206 :         DeselectEp(pPdd, epNum);

  00040	e2850054	 add         r0, r5, #0x54
  00044	e5823004	 str         r3, [r2, #4]
  00048	e3a03040	 mov         r3, #0x40
  0004c	e586300c	 str         r3, [r6, #0xC]
  00050	e5953024	 ldr         r3, [r5, #0x24]
  00054	e5834004	 str         r4, [r3, #4]
  00058	eb000000	 bl          LeaveCriticalSection
  0005c		 |$LN12@UfnPdd_Sta|

; 1207 :     }
; 1208 : 
; 1209 :     // Done
; 1210 :     return ERROR_SUCCESS;

  0005c	e3a00000	 mov         r0, #0

; 1211 : }

  00060	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M45224|

			 ENDP  ; |UfnPdd_StallEndpoint|

	EXPORT	|UfnPdd_ClearEndpointStall|

  00000			 AREA	 |.pdata|, PDATA
|$T45256| DCD	|$LN15@UfnPdd_Cle|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_ClearEndpointStall| PROC

; 1220 : {

  00000		 |$LN15@UfnPdd_Cle|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45253|
  00004	e3510000	 cmp         r1, #0
  00008	e1a05000	 mov         r5, r0

; 1221 :     DWORD rc = ERROR_INVALID_FUNCTION;
; 1222 :     USBFN_PDD *pPdd = pPddContext;
; 1223 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  0000c	e5956024	 ldr         r6, [r5, #0x24]
  00010	e3a00001	 mov         r0, #1

; 1224 :     DWORD epNum;
; 1225 : 
; 1226 :     DEBUGMSG(ZONE_PDD, (L"UsbFnPdd_ClearEndpoint %d\r\n", endPoint));
; 1227 : 
; 1228 :     // Endpoint can't be zero
; 1229 :     if (endPoint != 0)

  00014	0a000010	 beq         |$LN2@UfnPdd_Cle|

; 1230 :     {
; 1231 :         // Select EP
; 1232 :         epNum = USBD_EP_NUM & endPoint;
; 1233 : 
; 1234 :         if (!pPdd->ep[endPoint].dirRx)

  00018	e0853201	 add         r3, r5, r1, lsl #4
  0001c	e593306c	 ldr         r3, [r3, #0x6C]
  00020	e201400f	 and         r4, r1, #0xF

; 1235 :         {
; 1236 :             epNum |= USBD_EP_NUM_DIRIN;
; 1237 :         }
; 1238 : 
; 1239 :         SelectEp(pPdd, epNum);

  00024	e2850054	 add         r0, r5, #0x54
  00028	e3530000	 cmp         r3, #0
  0002c	03844010	 orreq       r4, r4, #0x10
  00030	eb000000	 bl          EnterCriticalSection
  00034	e5952024	 ldr         r2, [r5, #0x24]
  00038	e3843020	 orr         r3, r4, #0x20

; 1240 : 
; 1241 :         // Clear suspend, Clear data toggle
; 1242 :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT | USBD_CTRL_CLR_DATA_TOGGLE);
; 1243 : 
; 1244 :         // Deselect EP
; 1245 :         DeselectEp(pPdd, epNum);

  0003c	e2850054	 add         r0, r5, #0x54
  00040	e5823004	 str         r3, [r2, #4]
  00044	e3a03088	 mov         r3, #0x88
  00048	e586300c	 str         r3, [r6, #0xC]
  0004c	e5953024	 ldr         r3, [r5, #0x24]
  00050	e5834004	 str         r4, [r3, #4]
  00054	eb000000	 bl          LeaveCriticalSection

; 1246 : 
; 1247 :         // Done
; 1248 :         rc = ERROR_SUCCESS;

  00058	e3a00000	 mov         r0, #0
  0005c		 |$LN2@UfnPdd_Cle|

; 1249 :     }
; 1250 : 
; 1251 :     return rc;
; 1252 : }

  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M45254|

			 ENDP  ; |UfnPdd_ClearEndpointStall|

	EXPORT	|UfnPdd_IsEndpointHalted|

  00000			 AREA	 |.pdata|, PDATA
|$T45289| DCD	|$LN17@UfnPdd_IsE|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsEndpointHalted| PROC

; 1261 : {

  00000		 |$LN17@UfnPdd_IsE|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M45286|
  00004	e1a06002	 mov         r6, r2
  00008	e3510000	 cmp         r1, #0
  0000c	e1a05000	 mov         r5, r0

; 1262 :     DWORD rc = ERROR_INVALID_FUNCTION;
; 1263 :     USBFN_PDD *pPdd = pPddContext;
; 1264 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00010	e5957024	 ldr         r7, [r5, #0x24]
  00014	e3a00001	 mov         r0, #1

; 1265 :     DWORD epNum;
; 1266 : 
; 1267 :     DEBUGMSG(ZONE_PDD, (L"UsbFnPdd_IsEndpointHalted %d\r\n", endPoint));
; 1268 : 
; 1269 :     // Endpoint can't be zero
; 1270 :     if (endPoint != 0)

  00018	0a000013	 beq         |$LN2@UfnPdd_IsE|

; 1271 :     {
; 1272 :         // Select EP
; 1273 :         epNum = USBD_EP_NUM & endPoint;
; 1274 : 
; 1275 :         if (!pPdd->ep[endPoint].dirRx)

  0001c	e0853201	 add         r3, r5, r1, lsl #4
  00020	e593306c	 ldr         r3, [r3, #0x6C]
  00024	e201400f	 and         r4, r1, #0xF

; 1276 :         {
; 1277 :             epNum |= USBD_EP_NUM_DIRIN;
; 1278 :         }
; 1279 : 
; 1280 :         SelectEp(pPdd, epNum);

  00028	e2850054	 add         r0, r5, #0x54
  0002c	e3530000	 cmp         r3, #0
  00030	03844010	 orreq       r4, r4, #0x10
  00034	eb000000	 bl          EnterCriticalSection
  00038	e5951024	 ldr         r1, [r5, #0x24]
  0003c	e3843020	 orr         r3, r4, #0x20

; 1281 : 
; 1282 :         // Is EP halted?
; 1283 :         *pHalted = ((INREG32(&pUSBDRegs->STAT_FLG) & USBD_STAT_HALTED) != 0);
; 1284 : 
; 1285 :         // Deselect EP
; 1286 :         DeselectEp(pPdd, epNum);

  00040	e2850054	 add         r0, r5, #0x54
  00044	e5813004	 str         r3, [r1, #4]
  00048	e5973010	 ldr         r3, [r7, #0x10]
  0004c	e3130040	 tst         r3, #0x40
  00050	13a03001	 movne       r3, #1
  00054	03a03000	 moveq       r3, #0
  00058	e5863000	 str         r3, [r6]
  0005c	e5953024	 ldr         r3, [r5, #0x24]
  00060	e5834004	 str         r4, [r3, #4]
  00064	eb000000	 bl          LeaveCriticalSection

; 1287 : 
; 1288 :         // Done
; 1289 :         rc = ERROR_SUCCESS;

  00068	e3a00000	 mov         r0, #0
  0006c		 |$LN2@UfnPdd_IsE|

; 1290 :     }
; 1291 : 
; 1292 :     return rc;
; 1293 : }

  0006c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M45287|

			 ENDP  ; |UfnPdd_IsEndpointHalted|

	EXPORT	|UfnPdd_SendControlStatusHandshake|

  00000			 AREA	 |.pdata|, PDATA
|$T45319| DCD	|$LN16@UfnPdd_Sen|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_SendControlStatusHandshake| PROC

; 1303 : {

  00000		 |$LN16@UfnPdd_Sen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45316|
  00004	e1a05000	 mov         r5, r0

; 1304 :     USBFN_PDD *pPdd = pPddContext;
; 1305 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1306 :     DWORD epNum, stat;
; 1307 : 
; 1308 :     DEBUGMSG(ZONE_USB_EVENTS, (L"UfnPdd_SendControlStatusHandshake() - START\r\n"));
; 1309 : 
; 1310 :     // Select EP
; 1311 :     epNum = USBD_EP_NUM & endPoint;
; 1312 : 
; 1313 :     if (pPdd->setupDirRx)

  00008	e5953048	 ldr         r3, [r5, #0x48]
  0000c	e5956024	 ldr         r6, [r5, #0x24]
  00010	e201400f	 and         r4, r1, #0xF
  00014	e3530000	 cmp         r3, #0

; 1314 :     {
; 1315 :         epNum |= USBD_EP_NUM_DIRIN;
; 1316 :     }
; 1317 : 
; 1318 :     SelectEp(pPdd, epNum);

  00018	e2850054	 add         r0, r5, #0x54
  0001c	13844010	 orrne       r4, r4, #0x10
  00020	eb000000	 bl          EnterCriticalSection
  00024	e5952024	 ldr         r2, [r5, #0x24]
  00028	e3843020	 orr         r3, r4, #0x20

; 1319 : 
; 1320 :     // Get actual status
; 1321 :     stat = INREG32(&pUSBDRegs->STAT_FLG);
; 1322 : 
; 1323 :     DEBUGMSG(ZONE_USB_EVENTS, (L"UfnPdd_SendControlStatusHandshake() - "
; 1324 :         L"EndPoint %d (%s): STAT_FLG = 0x%04X\r\n", endPoint, pPdd->setupDirRx ? L"IN" : L"OUT", stat));
; 1325 : 
; 1326 :     // Only send the handshake when the EndPoint is not stalled.
; 1327 :     if ((stat & USBD_STAT_STALL) == 0)
; 1328 :     {
; 1329 :         // Clear & enable FIFO
; 1330 :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);
; 1331 :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);
; 1332 :     }
; 1333 :     else
; 1334 :     {
; 1335 :         DEBUGMSG(ZONE_USB_EVENTS, (L"UfnPdd_SendControlStatusHandshake() - "
; 1336 :             L"Not sending handshake because Endpoint %d is stalled\r\n", epNum));
; 1337 :     }
; 1338 : 
; 1339 :     // Deselect EP
; 1340 :     DeselectEp(pPdd, epNum);

  0002c	e2850054	 add         r0, r5, #0x54
  00030	e5823004	 str         r3, [r2, #4]
  00034	e5963010	 ldr         r3, [r6, #0x10]
  00038	e3130020	 tst         r3, #0x20
  0003c	03a03002	 moveq       r3, #2
  00040	0586300c	 streq       r3, [r6, #0xC]
  00044	03a03004	 moveq       r3, #4
  00048	0586300c	 streq       r3, [r6, #0xC]
  0004c	e5953024	 ldr         r3, [r5, #0x24]
  00050	e5834004	 str         r4, [r3, #4]
  00054	eb000000	 bl          LeaveCriticalSection

; 1341 : 
; 1342 :     DEBUGMSG(ZONE_USB_EVENTS, (L"UfnPdd_SendControlStatusHandshake() - END\r\n"));
; 1343 : 
; 1344 :     return ERROR_SUCCESS;

  00058	e3a00000	 mov         r0, #0

; 1345 : }

  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M45317|

			 ENDP  ; |UfnPdd_SendControlStatusHandshake|

	EXPORT	|UfnPdd_InitiateRemoteWakeup|

  00000			 AREA	 |.pdata|, PDATA
|$T45330| DCD	|$LN5@UfnPdd_Ini|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_InitiateRemoteWakeup| PROC

; 1352 : {

  00000		 |$LN5@UfnPdd_Ini|
  00000		 |$M45327|

; 1353 :     USBFN_PDD *pPdd = pPddContext;
; 1354 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00000	e5902024	 ldr         r2, [r0, #0x24]

; 1355 : 
; 1356 :     DEBUGMSG(ZONE_PDD, (L"UsbFnPdd_InitiateRemoteWakeup\r\n"));
; 1357 : 
; 1358 :     SETREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_RMT_WKP);
; 1359 : 
; 1360 :     return ERROR_SUCCESS;

  00004	e3a00000	 mov         r0, #0
  00008	e592301c	 ldr         r3, [r2, #0x1C]
  0000c	e3833040	 orr         r3, r3, #0x40
  00010	e582301c	 str         r3, [r2, #0x1C]

; 1361 : }

  00014	e12fff1e	 bx          lr
  00018		 |$M45328|

			 ENDP  ; |UfnPdd_InitiateRemoteWakeup|

	EXPORT	|??_C@_1DK@HJDLAGJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegOpenKeyExW|

  00000			 AREA	 |.pdata|, PDATA
|$T45340| DCD	|$LN5@OpenFuncti|
	DCD	0x40000d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@HJDLAGJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@| DCB "\\"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, "s", 0x0, "\\", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "\\"
	DCB	0x0, "F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OpenFunctionKey| PROC

; 1398 : {

  00000		 |$LN5@OpenFuncti|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45337|
  00008	e1a0e000	 mov         lr, r0

; 1399 :     // Determine which client driver to load
; 1400 :     return RegOpenKeyEx(HKEY_LOCAL_MACHINE,
; 1401 :                         PSZ_REG_CLIENT_DRIVER_PATH,
; 1402 :                         0,
; 1403 :                         0,
; 1404 :                         phkFunctions);

  0000c	e59f101c	 ldr         r1, [pc, #0x1C]
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a0010a	 mov         r0, #0xA, 2
  0001c	e58de000	 str         lr, [sp]
  00020	eb000000	 bl          RegOpenKeyExW

; 1405 : }

  00024	e28dd004	 add         sp, sp, #4
  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN6@OpenFuncti|
  00030		 |$LN7@OpenFuncti|
  00030	00000000	 DCD         |??_C@_1DK@HJDLAGJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@|
  00034		 |$M45338|

			 ENDP  ; |OpenFunctionKey|

	EXPORT	|??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|RegCloseKey|
	IMPORT	|RegSetValueExW|
	IMPORT	|wcslen|

  00000			 AREA	 |.pdata|, PDATA
|$T45358| DCD	|$LN9@ChangeDefa|
	DCD	0x40002302

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "f", 0x0, "a", 0x0, "u", 0x0, "l", 0x0, "t"
	DCB	0x0, "C", 0x0, "l", 0x0, "i", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, "D", 0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ChangeDefaultClient| PROC

; 1442 : {

  00000		 |$LN9@ChangeDefa|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M45355|
  00008	e1a05000	 mov         r5, r0

; 1443 :     DWORD dwRet;
; 1444 :     HKEY  hkFunctions = NULL;
; 1445 : 
; 1446 : 
; 1447 :     dwRet = OpenFunctionKey(&hkFunctions);

  0000c	e59f1074	 ldr         r1, [pc, #0x74]
  00010	e3a04000	 mov         r4, #0
  00014	e28de008	 add         lr, sp, #8
  00018	e3a03000	 mov         r3, #0
  0001c	e3a02000	 mov         r2, #0
  00020	e3a0010a	 mov         r0, #0xA, 2
  00024	e58d4008	 str         r4, [sp, #8]
  00028	e58de000	 str         lr, [sp]
  0002c	eb000000	 bl          RegOpenKeyExW
  00030	e1b04000	 movs        r4, r0

; 1448 :     if (dwRet == ERROR_SUCCESS)

  00034	1a00000b	 bne         |$LN2@ChangeDefa|

; 1449 :     {
; 1450 :         dwRet = RegSetValueEx(hkFunctions,
; 1451 :                               PSZ_REG_DEFAULT_DEFAULT_CLIENT_DRIVER,
; 1452 :                               0,
; 1453 :                               REG_SZ,
; 1454 :                               (PBYTE)pszClientName,
; 1455 :                               (_tcslen(pszClientName) + 1) * sizeof(TCHAR));

  00038	e1a00005	 mov         r0, r5
  0003c	eb000000	 bl          wcslen
  00040	e2803001	 add         r3, r0, #1
  00044	e59f1038	 ldr         r1, [pc, #0x38]
  00048	e59d0008	 ldr         r0, [sp, #8]
  0004c	e1a03083	 mov         r3, r3, lsl #1
  00050	e58d3004	 str         r3, [sp, #4]
  00054	e3a03001	 mov         r3, #1
  00058	e3a02000	 mov         r2, #0
  0005c	e58d5000	 str         r5, [sp]
  00060	eb000000	 bl          RegSetValueExW
  00064	e1a04000	 mov         r4, r0
  00068		 |$LN2@ChangeDefa|

; 1456 :     }
; 1457 : 
; 1458 :     if (hkFunctions)

  00068	e59d0008	 ldr         r0, [sp, #8]
  0006c	e3500000	 cmp         r0, #0

; 1459 :     {
; 1460 :         RegCloseKey(hkFunctions);

  00070	1b000000	 blne        RegCloseKey

; 1461 :     }
; 1462 : 
; 1463 :     return dwRet;
; 1464 : }

  00074	e1a00004	 mov         r0, r4
  00078	e28dd00c	 add         sp, sp, #0xC
  0007c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN10@ChangeDefa|
  00084		 |$LN11@ChangeDefa|
  00084	00000000	 DCD         |??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@|
  00088		 |$LN12@ChangeDefa|
  00088	00000000	 DCD         |??_C@_1DK@HJDLAGJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@|
  0008c		 |$M45356|

			 ENDP  ; |ChangeDefaultClient|

	EXPORT	|UfnPdd_IOControl|
	IMPORT	|CeSafeCopyMemory|

  00000			 AREA	 |.pdata|, PDATA
|$T45392| DCD	|$LN31@UfnPdd_IOC|
	DCD	0x40006502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IOControl| PROC

; 1479 : {

  00000		 |$LN31@UfnPdd_IOC|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M45389|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a06000	 mov         r6, r0
  00010	e3a03822	 mov         r3, #0x22, 16

; 1480 :     DWORD                rc   = ERROR_INVALID_PARAMETER;
; 1481 :     USBFN_PDD           *pPdd = pPddContext;
; 1482 :     UFN_PDD_INFO         info;
; 1483 :     CE_BUS_POWER_STATE  *pBusPowerState;
; 1484 :     CEDEVICE_POWER_STATE devicePowerState;
; 1485 : 
; 1486 : 
; 1487 :     switch (code)

  00014	e383e018	 orr         lr, r3, #0x18
  00018	e152000e	 cmp         r2, lr
  0001c	e3a04057	 mov         r4, #0x57
  00020	0a00003b	 beq         |$LN1@UfnPdd_IOC|
  00024	e3a03822	 mov         r3, #0x22, 16
  00028	e383ef65	 orr         lr, r3, #0x65, 30
  0002c	e152000e	 cmp         r2, lr
  00030	0a000022	 beq         |$LN16@UfnPdd_IOC|
  00034	e3a0382a	 mov         r3, #0x2A, 16
  00038	e383e00c	 orr         lr, r3, #0xC
  0003c	e152000e	 cmp         r2, lr
  00040	0a000013	 beq         |$LN11@UfnPdd_IOC|
  00044	e3a0382a	 mov         r3, #0x2A, 16
  00048	e3831010	 orr         r1, r3, #0x10
  0004c	e1520001	 cmp         r2, r1
  00050	1a000049	 bne         |$LN21@UfnPdd_IOC|

; 1525 : 
; 1526 :         case IOCTL_BUS_SET_POWER_STATE:
; 1527 :             if (pInBuffer == NULL || inSize < sizeof(CE_BUS_POWER_STATE))

  00054	e3550000	 cmp         r5, #0
  00058	0a000047	 beq         |$LN21@UfnPdd_IOC|
  0005c	e59d302c	 ldr         r3, [sp, #0x2C]
  00060	e353000c	 cmp         r3, #0xC
  00064	3a000044	 bcc         |$LN21@UfnPdd_IOC|

; 1528 :             {
; 1529 :                 DEBUGMSG(ZONE_WARNING, (L"UfnPdd_IOControl() "
; 1530 :                     L"WARNING: Bad Parameter\r\n"));
; 1531 :                 break;
; 1532 :             }
; 1533 :             pBusPowerState = (CE_BUS_POWER_STATE*)pInBuffer;
; 1534 :             if (!CeSafeCopyMemory(&devicePowerState, pBusPowerState->lpceDevicePowerState, sizeof(CEDEVICE_POWER_STATE)))

  00068	e5951004	 ldr         r1, [r5, #4]
  0006c	e3a02004	 mov         r2, #4
  00070	e28d000c	 add         r0, sp, #0xC
  00074	eb000000	 bl          CeSafeCopyMemory
  00078	e3500000	 cmp         r0, #0
  0007c	0a00003e	 beq         |$LN21@UfnPdd_IOC|

; 1535 :             {
; 1536 :                 break;
; 1537 :             }
; 1538 :             DEBUGMSG(ZONE_POWER, (L"UfnPdd_IOControl() - "
; 1539 :                 L"Set Power State to D%d\r\n", (int)devicePowerState));
; 1540 :             pPdd->m_NewPowerState = devicePowerState;

  00080	e59d300c	 ldr         r3, [sp, #0xC]

; 1541 :             if (UpdateDevicePower(pPdd))

  00084	e1a00006	 mov         r0, r6
  00088	e5863038	 str         r3, [r6, #0x38]
  0008c	eb000000	 bl          UpdateDevicePower

; 1542 :             {
; 1543 :                 rc = ERROR_SUCCESS;
; 1544 :             }
; 1545 :             break;

  00090	ea00001b	 b           |$LN28@UfnPdd_IOC|
  00094		 |$LN11@UfnPdd_IOC|

; 1507 : 
; 1508 :         case IOCTL_BUS_GET_POWER_STATE:
; 1509 :             if (source != MDD_IOCTL)

  00094	e3510002	 cmp         r1, #2
  00098	1a000037	 bne         |$LN21@UfnPdd_IOC|

; 1510 :             {
; 1511 :                 break;
; 1512 :             }
; 1513 :             if (pInBuffer == NULL || inSize < sizeof(CE_BUS_POWER_STATE))

  0009c	e3550000	 cmp         r5, #0
  000a0	0a000035	 beq         |$LN21@UfnPdd_IOC|
  000a4	e59d302c	 ldr         r3, [sp, #0x2C]
  000a8	e353000c	 cmp         r3, #0xC
  000ac	3a000032	 bcc         |$LN21@UfnPdd_IOC|

; 1514 :             {
; 1515 :                 break;
; 1516 :             }
; 1517 :             pBusPowerState = (CE_BUS_POWER_STATE*)pInBuffer;
; 1518 :             if (!CeSafeCopyMemory(pBusPowerState->lpceDevicePowerState, &pPdd->m_CurrentPowerState, sizeof(CEDEVICE_POWER_STATE)))

  000b0	e5950004	 ldr         r0, [r5, #4]
  000b4	e3a02004	 mov         r2, #4
  000b8	e286103c	 add         r1, r6, #0x3C

; 1519 :             {
; 1520 :                 break;
; 1521 :             }
; 1522 : 
; 1523 :             rc = ERROR_SUCCESS;
; 1524 :             break;

  000bc	ea00000f	 b           |$LN27@UfnPdd_IOC|
  000c0		 |$LN16@UfnPdd_IOC|

; 1488 :     {
; 1489 :         case IOCTL_UFN_GET_PDD_INFO:
; 1490 :             if (source != BUS_IOCTL)

  000c0	e3510000	 cmp         r1, #0
  000c4	1a00002c	 bne         |$LN21@UfnPdd_IOC|

; 1491 :             {
; 1492 :                 break;
; 1493 :             }
; 1494 :             if (pOutBuffer == NULL || outSize < sizeof(UFN_PDD_INFO))

  000c8	e59d0030	 ldr         r0, [sp, #0x30]
  000cc	e3500000	 cmp         r0, #0
  000d0	0a000029	 beq         |$LN21@UfnPdd_IOC|
  000d4	e59d3034	 ldr         r3, [sp, #0x34]
  000d8	e353000c	 cmp         r3, #0xC
  000dc	3a000026	 bcc         |$LN21@UfnPdd_IOC|

; 1495 :             {
; 1496 :                 break;
; 1497 :             }
; 1498 :             info.InterfaceType = Internal;
; 1499 :             info.BusNumber = 0;

  000e0	e3a02000	 mov         r2, #0

; 1500 :             info.dwAlignment = sizeof(DWORD);

  000e4	e3a01004	 mov         r1, #4
  000e8	e3a03000	 mov         r3, #0
  000ec	e58d2014	 str         r2, [sp, #0x14]
  000f0	e58d1018	 str         r1, [sp, #0x18]

; 1501 :             if (!CeSafeCopyMemory(pOutBuffer, &info, sizeof(UFN_PDD_INFO)))

  000f4	e3a0200c	 mov         r2, #0xC
  000f8	e28d1010	 add         r1, sp, #0x10
  000fc	e58d3010	 str         r3, [sp, #0x10]
  00100		 |$LN27@UfnPdd_IOC|
  00100	eb000000	 bl          CeSafeCopyMemory
  00104		 |$LN28@UfnPdd_IOC|
  00104	e3500000	 cmp         r0, #0
  00108	0a00001b	 beq         |$LN21@UfnPdd_IOC|

; 1502 :             {
; 1503 :                 break;
; 1504 :             }
; 1505 :             rc = ERROR_SUCCESS;

  0010c	e3a04000	 mov         r4, #0

; 1506 :             break;

  00110	ea000019	 b           |$LN21@UfnPdd_IOC|
  00114		 |$LN1@UfnPdd_IOC|

; 1546 : 
; 1547 :         case IOCTL_UFN_CHANGE_DEFAULT_CLIENT:
; 1548 :             rc = ChangeDefaultClient((LPTSTR)pInBuffer);

  00114	e59f1074	 ldr         r1, [pc, #0x74]
  00118	e3a04000	 mov         r4, #0
  0011c	e28de008	 add         lr, sp, #8
  00120	e3a03000	 mov         r3, #0
  00124	e3a02000	 mov         r2, #0
  00128	e3a0010a	 mov         r0, #0xA, 2
  0012c	e58d4008	 str         r4, [sp, #8]
  00130	e58de000	 str         lr, [sp]
  00134	eb000000	 bl          RegOpenKeyExW
  00138	e1b04000	 movs        r4, r0
  0013c	1a00000b	 bne         |$LN22@UfnPdd_IOC|
  00140	e1a00005	 mov         r0, r5
  00144	eb000000	 bl          wcslen
  00148	e2803001	 add         r3, r0, #1
  0014c	e59f1038	 ldr         r1, [pc, #0x38]
  00150	e59d0008	 ldr         r0, [sp, #8]
  00154	e1a03083	 mov         r3, r3, lsl #1
  00158	e58d3004	 str         r3, [sp, #4]
  0015c	e3a03001	 mov         r3, #1
  00160	e3a02000	 mov         r2, #0
  00164	e58d5000	 str         r5, [sp]
  00168	eb000000	 bl          RegSetValueExW
  0016c	e1a04000	 mov         r4, r0
  00170		 |$LN22@UfnPdd_IOC|
  00170	e59d0008	 ldr         r0, [sp, #8]
  00174	e3500000	 cmp         r0, #0
  00178	1b000000	 blne        RegCloseKey
  0017c		 |$LN21@UfnPdd_IOC|

; 1549 :             break;
; 1550 :     }
; 1551 : 
; 1552 :     return rc;
; 1553 : }

  0017c	e1a00004	 mov         r0, r4
  00180	e28dd01c	 add         sp, sp, #0x1C
  00184	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00188	e12fff1e	 bx          lr
  0018c		 |$LN32@UfnPdd_IOC|
  0018c		 |$LN33@UfnPdd_IOC|
  0018c	00000000	 DCD         |??_C@_1CI@MGKPCHDE@?$AAD?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAC?$AAl?$AAi?$AAe?$AAn?$AAt?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?$AA@|
  00190		 |$LN34@UfnPdd_IOC|
  00190	00000000	 DCD         |??_C@_1DK@HJDLAGJ@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?2?$AAU?$AAS?$AAB?$AA?2?$AAF?$AAu?$AAn?$AAc?$AAt?$AAi?$AAo?$AAn?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@|
  00194		 |$M45390|

			 ENDP  ; |UfnPdd_IOControl|

	EXPORT	|UfnPdd_Deinit|
	EXPORT	|??_C@_1M@KNLKOEJA@?$AAU?$AAs?$AAb?$AAF?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@GIHKGMGM@?$AA?$HL?$AA6?$AAF?$AA4?$AA0?$AA7?$AA9?$AA1?$AAD?$AA?9?$AA3?$AA0?$AA0?$AAE?$AA?9?$AA4?$AA4?$AAE?$AA4?$AA?9?$AAB?$AAC?$AA3?$AA8?$AA?9?$AAE?$AA0?$AAE?$AA6?$AA3?$AAC?$AAA@| [ DATA ] ; `string'
	IMPORT	|AdvertiseInterface|
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|InterruptDisable|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|CloseHandle|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T45409| DCD	|$LN12@UfnPdd_Dei|
	DCD	0x40004402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@KNLKOEJA@?$AAU?$AAs?$AAb?$AAF?$AAn?$AA?$AA@| DCB "U", 0x0, "s", 0x0
	DCB	"b", 0x0, "F", 0x0, "n", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@GIHKGMGM@?$AA?$HL?$AA6?$AAF?$AA4?$AA0?$AA7?$AA9?$AA1?$AAD?$AA?9?$AA3?$AA0?$AA0?$AAE?$AA?9?$AA4?$AA4?$AAE?$AA4?$AA?9?$AAB?$AAC?$AA3?$AA8?$AA?9?$AAE?$AA0?$AAE?$AA6?$AA3?$AAC?$AAA@| DCB "{"
	DCB	0x0, "6", 0x0, "F", 0x0, "4", 0x0, "0", 0x0, "7", 0x0, "9"
	DCB	0x0, "1", 0x0, "D", 0x0, "-", 0x0, "3", 0x0, "0", 0x0, "0"
	DCB	0x0, "E", 0x0, "-", 0x0, "4", 0x0, "4", 0x0, "E", 0x0, "4"
	DCB	0x0, "-", 0x0, "B", 0x0, "C", 0x0, "3", 0x0, "8", 0x0, "-"
	DCB	0x0, "E", 0x0, "0", 0x0, "E", 0x0, "6", 0x0, "3", 0x0, "C"
	DCB	0x0, "A", 0x0, "8", 0x0, "3", 0x0, "7", 0x0, "5", 0x0, "C"
	DCB	0x0, "}", 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\usbd\pdd\pdd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Deinit| PROC

; 1561 : {

  00000		 |$LN12@UfnPdd_Dei|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45406|
  00008	e1a04000	 mov         r4, r0

; 1562 :     USBFN_PDD *pPdd = pPddContext;
; 1563 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1564 : 
; 1565 : 
; 1566 :     // Stop interrupt thread
; 1567 :     if (pPdd->hIntrThread != NULL)

  0000c	e5943034	 ldr         r3, [r4, #0x34]
  00010	e3530000	 cmp         r3, #0
  00014	0a000009	 beq         |$LN5@UfnPdd_Dei|

; 1568 :     {
; 1569 :         pPdd->exitIntrThread = TRUE;
; 1570 :         SetEvent(pPdd->hIntrEvent);

  00018	e594002c	 ldr         r0, [r4, #0x2C]
  0001c	e3a03001	 mov         r3, #1
  00020	e3a01003	 mov         r1, #3
  00024	e5843030	 str         r3, [r4, #0x30]
  00028	eb000000	 bl          EventModify

; 1571 :         WaitForSingleObject(pPdd->hIntrThread, INFINITE);

  0002c	e5940034	 ldr         r0, [r4, #0x34]
  00030	e3e01000	 mvn         r1, #0
  00034	eb000000	 bl          WaitForSingleObject

; 1572 :         CloseHandle(pPdd->hIntrThread);

  00038	e5940034	 ldr         r0, [r4, #0x34]
  0003c	eb000000	 bl          CloseHandle
  00040		 |$LN5@UfnPdd_Dei|

; 1573 :     }
; 1574 : 
; 1575 :     // Close interrupt handler
; 1576 :     if (pPdd->hIntrEvent != NULL)

  00040	e594302c	 ldr         r3, [r4, #0x2C]
  00044	e3a05000	 mov         r5, #0
  00048	e3530000	 cmp         r3, #0
  0004c	0a000002	 beq         |$LN4@UfnPdd_Dei|

; 1577 :     {
; 1578 :         CloseHandle(pPdd->hIntrEvent);

  00050	e1a00003	 mov         r0, r3
  00054	eb000000	 bl          CloseHandle

; 1579 :         pPdd->hIntrEvent = NULL;

  00058	e584502c	 str         r5, [r4, #0x2C]
  0005c		 |$LN4@UfnPdd_Dei|

; 1580 :     }
; 1581 : 
; 1582 :     // If parent bus is open, set hardware to D4 and close it
; 1583 :     if (pPdd->hParentBus != NULL)

  0005c	e5943020	 ldr         r3, [r4, #0x20]
  00060	e3530000	 cmp         r3, #0
  00064	0a000006	 beq         |$LN3@UfnPdd_Dei|

; 1584 :     {
; 1585 :         SetDevicePowerState(pPdd->hParentBus, D4, NULL);

  00068	e3a02000	 mov         r2, #0
  0006c	e3a01004	 mov         r1, #4
  00070	e1a00003	 mov         r0, r3
  00074	eb000000	 bl          SetDevicePowerState

; 1586 :         CloseBusAccessHandle(pPdd->hParentBus);

  00078	e5940020	 ldr         r0, [r4, #0x20]
  0007c	eb000000	 bl          CloseBusAccessHandle

; 1587 :         pPdd->hParentBus = NULL;

  00080	e5845020	 str         r5, [r4, #0x20]
  00084		 |$LN3@UfnPdd_Dei|

; 1588 :     }
; 1589 : 
; 1590 :     // Unmap USBD controller registers
; 1591 :     if (pPdd->pUSBDRegs != NULL)

  00084	e5943024	 ldr         r3, [r4, #0x24]
  00088	e3530000	 cmp         r3, #0
  0008c	0a000003	 beq         |$LN2@UfnPdd_Dei|

; 1592 :     {
; 1593 :         MmUnmapIoSpace((VOID*)pPdd->pUSBDRegs, pPdd->memLen);

  00090	e5941004	 ldr         r1, [r4, #4]
  00094	e1a00003	 mov         r0, r3
  00098	eb000000	 bl          MmUnmapIoSpace

; 1594 :         pPdd->pUSBDRegs = NULL;

  0009c	e5845024	 str         r5, [r4, #0x24]
  000a0		 |$LN2@UfnPdd_Dei|

; 1595 :     }
; 1596 : 
; 1597 :     // Release interrupt
; 1598 :     if (pPdd->sysIntr != 0)

  000a0	e5943028	 ldr         r3, [r4, #0x28]
  000a4	e3530000	 cmp         r3, #0
  000a8	0a000009	 beq         |$LN1@UfnPdd_Dei|

; 1599 :     {
; 1600 :         InterruptDisable(pPdd->sysIntr);

  000ac	e1a00003	 mov         r0, r3
  000b0	eb000000	 bl          InterruptDisable

; 1601 :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR,
; 1602 :                         &pPdd->sysIntr,
; 1603 :                         sizeof(pPdd->sysIntr),
; 1604 :                         NULL,
; 1605 :                         0,
; 1606 :                         NULL);

  000b4	e59f0050	 ldr         r0, [pc, #0x50]
  000b8	e3a03000	 mov         r3, #0
  000bc	e3a02004	 mov         r2, #4
  000c0	e2841028	 add         r1, r4, #0x28
  000c4	e58d5004	 str         r5, [sp, #4]
  000c8	e58d5000	 str         r5, [sp]
  000cc	eb000000	 bl          KernelIoControl

; 1607 : 
; 1608 :         pPdd->sysIntr = 0;

  000d0	e5845028	 str         r5, [r4, #0x28]
  000d4		 |$LN1@UfnPdd_Dei|

; 1609 :     }
; 1610 : 
; 1611 :     // Delete critical section
; 1612 :     DeleteCriticalSection(&pPdd->epCS);

  000d4	e2840054	 add         r0, r4, #0x54
  000d8	eb000000	 bl          DeleteCriticalSection

; 1613 : 
; 1614 :     // Free PDD context
; 1615 :     LocalFree(pPdd);

  000dc	e1a00004	 mov         r0, r4
  000e0	eb000000	 bl          LocalFree

; 1616 : 
; 1617 :     AdvertiseInterface((const GUID *)DMCLASS_PROTECTEDBUSNAMESPACE, L"UsbFn",FALSE);

  000e4	e59f101c	 ldr         r1, [pc, #0x1C]
  000e8	e59f0014	 ldr         r0, [pc, #0x14]
  000ec	e3a02000	 mov         r2, #0
  000f0	eb000000	 bl          AdvertiseInterface

; 1618 : 
; 1619 :     // Done
; 1620 :     return ERROR_SUCCESS;

  000f4	e3a00000	 mov         r0, #0

; 1621 : }

  000f8	e28dd008	 add         sp, sp, #8
  000fc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$LN13@UfnPdd_Dei|
  00104		 |$LN14@UfnPdd_Dei|
  00104	00000000	 DCD         |??_C@_1EO@GIHKGMGM@?$AA?$HL?$AA6?$AAF?$AA4?$AA0?$AA7?$AA9?$AA1?$AAD?$AA?9?$AA3?$AA0?$AA0?$AAE?$AA?9?$AA4?$AA4?$AAE?$AA4?$AA?9?$AAB?$AAC?$AA3?$AA8?$AA?9?$AAE?$AA0?$AAE?$AA6?$AA3?$AAC?$AAA@|
  00108		 |$LN15@UfnPdd_Dei|
  00108	00000000	 DCD         |??_C@_1M@KNLKOEJA@?$AAU?$AAs?$AAb?$AAF?$AAn?$AA?$AA@|
  0010c		 |$LN16@UfnPdd_Dei|
  0010c	010100d8	 DCD         0x10100d8
  00110		 |$M45407|

			 ENDP  ; |UfnPdd_Deinit|

	EXPORT	|UfnPdd_DeregisterDevice|

  00000			 AREA	 |.pdata|, PDATA
|$T45426| DCD	|$LN10@UfnPdd_Der|
	DCD	0x40000c00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DeregisterDevice| PROC

; 1632 : {

  00000		 |$LN10@UfnPdd_Der|
  00000		 |$M45423|

; 1633 :     USBFN_PDD          *pPdd      = pPddContext;
; 1634 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00000	e5903024	 ldr         r3, [r0, #0x24]

; 1635 :     DWORD               ep;
; 1636 : 
; 1637 : 
; 1638 :     // Disable all RX, TX EPs
; 1639 :     OUTREG32(&pUSBDRegs->EP0, 0);

  00004	e3a01000	 mov         r1, #0
  00008	e3a0200f	 mov         r2, #0xF
  0000c	e5831080	 str         r1, [r3, #0x80]
  00010	e2833084	 add         r3, r3, #0x84
  00014		 |$LL3@UfnPdd_Der|

; 1640 : 
; 1641 :     for (ep = 0; ep < USBD_NONZERO_EP_COUNT; ep++)
; 1642 :     {
; 1643 :         OUTREG32(&pUSBDRegs->EP_RX[ep], 0);

  00014	e5831000	 str         r1, [r3]

; 1644 :         OUTREG32(&pUSBDRegs->EP_TX[ep], 0);

  00018	e5831040	 str         r1, [r3, #0x40]
  0001c	e2833004	 add         r3, r3, #4
  00020	e2522001	 subs        r2, r2, #1
  00024	1afffffa	 bne         |$LL3@UfnPdd_Der|

; 1645 :     }
; 1646 : 
; 1647 :     return ERROR_SUCCESS;

  00028	e3a00000	 mov         r0, #0

; 1648 : }

  0002c	e12fff1e	 bx          lr
  00030		 |$M45424|

			 ENDP  ; |UfnPdd_DeregisterDevice|

	EXPORT	|UfnPdd_Stop|

  00000			 AREA	 |.pdata|, PDATA
|$T45438| DCD	|$LN7@UfnPdd_Sto|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Stop| PROC

; 1659 : {

  00000		 |$LN7@UfnPdd_Sto|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45435|
  00004	e1a04000	 mov         r4, r0

; 1660 :     USBFN_PDD           *pPdd      = pPddContext;
; 1661 :     OMAP2420_USBD_REGS  *pUSBDRegs = pPdd->pUSBDRegs;
; 1662 :     CEDEVICE_POWER_STATE prevPowerState ;
; 1663 : 
; 1664 : 
; 1665 :     DEBUGMSG(ZONE_PDD, (L"UfnPdd_Stop\r\n"));
; 1666 : 
; 1667 :     prevPowerState = pPdd->m_CurrentPowerState;

  00008	e594503c	 ldr         r5, [r4, #0x3C]
  0000c	e5946024	 ldr         r6, [r4, #0x24]

; 1668 : 
; 1669 :     if ((prevPowerState == D3) || (prevPowerState == D4))

  00010	e3550003	 cmp         r5, #3
  00014	0a000001	 beq         |$LN1@UfnPdd_Sto|
  00018	e3550004	 cmp         r5, #4
  0001c	1a000003	 bne         |$LN2@UfnPdd_Sto|
  00020		 |$LN1@UfnPdd_Sto|

; 1670 :     {
; 1671 :         pPdd->m_NewPowerState = D2;

  00020	e3a03002	 mov         r3, #2

; 1672 :         UpdateDevicePower(pPdd);

  00024	e1a00004	 mov         r0, r4
  00028	e5843038	 str         r3, [r4, #0x38]
  0002c	eb000000	 bl          UpdateDevicePower
  00030		 |$LN2@UfnPdd_Sto|

; 1673 :     }
; 1674 : 
; 1675 :     // Deattach device
; 1676 :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  00030	e5963018	 ldr         r3, [r6, #0x18]

; 1677 : 
; 1678 :     pPdd->m_NewPowerState = prevPowerState;
; 1679 :     UpdateDevicePower(pPdd);

  00034	e1a00004	 mov         r0, r4
  00038	e3c33001	 bic         r3, r3, #1
  0003c	e5863018	 str         r3, [r6, #0x18]
  00040	e5845038	 str         r5, [r4, #0x38]
  00044	eb000000	 bl          UpdateDevicePower

; 1680 : 
; 1681 :     // Done
; 1682 :     return ERROR_SUCCESS;

  00048	e3a00000	 mov         r0, #0

; 1683 : }

  0004c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M45436|

			 ENDP  ; |UfnPdd_Stop|

	EXPORT	|UfnPdd_DeinitEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T45467| DCD	|$LN13@UfnPdd_Dei@2|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DeinitEndpoint| PROC

; 1694 : {

  00000		 |$LN13@UfnPdd_Dei@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M45464|
  00004	e1a06000	 mov         r6, r0

; 1695 :     USBFN_PDD          *pPdd      = pPddContext;
; 1696 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1697 :     DWORD               epNum;
; 1698 : 
; 1699 : 
; 1700 :     DEBUGMSG(ZONE_PDD, (L"UfnPdd_DeinitEndpoint: %d\r\n", endPoint));
; 1701 : 
; 1702 :     // Select EP
; 1703 :     epNum = USBD_EP_NUM & endPoint;
; 1704 :     SelectEp(pPdd, epNum);

  00008	e5964024	 ldr         r4, [r6, #0x24]
  0000c	e2860054	 add         r0, r6, #0x54
  00010	e201500f	 and         r5, r1, #0xF
  00014	eb000000	 bl          EnterCriticalSection
  00018	e5962024	 ldr         r2, [r6, #0x24]
  0001c	e3853020	 orr         r3, r5, #0x20

; 1705 : 
; 1706 :     // Clear EP
; 1707 :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);
; 1708 : 
; 1709 :     // Deselect EP
; 1710 :     DeselectEp(pPdd, epNum);

  00020	e2860054	 add         r0, r6, #0x54
  00024	e5823004	 str         r3, [r2, #4]
  00028	e3a03002	 mov         r3, #2
  0002c	e584300c	 str         r3, [r4, #0xC]
  00030	e5963024	 ldr         r3, [r6, #0x24]
  00034	e5835004	 str         r5, [r3, #4]
  00038	eb000000	 bl          LeaveCriticalSection

; 1711 : 
; 1712 :     // Done
; 1713 :     return ERROR_SUCCESS;

  0003c	e3a00000	 mov         r0, #0

; 1714 : }

  00040	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M45465|

			 ENDP  ; |UfnPdd_DeinitEndpoint|

	EXPORT	|UfnPdd_InitEndpoint|

  00000			 AREA	 |.pdata|, PDATA
|$T45476| DCD	|$LN5@UfnPdd_Ini@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_InitEndpoint| PROC

; 1732 : {

  00000		 |$LN5@UfnPdd_Ini@2|
  00000		 |$M45473|

; 1733 :     DEBUGMSG(ZONE_PDD, (L"UfnPdd_InitEndpoint: %d\r\n", endPoint));
; 1734 :     return ERROR_SUCCESS;

  00000	e3a00000	 mov         r0, #0

; 1735 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45474|

			 ENDP  ; |UfnPdd_InitEndpoint|

	EXPORT	|UfnPdd_SetAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T45485| DCD	|$LN5@UfnPdd_Set|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_SetAddress| PROC

; 1746 : {

  00000		 |$LN5@UfnPdd_Set|
  00000		 |$M45482|

; 1747 :     DEBUGMSG(ZONE_PDD, (L"UfnPdd_SetAddress(0x%08X, 0x%02X)\r\n", pPddContext, address));
; 1748 :     return ERROR_SUCCESS;

  00000	e3a00000	 mov         r0, #0

; 1749 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45483|

			 ENDP  ; |UfnPdd_SetAddress|

	EXPORT	|UfnPdd_Start|

  00000			 AREA	 |.pdata|, PDATA
|$T45497| DCD	|$LN7@UfnPdd_Sta@2|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Start| PROC

; 1760 : {

  00000		 |$LN7@UfnPdd_Sta@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45494|
  00004	e1b05000	 movs        r5, r0

; 1761 :     DWORD rv;
; 1762 :     
; 1763 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_Start() - START\r\n"));
; 1764 : 
; 1765 :     if (pPddContext == NULL)
; 1766 :     {
; 1767 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Start() - "
; 1768 :             L"Invalid Parameter: pPddContext is NULL\r\n"));
; 1769 :         rv = ERROR_INVALID_PARAMETER;

  00008	03a00057	 moveq       r0, #0x57

; 1791 :     }
; 1792 :     
; 1793 : 
; 1794 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_Start() - END\r\n"));
; 1795 : 
; 1796 :     // Done
; 1797 :     return rv;
; 1798 : }

  0000c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00010	012fff1e	 bxeq        lr

; 1770 :     }
; 1771 :     else
; 1772 :     {
; 1773 :         USBFN_PDD          * pPdd           = pPddContext;
; 1774 :         OMAP2420_USBD_REGS * pUSBDRegs      = pPdd->pUSBDRegs;
; 1775 : 
; 1776 : 
; 1777 :         pPdd->m_NewPowerState = D2;

  00014	e3a03002	 mov         r3, #2
  00018	e5853038	 str         r3, [r5, #0x38]

; 1778 :         UpdateDevicePower(pPdd);

  0001c	e1a00005	 mov         r0, r5
  00020	e5954024	 ldr         r4, [r5, #0x24]
  00024	eb000000	 bl          UpdateDevicePower

; 1779 : 
; 1780 :         // Enable interrupts
; 1781 :         OUTREG32(&pUSBDRegs->IRQ_EN, USBD_IRQ_MASK);

  00028	e3a03039	 mov         r3, #0x39
  0002c	e5843028	 str         r3, [r4, #0x28]

; 1782 : 
; 1783 :         // Attach device to bus (it has no effect when OTG controller is used)
; 1784 :         SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  00030	e5943018	 ldr         r3, [r4, #0x18]

; 1785 : 
; 1786 :         // Set fake device change flag which on first interrupt force
; 1787 :         // device state change handler even if it isn't indicated by hardware
; 1788 :         pPdd->fakeDsChange = TRUE;

  00034	e3a02001	 mov         r2, #1

; 1789 : 
; 1790 :         rv = ERROR_SUCCESS;

  00038	e3a00000	 mov         r0, #0
  0003c	e3833001	 orr         r3, r3, #1
  00040	e5843018	 str         r3, [r4, #0x18]
  00044	e5852168	 str         r2, [r5, #0x168]

; 1791 :     }
; 1792 :     
; 1793 : 
; 1794 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_Start() - END\r\n"));
; 1795 : 
; 1796 :     // Done
; 1797 :     return rv;
; 1798 : }

  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M45495|

			 ENDP  ; |UfnPdd_Start|

	EXPORT	|UfnPdd_RegisterDevice|

  00000			 AREA	 |.pdata|, PDATA
|$T45569| DCD	|$LN56@UfnPdd_Reg|
	DCD	0x4000a902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_RegisterDevice| PROC

; 1821 : {

  00000		 |$LN56@UfnPdd_Reg|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M45566|
  00008	e58d0004	 str         r0, [sp, #4]

; 1822 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1823 :     USBFN_PDD *pPdd = pPddContext;
; 1824 :     OMAP2420_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1825 :     UFN_INTERFACE *pIFC;
; 1826 :     UFN_ENDPOINT  *pEP;
; 1827 :     DWORD offset, ep;
; 1828 :     DWORD ifc, epx;
; 1829 :     DWORD cfg;
; 1830 : 
; 1831 : 
; 1832 :     DEBUGMSG(ZONE_FUNCTION, (L"UfnPdd_RegisterDevice() - START\r\n"));
; 1833 : 
; 1834 :     // Remember self powered flag
; 1835 :     pPdd->selfPowered = ((pFullSpeedConfig->Descriptor.bmAttributes & 0x20) != 0);

  0000c	e59de030	 ldr         lr, [sp, #0x30]
  00010	e5904024	 ldr         r4, [r0, #0x24]

; 1836 : 
; 1837 :     // Unlock configuration
; 1838 :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_CFG_LOCK);
; 1839 : 
; 1840 :     DEBUGMSG(ZONE_PDD, (L"UfnPdd_RegisterDevice() - "
; 1841 :         L"Configuring EndPoint 00 (RX)\r\n"));
; 1842 : 
; 1843 :     // Configure EP0
; 1844 :     offset = 8;
; 1845 :     cfg  = (Log2(pFullSpeedDeviceDesc->bMaxPacketSize0 >> 3) << 12);

  00014	e59d102c	 ldr         r1, [sp, #0x2C]
  00018	e5de300b	 ldrb        r3, [lr, #0xB]
  0001c	e3a02000	 mov         r2, #0
  00020	e3130020	 tst         r3, #0x20
  00024	13a03001	 movne       r3, #1
  00028	03a03000	 moveq       r3, #0
  0002c	e5803044	 str         r3, [r0, #0x44]
  00030	e5943018	 ldr         r3, [r4, #0x18]
  00034	e3c33c01	 bic         r3, r3, #1, 24
  00038	e5843018	 str         r3, [r4, #0x18]
  0003c	e5d13007	 ldrb        r3, [r1, #7]
  00040	e1b031a3	 movs        r3, r3, lsr #3
  00044	0a000004	 beq         |$LN25@UfnPdd_Reg|
  00048		 |$LL27@UfnPdd_Reg|
  00048	e1b030a3	 movs        r3, r3, lsr #1
  0004c	e2822001	 add         r2, r2, #1
  00050	1afffffc	 bne         |$LL27@UfnPdd_Reg|
  00054	e3520000	 cmp         r2, #0
  00058	12422001	 subne       r2, r2, #1
  0005c		 |$LN25@UfnPdd_Reg|
  0005c	e1a03602	 mov         r3, r2, lsl #12

; 1846 :     cfg |= offset >> 3;

  00060	e3833001	 orr         r3, r3, #1

; 1847 : 
; 1848 :     OUTREG32(&pUSBDRegs->EP0, cfg);

  00064	e5843080	 str         r3, [r4, #0x80]

; 1849 : 
; 1850 :     pPdd->ep[0].maxPacketSize = pFullSpeedDeviceDesc->bMaxPacketSize0;

  00068	e5d13007	 ldrb        r3, [r1, #7]

; 1851 :     offset += pFullSpeedDeviceDesc->bMaxPacketSize0;
; 1852 : 
; 1853 :     // Configure Rx EPs
; 1854 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  0006c	e3a07000	 mov         r7, #0
  00070	e58d7000	 str         r7, [sp]
  00074	e1c036b8	 strh        r3, [r0, #0x68]
  00078	e5d13007	 ldrb        r3, [r1, #7]
  0007c	e5de2008	 ldrb        r2, [lr, #8]
  00080	e283b008	 add         r11, r3, #8
  00084	e3520000	 cmp         r2, #0
  00088	0a00003c	 beq         |$LN18@UfnPdd_Reg|
  0008c	e3a05000	 mov         r5, #0
  00090		 |$LL20@UfnPdd_Reg|

; 1855 :     {
; 1856 :         // For each endpoint in interface...
; 1857 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00090	e59e3018	 ldr         r3, [lr, #0x18]

; 1858 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00094	e3a08000	 mov         r8, #0
  00098	e0859003	 add         r9, r5, r3
  0009c	e5d93008	 ldrb        r3, [r9, #8]
  000a0	e3530000	 cmp         r3, #0
  000a4	0a00002f	 beq         |$LN19@UfnPdd_Reg|
  000a8	e59de004	 ldr         lr, [sp, #4]
  000ac	e3a06000	 mov         r6, #0
  000b0	e3a07001	 mov         r7, #1
  000b4		 |$LL17@UfnPdd_Reg|

; 1859 :         {
; 1860 :             pEP = &pIFC->pEndpoints[epx];

  000b4	e5993018	 ldr         r3, [r9, #0x18]
  000b8	e0860003	 add         r0, r6, r3

; 1861 : 
; 1862 :             // If it is Tx EP skip it
; 1863 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) != 0)

  000bc	e5d02006	 ldrb        r2, [r0, #6]
  000c0	e3120080	 tst         r2, #0x80
  000c4	1a000020	 bne         |$LN16@UfnPdd_Reg|

; 1864 :             {
; 1865 :                 continue;
; 1866 :             }
; 1867 : 
; 1868 :             DEBUGMSG(ZONE_PDD, (L"UfnPdd_RegisterDevice() - "
; 1869 :                 L"Configuring Interface %02u EndPoint %02u (RX)\r\n", ifc, epx));
; 1870 : 
; 1871 :             // Get EP address
; 1872 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 1873 : 
; 1874 :             // Save max packet size & direction
; 1875 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  000c8	e5d01008	 ldrb        r1, [r0, #8]
  000cc	e5d03009	 ldrb        r3, [r0, #9]
  000d0	e202a00f	 and         r10, r2, #0xF
  000d4	e08e220a	 add         r2, lr, r10, lsl #4
  000d8	e1813403	 orr         r3, r1, r3, lsl #8
  000dc	e1c236b8	 strh        r3, [r2, #0x68]

; 1876 :             pPdd->ep[ep].dirRx = TRUE;

  000e0	e582706c	 str         r7, [r2, #0x6C]

; 1877 : 
; 1878 :             // Create EP config
; 1879 :             cfg  = USBD_EP_VALID;
; 1880 :             cfg |= (Log2(pEP->Descriptor.wMaxPacketSize >> 3) << 12);

  000e4	e5d02008	 ldrb        r2, [r0, #8]
  000e8	e5d03009	 ldrb        r3, [r0, #9]
  000ec	e3a01000	 mov         r1, #0
  000f0	e1823403	 orr         r3, r2, r3, lsl #8
  000f4	e1b031a3	 movs        r3, r3, lsr #3
  000f8	0a000004	 beq         |$LN30@UfnPdd_Reg|
  000fc		 |$LL32@UfnPdd_Reg|
  000fc	e1b030a3	 movs        r3, r3, lsr #1
  00100	e2811001	 add         r1, r1, #1
  00104	1afffffc	 bne         |$LL32@UfnPdd_Reg|
  00108	e3510000	 cmp         r1, #0
  0010c	12411001	 subne       r1, r1, #1
  00110		 |$LN30@UfnPdd_Reg|

; 1881 : 
; 1882 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01)

  00110	e5d02007	 ldrb        r2, [r0, #7]
  00114	e3813008	 orr         r3, r1, #8
  00118	e1a01603	 mov         r1, r3, lsl #12
  0011c	e2023003	 and         r3, r2, #3
  00120	e3530001	 cmp         r3, #1

; 1883 :             {
; 1884 :                 cfg |= USBD_EP_ISO;

  00124	03811b02	 orreq       r1, r1, #2, 22

; 1885 :             }
; 1886 : 
; 1887 :             cfg |= offset >> 3;
; 1888 : 
; 1889 :             if (ep > 0)

  00128	e35a0000	 cmp         r10, #0

; 1890 :                 OUTREG32(&pUSBDRegs->EP_RX[ep - 1], cfg);

  0012c	128a3020	 addne       r3, r10, #0x20
  00130	10842103	 addne       r2, r4, r3, lsl #2
  00134	118131ab	 orrne       r3, r1, r11, lsr #3
  00138	15823000	 strne       r3, [r2]

; 1891 :             else
; 1892 :                 DEBUGMSG(ZONE_PDD, (L"USBFN:: UfnPdd_RegisterDevice EP_RX = %d\r\n", ep - 1));
; 1893 : 
; 1894 :             // Update offset
; 1895 :             offset += pEP->Descriptor.wMaxPacketSize;

  0013c	e5d02008	 ldrb        r2, [r0, #8]
  00140	e5d03009	 ldrb        r3, [r0, #9]
  00144	e1823403	 orr         r3, r2, r3, lsl #8
  00148	e08bb003	 add         r11, r11, r3
  0014c		 |$LN16@UfnPdd_Reg|
  0014c	e5d93008	 ldrb        r3, [r9, #8]
  00150	e2888001	 add         r8, r8, #1
  00154	e2866014	 add         r6, r6, #0x14
  00158	e1580003	 cmp         r8, r3
  0015c	3affffd4	 bcc         |$LL17@UfnPdd_Reg|
  00160	e59de030	 ldr         lr, [sp, #0x30]
  00164	e59d7000	 ldr         r7, [sp]
  00168		 |$LN19@UfnPdd_Reg|
  00168	e5de3008	 ldrb        r3, [lr, #8]
  0016c	e2877001	 add         r7, r7, #1
  00170	e58d7000	 str         r7, [sp]
  00174	e1570003	 cmp         r7, r3
  00178	e285501c	 add         r5, r5, #0x1C
  0017c	3affffc3	 bcc         |$LL20@UfnPdd_Reg|
  00180		 |$LN18@UfnPdd_Reg|

; 1896 :         }
; 1897 :     }
; 1898 : 
; 1899 :     // Configure Tx EPs
; 1900 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++)

  00180	e5de3008	 ldrb        r3, [lr, #8]
  00184	e3a05000	 mov         r5, #0
  00188	e58d5000	 str         r5, [sp]
  0018c	e3530000	 cmp         r3, #0
  00190	0a00003c	 beq         |$LN8@UfnPdd_Reg|
  00194	e3a06000	 mov         r6, #0
  00198		 |$LL10@UfnPdd_Reg|

; 1901 :     {
; 1902 :         // For each endpoint in interface
; 1903 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00198	e59e3018	 ldr         r3, [lr, #0x18]

; 1904 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  0019c	e3a08000	 mov         r8, #0
  001a0	e0869003	 add         r9, r6, r3
  001a4	e5d93008	 ldrb        r3, [r9, #8]
  001a8	e3530000	 cmp         r3, #0
  001ac	0a00002f	 beq         |$LN9@UfnPdd_Reg|
  001b0	e59de004	 ldr         lr, [sp, #4]
  001b4	e3a07000	 mov         r7, #0
  001b8	e3a05000	 mov         r5, #0
  001bc		 |$LL7@UfnPdd_Reg|

; 1905 :         {
; 1906 :             pEP = &pIFC->pEndpoints[epx];

  001bc	e5993018	 ldr         r3, [r9, #0x18]
  001c0	e0870003	 add         r0, r7, r3

; 1907 : 
; 1908 :             // If it is Rx EP skip it
; 1909 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) == 0)

  001c4	e5d02006	 ldrb        r2, [r0, #6]
  001c8	e3120080	 tst         r2, #0x80
  001cc	0a000020	 beq         |$LN6@UfnPdd_Reg|

; 1910 :             {
; 1911 :                 continue;
; 1912 :             }
; 1913 : 
; 1914 :             DEBUGMSG(ZONE_PDD, (L"UfnPdd_RegisterDevice() - "
; 1915 :                 L"Configuring Interface %02u EndPoint %02u (TX)\r\n", ifc, epx));
; 1916 : 
; 1917 :             // Get EP address
; 1918 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 1919 : 
; 1920 :             // Save max packet size & direction
; 1921 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  001d0	e5d01008	 ldrb        r1, [r0, #8]
  001d4	e5d03009	 ldrb        r3, [r0, #9]
  001d8	e202a00f	 and         r10, r2, #0xF
  001dc	e08e220a	 add         r2, lr, r10, lsl #4
  001e0	e1813403	 orr         r3, r1, r3, lsl #8
  001e4	e1c236b8	 strh        r3, [r2, #0x68]

; 1922 :             pPdd->ep[ep].dirRx = FALSE;

  001e8	e582506c	 str         r5, [r2, #0x6C]

; 1923 : 
; 1924 :             // Create EP config
; 1925 :             cfg  = USBD_EP_VALID;
; 1926 : 
; 1927 :             cfg |= (Log2(pEP->Descriptor.wMaxPacketSize >> 3) << 12);

  001ec	e5d02008	 ldrb        r2, [r0, #8]
  001f0	e5d03009	 ldrb        r3, [r0, #9]
  001f4	e3a01000	 mov         r1, #0
  001f8	e1823403	 orr         r3, r2, r3, lsl #8
  001fc	e1b031a3	 movs        r3, r3, lsr #3
  00200	0a000004	 beq         |$LN35@UfnPdd_Reg|
  00204		 |$LL37@UfnPdd_Reg|
  00204	e1b030a3	 movs        r3, r3, lsr #1
  00208	e2811001	 add         r1, r1, #1
  0020c	1afffffc	 bne         |$LL37@UfnPdd_Reg|
  00210	e3510000	 cmp         r1, #0
  00214	12411001	 subne       r1, r1, #1
  00218		 |$LN35@UfnPdd_Reg|

; 1928 : 
; 1929 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01)

  00218	e5d02007	 ldrb        r2, [r0, #7]
  0021c	e3813008	 orr         r3, r1, #8
  00220	e1a01603	 mov         r1, r3, lsl #12
  00224	e2023003	 and         r3, r2, #3
  00228	e3530001	 cmp         r3, #1

; 1930 :             {
; 1931 :                 cfg |= USBD_EP_ISO;

  0022c	03811b02	 orreq       r1, r1, #2, 22

; 1932 :             }
; 1933 : 
; 1934 :             cfg |= offset >> 3;
; 1935 : 
; 1936 :             if (ep > 0)

  00230	e35a0000	 cmp         r10, #0

; 1937 :                 OUTREG32(&pUSBDRegs->EP_TX[ep - 1], cfg);

  00234	128a3030	 addne       r3, r10, #0x30
  00238	10842103	 addne       r2, r4, r3, lsl #2
  0023c	118131ab	 orrne       r3, r1, r11, lsr #3
  00240	15823000	 strne       r3, [r2]

; 1938 :             else
; 1939 :                 DEBUGMSG(ZONE_PDD, (L"USBFN:: UfnPdd_RegisterDevice "
; 1940 :                     L"EP_TX = %d\r\n", ep - 1));
; 1941 : 
; 1942 : 
; 1943 :             // Update offset
; 1944 :             offset += pEP->Descriptor.wMaxPacketSize;

  00244	e5d02008	 ldrb        r2, [r0, #8]
  00248	e5d03009	 ldrb        r3, [r0, #9]
  0024c	e1823403	 orr         r3, r2, r3, lsl #8
  00250	e08bb003	 add         r11, r11, r3
  00254		 |$LN6@UfnPdd_Reg|
  00254	e5d93008	 ldrb        r3, [r9, #8]
  00258	e2888001	 add         r8, r8, #1
  0025c	e2877014	 add         r7, r7, #0x14
  00260	e1580003	 cmp         r8, r3
  00264	3affffd4	 bcc         |$LL7@UfnPdd_Reg|
  00268	e59de030	 ldr         lr, [sp, #0x30]
  0026c	e59d5000	 ldr         r5, [sp]
  00270		 |$LN9@UfnPdd_Reg|
  00270	e5de3008	 ldrb        r3, [lr, #8]
  00274	e2855001	 add         r5, r5, #1
  00278	e58d5000	 str         r5, [sp]
  0027c	e1550003	 cmp         r5, r3
  00280	e286601c	 add         r6, r6, #0x1C
  00284	3affffc3	 bcc         |$LL10@UfnPdd_Reg|
  00288		 |$LN8@UfnPdd_Reg|

; 1945 :         }
; 1946 :     }
; 1947 : 
; 1948 :     // Lock configuration
; 1949 :     SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_CFG_LOCK);

  00288	e5943018	 ldr         r3, [r4, #0x18]

; 1950 : 
; 1951 :     DEBUGMSG(ZONE_PDD, (L"UfnPdd_RegisterDevice() - END\r\n"));
; 1952 : 
; 1953 :     // Done
; 1954 :     return ERROR_SUCCESS;

  0028c	e3a00000	 mov         r0, #0
  00290	e3833c01	 orr         r3, r3, #1, 24
  00294	e5843018	 str         r3, [r4, #0x18]

; 1955 : }

  00298	e28dd008	 add         sp, sp, #8
  0029c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002a0	e12fff1e	 bx          lr
  002a4		 |$M45567|

			 ENDP  ; |UfnPdd_RegisterDevice|

	EXPORT	|UfnPdd_IsEndpointSupportable|

  00000			 AREA	 |.pdata|, PDATA
|$T45580| DCD	|$LN6@UfnPdd_IsE@2|
	DCD	0x40000700
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsEndpointSupportable| PROC

; 1975 : {

  00000		 |$LN6@UfnPdd_IsE@2|
  00000		 |$M45577|
  00000	e3510000	 cmp         r1, #0

; 1976 :     USBFN_PDD *pPdd = pPddContext;
; 1977 : 
; 1978 : 
; 1979 :     // Update maximal packet size for EP0
; 1980 :     if (endPoint == 0)
; 1981 :     {
; 1982 :         DEBUGCHK(pEPDesc->wMaxPacketSize <= 64);
; 1983 :         DEBUGCHK(pEPDesc->bmAttributes == USB_ENDPOINT_TYPE_CONTROL);
; 1984 :         pEPDesc->wMaxPacketSize = 64;

  00004	03a02040	 moveq       r2, #0x40
  00008	03a01000	 moveq       r1, #0
  0000c	05c32004	 streqb      r2, [r3, #4]
  00010	05c31005	 streqb      r1, [r3, #5]

; 1985 :     }
; 1986 : 
; 1987 :     // Done
; 1988 :     return ERROR_SUCCESS;

  00014	e3a00000	 mov         r0, #0

; 1989 : }

  00018	e12fff1e	 bx          lr
  0001c		 |$M45578|

			 ENDP  ; |UfnPdd_IsEndpointSupportable|

	EXPORT	|UfnPdd_IsConfigurationSupportable|

  00000			 AREA	 |.pdata|, PDATA
|$T45616| DCD	|$LN29@UfnPdd_IsC|
	DCD	0x40004101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_IsConfigurationSupportable| PROC

; 2007 : {

  00000		 |$LN29@UfnPdd_IsC|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45613|
  00004	e1a05002	 mov         r5, r2

; 2008 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 2009 :     USBFN_PDD *pPdd = pPddContext;
; 2010 :     UFN_INTERFACE *pIFC;
; 2011 :     UFN_ENDPOINT *pEP;
; 2012 :     DWORD ifc, epx, count;
; 2013 :     DWORD offset, size;
; 2014 : 
; 2015 : 
; 2016 :     // TODO: Update self power bit & maxPower
; 2017 : 
; 2018 :     // We must start with offset 8 + 64 (config plus EP0 size)
; 2019 :     offset = 8 + 64;
; 2020 : 
; 2021 :     // Clear number of end points
; 2022 :     count = 0;
; 2023 : 
; 2024 :     // For each interface in configuration
; 2025 :     for (ifc = 0; ifc < pConfig->Descriptor.bNumInterfaces; ifc++)

  00008	e5d53008	 ldrb        r3, [r5, #8]
  0000c	e3a00057	 mov         r0, #0x57
  00010	e3a08048	 mov         r8, #0x48
  00014	e3530000	 cmp         r3, #0
  00018	e3a0e000	 mov         lr, #0
  0001c	e3a07000	 mov         r7, #0
  00020	0a000034	 beq         |$LN26@UfnPdd_IsC|
  00024	e3a04000	 mov         r4, #0
  00028	e3a00001	 mov         r0, #1
  0002c		 |$LL11@UfnPdd_IsC|

; 2026 :     {
; 2027 :         // For each endpoint in interface
; 2028 :         pIFC = &pConfig->pInterfaces[ifc];

  0002c	e5953018	 ldr         r3, [r5, #0x18]

; 2029 : 
; 2030 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++)

  00030	e3a0b000	 mov         r11, #0
  00034	e0846003	 add         r6, r4, r3
  00038	e5d63008	 ldrb        r3, [r6, #8]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000020	 beq         |$LN6@UfnPdd_IsC|

; 2026 :     {
; 2027 :         // For each endpoint in interface
; 2028 :         pIFC = &pConfig->pInterfaces[ifc];

  00044	e3a09000	 mov         r9, #0
  00048		 |$LL8@UfnPdd_IsC|

; 2031 :         {
; 2032 :             pEP = &pIFC->pEndpoints[epx];

  00048	e5963018	 ldr         r3, [r6, #0x18]

; 2033 : 
; 2034 :             // We support maximal sizes 8, 16, 32 and 64 bytes for non-ISO
; 2035 :             size = pEP->Descriptor.wMaxPacketSize;
; 2036 : 
; 2037 :             // First round size to supported sizes
; 2038 :             size = 1 << Log2(size);

  0004c	e3a01000	 mov         r1, #0
  00050	e089a003	 add         r10, r9, r3
  00054	e5da2008	 ldrb        r2, [r10, #8]
  00058	e5da3009	 ldrb        r3, [r10, #9]
  0005c	e1923403	 orrs        r3, r2, r3, lsl #8
  00060	0a000004	 beq         |$LN14@UfnPdd_IsC|
  00064		 |$LL16@UfnPdd_IsC|
  00064	e1b030a3	 movs        r3, r3, lsr #1
  00068	e2811001	 add         r1, r1, #1
  0006c	1afffffc	 bne         |$LL16@UfnPdd_IsC|
  00070	e3510000	 cmp         r1, #0
  00074	12411001	 subne       r1, r1, #1
  00078		 |$LN14@UfnPdd_IsC|

; 2039 : 
; 2040 :             // Is it ISO end point?
; 2041 :             if ((pEP->Descriptor.bmAttributes & 0x03) != 0x01)

  00078	e5da3007	 ldrb        r3, [r10, #7]
  0007c	e1a02110	 mov         r2, r0, lsl r1
  00080	e2033003	 and         r3, r3, #3
  00084	e3530001	 cmp         r3, #1
  00088	0a000003	 beq         |$LN5@UfnPdd_IsC|

; 2042 :             {
; 2043 :                 // Non-ISO, max size is 64 bytes
; 2044 :                 if (size > 64)

  0008c	e3520040	 cmp         r2, #0x40
  00090	9a000003	 bls         |$LN2@UfnPdd_IsC|

; 2045 :                 {
; 2046 :                     size = 64;

  00094	e3a02040	 mov         r2, #0x40

; 2047 :                 }
; 2048 :             }
; 2049 :             else

  00098	ea000001	 b           |$LN2@UfnPdd_IsC|
  0009c		 |$LN5@UfnPdd_IsC|

; 2050 :             {
; 2051 :                 // ISO edpoint, maximal size is 512 bytes
; 2052 :                 if (size > 512)

  0009c	e3520c02	 cmp         r2, #2, 24

; 2053 :                 {
; 2054 :                     size = 512;

  000a0	83a02c02	 movhi       r2, #2, 24
  000a4		 |$LN2@UfnPdd_IsC|

; 2055 :                 }
; 2056 :             }
; 2057 : 
; 2058 :             // Update EP size
; 2059 :             pEP->Descriptor.wMaxPacketSize = (USHORT)size;

  000a4	e1a03422	 mov         r3, r2, lsr #8
  000a8	e5ca3009	 strb        r3, [r10, #9]
  000ac	e5ca2008	 strb        r2, [r10, #8]
  000b0	e5d63008	 ldrb        r3, [r6, #8]
  000b4	e28bb001	 add         r11, r11, #1

; 2060 : 
; 2061 :             // Calculate total buffer size
; 2062 :             offset += size;

  000b8	e0888002	 add         r8, r8, r2
  000bc	e15b0003	 cmp         r11, r3
  000c0	e2899014	 add         r9, r9, #0x14
  000c4	3affffdf	 bcc         |$LL8@UfnPdd_IsC|
  000c8		 |$LN6@UfnPdd_IsC|

; 2063 :         }
; 2064 : 
; 2065 :         // Add number of end points to total count
; 2066 :         count += pIFC->Descriptor.bNumEndpoints;

  000c8	e5d63008	 ldrb        r3, [r6, #8]
  000cc	e5d52008	 ldrb        r2, [r5, #8]
  000d0	e2877001	 add         r7, r7, #1
  000d4	e08ee003	 add         lr, lr, r3
  000d8	e1570002	 cmp         r7, r2
  000dc	e284401c	 add         r4, r4, #0x1C
  000e0	3affffd1	 bcc         |$LL11@UfnPdd_IsC|

; 2067 :     }
; 2068 : 
; 2069 :     // Can we support this configuration?
; 2070 :     if (count < USBD_EP_COUNT && offset <= 2048)

  000e4	e35e0010	 cmp         lr, #0x10
  000e8	e3a00057	 mov         r0, #0x57
  000ec	2a000002	 bcs         |$LN1@UfnPdd_IsC|
  000f0	e3580b02	 cmp         r8, #2, 22
  000f4	8a000000	 bhi         |$LN1@UfnPdd_IsC|
  000f8		 |$LN26@UfnPdd_IsC|

; 2071 :     {
; 2072 :         rc = ERROR_SUCCESS;

  000f8	e3a00000	 mov         r0, #0
  000fc		 |$LN1@UfnPdd_IsC|

; 2073 :     }
; 2074 : 
; 2075 :     // Done
; 2076 :     return rc;
; 2077 : }

  000fc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00100	e12fff1e	 bx          lr
  00104		 |$M45614|

			 ENDP  ; |UfnPdd_IsConfigurationSupportable|

	EXPORT	|UfnPdd_DllEntry|

  00000			 AREA	 |.pdata|, PDATA
|$T45625| DCD	|$LN5@UfnPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_DllEntry| PROC

; 2290 : {

  00000		 |$LN5@UfnPdd_Dll|
  00000		 |$M45622|

; 2291 : //    DEBUGMSG(ZONE_PDD, (L"UfnPdd_DllEntry() - CALLED\r\n"));
; 2292 :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 2293 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M45623|

			 ENDP  ; |UfnPdd_DllEntry|

	EXPORT	|PDD_Dump|
	IMPORT	|MmMapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T45638| DCD	|$LN11@PDD_Dump|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PDD_Dump| PROC

; 2301 : {

  00000		 |$LN11@PDD_Dump|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M45635|

; 2302 :     DEBUGMSG(ZONE_PDD, (L"============================================================\r\n"));
; 2303 :     DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2304 : 
; 2305 :     if (pPddRegs == NULL)
; 2306 :     {
; 2307 :         DEBUGMSG(ZONE_PDD, (L"USBD PDD_Dump() - ERROR: Pointer to USBD Registers is NULL\r\n"));
; 2308 :     }
; 2309 :     else
; 2310 :     {
; 2311 :         // Print out the values of all USB Device Registers
; 2312 :         DEBUGMSG(ZONE_PDD, (L"Dump USBD Registers:\r\n"));
; 2313 :         DEBUGMSG(ZONE_PDD, (L"\tREV        = 0x%04X\r\n", INREG32(&pPddRegs->REV)));        // 0000 - Revision
; 2314 :         DEBUGMSG(ZONE_PDD, (L"\tEP_NUM     = 0x%04X\r\n", INREG32(&pPddRegs->EP_NUM)));     // 0004 - Endpoint selection
; 2315 : //      DEBUGMSG(ZONE_PDD, (L"\tDATA       = 0x%04X\r\n", INREG32(&pPddRegs->DATA)));       // 0008 - Data
; 2316 :         DEBUGMSG(ZONE_PDD, (L"\tCTRL       = 0x%04X\r\n", INREG32(&pPddRegs->CTRL)));       // 000C - Control
; 2317 :         DEBUGMSG(ZONE_PDD, (L"\tSTAT_FLG   = 0x%04X\r\n", INREG32(&pPddRegs->STAT_FLG)));   // 0010 - Status
; 2318 :         DEBUGMSG(ZONE_PDD, (L"\tRXFSTAT    = 0x%04X\r\n", INREG32(&pPddRegs->RXFSTAT)));    // 0014 - Receive FIFO status
; 2319 :         DEBUGMSG(ZONE_PDD, (L"\tSYSCON1    = 0x%04X\r\n", INREG32(&pPddRegs->SYSCON1)));    // 0018 - System configuration 1
; 2320 :         DEBUGMSG(ZONE_PDD, (L"\tSYSCON2    = 0x%04X\r\n", INREG32(&pPddRegs->SYSCON2)));    // 001C - System configuration 2
; 2321 :         DEBUGMSG(ZONE_PDD, (L"\tDEVSTAT    = 0x%04X\r\n", INREG32(&pPddRegs->DEVSTAT)));    // 0020 - Device status
; 2322 :         DEBUGMSG(ZONE_PDD, (L"\tSOF        = 0x%04X\r\n", INREG32(&pPddRegs->SOF)));        // 0024 - Start of frame
; 2323 :         DEBUGMSG(ZONE_PDD, (L"\tIRQ_EN     = 0x%04X\r\n", INREG32(&pPddRegs->IRQ_EN)));     // 0028 - Interrupt enable
; 2324 :         DEBUGMSG(ZONE_PDD, (L"\tDMA_IRQ_EN = 0x%04X\r\n", INREG32(&pPddRegs->DMA_IRQ_EN))); // 002C - DMA interrupt enable
; 2325 :         DEBUGMSG(ZONE_PDD, (L"\tIRQ_SRC    = 0x%04X\r\n", INREG32(&pPddRegs->IRQ_SRC)));    // 0030 - Interrupt source
; 2326 :         DEBUGMSG(ZONE_PDD, (L"\tEP_STAT    = 0x%04X\r\n", INREG32(&pPddRegs->EP_STAT)));    // 0034 - Non-ISO endpoint interrupt enable
; 2327 :         DEBUGMSG(ZONE_PDD, (L"\tDMA_STAT   = 0x%04X\r\n", INREG32(&pPddRegs->DMA_STAT)));   // 0038 - Non-ISO DMA interrupt enable
; 2328 :         DEBUGMSG(ZONE_PDD, (L"\tRXDMA_CFG  = 0x%04X\r\n", INREG32(&pPddRegs->RXDMA_CFG)));  // 0040 - DMA receive channels config
; 2329 :         DEBUGMSG(ZONE_PDD, (L"\tTXDMA_CFG  = 0x%04X\r\n", INREG32(&pPddRegs->TXDMA_CFG)));  // 0044 - DMA transmit channels config
; 2330 : //      DEBUGMSG(ZONE_PDD, (L"\tDATA_DMA   = 0x%04X\r\n", INREG32(&pPddRegs->DATA_DMA)));   // 0048 - DMA FIFO data
; 2331 :         DEBUGMSG(ZONE_PDD, (L"\tTXDMA0     = 0x%04X\r\n", INREG32(&pPddRegs->TXDMA0)));     // 0050 - Transmit DMA control 0
; 2332 :         DEBUGMSG(ZONE_PDD, (L"\tTXDMA1     = 0x%04X\r\n", INREG32(&pPddRegs->TXDMA1)));     // 0054 - Transmit DMA control 1
; 2333 :         DEBUGMSG(ZONE_PDD, (L"\tTXDMA2     = 0x%04X\r\n", INREG32(&pPddRegs->TXDMA2)));     // 0058 - Transmit DMA control 2
; 2334 :         DEBUGMSG(ZONE_PDD, (L"\tRXDMA0     = 0x%04X\r\n", INREG32(&pPddRegs->RXDMA0)));     // 0060 - Receive DMA control 0
; 2335 :         DEBUGMSG(ZONE_PDD, (L"\tRXDMA1     = 0x%04X\r\n", INREG32(&pPddRegs->RXDMA1)));     // 0064 - Receive DMA control 0
; 2336 :         DEBUGMSG(ZONE_PDD, (L"\tRXDMA2     = 0x%04X\r\n", INREG32(&pPddRegs->RXDMA2)));     // 0068 - Receive DMA control 0
; 2337 :         DEBUGMSG(ZONE_PDD, (L"\tEP0        = 0x%04X\r\n", INREG32(&pPddRegs->EP0)));        // 0080 - Endpoint 0 configuration
; 2338 :         DEBUGMSG(ZONE_PDD, (L"\tEP_RX[0]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_RX[0])));   // 0084 - Endpoint 1 configuration
; 2339 :         DEBUGMSG(ZONE_PDD, (L"\tEP_RX[1]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_RX[1])));   // 0088 - Endpoint 2 configuration
; 2340 :         DEBUGMSG(ZONE_PDD, (L"\tEP_RX[2]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_RX[2])));   // 008C - Endpoint 3 configuration
; 2341 :         DEBUGMSG(ZONE_PDD, (L"\tEP_RX[3]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_RX[3])));   // 0090 - Endpoint 4 configuration
; 2342 :         DEBUGMSG(ZONE_PDD, (L"\tEP_TX[0]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_TX[0])));   // 00C4 - Endpoint 1 configuration
; 2343 :         DEBUGMSG(ZONE_PDD, (L"\tEP_TX[1]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_TX[1])));   // 00C8 - Endpoint 2 configuration
; 2344 :         DEBUGMSG(ZONE_PDD, (L"\tEP_TX[2]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_TX[2])));   // 00CC - Endpoint 3 configuration
; 2345 :         DEBUGMSG(ZONE_PDD, (L"\tEP_TX[3]   = 0x%04X\r\n", INREG32(&pPddRegs->EP_TX[3])));   // 00D0 - Endpoint 4 configuration
; 2346 :         DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2347 :     }
; 2348 : 
; 2349 : #ifdef SHOW_CONFIG_REGISTERS
; 2350 :     {
; 2351 :         PHYSICAL_ADDRESS pa;
; 2352 :         OMAP2420_SYSC1_REGS * pConfRegs;
; 2353 : 
; 2354 :         pa.QuadPart = OMAP2420_SYSC1_REGS_PA;

  00004	e3a00312	 mov         r0, #0x12, 6
  00008	e3a01000	 mov         r1, #0

; 2355 :         pConfRegs   = (OMAP2420_SYSC1_REGS*)MmMapIoSpace(pa, sizeof(OMAP2420_SYSC1_REGS), FALSE);

  0000c	e3a03000	 mov         r3, #0
  00010	e3a02fd6	 mov         r2, #0xD6, 30
  00014	eb000000	 bl          MmMapIoSpace
  00018	e3500000	 cmp         r0, #0

; 2356 : 
; 2357 :         if (pConfRegs == NULL)
; 2358 :         {
; 2359 :             DEBUGMSG(ZONE_PDD, (L"USBD PDD_Dump() - ERROR: Unable to map memory for System Control Registers\r\n"));
; 2360 :         }
; 2361 :         else
; 2362 :         {
; 2363 :             DEBUGMSG(ZONE_PDD, (L"Dump System Control Registers\r\n"));
; 2364 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_REVISION      = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_REVISION)));
; 2365 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_SYSCONFIG     = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_SYSCONFIG)));
; 2366 :             DEBUGMSG(ZONE_PDD, (L"\tPADCONF_TV_RREF       = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_PADCONF.ulPADCONF_TV_RREF)));
; 2367 :             DEBUGMSG(ZONE_PDD, (L"\tPADCONF_USB0_RCV      = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_PADCONF.ulPADCONF_USB0_RCV)));
; 2368 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_DEBOBS        = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_DEBOBS)));
; 2369 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_DEVCONF       = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_DEVCONF)));
; 2370 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_EMU_SUPPORT   = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_EMU_SUPPORT)));
; 2371 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_MSUSPENDMUX_0 = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_MSUSPENDMUX_0)));
; 2372 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_MSUSPENDMUX_1 = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_MSUSPENDMUX_1)));
; 2373 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_MSUSPENDMUX_2 = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_MSUSPENDMUX_2)));
; 2374 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_MSUSPENDMUX_3 = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_MSUSPENDMUX_3)));
; 2375 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_MSUSPENDMUX_4 = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_MSUSPENDMUX_4)));
; 2376 :             DEBUGMSG(ZONE_PDD, (L"\tCONTROL_MSUSPENDMUX_5 = 0x%08X\r\n", INREG32(&pConfRegs->ulCONTROL_MSUSPENDMUX_5)));
; 2377 :             DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2378 : 
; 2379 :             // Unmap System Control Registers
; 2380 :             MmUnmapIoSpace((VOID*)pConfRegs, sizeof(OMAP2420_SYSC1_REGS));

  0001c	13a01fd6	 movne       r1, #0xD6, 30
  00020	1b000000	 blne        MmUnmapIoSpace

; 2381 :             pConfRegs = NULL;
; 2382 :         }
; 2383 :     }
; 2384 : #endif // SHOW_CONFIG_REGISTERS
; 2385 : #ifdef SHOW_OTG_REGISTERS
; 2386 :     {
; 2387 :         PHYSICAL_ADDRESS pa;
; 2388 :         OMAP2420_OTG_REGS * pOtgRegs;
; 2389 : 
; 2390 :         pa.QuadPart = OMAP2420_OTG_REGS_PA;

  00024	e59f0020	 ldr         r0, [pc, #0x20]
  00028	e3a01000	 mov         r1, #0

; 2391 :         pOtgRegs    = (OMAP2420_OTG_REGS*)MmMapIoSpace(pa, sizeof(OMAP2420_OTG_REGS), FALSE);

  0002c	e3a03000	 mov         r3, #0
  00030	e3a02c01	 mov         r2, #1, 24
  00034	eb000000	 bl          MmMapIoSpace
  00038	e3500000	 cmp         r0, #0

; 2392 : 
; 2393 :         if (pOtgRegs == NULL)
; 2394 :         {
; 2395 :             DEBUGMSG(ZONE_PDD, (L"USBD PDD_Dump() - ERROR: Unable to map memory for USB OTG Registers\r\n"));
; 2396 :         }
; 2397 :         else
; 2398 :         {
; 2399 :             DEBUGMSG(ZONE_PDD, (L"Dump USB OTG registers\r\n"));
; 2400 :             DEBUGMSG(ZONE_PDD, (L"\tREV      = 0x%08X\r\n", INREG32(&pOtgRegs->REV)));
; 2401 :             DEBUGMSG(ZONE_PDD, (L"\tSYSCON_1 = 0x%08X\r\n", INREG32(&pOtgRegs->SYSCON_1)));
; 2402 :             DEBUGMSG(ZONE_PDD, (L"\tSYSCON_2 = 0x%08X\r\n", INREG32(&pOtgRegs->SYSCON_2)));
; 2403 :             DEBUGMSG(ZONE_PDD, (L"\tCTRL     = 0x%08X\r\n", INREG32(&pOtgRegs->CTRL)));
; 2404 :             DEBUGMSG(ZONE_PDD, (L"\tIRQ_EN   = 0x%04X\r\n", INREG32(&pOtgRegs->IRQ_EN)));
; 2405 :             DEBUGMSG(ZONE_PDD, (L"\tIRQ_SRC  = 0x%04X\r\n", INREG32(&pOtgRegs->IRQ_SRC)));
; 2406 :             DEBUGMSG(ZONE_PDD, (L"\tOUTCTRL  = 0x%04X\r\n", INREG32(&pOtgRegs->OUTCTRL)));
; 2407 :             DEBUGMSG(ZONE_PDD, (L"\tTEST     = 0x%04X\r\n", INREG32(&pOtgRegs->TEST)));
; 2408 :             DEBUGMSG(ZONE_PDD, (L"\tVC       = 0x%08X\r\n", INREG32(&pOtgRegs->VC)));
; 2409 :             DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2410 : 
; 2411 :             // Unmap USB OTG Registers
; 2412 :             MmUnmapIoSpace((VOID*)pOtgRegs, sizeof(OMAP2420_OTG_REGS));

  0003c	13a01c01	 movne       r1, #1, 24
  00040	1b000000	 blne        MmUnmapIoSpace

; 2413 :             pOtgRegs = NULL;
; 2414 :         }
; 2415 :     }
; 2416 : #endif // SHOW_OTG_REGISTERS
; 2417 : #ifdef SHOW_INTC_MPU_REGISTERS
; 2418 :     {
; 2419 :         PHYSICAL_ADDRESS pa;
; 2420 :         OMAP2420_MPUINTC_REGS * pIntcMpuRegs;
; 2421 : 
; 2422 :         pa.QuadPart  = OMAP2420_INTC_MPU_REGS_PA;
; 2423 :         pIntcMpuRegs = (OMAP2420_MPUINTC_REGS*)MmMapIoSpace(pa, sizeof(OMAP2420_MPUINTC_REGS), FALSE);
; 2424 : 
; 2425 :         if (pIntcMpuRegs == NULL)
; 2426 :         {
; 2427 :             DEBUGMSG(ZONE_PDD, (L"USBD PDD_Dump() - ERROR: Unable to map memory for INTC MPU Registers\r\n"));
; 2428 :         }
; 2429 :         else
; 2430 :         {
; 2431 :             DEBUGMSG(ZONE_PDD, (L"Dump INTC MPU Registers\r\n"));
; 2432 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_REVISION     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_REVISION)));
; 2433 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SYSCONFIG    = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_SYSCONFIG)));
; 2434 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SYSSTATUS    = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_SYSSTATUS)));
; 2435 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SIR_IRQ      = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_SIR_IRQ)));
; 2436 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SIR_FIQ      = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_SIR_FIQ)));
; 2437 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_CONTROL      = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_CONTROL)));
; 2438 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PROTECTION   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PROTECTION)));
; 2439 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_IDLE         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_IDLE)));
; 2440 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ITR0         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ITR0)));
; 2441 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR0         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR0)));
; 2442 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_CLEAR0   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR_CLEAR0)));
; 2443 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_SET0     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR_SET0)));
; 2444 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_SET0     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ISR_SET0)));
; 2445 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_CLEAR0   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ISR_CLEAR0)));
; 2446 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_IRQ0 = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PENDING_IRQ0)));
; 2447 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_FIQ0 = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PENDING_FIQ0)));
; 2448 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ITR1         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ITR1)));
; 2449 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR1         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR1)));
; 2450 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_CLEAR1   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR_CLEAR1)));
; 2451 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_SET1     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR_SET1)));
; 2452 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_SET1     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ISR_SET1)));
; 2453 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_CLEAR1   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ISR_CLEAR1)));
; 2454 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_IRQ1 = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PENDING_IRQ1)));
; 2455 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_FIQ1 = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PENDING_FIQ1)));
; 2456 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ITR2         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ITR2)));
; 2457 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR2         = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR2)));
; 2458 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_CLEAR2   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR_CLEAR2)));
; 2459 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_SET2     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_MIR_SET2)));
; 2460 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_SET2     = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ISR_SET2)));
; 2461 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_CLEAR2   = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_ISR_CLEAR2)));
; 2462 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_IRQ2 = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PENDING_IRQ2)));
; 2463 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_FIQ2 = 0x%08X\r\n", INREG32(&pIntcMpuRegs->ulINTC_PENDING_FIQ2)));
; 2464 :             DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2465 :             // Unmap INTC MPU Registers
; 2466 :             MmUnmapIoSpace((VOID*)pIntcMpuRegs, sizeof(OMAP2420_MPUINTC_REGS));
; 2467 :             pIntcMpuRegs = NULL;
; 2468 :         }
; 2469 :     }
; 2470 : #endif // SHOW_INTC_MPU_REGISTERS
; 2471 : #ifdef SHOW_INTC_IVA_REGISTERS
; 2472 :     {
; 2473 :         PHYSICAL_ADDRESS pa;
; 2474 :         OMAP2420_IVAINTC_REGS * pIntcIvaRegs;
; 2475 : 
; 2476 :         pa.QuadPart  = OMAP2420_INTC_IVA_REGS_PA;
; 2477 :         pIntcIvaRegs = (OMAP2420_IVAINTC_REGS*)MmMapIoSpace(pa, sizeof(OMAP2420_IVAINTC_REGS), FALSE);
; 2478 : 
; 2479 :         if (pIntcIvaRegs == NULL)
; 2480 :         {
; 2481 :             DEBUGMSG(ZONE_PDD, (L"USBD PDD_Dump() - ERROR: Unable to map memory for INTC IVA Registers\r\n"));
; 2482 :         }
; 2483 :         else
; 2484 :         {
; 2485 :             DEBUGMSG(ZONE_PDD, (L"Dump INTC IVA Registers\r\n"));
; 2486 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_REVISION     = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_REVISION)));
; 2487 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SYSCONFIG    = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_SYSCONFIG)));
; 2488 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SYSSTATUS    = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_SYSSTATUS)));
; 2489 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SIR_IRQ      = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_SIR_IRQ)));
; 2490 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_SIR_FIQ      = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_SIR_FIQ)));
; 2491 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_CONTROL      = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_CONTROL)));
; 2492 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PROTECTION   = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_PROTECTION)));
; 2493 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_IDLE         = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_IDLE)));
; 2494 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ITR0         = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_ITR0)));
; 2495 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR0         = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_MIR0)));
; 2496 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_CLEAR0   = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_MIR_CLEAR0)));
; 2497 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_MIR_SET0     = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_MIR_SET0)));
; 2498 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_SET0     = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_ISR_SET0)));
; 2499 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_ISR_CLEAR0   = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_ISR_CLEAR0)));
; 2500 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_IRQ0 = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_PENDING_IRQ0)));
; 2501 :             DEBUGMSG(ZONE_PDD, (L"\tINTC_PENDING_FIQ0 = 0x%08X\r\n", INREG32(&pIntcIvaRegs->ulINTC_PENDING_FIQ0)));
; 2502 :             DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2503 : 
; 2504 :             // Unmap INTC IVA Registers
; 2505 :             MmUnmapIoSpace((VOID*)pIntcIvaRegs, sizeof(OMAP2420_IVAINTC_REGS));
; 2506 :             pIntcIvaRegs = NULL;
; 2507 :         }
; 2508 :     }
; 2509 : #endif // SHOW_INTC_IVA_REGISTERS
; 2510 : 
; 2511 :     DEBUGMSG(ZONE_PDD, (L"============================================================\r\n"));
; 2512 : }

  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$LN12@PDD_Dump|
  0004c		 |$LN13@PDD_Dump|
  0004c	4805e300	 DCD         0x4805e300
  00050		 |$M45636|

			 ENDP  ; |PDD_Dump|


  00000			 AREA	 |.pdata|, PDATA
|$T45647| DCD	|$LN5@printUsbdD|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |printUsbdDriverSettings| PROC

; 2519 : {

  00000		 |$LN5@printUsbdD|
  00000		 |$M45644|

; 2520 : #ifdef DEBUG
; 2521 :     LPTSTR            defaultClientName;
; 2522 :     PLATFORMVERSION * platVer;
; 2523 :     DWORD             numBytesReturned;
; 2524 :     DWORD             infoType;
; 2525 :     DWORD             platformTypeStringMaxBytes = PLATFORM_TYPE_STRING_MAX_NUM_BYTES;
; 2526 :     DWORD             outputBufferSize;
; 2527 :     DWORD             i;
; 2528 :     DWORD             index = 0;
; 2529 :     DWORD             newStringSize      = 0;
; 2530 :     DWORD             numPlatformTypes   = 0;
; 2531 :     wchar_t         * platformTypeString = NULL;
; 2532 :     wchar_t         * platformTypes[(PLATFORM_TYPE_STRING_MAX_NUM_BYTES / sizeof(wchar_t))];
; 2533 : 
; 2534 : 
; 2535 :     DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2536 :     DEBUGMSG(ZONE_PDD, (L"----------------------------------------\r\n"));
; 2537 :     DEBUGMSG(ZONE_PDD, (L"USB Client Driver Settings\r\n"));
; 2538 :     DEBUGMSG(ZONE_PDD, (L"Built on %s at %s\r\n", TEXT(__DATE__), TEXT(__TIME__)));
; 2539 :     DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2540 : 
; 2541 : 
; 2542 :     // Get default client type
; 2543 :     defaultClientName = (LPTSTR)LocalAlloc(LPTR, MAX_LOADSTRING);
; 2544 :     if (defaultClientName)
; 2545 :     {
; 2546 :         if (GetDefaultClientName((LPTSTR)defaultClientName) == ERROR_SUCCESS)
; 2547 :         {
; 2548 :             DEBUGMSG(ZONE_PDD, (L"USBD Default Client = %s\r\n", defaultClientName));
; 2549 :         }
; 2550 :         else
; 2551 :         {
; 2552 :             DEBUGMSG(ZONE_PDD, (L"USBD Default Client = UNKNOWN\r\n"));
; 2553 :         }
; 2554 :         LocalFree((HLOCAL)defaultClientName);
; 2555 :     }
; 2556 :     else
; 2557 :     {
; 2558 :         DEBUGMSG(ZONE_PDD, (L"USBD Default Client = UNKNOWN\r\n"));
; 2559 :     }
; 2560 : 
; 2561 :     // Get the USB Device's Platform Type Array.
; 2562 :     // 32 bytes should be enough space to store the Platform Type string.
; 2563 :     platformTypeString = (wchar_t *)LocalAlloc(LPTR, platformTypeStringMaxBytes);
; 2564 :     if (platformTypeString)
; 2565 :     {
; 2566 :         infoType = SPI_GETPLATFORMTYPE;
; 2567 : 
; 2568 :         if (KernelIoControl(IOCTL_HAL_GET_DEVICE_INFO,
; 2569 :                             &infoType,
; 2570 :                             sizeof(infoType),
; 2571 :                             platformTypeString,
; 2572 :                             platformTypeStringMaxBytes,
; 2573 :                             &numBytesReturned))
; 2574 :         {
; 2575 :             for (i = 0; i < (numBytesReturned / sizeof(wchar_t)); i++)
; 2576 :             {
; 2577 :                 // Loop through platformTypeString one character at a time until we find a null string terminator
; 2578 :                 if (platformTypeString[i] == (wchar_t)'\0')
; 2579 :                 {
; 2580 :                     // If (index == i), then we have found two consecutive null string terminators.
; 2581 :                     if (i > index)
; 2582 :                     {
; 2583 :                         newStringSize = (i + 1 - index) * sizeof(wchar_t);
; 2584 : 
; 2585 :                         // Allocate a new element in platformTypes to contain the string we have found
; 2586 :                         platformTypes[numPlatformTypes] = (wchar_t *)LocalAlloc(LPTR, newStringSize);
; 2587 :                         if (platformTypes[numPlatformTypes])
; 2588 :                         {
; 2589 :                             // Extract the string from platformTypeString
; 2590 :                             // Note: Pass the number of characters (NOT including
; 2591 :                             //       the NULL terminator), not the number of bytes!
; 2592 :                             wcsncpy(platformTypes[numPlatformTypes], (platformTypeString + index), (i - index));
; 2593 :                             numPlatformTypes++;
; 2594 :                             index = i + 1;
; 2595 :                         }
; 2596 :                     }
; 2597 :                 }
; 2598 :             }
; 2599 : 
; 2600 :             // At this point, all of the strings contained in platformTypeString should have
; 2601 :             // been parsed and placed into separate elements within the platformTypes[] array.
; 2602 :             // numPlatformTypes should contain the number of platform types.
; 2603 :         }
; 2604 :         else
; 2605 :         {
; 2606 :             DEBUGMSG(ZONE_PDD, (L"USBD Platform Type String = UNKNOWN\r\n"));
; 2607 :         }
; 2608 : 
; 2609 :         LocalFree((HLOCAL)platformTypeString);
; 2610 :         platformTypeString = NULL;
; 2611 :     }
; 2612 : 
; 2613 :     if (numPlatformTypes > 0)
; 2614 :     {
; 2615 :         infoType         = SPI_GETPLATFORMVERSION;
; 2616 :         outputBufferSize = numPlatformTypes * sizeof(PLATFORMVERSION);
; 2617 : 
; 2618 :         // Get the Windows Mobile Platform Version Array.
; 2619 :         platVer = (PLATFORMVERSION *)LocalAlloc(LPTR, outputBufferSize);
; 2620 :         if (platVer)
; 2621 :         {
; 2622 :             if (KernelIoControl(IOCTL_HAL_GET_DEVICE_INFO,
; 2623 :                                 &infoType,
; 2624 :                                 sizeof(infoType),
; 2625 :                                 platVer,
; 2626 :                                 outputBufferSize,
; 2627 :                                 &numBytesReturned))
; 2628 :             {
; 2629 :                 if (outputBufferSize == numBytesReturned)
; 2630 :                 {
; 2631 :                     for (i = 0; i < numPlatformTypes; i++)
; 2632 :                     {
; 2633 :                         DEBUGMSG(ZONE_PDD, (L"USBD Platform: %s (Version %d.%d)\r\n", platformTypes[i], platVer[i].dwMajor, platVer[i].dwMinor));
; 2634 :                     }
; 2635 :                 }
; 2636 :             }
; 2637 :             LocalFree((HLOCAL)platVer);
; 2638 :             platVer = NULL;
; 2639 :         }
; 2640 :     }
; 2641 : 
; 2642 :     // Free the memory allocated for platform version strings.
; 2643 :     for (i = 0; i < numPlatformTypes; i++)
; 2644 :     {
; 2645 :         if (platformTypes[i])
; 2646 :         {
; 2647 :             LocalFree((HLOCAL)platformTypes[i]);
; 2648 :             platformTypes[i] = NULL;
; 2649 :         }
; 2650 :     }
; 2651 : 
; 2652 :     DEBUGMSG(ZONE_PDD, (L"----------------------------------------\r\n"));
; 2653 :     DEBUGMSG(ZONE_PDD, (L"\r\n"));
; 2654 : #endif
; 2655 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M45645|

			 ENDP  ; |printUsbdDriverSettings|

	EXPORT	|UfnPdd_Init|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|LocalAlloc|
	IMPORT	|InitializeHardware|

  00000			 AREA	 |.pdata|, PDATA
|$T45672| DCD	|$LN25@UfnPdd_Ini@3|
	DCD	0x4000c502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UfnPdd_Init| PROC

; 2092 : {

  00000		 |$LN25@UfnPdd_Ini@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd02c	 sub         sp, sp, #0x2C
  00008		 |$M45669|
  00008	e58d3008	 str         r3, [sp, #8]
  0000c	e58d2014	 str         r2, [sp, #0x14]
  00010	e58d1010	 str         r1, [sp, #0x10]
  00014	e1a05000	 mov         r5, r0

; 2093 :     DWORD                rc = ERROR_INVALID_PARAMETER;

  00018	e3a06057	 mov         r6, #0x57

; 2094 :     DWORD                ep;
; 2095 :     USBFN_PDD          * pPdd;
; 2096 :     OMAP2420_USBD_REGS * pUSBDRegs;
; 2097 :     PHYSICAL_ADDRESS     pa;
; 2098 : 	DWORD                irqs[5];
; 2099 : 
; 2100 : 
; 2101 :     DEBUGMSG(ZONE_INIT, (L"UfnPdd_Init() - START\r\n"));
; 2102 : 
; 2103 :     printUsbdDriverSettings();
; 2104 : 
; 2105 :     DEBUGMSG(ZONE_INIT, (L"UfnPdd_Init() - "
; 2106 :         L"Initializing Hardware...\r\n"));
; 2107 : 
; 2108 :     if (InitializeHardware() == FALSE)

  0001c	eb000000	 bl          InitializeHardware
  00020	e3500000	 cmp         r0, #0
  00024	0a00009b	 beq         |$LN22@UfnPdd_Ini@3|

; 2109 :     {
; 2110 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2111 :             L"ERROR: Hardware Initialization FAILED\r\n"));
; 2112 :         goto InitClean;
; 2113 :     }
; 2114 :     // Allocate PDD object
; 2115 :     pPdd = LocalAlloc(LPTR, sizeof(USBFN_PDD));

  00028	e3a01f5b	 mov         r1, #0x5B, 30
  0002c	e3a00040	 mov         r0, #0x40
  00030	eb000000	 bl          LocalAlloc
  00034	e1b04000	 movs        r4, r0
  00038	e58d400c	 str         r4, [sp, #0xC]

; 2116 :     if (pPdd == NULL)

  0003c	0a000099	 beq         |$LN1@UfnPdd_Ini@3|

; 2117 :     {
; 2118 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2119 :             L"ERROR: Could not allocate memory for pPdd\r\n"));
; 2120 :         goto InitClean;
; 2121 :     }
; 2122 : 
; 2123 :     // Initialize critical section
; 2124 :     InitializeCriticalSection(&pPdd->epCS);

  00040	e2840054	 add         r0, r4, #0x54
  00044	eb000000	 bl          InitializeCriticalSection

; 2125 :     pPdd->devState = 0;
; 2126 : 
; 2127 :     // Read device parameters
; 2128 :     if (GetDeviceRegistryParams(szActiveKey, pPdd, dimof(g_deviceRegParams), g_deviceRegParams) != ERROR_SUCCESS)

  00048	e59f32c0	 ldr         r3, [pc, #0x2C0]
  0004c	e3a07000	 mov         r7, #0
  00050	e3a02004	 mov         r2, #4
  00054	e1a01004	 mov         r1, r4
  00058	e1a00005	 mov         r0, r5
  0005c	e5847040	 str         r7, [r4, #0x40]
  00060	eb000000	 bl          GetDeviceRegistryParams
  00064	e3500000	 cmp         r0, #0
  00068	1a00008b	 bne         |$LN21@UfnPdd_Ini@3|

; 2129 :     {
; 2130 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2131 :             L"ERROR: Could not get Device Registry Parameters\r\n"));
; 2132 :         goto InitClean;
; 2133 :     }
; 2134 : 
; 2135 :     ASSERT(pPdd->memBase == OMAP2420_USBD_REGS_PA);
; 2136 :     ASSERT(pPdd->memLen >= sizeof(OMAP2420_USBD_REGS));
; 2137 : 
; 2138 :     pPdd->irq[0] = IRQ_USB_GEN;

  0006c	e3a0304b	 mov         r3, #0x4B

; 2139 :     pPdd->irq[1] = IRQ_USB_NISO;

  00070	e3a0204c	 mov         r2, #0x4C

; 2140 :     pPdd->irq[2] = IRQ_USB_ISO;

  00074	e3a0104d	 mov         r1, #0x4D

; 2141 : 
; 2142 :     // Set PM to Default
; 2143 :     pPdd->m_NewPowerState     = D0;
; 2144 :     pPdd->m_CurrentPowerState = D4;

  00078	e3a08004	 mov         r8, #4

; 2145 : 
; 2146 :     pPdd->hParentBus = CreateBusAccessHandle(szActiveKey);

  0007c	e1a00005	 mov         r0, r5
  00080	e584300c	 str         r3, [r4, #0xC]
  00084	e5842010	 str         r2, [r4, #0x10]
  00088	e5841014	 str         r1, [r4, #0x14]
  0008c	e584803c	 str         r8, [r4, #0x3C]
  00090	e5847038	 str         r7, [r4, #0x38]
  00094	eb000000	 bl          CreateBusAccessHandle
  00098	e3500000	 cmp         r0, #0
  0009c	e5840020	 str         r0, [r4, #0x20]

; 2147 :     if (pPdd->hParentBus == NULL)

  000a0	0a00007d	 beq         |$LN21@UfnPdd_Ini@3|

; 2148 :     {
; 2149 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2150 :             L"ERROR: pPdd->hParentBus is NULL\r\n"));
; 2151 :         goto InitClean;
; 2152 :     }
; 2153 : 
; 2154 :     // Set hardware to standby mode
; 2155 :     pPdd->m_NewPowerState = D2;

  000a4	e3a03002	 mov         r3, #2

; 2156 :     UpdateDevicePower(pPdd);

  000a8	e1a00004	 mov         r0, r4
  000ac	e5843038	 str         r3, [r4, #0x38]
  000b0	eb000000	 bl          UpdateDevicePower

; 2157 : 
; 2158 :     // Map the USB OHCI registers
; 2159 :     pa.QuadPart = pPdd->memBase;

  000b4	e5940000	 ldr         r0, [r4]

; 2160 :     pUSBDRegs = MmMapIoSpace(pa, pPdd->memLen, FALSE);

  000b8	e5942004	 ldr         r2, [r4, #4]
  000bc	e3a01000	 mov         r1, #0
  000c0	e3a03000	 mov         r3, #0
  000c4	eb000000	 bl          MmMapIoSpace
  000c8	e3500000	 cmp         r0, #0

; 2161 : 
; 2162 :     if (pUSBDRegs == NULL)

  000cc	0a000072	 beq         |$LN21@UfnPdd_Ini@3|

; 2163 :     {
; 2164 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2165 :             L"ERROR: Could not map memory for USBD Registers\r\n"));
; 2166 :         goto InitClean;
; 2167 :     }
; 2168 :     pPdd->pUSBDRegs = pUSBDRegs;
; 2169 : 
; 2170 :     DEBUGMSG((ZONE_INIT && ZONE_INTERRUPTS), (L"UfnPdd_Init() - Setting up interrupts...\r\n"));
; 2171 : 
; 2172 :     // Clear USB Interrupt enable registers
; 2173 :     OUTREG32(&pUSBDRegs->IRQ_EN, 0);

  000d0	e5840024	 str         r0, [r4, #0x24]
  000d4	e5807028	 str         r7, [r0, #0x28]

; 2174 :     OUTREG32(&pUSBDRegs->DMA_IRQ_EN, 0);
; 2175 : 
; 2176 :     // Reset all interrupts
; 2177 :     OUTREG32(&pUSBDRegs->IRQ_SRC, 0xFFFFFFFF);

  000d8	e3e01000	 mvn         r1, #0
  000dc	e580702c	 str         r7, [r0, #0x2C]
  000e0	e5801030	 str         r1, [r0, #0x30]

; 2178 : 
; 2179 :     // Disable all RX and TX EndPoints (RX 0 - 15, TX 1 - 15)
; 2180 :     OUTREG32(&pUSBDRegs->EP0, 0);

  000e4	e5807080	 str         r7, [r0, #0x80]
  000e8	e2803084	 add         r3, r0, #0x84
  000ec	e3a0200f	 mov         r2, #0xF
  000f0		 |$LL9@UfnPdd_Ini@3|

; 2181 :     for (ep = 0; ep < USBD_NONZERO_EP_COUNT; ep++)
; 2182 :     {
; 2183 :         OUTREG32(&pUSBDRegs->EP_RX[ep], 0);

  000f0	e5837000	 str         r7, [r3]

; 2184 :         OUTREG32(&pUSBDRegs->EP_TX[ep], 0);

  000f4	e5837040	 str         r7, [r3, #0x40]
  000f8	e2833004	 add         r3, r3, #4
  000fc	e2522001	 subs        r2, r2, #1
  00100	1afffffa	 bne         |$LL9@UfnPdd_Ini@3|

; 2185 :     }
; 2186 : 
; 2187 :     // Request SYSINTR for interrupts
; 2188 :     irqs[0] = -1;                   // We are using new call format
; 2189 :     irqs[1] = OAL_INTR_FORCE_STATIC;      // Mapping flags

  00104	e3a03004	 mov         r3, #4
  00108	e58d301c	 str         r3, [sp, #0x1C]
  0010c	e58d1018	 str         r1, [sp, #0x18]

; 2190 :     irqs[2] = pPdd->irq[0];         // Device state, EP0 & DMA

  00110	e594300c	 ldr         r3, [r4, #0xC]

; 2191 :     irqs[3] = pPdd->irq[1];         // Non-ISO EP
; 2192 :     irqs[4] = pPdd->irq[2];         // ISO EP
; 2193 :     pPdd->m_NewPowerState = D4;     // Assume Detached First.
; 2194 :     UpdateDevicePower(pPdd);

  00114	e1a00004	 mov         r0, r4
  00118	e58d3020	 str         r3, [sp, #0x20]
  0011c	e5943010	 ldr         r3, [r4, #0x10]
  00120	e58d3024	 str         r3, [sp, #0x24]
  00124	e5943014	 ldr         r3, [r4, #0x14]
  00128	e58d3028	 str         r3, [sp, #0x28]
  0012c	e5848038	 str         r8, [r4, #0x38]
  00130	eb000000	 bl          UpdateDevicePower

; 2195 : 
; 2196 :     DEBUGMSG((ZONE_INIT && ZONE_INTERRUPTS), (L"UfnPdd_Init() - "
; 2197 :         L"Mapping IRQs %d, %d, and %d to System Interrupt...\r\n", irqs[2], irqs[3], irqs[4]));
; 2198 :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, irqs, sizeof(irqs), &pPdd->sysIntr, sizeof(pPdd->sysIntr), NULL))

  00134	e59f01d0	 ldr         r0, [pc, #0x1D0]
  00138	e2843028	 add         r3, r4, #0x28
  0013c	e3a02014	 mov         r2, #0x14
  00140	e28d1018	 add         r1, sp, #0x18
  00144	e58d7004	 str         r7, [sp, #4]
  00148	e58d8000	 str         r8, [sp]
  0014c	eb000000	 bl          KernelIoControl
  00150	e3500000	 cmp         r0, #0
  00154	0a000050	 beq         |$LN21@UfnPdd_Ini@3|

; 2199 :     {
; 2200 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2201 :             L"ERROR: System IRQ Request FAILED\r\n"));
; 2202 :         goto InitClean;
; 2203 :     }
; 2204 :     else
; 2205 :     {
; 2206 :         DEBUGMSG((ZONE_INIT && ZONE_INTERRUPTS), (L"UfnPdd_Init() - "
; 2207 :             L"System Interrupt is 0x%08X\r\n", pPdd->sysIntr));
; 2208 :     }
; 2209 : 
; 2210 :     // Create interrupt event
; 2211 :     pPdd->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00158	e3a03000	 mov         r3, #0
  0015c	e3a02000	 mov         r2, #0
  00160	e3a01000	 mov         r1, #0
  00164	e3a00000	 mov         r0, #0
  00168	eb000000	 bl          CreateEventW
  0016c	e1b01000	 movs        r1, r0
  00170	e584102c	 str         r1, [r4, #0x2C]

; 2212 : 
; 2213 :     if (pPdd->hIntrEvent == NULL)

  00174	0a000048	 beq         |$LN21@UfnPdd_Ini@3|

; 2214 :     {
; 2215 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2216 :             L"ERROR: Could not create interrupt notification event\r\n"));
; 2217 :         goto InitClean;
; 2218 :     }
; 2219 : 
; 2220 :     DEBUGMSG((ZONE_INIT && ZONE_INTERRUPTS), (L"UfnPdd_Init() - "
; 2221 :         L"Associating Interrupt Event with System Interrupt 0x%08X...\r\n", pPdd->sysIntr));
; 2222 : 
; 2223 :     // Initialize interrupt
; 2224 :     if (!InterruptInitialize(pPdd->sysIntr, pPdd->hIntrEvent, NULL, 0))

  00178	e5940028	 ldr         r0, [r4, #0x28]
  0017c	e3a03000	 mov         r3, #0
  00180	e3a02000	 mov         r2, #0
  00184	eb000000	 bl          InterruptInitialize
  00188	e3500000	 cmp         r0, #0
  0018c	0a000042	 beq         |$LN21@UfnPdd_Ini@3|

; 2225 :     {
; 2226 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2227 :             L"ERROR: Could not initialize interrupt notification event\r\n"));
; 2228 :         goto InitClean;
; 2229 :     }
; 2230 : 
; 2231 :     // Run interrupt thread
; 2232 :     pPdd->exitIntrThread = FALSE;
; 2233 :     pPdd->hIntrThread    = CreateThread(NULL, 0, InterruptThread, pPdd, 0, NULL);

  00190	e59f2170	 ldr         r2, [pc, #0x170]
  00194	e1a03004	 mov         r3, r4
  00198	e3a01000	 mov         r1, #0
  0019c	e3a00000	 mov         r0, #0
  001a0	e5847030	 str         r7, [r4, #0x30]
  001a4	e58d7004	 str         r7, [sp, #4]
  001a8	e58d7000	 str         r7, [sp]
  001ac	eb000000	 bl          CreateThread
  001b0	e3500000	 cmp         r0, #0
  001b4	e5840034	 str         r0, [r4, #0x34]

; 2234 : 
; 2235 :     if (pPdd->hIntrThread == NULL)

  001b8	0a000037	 beq         |$LN21@UfnPdd_Ini@3|

; 2236 :     {
; 2237 :         DEBUGMSG(ZONE_ERROR, (L"UfnPdd_Init() - "
; 2238 :             L"ERROR: Could not create Interrupt Thread\r\n"));
; 2239 :         goto InitClean;
; 2240 :     }
; 2241 :     CeSetThreadPriority(pPdd->hIntrThread, pPdd->priority256);

  001bc	e5941008	 ldr         r1, [r4, #8]
  001c0	eb000000	 bl          CeSetThreadPriority

; 2242 : 
; 2243 :     // Set PDD interface
; 2244 :     pPddIfc->dwVersion         = UFN_PDD_INTERFACE_VERSION;
; 2245 :     pPddIfc->dwCapabilities    = UFN_PDD_CAPS_SUPPORTS_FULL_SPEED;
; 2246 :     pPddIfc->dwEndpointCount   = USBD_EP_COUNT;
; 2247 :     pPddIfc->pvPddContext      = pPdd;
; 2248 :     pPddIfc->pfnDeinit         = UfnPdd_Deinit;
; 2249 :     pPddIfc->pfnIsConfigurationSupportable = UfnPdd_IsConfigurationSupportable;
; 2250 :     pPddIfc->pfnIsEndpointSupportable      = UfnPdd_IsEndpointSupportable;
; 2251 :     pPddIfc->pfnInitEndpoint   = UfnPdd_InitEndpoint;
; 2252 :     pPddIfc->pfnRegisterDevice = UfnPdd_RegisterDevice;
; 2253 :     pPddIfc->pfnDeregisterDevice           = UfnPdd_DeregisterDevice;
; 2254 :     pPddIfc->pfnStart          = UfnPdd_Start;
; 2255 :     pPddIfc->pfnStop           = UfnPdd_Stop;
; 2256 :     pPddIfc->pfnIssueTransfer  = UfnPdd_IssueTransfer;
; 2257 :     pPddIfc->pfnAbortTransfer  = UfnPdd_AbortTransfer;
; 2258 :     pPddIfc->pfnDeinitEndpoint = UfnPdd_DeinitEndpoint;
; 2259 :     pPddIfc->pfnStallEndpoint  = UfnPdd_StallEndpoint;
; 2260 :     pPddIfc->pfnClearEndpointStall         = UfnPdd_ClearEndpointStall;
; 2261 :     pPddIfc->pfnSendControlStatusHandshake = UfnPdd_SendControlStatusHandshake;
; 2262 :     pPddIfc->pfnSetAddress     = UfnPdd_SetAddress;
; 2263 :     pPddIfc->pfnIsEndpointHalted           = UfnPdd_IsEndpointHalted;
; 2264 :     pPddIfc->pfnInitiateRemoteWakeup       = UfnPdd_InitiateRemoteWakeup;
; 2265 :     pPddIfc->pfnPowerDown      = UfnPdd_PowerDown;
; 2266 :     pPddIfc->pfnPowerUp        = UfnPdd_PowerUp;
; 2267 :     pPddIfc->pfnIOControl      = UfnPdd_IOControl;

  001c4	e59f3138	 ldr         r3, [pc, #0x138]
  001c8	e59d2008	 ldr         r2, [sp, #8]
  001cc	e59f112c	 ldr         r1, [pc, #0x12C]
  001d0	e59f0124	 ldr         r0, [pc, #0x124]
  001d4	e5823010	 str         r3, [r2, #0x10]
  001d8	e59f2118	 ldr         r2, [pc, #0x118]
  001dc	e59d3008	 ldr         r3, [sp, #8]
  001e0	e59fe10c	 ldr         lr, [pc, #0x10C]
  001e4	e59f4104	 ldr         r4, [pc, #0x104]
  001e8	e5832014	 str         r2, [r3, #0x14]
  001ec	e1a02003	 mov         r2, r3
  001f0	e59f30f4	 ldr         r3, [pc, #0xF4]
  001f4	e59f50ec	 ldr         r5, [pc, #0xEC]
  001f8	e59f60e4	 ldr         r6, [pc, #0xE4]
  001fc	e5823044	 str         r3, [r2, #0x44]
  00200	e59f30d8	 ldr         r3, [pc, #0xD8]
  00204	e59f70d0	 ldr         r7, [pc, #0xD0]
  00208	e59f80c8	 ldr         r8, [pc, #0xC8]
  0020c	e5823048	 str         r3, [r2, #0x48]
  00210	e59f30bc	 ldr         r3, [pc, #0xBC]
  00214	e59f90b4	 ldr         r9, [pc, #0xB4]
  00218	e59fa0ac	 ldr         r10, [pc, #0xAC]
  0021c	e582304c	 str         r3, [r2, #0x4C]
  00220	e59f30a0	 ldr         r3, [pc, #0xA0]
  00224	e59fb098	 ldr         r11, [pc, #0x98]
  00228	e5821018	 str         r1, [r2, #0x18]
  0022c	e5823050	 str         r3, [r2, #0x50]
  00230	e59f3088	 ldr         r3, [pc, #0x88]
  00234	e282c01c	 add         r12, r2, #0x1C
  00238	e88c4001	 stmia       r12, {r0, lr}
  0023c		 |$InitClean$44481|

; 2268 : 
; 2269 :     // Save MDD context & notify function
; 2270 :     pPdd->pMddContext = pMddContext;
; 2271 :     pPdd->pfnNotify   = pMddIfc->pfnNotify;
; 2272 : 
; 2273 :     // Done
; 2274 :     rc = ERROR_SUCCESS;

  0023c	e5823054	 str         r3, [r2, #0x54]
  00240	e59f3074	 ldr         r3, [pc, #0x74]
  00244	e282c024	 add         r12, r2, #0x24
  00248	e88c0ff0	 stmia       r12, {r4 - r11}
  0024c	e3a06000	 mov         r6, #0
  00250	e5823058	 str         r3, [r2, #0x58]
  00254	e59f305c	 ldr         r3, [pc, #0x5C]
  00258	e582305c	 str         r3, [r2, #0x5C]
  0025c	e3a03806	 mov         r3, #6, 16
  00260	e5823000	 str         r3, [r2]
  00264	e3a03001	 mov         r3, #1
  00268	e5823004	 str         r3, [r2, #4]
  0026c	e3a03010	 mov         r3, #0x10
  00270	e5823008	 str         r3, [r2, #8]
  00274	e59d200c	 ldr         r2, [sp, #0xC]
  00278	e59d3008	 ldr         r3, [sp, #8]
  0027c	e583200c	 str         r2, [r3, #0xC]
  00280	e59d3010	 ldr         r3, [sp, #0x10]
  00284	e5823018	 str         r3, [r2, #0x18]
  00288	e59d3014	 ldr         r3, [sp, #0x14]
  0028c	e5933004	 ldr         r3, [r3, #4]
  00290	e582301c	 str         r3, [r2, #0x1C]

; 2275 : 
; 2276 : InitClean:
; 2277 :     DEBUGMSG(ZONE_INIT, (_T("UfnPdd_Init() - END\r\n")));
; 2278 : 
; 2279 :     if ( (rc != ERROR_SUCCESS) && (pPdd != NULL) )

  00294	ea000003	 b           |$LN1@UfnPdd_Ini@3|
  00298		 |$LN22@UfnPdd_Ini@3|
  00298	e59d4014	 ldr         r4, [sp, #0x14]
  0029c		 |$LN21@UfnPdd_Ini@3|
  0029c	e3540000	 cmp         r4, #0

; 2280 :     {
; 2281 :             LocalFree(pPdd);

  002a0	11a00004	 movne       r0, r4
  002a4	1b000000	 blne        LocalFree
  002a8		 |$LN1@UfnPdd_Ini@3|

; 2282 :     }
; 2283 : 
; 2284 :     return rc;
; 2285 : }

  002a8	e1a00006	 mov         r0, r6
  002ac	e28dd02c	 add         sp, sp, #0x2C
  002b0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002b4	e12fff1e	 bx          lr
  002b8		 |$LN26@UfnPdd_Ini@3|
  002b8		 |$LN27@UfnPdd_Ini@3|
  002b8	00000000	 DCD         |UfnPdd_IOControl|
  002bc		 |$LN28@UfnPdd_Ini@3|
  002bc	00000000	 DCD         |UfnPdd_PowerUp|
  002c0		 |$LN29@UfnPdd_Ini@3|
  002c0	00000000	 DCD         |UfnPdd_PowerDown|
  002c4		 |$LN30@UfnPdd_Ini@3|
  002c4	00000000	 DCD         |UfnPdd_ClearEndpointStall|
  002c8		 |$LN31@UfnPdd_Ini@3|
  002c8	00000000	 DCD         |UfnPdd_InitiateRemoteWakeup|
  002cc		 |$LN32@UfnPdd_Ini@3|
  002cc	00000000	 DCD         |UfnPdd_StallEndpoint|
  002d0		 |$LN33@UfnPdd_Ini@3|
  002d0	00000000	 DCD         |UfnPdd_DeinitEndpoint|
  002d4		 |$LN34@UfnPdd_Ini@3|
  002d4	00000000	 DCD         |UfnPdd_IsEndpointHalted|
  002d8		 |$LN35@UfnPdd_Ini@3|
  002d8	00000000	 DCD         |UfnPdd_AbortTransfer|
  002dc		 |$LN36@UfnPdd_Ini@3|
  002dc	00000000	 DCD         |UfnPdd_IssueTransfer|
  002e0		 |$LN37@UfnPdd_Ini@3|
  002e0	00000000	 DCD         |UfnPdd_SetAddress|
  002e4		 |$LN38@UfnPdd_Ini@3|
  002e4	00000000	 DCD         |UfnPdd_Stop|
  002e8		 |$LN39@UfnPdd_Ini@3|
  002e8	00000000	 DCD         |UfnPdd_Start|
  002ec		 |$LN40@UfnPdd_Ini@3|
  002ec	00000000	 DCD         |UfnPdd_SendControlStatusHandshake|
  002f0		 |$LN41@UfnPdd_Ini@3|
  002f0	00000000	 DCD         |UfnPdd_DeregisterDevice|
  002f4		 |$LN42@UfnPdd_Ini@3|
  002f4	00000000	 DCD         |UfnPdd_RegisterDevice|
  002f8		 |$LN43@UfnPdd_Ini@3|
  002f8	00000000	 DCD         |UfnPdd_IsConfigurationSupportable|
  002fc		 |$LN44@UfnPdd_Ini@3|
  002fc	00000000	 DCD         |UfnPdd_InitEndpoint|
  00300		 |$LN45@UfnPdd_Ini@3|
  00300	00000000	 DCD         |UfnPdd_IsEndpointSupportable|
  00304		 |$LN46@UfnPdd_Ini@3|
  00304	00000000	 DCD         |UfnPdd_Deinit|
  00308		 |$LN47@UfnPdd_Ini@3|
  00308	00000000	 DCD         |InterruptThread|
  0030c		 |$LN48@UfnPdd_Ini@3|
  0030c	01010098	 DCD         0x1010098
  00310		 |$LN49@UfnPdd_Ini@3|
  00310	00000000	 DCD         |g_deviceRegParams|
  00314		 |$M45670|

			 ENDP  ; |UfnPdd_Init|

	END
