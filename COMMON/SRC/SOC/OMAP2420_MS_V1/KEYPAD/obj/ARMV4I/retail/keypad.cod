; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\KEYPAD\keypad.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@CLLAOEB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@IJOLEABA@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA4?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@BEDMHIKJ@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA3?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@KMIABPMM@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA2?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@LODFLACC@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA1?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@GIJNHEH@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA0?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|g_deviceRegParams| DCD |??_C@_1BA@GIJNHEH@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA0?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0xc
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BA@LODFLACC@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA1?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x10
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BA@KMIABPMM@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA2?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x14
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BA@BEDMHIKJ@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA3?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x18
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BA@IJOLEABA@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA4?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x1c
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x20
	DCD	0x4
	DCD	0x64
	DCD	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x24
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x28
	DCD	0x4
	DCD	0x28
	DCD	|??_C@_1BK@CLLAOEB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x2c
	DCD	0x4
	DCD	0x50
	DCD	|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x30
	DCD	0x4
	DCD	0x1f4
	DCD	|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x34
	DCD	0x4
	DCD	0x7d

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| DCB "N"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, "R", 0x0, "e", 0x0, "p"
	DCB	0x0, "e", 0x0, "a", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| DCB "F"
	DCB	0x0, "i", 0x0, "r", 0x0, "s", 0x0, "t", 0x0, "R", 0x0, "e"
	DCB	0x0, "p", 0x0, "e", 0x0, "a", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@CLLAOEB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "b", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "c"
	DCB	0x0, "e", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@| DCB "S"
	DCB	0x0, "a", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "P"
	DCB	0x0, "e", 0x0, "r", 0x0, "i", 0x0, "o", 0x0, "d", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| DCB "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@IJOLEABA@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA4?$AA?$AA@| DCB "I", 0x0
	DCB	"r", 0x0, "q", 0x0, "R", 0x0, "o", 0x0, "w", 0x0, "4", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@BEDMHIKJ@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA3?$AA?$AA@| DCB "I", 0x0
	DCB	"r", 0x0, "q", 0x0, "R", 0x0, "o", 0x0, "w", 0x0, "3", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@KMIABPMM@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA2?$AA?$AA@| DCB "I", 0x0
	DCB	"r", 0x0, "q", 0x0, "R", 0x0, "o", 0x0, "w", 0x0, "2", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@LODFLACC@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA1?$AA?$AA@| DCB "I", 0x0
	DCB	"r", 0x0, "q", 0x0, "R", 0x0, "o", 0x0, "w", 0x0, "1", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@GIJNHEH@?$AAI?$AAr?$AAq?$AAR?$AAo?$AAw?$AA0?$AA?$AA@| DCB "I", 0x0
	DCB	"r", 0x0, "q", 0x0, "R", 0x0, "o", 0x0, "w", 0x0, "0", 0x0
	DCB	0x0, 0x0				; `string'
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43283| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43280|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43281|

			 ENDP  ; |SetEvent|

	EXPORT	|KPD_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseHandle|
	IMPORT	|KernelIoControl|
	IMPORT	|InterruptDisable|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T43298| DCD	|$LN16@KPD_Deinit|
	DCD	0x40005102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\keypad\keypad.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Deinit| PROC

; 330  : {

  00000		 |$LN16@KPD_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43295|
  00008	e1b04000	 movs        r4, r0

; 331  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 332  :     KPD_DEVICE *pDevice = (KPD_DEVICE*)context;
; 333  : 
; 334  : 
; 335  :     DEBUGMSG(ZONE_FUNCTION, (L"+KPD_Deinit(0x%08x)\r\n", context));
; 336  : 
; 337  :     // Check if we get correct context
; 338  :     if (pDevice == NULL || pDevice->cookie != KPD_DEVICE_COOKIE) {

  00010	0a000046	 beq         |$cleanUp$42928|
  00014	e5942000	 ldr         r2, [r4]
  00018	e59f3120	 ldr         r3, [pc, #0x120]
  0001c	e1520003	 cmp         r2, r3
  00020	1a000042	 bne         |$cleanUp$42928|

; 339  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Deinit: "
; 340  :             L"Incorrect context parameter\r\n"
; 341  :         ));
; 342  :         goto cleanUp;
; 343  :     }
; 344  : 
; 345  :     // Close interrupt thread
; 346  :     if (pDevice->hIntrThread != NULL) {

  00024	e5943064	 ldr         r3, [r4, #0x64]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000007	 beq         |$LN7@KPD_Deinit|

; 347  :         // Signal stop to thread
; 348  :         pDevice->intrThreadExit = TRUE;
; 349  :         // Set event to wake it
; 350  :         SetEvent(pDevice->hIntrEvent);

  00030	e5940060	 ldr         r0, [r4, #0x60]
  00034	e3a03001	 mov         r3, #1
  00038	e3a01003	 mov         r1, #3
  0003c	e5843068	 str         r3, [r4, #0x68]
  00040	eb000000	 bl          EventModify

; 351  :         // Wait until thread exits
; 352  :         WaitForSingleObject(pDevice->hIntrThread, INFINITE);

  00044	e5940064	 ldr         r0, [r4, #0x64]
  00048	e3e01000	 mvn         r1, #0
  0004c	eb000000	 bl          WaitForSingleObject
  00050		 |$LN7@KPD_Deinit|

; 353  :     }
; 354  : 
; 355  :     // Unmap GPIO controller registers
; 356  :         // Set all output columns to ones
; 357  :         // Ie, drive all the column GPIO's
; 358  : 
; 359  :         // Mask keyboard interrupts
; 360  :         // Unmap registers
; 361  :     if (pDevice->pGPIO1Regs != NULL)

  00050	e594304c	 ldr         r3, [r4, #0x4C]
  00054	e3530000	 cmp         r3, #0

; 362  :     {
; 363  :         OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_SETDATAOUT, 1<<15);    // column 2 = Drive GPIO15

  00058	13a02902	 movne       r2, #2, 18
  0005c	15832094	 strne       r2, [r3, #0x94]

; 364  :         OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_SETDATAOUT, 1<<12);    // column 4 = Drive GPIO12

  00060	1594304c	 ldrne       r3, [r4, #0x4C]
  00064	13a02a01	 movne       r2, #1, 20

; 365  :         MmUnmapIoSpace((VOID*)pDevice->pGPIO1Regs, sizeof(OMAP2420_GPIO_REGS));

  00068	13a01098	 movne       r1, #0x98
  0006c	15832094	 strne       r2, [r3, #0x94]
  00070	1594004c	 ldrne       r0, [r4, #0x4C]
  00074	1b000000	 blne        MmUnmapIoSpace

; 366  :     }
; 367  : 
; 368  :     if (pDevice->pGPIO2Regs != NULL)

  00078	e5943050	 ldr         r3, [r4, #0x50]
  0007c	e3530000	 cmp         r3, #0

; 369  :     {
; 370  :         OUTREG32(&pDevice->pGPIO2Regs->ulGPIO_SETDATAOUT, 1<<4);     // column 3 = Drive GPIO36

  00080	13a02010	 movne       r2, #0x10
  00084	15832094	 strne       r2, [r3, #0x94]

; 371  :         MmUnmapIoSpace((VOID*)pDevice->pGPIO2Regs, sizeof(OMAP2420_GPIO_REGS));

  00088	15940050	 ldrne       r0, [r4, #0x50]
  0008c	13a01098	 movne       r1, #0x98
  00090	1b000000	 blne        MmUnmapIoSpace

; 372  :     }
; 373  : 
; 374  :     if (pDevice->pGPIO3Regs != NULL)

  00094	e5943054	 ldr         r3, [r4, #0x54]
  00098	e3530000	 cmp         r3, #0

; 375  :     {
; 376  :         OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_SETDATAOUT, 1<<26);    // column 0 = Drive GPIO90

  0009c	13a02301	 movne       r2, #1, 6
  000a0	15832094	 strne       r2, [r3, #0x94]

; 377  :         OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_SETDATAOUT, 1<<27);    // column 1 = Drive GPIO91

  000a4	15943054	 ldrne       r3, [r4, #0x54]
  000a8	13a02302	 movne       r2, #2, 6

; 378  :         MmUnmapIoSpace((VOID*)pDevice->pGPIO3Regs, sizeof(OMAP2420_GPIO_REGS));

  000ac	13a01098	 movne       r1, #0x98
  000b0	15832094	 strne       r2, [r3, #0x94]
  000b4	15940054	 ldrne       r0, [r4, #0x54]
  000b8	1b000000	 blne        MmUnmapIoSpace

; 379  :     }
; 380  : 
; 381  :     if (pDevice->pGPIO4Regs != NULL)

  000bc	e5943058	 ldr         r3, [r4, #0x58]
  000c0	e3530000	 cmp         r3, #0

; 382  :     {
; 383  :         OUTREG32(&pDevice->pGPIO4Regs->ulGPIO_SETDATAOUT, 1<<1);     // column 5 = Drive GPIO97

  000c4	13a02002	 movne       r2, #2
  000c8	15832094	 strne       r2, [r3, #0x94]

; 384  :         MmUnmapIoSpace((VOID*)pDevice->pGPIO4Regs, sizeof(OMAP2420_GPIO_REGS));

  000cc	15940058	 ldrne       r0, [r4, #0x58]
  000d0	13a01098	 movne       r1, #0x98
  000d4	1b000000	 blne        MmUnmapIoSpace

; 385  :     }
; 386  : 
; 387  :     // Disable interrupt
; 388  :     if (pDevice->sysIntr != 0) {

  000d8	e594305c	 ldr         r3, [r4, #0x5C]
  000dc	e3530000	 cmp         r3, #0
  000e0	0a000009	 beq         |$LN2@KPD_Deinit|

; 389  :         InterruptDisable(pDevice->sysIntr);

  000e4	e1a00003	 mov         r0, r3
  000e8	eb000000	 bl          InterruptDisable

; 390  :         KernelIoControl(
; 391  :             IOCTL_HAL_RELEASE_SYSINTR, &pDevice->sysIntr,
; 392  :             sizeof(pDevice->sysIntr), NULL, 0, NULL
; 393  :         );

  000ec	e59f0048	 ldr         r0, [pc, #0x48]
  000f0	e3a0e000	 mov         lr, #0
  000f4	e3a03000	 mov         r3, #0
  000f8	e3a02004	 mov         r2, #4
  000fc	e284105c	 add         r1, r4, #0x5C
  00100	e58de004	 str         lr, [sp, #4]
  00104	e58de000	 str         lr, [sp]
  00108	eb000000	 bl          KernelIoControl
  0010c		 |$LN2@KPD_Deinit|

; 394  :     }
; 395  : 
; 396  :     // Close interrupt handler
; 397  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  0010c	e5943060	 ldr         r3, [r4, #0x60]
  00110	e3530000	 cmp         r3, #0
  00114	11a00003	 movne       r0, r3
  00118	1b000000	 blne        CloseHandle

; 398  : 
; 399  :     // Delete critical section
; 400  :     DeleteCriticalSection(&pDevice->cs);

  0011c	e2840038	 add         r0, r4, #0x38
  00120	eb000000	 bl          DeleteCriticalSection

; 401  : 
; 402  :     // Free device structure
; 403  :     LocalFree(pDevice);

  00124	e1a00004	 mov         r0, r4
  00128	eb000000	 bl          LocalFree

; 404  : 
; 405  :     // Done
; 406  :     rc = TRUE;

  0012c	e3a00001	 mov         r0, #1
  00130		 |$cleanUp$42928|

; 407  : 
; 408  : cleanUp:
; 409  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_Deinit(rc = %d)\r\n", rc));
; 410  :     return rc;
; 411  : }

  00130	e28dd008	 add         sp, sp, #8
  00134	e8bd4010	 ldmia       sp!, {r4, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$LN17@KPD_Deinit|
  0013c		 |$LN18@KPD_Deinit|
  0013c	010100d8	 DCD         0x10100d8
  00140		 |$LN19@KPD_Deinit|
  00140	6b706444	 DCD         0x6b706444
  00144		 |$M43296|

			 ENDP  ; |KPD_Deinit|

	EXPORT	|KPD_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T43311| DCD	|$LN5@KPD_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Open| PROC

; 420  : {

  00000		 |$LN5@KPD_Open|
  00000		 |$M43308|

; 421  :     return context;
; 422  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43309|

			 ENDP  ; |KPD_Open|

	EXPORT	|KPD_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T43320| DCD	|$LN5@KPD_Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Close| PROC

; 431  : {

  00000		 |$LN5@KPD_Close|
  00000		 |$M43317|

; 432  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 433  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43318|

			 ENDP  ; |KPD_Close|

	EXPORT	|KPD_IOControl|

  00000			 AREA	 |.pdata|, PDATA
|$T43329| DCD	|$LN5@KPD_IOCont|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_IOControl| PROC

; 444  : ) {

  00000		 |$LN5@KPD_IOCont|
  00000		 |$M43326|

; 445  :     DEBUGMSG(ZONE_INIT, (L"KPD_IOControl"));
; 446  :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 447  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43327|

			 ENDP  ; |KPD_IOControl|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|InterruptDone|
	IMPORT	|PowerPolicyNotify|
	IMPORT	|keybd_event|
	IMPORT	|GetTickCount|
	IMPORT	|Sleep|
	IMPORT	|g_keypadRepeat|
	IMPORT	|LocalAlloc|
	IMPORT	|g_keypadRemap|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|g_keypadVK|
	IMPORT	|__security_cookie|
	IMPORT	|memcpy|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T43430| DCD	|$LN145@KPD_IntrTh|
	DCD	0xc0022e02

  00000			 AREA	 |.xdata|, DATA
|$T43426| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43426|

  00008		 |KPD_IntrThread| PROC

; 456  : {

  00008		 |$LN145@KPD_IntrTh|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd070	 sub         sp, sp, #0x70
  00010		 |$M43427|
  00010	e1a0b000	 mov         r11, r0
  00014	e58db018	 str         r11, [sp, #0x18]
  00018	e59f389c	 ldr         r3, [pc, #0x89C]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d306c	 str         r3, [sp, #0x6C]

; 457  :     KPD_DEVICE *pDevice = (KPD_DEVICE*)pContext;
; 458  :     DWORD timeout, time, ix;
; 459  :     DWORD change, mask;
; 460  :     UINT16 ir, ik;
; 461  :     USHORT data[KEYPAD_COLUMNS];
; 462  :     UINT16 ic=0;
; 463  :     DWORD vkState[VK_KEYS/DWORD_BITS], vkNewState[VK_KEYS/DWORD_BITS];
; 464  :     KEYPAD_REMAP_STATE *pRemapState = NULL;
; 465  :     KEYPAD_REPEAT_STATE *pRepeatState = NULL;
; 466  :     BOOL keyDown;
; 467  :     UCHAR vk;
; 468  : 
; 469  :     DEBUGMSG(ZONE_IST, (L"KPD - Start IntrThread\r\n"));
; 470  : 
; 471  :     // Init data
; 472  :     memset(vkState, 0, sizeof(vkState));

  00024	e3a08000	 mov         r8, #0
  00028	e3a03000	 mov         r3, #0
  0002c	e3a02020	 mov         r2, #0x20
  00030	e3a01000	 mov         r1, #0
  00034	e28d0040	 add         r0, sp, #0x40
  00038	e58d8010	 str         r8, [sp, #0x10]
  0003c	e58d300c	 str         r3, [sp, #0xC]
  00040	eb000000	 bl          memset

; 473  : 
; 474  :     // Initialize remap informations
; 475  :     if (g_keypadRemap.count > 0) {

  00044	e59f9864	 ldr         r9, [pc, #0x864]
  00048	e1d930b0	 ldrh        r3, [r9]
  0004c	e3530000	 cmp         r3, #0
  00050	0a000005	 beq         |$LN93@KPD_IntrTh|

; 476  :         // Allocate state structure for remap
; 477  :         if ((pRemapState = LocalAlloc(
; 478  :             LPTR, g_keypadRemap.count * sizeof(KEYPAD_REMAP_STATE)
; 479  :         ))  == NULL) {

  00054	e1a01203	 mov         r1, r3, lsl #4
  00058	e3a00040	 mov         r0, #0x40
  0005c	eb000000	 bl          LocalAlloc
  00060	e1b08000	 movs        r8, r0
  00064	e58d8010	 str         r8, [sp, #0x10]
  00068	0a00020a	 beq         |$LN1@KPD_IntrTh|
  0006c		 |$LN93@KPD_IntrTh|

; 480  :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 481  :                 L"Failed allocate memory for virtual key remap\r\n"
; 482  :             ));
; 483  :             goto cleanUp;
; 484  :         }
; 485  :     }
; 486  : 
; 487  :     // Initialize repeat informations
; 488  :     if (g_keypadRepeat.count > 0) {

  0006c	e59f5840	 ldr         r5, [pc, #0x840]
  00070	e1d530b0	 ldrh        r3, [r5]
  00074	e3530000	 cmp         r3, #0
  00078	0a000006	 beq         |$LN91@KPD_IntrTh|

; 489  :         // Allocate state structure for remap
; 490  :         if ((pRepeatState = LocalAlloc(
; 491  :             LPTR, g_keypadRepeat.count * sizeof(KEYPAD_REPEAT_STATE)
; 492  :         ))  == NULL) {

  0007c	e0833083	 add         r3, r3, r3, lsl #1
  00080	e1a01103	 mov         r1, r3, lsl #2
  00084	e3a00040	 mov         r0, #0x40
  00088	eb000000	 bl          LocalAlloc
  0008c	e1b04000	 movs        r4, r0
  00090	e58d400c	 str         r4, [sp, #0xC]
  00094	0a0001f9	 beq         |$cleanUp$43028|
  00098		 |$LN91@KPD_IntrTh|

; 493  :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 494  :                 L"Failed allocate memory for virtual key auto repeat\r\n"
; 495  :             ));
; 496  :             goto cleanUp;
; 497  :         }
; 498  :     }
; 499  : 
; 500  :     // Set delay to sample period
; 501  :     timeout = INFINITE;
; 502  : 
; 503  :     // Loop until we are not stopped...
; 504  :     while (!pDevice->intrThreadExit) {

  00098	e59b3068	 ldr         r3, [r11, #0x68]
  0009c	e3e04000	 mvn         r4, #0
  000a0	e3530000	 cmp         r3, #0
  000a4	1a0001f4	 bne         |$LN132@KPD_IntrTh|
  000a8		 |$LN142@KPD_IntrTh|
  000a8	e28d7060	 add         r7, sp, #0x60
  000ac	e28d6060	 add         r6, sp, #0x60
  000b0	e28d5060	 add         r5, sp, #0x60
  000b4	e28da060	 add         r10, sp, #0x60

; 505  : 
; 506  :         if (pDevice->intrThreadExit) break;

  000b8	e3530000	 cmp         r3, #0
  000bc	1a0001ee	 bne         |$LN132@KPD_IntrTh|

; 507  : 
; 508  :         keyDown = FALSE;
; 509  :         // Wait for event
; 510  :         WaitForSingleObject(pDevice->hIntrEvent, timeout);

  000c0	e59b0060	 ldr         r0, [r11, #0x60]
  000c4	e1a01004	 mov         r1, r4
  000c8	eb000000	 bl          WaitForSingleObject

; 511  :         Sleep(5); //settle time

  000cc	e3a00005	 mov         r0, #5
  000d0	eb000000	 bl          Sleep

; 512  : 
; 513  :         memset(data, 0, sizeof(data));

  000d4	e3a0200c	 mov         r2, #0xC
  000d8	e3a01000	 mov         r1, #0
  000dc	e28d0060	 add         r0, sp, #0x60
  000e0	eb000000	 bl          memset

; 514  :         for (ic=0; ic < KEYPAD_COLUMNS; ic++)

  000e4	e3a00000	 mov         r0, #0
  000e8	e3a01000	 mov         r1, #0
  000ec	e28d9060	 add         r9, sp, #0x60
  000f0	e3a04902	 mov         r4, #2, 18
  000f4		 |$LL87@KPD_IntrTh|

; 515  :         {
; 516  :             // Don't drive any column GPIO's
; 517  :             OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_SETDATAOUT, 1<<26);    // column 0 = Drive GPIO90

  000f4	e59b3054	 ldr         r3, [r11, #0x54]

; 518  :             OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_SETDATAOUT, 1<<27);    // column 1 = Drive GPIO91
; 519  :             OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_SETDATAOUT, 1<<15);    // column 2 = Drive GPIO15
; 520  :             OUTREG32(&pDevice->pGPIO2Regs->ulGPIO_SETDATAOUT, 1<<4);     // column 3 = Drive GPIO36
; 521  :             OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_SETDATAOUT, 1<<12);    // column 4 = Drive GPIO12
; 522  :             OUTREG32(&pDevice->pGPIO4Regs->ulGPIO_SETDATAOUT, 1<<1);     // column 5 = Drive GPIO97
; 523  : 
; 524  :             // Ie, drive all the column GPIO's in turn
; 525  :             if (ic == 0)

  000f8	e3a02301	 mov         r2, #1, 6
  000fc	e3a0e302	 mov         lr, #2, 6
  00100	e5832094	 str         r2, [r3, #0x94]
  00104	e59b3054	 ldr         r3, [r11, #0x54]
  00108	e3a07010	 mov         r7, #0x10
  0010c	e3a06002	 mov         r6, #2
  00110	e583e094	 str         lr, [r3, #0x94]
  00114	e59b304c	 ldr         r3, [r11, #0x4C]
  00118	e3510000	 cmp         r1, #0
  0011c	e5834094	 str         r4, [r3, #0x94]
  00120	e59b3050	 ldr         r3, [r11, #0x50]
  00124	e5837094	 str         r7, [r3, #0x94]
  00128	e59b304c	 ldr         r3, [r11, #0x4C]
  0012c	e3a07a01	 mov         r7, #1, 20
  00130	e5837094	 str         r7, [r3, #0x94]
  00134	e59b3058	 ldr         r3, [r11, #0x58]
  00138	e5836094	 str         r6, [r3, #0x94]

; 526  :                 OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_CLEARDATAOUT, 1<<26);    // column 0 = Drive GPIO90

  0013c	059b3054	 ldreq       r3, [r11, #0x54]
  00140	0a000013	 beq         |$LN135@KPD_IntrTh|

; 527  :             else if (ic == 1)

  00144	e3510001	 cmp         r1, #1

; 528  :                 OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_CLEARDATAOUT, 1<<27);    // column 1 = Drive GPIO91

  00148	059b3054	 ldreq       r3, [r11, #0x54]
  0014c	0583e090	 streq       lr, [r3, #0x90]
  00150	0a000010	 beq         |$LN74@KPD_IntrTh|

; 529  :             else if (ic == 2)

  00154	e3510002	 cmp         r1, #2

; 530  :                 OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_CLEARDATAOUT, 1<<15);    // column 2 = Drive GPIO15

  00158	059b304c	 ldreq       r3, [r11, #0x4C]
  0015c	05834090	 streq       r4, [r3, #0x90]
  00160	0a00000c	 beq         |$LN74@KPD_IntrTh|

; 531  :             else if (ic == 3)

  00164	e3510003	 cmp         r1, #3

; 532  :                 OUTREG32(&pDevice->pGPIO2Regs->ulGPIO_CLEARDATAOUT, 1<<4);     // column 3 = Drive GPIO36

  00168	059b3050	 ldreq       r3, [r11, #0x50]
  0016c	03a02010	 moveq       r2, #0x10
  00170	0a000007	 beq         |$LN135@KPD_IntrTh|

; 533  :             else if (ic == 4)

  00174	e3510004	 cmp         r1, #4

; 534  :                 OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_CLEARDATAOUT, 1<<12);    // column 4 = Drive GPIO12

  00178	059b304c	 ldreq       r3, [r11, #0x4C]
  0017c	05837090	 streq       r7, [r3, #0x90]
  00180	0a000004	 beq         |$LN74@KPD_IntrTh|

; 535  :             else if (ic == 5)

  00184	e3510005	 cmp         r1, #5
  00188	1a000002	 bne         |$LN74@KPD_IntrTh|

; 536  :                 OUTREG32(&pDevice->pGPIO4Regs->ulGPIO_CLEARDATAOUT, 1<<1);     // column 5 = Drive GPIO97

  0018c	e59b3058	 ldr         r3, [r11, #0x58]
  00190	e3a02002	 mov         r2, #2
  00194		 |$LN135@KPD_IntrTh|
  00194	e5832090	 str         r2, [r3, #0x90]
  00198		 |$LN74@KPD_IntrTh|

; 537  : 
; 538  :             // Get row status
; 539  :             if ((INREG32(&pDevice->pGPIO3Regs->ulGPIO_DATAIN) & (1<<24)) == 0) // row 0 GPIO 88

  00198	e59be054	 ldr         lr, [r11, #0x54]
  0019c	e28d6060	 add         r6, sp, #0x60
  001a0	e28d7060	 add         r7, sp, #0x60
  001a4	e59e3038	 ldr         r3, [lr, #0x38]
  001a8	e3130401	 tst         r3, #1, 8

; 540  :             {
; 541  :                 DEBUGMSG(ZONE_INFO, (L"Row 0 detected when column #%d driven. \r\n", ic));
; 542  :                 data[ic] |= 1;

  001ac	008a2080	 addeq       r2, r10, r0, lsl #1
  001b0	01d230b0	 ldreqh      r3, [r2]
  001b4	03833001	 orreq       r3, r3, #1
  001b8	01c230b0	 streqh      r3, [r2]

; 543  :             }
; 544  :             if ((INREG32(&pDevice->pGPIO3Regs->ulGPIO_DATAIN) & (1<<25)) == 0) // row 1 GPIO 89

  001bc	e59e3038	 ldr         r3, [lr, #0x38]

; 545  :             {
; 546  :                 DEBUGMSG(ZONE_INFO, (L"Row 1 detected when column #%d driven.\r\n", ic));
; 547  :                 data[ic] |= 1 << 1;
; 548  :             }
; 549  :             if ((INREG32(&pDevice->pGPIO4Regs->ulGPIO_DATAIN) & (1<<28)) == 0) // row 2 GPIO 124
; 550  :             {
; 551  :                 DEBUGMSG(ZONE_INFO, (L"Row 2 detected when column #%d driven.\r\n", ic));
; 552  :                 data[ic] |= 1 << 2;
; 553  :             }
; 554  :             if ((INREG32(&pDevice->pGPIO1Regs->ulGPIO_DATAIN) & (1<<11)) == 0) // row 3 GPIO 11

  001c0	e59be04c	 ldr         lr, [r11, #0x4C]
  001c4	e3130402	 tst         r3, #2, 8
  001c8	00852080	 addeq       r2, r5, r0, lsl #1
  001cc	01d230b0	 ldreqh      r3, [r2]
  001d0	03833002	 orreq       r3, r3, #2
  001d4	01c230b0	 streqh      r3, [r2]
  001d8	e59b3058	 ldr         r3, [r11, #0x58]
  001dc	e5933038	 ldr         r3, [r3, #0x38]
  001e0	e3130201	 tst         r3, #1, 4
  001e4	00862080	 addeq       r2, r6, r0, lsl #1
  001e8	01d230b0	 ldreqh      r3, [r2]
  001ec	03833004	 orreq       r3, r3, #4
  001f0	01c230b0	 streqh      r3, [r2]
  001f4	e59e3038	 ldr         r3, [lr, #0x38]
  001f8	e3130b02	 tst         r3, #2, 22

; 555  :             {
; 556  :                 DEBUGMSG(ZONE_INFO, (L"Row 3 detected when column #%d driven.\r\n", ic));
; 557  :                 data[ic] |= 1 << 3;

  001fc	00892080	 addeq       r2, r9, r0, lsl #1
  00200	01d230b0	 ldreqh      r3, [r2]
  00204	03833008	 orreq       r3, r3, #8
  00208	01c230b0	 streqh      r3, [r2]

; 558  :             }
; 559  :             if ((INREG32(&pDevice->pGPIO1Regs->ulGPIO_DATAIN) & (1<<6)) == 0) // row 4 GPIO 6

  0020c	e59e3038	 ldr         r3, [lr, #0x38]
  00210	e3130040	 tst         r3, #0x40

; 560  :             {
; 561  :                 DEBUGMSG(ZONE_INFO, (L"Row 4 detected when column #%d driven.\r\n", ic));
; 562  :                 data[ic] |= 1 << 4;

  00214	00872080	 addeq       r2, r7, r0, lsl #1
  00218	01d230b0	 ldreqh      r3, [r2]
  0021c	03833010	 orreq       r3, r3, #0x10
  00220	01c230b0	 streqh      r3, [r2]
  00224	e2813001	 add         r3, r1, #1
  00228	e1a00803	 mov         r0, r3, lsl #16
  0022c	e1a00820	 mov         r0, r0, lsr #16
  00230	e1a01000	 mov         r1, r0
  00234	e3500006	 cmp         r0, #6
  00238	3affffad	 bcc         |$LL87@KPD_IntrTh|

; 563  :             }
; 564  :         } // for loop
; 565  : 
; 566  : //      data[0] = ~data[0];
; 567  : //      data[1] = ~data[1];
; 568  : //      data[2] = ~data[2];
; 569  : //      data[3] = ~data[3];
; 570  : //      data[4] = ~data[4];
; 571  : //      data[5] = ~data[5];
; 572  :         //--------------------------------------------------------------
; 573  :         // Convert physical state to virtual keys state
; 574  :         //--------------------------------------------------------------
; 575  :         // Get new state for virtual key table
; 576  :         memset(vkNewState, 0, sizeof(vkNewState));

  0023c	e3a02020	 mov         r2, #0x20
  00240	e3a01000	 mov         r1, #0
  00244	e28d0020	 add         r0, sp, #0x20
  00248	eb000000	 bl          memset

; 577  :         keyDown = FALSE;

  0024c	e3a07000	 mov         r7, #0
  00250	e59f9658	 ldr         r9, [pc, #0x658]
  00254	e58d7008	 str         r7, [sp, #8]

; 578  :         for (ic = 0, ik = 0; ic < KEYPAD_COLUMNS; ic++) {

  00258	e3a03000	 mov         r3, #0
  0025c	e3a0e000	 mov         lr, #0
  00260	e3a06000	 mov         r6, #0
  00264	e28d8060	 add         r8, sp, #0x60
  00268	e3a0b001	 mov         r11, #1
  0026c		 |$LL68@KPD_IntrTh|

; 579  :             data[ic] = ~data[ic];

  0026c	e0882083	 add         r2, r8, r3, lsl #1
  00270	e1d230b0	 ldrh        r3, [r2]
  00274	e1e03003	 mvn         r3, r3
  00278	e1a04803	 mov         r4, r3, lsl #16
  0027c	e1a04824	 mov         r4, r4, lsr #16

; 580  :             // Find pressed virtual keys
; 581  :             if ((data[ic] & KEYPAD_ROWS_MASK) == KEYPAD_ROWS_MASK) {

  00280	e204301f	 and         r3, r4, #0x1F
  00284	e353001f	 cmp         r3, #0x1F

; 582  :                 ik += KEYPAD_ROWS;

  00288	028e3005	 addeq       r3, lr, #5
  0028c	01a0e803	 moveq       lr, r3, lsl #16
  00290	01a0e82e	 moveq       lr, lr, lsr #16
  00294	e1c240b0	 strh        r4, [r2]
  00298	0a000019	 beq         |$LN67@KPD_IntrTh|
  0029c	e59f9614	 ldr         r9, [pc, #0x614]

; 583  :             } else for (ir = 0; ir < KEYPAD_ROWS; ir++, ik++) {

  002a0	e3a02000	 mov         r2, #0
  002a4	e3a05000	 mov         r5, #0
  002a8	e3a08001	 mov         r8, #1
  002ac		 |$LL63@KPD_IntrTh|

; 584  :                 if ((data[ic] & (1 << ir)) == 0) {

  002ac	e1140218	 tst         r4, r8, lsl r2
  002b0	1a000008	 bne         |$LN62@KPD_IntrTh|

; 585  :                     vk = g_keypadVK[ik];

  002b4	e7de1009	 ldrb        r1, [lr, +r9]

; 586  :                     vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 587  :                     keyDown = TRUE;

  002b8	e3a03001	 mov         r3, #1
  002bc	e58d3008	 str         r3, [sp, #8]
  002c0	e1a032a1	 mov         r3, r1, lsr #5
  002c4	e28d0020	 add         r0, sp, #0x20
  002c8	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  002cc	e201301f	 and         r3, r1, #0x1F
  002d0	e182331b	 orr         r3, r2, r11, lsl r3
  002d4	e5803000	 str         r3, [r0]
  002d8		 |$LN62@KPD_IntrTh|
  002d8	e2853001	 add         r3, r5, #1
  002dc	e1a02803	 mov         r2, r3, lsl #16
  002e0	e28e3001	 add         r3, lr, #1
  002e4	e1a0e803	 mov         lr, r3, lsl #16
  002e8	e1a02822	 mov         r2, r2, lsr #16
  002ec	e1a0e82e	 mov         lr, lr, lsr #16
  002f0	e1a05002	 mov         r5, r2
  002f4	e3520005	 cmp         r2, #5
  002f8	3affffeb	 bcc         |$LL63@KPD_IntrTh|
  002fc	e59f95ac	 ldr         r9, [pc, #0x5AC]
  00300	e28d8060	 add         r8, sp, #0x60
  00304		 |$LN67@KPD_IntrTh|
  00304	e2863001	 add         r3, r6, #1
  00308	e1a03803	 mov         r3, r3, lsl #16
  0030c	e1a03823	 mov         r3, r3, lsr #16
  00310	e1a06003	 mov         r6, r3
  00314	e3530006	 cmp         r3, #6
  00318	3affffd3	 bcc         |$LL68@KPD_IntrTh|

; 588  :                     DEBUGMSG(ZONE_INFO, (L"keyDown = TRUE \r\n"));
; 589  :                 }
; 590  :             }
; 591  :         }
; 592  : 
; 593  :         //--------------------------------------------------------------
; 594  :         // Remap multi virtual keys to final virtual key
; 595  :         //--------------------------------------------------------------
; 596  :         time = GetTickCount();

  0031c	eb000000	 bl          GetTickCount

; 597  :         for (ix = 0; ix < g_keypadRemap.count; ix++) {

  00320	e1d930b0	 ldrh        r3, [r9]
  00324	e1a01000	 mov         r1, r0
  00328	e3a0a000	 mov         r10, #0
  0032c	e59db018	 ldr         r11, [sp, #0x18]
  00330	e59d8010	 ldr         r8, [sp, #0x10]
  00334	e3530000	 cmp         r3, #0
  00338	e58d1000	 str         r1, [sp]
  0033c	e58da004	 str         r10, [sp, #4]
  00340	0a0000ab	 beq         |$LN57@KPD_IntrTh|
  00344	e1a04008	 mov         r4, r8
  00348	e58d4014	 str         r4, [sp, #0x14]
  0034c		 |$LL59@KPD_IntrTh|
  0034c	e5993004	 ldr         r3, [r9, #4]

; 598  :             const KEYPAD_REMAP_ITEM *pItem = &g_keypadRemap.pItem[ix];
; 599  :             KEYPAD_REMAP_STATE *pState = &pRemapState[ix];
; 600  :             DWORD state = 0;

  00350	e3a0b000	 mov         r11, #0

; 601  :             USHORT down = 0;

  00354	e3a05000	 mov         r5, #0
  00358	e083918a	 add         r9, r3, r10, lsl #3

; 602  : 
; 603  :             // Count number of keys down & save down/up state
; 604  :             for (ik = 0; ik < pItem->keys; ik++) {

  0035c	e5d93001	 ldrb        r3, [r9, #1]
  00360	e58d901c	 str         r9, [sp, #0x1C]
  00364	e3a0e000	 mov         lr, #0
  00368	e1b08003	 movs        r8, r3
  0036c	0a000017	 beq         |$LN54@KPD_IntrTh|
  00370	e5997004	 ldr         r7, [r9, #4]
  00374	e28d9020	 add         r9, sp, #0x20
  00378	e3a06000	 mov         r6, #0
  0037c	e3a0a001	 mov         r10, #1
  00380	e3a04001	 mov         r4, #1
  00384		 |$LL56@KPD_IntrTh|

; 605  :                 vk = pItem->pVKeys[ik];

  00384	e7d7100e	 ldrb        r1, [r7, +lr]

; 606  :                 if ((vkNewState[vk >> 5] & (1 << (vk & 0x1F))) != 0) {

  00388	e1a032a1	 mov         r3, r1, lsr #5
  0038c	e7992103	 ldr         r2, [r9, +r3, lsl #2]
  00390	e201301f	 and         r3, r1, #0x1F
  00394	e1120314	 tst         r2, r4, lsl r3

; 607  :                     state |= 1 << ik;
; 608  :                     down++;

  00398	12853001	 addne       r3, r5, #1
  0039c	11a05803	 movne       r5, r3, lsl #16
  003a0	e2863001	 add         r3, r6, #1
  003a4	118bbe1a	 orrne       r11, r11, r10, lsl lr
  003a8	e1a0e803	 mov         lr, r3, lsl #16
  003ac	e1a0e82e	 mov         lr, lr, lsr #16
  003b0	11a05825	 movne       r5, r5, lsr #16
  003b4	e1a0600e	 mov         r6, lr
  003b8	e15e0008	 cmp         lr, r8
  003bc	3afffff0	 bcc         |$LL56@KPD_IntrTh|

; 670  :             }
; 671  :             // Save key state
; 672  :             pState->state = state;

  003c0	e59d4014	 ldr         r4, [sp, #0x14]
  003c4	e59d901c	 ldr         r9, [sp, #0x1C]
  003c8	e59da004	 ldr         r10, [sp, #4]
  003cc	e59d1000	 ldr         r1, [sp]
  003d0		 |$LN54@KPD_IntrTh|

; 609  :                 }
; 610  :             }
; 611  :             // Depending on number of keys down
; 612  :             if (down >= pItem->keys && pItem->keys > 1) {

  003d0	e1550008	 cmp         r5, r8
  003d4	3a000022	 bcc         |$LN52@KPD_IntrTh|
  003d8	e3580001	 cmp         r8, #1
  003dc	9a000020	 bls         |$LN52@KPD_IntrTh|

; 613  :                 // Clear all mapping keys
; 614  :                 for (ik = 0; ik < pItem->keys; ik++) {

  003e0	e3a01000	 mov         r1, #0
  003e4	e3580000	 cmp         r8, #0
  003e8	0a000010	 beq         |$LN49@KPD_IntrTh|
  003ec	e5995004	 ldr         r5, [r9, #4]
  003f0	e3a03000	 mov         r3, #0
  003f4	e3a0a001	 mov         r10, #1
  003f8		 |$LL51@KPD_IntrTh|

; 615  :                     vk = pItem->pVKeys[ik];

  003f8	e7d11005	 ldrb        r1, [r1, +r5]

; 616  :                     vkNewState[vk >> 5] &= ~(1 << (vk & 0x1F));

  003fc	e2830001	 add         r0, r3, #1
  00400	e28de020	 add         lr, sp, #0x20
  00404	e1a032a1	 mov         r3, r1, lsr #5
  00408	e7be2103	 ldr         r2, [lr, +r3, lsl #2]!
  0040c	e201301f	 and         r3, r1, #0x1F
  00410	e1a01800	 mov         r1, r0, lsl #16
  00414	e1a01821	 mov         r1, r1, lsr #16
  00418	e1c2331a	 bic         r3, r2, r10, lsl r3
  0041c	e1510008	 cmp         r1, r8
  00420	e58e3000	 str         r3, [lr]
  00424	e1a03001	 mov         r3, r1
  00428	3afffff2	 bcc         |$LL51@KPD_IntrTh|

; 670  :             }
; 671  :             // Save key state
; 672  :             pState->state = state;

  0042c	e59da004	 ldr         r10, [sp, #4]
  00430		 |$LN49@KPD_IntrTh|

; 617  :                 }
; 618  :                 // All keys are down set final key
; 619  :                 vk = pItem->vkey;

  00430	e5d91000	 ldrb        r1, [r9]

; 620  :                 vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 621  :                 DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 622  :                     L"Mapped vkey: 0x%x\r\n", vk
; 623  :                 ));
; 624  : 
; 625  :                 // Clear remap pending flag
; 626  :                 pState->pending = FALSE;

  00434	e3a03000	 mov         r3, #0
  00438	e5843000	 str         r3, [r4]
  0043c	e1a032a1	 mov         r3, r1, lsr #5
  00440	e28d0020	 add         r0, sp, #0x20
  00444	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  00448	e201301f	 and         r3, r1, #0x1F

; 627  :                 // Set remap processing flag
; 628  :                 pState->remapped = TRUE;

  0044c	e3a01001	 mov         r1, #1
  00450	e5841004	 str         r1, [r4, #4]
  00454		 |$LN136@KPD_IntrTh|
  00454	e3a01001	 mov         r1, #1
  00458	e1823311	 orr         r3, r2, r1, lsl r3
  0045c	e5803000	 str         r3, [r0]
  00460	ea000058	 b           |$LN131@KPD_IntrTh|
  00464		 |$LN52@KPD_IntrTh|

; 629  :             } else if (down > 0) {

  00464	e3550000	 cmp         r5, #0
  00468	0a000033	 beq         |$LN47@KPD_IntrTh|

; 630  :                 // If already remapping or remapping is not pending
; 631  :                 // or pending time expired
; 632  :                 if (pState->remapped || !pState->pending ||
; 633  :                     (INT32)(time - pState->time) < 0 ) {

  0046c	e5943004	 ldr         r3, [r4, #4]
  00470	e1b02003	 movs        r2, r3
  00474	1a000011	 bne         |$LN45@KPD_IntrTh|
  00478	e5943000	 ldr         r3, [r4]
  0047c	e3530000	 cmp         r3, #0
  00480	0a000011	 beq         |$LN129@KPD_IntrTh|
  00484	e5943008	 ldr         r3, [r4, #8]
  00488	e0513003	 subs        r3, r1, r3
  0048c	4a00000b	 bmi         |$LN45@KPD_IntrTh|

; 643  :                     }
; 644  :                 } else if (
; 645  :                     pItem->keys == 1 && (INT32)(time - pState->time) >= 0
; 646  :                 ) {

  00490	e3580001	 cmp         r8, #1
  00494	1a00004c	 bne         |$LN38@KPD_IntrTh|

; 647  :                     // This is press and hold key
; 648  :                    DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 649  :                         L"Mapped press and hold vkey: 0x%x\r\n", vk
; 650  :                     ));
; 651  :                     vk = pItem->vkey;

  00498	e5d91000	 ldrb        r1, [r9]

; 652  :                     vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 653  :                     keyDown = TRUE;

  0049c	e3a03001	 mov         r3, #1
  004a0	e58d3008	 str         r3, [sp, #8]
  004a4	e1a032a1	 mov         r3, r1, lsr #5
  004a8	e28d0020	 add         r0, sp, #0x20
  004ac	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  004b0	e201301f	 and         r3, r1, #0x1F

; 654  :                     pState->pending = FALSE;

  004b4	e3a01000	 mov         r1, #0
  004b8	e5841000	 str         r1, [r4]
  004bc	eaffffe4	 b           |$LN136@KPD_IntrTh|
  004c0		 |$LN45@KPD_IntrTh|

; 634  :                     // If we are not pending and not already remapping, start
; 635  :                     if (!pState->pending && !pState->remapped) {

  004c0	e5943000	 ldr         r3, [r4]
  004c4	e3530000	 cmp         r3, #0
  004c8	1a000005	 bne         |$LN44@KPD_IntrTh|
  004cc		 |$LN129@KPD_IntrTh|
  004cc	e3520000	 cmp         r2, #0

; 636  :                         pState->pending = TRUE;

  004d0	03a03001	 moveq       r3, #1
  004d4	05843000	 streq       r3, [r4]

; 637  :                         pState->time = time + pItem->delay;

  004d8	01d930b2	 ldreqh      r3, [r9, #2]
  004dc	00833001	 addeq       r3, r3, r1
  004e0	05843008	 streq       r3, [r4, #8]
  004e4		 |$LN44@KPD_IntrTh|

; 638  :                     }
; 639  :                     // Clear all mapping keys
; 640  :                     for (ik = 0; ik < pItem->keys; ik++) {

  004e4	e5d93001	 ldrb        r3, [r9, #1]
  004e8	e3a01000	 mov         r1, #0
  004ec	e1b06003	 movs        r6, r3
  004f0	0a000034	 beq         |$LN131@KPD_IntrTh|
  004f4	e5995004	 ldr         r5, [r9, #4]
  004f8	e3a03000	 mov         r3, #0
  004fc	e3a0a001	 mov         r10, #1
  00500		 |$LL43@KPD_IntrTh|

; 641  :                         vk = pItem->pVKeys[ik];

  00500	e7d11005	 ldrb        r1, [r1, +r5]

; 642  :                         vkNewState[vk >> 5] &= ~(1 << (vk & 0x1F));

  00504	e2830001	 add         r0, r3, #1
  00508	e28de020	 add         lr, sp, #0x20
  0050c	e1a032a1	 mov         r3, r1, lsr #5
  00510	e7be2103	 ldr         r2, [lr, +r3, lsl #2]!
  00514	e201301f	 and         r3, r1, #0x1F
  00518	e1a01800	 mov         r1, r0, lsl #16
  0051c	e1a01821	 mov         r1, r1, lsr #16
  00520	e1c2331a	 bic         r3, r2, r10, lsl r3
  00524	e1510006	 cmp         r1, r6
  00528	e58e3000	 str         r3, [lr]
  0052c	e1a03001	 mov         r3, r1
  00530	3afffff2	 bcc         |$LL43@KPD_IntrTh|

; 655  :                 }
; 656  :             } else {

  00534	e59da004	 ldr         r10, [sp, #4]
  00538	ea000022	 b           |$LN131@KPD_IntrTh|
  0053c		 |$LN47@KPD_IntrTh|

; 657  :                 // All keys are up, if remapping was pending set keys
; 658  :                 if (pState->pending) {

  0053c	e5943000	 ldr         r3, [r4]
  00540	e3530000	 cmp         r3, #0
  00544	0a00001d	 beq         |$LN134@KPD_IntrTh|

; 659  :                     for (ik = 0; ik < pItem->keys; ik++) {

  00548	e3a02000	 mov         r2, #0
  0054c	e3580000	 cmp         r8, #0
  00550	0a000017	 beq         |$LN34@KPD_IntrTh|
  00554	e594500c	 ldr         r5, [r4, #0xC]
  00558	e3a04001	 mov         r4, #1
  0055c	e3a0e000	 mov         lr, #0
  00560	e3a0a001	 mov         r10, #1
  00564		 |$LL36@KPD_IntrTh|

; 660  :                         if ((pState->state & (1 << ik)) != 0) {

  00564	e115021a	 tst         r5, r10, lsl r2
  00568	0a000009	 beq         |$LN35@KPD_IntrTh|

; 661  :                             vk = pItem->pVKeys[ik];

  0056c	e5993004	 ldr         r3, [r9, #4]

; 662  :                             vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 663  :                             DEBUGMSG(ZONE_INFO, (L"keyDown = TRUE 2\r\n"));
; 664  :                             keyDown = TRUE;

  00570	e3a01001	 mov         r1, #1
  00574	e58d1008	 str         r1, [sp, #8]
  00578	e7d21003	 ldrb        r1, [r2, +r3]
  0057c	e28d0020	 add         r0, sp, #0x20
  00580	e1a032a1	 mov         r3, r1, lsr #5
  00584	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  00588	e201301f	 and         r3, r1, #0x1F
  0058c	e1823314	 orr         r3, r2, r4, lsl r3
  00590	e5803000	 str         r3, [r0]
  00594		 |$LN35@KPD_IntrTh|
  00594	e28e3001	 add         r3, lr, #1
  00598	e1a02803	 mov         r2, r3, lsl #16
  0059c	e1a02822	 mov         r2, r2, lsr #16
  005a0	e1a0e002	 mov         lr, r2
  005a4	e1520008	 cmp         r2, r8
  005a8	3affffed	 bcc         |$LL36@KPD_IntrTh|

; 670  :             }
; 671  :             // Save key state
; 672  :             pState->state = state;

  005ac	e59d4014	 ldr         r4, [sp, #0x14]
  005b0	e59da004	 ldr         r10, [sp, #4]
  005b4		 |$LN34@KPD_IntrTh|
  005b4	e3a03000	 mov         r3, #0
  005b8	e5843000	 str         r3, [r4]
  005bc	ea000000	 b           |$LN37@KPD_IntrTh|
  005c0		 |$LN134@KPD_IntrTh|

; 489  :         // Allocate state structure for remap
; 490  :         if ((pRepeatState = LocalAlloc(
; 491  :             LPTR, g_keypadRepeat.count * sizeof(KEYPAD_REPEAT_STATE)
; 492  :         ))  == NULL) {

  005c0	e3a03000	 mov         r3, #0
  005c4		 |$LN37@KPD_IntrTh|

; 665  :                         }
; 666  :                     }
; 667  :                     pState->pending = FALSE;
; 668  :                 }
; 669  :                 pState->remapped = FALSE;

  005c4	e5843004	 str         r3, [r4, #4]
  005c8		 |$LN131@KPD_IntrTh|

; 654  :                     pState->pending = FALSE;

  005c8	e59d1000	 ldr         r1, [sp]
  005cc		 |$LN38@KPD_IntrTh|

; 670  :             }
; 671  :             // Save key state
; 672  :             pState->state = state;

  005cc	e59f92dc	 ldr         r9, [pc, #0x2DC]
  005d0	e584b00c	 str         r11, [r4, #0xC]
  005d4	e28aa001	 add         r10, r10, #1
  005d8	e1d930b0	 ldrh        r3, [r9]
  005dc	e2844010	 add         r4, r4, #0x10
  005e0	e58da004	 str         r10, [sp, #4]
  005e4	e15a0003	 cmp         r10, r3
  005e8	e58d4014	 str         r4, [sp, #0x14]
  005ec	3affff56	 bcc         |$LL59@KPD_IntrTh|

; 597  :         for (ix = 0; ix < g_keypadRemap.count; ix++) {

  005f0	e59db018	 ldr         r11, [sp, #0x18]
  005f4		 |$LN57@KPD_IntrTh|

; 673  :         }
; 674  : 
; 675  :         //--------------------------------------------------------------
; 676  :         // Find pressed/released keys
; 677  :         //--------------------------------------------------------------
; 678  :         for (ic = 0, vk = 0; ic < VK_KEYS/DWORD_BITS; ic++) {

  005f4	e3a03000	 mov         r3, #0
  005f8	e3a05000	 mov         r5, #0
  005fc	e3a08000	 mov         r8, #0
  00600	e28d2020	 add         r2, sp, #0x20
  00604	e28d1040	 add         r1, sp, #0x40
  00608		 |$LL32@KPD_IntrTh|

; 679  :             change = vkState[ic] ^ vkNewState[ic];

  00608	e7926103	 ldr         r6, [r2, +r3, lsl #2]
  0060c	e7913103	 ldr         r3, [r1, +r3, lsl #2]
  00610	e0337006	 eors        r7, r3, r6

; 680  :             if (change == 0) {
; 681  :                 vk += DWORD_BITS;

  00614	02853020	 addeq       r3, r5, #0x20
  00618	020350ff	 andeq       r5, r3, #0xFF
  0061c	0a00001a	 beq         |$LN31@KPD_IntrTh|

; 682  :             } else for (mask = 1; mask != 0; mask <<= 1, vk++) {

  00620	e3a04001	 mov         r4, #1
  00624		 |$LL27@KPD_IntrTh|

; 683  :                 // Check for change
; 684  :                 if ((change & mask) != 0) {

  00624	e1140007	 tst         r4, r7
  00628	0a000011	 beq         |$LN26@KPD_IntrTh|

; 685  :                     if ((vkNewState[ic] & mask) != 0)

  0062c	e1160004	 tst         r6, r4

; 686  :                     {
; 687  :                         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: Key Down: 0x%x\r\n", vk ));
; 688  :                         keybd_event(vk, 0, 0, 0);

  00630	e3a03000	 mov         r3, #0
  00634	e3a01000	 mov         r1, #0
  00638	e1a00005	 mov         r0, r5
  0063c	0a00000a	 beq         |$LN23@KPD_IntrTh|
  00640	e3a02000	 mov         r2, #0
  00644	eb000000	 bl          keybd_event

; 689  : 
; 690  :                         //Notify for power manager events
; 691  :                         if(vk == VK_TPOWER)

  00648	e3550081	 cmp         r5, #0x81

; 692  :                         {
; 693  :                             PowerPolicyNotify(PPN_POWERBUTTONPRESSED, 0);

  0064c	e3a01000	 mov         r1, #0
  00650	1a000002	 bne         |$LN22@KPD_IntrTh|
  00654	e3a00004	 mov         r0, #4

; 694  :                         }
; 695  :                         else
; 696  :                         {
; 697  :                             //Application button pressed
; 698  :                             //PM uses this to indicate user activity and reset timers
; 699  :                             PowerPolicyNotify(PPN_APPBUTTONPRESSED, 0);

  00658	eb000000	 bl          PowerPolicyNotify

; 700  :                         }
; 701  : 
; 702  :                         if(vk == VK_TSTAR)
; 703  :                         {
; 704  :                             DEBUGMSG(ZONE_IST, (L"VK_TSTAR\r\n"));
; 705  :                         }
; 706  :                     }
; 707  :                     else

  0065c	ea000004	 b           |$LN26@KPD_IntrTh|
  00660		 |$LN22@KPD_IntrTh|

; 694  :                         }
; 695  :                         else
; 696  :                         {
; 697  :                             //Application button pressed
; 698  :                             //PM uses this to indicate user activity and reset timers
; 699  :                             PowerPolicyNotify(PPN_APPBUTTONPRESSED, 0);

  00660	e3a00006	 mov         r0, #6
  00664	eb000000	 bl          PowerPolicyNotify

; 700  :                         }
; 701  : 
; 702  :                         if(vk == VK_TSTAR)
; 703  :                         {
; 704  :                             DEBUGMSG(ZONE_IST, (L"VK_TSTAR\r\n"));
; 705  :                         }
; 706  :                     }
; 707  :                     else

  00668	ea000001	 b           |$LN26@KPD_IntrTh|
  0066c		 |$LN23@KPD_IntrTh|

; 708  :                     {
; 709  :                         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: Key Up: 0x%x\r\n", vk ));
; 710  :                         keybd_event(vk, 0, KEYEVENTF_KEYUP, 0);

  0066c	e3a02002	 mov         r2, #2
  00670	eb000000	 bl          keybd_event
  00674		 |$LN26@KPD_IntrTh|
  00674	e2853001	 add         r3, r5, #1
  00678	e20350ff	 and         r5, r3, #0xFF
  0067c	e1b04084	 movs        r4, r4, lsl #1
  00680	1affffe7	 bne         |$LL27@KPD_IntrTh|
  00684	e28d2020	 add         r2, sp, #0x20
  00688	e28d1040	 add         r1, sp, #0x40
  0068c		 |$LN31@KPD_IntrTh|
  0068c	e2883001	 add         r3, r8, #1
  00690	e1a03803	 mov         r3, r3, lsl #16
  00694	e1a03823	 mov         r3, r3, lsr #16
  00698	e1a08003	 mov         r8, r3
  0069c	e3530008	 cmp         r3, #8
  006a0	3affffd8	 bcc         |$LL32@KPD_IntrTh|

; 711  :                     }
; 712  :                 }
; 713  :             }
; 714  :         }
; 715  : 
; 716  :         //--------------------------------------------------------------
; 717  :         //  Check for auto-repeat keys
; 718  :         //--------------------------------------------------------------
; 719  :         for (ix = 0; ix < g_keypadRepeat.count; ix++) {

  006a4	e59f5208	 ldr         r5, [pc, #0x208]
  006a8	e3a09000	 mov         r9, #0
  006ac	e1d530b0	 ldrh        r3, [r5]
  006b0	e3530000	 cmp         r3, #0
  006b4	0a000050	 beq         |$LN16@KPD_IntrTh|
  006b8	e59d300c	 ldr         r3, [sp, #0xC]
  006bc	e59da000	 ldr         r10, [sp]
  006c0	e3a08000	 mov         r8, #0
  006c4	e1a04003	 mov         r4, r3
  006c8	e3a00001	 mov         r0, #1
  006cc		 |$LL18@KPD_IntrTh|
  006cc	e5953004	 ldr         r3, [r5, #4]

; 720  :             const KEYPAD_REPEAT_ITEM *pItem = &g_keypadRepeat.pItem[ix];
; 721  :             const KEYPAD_REPEAT_BLOCK *pBlock = pItem->pBlock;
; 722  :             KEYPAD_REPEAT_STATE *pState = &pRepeatState[ix];
; 723  :             DWORD delay;
; 724  :             BOOL blockRepeat = FALSE;
; 725  :             UCHAR vkBlock;
; 726  : 
; 727  :             vk = pItem->vkey;
; 728  :             if ((vkNewState[vk >> 5] & (1 << (vk & 0x1F))) != 0) {

  006d0	e28d2020	 add         r2, sp, #0x20
  006d4	e0886003	 add         r6, r8, r3
  006d8	e5d67000	 ldrb        r7, [r6]
  006dc	e596100c	 ldr         r1, [r6, #0xC]
  006e0	e1a032a7	 mov         r3, r7, lsr #5
  006e4	e7922103	 ldr         r2, [r2, +r3, lsl #2]
  006e8	e207301f	 and         r3, r7, #0x1F
  006ec	e1120310	 tst         r2, r0, lsl r3
  006f0	0a000038	 beq         |$LN15@KPD_IntrTh|

; 729  :                 if (!pState->pending) {

  006f4	e5943000	 ldr         r3, [r4]
  006f8	e3530000	 cmp         r3, #0
  006fc	1a000008	 bne         |$LN14@KPD_IntrTh|

; 730  :                     // Key was just pressed
; 731  :                     delay = pItem->firstDelay;

  00700	e1d630b2	 ldrh        r3, [r6, #2]
  00704	e3530000	 cmp         r3, #0

; 732  :                     if (delay == 0) delay = pDevice->firstRepeat;

  00708	059b3030	 ldreq       r3, [r11, #0x30]

; 733  :                     pState->time = time + delay;

  0070c	e083300a	 add         r3, r3, r10
  00710	e5843004	 str         r3, [r4, #4]

; 734  :                     pState->pending = TRUE;

  00714	e3a03001	 mov         r3, #1
  00718	e5843000	 str         r3, [r4]

; 735  :                     pState->blocked = FALSE;

  0071c	e3a03000	 mov         r3, #0
  00720	ea00002e	 b           |$LN138@KPD_IntrTh|
  00724		 |$LN14@KPD_IntrTh|

; 736  :                 } else if ((INT32)(time - pState->time) >= 0) {

  00724	e5943004	 ldr         r3, [r4, #4]
  00728	e05a3003	 subs        r3, r10, r3
  0072c	4a00002c	 bmi         |$LN17@KPD_IntrTh|

; 737  :                     // Check if any blocking keys are pressed
; 738  :                     if (pBlock != 0) {

  00730	e3510000	 cmp         r1, #0
  00734	0a000015	 beq         |$LN7@KPD_IntrTh|

; 739  :                         for (ik = 0; ik < pBlock->count; ik++) {

  00738	e5d13000	 ldrb        r3, [r1]
  0073c	e3a00000	 mov         r0, #0
  00740	e1b05003	 movs        r5, r3
  00744	0a000010	 beq         |$LN133@KPD_IntrTh|
  00748	e591e004	 ldr         lr, [r1, #4]
  0074c		 |$LL9@KPD_IntrTh|

; 740  :                             vkBlock = pBlock->pVKey[ik];

  0074c	e7d0100e	 ldrb        r1, [r0, +lr]

; 741  :                             if ((
; 742  :                                 vkNewState[vkBlock >> 5] &
; 743  :                                 (1 << (vkBlock & 0x1F))
; 744  :                             ) != 0) {

  00750	e28d2020	 add         r2, sp, #0x20
  00754	e1a032a1	 mov         r3, r1, lsr #5
  00758	e7922103	 ldr         r2, [r2, +r3, lsl #2]
  0075c	e201301f	 and         r3, r1, #0x1F
  00760	e3a01001	 mov         r1, #1
  00764	e1120311	 tst         r2, r1, lsl r3
  00768	1a000005	 bne         |$LN114@KPD_IntrTh|
  0076c	e2803001	 add         r3, r0, #1
  00770	e1a00803	 mov         r0, r3, lsl #16
  00774	e1a00820	 mov         r0, r0, lsr #16
  00778	e1500005	 cmp         r0, r5
  0077c	3afffff2	 bcc         |$LL9@KPD_IntrTh|

; 505  : 
; 506  :         if (pDevice->intrThreadExit) break;

  00780	ea000001	 b           |$LN133@KPD_IntrTh|
  00784		 |$LN114@KPD_IntrTh|

; 745  :                                 pState->blocked = TRUE;

  00784	e3a03001	 mov         r3, #1
  00788	e5843008	 str         r3, [r4, #8]
  0078c		 |$LN133@KPD_IntrTh|

; 489  :         // Allocate state structure for remap
; 490  :         if ((pRepeatState = LocalAlloc(
; 491  :             LPTR, g_keypadRepeat.count * sizeof(KEYPAD_REPEAT_STATE)
; 492  :         ))  == NULL) {

  0078c	e59f5120	 ldr         r5, [pc, #0x120]
  00790		 |$LN7@KPD_IntrTh|

; 746  :                                 DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 747  :                                     L"Block repeat: 0x%x because of 0x%x\r\n",
; 748  :                                     vk, vkBlock
; 749  :                                 ));
; 750  :                                 break;
; 751  :                             }
; 752  :                         }
; 753  :                     }
; 754  :                     // Repeat if not blocked
; 755  :                     if (!pState->blocked) {

  00790	e5943008	 ldr         r3, [r4, #8]
  00794	e3530000	 cmp         r3, #0
  00798	1a000007	 bne         |$LN5@KPD_IntrTh|

; 756  :                         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 757  :                             L"Key Repeat: 0x%x\r\n", vk
; 758  :                         ));
; 759  :                         keybd_event(vk, 0, pItem->silent?KEYEVENTF_SILENT:0, 0);

  0079c	e5963008	 ldr         r3, [r6, #8]
  007a0	e3a01000	 mov         r1, #0
  007a4	e1a00007	 mov         r0, r7
  007a8	e3530000	 cmp         r3, #0
  007ac	13a02004	 movne       r2, #4
  007b0	03a02000	 moveq       r2, #0
  007b4	e3a03000	 mov         r3, #0
  007b8	eb000000	 bl          keybd_event
  007bc		 |$LN5@KPD_IntrTh|

; 760  :                     }
; 761  :                     // Set time for next repeat
; 762  :                     delay = pItem->nextDelay;

  007bc	e1d630b4	 ldrh        r3, [r6, #4]

; 763  :                     if (delay == 0) delay = pDevice->nextRepeat;
; 764  :                     pState->time = time + delay;
; 765  :                 }
; 766  :             } else {

  007c0	e3a00001	 mov         r0, #1
  007c4	e3530000	 cmp         r3, #0
  007c8	059b3034	 ldreq       r3, [r11, #0x34]
  007cc	e083300a	 add         r3, r3, r10
  007d0	e5843004	 str         r3, [r4, #4]
  007d4	ea000002	 b           |$LN17@KPD_IntrTh|
  007d8		 |$LN15@KPD_IntrTh|

; 767  :                 pState->pending = FALSE;

  007d8	e3a03000	 mov         r3, #0
  007dc	e5843000	 str         r3, [r4]
  007e0		 |$LN138@KPD_IntrTh|

; 768  :                 pState->blocked = FALSE;

  007e0	e5843008	 str         r3, [r4, #8]
  007e4		 |$LN17@KPD_IntrTh|
  007e4	e1d530b0	 ldrh        r3, [r5]
  007e8	e2899001	 add         r9, r9, #1
  007ec	e2888010	 add         r8, r8, #0x10
  007f0	e1590003	 cmp         r9, r3
  007f4	e284400c	 add         r4, r4, #0xC
  007f8	3affffb3	 bcc         |$LL18@KPD_IntrTh|
  007fc		 |$LN16@KPD_IntrTh|

; 769  :             }
; 770  :         }
; 771  : 
; 772  :         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: Prepare for next run\r\n"));
; 773  :         //--------------------------------------------------------------
; 774  :         // Prepare for next run
; 775  :         //--------------------------------------------------------------
; 776  :         // New state become old
; 777  :         memcpy(vkState, vkNewState, sizeof(vkState));

  007fc	e28d0040	 add         r0, sp, #0x40
  00800	e28d1020	 add         r1, sp, #0x20
  00804	e3a02020	 mov         r2, #0x20
  00808	eb000000	 bl          memcpy

; 778  : 
; 779  :         // Don't drive any column GPIO's
; 780  :         OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_CLEARDATAOUT, 1<<26);    // column 0 = Drive GPIO90
; 781  :         OUTREG32(&pDevice->pGPIO3Regs->ulGPIO_CLEARDATAOUT, 1<<27);    // column 1 = Drive GPIO91
; 782  :         OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_CLEARDATAOUT, 1<<15);    // column 2 = Drive GPIO15
; 783  :         OUTREG32(&pDevice->pGPIO2Regs->ulGPIO_CLEARDATAOUT, 1<<4);     // column 3 = Drive GPIO36
; 784  :         OUTREG32(&pDevice->pGPIO1Regs->ulGPIO_CLEARDATAOUT, 1<<12);    // column 4 = Drive GPIO12
; 785  :         OUTREG32(&pDevice->pGPIO4Regs->ulGPIO_CLEARDATAOUT, 1<<1);     // column 5 = Drive GPIO97
; 786  : 
; 787  :         // Set timeout period depending on data state
; 788  :         timeout = keyDown ? pDevice->samplePeriod : INFINITE;

  0080c	e59d2008	 ldr         r2, [sp, #8]
  00810	e59b3054	 ldr         r3, [r11, #0x54]
  00814	e3520000	 cmp         r2, #0
  00818	e3a02301	 mov         r2, #1, 6
  0081c	e5832090	 str         r2, [r3, #0x90]
  00820	e59b3054	 ldr         r3, [r11, #0x54]
  00824	e3a02302	 mov         r2, #2, 6
  00828	e5832090	 str         r2, [r3, #0x90]
  0082c	e59b304c	 ldr         r3, [r11, #0x4C]
  00830	e3a02902	 mov         r2, #2, 18
  00834	e5832090	 str         r2, [r3, #0x90]
  00838	e59b3050	 ldr         r3, [r11, #0x50]
  0083c	e3a02010	 mov         r2, #0x10
  00840	e5832090	 str         r2, [r3, #0x90]
  00844	e59b304c	 ldr         r3, [r11, #0x4C]
  00848	e3a02a01	 mov         r2, #1, 20
  0084c	e5832090	 str         r2, [r3, #0x90]
  00850	e59b3058	 ldr         r3, [r11, #0x58]
  00854	e3a02002	 mov         r2, #2
  00858	e5832090	 str         r2, [r3, #0x90]

; 789  :         DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: InterruptDone, timeout set to %d\r\n", timeout));
; 790  :         // Interrupt is done
; 791  :         InterruptDone(pDevice->sysIntr);

  0085c	e59b005c	 ldr         r0, [r11, #0x5C]
  00860	159b4028	 ldrne       r4, [r11, #0x28]
  00864	03e04000	 mvneq       r4, #0
  00868	eb000000	 bl          InterruptDone
  0086c	e59b3068	 ldr         r3, [r11, #0x68]
  00870	e59d8010	 ldr         r8, [sp, #0x10]
  00874	e59f9034	 ldr         r9, [pc, #0x34]
  00878	eafffe0a	 b           |$LN142@KPD_IntrTh|
  0087c		 |$LN132@KPD_IntrTh|

; 489  :         // Allocate state structure for remap
; 490  :         if ((pRepeatState = LocalAlloc(
; 491  :             LPTR, g_keypadRepeat.count * sizeof(KEYPAD_REPEAT_STATE)
; 492  :         ))  == NULL) {

  0087c	e59d400c	 ldr         r4, [sp, #0xC]
  00880		 |$cleanUp$43028|

; 792  :     }
; 793  : 
; 794  : cleanUp:
; 795  : 
; 796  :     if (pRemapState != NULL) LocalFree(pRemapState);

  00880	e59d0010	 ldr         r0, [sp, #0x10]
  00884	e3500000	 cmp         r0, #0
  00888	1b000000	 blne        LocalFree

; 797  :     if (pRepeatState != NULL) LocalFree(pRepeatState);

  0088c	e3540000	 cmp         r4, #0
  00890	11a00004	 movne       r0, r4
  00894	1b000000	 blne        LocalFree
  00898		 |$LN1@KPD_IntrTh|

; 798  :     return ERROR_SUCCESS;

  00898	e59d006c	 ldr         r0, [sp, #0x6C]
  0089c	eb000000	 bl          __security_check_cookie
  008a0	e3a00000	 mov         r0, #0

; 799  : }

  008a4	e28dd070	 add         sp, sp, #0x70
  008a8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  008ac	e12fff1e	 bx          lr
  008b0		 |$LN146@KPD_IntrTh|
  008b0		 |$LN147@KPD_IntrTh|
  008b0	00000000	 DCD         |g_keypadRemap|
  008b4		 |$LN148@KPD_IntrTh|
  008b4	00000000	 DCD         |g_keypadRepeat|
  008b8		 |$LN149@KPD_IntrTh|
  008b8	00000000	 DCD         |g_keypadVK|
  008bc		 |$LN150@KPD_IntrTh|
  008bc	00000000	 DCD         |__security_cookie|
  008c0		 |$M43428|

			 ENDP  ; |KPD_IntrThread|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|

  00000			 AREA	 |.pdata|, PDATA
|$T43447| DCD	|$LN8@DllMain|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 808  : {

  00000		 |$LN8@DllMain|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43444|

; 809  :     switch (reason) {

  00004	e3510001	 cmp         r1, #1

; 810  :     case DLL_PROCESS_ATTACH:
; 811  :         DEBUGREGISTER(hDLL);
; 812  :         DisableThreadLibraryCalls((HMODULE)hDLL);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 813  :         break;
; 814  :     }
; 815  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 816  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M43445|

			 ENDP  ; |DllMain|

	EXPORT	|KPD_Init|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43468| DCD	|$LN20@KPD_Init|
	DCD	0x40008802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Init| PROC

; 173  : {

  00000		 |$LN20@KPD_Init|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43465|
  00008	e1a06000	 mov         r6, r0

; 174  :     DWORD rc = (DWORD)NULL;
; 175  :     KPD_DEVICE *pDevice = NULL;
; 176  :     PHYSICAL_ADDRESS pa;
; 177  : 
; 178  : 
; 179  :     DEBUGMSG(ZONE_FUNCTION, (
; 180  :         L"+KPD_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 181  :     ));
; 182  : 
; 183  :     // Create device structure
; 184  :     pDevice = (KPD_DEVICE *)LocalAlloc(LPTR, sizeof(KPD_DEVICE));

  0000c	e3a0106c	 mov         r1, #0x6C
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a05000	 mov         r5, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 185  :     if (pDevice == NULL) {

  00020	0a000073	 beq         |$LN17@KPD_Init|

; 186  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 187  :             L"Failed allocate KDP driver structure\r\n"
; 188  :         ));
; 189  :         goto cleanUp;
; 190  :     }
; 191  : 
; 192  :     // Set cookie & initialize critical section
; 193  :     pDevice->cookie = KPD_DEVICE_COOKIE;

  00024	e59f31f0	 ldr         r3, [pc, #0x1F0]

; 194  :     InitializeCriticalSection(&pDevice->cs);

  00028	e1a00004	 mov         r0, r4
  0002c	e4803038	 str         r3, [r0], #0x38
  00030	eb000000	 bl          InitializeCriticalSection

; 195  : 
; 196  :     // Read device parameters
; 197  :     if (GetDeviceRegistryParams(
; 198  :         szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams
; 199  :     ) != ERROR_SUCCESS) {

  00034	e59f31dc	 ldr         r3, [pc, #0x1DC]
  00038	e3a0200b	 mov         r2, #0xB
  0003c	e1a01004	 mov         r1, r4
  00040	e1a00006	 mov         r0, r6
  00044	eb000000	 bl          GetDeviceRegistryParams
  00048	e3500000	 cmp         r0, #0
  0004c	e3e07000	 mvn         r7, #0
  00050	e3a08002	 mov         r8, #2
  00054	e3a06000	 mov         r6, #0
  00058	0a000010	 beq         |$LN13@KPD_Init|

; 200  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 201  :             L"Failed read KPD driver registry parameters\r\n"
; 202  :         ));
; 203  :         pDevice->irqs[0]= -1;
; 204  :         pDevice->irqs[1]= 2;
; 205  :         pDevice->irqs[2]=(DWORD)NULL;
; 206  :         pDevice->irqs[3]=(DWORD)NULL;
; 207  :         pDevice->irqs[4]=(DWORD)NULL;
; 208  :         pDevice->irqs[5]=(DWORD)NULL;
; 209  :         pDevice->irqs[6]=(DWORD)NULL;
; 210  :         pDevice->priority256=100;

  0005c	e3a03064	 mov         r3, #0x64

; 211  :         pDevice->samplePeriod=40;

  00060	e3a02028	 mov         r2, #0x28

; 212  :         pDevice->debounceTime=0x50;

  00064	e3a01050	 mov         r1, #0x50

; 213  :         pDevice->firstRepeat=500;

  00068	e3a00f7d	 mov         r0, #0x7D, 30

; 214  :         pDevice->nextRepeat=125;

  0006c	e3a0e07d	 mov         lr, #0x7D
  00070	e5843020	 str         r3, [r4, #0x20]
  00074	e5842028	 str         r2, [r4, #0x28]
  00078	e584102c	 str         r1, [r4, #0x2C]
  0007c	e5840030	 str         r0, [r4, #0x30]
  00080	e584e034	 str         lr, [r4, #0x34]
  00084	e5847004	 str         r7, [r4, #4]
  00088	e5848008	 str         r8, [r4, #8]
  0008c	e584600c	 str         r6, [r4, #0xC]
  00090	e5846010	 str         r6, [r4, #0x10]
  00094	e5846014	 str         r6, [r4, #0x14]
  00098	e5846018	 str         r6, [r4, #0x18]
  0009c	e584601c	 str         r6, [r4, #0x1C]
  000a0		 |$LN13@KPD_Init|
  000a0	e3a03312	 mov         r3, #0x12, 6

; 215  : //        goto cleanUp;
; 216  :     }
; 217  : 
; 218  :     // map gpio memory space
; 219  :     pa.QuadPart = OMAP2420_GPIO1_REGS_PA;

  000a4	e3830906	 orr         r0, r3, #6, 18

; 220  :     pDevice->pGPIO1Regs = (OMAP2420_GPIO_REGS *) MmMapIoSpace(pa, sizeof(OMAP2420_GPIO_REGS), FALSE);

  000a8	e3a03000	 mov         r3, #0
  000ac	e3a01000	 mov         r1, #0
  000b0	e3a02098	 mov         r2, #0x98
  000b4	eb000000	 bl          MmMapIoSpace
  000b8	e3500000	 cmp         r0, #0
  000bc	e584004c	 str         r0, [r4, #0x4C]

; 221  :     if (pDevice->pGPIO1Regs == NULL)

  000c0	0a00004b	 beq         |$LN17@KPD_Init|
  000c4	e3a03312	 mov         r3, #0x12, 6

; 222  :     {
; 223  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: Failed to map GPIO1 registers\r\n"));
; 224  :         goto cleanUp;
; 225  :     }
; 226  : 
; 227  :     pa.QuadPart = OMAP2420_GPIO2_REGS_PA;

  000c8	e3830a1a	 orr         r0, r3, #0x1A, 20

; 228  :     pDevice->pGPIO2Regs = (OMAP2420_GPIO_REGS *) MmMapIoSpace(pa, sizeof(OMAP2420_GPIO_REGS), FALSE);

  000cc	e3a03000	 mov         r3, #0
  000d0	e3a01000	 mov         r1, #0
  000d4	e3a02098	 mov         r2, #0x98
  000d8	eb000000	 bl          MmMapIoSpace
  000dc	e3500000	 cmp         r0, #0
  000e0	e5840050	 str         r0, [r4, #0x50]

; 229  :     if (pDevice->pGPIO2Regs == NULL)

  000e4	0a000042	 beq         |$LN17@KPD_Init|
  000e8	e3a03312	 mov         r3, #0x12, 6

; 230  :     {
; 231  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: Failed to map GPIO2 registers\r\n"));
; 232  :         goto cleanUp;
; 233  :     }
; 234  : 
; 235  :     pa.QuadPart = OMAP2420_GPIO3_REGS_PA;

  000ec	e3830907	 orr         r0, r3, #7, 18

; 236  :     pDevice->pGPIO3Regs = (OMAP2420_GPIO_REGS *) MmMapIoSpace(pa, sizeof(OMAP2420_GPIO_REGS), FALSE);

  000f0	e3a03000	 mov         r3, #0
  000f4	e3a01000	 mov         r1, #0
  000f8	e3a02098	 mov         r2, #0x98
  000fc	eb000000	 bl          MmMapIoSpace
  00100	e3500000	 cmp         r0, #0
  00104	e5840054	 str         r0, [r4, #0x54]

; 237  :     if (pDevice->pGPIO3Regs == NULL)

  00108	0a000039	 beq         |$LN17@KPD_Init|
  0010c	e3a03312	 mov         r3, #0x12, 6

; 238  :     {
; 239  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: Failed to map GPIO3 registers\r\n"));
; 240  :         goto cleanUp;
; 241  :     }
; 242  : 
; 243  :     pa.QuadPart = OMAP2420_GPIO4_REGS_PA;

  00110	e3830a1e	 orr         r0, r3, #0x1E, 20

; 244  :     pDevice->pGPIO4Regs = (OMAP2420_GPIO_REGS *) MmMapIoSpace(pa, sizeof(OMAP2420_GPIO_REGS), FALSE);

  00114	e3a03000	 mov         r3, #0
  00118	e3a01000	 mov         r1, #0
  0011c	e3a02098	 mov         r2, #0x98
  00120	eb000000	 bl          MmMapIoSpace
  00124	e3500000	 cmp         r0, #0
  00128	e5840058	 str         r0, [r4, #0x58]

; 245  :     if (pDevice->pGPIO4Regs == NULL)

  0012c	0a000030	 beq         |$LN17@KPD_Init|

; 246  :     {
; 247  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: Failed to map GPIO4 registers\r\n"));
; 248  :         goto cleanUp;
; 249  :     }
; 250  : 
; 251  :     // Need to configure the row GPIO's as interrupt sources
; 252  :     pDevice->irqs[0] = -1;
; 253  :     pDevice->irqs[1] = 2;
; 254  :     //pDevice->irqs[2] = IRQ_GPIO_0+88;	// row 0 = GPIO88
; 255  :     //pDevice->irqs[3] = IRQ_GPIO_0+89;	// row 1 = GPIO89
; 256  :     //pDevice->irqs[4] = IRQ_GPIO_0+124;	// row 2 = GPIO124
; 257  :     //pDevice->irqs[5] = IRQ_GPIO_0+11;	// row 3 = GPIO11
; 258  :     //pDevice->irqs[6] = IRQ_GPIO_0+6;	// row 4 = GPIO6
; 259  : 
; 260  : 
; 261  :     // Map interrupts
; 262  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR,
; 263  :         pDevice->irqs, sizeof(pDevice->irqs),
; 264  :         &pDevice->sysIntr, sizeof(pDevice->sysIntr), NULL
; 265  :     )) {

  00130	e59f00dc	 ldr         r0, [pc, #0xDC]
  00134	e3a0e004	 mov         lr, #4
  00138	e284305c	 add         r3, r4, #0x5C
  0013c	e3a0201c	 mov         r2, #0x1C
  00140	e2841004	 add         r1, r4, #4
  00144	e5847004	 str         r7, [r4, #4]
  00148	e5848008	 str         r8, [r4, #8]
  0014c	e58d6004	 str         r6, [sp, #4]
  00150	e58de000	 str         lr, [sp]
  00154	eb000000	 bl          KernelIoControl
  00158	e3500000	 cmp         r0, #0
  0015c	0a000024	 beq         |$LN17@KPD_Init|

; 266  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 267  :             L"Failed map Keyboard Interrupt\r\n"
; 268  :         ));
; 269  :         goto cleanUp;
; 270  :     } else DEBUGMSG(ZONE_INIT, (L"KPD_Init: sysintr = %d",pDevice->sysIntr));
; 271  : 
; 272  :     // Enable wakeup from keyboard if required
; 273  :     if (pDevice->enableWake != 0) {

  00160	e5943024	 ldr         r3, [r4, #0x24]
  00164	e3530000	 cmp         r3, #0

; 274  :         DEBUGMSG(ZONE_ERROR, (L"Enable keyboard as wakeup source\r\n"));
; 275  :         if (!KernelIoControl(
; 276  :             IOCTL_HAL_ENABLE_WAKE, &pDevice->sysIntr, sizeof(pDevice->sysIntr),
; 277  :             NULL, 0, NULL
; 278  :         )) {

  00168	159f00a0	 ldrne       r0, [pc, #0xA0]
  0016c	13a03000	 movne       r3, #0
  00170	13a02004	 movne       r2, #4
  00174	1284105c	 addne       r1, r4, #0x5C
  00178	158d6004	 strne       r6, [sp, #4]
  0017c	158d6000	 strne       r6, [sp]
  00180	1b000000	 blne        KernelIoControl

; 279  :             DEBUGMSG(ZONE_WARN, (L"WARN: KPD_Init: "
; 280  :                 L"Failed enable keyboard as wakeup source\r\n"
; 281  :             ));
; 282  :         }
; 283  :     }
; 284  : 
; 285  :     // Create interrupt event
; 286  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00184	e3a03000	 mov         r3, #0
  00188	e3a02000	 mov         r2, #0
  0018c	e3a01000	 mov         r1, #0
  00190	e3a00000	 mov         r0, #0
  00194	eb000000	 bl          CreateEventW
  00198	e1b01000	 movs        r1, r0
  0019c	e5841060	 str         r1, [r4, #0x60]

; 287  :     if (pDevice->hIntrEvent == NULL) {

  001a0	0a000013	 beq         |$LN17@KPD_Init|

; 288  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 289  :             L"Failed create interrupt event\r\n"
; 290  :         ));
; 291  :         goto cleanUp;
; 292  :     }
; 293  : 
; 294  :     // Initialize interrupt
; 295  :     if (!InterruptInitialize(pDevice->sysIntr, pDevice->hIntrEvent, NULL, 0)) {

  001a4	e594005c	 ldr         r0, [r4, #0x5C]
  001a8	e3a03000	 mov         r3, #0
  001ac	e3a02000	 mov         r2, #0
  001b0	eb000000	 bl          InterruptInitialize
  001b4	e3500000	 cmp         r0, #0
  001b8	0a00000d	 beq         |$LN17@KPD_Init|

; 296  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 297  :             L"InterruptInitialize failed\r\n"
; 298  :         ));
; 299  :         goto cleanUp;
; 300  :     }
; 301  :     // Start interrupt service thread
; 302  :     if ((pDevice->hIntrThread = CreateThread(
; 303  :         NULL, 0, KPD_IntrThread, pDevice, 0,NULL
; 304  :     )) == NULL) {

  001bc	e59f2048	 ldr         r2, [pc, #0x48]
  001c0	e1a03004	 mov         r3, r4
  001c4	e3a01000	 mov         r1, #0
  001c8	e3a00000	 mov         r0, #0
  001cc	e58d6004	 str         r6, [sp, #4]
  001d0	e58d6000	 str         r6, [sp]
  001d4	eb000000	 bl          CreateThread
  001d8	e3500000	 cmp         r0, #0
  001dc	e5840064	 str         r0, [r4, #0x64]
  001e0	0a000003	 beq         |$LN17@KPD_Init|

; 305  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 306  :             L"Failed create interrupt thread\r\n"
; 307  :         ));
; 308  :         goto cleanUp;
; 309  :     }
; 310  :     // Set thread priority
; 311  :     CeSetThreadPriority(pDevice->hIntrThread, pDevice->priority256);

  001e4	e5941020	 ldr         r1, [r4, #0x20]
  001e8	eb000000	 bl          CeSetThreadPriority

; 312  : 
; 313  :     // Return non-null value
; 314  :     rc = (DWORD)pDevice;

  001ec	e1a05004	 mov         r5, r4
  001f0		 |$cleanUp$42856|

; 315  : 
; 316  : cleanUp:
; 317  :     if (rc == 0) KPD_Deinit((DWORD)pDevice);

  001f0	ea000001	 b           |$LN1@KPD_Init|
  001f4		 |$LN17@KPD_Init|
  001f4	e1a00004	 mov         r0, r4
  001f8	eb000000	 bl          KPD_Deinit
  001fc		 |$LN1@KPD_Init|

; 318  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_Init(rc = %d\r\n", rc));
; 319  : 
; 320  :     return rc;
; 321  : }

  001fc	e1a00005	 mov         r0, r5
  00200	e28dd008	 add         sp, sp, #8
  00204	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00208	e12fff1e	 bx          lr
  0020c		 |$LN21@KPD_Init|
  0020c		 |$LN22@KPD_Init|
  0020c	00000000	 DCD         |KPD_IntrThread|
  00210		 |$LN23@KPD_Init|
  00210	010100a0	 DCD         0x10100a0
  00214		 |$LN24@KPD_Init|
  00214	01010098	 DCD         0x1010098
  00218		 |$LN25@KPD_Init|
  00218	00000000	 DCD         |g_deviceRegParams|
  0021c		 |$LN26@KPD_Init|
  0021c	6b706444	 DCD         0x6b706444
  00220		 |$M43466|

			 ENDP  ; |KPD_Init|

	END
