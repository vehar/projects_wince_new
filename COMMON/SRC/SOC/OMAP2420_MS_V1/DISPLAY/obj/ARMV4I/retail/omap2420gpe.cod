; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\DISPLAY\omap2420gpe.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1EO@BHDHHEGO@?$AA?$HL?$AAE?$AAB?$AA9?$AA1?$AAC?$AA7?$AAC?$AA9?$AA?9?$AA8?$AAB?$AAF?$AA6?$AA?9?$AA4?$AAa?$AA2?$AAd?$AA?9?$AA9?$AAA?$AAB?$AA8?$AA?9?$AA6?$AA9?$AA7?$AA2?$AA4?$AAE?$AAE@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CE@LGAKADBG@?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAP?$AAo?$AAw?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@FBNLNLFG@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAD?$AAe?$AAl?$AAa?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17JBHIEIFL@?$AAB?$AAp?$AAp?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|DEVICE_IFC_I2C_GUID| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|g_bitMasks| %	0xc

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@BHDHHEGO@?$AA?$HL?$AAE?$AAB?$AA9?$AA1?$AAC?$AA7?$AAC?$AA9?$AA?9?$AA8?$AAB?$AAF?$AA6?$AA?9?$AA4?$AAa?$AA2?$AAd?$AA?9?$AA9?$AAA?$AAB?$AA8?$AA?9?$AA6?$AA9?$AA7?$AA2?$AA4?$AAE?$AAE@| DCB "{"
	DCB	0x0, "E", 0x0, "B", 0x0, "9", 0x0, "1", 0x0, "C", 0x0, "7"
	DCB	0x0, "C", 0x0, "9", 0x0, "-", 0x0, "8", 0x0, "B", 0x0, "F"
	DCB	0x0, "6", 0x0, "-", 0x0, "4", 0x0, "a", 0x0, "2", 0x0, "d"
	DCB	0x0, "-", 0x0, "9", 0x0, "A", 0x0, "B", 0x0, "8", 0x0, "-"
	DCB	0x0, "6", 0x0, "9", 0x0, "7", 0x0, "2", 0x0, "4", 0x0, "E"
	DCB	0x0, "E", 0x0, "D", 0x0, "9", 0x0, "7", 0x0, "D", 0x0, "1"
	DCB	0x0, "}", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@LGAKADBG@?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAP?$AAo?$AAw?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@| DCB "D"
	DCB	0x0, "i", 0x0, "s", 0x0, "p", 0x0, "l", 0x0, "a", 0x0, "y"
	DCB	0x0, "P", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "C"
	DCB	0x0, "l", 0x0, "a", 0x0, "s", 0x0, "s", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@FBNLNLFG@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAD?$AAe?$AAl?$AAa?$AAy?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "D", 0x0, "e"
	DCB	0x0, "l", 0x0, "a", 0x0, "y", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17JBHIEIFL@?$AAB?$AAp?$AAp?$AA?$AA@| DCB "B", 0x0, "p", 0x0, "p", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| DCB "M", 0x0, "e"
	DCB	0x0, "m", 0x0, "L", 0x0, "e", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "M", 0x0
	DCB	"e", 0x0, "m", 0x0, "B", 0x0, "a", 0x0, "s", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
	%	16
|FourCCDescriptionTable| DCD 0x32595559
	DCD	0x10
	DCD	0xff00ff
	DCD	0xff00
	DCD	0xff000000
	DCD	0x56595559
	DCD	0x10
	DCD	0xff00ff
	DCD	0xff00
	DCD	0xff000000
	DCD	0x55595659
	DCD	0x10
	DCD	0xff00ff00
	DCD	0xff
	DCD	0xff0000
	DCD	0x59565955
	DCD	0x10
	DCD	0xff00ff00
	DCD	0xff
	DCD	0xff0000
	DCD	0x36315659
	DCD	0x10
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x32315659
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x3231564e
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x30323449
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0x56555949
	DCD	0xc
	DCD	0xffffffff
	DCD	0xffffffff
	DCD	0xffffffff
	%	4
|g_deviceRegParams| DCD |??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
	DCD	0x3
	DCD	0x1
	DCD	0x40
	DCD	0x14
	DCD	0x0
	DCD	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@|
	DCD	0x3
	DCD	0x1
	DCD	0x54
	DCD	0x14
	DCD	0x0
	DCD	|??_C@_17JBHIEIFL@?$AAB?$AAp?$AAp?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x68
	DCD	0x4
	DCD	0x10
	DCD	|??_C@_1BG@FBNLNLFG@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAD?$AAe?$AAl?$AAa?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x74
	DCD	0x4
	DCD	0xffffffff
	DCD	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x78
	DCD	0x4
	DCD	0xfc
	DCD	|??_C@_1CE@LGAKADBG@?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAP?$AAo?$AAw?$AAe?$AAr?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@|
	DCD	0x2
	DCD	0x0
	DCD	0x70
	DCD	0x0
	DCD	|??_C@_1EO@BHDHHEGO@?$AA?$HL?$AAE?$AAB?$AA9?$AA1?$AAC?$AA7?$AAC?$AA9?$AA?9?$AA8?$AAB?$AAF?$AA6?$AA?9?$AA4?$AAa?$AA2?$AAd?$AA?9?$AA9?$AAA?$AAB?$AA8?$AA?9?$AA6?$AA9?$AA7?$AA2?$AA4?$AAE?$AAE@|
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42733| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42730|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42731|

			 ENDP  ; |SetEvent|

	EXPORT	|?Stride@GPESurf@@QAAHXZ|		; GPESurf::Stride
; File c:\wince600\public\common\oak\inc\gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T42743| DCD	|$LN5@Stride|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Stride@GPESurf@@QAAHXZ| PROC		; GPESurf::Stride

; 177  :     {

  00000		 |$LN5@Stride|
  00000		 |$M42740|

; 178  :         return m_nStrideBytes;

  00000	e5900008	 ldr         r0, [r0, #8]

; 179  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42741|

			 ENDP  ; |?Stride@GPESurf@@QAAHXZ|, GPESurf::Stride

	EXPORT	|?Format@GPESurf@@QAA?AW4EGPEFormat@@XZ| ; GPESurf::Format

  00000			 AREA	 |.pdata|, PDATA
|$T42753| DCD	|$LN5@Format|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Format@GPESurf@@QAA?AW4EGPEFormat@@XZ| PROC ; GPESurf::Format

; 189  :     {

  00000		 |$LN5@Format|
  00000		 |$M42750|

; 190  :         return m_eFormat;

  00000	e590001c	 ldr         r0, [r0, #0x1C]

; 191  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42751|

			 ENDP  ; |?Format@GPESurf@@QAA?AW4EGPEFormat@@XZ|, GPESurf::Format

	EXPORT	|?Buffer@GPESurf@@QAAPAXXZ|		; GPESurf::Buffer

  00000			 AREA	 |.pdata|, PDATA
|$T42763| DCD	|$LN5@Buffer|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Buffer@GPESurf@@QAAPAXXZ| PROC	; GPESurf::Buffer

; 201  :     {

  00000		 |$LN5@Buffer|
  00000		 |$M42760|

; 202  :         return (void *)m_pVirtAddr;

  00000	e5900004	 ldr         r0, [r0, #4]

; 203  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42761|

			 ENDP  ; |?Buffer@GPESurf@@QAAPAXXZ|, GPESurf::Buffer

	EXPORT	|?Width@GPESurf@@QAAHXZ|		; GPESurf::Width

  00000			 AREA	 |.pdata|, PDATA
|$T42773| DCD	|$LN5@Width|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Width@GPESurf@@QAAHXZ| PROC		; GPESurf::Width

; 207  :     {

  00000		 |$LN5@Width|
  00000		 |$M42770|

; 208  :         return m_nWidth;

  00000	e590002c	 ldr         r0, [r0, #0x2C]

; 209  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42771|

			 ENDP  ; |?Width@GPESurf@@QAAHXZ|, GPESurf::Width

	EXPORT	|?Height@GPESurf@@QAAHXZ|		; GPESurf::Height

  00000			 AREA	 |.pdata|, PDATA
|$T42783| DCD	|$LN5@Height|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Height@GPESurf@@QAAHXZ| PROC		; GPESurf::Height

; 213  :     {

  00000		 |$LN5@Height|
  00000		 |$M42780|

; 214  :         return m_nHeight;

  00000	e5900030	 ldr         r0, [r0, #0x30]

; 215  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42781|

			 ENDP  ; |?Height@GPESurf@@QAAHXZ|, GPESurf::Height

	EXPORT	|?OffsetInVideoMemory@GPESurf@@QAAKXZ|	; GPESurf::OffsetInVideoMemory

  00000			 AREA	 |.pdata|, PDATA
|$T42793| DCD	|$LN5@OffsetInVi|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OffsetInVideoMemory@GPESurf@@QAAKXZ| PROC ; GPESurf::OffsetInVideoMemory

; 239  :     {

  00000		 |$LN5@OffsetInVi|
  00000		 |$M42790|

; 240  :         return m_nOffsetInVideoMemory;

  00000	e5900034	 ldr         r0, [r0, #0x34]

; 241  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42791|

			 ENDP  ; |?OffsetInVideoMemory@GPESurf@@QAAKXZ|, GPESurf::OffsetInVideoMemory

	EXPORT	|?Rotate@GPESurf@@QAAHXZ|		; GPESurf::Rotate

  00000			 AREA	 |.pdata|, PDATA
|$T42803| DCD	|$LN5@Rotate|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Rotate@GPESurf@@QAAHXZ| PROC		; GPESurf::Rotate

; 257  :     {

  00000		 |$LN5@Rotate|
  00000		 |$M42800|

; 258  :         return m_iRotate;

  00000	e5900038	 ldr         r0, [r0, #0x38]

; 259  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M42801|

			 ENDP  ; |?Rotate@GPESurf@@QAAHXZ|, GPESurf::Rotate

	EXPORT	|?IsOverlay@DDGPESurf@@QAAHXZ|		; DDGPESurf::IsOverlay
; File c:\wince600\public\common\oak\inc\ddgpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T42813| DCD	|$LN5@IsOverlay|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsOverlay@DDGPESurf@@QAAHXZ| PROC	; DDGPESurf::IsOverlay

; 313  : 	{

  00000		 |$LN5@IsOverlay|
  00000		 |$M42810|

; 314  : 		return m_bOverlay; 

  00000	e5900060	 ldr         r0, [r0, #0x60]

; 315  : 	}

  00004	e12fff1e	 bx          lr
  00008		 |$M42811|

			 ENDP  ; |?IsOverlay@DDGPESurf@@QAAHXZ|, DDGPESurf::IsOverlay

	EXPORT	|DrvEnableDriver|
	IMPORT	|?GPEEnableDriver@@YAHKKPAUtagDrvEnableData@@PAU_ENGCALLBACKS@@@Z| ; GPEEnableDriver
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T42826| DCD	|$LN5@DrvEnableD|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DrvEnableDriver| PROC

; 160  : {

  00000		 |$LN5@DrvEnableD|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42823|

; 161  :     BOOL rc;
; 162  : 
; 163  :     DEBUGMSG(GPE_ZONE_PDD, (L"+DrvEnableDriver(0x%08x, %d, 0x%08x, 0x%08x)\r\n", 
; 164  :         version, cj, pData, pCallbacks
; 165  :     ));
; 166  : 
; 167  :     rc = GPEEnableDriver(version, cj, pData, pCallbacks);

  00004	eb000000	 bl          |?GPEEnableDriver@@YAHKKPAUtagDrvEnableData@@PAU_ENGCALLBACKS@@@Z|

; 168  : 
; 169  :     DEBUGMSG(GPE_ZONE_PDD, (L"-DrvEnableDriver(rc = %d)\r\n", rc));
; 170  :     return rc;
; 171  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M42824|

			 ENDP  ; |DrvEnableDriver|

	EXPORT	|DrvGetMasks|

  00000			 AREA	 |.pdata|, PDATA
|$T42835| DCD	|$LN5@DrvGetMask|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DrvGetMasks| PROC

; 178  : {

  00000		 |$LN5@DrvGetMask|
  00000		 |$M42832|

; 179  :     return g_bitMasks;

  00000	e59f0000	 ldr         r0, [pc]

; 180  : }

  00004	e12fff1e	 bx          lr
  00008		 |$LN6@DrvGetMask|
  00008		 |$LN7@DrvGetMask|
  00008	00000000	 DCD         |g_bitMasks|
  0000c		 |$M42833|

			 ENDP  ; |DrvGetMasks|

	EXPORT	|GetGPE|

  0000c			 AREA	 |.bss|, NOINIT
|g_pGPE| %	0x4
|g_pGPE| %	0x4

  00000			 AREA	 |.pdata|, PDATA
|$T42846| DCD	|$LN5@GetGPE|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetGPE| PROC

; 190  : {

  00000		 |$LN5@GetGPE|
  00000		 |$M42843|

; 191  :     return g_pGPE;

  00000	e59f3004	 ldr         r3, [pc, #4]
  00004	e5930000	 ldr         r0, [r3]

; 192  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$LN6@GetGPE|
  0000c		 |$LN7@GetGPE|
  0000c	00000000	 DCD         |g_pGPE|
  00010		 |$M42844|

			 ENDP  ; |GetGPE|

	EXPORT	|??_C@_1GI@LBPPMOKF@?$AA?$HL?$AA?$CF?$AA0?$AA8?$AAl?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0?$AA2?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0@| [ DATA ] ; `string'
	IMPORT	|swscanf|

  00000			 AREA	 |.pdata|, PDATA
|$T42864| DCD	|$LN13@ConvertStr|
	DCD	0x40002c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@LBPPMOKF@?$AA?$HL?$AA?$CF?$AA0?$AA8?$AAl?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0?$AA2?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0@| DCB "{"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "l", 0x0, "X", 0x0, "-"
	DCB	0x0, "%", 0x0, "0", 0x0, "4", 0x0, "X", 0x0, "-", 0x0, "%"
	DCB	0x0, "0", 0x0, "4", 0x0, "X", 0x0, "-", 0x0, "%", 0x0, "0"
	DCB	0x0, "2", 0x0, "X", 0x0, "%", 0x0, "0", 0x0, "2", 0x0, "X"
	DCB	0x0, "-", 0x0, "%", 0x0, "0", 0x0, "2", 0x0, "X", 0x0, "%"
	DCB	0x0, "0", 0x0, "2", 0x0, "X", 0x0, "%", 0x0, "0", 0x0, "2"
	DCB	0x0, "X", 0x0, "%", 0x0, "0", 0x0, "2", 0x0, "X", 0x0, "%"
	DCB	0x0, "0", 0x0, "2", 0x0, "X", 0x0, "%", 0x0, "0", 0x0, "2"
	DCB	0x0, "X", 0x0, "}", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ConvertStringToGuid| PROC

; 199  : {

  00000		 |$LN13@ConvertStr|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd048	 sub         sp, sp, #0x48
  00008		 |$M42861|
  00008	e1a02001	 mov         r2, r1
  0000c	e58d2024	 str         r2, [sp, #0x24]

; 200  :     BOOL rc = FALSE;
; 201  :     int idx, data4[8];
; 202  :     const LPWSTR fmt = L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}";
; 203  : 
; 204  :     if (swscanf(
; 205  :         szGuid, fmt, &pGuid->Data1, &pGuid->Data2, &pGuid->Data3, 
; 206  :         &data4[0], &data4[1], &data4[2], &data4[3], 
; 207  :         &data4[4], &data4[5], &data4[6], &data4[7]
; 208  :     ) != 11) goto cleanUp;

  00010	e59f1094	 ldr         r1, [pc, #0x94]
  00014	e28d4040	 add         r4, sp, #0x40
  00018	e28d503c	 add         r5, sp, #0x3C
  0001c	e28d6038	 add         r6, sp, #0x38
  00020	e28d7034	 add         r7, sp, #0x34
  00024	e28d8030	 add         r8, sp, #0x30
  00028	e28d902c	 add         r9, sp, #0x2C
  0002c	e28da028	 add         r10, sp, #0x28
  00030	e282b006	 add         r11, r2, #6
  00034	e28de044	 add         lr, sp, #0x44
  00038	e2823004	 add         r3, r2, #4
  0003c	e58de020	 str         lr, [sp, #0x20]
  00040	e58d401c	 str         r4, [sp, #0x1C]
  00044	e58d5018	 str         r5, [sp, #0x18]
  00048	e58d6014	 str         r6, [sp, #0x14]
  0004c	e58d7010	 str         r7, [sp, #0x10]
  00050	e58d800c	 str         r8, [sp, #0xC]
  00054	e58d9008	 str         r9, [sp, #8]
  00058	e58da004	 str         r10, [sp, #4]
  0005c	e58db000	 str         r11, [sp]
  00060	eb000000	 bl          swscanf
  00064	e350000b	 cmp         r0, #0xB
  00068	1a00000a	 bne         |$LN10@ConvertStr|

; 209  : 
; 210  :     for (idx = 0; idx < dimof(data4); idx++) {
; 211  :         pGuid->Data4[idx] = (UCHAR)data4[idx];
; 212  :     }
; 213  : 
; 214  :     rc = TRUE;

  0006c	e59de024	 ldr         lr, [sp, #0x24]
  00070	e3a01000	 mov         r1, #0
  00074	e28d0028	 add         r0, sp, #0x28
  00078		 |$LL3@ConvertStr|
  00078	e4902004	 ldr         r2, [r0], #4
  0007c	e081300e	 add         r3, r1, lr
  00080	e2811001	 add         r1, r1, #1
  00084	e3510008	 cmp         r1, #8
  00088	e5c32008	 strb        r2, [r3, #8]
  0008c	3afffff9	 bcc         |$LL3@ConvertStr|
  00090	e3a03001	 mov         r3, #1
  00094	ea000000	 b           |$cleanUp$41743|
  00098		 |$LN10@ConvertStr|
  00098	e3a03000	 mov         r3, #0
  0009c		 |$cleanUp$41743|

; 215  : 
; 216  : cleanUp:
; 217  :     return rc;
; 218  : }

  0009c	e1a00003	 mov         r0, r3
  000a0	e28dd048	 add         sp, sp, #0x48
  000a4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN14@ConvertStr|
  000ac		 |$LN15@ConvertStr|
  000ac	00000000	 DCD         |??_C@_1GI@LBPPMOKF@?$AA?$HL?$AA?$CF?$AA0?$AA8?$AAl?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0?$AA2?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0@|
  000b0		 |$M42862|

			 ENDP  ; |ConvertStringToGuid|

	EXPORT	|??0OMAP2420GPE@@QAA@XZ|		; OMAP2420GPE::OMAP2420GPE
	EXPORT	|??_7OMAP2420GPE@@6B@| [ DATA ]		; OMAP2420GPE::`vftable'
	EXPORT	|?BltPrepare@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z| ; OMAP2420GPE::BltPrepare
	EXPORT	|?BltComplete@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z| ; OMAP2420GPE::BltComplete
	EXPORT	|?Line@OMAP2420GPE@@UAAJPAUGPELineParms@@W4EGPEPhase@@@Z| ; OMAP2420GPE::Line
	EXPORT	|?AllocSurface@OMAP2420GPE@@UAAJPAPAVGPESurf@@HHW4EGPEFormat@@H@Z| ; OMAP2420GPE::AllocSurface
	EXPORT	|?SetPointerShape@OMAP2420GPE@@UAAJPAVGPESurf@@0HHHH@Z| ; OMAP2420GPE::SetPointerShape
	EXPORT	|?MovePointer@OMAP2420GPE@@UAAJHH@Z|	; OMAP2420GPE::MovePointer
	EXPORT	|?SetPalette@OMAP2420GPE@@UAAJPBUtagPALETTEENTRY@@GG@Z| ; OMAP2420GPE::SetPalette
	EXPORT	|?GetModeInfo@OMAP2420GPE@@UAAJPAUGPEMode@@H@Z| ; OMAP2420GPE::GetModeInfo
	EXPORT	|?NumModes@OMAP2420GPE@@UAAHXZ|		; OMAP2420GPE::NumModes
	EXPORT	|?SetMode@OMAP2420GPE@@UAAJHPAPAUHPALETTE__@@@Z| ; OMAP2420GPE::SetMode
	EXPORT	|?InVBlank@OMAP2420GPE@@UAAHXZ|		; OMAP2420GPE::InVBlank
	EXPORT	|?PowerHandler@OMAP2420GPE@@UAAXH@Z|	; OMAP2420GPE::PowerHandler
	EXPORT	|?DrvEscape@OMAP2420GPE@@UAAKPAU_SURFOBJ@@KKPAXK1@Z| ; OMAP2420GPE::DrvEscape
	EXPORT	|?SurfaceBusyFlipping@OMAP2420GPE@@UAAHPAVGPESurf@@@Z| ; OMAP2420GPE::SurfaceBusyFlipping
	EXPORT	|?AllocSurface@OMAP2420GPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@H@Z| ; OMAP2420GPE::AllocSurface
	EXPORT	|?SetVisibleSurface@OMAP2420GPE@@UAAXPAVGPESurf@@KH@Z| ; OMAP2420GPE::SetVisibleSurface
	EXPORT	|?GetPhysicalModeId@DDGPE@@UAAKXZ|	; DDGPE::GetPhysicalModeId
	EXPORT	|?GetDriverData@DDGPE@@UAAPAUDDGPEDriverData@@XZ| ; DDGPE::GetDriverData
	EXPORT	|?SetDriverData@DDGPE@@UAAXPAUDDGPEDriverData@@@Z| ; DDGPE::SetDriverData
	IMPORT	|InitializeCriticalSection|
	IMPORT	|??0DDGPE@@QAA@XZ|			; DDGPE::DDGPE
	IMPORT	|??_EOMAP2420GPE@@UAAPAXI@Z|, WEAK |??_GOMAP2420GPE@@UAAPAXI@Z| ; OMAP2420GPE::`vector deleting destructor', OMAP2420GPE::`scalar deleting destructor'
	IMPORT	|?GetPalette@GPE@@UAAJPAPAUtagPALETTEENTRY@@PAG@Z| ; GPE::GetPalette
	IMPORT	|?IsPaletteSettable@GPE@@UAAHXZ|	; GPE::IsPaletteSettable
	IMPORT	|?ContrastControl@GPE@@UAAHKPAK@Z|	; GPE::ContrastControl
	IMPORT	|?GetGraphicsCaps@GPE@@UAAKXZ|		; GPE::GetGraphicsCaps
	IMPORT	|?GetPhysicalVideoMemory@GPE@@UAAXPAK0@Z| ; GPE::GetPhysicalVideoMemory
	IMPORT	|?SetVisibleSurface@GPE@@UAAXPAVGPESurf@@@Z| ; GPE::SetVisibleSurface
	IMPORT	|?FlipInProgress@GPE@@UAAHXZ|		; GPE::FlipInProgress
	IMPORT	|?WaitForVBlank@GPE@@UAAXXZ|		; GPE::WaitForVBlank
	IMPORT	|?IsBusy@GPE@@UAAHXZ|			; GPE::IsBusy
	IMPORT	|?WaitForNotBusy@GPE@@UAAXXZ|		; GPE::WaitForNotBusy
	IMPORT	|?AvailableVideoMemory@GPE@@UAAKXZ|	; GPE::AvailableVideoMemory
	IMPORT	|?ScanLine@GPE@@UAAHXZ|			; GPE::ScanLine
	IMPORT	|?ProcessCommandBlock@GPE@@UAAJPAE@Z|	; GPE::ProcessCommandBlock
	IMPORT	|?GetScreenDimensions@GPE@@UAAHPAUGPEScreenProps@@@Z| ; GPE::GetScreenDimensions
	IMPORT	|?GetClearTypeRGBMasks@GPE@@UAAPAKXZ|	; GPE::GetClearTypeRGBMasks
	IMPORT	|?DisablePrimary@GPE@@UAAHXZ|		; GPE::DisablePrimary
	IMPORT	|?AllocSurface@DDGPE@@UAAJPAPAVDDGPESurf@@PAUDDGPEAllocSurfaceData@@@Z| ; DDGPE::AllocSurface
	IMPORT	|?AllocVideoSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@PAUDDGPEAllocSurfaceData@@PAK@Z| ; DDGPE::AllocVideoSurface
	IMPORT	|?AllocVideoSurface@DDGPE@@UAAJPAPAVDDGPESurf@@PAUDDGPEAllocSurfaceData@@PAK@Z| ; DDGPE::AllocVideoSurface
	IMPORT	|?AllocVideoSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAK@Z| ; DDGPE::AllocVideoSurface
	IMPORT	|?AllocVideoSurface@DDGPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAK@Z| ; DDGPE::AllocVideoSurface
	IMPORT	|?AllocBackBuffer@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@@Z| ; DDGPE::AllocBackBuffer
	IMPORT	|?WrapSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@PAUDDGPEAllocSurfaceData@@@Z| ; DDGPE::WrapSurface
	IMPORT	|?WrapSurface@DDGPE@@UAAJPAPAVDDGPESurf@@PAUDDGPEAllocSurfaceData@@@Z| ; DDGPE::WrapSurface
	IMPORT	|?WrapSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAEH@Z| ; DDGPE::WrapSurface
	IMPORT	|?WrapSurface@DDGPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAEH@Z| ; DDGPE::WrapSurface
	IMPORT	|?WrapSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@HH@Z| ; DDGPE::WrapSurface
	IMPORT	|?BltPrepare@DDGPE@@UAAJPAUDDGPEBltParms@@@Z| ; DDGPE::BltPrepare
	IMPORT	|?PerformBlt@DDGPE@@UAAJPAUDDGPEBltParms@@@Z| ; DDGPE::PerformBlt
	IMPORT	|?BltExpanded@DDGPE@@UAAJPAVDDGPESurf@@00PBUtagRECT@@1KKK@Z| ; DDGPE::BltExpanded
	IMPORT	|?BltExpanded@DDGPE@@UAAJPAVDDGPESurf@@000PAU_CLIPOBJ@@PAU_XLATEOBJ@@PBUtagRECT@@3KKK@Z| ; DDGPE::BltExpanded
	IMPORT	|?SetVisibleSurface@DDGPE@@UAAXPAVGPESurf@@H@Z| ; DDGPE::SetVisibleSurface
	IMPORT	|?DetectMode@DDGPE@@UAAJPAKKKW4EGPEFormat@@W4EDDGPEPixelFormat@@PAU_DDPIXELFORMAT@@@Z| ; DDGPE::DetectMode
	IMPORT	|?DetectPixelFormat@DDGPE@@UAAJKPAU_DDPIXELFORMAT@@PAW4EGPEFormat@@PAW4EDDGPEPixelFormat@@@Z| ; DDGPE::DetectPixelFormat
	IMPORT	|?InDisplay@DDGPE@@UAAHXZ|		; DDGPE::InDisplay
	IMPORT	|?GetModeInfoEx@DDGPE@@UAAJPAUGPEModeEx@@H@Z| ; DDGPE::GetModeInfoEx
	IMPORT	|?SetMode@DDGPE@@UAAJHPAPAUHPALETTE__@@H@Z| ; DDGPE::SetMode

  00000			 AREA	 |.pdata|, PDATA
|$T42876| DCD	|$LN5@OMAP2420GP|
	DCD	0x40001101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAP2420GPE@@6B@| DCD |??_EOMAP2420GPE@@UAAPAXI@Z|	; OMAP2420GPE::`vftable'
	DCD	|?BltPrepare@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z|
	DCD	|?BltComplete@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z|
	DCD	|?Line@OMAP2420GPE@@UAAJPAUGPELineParms@@W4EGPEPhase@@@Z|
	DCD	|?AllocSurface@OMAP2420GPE@@UAAJPAPAVGPESurf@@HHW4EGPEFormat@@H@Z|
	DCD	|?SetPointerShape@OMAP2420GPE@@UAAJPAVGPESurf@@0HHHH@Z|
	DCD	|?MovePointer@OMAP2420GPE@@UAAJHH@Z|
	DCD	|?SetPalette@OMAP2420GPE@@UAAJPBUtagPALETTEENTRY@@GG@Z|
	DCD	|?GetPalette@GPE@@UAAJPAPAUtagPALETTEENTRY@@PAG@Z|
	DCD	|?GetModeInfo@OMAP2420GPE@@UAAJPAUGPEMode@@H@Z|
	DCD	|?NumModes@OMAP2420GPE@@UAAHXZ|
	DCD	|?SetMode@OMAP2420GPE@@UAAJHPAPAUHPALETTE__@@@Z|
	DCD	|?InVBlank@OMAP2420GPE@@UAAHXZ|
	DCD	|?IsPaletteSettable@GPE@@UAAHXZ|
	DCD	|?ContrastControl@GPE@@UAAHKPAK@Z|
	DCD	|?PowerHandler@OMAP2420GPE@@UAAXH@Z|
	DCD	|?DrvEscape@OMAP2420GPE@@UAAKPAU_SURFOBJ@@KKPAXK1@Z|
	DCD	|?GetGraphicsCaps@GPE@@UAAKXZ|
	DCD	|?GetPhysicalVideoMemory@GPE@@UAAXPAK0@Z|
	DCD	|?SetVisibleSurface@GPE@@UAAXPAVGPESurf@@@Z|
	DCD	|?FlipInProgress@GPE@@UAAHXZ|
	DCD	|?WaitForVBlank@GPE@@UAAXXZ|
	DCD	|?SurfaceBusyFlipping@OMAP2420GPE@@UAAHPAVGPESurf@@@Z|
	DCD	|?IsBusy@GPE@@UAAHXZ|
	DCD	|?WaitForNotBusy@GPE@@UAAXXZ|
	DCD	|?AvailableVideoMemory@GPE@@UAAKXZ|
	DCD	|?ScanLine@GPE@@UAAHXZ|
	DCD	|?ProcessCommandBlock@GPE@@UAAJPAE@Z|
	DCD	|?GetScreenDimensions@GPE@@UAAHPAUGPEScreenProps@@@Z|
	DCD	|?GetClearTypeRGBMasks@GPE@@UAAPAKXZ|
	DCD	|?DisablePrimary@GPE@@UAAHXZ|
	DCD	|?AllocSurface@DDGPE@@UAAJPAPAVDDGPESurf@@PAUDDGPEAllocSurfaceData@@@Z|
	DCD	|?AllocSurface@OMAP2420GPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@H@Z|
	DCD	|?AllocVideoSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@PAUDDGPEAllocSurfaceData@@PAK@Z|
	DCD	|?AllocVideoSurface@DDGPE@@UAAJPAPAVDDGPESurf@@PAUDDGPEAllocSurfaceData@@PAK@Z|
	DCD	|?AllocVideoSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAK@Z|
	DCD	|?AllocVideoSurface@DDGPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAK@Z|
	DCD	|?AllocBackBuffer@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@@Z|
	DCD	|?WrapSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@PAUDDGPEAllocSurfaceData@@@Z|
	DCD	|?WrapSurface@DDGPE@@UAAJPAPAVDDGPESurf@@PAUDDGPEAllocSurfaceData@@@Z|
	DCD	|?WrapSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAEH@Z|
	DCD	|?WrapSurface@DDGPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@PAEH@Z|
	DCD	|?WrapSurface@DDGPE@@UAAJPAU_DDRAWI_DDRAWSURFACE_LCL@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@HH@Z|
	DCD	|?BltPrepare@DDGPE@@UAAJPAUDDGPEBltParms@@@Z|
	DCD	|?PerformBlt@DDGPE@@UAAJPAUDDGPEBltParms@@@Z|
	DCD	|?BltExpanded@DDGPE@@UAAJPAVDDGPESurf@@00PBUtagRECT@@1KKK@Z|
	DCD	|?BltExpanded@DDGPE@@UAAJPAVDDGPESurf@@000PAU_CLIPOBJ@@PAU_XLATEOBJ@@PBUtagRECT@@3KKK@Z|
	DCD	|?SetVisibleSurface@OMAP2420GPE@@UAAXPAVGPESurf@@KH@Z|
	DCD	|?SetVisibleSurface@DDGPE@@UAAXPAVGPESurf@@H@Z|
	DCD	|?DetectMode@DDGPE@@UAAJPAKKKW4EGPEFormat@@W4EDDGPEPixelFormat@@PAU_DDPIXELFORMAT@@@Z|
	DCD	|?DetectPixelFormat@DDGPE@@UAAJKPAU_DDPIXELFORMAT@@PAW4EGPEFormat@@PAW4EDDGPEPixelFormat@@@Z|
	DCD	|?GetPhysicalModeId@DDGPE@@UAAKXZ|
	DCD	|?InDisplay@DDGPE@@UAAHXZ|
	DCD	|?GetModeInfoEx@DDGPE@@UAAJPAUGPEModeEx@@H@Z|
	DCD	|?SetMode@DDGPE@@UAAJHPAPAUHPALETTE__@@H@Z|
	DCD	|?GetDriverData@DDGPE@@UAAPAUDDGPEDriverData@@XZ|
	DCD	|?SetDriverData@DDGPE@@UAAXPAUDDGPEDriverData@@@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAP2420GPE@@QAA@XZ| PROC		; OMAP2420GPE::OMAP2420GPE

; 225  : {

  00000		 |$LN5@OMAP2420GP|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42873|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          |??0DDGPE@@QAA@XZ|
  0000c	e59f302c	 ldr         r3, [pc, #0x2C]

; 226  :     m_pVisibleSurface = NULL;
; 227  :     m_pVisibleOverlay = NULL;
; 228  :     m_currentDX = D4;

  00010	e3a02004	 mov         r2, #4
  00014	e3a01000	 mov         r1, #0

; 229  :     m_externalDX = D0;
; 230  :     InitializeCriticalSection(&m_powerCS);

  00018	e28400d4	 add         r0, r4, #0xD4
  0001c	e5843000	 str         r3, [r4]
  00020	e584108c	 str         r1, [r4, #0x8C]
  00024	e5841090	 str         r1, [r4, #0x90]
  00028	e58420b0	 str         r2, [r4, #0xB0]
  0002c	e58410b4	 str         r1, [r4, #0xB4]
  00030	eb000000	 bl          InitializeCriticalSection

; 231  : }

  00034	e1a00004	 mov         r0, r4
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN6@OMAP2420GP|
  00040		 |$LN7@OMAP2420GP|
  00040	00000000	 DCD         |??_7OMAP2420GPE@@6B@|
  00044		 |$M42874|

			 ENDP  ; |??0OMAP2420GPE@@QAA@XZ|, OMAP2420GPE::OMAP2420GPE

; File c:\wince600\public\common\oak\inc\ddgpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T42888| DCD	|$LN5@GetPhysica|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPhysicalModeId@DDGPE@@UAAKXZ| PROC ; DDGPE::GetPhysicalModeId

; 486  : 	virtual DWORD	GetPhysicalModeId	(void) { return m_dwPhysicalModeID; }	// Get current hardware mode (mode of ddraw primary)

  00000		 |$LN5@GetPhysica|
  00000		 |$M42885|
  00000	e5900028	 ldr         r0, [r0, #0x28]
  00004	e12fff1e	 bx          lr
  00008		 |$M42886|

			 ENDP  ; |?GetPhysicalModeId@DDGPE@@UAAKXZ|, DDGPE::GetPhysicalModeId


  00000			 AREA	 |.pdata|, PDATA
|$T42898| DCD	|$LN5@GetDriverD|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDriverData@DDGPE@@UAAPAUDDGPEDriverData@@XZ| PROC ; DDGPE::GetDriverData

; 502  : 	virtual DDGPEDriverData*		GetDriverData(void) { return m_pDriverData; }

  00000		 |$LN5@GetDriverD|
  00000		 |$M42895|
  00000	e590002c	 ldr         r0, [r0, #0x2C]
  00004	e12fff1e	 bx          lr
  00008		 |$M42896|

			 ENDP  ; |?GetDriverData@DDGPE@@UAAPAUDDGPEDriverData@@XZ|, DDGPE::GetDriverData


  00000			 AREA	 |.pdata|, PDATA
|$T42907| DCD	|$LN5@SetDriverD|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetDriverData@DDGPE@@UAAXPAUDDGPEDriverData@@@Z| PROC ; DDGPE::SetDriverData

; 503  : 	virtual void					SetDriverData(DDGPEDriverData* pDriverData) { m_pDriverData = pDriverData; }

  00000		 |$LN5@SetDriverD|
  00000		 |$M42904|
  00000	e580102c	 str         r1, [r0, #0x2C]
  00004	e12fff1e	 bx          lr
  00008		 |$M42905|

			 ENDP  ; |?SetDriverData@DDGPE@@UAAXPAUDDGPEDriverData@@@Z|, DDGPE::SetDriverData

; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T42916| DCD	|$LN5@SetPalette|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPalette@OMAP2420GPE@@UAAJPBUtagPALETTEENTRY@@GG@Z| PROC ; OMAP2420GPE::SetPalette

; 156  :     virtual SCODE SetPalette(const PALETTEENTRY*, WORD, WORD) { return S_OK; }

  00000		 |$LN5@SetPalette|
  00000		 |$M42913|
  00000	e3a00000	 mov         r0, #0
  00004	e12fff1e	 bx          lr
  00008		 |$M42914|

			 ENDP  ; |?SetPalette@OMAP2420GPE@@UAAJPBUtagPALETTEENTRY@@GG@Z|, OMAP2420GPE::SetPalette

	EXPORT	|??1OMAP2420GPE@@UAA@XZ|		; OMAP2420GPE::~OMAP2420GPE
	EXPORT	|??_C@_17EFNPLDEM@?$AAD?$AAD?$AAI?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|??1DDGPE@@UAA@XZ|			; DDGPE::~DDGPE
	IMPORT	|DeleteCriticalSection|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|AdvertiseInterface|
	IMPORT	|LocalFree|
	IMPORT	|DisplayPddDeinit|
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T42928| DCD	|$LN15@OMAP2420GP@2|
	DCD	0x40003801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17EFNPLDEM@?$AAD?$AAD?$AAI?$AA?$AA@| DCB "D", 0x0, "D", 0x0, "I", 0x0
	DCB	0x0, 0x0				; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAP2420GPE@@UAA@XZ| PROC		; OMAP2420GPE::~OMAP2420GPE

; 238  : {

  00000		 |$LN15@OMAP2420GP@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M42925|
  00004	e1a04000	 mov         r4, r0
  00008	e59f30cc	 ldr         r3, [pc, #0xCC]

; 239  :     // Close power thread
; 240  :     if (m_hPowerThread != NULL) {

  0000c	e59420cc	 ldr         r2, [r4, #0xCC]
  00010	e5843000	 str         r3, [r4]
  00014	e3520000	 cmp         r2, #0
  00018	0a000007	 beq         |$LN8@OMAP2420GP@2|

; 241  :         // Signal stop to thread
; 242  :         m_powerThreadExit = TRUE;
; 243  :         // Set event to wake it
; 244  :         SetEvent(m_hPowerEvent);

  0001c	e59400c8	 ldr         r0, [r4, #0xC8]
  00020	e3a03001	 mov         r3, #1
  00024	e3a01003	 mov         r1, #3
  00028	e58430d0	 str         r3, [r4, #0xD0]
  0002c	eb000000	 bl          EventModify

; 245  :         // Wait until thread exits
; 246  :         WaitForSingleObject(m_hPowerThread, INFINITE);

  00030	e59400cc	 ldr         r0, [r4, #0xCC]
  00034	e3e01000	 mvn         r1, #0
  00038	eb000000	 bl          WaitForSingleObject
  0003c		 |$LN8@OMAP2420GP@2|

; 247  :     }
; 248  : 
; 249  :     // Close power event
; 250  :     if (m_hPowerEvent != NULL)

  0003c	e59430c8	 ldr         r3, [r4, #0xC8]
  00040	e3530000	 cmp         r3, #0

; 251  :     {
; 252  :         CloseHandle(m_hPowerEvent);

  00044	11a00003	 movne       r0, r3
  00048	1b000000	 blne        CloseHandle

; 253  :     }
; 254  : 
; 255  :     // Delete critical section
; 256  : //    DeleteCriticalSection(&m_powerCS);
; 257  : 
; 258  :     // Delete LCD object
; 259  :     if (m_hDisplay != NULL) DisplayPddDeinit(m_hDisplay);

  0004c	e5943088	 ldr         r3, [r4, #0x88]
  00050	e3530000	 cmp         r3, #0
  00054	11a00003	 movne       r0, r3
  00058	1b000000	 blne        DisplayPddDeinit

; 260  : 
; 261  :     // Remove power class interface
; 262  :     if (m_szDisplayPowerClass != NULL) {

  0005c	e5943070	 ldr         r3, [r4, #0x70]
  00060	e3530000	 cmp         r3, #0
  00064	0a000002	 beq         |$LN5@OMAP2420GP@2|

; 263  :         LocalFree(m_szDisplayPowerClass);

  00068	e1a00003	 mov         r0, r3
  0006c	eb000000	 bl          LocalFree

; 264  :     } else {        

  00070	ea000003	 b           |$LN4@OMAP2420GP@2|
  00074		 |$LN5@OMAP2420GP@2|

; 265  :         AdvertiseInterface(&m_powerClassGUID, L"DDI", FALSE);

  00074	e59f105c	 ldr         r1, [pc, #0x5C]
  00078	e3a02000	 mov         r2, #0
  0007c	e28400b8	 add         r0, r4, #0xB8
  00080	eb000000	 bl          AdvertiseInterface
  00084		 |$LN4@OMAP2420GP@2|

; 266  :     }
; 267  : 
; 268  :     // Unmap hardware registers & SRAM
; 269  :     if (m_pDSSRegs != NULL)

  00084	e594307c	 ldr         r3, [r4, #0x7C]
  00088	e3530000	 cmp         r3, #0

; 270  :     {
; 271  :         MmUnmapIoSpace((VOID*)m_pDSSRegs, m_memLen[MEM_IDX_DSS]);

  0008c	15941054	 ldrne       r1, [r4, #0x54]
  00090	11a00003	 movne       r0, r3
  00094	1b000000	 blne        MmUnmapIoSpace

; 272  :     }
; 273  :     if (m_pDISPCRegs != NULL)

  00098	e5943080	 ldr         r3, [r4, #0x80]
  0009c	e3530000	 cmp         r3, #0

; 274  :     {
; 275  :         MmUnmapIoSpace((VOID*)m_pDISPCRegs, m_memLen[MEM_IDX_LCD]);

  000a0	15941058	 ldrne       r1, [r4, #0x58]
  000a4	11a00003	 movne       r0, r3
  000a8	1b000000	 blne        MmUnmapIoSpace

; 276  :     }
; 277  :     if (m_pVENCRegs != NULL)

  000ac	e5943084	 ldr         r3, [r4, #0x84]
  000b0	e3530000	 cmp         r3, #0

; 278  :     {
; 279  :         MmUnmapIoSpace((VOID*)m_pVENCRegs, m_memLen[MEM_IDX_VENC]);

  000b4	15941060	 ldrne       r1, [r4, #0x60]
  000b8	11a00003	 movne       r0, r3
  000bc	1b000000	 blne        MmUnmapIoSpace

; 280  :     }
; 281  :     
; 282  :     // As last delete critical section
; 283  :     DeleteCriticalSection(&m_powerCS);

  000c0	e28400d4	 add         r0, r4, #0xD4
  000c4	eb000000	 bl          DeleteCriticalSection

; 284  : }

  000c8	e1a00004	 mov         r0, r4
  000cc	eb000000	 bl          |??1DDGPE@@UAA@XZ|
  000d0	e8bd4010	 ldmia       sp!, {r4, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN16@OMAP2420GP@2|
  000d8		 |$LN17@OMAP2420GP@2|
  000d8	00000000	 DCD         |??_C@_17EFNPLDEM@?$AAD?$AAD?$AAI?$AA?$AA@|
  000dc		 |$LN18@OMAP2420GP@2|
  000dc	00000000	 DCD         |??_7OMAP2420GPE@@6B@|
  000e0		 |$M42926|

			 ENDP  ; |??1OMAP2420GPE@@UAA@XZ|, OMAP2420GPE::~OMAP2420GPE

	IMPORT	|DisplayPddNumModes|

  00000			 AREA	 |.pdata|, PDATA
|$T42941| DCD	|$LN5@NumModes|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NumModes@OMAP2420GPE@@UAAHXZ| PROC	; OMAP2420GPE::NumModes

; 437  : {

  00000		 |$LN5@NumModes|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42938|

; 438  :     int count;
; 439  : 
; 440  :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::NumModes()\r\n"));
; 441  :     count = DisplayPddNumModes(m_hDisplay);

  00004	e5900088	 ldr         r0, [r0, #0x88]
  00008	eb000000	 bl          DisplayPddNumModes

; 442  :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::NumModes(count = %d)\r\n", count));
; 443  :     return count;
; 444  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M42939|

			 ENDP  ; |?NumModes@OMAP2420GPE@@UAAHXZ|, OMAP2420GPE::NumModes

	IMPORT	|DisplayPddGetModeInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T42955| DCD	|$LN17@GetModeInf|
	DCD	0x40003002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetModeInfo@OMAP2420GPE@@UAAJPAUGPEMode@@H@Z| PROC ; OMAP2420GPE::GetModeInfo

; 454  : {

  00000		 |$LN17@GetModeInf|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd05c	 sub         sp, sp, #0x5C
  00008		 |$M42952|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a06000	 mov         r6, r0

; 455  :     SCODE sc = E_FAIL;
; 456  :     OMAP2420_DISPLAY_MODE_INFO info;
; 457  : 
; 458  :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::GetModeInfo(0x%08x, %d, Bpp=%d)\r\n", pMode, modeNumber, m_bitsPerPixel));
; 459  : 
; 460  :     // Get hardware info
; 461  :     if (!DisplayPddGetModeInfo(m_hDisplay, modeNumber, &info)) {

  00014	e5960088	 ldr         r0, [r6, #0x88]
  00018	e3a03116	 mov         r3, #0x16, 2
  0001c	e28d2000	 add         r2, sp, #0
  00020	e1a01007	 mov         r1, r7
  00024	e3835901	 orr         r5, r3, #1, 18
  00028	eb000000	 bl          DisplayPddGetModeInfo
  0002c	e3500000	 cmp         r0, #0
  00030	0a00001e	 beq         |$cleanUp$41827|

; 462  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::GetModeInfo: "
; 463  :             L"Failed get mode info from display for mode %d\r\n", modeNumber
; 464  :         ));
; 465  :         goto cleanUp;
; 466  :     }
; 467  : 
; 468  :     // Now convert it to logical info
; 469  :     pMode->modeId = modeNumber;
; 470  :     pMode->width  = info.width;

  00034	e59d3000	 ldr         r3, [sp]

; 471  :     pMode->height = info.height;

  00038	e59de004	 ldr         lr, [sp, #4]
  0003c	e5847000	 str         r7, [r4]
  00040	e5843004	 str         r3, [r4, #4]
  00044	e584e008	 str         lr, [r4, #8]

; 472  :     pMode->Bpp = m_bitsPerPixel;

  00048	e5963068	 ldr         r3, [r6, #0x68]

; 473  :     pMode->frequency = 60;

  0004c	e3a0203c	 mov         r2, #0x3C
  00050	e5842010	 str         r2, [r4, #0x10]
  00054	e584300c	 str         r3, [r4, #0xC]

; 474  :     switch (m_bitsPerPixel) {

  00058	e5963068	 ldr         r3, [r6, #0x68]
  0005c	e3530001	 cmp         r3, #1
  00060	0a00000f	 beq         |$LN7@GetModeInf|
  00064	e3530002	 cmp         r3, #2
  00068	0a00000b	 beq         |$LN6@GetModeInf|
  0006c	e3530004	 cmp         r3, #4
  00070	0a000007	 beq         |$LN5@GetModeInf|
  00074	e3530008	 cmp         r3, #8
  00078	0a000003	 beq         |$LN4@GetModeInf|
  0007c	e3530010	 cmp         r3, #0x10
  00080	1a00000a	 bne         |$cleanUp$41827|

; 488  :     case 16:
; 489  :         pMode->format = gpe16Bpp;

  00084	e3a03004	 mov         r3, #4

; 490  :         break;

  00088	ea000006	 b           |$LN14@GetModeInf|
  0008c		 |$LN4@GetModeInf|

; 485  :     case 8:
; 486  :         pMode->format = gpe8Bpp;

  0008c	e3a03003	 mov         r3, #3

; 487  :         break;

  00090	ea000004	 b           |$LN14@GetModeInf|
  00094		 |$LN5@GetModeInf|

; 482  :     case 4:
; 483  :         pMode->format = gpe4Bpp;

  00094	e3a03002	 mov         r3, #2

; 484  :         break;

  00098	ea000002	 b           |$LN14@GetModeInf|
  0009c		 |$LN6@GetModeInf|

; 478  :         break;
; 479  :     case 2:
; 480  :         pMode->format = gpe2Bpp;

  0009c	e3a03001	 mov         r3, #1

; 481  :         break;

  000a0	ea000000	 b           |$LN14@GetModeInf|
  000a4		 |$LN7@GetModeInf|

; 475  : 
; 476  :     case 1:
; 477  :         pMode->format = gpe1Bpp;

  000a4	e3a03000	 mov         r3, #0
  000a8		 |$LN14@GetModeInf|
  000a8	e5843014	 str         r3, [r4, #0x14]

; 491  :     default:
; 492  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::GetModeInfo: "
; 493  :             L"Unsupported display mode with %d bits per pixel\r\n",
; 494  :             m_bitsPerPixel
; 495  :         ));
; 496  :         goto cleanUp;
; 497  :     }
; 498  : 
; 499  :     // Done
; 500  :     sc = S_OK;

  000ac	e3a05000	 mov         r5, #0
  000b0		 |$cleanUp$41827|

; 501  : 
; 502  : cleanUp:
; 503  :     
; 504  :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::GetModeInfo(sc = 0x%08x)\r\n", sc));
; 505  :     return sc;
; 506  : }

  000b0	e1a00005	 mov         r0, r5
  000b4	e28dd05c	 add         sp, sp, #0x5C
  000b8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$M42953|

			 ENDP  ; |?GetModeInfo@OMAP2420GPE@@UAAJPAUGPEMode@@H@Z|, OMAP2420GPE::GetModeInfo

	IMPORT	|??0GPESurf@@QAA@HHW4EGPEFormat@@@Z|	; GPESurf::GPESurf
	IMPORT	|??0DDGPESurf@@QAA@HHW4EGPEFormat@@@Z|	; DDGPESurf::DDGPESurf
	IMPORT	|?SurfaceOk@OMAP2420Surf@@QAAHXZ|	; OMAP2420Surf::SurfaceOk
	IMPORT	|FreePhysMem|
	IMPORT	|??0OMAP2420Surf@@QAA@HHKPAXHW4EGPEFormat@@@Z| ; OMAP2420Surf::OMAP2420Surf
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|AllocPhysMem|
	IMPORT	|MulDiv|
	IMPORT	|EGPEFormatToBpp|
; File c:\wince600\public\common\oak\inc\gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T43000| DCD	|$LN33@AllocSurfa|
	DCD	0x40006b02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocSurface@OMAP2420GPE@@UAAJPAPAVGPESurf@@HHW4EGPEFormat@@H@Z| PROC ; OMAP2420GPE::AllocSurface

; 639  : {

  00000		 |$LN33@AllocSurfa|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M42997|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a06001	 mov         r6, r1

; 640  :     SCODE sc = S_OK;
; 641  :     DWORD pa;
; 642  : 
; 643  :     // Is video memory required?
; 644  :     if ((nFlags & (GPE_REQUIRE_VIDEO_MEMORY|GPE_BACK_BUFFER)) != 0)

  00014	e59d1034	 ldr         r1, [sp, #0x34]
  00018	e3a05000	 mov         r5, #0
  0001c	e3110005	 tst         r1, #5
  00020	0a000035	 beq         |$LN15@AllocSurfa|

; 645  :         {
; 646  :         
; 647  :         ULONG stride = (nWidth * EGPEFormatToBpp[nFormat] + 7) >> 3;

  00024	e59f017c	 ldr         r0, [pc, #0x17C]
  00028	e59d9030	 ldr         r9, [sp, #0x30]

; 648  :         ULONG size = MulDiv(stride, nHeight, 1);

  0002c	e3a02001	 mov         r2, #1
  00030	e1a01004	 mov         r1, r4
  00034	e7900109	 ldr         r0, [r0, +r9, lsl #2]
  00038	e00e0790	 mul         lr, r0, r7
  0003c	e28e0007	 add         r0, lr, #7
  00040	e1a0a1c0	 mov         r10, r0, asr #3
  00044	e1a0000a	 mov         r0, r10
  00048	eb000000	 bl          MulDiv

; 649  :         if (size == -1)

  0004c	e3700001	 cmn         r0, #1

; 650  :             {
; 651  :             sc = E_OUTOFMEMORY;

  00050	0a000024	 beq         |$LN30@AllocSurfa|

; 652  :             goto cleanUp;
; 653  :             }
; 654  : 
; 655  :         VOID *pSurface = AllocPhysMem(size, PAGE_READWRITE, 0, 0, &pa);

  00054	e28d300c	 add         r3, sp, #0xC
  00058	e58d3000	 str         r3, [sp]
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02000	 mov         r2, #0
  00064	e3a01004	 mov         r1, #4
  00068	eb000000	 bl          AllocPhysMem
  0006c	e1b08000	 movs        r8, r0

; 719  :         goto cleanUp;
; 720  :         }
; 721  : 
; 722  :     // We are done
; 723  :     DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::AllocSurface: "
; 724  :         L"Surface in memory (width: %d, height: %d, format %d, 0x%08x)\r\n",
; 725  :         nWidth, nHeight, nFormat, (*ppSurf)->Buffer()
; 726  :         ));
; 727  : 
; 728  : cleanUp:

  00070	0a00001c	 beq         |$LN30@AllocSurfa|
  00074	e3a0008c	 mov         r0, #0x8C
  00078	eb000000	 bl          |??2@YAPAXI@Z|
  0007c	e3500000	 cmp         r0, #0
  00080	0a000008	 beq         |$LN18@AllocSurfa|
  00084	e59d300c	 ldr         r3, [sp, #0xC]
  00088	e1a02004	 mov         r2, r4
  0008c	e1a01007	 mov         r1, r7
  00090	e58d9008	 str         r9, [sp, #8]
  00094	e58da004	 str         r10, [sp, #4]
  00098	e58d8000	 str         r8, [sp]
  0009c	eb000000	 bl          |??0OMAP2420Surf@@QAA@HHKPAXHW4EGPEFormat@@@Z|
  000a0	e1a04000	 mov         r4, r0
  000a4	ea000000	 b           |$LN19@AllocSurfa|
  000a8		 |$LN18@AllocSurfa|

; 656  :         if (pSurface == NULL)
; 657  :             {
; 658  :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::AllocSurface: "
; 659  :                 L"Couldn't allocate video memory in SDRAM\r\n"
; 660  :                 ));
; 661  :             sc = E_OUTOFMEMORY;
; 662  :             goto cleanUp;
; 663  :             }
; 664  : 
; 665  :         OMAP2420Surf *pSurf = new OMAP2420Surf(
; 666  :             nWidth, nHeight, pa, pSurface, stride, nFormat
; 667  :             );

  000a8	e3a04000	 mov         r4, #0
  000ac		 |$LN19@AllocSurfa|

; 668  :         
; 669  :         if (pSurf == NULL)

  000ac	e3540000	 cmp         r4, #0
  000b0	1a000002	 bne         |$LN10@AllocSurfa|

; 670  :             {
; 671  :             // When allocation failed, we are out of memory...
; 672  :             FreePhysMem(pSurface);

  000b4	e1a00008	 mov         r0, r8
  000b8	eb000000	 bl          FreePhysMem

; 719  :         goto cleanUp;
; 720  :         }
; 721  : 
; 722  :     // We are done
; 723  :     DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::AllocSurface: "
; 724  :         L"Surface in memory (width: %d, height: %d, format %d, 0x%08x)\r\n",
; 725  :         nWidth, nHeight, nFormat, (*ppSurf)->Buffer()
; 726  :         ));
; 727  : 
; 728  : cleanUp:

  000bc	ea000009	 b           |$LN30@AllocSurfa|
  000c0		 |$LN10@AllocSurfa|

; 673  :             sc = E_OUTOFMEMORY;
; 674  :             goto cleanUp;
; 675  :             }
; 676  : 
; 677  :         // sanity check, cached mapping may have failed in constructor
; 678  :         if (!pSurf->SurfaceOk())

  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          |?SurfaceOk@OMAP2420Surf@@QAAHXZ|
  000c8	e3500000	 cmp         r0, #0
  000cc	1a000008	 bne         |$LN8@AllocSurfa|

; 679  :             {
; 680  :             // When allocation failed, we are out of memory...
; 681  :             delete pSurf;

  000d0	e5943000	 ldr         r3, [r4]
  000d4	e3a01001	 mov         r1, #1
  000d8	e1a00004	 mov         r0, r4
  000dc	e5933000	 ldr         r3, [r3]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff13	 bx          r3
  000e8		 |$LN30@AllocSurfa|
  000e8	e3a0313a	 mov         r3, #0x3A, 2

; 682  :             sc = E_OUTOFMEMORY;

  000ec	e3835807	 orr         r5, r3, #7, 16

; 719  :         goto cleanUp;
; 720  :         }
; 721  : 
; 722  :     // We are done
; 723  :     DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::AllocSurface: "
; 724  :         L"Surface in memory (width: %d, height: %d, format %d, 0x%08x)\r\n",
; 725  :         nWidth, nHeight, nFormat, (*ppSurf)->Buffer()
; 726  :         ));
; 727  : 
; 728  : cleanUp:

  000f0	ea000028	 b           |$cleanUp$41900|
  000f4		 |$LN8@AllocSurfa|

; 683  :             goto cleanUp;
; 684  :             }
; 685  : 
; 686  :         *ppSurf = pSurf;

  000f4	e5864000	 str         r4, [r6]

; 719  :         goto cleanUp;
; 720  :         }
; 721  : 
; 722  :     // We are done
; 723  :     DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::AllocSurface: "
; 724  :         L"Surface in memory (width: %d, height: %d, format %d, 0x%08x)\r\n",
; 725  :         nWidth, nHeight, nFormat, (*ppSurf)->Buffer()
; 726  :         ));
; 727  : 
; 728  : cleanUp:

  000f8	ea000026	 b           |$cleanUp$41900|
  000fc		 |$LN15@AllocSurfa|

; 687  : 
; 688  :         // We are done
; 689  :         DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::AllocSurface: "
; 690  :             L"Surface allocated in SDRAM memory (pa: 0x%08x, va: 0x%08x, "
; 691  :             L"width: %d, height: %d, format %d)\r\n",
; 692  :             pa, pSurface, nWidth, nHeight, nFormat
; 693  :             )); 
; 694  : 
; 695  :         goto cleanUp;
; 696  :         }
; 697  : 
; 698  :     if ((nFlags & GPE_DDGPE_SURF) != 0)

  000fc	e3110102	 tst         r1, #2, 2
  00100	0a000008	 beq         |$LN5@AllocSurfa|

; 699  :         {
; 700  :         // Create DDGPE surface in memory
; 701  :         *ppSurf = new DDGPESurf(nWidth, nHeight, nFormat);

  00104	e3a0007c	 mov         r0, #0x7C
  00108	eb000000	 bl          |??2@YAPAXI@Z|
  0010c	e3500000	 cmp         r0, #0
  00110	0a00000d	 beq         |$LN24@AllocSurfa|
  00114	e59d3030	 ldr         r3, [sp, #0x30]
  00118	e1a02004	 mov         r2, r4
  0011c	e1a01007	 mov         r1, r7
  00120	eb000000	 bl          |??0DDGPESurf@@QAA@HHW4EGPEFormat@@@Z|
  00124	ea000009	 b           |$LN25@AllocSurfa|
  00128		 |$LN5@AllocSurfa|

; 702  :         }
; 703  :     else 
; 704  :         {
; 705  :         // Create GPE surface in memory
; 706  :         *ppSurf = new GPESurf(nWidth, nHeight, nFormat);

  00128	e3a0004c	 mov         r0, #0x4C
  0012c	eb000000	 bl          |??2@YAPAXI@Z|
  00130	e3500000	 cmp         r0, #0
  00134	0a000004	 beq         |$LN24@AllocSurfa|
  00138	e59d3030	 ldr         r3, [sp, #0x30]
  0013c	e1a02004	 mov         r2, r4
  00140	e1a01007	 mov         r1, r7
  00144	eb000000	 bl          |??0GPESurf@@QAA@HHW4EGPEFormat@@@Z|
  00148	ea000000	 b           |$LN25@AllocSurfa|
  0014c		 |$LN24@AllocSurfa|
  0014c	e3a00000	 mov         r0, #0
  00150		 |$LN25@AllocSurfa|

; 707  :         }
; 708  :     
; 709  :     // Check for failure
; 710  :     if ((*ppSurf == NULL) || ((*ppSurf)->Buffer() == NULL))

  00150	e1a03000	 mov         r3, r0
  00154	e1b02003	 movs        r2, r3
  00158	e5860000	 str         r0, [r6]
  0015c	0a000002	 beq         |$LN2@AllocSurfa|
  00160	e5923004	 ldr         r3, [r2, #4]
  00164	e3530000	 cmp         r3, #0
  00168	1a00000a	 bne         |$cleanUp$41900|
  0016c		 |$LN2@AllocSurfa|

; 711  :         {
; 712  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::AllocSurface: "
; 713  :             L"Failed allocate surface (width: %d, height: %d, format %d)\r\n",
; 714  :             nWidth, nHeight, nFormat
; 715  :             ));
; 716  :         delete *ppSurf;

  0016c	e3520000	 cmp         r2, #0
  00170	15923000	 ldrne       r3, [r2]
  00174	13a01001	 movne       r1, #1
  00178	11a00002	 movne       r0, r2
  0017c	15933000	 ldrne       r3, [r3]
  00180	11a0e00f	 movne       lr, pc
  00184	112fff13	 bxne        r3

; 717  :         *ppSurf = NULL;

  00188	e3a03000	 mov         r3, #0
  0018c	e3a0213a	 mov         r2, #0x3A, 2
  00190	e5863000	 str         r3, [r6]

; 718  :         sc = E_OUTOFMEMORY;

  00194	e3825807	 orr         r5, r2, #7, 16
  00198		 |$cleanUp$41900|

; 729  :     return sc;
; 730  : 
; 731  : }

  00198	e1a00005	 mov         r0, r5
  0019c	e28dd010	 add         sp, sp, #0x10
  001a0	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001a4	e12fff1e	 bx          lr
  001a8		 |$LN34@AllocSurfa|
  001a8		 |$LN35@AllocSurfa|
  001a8	00000000	 DCD         |EGPEFormatToBpp|
  001ac		 |$M42998|

			 ENDP  ; |?AllocSurface@OMAP2420GPE@@UAAJPAPAVGPESurf@@HHW4EGPEFormat@@H@Z|, OMAP2420GPE::AllocSurface


  00000			 AREA	 |.pdata|, PDATA
|$T43015| DCD	|$LN5@AllocSurfa@2|
	DCD	0x40000e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AllocSurface@OMAP2420GPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@H@Z| PROC ; OMAP2420GPE::AllocSurface

; 743  : {

  00000		 |$LN5@AllocSurfa@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43012|

; 744  :     return AllocSurface(
; 745  :         (GPESurf **)ppSurf, width, height, format, flags | GPE_DDGPE_SURF
; 746  :         );

  00008	e59d4020	 ldr         r4, [sp, #0x20]
  0000c	e590e000	 ldr         lr, [r0]
  00010	e59d5018	 ldr         r5, [sp, #0x18]
  00014	e3844102	 orr         r4, r4, #2, 2
  00018	e59e6010	 ldr         r6, [lr, #0x10]
  0001c	e58d4004	 str         r4, [sp, #4]
  00020	e58d5000	 str         r5, [sp]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff16	 bx          r6

; 747  : }

  0002c	e28dd008	 add         sp, sp, #8
  00030	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M43013|

			 ENDP  ; |?AllocSurface@OMAP2420GPE@@UAAJPAPAVDDGPESurf@@HHW4EGPEFormat@@W4EDDGPEPixelFormat@@H@Z|, OMAP2420GPE::AllocSurface


  00000			 AREA	 |.pdata|, PDATA
|$T43025| DCD	|$LN5@SurfaceBus|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SurfaceBusyFlipping@OMAP2420GPE@@UAAHPAVGPESurf@@@Z| PROC ; OMAP2420GPE::SurfaceBusyFlipping

; 759  : {

  00000		 |$LN5@SurfaceBus|
  00000		 |$M43022|

; 760  : #if 0
; 761  :     DEBUGMSG(TRUE,(L"Check for SurBusy\r\n"));
; 762  :     // Check the DISPC_IRQSTATUS_GFXEndWindow bit.
; 763  :     // If bit is set, it means all the data from GFX Window has been
; 764  :     // fetched from memory and displayed on screen.
; 765  :     // To clear the bit, write 1 to it.
; 766  : //    while((INREG32(&m_pDISPCRegs->ulDISPC_IRQSTATUS) & 0x80)==0) Sleep(1);
; 767  :     
; 768  :     // Disable GFX window
; 769  : //    CLRREG32(&m_pDISPCRegs->ulDISPC_GFX_ATTRIBUTES, DISPC_GFX_ATTR_GFXENABLE);
; 770  : 
; 771  :     // enable the LCD and wait for it to complete
; 772  : //    SETREG32(&m_pDISPCRegs->ulDISPC_CONTROL, DISPC_CONTROL_LCDENABLE | DISPC_CONTROL_GOLCD);
; 773  : //    while (INREG32(&m_pDISPCRegs->ulDISPC_CONTROL) & DISPC_CONTROL_GOLCD) Sleep(0);
; 774  :    
; 775  :     m_flipBusy = FALSE;
; 776  : 
; 777  :     // Clear the EOL Status interrupt.
; 778  : //    SETREG32(&m_pDISPCRegs->ulDISPC_IRQSTATUS, 0x80);
; 779  : 
; 780  :     DEBUGMSG(TRUE,(L"Surface is free\r\n"));
; 781  : #endif
; 782  :     m_flipBusy = FALSE;

  00000	e3a03000	 mov         r3, #0
  00004	e5803094	 str         r3, [r0, #0x94]

; 783  :     return FALSE;

  00008	e3a00000	 mov         r0, #0

; 784  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M43023|

			 ENDP  ; |?SurfaceBusyFlipping@OMAP2420GPE@@UAAHPAVGPESurf@@@Z|, OMAP2420GPE::SurfaceBusyFlipping

	EXPORT	|?UpdateOverlay@OMAP2420GPE@@QAAKPAU_DDHAL_UPDATEOVERLAYDATA@@@Z| ; OMAP2420GPE::UpdateOverlay
	IMPORT	|WRITE_REGISTER_ULONG|
	IMPORT	|READ_REGISTER_ULONG|
	IMPORT	|?GetDDGPESurf@DDGPESurf@@SAPAV1@PAU_DDRAWI_DDRAWSURFACE_LCL@@@Z| ; DDGPESurf::GetDDGPESurf
; File c:\wince600\public\common\oak\inc\gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T43171| DCD	|$LN111@UpdateOver|
	DCD	0x40011e02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateOverlay@OMAP2420GPE@@QAAKPAU_DDHAL_UPDATEOVERLAYDATA@@@Z| PROC ; OMAP2420GPE::UpdateOverlay

; 841  : {

  00000		 |$LN111@UpdateOver|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43168|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 842  :     DWORD               dwBA0, dwBA1, dwAttr, dwPixelInc, dwRowInc, dwBytesPerPixel, dwWidth;
; 843  :     DDGPESurf           *pSrcSurf = DDGPESurf::GetDDGPESurf(pUpdate->lpDDSrcSurface);

  00010	e5960018	 ldr         r0, [r6, #0x18]
  00014	eb000000	 bl          |?GetDDGPESurf@DDGPESurf@@SAPAV1@PAU_DDRAWI_DDRAWSURFACE_LCL@@@Z|
  00018	e1a05000	 mov         r5, r0

; 844  :     DDGPESurf           *pDestSurf = DDGPESurf::GetDDGPESurf(pUpdate->lpDDDestSurface);

  0001c	e5960004	 ldr         r0, [r6, #4]
  00020	eb000000	 bl          |?GetDDGPESurf@DDGPESurf@@SAPAV1@PAU_DDRAWI_DDRAWSURFACE_LCL@@@Z|

; 845  :     OMAP2420_VID_REGS   *pVidRegs = &m_pDISPCRegs->tDISPC_VID1;

  00024	e5942080	 ldr         r2, [r4, #0x80]

; 846  : 
; 847  :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::UpdateOverlay: %08X %08X %08X %08X\r\n", pSrcSurf, pDestSurf, m_pVisibleOverlay, pUpdate->dwFlags));
; 848  : 
; 849  :     // hide the surface if requested
; 850  :     if (pUpdate->dwFlags & DDOVER_HIDE)

  00028	e596302c	 ldr         r3, [r6, #0x2C]
  0002c	e282a0bc	 add         r10, r2, #0xBC
  00030	e3130020	 tst         r3, #0x20
  00034	0a000019	 beq         |$LN36@UpdateOver|

; 851  :     {
; 852  :         if (pSrcSurf == m_pVisibleOverlay)

  00038	e5943090	 ldr         r3, [r4, #0x90]
  0003c	e3a07000	 mov         r7, #0
  00040	e1550003	 cmp         r5, r3
  00044	1a000013	 bne         |$LN35@UpdateOver|

; 853  :         {
; 854  :             DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::UpdateOverlay: HIDE\r\n"));
; 855  : 
; 856  :             // disable the overlay
; 857  :             CLRREG32(&pVidRegs->ulATTRIBUTES, DISPC_VID_ATTR_VIDENABLE);

  00048	e28a0010	 add         r0, r10, #0x10
  0004c	eb000000	 bl          READ_REGISTER_ULONG
  00050	e3c01001	 bic         r1, r0, #1
  00054	e28a0010	 add         r0, r10, #0x10
  00058	eb000000	 bl          WRITE_REGISTER_ULONG

; 858  : 
; 859  :             // commit the display controller changes
; 860  :             SETREG32(&m_pDISPCRegs->ulDISPC_CONTROL, DISPC_CONTROL_LCDENABLE | DISPC_CONTROL_GOLCD);

  0005c	e5943080	 ldr         r3, [r4, #0x80]
  00060	e2830040	 add         r0, r3, #0x40
  00064	eb000000	 bl          READ_REGISTER_ULONG
  00068	e5943080	 ldr         r3, [r4, #0x80]
  0006c	e3801021	 orr         r1, r0, #0x21
  00070	e2830040	 add         r0, r3, #0x40
  00074	eb000000	 bl          WRITE_REGISTER_ULONG
  00078		 |$LL34@UpdateOver|

; 861  :             while (INREG32(&m_pDISPCRegs->ulDISPC_CONTROL) & DISPC_CONTROL_GOLCD);

  00078	e5943080	 ldr         r3, [r4, #0x80]
  0007c	e2830040	 add         r0, r3, #0x40
  00080	eb000000	 bl          READ_REGISTER_ULONG
  00084	e3100020	 tst         r0, #0x20
  00088	1afffffa	 bne         |$LL34@UpdateOver|

; 862  : 
; 863  :             // clear the visible overlay pointer
; 864  :             m_pVisibleOverlay->m_pVidRegs = NULL;

  0008c	e5943090	 ldr         r3, [r4, #0x90]
  00090	e5837088	 str         r7, [r3, #0x88]

; 865  :             m_pVisibleOverlay = NULL;

  00094	e5847090	 str         r7, [r4, #0x90]
  00098		 |$LN35@UpdateOver|

; 866  :         }
; 867  : 
; 868  :         pUpdate->ddRVal = DD_OK;

  00098	e586704c	 str         r7, [r6, #0x4C]

; 869  :         DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::UpdateOverlay: HIDDEN\r\n"));
; 870  :         return DDHAL_DRIVER_HANDLED;

  0009c	ea0000ef	 b           |$LN98@UpdateOver|
  000a0		 |$LN36@UpdateOver|

; 871  :     }
; 872  : 
; 873  :     // if this isn't the visible overlay
; 874  :     if (pSrcSurf != m_pVisibleOverlay)

  000a0	e5941090	 ldr         r1, [r4, #0x90]
  000a4	e1550001	 cmp         r5, r1
  000a8	0a000005	 beq         |$LN29@UpdateOver|

; 875  :     {
; 876  :         // and we haven't been asked to make it visible, there's nothing to do
; 877  :         if (!(pUpdate->dwFlags & DDOVER_SHOW))

  000ac	e3130b01	 tst         r3, #1, 22

; 878  :         {
; 879  :             pUpdate->ddRVal = DD_OK;
; 880  :             return DDHAL_DRIVER_HANDLED;

  000b0	0a0000e8	 beq         |$LN99@UpdateOver|

; 881  :         }
; 882  :         // it's an error if some other overlay is already visible
; 883  :         else if (m_pVisibleOverlay != NULL)

  000b4	e3510000	 cmp         r1, #0
  000b8	0a000001	 beq         |$LN29@UpdateOver|
  000bc		 |$LN106@UpdateOver|

; 884  :         {
; 885  :             DEBUGMSG(1, (L"OMAP2420GPE::UpdateOverlay: "
; 886  :                 L"ERROR: Other overlay already visible!\r\n"));
; 887  :             pUpdate->ddRVal = DDERR_OUTOFCAPS;

  000bc	e59f33b0	 ldr         r3, [pc, #0x3B0]

; 888  :             return DDHAL_DRIVER_HANDLED;

  000c0	ea0000e5	 b           |$LN100@UpdateOver|
  000c4		 |$LN29@UpdateOver|

; 889  :         }
; 890  :     }
; 891  : 
; 892  :     // enable/disable the color key
; 893  :     if (pUpdate->dwFlags & DDOVER_KEYSRC)

  000c4	e3130c01	 tst         r3, #1, 24
  000c8	0a000014	 beq         |$LN28@UpdateOver|

; 894  :     {
; 895  :         OUTREG32(&m_pDISPCRegs->ulDISPC_TRANS_COLOR0, pSrcSurf->ColorKey());

  000cc	e5953000	 ldr         r3, [r5]
  000d0	e1a00005	 mov         r0, r5
  000d4	e5933018	 ldr         r3, [r3, #0x18]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3
  000e0	e5943080	 ldr         r3, [r4, #0x80]
  000e4	e1a01000	 mov         r1, r0
  000e8	e2830054	 add         r0, r3, #0x54
  000ec		 |$LN102@UpdateOver|
  000ec	eb000000	 bl          WRITE_REGISTER_ULONG

; 896  :         SETREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDSELECTION);

  000f0	e5943080	 ldr         r3, [r4, #0x80]
  000f4	e2830044	 add         r0, r3, #0x44
  000f8	eb000000	 bl          READ_REGISTER_ULONG
  000fc	e3801b02	 orr         r1, r0, #2, 22
  00100		 |$LN108@UpdateOver|
  00100	e5943080	 ldr         r3, [r4, #0x80]
  00104	e2830044	 add         r0, r3, #0x44
  00108	eb000000	 bl          WRITE_REGISTER_ULONG

; 897  :         SETREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE);

  0010c	e5943080	 ldr         r3, [r4, #0x80]
  00110	e2830044	 add         r0, r3, #0x44
  00114	eb000000	 bl          READ_REGISTER_ULONG
  00118	e3801b01	 orr         r1, r0, #1, 22
  0011c	ea00001b	 b           |$LN101@UpdateOver|
  00120		 |$LN28@UpdateOver|

; 898  :     }
; 899  :     else if (pUpdate->dwFlags & DDOVER_KEYSRCOVERRIDE)

  00120	e3130c02	 tst         r3, #2, 24

; 900  :     {
; 901  :         OUTREG32(&m_pDISPCRegs->ulDISPC_TRANS_COLOR0, pUpdate->overlayFX.dckSrcColorkey.dwColorSpaceLowValue);

  00124	15961044	 ldrne       r1, [r6, #0x44]
  00128	12820054	 addne       r0, r2, #0x54
  0012c	1affffee	 bne         |$LN102@UpdateOver|

; 902  :         SETREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDSELECTION);
; 903  :         SETREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE);
; 904  :     }
; 905  :     else if (pUpdate->dwFlags & DDOVER_KEYDEST)

  00130	e3130040	 tst         r3, #0x40
  00134	0a00000d	 beq         |$LN24@UpdateOver|

; 906  :     {
; 907  :         OUTREG32(&m_pDISPCRegs->ulDISPC_TRANS_COLOR0, pDestSurf->ColorKey());

  00138	e5903000	 ldr         r3, [r0]
  0013c	e5933018	 ldr         r3, [r3, #0x18]
  00140	e1a0e00f	 mov         lr, pc
  00144	e12fff13	 bx          r3
  00148	e5943080	 ldr         r3, [r4, #0x80]
  0014c	e1a01000	 mov         r1, r0
  00150	e2830054	 add         r0, r3, #0x54
  00154		 |$LN107@UpdateOver|
  00154	eb000000	 bl          WRITE_REGISTER_ULONG

; 908  :         CLRREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDSELECTION);

  00158	e5943080	 ldr         r3, [r4, #0x80]
  0015c	e2830044	 add         r0, r3, #0x44
  00160	eb000000	 bl          READ_REGISTER_ULONG
  00164	e1a02000	 mov         r2, r0
  00168	e3c21b02	 bic         r1, r2, #2, 22

; 909  :         SETREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE);

  0016c	eaffffe3	 b           |$LN108@UpdateOver|
  00170		 |$LN24@UpdateOver|

; 910  :     }
; 911  :     else if (pUpdate->dwFlags & DDOVER_KEYDESTOVERRIDE)

  00170	e3130080	 tst         r3, #0x80

; 912  :     {
; 913  :         OUTREG32(&m_pDISPCRegs->ulDISPC_TRANS_COLOR0, pUpdate->overlayFX.dckDestColorkey.dwColorSpaceLowValue);

  00174	1596103c	 ldrne       r1, [r6, #0x3C]
  00178	12820054	 addne       r0, r2, #0x54
  0017c	1afffff4	 bne         |$LN107@UpdateOver|

; 914  :         CLRREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDSELECTION);
; 915  :         SETREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE);
; 916  :     }
; 917  :     else
; 918  :     {
; 919  :         CLRREG32(&m_pDISPCRegs->ulDISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE);

  00180	e2820044	 add         r0, r2, #0x44
  00184	eb000000	 bl          READ_REGISTER_ULONG
  00188	e1a02000	 mov         r2, r0
  0018c	e3c21b01	 bic         r1, r2, #1, 22
  00190		 |$LN101@UpdateOver|
  00190	e5943080	 ldr         r3, [r4, #0x80]
  00194	e2830044	 add         r0, r3, #0x44
  00198	eb000000	 bl          WRITE_REGISTER_ULONG

; 920  :     }
; 921  : 
; 922  :     // set the source address, rotation parameters, and attributes
; 923  :     // based on the source format
; 924  :     switch (pSrcSurf->Format())

  0019c	e595101c	 ldr         r1, [r5, #0x1C]
  001a0	e3510004	 cmp         r1, #4
  001a4	0a00002b	 beq         |$LN18@UpdateOver|
  001a8	e3510007	 cmp         r1, #7

; 986  : 
; 987  :         // all others are errors
; 988  :         default:
; 989  :             DEBUGMSG(GPE_ZONE_ERROR, (L"OMAP2420GPE::UpdateOverlay: "
; 990  :                 L"Invalid source format: %d!\r\n", pSrcSurf->Format()));
; 991  :             pUpdate->ddRVal = DDERR_OUTOFCAPS;
; 992  :             return DDHAL_DRIVER_HANDLED;

  001ac	1affffc2	 bne         |$LN106@UpdateOver|
  001b0	e595302c	 ldr         r3, [r5, #0x2C]
  001b4	e5952038	 ldr         r2, [r5, #0x38]
  001b8	e3a0b014	 mov         r11, #0x14
  001bc	e0833fa3	 add         r3, r3, r3, lsr #31
  001c0	e1a0e0c3	 mov         lr, r3, asr #1
  001c4	e3520000	 cmp         r2, #0
  001c8	0a000058	 beq         |$LN15@UpdateOver|

; 952  :             }
; 953  :             dwBA1 = dwBA0;
; 954  :         break;
; 955  : 
; 956  :         // 16-bit YCrCb (??)
; 957  :         case gpe16YCrCb:
; 958  :             dwBytesPerPixel = 4;
; 959  :             dwWidth = pSrcSurf->Width() / 2;
; 960  :             dwAttr = DISPC_VID_ATTR_VIDFORMAT(10); // ??? 10 (YUV2 4:2:2) or 11(UYVY 4:2:2)
; 961  :             switch (pSrcSurf->Rotate())

  001cc	e3520001	 cmp         r2, #1
  001d0	0a000016	 beq         |$LN7@UpdateOver|
  001d4	e3520002	 cmp         r2, #2
  001d8	0a00000c	 beq         |$LN6@UpdateOver|
  001dc	e3520004	 cmp         r2, #4
  001e0	1a000038	 bne         |$LN97@UpdateOver|

; 978  :                 case DMDO_270:
; 979  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory() + (dwWidth - 1) * dwBytesPerPixel;
; 980  :                 dwPixelInc = (dwWidth - 1) * dwBytesPerPixel + 1;
; 981  :                 dwRowInc = -((LONG)dwWidth * (pSrcSurf->Height() - 1)) * dwBytesPerPixel - dwBytesPerPixel - (dwBytesPerPixel - 1);

  001e4	e5953030	 ldr         r3, [r5, #0x30]
  001e8	e5950034	 ldr         r0, [r5, #0x34]
  001ec	e24e1001	 sub         r1, lr, #1
  001f0	e2433001	 sub         r3, r3, #1
  001f4	e0020e93	 mul         r2, r3, lr
  001f8	e1a03101	 mov         r3, r1, lsl #2
  001fc	e3e0e006	 mvn         lr, #6
  00200	e04e7102	 sub         r7, lr, r2, lsl #2
  00204	e0808101	 add         r8, r0, r1, lsl #2
  00208	e2839001	 add         r9, r3, #1
  0020c	ea00004a	 b           |$LN16@UpdateOver|
  00210		 |$LN6@UpdateOver|

; 972  :                 break;
; 973  :                 case DMDO_180:
; 974  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory() + (dwWidth * pSrcSurf->Height() - 1) * dwBytesPerPixel;

  00210	e5952030	 ldr         r2, [r5, #0x30]
  00214	e5951034	 ldr         r1, [r5, #0x34]

; 975  :                 dwPixelInc = -(LONG)dwBytesPerPixel - (dwBytesPerPixel - 1);

  00218	e3e07006	 mvn         r7, #6
  0021c	e0030e92	 mul         r3, r2, lr
  00220	e1a09007	 mov         r9, r7
  00224	e2433001	 sub         r3, r3, #1
  00228	e0818103	 add         r8, r1, r3, lsl #2

; 976  :                 dwRowInc = -(LONG)dwBytesPerPixel - (dwBytesPerPixel - 1);
; 977  :                 break;

  0022c	ea000042	 b           |$LN16@UpdateOver|
  00230		 |$LN7@UpdateOver|

; 962  :             {
; 963  :                 case DMDO_0:
; 964  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory();
; 965  :                 dwPixelInc = 1;
; 966  :                 dwRowInc = 1;
; 967  :                 break;
; 968  :                 case DMDO_90:
; 969  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory() + (dwWidth * (pSrcSurf->Height() - 1) * dwBytesPerPixel);

  00230	e5953030	 ldr         r3, [r5, #0x30]
  00234	e5951034	 ldr         r1, [r5, #0x34]

; 970  :                 dwPixelInc = -(LONG)dwWidth * dwBytesPerPixel - (dwBytesPerPixel - 1);

  00238	e3e00002	 mvn         r0, #2
  0023c	e2433001	 sub         r3, r3, #1
  00240	e0020e93	 mul         r2, r3, lr
  00244	e040910e	 sub         r9, r0, lr, lsl #2
  00248	e1a03102	 mov         r3, r2, lsl #2

; 971  :                 dwRowInc = (dwWidth * (pSrcSurf->Height() - 1)) * dwBytesPerPixel + 1;

  0024c	e2837001	 add         r7, r3, #1
  00250	e0818102	 add         r8, r1, r2, lsl #2

; 982  :                 break;
; 983  :             }
; 984  :             dwBA1 = dwBA0;
; 985  :         break;

  00254	ea000038	 b           |$LN16@UpdateOver|
  00258		 |$LN18@UpdateOver|

; 925  :     {
; 926  :         // 16-bit RGB
; 927  :         case gpe16Bpp:
; 928  :             dwBytesPerPixel = EGPEFormatToBpp[pSrcSurf->Format()] / 8;

  00258	e59f3210	 ldr         r3, [pc, #0x210]

; 929  :             dwAttr = DISPC_VID_ATTR_VIDFORMAT(6);
; 930  :             switch (pSrcSurf->Rotate())

  0025c	e5952038	 ldr         r2, [r5, #0x38]
  00260	e3a0b00c	 mov         r11, #0xC
  00264	e7933101	 ldr         r3, [r3, +r1, lsl #2]
  00268	e3530000	 cmp         r3, #0
  0026c	42833007	 addmi       r3, r3, #7
  00270	e1a081c3	 mov         r8, r3, asr #3
  00274	e3520000	 cmp         r2, #0
  00278	0a00002c	 beq         |$LN15@UpdateOver|
  0027c	e3520001	 cmp         r2, #1
  00280	0a00001e	 beq         |$LN14@UpdateOver|
  00284	e3520002	 cmp         r2, #2
  00288	0a000012	 beq         |$LN13@UpdateOver|
  0028c	e3520004	 cmp         r2, #4
  00290	1a00000c	 bne         |$LN97@UpdateOver|

; 947  :                 case DMDO_270:
; 948  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory() + (pSrcSurf->Width() - 1) * dwBytesPerPixel;
; 949  :                 dwPixelInc = (pSrcSurf->Width() - 1) * dwBytesPerPixel + 1;
; 950  :                 dwRowInc = -(pSrcSurf->Width() * (pSrcSurf->Height() - 1)) * dwBytesPerPixel - dwBytesPerPixel - (dwBytesPerPixel - 1);

  00294	e5953030	 ldr         r3, [r5, #0x30]
  00298	e595102c	 ldr         r1, [r5, #0x2C]
  0029c	e5950034	 ldr         r0, [r5, #0x34]
  002a0	e2433001	 sub         r3, r3, #1
  002a4	e0020193	 mul         r2, r3, r1
  002a8	e2411001	 sub         r1, r1, #1
  002ac	e2823002	 add         r3, r2, #2
  002b0	e0020893	 mul         r2, r3, r8
  002b4	e0030891	 mul         r3, r1, r8
  002b8	e2627001	 rsb         r7, r2, #1
  002bc	e2839001	 add         r9, r3, #1
  002c0	e0280891	 mla         r8, r1, r8, r0

; 951  :                 break;

  002c4	ea00001c	 b           |$LN16@UpdateOver|
  002c8		 |$LN97@UpdateOver|

; 934  :                 dwPixelInc = 1;
; 935  :                 dwRowInc = 1;

  002c8	e59d8000	 ldr         r8, [sp]
  002cc	e59d9000	 ldr         r9, [sp]
  002d0	e59d7000	 ldr         r7, [sp]
  002d4	ea000018	 b           |$LN16@UpdateOver|
  002d8		 |$LN13@UpdateOver|

; 942  :                 case DMDO_180:
; 943  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory() + (pSrcSurf->Width() * pSrcSurf->Height() - 1) * dwBytesPerPixel;

  002d8	e5951030	 ldr         r1, [r5, #0x30]
  002dc	e595202c	 ldr         r2, [r5, #0x2C]
  002e0	e5950034	 ldr         r0, [r5, #0x34]

; 944  :                 dwPixelInc = -(LONG)dwBytesPerPixel - (dwBytesPerPixel - 1);

  002e4	e1a03088	 mov         r3, r8, lsl #1
  002e8	e0020291	 mul         r2, r1, r2
  002ec	e2637001	 rsb         r7, r3, #1
  002f0	e2423001	 sub         r3, r2, #1
  002f4	e0280893	 mla         r8, r3, r8, r0
  002f8	e1a09007	 mov         r9, r7

; 945  :                 dwRowInc = -(LONG)dwBytesPerPixel - (dwBytesPerPixel - 1);
; 946  :                 break;

  002fc	ea00000e	 b           |$LN16@UpdateOver|
  00300		 |$LN14@UpdateOver|

; 936  :                 break;
; 937  :                 case DMDO_90:
; 938  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory() + (pSrcSurf->Width() * (pSrcSurf->Height() - 1) * dwBytesPerPixel);

  00300	e5953030	 ldr         r3, [r5, #0x30]
  00304	e595202c	 ldr         r2, [r5, #0x2C]
  00308	e595e034	 ldr         lr, [r5, #0x34]
  0030c	e2433001	 sub         r3, r3, #1
  00310	e0000293	 mul         r0, r3, r2

; 939  :                 dwPixelInc = -pSrcSurf->Width() * dwBytesPerPixel - (dwBytesPerPixel - 1);

  00314	e2823001	 add         r3, r2, #1
  00318	e0020890	 mul         r2, r0, r8
  0031c	e0010893	 mul         r1, r3, r8

; 940  :                 dwRowInc = (pSrcSurf->Width() * (pSrcSurf->Height() - 1)) * dwBytesPerPixel + 1;

  00320	e2827001	 add         r7, r2, #1
  00324	e028e890	 mla         r8, r0, r8, lr
  00328	e2619001	 rsb         r9, r1, #1

; 941  :                 break;

  0032c	ea000002	 b           |$LN16@UpdateOver|
  00330		 |$LN15@UpdateOver|

; 931  :             {
; 932  :                 case DMDO_0:
; 933  :                 dwBA0 = pSrcSurf->OffsetInVideoMemory();

  00330	e5958034	 ldr         r8, [r5, #0x34]

; 934  :                 dwPixelInc = 1;
; 935  :                 dwRowInc = 1;

  00334	e3a07001	 mov         r7, #1
  00338	e3a09001	 mov         r9, #1
  0033c		 |$LN16@UpdateOver|

; 993  :         break;
; 994  :     }
; 995  : 
; 996  :     // set the source address, rotation parameters, and attributes (including format)
; 997  :     OUTREG32(&pVidRegs->ulBA0, dwBA0);

  0033c	e1a01008	 mov         r1, r8
  00340	e1a0000a	 mov         r0, r10
  00344	eb000000	 bl          WRITE_REGISTER_ULONG

; 998  :     OUTREG32(&pVidRegs->ulBA1, dwBA1);

  00348	e1a01008	 mov         r1, r8
  0034c	e28a0004	 add         r0, r10, #4
  00350	eb000000	 bl          WRITE_REGISTER_ULONG

; 999  :     OUTREG32(&pVidRegs->ulPIXEL_INC, dwPixelInc);

  00354	e1a01009	 mov         r1, r9
  00358	e28a0020	 add         r0, r10, #0x20
  0035c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1000 :     OUTREG32(&pVidRegs->ulROW_INC, dwRowInc);

  00360	e1a01007	 mov         r1, r7
  00364	e28a001c	 add         r0, r10, #0x1C
  00368	eb000000	 bl          WRITE_REGISTER_ULONG

; 1001 :     OUTREG32(&pVidRegs->ulATTRIBUTES, (INREG32(&pVidRegs->ulATTRIBUTES) & DISPC_VID_ATTR_VIDENABLE) | dwAttr);

  0036c	e28a0010	 add         r0, r10, #0x10
  00370	eb000000	 bl          READ_REGISTER_ULONG
  00374	e2003001	 and         r3, r0, #1
  00378	e183100b	 orr         r1, r3, r11
  0037c	e28a0010	 add         r0, r10, #0x10
  00380	eb000000	 bl          WRITE_REGISTER_ULONG

; 1002 : 
; 1003 :     // set the source size (position is 0,0)
; 1004 :     OUTREG32(&pVidRegs->ulPICTURE_SIZE, DISPC_VID_PICTURE_SIZE_VIDORGSIZEY(pUpdate->rSrc.bottom - pUpdate->rSrc.top) |
; 1005 :     DISPC_VID_PICTURE_SIZE_VIDORGSIZEX(pUpdate->rSrc.right - pUpdate->rSrc.left));

  00384	e5961028	 ldr         r1, [r6, #0x28]
  00388	e5963020	 ldr         r3, [r6, #0x20]
  0038c	e5960024	 ldr         r0, [r6, #0x24]
  00390	e596201c	 ldr         r2, [r6, #0x1C]
  00394	e0413003	 sub         r3, r1, r3
  00398	e2431001	 sub         r1, r3, #1
  0039c	e0403002	 sub         r3, r0, r2
  003a0	e2433001	 sub         r3, r3, #1
  003a4	e1831801	 orr         r1, r3, r1, lsl #16
  003a8	e28a0028	 add         r0, r10, #0x28
  003ac	eb000000	 bl          WRITE_REGISTER_ULONG

; 1006 : 
; 1007 :     // set the destination position and size
; 1008 :     OUTREG32(&pVidRegs->ulPOSITION, DISPC_VID_POS_VIDPOSY(pUpdate->rDest.top) | DISPC_VID_POS_VIDPOSX(pUpdate->rDest.left));

  003b0	e596200c	 ldr         r2, [r6, #0xC]
  003b4	e5963008	 ldr         r3, [r6, #8]
  003b8	e28a0008	 add         r0, r10, #8
  003bc	e1831802	 orr         r1, r3, r2, lsl #16
  003c0	eb000000	 bl          WRITE_REGISTER_ULONG

; 1009 :     OUTREG32(&pVidRegs->ulSIZE, DISPC_VID_SIZE_VIDSIZEY(pUpdate->rDest.bottom - pUpdate->rDest.top) |
; 1010 :     DISPC_VID_SIZE_VIDSIZEX(pUpdate->rDest.right - pUpdate->rDest.left));

  003c4	e5961014	 ldr         r1, [r6, #0x14]
  003c8	e596300c	 ldr         r3, [r6, #0xC]
  003cc	e5960010	 ldr         r0, [r6, #0x10]
  003d0	e5962008	 ldr         r2, [r6, #8]
  003d4	e0413003	 sub         r3, r1, r3
  003d8	e2431001	 sub         r1, r3, #1
  003dc	e0403002	 sub         r3, r0, r2
  003e0	e2433001	 sub         r3, r3, #1
  003e4	e1831801	 orr         r1, r3, r1, lsl #16
  003e8	e28a000c	 add         r0, r10, #0xC
  003ec	eb000000	 bl          WRITE_REGISTER_ULONG
  003f0	e3a0373f	 mov         r3, #0x3F, 14

; 1011 : 
; 1012 :     // set the overlay attributes
; 1013 :     OUTREG32(&pVidRegs->ulFIFO_THRESHOLD, BSP_TV_FIFO_THRESHOLD);

  003f4	e38310c0	 orr         r1, r3, #0xC0
  003f8	e28a0014	 add         r0, r10, #0x14
  003fc	eb000000	 bl          WRITE_REGISTER_ULONG

; 1014 : 
; 1015 :     // show the surface if requested
; 1016 :     if (pUpdate->dwFlags & DDOVER_SHOW)

  00400	e596302c	 ldr         r3, [r6, #0x2C]
  00404	e3130b01	 tst         r3, #1, 22
  00408	0a000006	 beq         |$LN3@UpdateOver|

; 1017 :     {
; 1018 :         DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::UpdateOverlay: SHOW\r\n"));
; 1019 : 
; 1020 :         // enable the overlay
; 1021 :         SETREG32(&pVidRegs->ulATTRIBUTES, DISPC_VID_ATTR_VIDENABLE);

  0040c	e28a0010	 add         r0, r10, #0x10
  00410	eb000000	 bl          READ_REGISTER_ULONG
  00414	e3801001	 orr         r1, r0, #1
  00418	e28a0010	 add         r0, r10, #0x10
  0041c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1022 : 
; 1023 :         // set the visible overlay pointer
; 1024 :         m_pVisibleOverlay = (OMAP2420Surf *)pSrcSurf;

  00420	e5845090	 str         r5, [r4, #0x90]

; 1025 :         m_pVisibleOverlay->m_pVidRegs = pVidRegs;

  00424	e585a088	 str         r10, [r5, #0x88]
  00428		 |$LN3@UpdateOver|

; 1026 :     }
; 1027 : 
; 1028 :     // commit the display controller changes
; 1029 :     SETREG32(&m_pDISPCRegs->ulDISPC_CONTROL, DISPC_CONTROL_LCDENABLE | DISPC_CONTROL_GOLCD);

  00428	e5943080	 ldr         r3, [r4, #0x80]
  0042c	e2830040	 add         r0, r3, #0x40
  00430	eb000000	 bl          READ_REGISTER_ULONG
  00434	e5943080	 ldr         r3, [r4, #0x80]
  00438	e3801021	 orr         r1, r0, #0x21
  0043c	e2830040	 add         r0, r3, #0x40
  00440	eb000000	 bl          WRITE_REGISTER_ULONG
  00444		 |$LL2@UpdateOver|

; 1030 :     while (INREG32(&m_pDISPCRegs->ulDISPC_CONTROL) & DISPC_CONTROL_GOLCD);

  00444	e5943080	 ldr         r3, [r4, #0x80]
  00448	e2830040	 add         r0, r3, #0x40
  0044c	eb000000	 bl          READ_REGISTER_ULONG
  00450	e3100020	 tst         r0, #0x20
  00454	1afffffa	 bne         |$LL2@UpdateOver|
  00458		 |$LN99@UpdateOver|

; 1031 : 
; 1032 : #if defined(DEBUG)
; 1033 :     DumpRegs(L"UpdateOverlay");
; 1034 : #endif
; 1035 : 
; 1036 :     // indicate success
; 1037 :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::UpdateOverlay\r\n"));
; 1038 :     pUpdate->ddRVal = DD_OK;

  00458	e3a03000	 mov         r3, #0
  0045c		 |$LN100@UpdateOver|
  0045c	e586304c	 str         r3, [r6, #0x4C]
  00460		 |$LN98@UpdateOver|

; 1039 :     return DDHAL_DRIVER_HANDLED;

  00460	e3a00001	 mov         r0, #1

; 1040 : }

  00464	e28dd004	 add         sp, sp, #4
  00468	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0046c	e12fff1e	 bx          lr
  00470		 |$LN112@UpdateOver|
  00470		 |$LN113@UpdateOver|
  00470	00000000	 DCD         |EGPEFormatToBpp|
  00474		 |$LN114@UpdateOver|
  00474	88760168	 DCD         0x88760168
  00478		 |$M43169|

			 ENDP  ; |?UpdateOverlay@OMAP2420GPE@@QAAKPAU_DDHAL_UPDATEOVERLAYDATA@@@Z|, OMAP2420GPE::UpdateOverlay

	EXPORT	|?SetOverlayPosition@OMAP2420GPE@@QAAKPAU_DDHAL_SETOVERLAYPOSITIONDATA@@@Z| ; OMAP2420GPE::SetOverlayPosition

  00000			 AREA	 |.pdata|, PDATA
|$T43189| DCD	|$LN10@SetOverlay|
	DCD	0x40002001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetOverlayPosition@OMAP2420GPE@@QAAKPAU_DDHAL_SETOVERLAYPOSITIONDATA@@@Z| PROC ; OMAP2420GPE::SetOverlayPosition

; 1045 : {

  00000		 |$LN10@SetOverlay|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43186|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 1046 :     DDGPESurf           *pSurf = DDGPESurf::GetDDGPESurf(pSetPos->lpDDSrcSurface);

  0000c	e5940004	 ldr         r0, [r4, #4]
  00010	eb000000	 bl          |?GetDDGPESurf@DDGPESurf@@SAPAV1@PAU_DDRAWI_DDRAWSURFACE_LCL@@@Z|

; 1047 :     OMAP2420_VID_REGS   *pVidRegs = &m_pDISPCRegs->tDISPC_VID1;

  00014	e5953080	 ldr         r3, [r5, #0x80]

; 1048 : 
; 1049 :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::SetOverlayPosition: %08X %d %d\r\n", pSurf, pSetPos->lXPos, pSetPos->lYPos));
; 1050 : 
; 1051 :     // must be the current surface
; 1052 :     if (pSurf != m_pVisibleOverlay)

  00018	e5952090	 ldr         r2, [r5, #0x90]
  0001c	e28310bc	 add         r1, r3, #0xBC
  00020	e1500002	 cmp         r0, r2

; 1053 :     {
; 1054 :         DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::SetOverlayPosition: "
; 1055 :             L"NOT visible\r\n"));
; 1056 :         pSetPos->ddRVal = DD_OK;
; 1057 :         return DDHAL_DRIVER_HANDLED;

  00024	1a000010	 bne         |$LN7@SetOverlay|

; 1058 :     }
; 1059 : 
; 1060 :     // set the overlay position
; 1061 :     OUTREG32(&pVidRegs->ulPOSITION, DISPC_VID_POS_VIDPOSY(pSetPos->lYPos) | DISPC_VID_POS_VIDPOSX(pSetPos->lXPos));

  00028	e5942010	 ldr         r2, [r4, #0x10]
  0002c	e594300c	 ldr         r3, [r4, #0xC]
  00030	e2810008	 add         r0, r1, #8
  00034	e1831802	 orr         r1, r3, r2, lsl #16
  00038	eb000000	 bl          WRITE_REGISTER_ULONG

; 1062 : 
; 1063 :     // commit the display controller changes
; 1064 :     SETREG32(&m_pDISPCRegs->ulDISPC_CONTROL, DISPC_CONTROL_LCDENABLE | DISPC_CONTROL_GOLCD);

  0003c	e5953080	 ldr         r3, [r5, #0x80]
  00040	e2830040	 add         r0, r3, #0x40
  00044	eb000000	 bl          READ_REGISTER_ULONG
  00048	e5953080	 ldr         r3, [r5, #0x80]
  0004c	e3801021	 orr         r1, r0, #0x21
  00050	e2830040	 add         r0, r3, #0x40
  00054	eb000000	 bl          WRITE_REGISTER_ULONG
  00058		 |$LL2@SetOverlay|

; 1065 :     while (INREG32(&m_pDISPCRegs->ulDISPC_CONTROL) & DISPC_CONTROL_GOLCD);

  00058	e5953080	 ldr         r3, [r5, #0x80]
  0005c	e2830040	 add         r0, r3, #0x40
  00060	eb000000	 bl          READ_REGISTER_ULONG
  00064	e3100020	 tst         r0, #0x20
  00068	1afffffa	 bne         |$LL2@SetOverlay|
  0006c		 |$LN7@SetOverlay|

; 1066 : 
; 1067 :     // indicate success
; 1068 :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::SetOverlayPosition\r\n"));
; 1069 :     pSetPos->ddRVal = DD_OK;

  0006c	e3a03000	 mov         r3, #0
  00070	e5843014	 str         r3, [r4, #0x14]

; 1070 :     return DDHAL_DRIVER_HANDLED;

  00074	e3a00001	 mov         r0, #1

; 1071 : }

  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M43187|

			 ENDP  ; |?SetOverlayPosition@OMAP2420GPE@@QAAKPAU_DDHAL_SETOVERLAYPOSITIONDATA@@@Z|, OMAP2420GPE::SetOverlayPosition

	EXPORT	|?WrappedEmulatedLine@OMAP2420GPE@@AAAJPAUGPELineParms@@@Z| ; OMAP2420GPE::WrappedEmulatedLine
	IMPORT	|?EmulatedLine@GPE@@QAAJPAUGPELineParms@@@Z| ; GPE::EmulatedLine

  00000			 AREA	 |.pdata|, PDATA
|$T43201| DCD	|$LN5@WrappedEmu|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WrappedEmulatedLine@OMAP2420GPE@@AAAJPAUGPELineParms@@@Z| PROC ; OMAP2420GPE::WrappedEmulatedLine

; 1107 : {

  00000		 |$LN5@WrappedEmu|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43198|
  00004	e1a04000	 mov         r4, r0

; 1108 :     SCODE sc;
; 1109 :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::WrappedEmulatedLine\r\n"));
; 1110 :     // Do emulated line
; 1111 :     sc = EmulatedLine(lineParameters);

  00008	eb000000	 bl          |?EmulatedLine@GPE@@QAAJPAUGPELineParms@@@Z|

; 1112 :     // Set update flag
; 1113 :     m_updateFlag = TRUE;

  0000c	e3a03001	 mov         r3, #1

; 1114 :     // Done   
; 1115 :     return sc;
; 1116 : }

  00010	e58430e8	 str         r3, [r4, #0xE8]
  00014	e8bd4010	 ldmia       sp!, {r4, lr}
  00018	e12fff1e	 bx          lr
  0001c		 |$M43199|

			 ENDP  ; |?WrappedEmulatedLine@OMAP2420GPE@@AAAJPAUGPELineParms@@@Z|, OMAP2420GPE::WrappedEmulatedLine


  00000			 AREA	 |.pdata|, PDATA
|$T43211| DCD	|$LN5@BltComplet|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?BltComplete@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z| PROC ; OMAP2420GPE::BltComplete

; 1207 : {

  00000		 |$LN5@BltComplet|
  00000		 |$M43208|

; 1208 :     // Set update flag
; 1209 :     m_updateFlag = TRUE;

  00000	e3a03001	 mov         r3, #1
  00004	e58030e8	 str         r3, [r0, #0xE8]

; 1210 :     return S_OK;

  00008	e3a00000	 mov         r0, #0

; 1211 : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M43209|

			 ENDP  ; |?BltComplete@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z|, OMAP2420GPE::BltComplete


  00000			 AREA	 |.pdata|, PDATA
|$T43220| DCD	|$LN5@SetPointer|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPointerShape@OMAP2420GPE@@UAAJPAVGPESurf@@0HHHH@Z| PROC ; OMAP2420GPE::SetPointerShape

; 1222 : {

  00000		 |$LN5@SetPointer|
  00000		 |$M43217|

; 1223 :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::SetPointerShape\r\n"));
; 1224 :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::SetPointerShape\r\n"));
; 1225 :     return S_OK;

  00000	e3a00000	 mov         r0, #0

; 1226 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43218|

			 ENDP  ; |?SetPointerShape@OMAP2420GPE@@UAAJPAVGPESurf@@0HHHH@Z|, OMAP2420GPE::SetPointerShape


  00000			 AREA	 |.pdata|, PDATA
|$T43229| DCD	|$LN5@MovePointe|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MovePointer@OMAP2420GPE@@UAAJHH@Z| PROC ; OMAP2420GPE::MovePointer

; 1236 : {

  00000		 |$LN5@MovePointe|
  00000		 |$M43226|

; 1237 :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::MovePointer(%d, %d)\r\n", x, y));
; 1238 :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::MovePointer(sc = 0x%08x)\r\n", S_OK));
; 1239 :     return S_OK;

  00000	e3a00000	 mov         r0, #0

; 1240 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43227|

			 ENDP  ; |?MovePointer@OMAP2420GPE@@UAAJHH@Z|, OMAP2420GPE::MovePointer


  00000			 AREA	 |.pdata|, PDATA
|$T43238| DCD	|$LN5@InVBlank|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InVBlank@OMAP2420GPE@@UAAHXZ| PROC	; OMAP2420GPE::InVBlank

; 1247 : {

  00000		 |$LN5@InVBlank|
  00000		 |$M43235|

; 1248 :     //DEBUGMSG(TRUE,(L"InVBlank++\r\n"));
; 1249 : 
; 1250 :     //To do set the required number of Vertical Blank pulses.
; 1251 :     //DEBUGMSG(TRUE,(L"InVBlank--\r\n"));
; 1252 : 
; 1253 :     return 1;

  00000	e3a00001	 mov         r0, #1

; 1254 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43236|

			 ENDP  ; |?InVBlank@OMAP2420GPE@@UAAHXZ|, OMAP2420GPE::InVBlank


  00000			 AREA	 |.pdata|, PDATA
|$T43245| DCD	|$LN5@PowerHandl|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerHandler@OMAP2420GPE@@UAAXH@Z| PROC ; OMAP2420GPE::PowerHandler

; 1261 : {

  00000		 |$LN5@PowerHandl|
  00000		 |$M43242|

; 1262 : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43243|

			 ENDP  ; |?PowerHandler@OMAP2420GPE@@UAAXH@Z|, OMAP2420GPE::PowerHandler

	EXPORT	|?InitController@OMAP2420GPE@@AAAXPAUOMAP2420_DISPLAY_MODE_INFO@@@Z| ; OMAP2420GPE::InitController
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T43258| DCD	|$LN11@InitContro|
	DCD	0x40006601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitController@OMAP2420GPE@@AAAXPAUOMAP2420_DISPLAY_MODE_INFO@@@Z| PROC ; OMAP2420GPE::InitController

; 1389 : {

  00000		 |$LN11@InitContro|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43255|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 1390 :     // reset the display controller and wait for it to complete
; 1391 :     OUTREG32(&m_pDISPCRegs->ulDISPC_SYSCONFIG, DISPC_SYSCONFIG_SOFTRESET); 

  0000c	e5943080	 ldr         r3, [r4, #0x80]
  00010	e3a01002	 mov         r1, #2
  00014	e2830010	 add         r0, r3, #0x10
  00018	eb000000	 bl          WRITE_REGISTER_ULONG

; 1392 :     while (!(INREG32(&m_pDISPCRegs->ulDISPC_SYSSTATUS) & DISPC_SYSSTATUS_RESETDONE)) Sleep(0);

  0001c	ea000001	 b           |$LN8@InitContro|
  00020		 |$LL2@InitContro|
  00020	e3a00000	 mov         r0, #0
  00024	eb000000	 bl          Sleep
  00028		 |$LN8@InitContro|
  00028	e5943080	 ldr         r3, [r4, #0x80]
  0002c	e2830014	 add         r0, r3, #0x14
  00030	eb000000	 bl          READ_REGISTER_ULONG
  00034	e3100001	 tst         r0, #1
  00038	0afffff8	 beq         |$LL2@InitContro|

; 1393 : 
; 1394 :     // disable the display controller and IRQ
; 1395 :     OUTREG32(&m_pDISPCRegs->ulDISPC_CONTROL, 0);

  0003c	e5943080	 ldr         r3, [r4, #0x80]
  00040	e3a01000	 mov         r1, #0
  00044	e2830040	 add         r0, r3, #0x40
  00048	eb000000	 bl          WRITE_REGISTER_ULONG

; 1396 :     OUTREG32(&m_pDISPCRegs->ulDISPC_IRQENABLE,0);

  0004c	e5943080	 ldr         r3, [r4, #0x80]
  00050	e3a01000	 mov         r1, #0
  00054	e283001c	 add         r0, r3, #0x1C
  00058	eb000000	 bl          WRITE_REGISTER_ULONG

; 1397 :     OUTREG32(&m_pDISPCRegs->ulDISPC_IRQSTATUS, 0x7FFF);

  0005c	e5943080	 ldr         r3, [r4, #0x80]
  00060	e3a02c7f	 mov         r2, #0x7F, 24
  00064	e38210ff	 orr         r1, r2, #0xFF
  00068	e2830018	 add         r0, r3, #0x18
  0006c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1398 : 
; 1399 :     // set the display controller attributes
; 1400 :     OUTREG32(&m_pDISPCRegs->ulDISPC_SYSCONFIG, pInfo->sysconfig);

  00070	e5943080	 ldr         r3, [r4, #0x80]
  00074	e5951014	 ldr         r1, [r5, #0x14]
  00078	e2830010	 add         r0, r3, #0x10
  0007c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1401 :     OUTREG32(&m_pDISPCRegs->ulDISPC_CONTROL, pInfo->control);

  00080	e5943080	 ldr         r3, [r4, #0x80]
  00084	e5951018	 ldr         r1, [r5, #0x18]
  00088	e2830040	 add         r0, r3, #0x40
  0008c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1402 :     OUTREG32(&m_pDISPCRegs->ulDISPC_CONFIG, pInfo->config);

  00090	e5943080	 ldr         r3, [r4, #0x80]
  00094	e595101c	 ldr         r1, [r5, #0x1C]
  00098	e2830044	 add         r0, r3, #0x44
  0009c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1403 : 
; 1404 :     // set the LCD attributes
; 1405 :     OUTREG32(&m_pDISPCRegs->ulDISPC_TIMING_H, pInfo->timing_H);

  000a0	e5943080	 ldr         r3, [r4, #0x80]
  000a4	e5951020	 ldr         r1, [r5, #0x20]
  000a8	e2830064	 add         r0, r3, #0x64
  000ac	eb000000	 bl          WRITE_REGISTER_ULONG

; 1406 :     OUTREG32(&m_pDISPCRegs->ulDISPC_TIMING_V, pInfo->timing_V);

  000b0	e5943080	 ldr         r3, [r4, #0x80]
  000b4	e5951024	 ldr         r1, [r5, #0x24]
  000b8	e2830068	 add         r0, r3, #0x68
  000bc	eb000000	 bl          WRITE_REGISTER_ULONG

; 1407 :     OUTREG32(&m_pDISPCRegs->ulDISPC_POL_FREQ, pInfo->pol_freq);

  000c0	e5943080	 ldr         r3, [r4, #0x80]
  000c4	e5951028	 ldr         r1, [r5, #0x28]
  000c8	e283006c	 add         r0, r3, #0x6C
  000cc	eb000000	 bl          WRITE_REGISTER_ULONG

; 1408 :     OUTREG32(&m_pDISPCRegs->ulDISPC_DIVISOR, pInfo->divisor);

  000d0	e5943080	 ldr         r3, [r4, #0x80]
  000d4	e595102c	 ldr         r1, [r5, #0x2C]
  000d8	e2830070	 add         r0, r3, #0x70
  000dc	eb000000	 bl          WRITE_REGISTER_ULONG

; 1409 :     OUTREG32(&m_pDISPCRegs->ulDISPC_SIZE_LCD, pInfo->size_LCD);

  000e0	e5943080	 ldr         r3, [r4, #0x80]
  000e4	e5951030	 ldr         r1, [r5, #0x30]
  000e8	e283007c	 add         r0, r3, #0x7C
  000ec	eb000000	 bl          WRITE_REGISTER_ULONG

; 1410 :     OUTREG32(&m_pDISPCRegs->ulDISPC_SIZE_DIG, pInfo->size_DIG);

  000f0	e5943080	 ldr         r3, [r4, #0x80]
  000f4	e5951034	 ldr         r1, [r5, #0x34]
  000f8	e2830078	 add         r0, r3, #0x78
  000fc	eb000000	 bl          WRITE_REGISTER_ULONG

; 1411 :     OUTREG32(&m_pDISPCRegs->ulDISPC_DEFAULT_COLOR0, pInfo->background_LCD);

  00100	e5943080	 ldr         r3, [r4, #0x80]
  00104	e5951038	 ldr         r1, [r5, #0x38]
  00108	e283004c	 add         r0, r3, #0x4C
  0010c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1412 :     OUTREG32(&m_pDISPCRegs->ulDISPC_DEFAULT_COLOR1, pInfo->background_DIG);

  00110	e5943080	 ldr         r3, [r4, #0x80]
  00114	e595103c	 ldr         r1, [r5, #0x3C]
  00118	e2830050	 add         r0, r3, #0x50
  0011c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1413 : 
; 1414 :     // set the graphic attributes
; 1415 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_POSITION, pInfo->GFX_pos);

  00120	e5943080	 ldr         r3, [r4, #0x80]
  00124	e5951040	 ldr         r1, [r5, #0x40]
  00128	e2830088	 add         r0, r3, #0x88
  0012c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1416 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_SIZE, pInfo->GFX_size);

  00130	e5943080	 ldr         r3, [r4, #0x80]
  00134	e5951044	 ldr         r1, [r5, #0x44]
  00138	e283008c	 add         r0, r3, #0x8C
  0013c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1417 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_ATTRIBUTES, pInfo->GFX_attr);

  00140	e5943080	 ldr         r3, [r4, #0x80]
  00144	e5951048	 ldr         r1, [r5, #0x48]
  00148	e28300a0	 add         r0, r3, #0xA0
  0014c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1418 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_FIFO_THRESHOLD, pInfo->GFX_FIFO_thres);

  00150	e5943080	 ldr         r3, [r4, #0x80]
  00154	e595104c	 ldr         r1, [r5, #0x4C]
  00158	e28300a4	 add         r0, r3, #0xA4
  0015c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1419 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_ROW_INC, pInfo->GFX_row_inc);

  00160	e5943080	 ldr         r3, [r4, #0x80]
  00164	e5951050	 ldr         r1, [r5, #0x50]
  00168	e28300ac	 add         r0, r3, #0xAC
  0016c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1420 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_PIXEL_INC, pInfo->GFX_pixel_inc);

  00170	e5943080	 ldr         r3, [r4, #0x80]
  00174	e5951054	 ldr         r1, [r5, #0x54]
  00178	e28300b0	 add         r0, r3, #0xB0
  0017c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1421 :     OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_WINDOW_SKIP, pInfo->GFX_window_skip);

  00180	e5943080	 ldr         r3, [r4, #0x80]
  00184	e5951058	 ldr         r1, [r5, #0x58]
  00188	e28300b4	 add         r0, r3, #0xB4
  0018c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1422 : 
; 1423 : #if defined(TVOUT)
; 1424 :     // set the video attributes for TV-Out
; 1425 :     OUTREG32(&m_pTVVidRegs->ulPOSITION, BSP_TV_POS);
; 1426 :     OUTREG32(&m_pTVVidRegs->ulSIZE, BSP_TV_SIZE);
; 1427 :     OUTREG32(&m_pTVVidRegs->ulPICTURE_SIZE, BSP_TV_PICTURE_SIZE);
; 1428 :     OUTREG32(&m_pTVVidRegs->ulATTRIBUTES, BSP_TV_ATTR);
; 1429 :     OUTREG32(&m_pTVVidRegs->ulFIFO_THRESHOLD, BSP_TV_FIFO_THRESHOLD);
; 1430 :     OUTREG32(&m_pTVVidRegs->ulROW_INC, BSP_TV_ROW_INC);
; 1431 :     OUTREG32(&m_pTVVidRegs->ulPIXEL_INC, BSP_TV_PIXEL_INC);
; 1432 : #endif
; 1433 : }

  00190	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00194	e12fff1e	 bx          lr
  00198		 |$M43256|

			 ENDP  ; |?InitController@OMAP2420GPE@@AAAXPAUOMAP2420_DISPLAY_MODE_INFO@@@Z|, OMAP2420GPE::InitController

	EXPORT	|?SetControllerAddresses@OMAP2420GPE@@AAAXXZ| ; OMAP2420GPE::SetControllerAddresses
; File c:\wince600\public\common\oak\inc\gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T43283| DCD	|$LN18@SetControl|
	DCD	0x40002a01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetControllerAddresses@OMAP2420GPE@@AAAXXZ| PROC ; OMAP2420GPE::SetControllerAddresses

; 1444 : {

  00000		 |$LN18@SetControl|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43280|
  00004	e1a04000	 mov         r4, r0

; 1445 :     DEBUGMSG(TRUE,(L"OMAP2420GPE::SetControllerAddresses: %08X %08X\r\n", m_pVisibleSurface, m_pVisibleOverlay));
; 1446 : 
; 1447 :     // update the graphics addresses
; 1448 :     if (m_pVisibleSurface)

  00008	e594308c	 ldr         r3, [r4, #0x8C]
  0000c	e1b02003	 movs        r2, r3
  00010	0a000008	 beq         |$LN4@SetControl|

; 1449 :     {
; 1450 :         OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_BA0, m_pVisibleSurface->OffsetInVideoMemory());

  00014	e5943080	 ldr         r3, [r4, #0x80]
  00018	e5921034	 ldr         r1, [r2, #0x34]
  0001c	e2830080	 add         r0, r3, #0x80
  00020	eb000000	 bl          WRITE_REGISTER_ULONG

; 1451 :         OUTREG32(&m_pDISPCRegs->ulDISPC_GFX_BA1, m_pVisibleSurface->OffsetInVideoMemory());

  00024	e594308c	 ldr         r3, [r4, #0x8C]
  00028	e5942080	 ldr         r2, [r4, #0x80]
  0002c	e5931034	 ldr         r1, [r3, #0x34]
  00030	e2820084	 add         r0, r2, #0x84
  00034	eb000000	 bl          WRITE_REGISTER_ULONG
  00038		 |$LN4@SetControl|

; 1452 : #if defined(TVOUT)
; 1453 :         OUTREG32(&m_pTVVidRegs->ulBA0, m_pVisibleSurface->OffsetInVideoMemory());
; 1454 :         OUTREG32(&m_pTVVidRegs->ulBA1, m_pVisibleSurface->OffsetInVideoMemory());
; 1455 : #endif
; 1456 :     }
; 1457 : 
; 1458 :     // update the overlay addresses
; 1459 :     if (m_pVisibleOverlay)

  00038	e5943090	 ldr         r3, [r4, #0x90]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000007	 beq         |$LN3@SetControl|

; 1460 :     {
; 1461 :         OUTREG32(&m_pVisibleOverlay->m_pVidRegs->ulBA0, m_pVisibleOverlay->OffsetInVideoMemory());

  00044	e5931034	 ldr         r1, [r3, #0x34]
  00048	e5930088	 ldr         r0, [r3, #0x88]
  0004c	eb000000	 bl          WRITE_REGISTER_ULONG

; 1462 :         OUTREG32(&m_pVisibleOverlay->m_pVidRegs->ulBA1, m_pVisibleOverlay->OffsetInVideoMemory());

  00050	e5943090	 ldr         r3, [r4, #0x90]
  00054	e5932088	 ldr         r2, [r3, #0x88]
  00058	e5931034	 ldr         r1, [r3, #0x34]
  0005c	e2820004	 add         r0, r2, #4
  00060	eb000000	 bl          WRITE_REGISTER_ULONG
  00064		 |$LN3@SetControl|

; 1463 :     }
; 1464 : 
; 1465 :     // commit the display controller changes
; 1466 :     SETREG32(&m_pDISPCRegs->ulDISPC_CONTROL, DISPC_CONTROL_LCDENABLE | DISPC_CONTROL_GOLCD);

  00064	e5943080	 ldr         r3, [r4, #0x80]
  00068	e2830040	 add         r0, r3, #0x40
  0006c	eb000000	 bl          READ_REGISTER_ULONG
  00070	e5943080	 ldr         r3, [r4, #0x80]
  00074	e3801021	 orr         r1, r0, #0x21
  00078	e2830040	 add         r0, r3, #0x40
  0007c	eb000000	 bl          WRITE_REGISTER_ULONG
  00080		 |$LL2@SetControl|

; 1467 :     while (INREG32(&m_pDISPCRegs->ulDISPC_CONTROL) & DISPC_CONTROL_GOLCD);

  00080	e5943080	 ldr         r3, [r4, #0x80]
  00084	e2830040	 add         r0, r3, #0x40
  00088	eb000000	 bl          READ_REGISTER_ULONG
  0008c	e3100020	 tst         r0, #0x20
  00090	1afffffa	 bne         |$LL2@SetControl|

; 1468 : 
; 1469 :     // Next blit needs to synchronize on this operation!
; 1470 :     m_flipBusy = TRUE;

  00094	e3a03001	 mov         r3, #1
  00098	e5843094	 str         r3, [r4, #0x94]

; 1471 : 
; 1472 :     // Set update flag
; 1473 :     m_updateFlag = TRUE;

  0009c	e58430e8	 str         r3, [r4, #0xE8]

; 1474 : }

  000a0	e8bd4010	 ldmia       sp!, {r4, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M43281|

			 ENDP  ; |?SetControllerAddresses@OMAP2420GPE@@AAAXXZ|, OMAP2420GPE::SetControllerAddresses

	EXPORT	|?GetGameXInfo@OMAP2420GPE@@QAAHKKPAXK0@Z| ; OMAP2420GPE::GetGameXInfo
	IMPORT	|SetLastError|
; File c:\wince600\public\common\oak\inc\gpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T43312| DCD	|$LN26@GetGameXIn|
	DCD	0x40008701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetGameXInfo@OMAP2420GPE@@QAAHKKPAXK0@Z| PROC ; OMAP2420GPE::GetGameXInfo

; 1483 : {

  00000		 |$LN26@GetGameXIn|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M43309|

; 1484 :     int rc = 0;
; 1485 :     GXDeviceInfo *pInfo;
; 1486 : 
; 1487 :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::GetGameXInfo"));
; 1488 : 
; 1489 :     // GAPI only support P8, RGB444, RGB555, RGB565, and RGB888
; 1490 :     pInfo = (GXDeviceInfo *)pOut;
; 1491 :     if (
; 1492 :         pOut != NULL && outSize >= sizeof(GXDeviceInfo) && (
; 1493 :             m_pMode->Bpp == 8 || m_pMode->Bpp == 12 ||
; 1494 :             m_pMode->Bpp == 16 || m_pMode->Bpp == 24 ||
; 1495 :             m_pMode->Bpp == 32
; 1496 :         ) && pInfo->idVersion == kidVersion100
; 1497 :     )

  00004	e59d2028	 ldr         r2, [sp, #0x28]
  00008	e3a01000	 mov         r1, #0
  0000c	e3520000	 cmp         r2, #0
  00010	0a00007b	 beq         |$LN12@GetGameXIn|
  00014	e59d3024	 ldr         r3, [sp, #0x24]
  00018	e3530084	 cmp         r3, #0x84
  0001c	3a000078	 bcc         |$LN12@GetGameXIn|
  00020	e5903010	 ldr         r3, [r0, #0x10]
  00024	e593300c	 ldr         r3, [r3, #0xC]
  00028	e3530008	 cmp         r3, #8
  0002c	0a000007	 beq         |$LN11@GetGameXIn|
  00030	e353000c	 cmp         r3, #0xC
  00034	0a000005	 beq         |$LN11@GetGameXIn|
  00038	e3530010	 cmp         r3, #0x10
  0003c	0a000003	 beq         |$LN11@GetGameXIn|
  00040	e3530018	 cmp         r3, #0x18
  00044	0a000001	 beq         |$LN11@GetGameXIn|
  00048	e3530020	 cmp         r3, #0x20
  0004c	1a00006c	 bne         |$LN12@GetGameXIn|
  00050		 |$LN11@GetGameXIn|
  00050	e5923000	 ldr         r3, [r2]
  00054	e3530064	 cmp         r3, #0x64
  00058	1a000069	 bne         |$LN12@GetGameXIn|

; 1498 :     {
; 1499 :         pInfo->pvFrameBuffer = (UCHAR*)m_pPrimarySurface->Buffer();

  0005c	e5903004	 ldr         r3, [r0, #4]
  00060	e5933004	 ldr         r3, [r3, #4]
  00064	e5823004	 str         r3, [r2, #4]

; 1500 :         pInfo->cbStride = m_pPrimarySurface->Stride();

  00068	e5903004	 ldr         r3, [r0, #4]
  0006c	e5933008	 ldr         r3, [r3, #8]
  00070	e5823008	 str         r3, [r2, #8]

; 1501 :         pInfo->cxWidth  = m_pPrimarySurface->Width();

  00074	e5903004	 ldr         r3, [r0, #4]
  00078	e593302c	 ldr         r3, [r3, #0x2C]
  0007c	e582300c	 str         r3, [r2, #0xC]

; 1502 :         pInfo->cyHeight = m_pPrimarySurface->Height();

  00080	e5903004	 ldr         r3, [r0, #4]
  00084	e5933030	 ldr         r3, [r3, #0x30]
  00088	e5823010	 str         r3, [r2, #0x10]

; 1503 :         switch (m_pMode->Bpp) {

  0008c	e5903010	 ldr         r3, [r0, #0x10]
  00090	e593300c	 ldr         r3, [r3, #0xC]
  00094	e3530008	 cmp         r3, #8
  00098	0a00001b	 beq         |$LN8@GetGameXIn|
  0009c	e353000c	 cmp         r3, #0xC
  000a0	0a000015	 beq         |$LN7@GetGameXIn|
  000a4	e3530010	 cmp         r3, #0x10
  000a8	0a00000f	 beq         |$LN6@GetGameXIn|
  000ac	e3530018	 cmp         r3, #0x18
  000b0	0a000002	 beq         |$LN5@GetGameXIn|
  000b4	e3530020	 cmp         r3, #0x20
  000b8	0a000005	 beq         |$LN4@GetGameXIn|
  000bc	ea000053	 b           |$cleanUp$42332|
  000c0		 |$LN5@GetGameXIn|

; 1516 :         case 24:
; 1517 :             pInfo->cBPP = 24;
; 1518 :             pInfo->ffFormat |= kfDirect | kfDirect888;

  000c0	e5923018	 ldr         r3, [r2, #0x18]
  000c4	e3a00018	 mov         r0, #0x18
  000c8	e5820014	 str         r0, [r2, #0x14]
  000cc	e3833e12	 orr         r3, r3, #0x12, 28
  000d0	e5823018	 str         r3, [r2, #0x18]
  000d4		 |$LN4@GetGameXIn|

; 1519 :         case 32:
; 1520 :             pInfo->cBPP = 32;
; 1521 :             pInfo->ffFormat |= kfDirect | kfDirect888;

  000d4	e5923018	 ldr         r3, [r2, #0x18]
  000d8	e3a00020	 mov         r0, #0x20
  000dc	e5820014	 str         r0, [r2, #0x14]
  000e0	e3833e12	 orr         r3, r3, #0x12, 28
  000e4	e5823018	 str         r3, [r2, #0x18]

; 1522 :         default:
; 1523 :             goto cleanUp;

  000e8	ea000048	 b           |$cleanUp$42332|
  000ec		 |$LN6@GetGameXIn|

; 1512 :         case 16:
; 1513 :             pInfo->cBPP = 16;
; 1514 :             pInfo->ffFormat |= kfDirect | kfDirect565;

  000ec	e5923018	 ldr         r3, [r2, #0x18]
  000f0	e3a01010	 mov         r1, #0x10
  000f4	e38330a0	 orr         r3, r3, #0xA0

; 1515 :             break;

  000f8	ea000006	 b           |$LN23@GetGameXIn|
  000fc		 |$LN7@GetGameXIn|

; 1507 :             break;
; 1508 :         case 12:
; 1509 :             pInfo->cBPP = 12;
; 1510 :             pInfo->ffFormat |= kfDirect | kfDirect444;

  000fc	e5923018	 ldr         r3, [r2, #0x18]
  00100	e3a0100c	 mov         r1, #0xC
  00104	e3833e22	 orr         r3, r3, #0x22, 28

; 1511 :             break;

  00108	ea000002	 b           |$LN23@GetGameXIn|
  0010c		 |$LN8@GetGameXIn|

; 1504 :         case 8:
; 1505 :             pInfo->cBPP = 8;
; 1506 :             pInfo->ffFormat |= kfPalette;

  0010c	e5923018	 ldr         r3, [r2, #0x18]
  00110	e3a01008	 mov         r1, #8
  00114	e3833010	 orr         r3, r3, #0x10
  00118		 |$LN23@GetGameXIn|
  00118	e5823018	 str         r3, [r2, #0x18]
  0011c	e3a03c01	 mov         r3, #1, 24

; 1524 :         }
; 1525 : 
; 1526 :         // todo: get keys from registry
; 1527 :         pInfo->vkButtonUpPortrait = VK_UP;
; 1528 :         pInfo->vkButtonUpLandscape = VK_LEFT;
; 1529 :         pInfo->ptButtonUp.x = 88;
; 1530 :         pInfo->ptButtonUp.y = 250;
; 1531 :         pInfo->vkButtonDownPortrait = VK_DOWN;
; 1532 :         pInfo->vkButtonDownLandscape = VK_RIGHT;
; 1533 :         pInfo->ptButtonDown.x = 88;
; 1534 :         pInfo->ptButtonDown.y = 270;

  00120	e383300e	 orr         r3, r3, #0xE

; 1535 :         pInfo->vkButtonLeftPortrait = VK_LEFT;
; 1536 :         pInfo->vkButtonLeftLandscape = VK_DOWN;
; 1537 :         pInfo->ptButtonLeft.x = 78;
; 1538 :         pInfo->ptButtonLeft.y = 260;
; 1539 :         pInfo->vkButtonRightPortrait = VK_RIGHT;
; 1540 :         pInfo->vkButtonRightLandscape = VK_UP;
; 1541 :         pInfo->ptButtonRight.x = 98;
; 1542 :         pInfo->ptButtonRight.y = 260;
; 1543 : 
; 1544 : #if 1       // default to Smartphone settings for now
; 1545 :         pInfo->vkButtonAPortrait = VK_F1;   // Softkey 1
; 1546 :         pInfo->vkButtonALandscape = VK_F1;
; 1547 :         pInfo->ptButtonA.x = 10;
; 1548 :         pInfo->ptButtonA.y = 240;
; 1549 :         pInfo->vkButtonBPortrait = VK_F2;   // Softkey 2
; 1550 :         pInfo->vkButtonBLandscape = VK_F2;
; 1551 :         pInfo->ptButtonB.x = 166;
; 1552 :         pInfo->ptButtonB.y = 240;
; 1553 :         pInfo->vkButtonCPortrait = VK_F8;   // Asterisk on keypad
; 1554 :         pInfo->vkButtonCLandscape = VK_F8;
; 1555 :         pInfo->ptButtonC.x = 10;
; 1556 :         pInfo->ptButtonC.y = 320;

  00124	e5823030	 str         r3, [r2, #0x30]
  00128	e3a03070	 mov         r3, #0x70

; 1557 : #else
; 1558 :         //  Added For GAPI to map Literal A, B, C
; 1559 :         pInfo->vkButtonAPortrait = VK_APP_LAUNCH1;
; 1560 :         pInfo->vkButtonALandscape = VK_APP_LAUNCH1;
; 1561 :         pInfo->ptButtonA.x = 10;
; 1562 :         pInfo->ptButtonA.y = 240;
; 1563 :         pInfo->vkButtonBPortrait = VK_APP_LAUNCH4;
; 1564 :         pInfo->vkButtonBLandscape = VK_APP_LAUNCH4;
; 1565 :         pInfo->ptButtonB.x = 166;
; 1566 :         pInfo->ptButtonB.y = 240;
; 1567 :         pInfo->vkButtonCPortrait = VK_APP_LAUNCH2;   // Asterisk on keypad
; 1568 :         pInfo->vkButtonCLandscape = VK_APP_LAUNCH2;
; 1569 :         pInfo->ptButtonC.x = 10;
; 1570 :         pInfo->ptButtonC.y = 320;
; 1571 : #endif
; 1572 :         pInfo->vkButtonStartPortrait  = '\r';
; 1573 :         pInfo->vkButtonStartLandscape = '\r';
; 1574 :         pInfo->ptButtonStart.x = 88;
; 1575 :         pInfo->ptButtonStart.y = 260;
; 1576 :         pInfo->pvReserved1 = (void *) 0;

  0012c	e1c234bc	 strh        r3, [r2, #0x4C]
  00130	e1c234be	 strh        r3, [r2, #0x4E]
  00134	e3a0300a	 mov         r3, #0xA
  00138	e5821014	 str         r1, [r2, #0x14]
  0013c	e5823050	 str         r3, [r2, #0x50]
  00140	e5823068	 str         r3, [r2, #0x68]
  00144	e3a01028	 mov         r1, #0x28
  00148	e3a03d05	 mov         r3, #5, 26
  0014c	e3a040fa	 mov         r4, #0xFA
  00150	e3a00025	 mov         r0, #0x25
  00154	e3a0a058	 mov         r10, #0x58
  00158	e1c212b8	 strh        r1, [r2, #0x28]
  0015c	e1c213b6	 strh        r1, [r2, #0x36]
  00160	e582306c	 str         r3, [r2, #0x6C]
  00164	e1c201be	 strh        r0, [r2, #0x1E]
  00168	e582a020	 str         r10, [r2, #0x20]
  0016c	e5824024	 str         r4, [r2, #0x24]
  00170	e1c203b4	 strh        r0, [r2, #0x34]
  00174	e3a010a6	 mov         r1, #0xA6
  00178	e3a03000	 mov         r3, #0
  0017c	e3a0704e	 mov         r7, #0x4E
  00180	e3a06026	 mov         r6, #0x26
  00184	e3a0e027	 mov         lr, #0x27
  00188	e3a080f0	 mov         r8, #0xF0
  0018c	e3a05071	 mov         r5, #0x71
  00190	e3a09077	 mov         r9, #0x77
  00194	e3a0b00d	 mov         r11, #0xD
  00198	e3a04058	 mov         r4, #0x58
  0019c	e3a00f41	 mov         r0, #0x41, 30
  001a0	e3a0a062	 mov         r10, #0x62
  001a4	e582105c	 str         r1, [r2, #0x5C]
  001a8	e582307c	 str         r3, [r2, #0x7C]

; 1577 :         pInfo->pvReserved2 = (void *) 0;

  001ac	e5823080	 str         r3, [r2, #0x80]
  001b0	e1c261bc	 strh        r6, [r2, #0x1C]
  001b4	e1c2e2ba	 strh        lr, [r2, #0x2A]
  001b8	e582402c	 str         r4, [r2, #0x2C]
  001bc	e5827038	 str         r7, [r2, #0x38]
  001c0	e582003c	 str         r0, [r2, #0x3C]
  001c4	e1c2e4b0	 strh        lr, [r2, #0x40]
  001c8	e1c264b2	 strh        r6, [r2, #0x42]
  001cc	e582a044	 str         r10, [r2, #0x44]
  001d0	e5820048	 str         r0, [r2, #0x48]
  001d4	e5828054	 str         r8, [r2, #0x54]
  001d8	e1c255b8	 strh        r5, [r2, #0x58]
  001dc	e1c255ba	 strh        r5, [r2, #0x5A]
  001e0	e5828060	 str         r8, [r2, #0x60]
  001e4	e1c296b4	 strh        r9, [r2, #0x64]
  001e8	e1c296b6	 strh        r9, [r2, #0x66]
  001ec	e1c2b7b0	 strh        r11, [r2, #0x70]
  001f0	e1c2b7b2	 strh        r11, [r2, #0x72]
  001f4	e5824074	 str         r4, [r2, #0x74]
  001f8	e5820078	 str         r0, [r2, #0x78]

; 1578 : 
; 1579 :         rc = 1;

  001fc	e3a01001	 mov         r1, #1

; 1580 :     }
; 1581 :     else {

  00200	ea000002	 b           |$cleanUp$42332|
  00204		 |$LN12@GetGameXIn|

; 1582 :         SetLastError (ERROR_INVALID_PARAMETER);

  00204	e3a00057	 mov         r0, #0x57
  00208	eb000000	 bl          SetLastError

; 1583 :         rc = -1;

  0020c	e3e01000	 mvn         r1, #0
  00210		 |$cleanUp$42332|

; 1584 :     }
; 1585 : 
; 1586 : cleanUp:
; 1587 :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::GetGameXInfo: %d\r\n", rc));
; 1588 :     return rc;
; 1589 : }

  00210	e1a00001	 mov         r0, r1
  00214	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00218	e12fff1e	 bx          lr
  0021c		 |$M43310|

			 ENDP  ; |?GetGameXInfo@OMAP2420GPE@@QAAHKKPAXK0@Z|, OMAP2420GPE::GetGameXInfo

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?ReadI2C@OMAP2420GPE@@QAAHKKEPAE@Z|	; OMAP2420GPE::ReadI2C
	IMPORT	|DeviceIoControl|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T43336| DCD	|$LN9@ReadI2C|
	DCD	0xc0004c02

  00000			 AREA	 |.xdata|, DATA
|$T43332| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43332|

  00008		 |?ReadI2C@OMAP2420GPE@@QAAHKKEPAE@Z| PROC ; OMAP2420GPE::ReadI2C

; 1934 : {

  00008		 |$LN9@ReadI2C|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dde19	 sub         sp, sp, #0x19, 28
  00010		 |$M43333|
  00010	e1a08003	 mov         r8, r3
  00014	e1a05002	 mov         r5, r2
  00018	e1a04001	 mov         r4, r1
  0001c	e1a07000	 mov         r7, r0
  00020	e59fe10c	 ldr         lr, [pc, #0x10C]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de18c	 str         lr, [sp, #0x18C]

; 1935 :     DWORD                   dwNumBytes;
; 1936 :     I2C_SET_SLAVE_ADDRESS   sI2CAddress;
; 1937 :     I2CTRANS                sI2C_Transaction;
; 1938 : 
; 1939 :     // set the I2C slave address
; 1940 :     sI2CAddress.address = dwAddress;
; 1941 :     sI2CAddress.size = dwAddressSize;
; 1942 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_SET_SLAVE_ADDRESS, (PVOID)&sI2CAddress, sizeof(sI2CAddress), NULL, 0, NULL, NULL))

  0002c	e59700f4	 ldr         r0, [r7, #0xF4]
  00030	e3a01822	 mov         r1, #0x22, 16
  00034	e59d61b4	 ldr         r6, [sp, #0x1B4]
  00038	e3a0e000	 mov         lr, #0
  0003c	e3811b02	 orr         r1, r1, #2, 22
  00040	e3a03008	 mov         r3, #8
  00044	e28d2010	 add         r2, sp, #0x10
  00048	e58d4014	 str         r4, [sp, #0x14]
  0004c	e58d5010	 str         r5, [sp, #0x10]
  00050	e58de00c	 str         lr, [sp, #0xC]
  00054	e58de008	 str         lr, [sp, #8]
  00058	e58de004	 str         lr, [sp, #4]
  0005c	e58de000	 str         lr, [sp]
  00060	eb000000	 bl          DeviceIoControl
  00064	e3500000	 cmp         r0, #0
  00068	1a000003	 bne         |$LN3@ReadI2C|
  0006c		 |$LN6@ReadI2C|

; 1943 :     {
; 1944 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:ReadI2C: Failed (%08X) to set I2C slave address\r\n", GetLastError()));
; 1945 :         return FALSE;

  0006c	e59d018c	 ldr         r0, [sp, #0x18C]
  00070	eb000000	 bl          __security_check_cookie
  00074	e3a00000	 mov         r0, #0
  00078	ea000029	 b           |$LN4@ReadI2C|
  0007c		 |$LN3@ReadI2C|

; 1946 :     }
; 1947 : 
; 1948 :     ZeroMemory(&sI2C_Transaction,sizeof(sI2C_Transaction));

  0007c	e3a02e17	 mov         r2, #0x17, 28
  00080	e3a01000	 mov         r1, #0
  00084	e28d001c	 add         r0, sp, #0x1C
  00088	eb000000	 bl          memset

; 1949 :     sI2C_Transaction.mClk_HL_Divisor = I2C_CLOCK_DEFAULT;
; 1950 :     sI2C_Transaction.mOpCode[0] = I2C_OPCODE_WRITE;
; 1951 :     sI2C_Transaction.mBufferOffset[0] = 0;
; 1952 :     sI2C_Transaction.mBuffer[0] = ucReg;
; 1953 :     sI2C_Transaction.mTransLen[0] = 1;
; 1954 :     sI2C_Transaction.mOpCode[1] = I2C_OPCODE_READ;
; 1955 :     sI2C_Transaction.mBufferOffset[1] = 1;
; 1956 :     sI2C_Transaction.mTransLen[1] = 1;
; 1957 :     
; 1958 :     //Issue transaction
; 1959 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_TRANSACT, NULL, 0, &sI2C_Transaction, sizeof(sI2C_Transaction), &dwNumBytes, NULL))

  0008c	e3a0500f	 mov         r5, #0xF
  00090	e58d5024	 str         r5, [sp, #0x24]
  00094	e3a05001	 mov         r5, #1
  00098	e58d504c	 str         r5, [sp, #0x4C]
  0009c	e3a05001	 mov         r5, #1
  000a0	e59f1088	 ldr         r1, [pc, #0x88]
  000a4	e59700f4	 ldr         r0, [r7, #0xF4]
  000a8	e28de018	 add         lr, sp, #0x18
  000ac	e58d506c	 str         r5, [sp, #0x6C]
  000b0	e58de008	 str         lr, [sp, #8]
  000b4	e3a05000	 mov         r5, #0
  000b8	e3a07002	 mov         r7, #2
  000bc	e3a09000	 mov         r9, #0
  000c0	e3a0a001	 mov         r10, #1
  000c4	e3a0b001	 mov         r11, #1
  000c8	e28d401c	 add         r4, sp, #0x1C
  000cc	e3a0ee17	 mov         lr, #0x17, 28
  000d0	e3a03000	 mov         r3, #0
  000d4	e3a02000	 mov         r2, #0
  000d8	e58d500c	 str         r5, [sp, #0xC]
  000dc	e58d7028	 str         r7, [sp, #0x28]
  000e0	e58d9048	 str         r9, [sp, #0x48]
  000e4	e5cd808c	 strb        r8, [sp, #0x8C]
  000e8	e58da068	 str         r10, [sp, #0x68]
  000ec	e58db02c	 str         r11, [sp, #0x2C]
  000f0	e58de004	 str         lr, [sp, #4]
  000f4	e58d4000	 str         r4, [sp]
  000f8	eb000000	 bl          DeviceIoControl
  000fc	e3500000	 cmp         r0, #0

; 1960 :     {
; 1961 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:IOCTL_I2C_TRANSACT: Failed "));
; 1962 :         return FALSE;

  00100	0affffd9	 beq         |$LN6@ReadI2C|

; 1963 :     }
; 1964 : 
; 1965 :     if (sI2C_Transaction.mErrorCode)

  00104	e59d3088	 ldr         r3, [sp, #0x88]
  00108	e3530000	 cmp         r3, #0

; 1966 :     {
; 1967 :         DEBUGMSG(GPE_ZONE_ERROR, (L"CMenelaus::ReadData failed with error code 0x%08X\r\n", sI2C_Transaction.mErrorCode));
; 1968 :         return FALSE;

  0010c	1affffd6	 bne         |$LN6@ReadI2C|

; 1969 :     }
; 1970 : 
; 1971 :     *pucData = sI2C_Transaction.mBuffer[1];

  00110	e5dd308d	 ldrb        r3, [sp, #0x8D]
  00114	e5c63000	 strb        r3, [r6]

; 1972 :     return TRUE;

  00118	e59d018c	 ldr         r0, [sp, #0x18C]
  0011c	eb000000	 bl          __security_check_cookie
  00120	e3a00001	 mov         r0, #1
  00124		 |$LN4@ReadI2C|

; 1973 : }

  00124	e28dde19	 add         sp, sp, #0x19, 28
  00128	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$LN10@ReadI2C|
  00130		 |$LN11@ReadI2C|
  00130	00220804	 DCD         0x220804
  00134		 |$LN12@ReadI2C|
  00134	00000000	 DCD         |__security_cookie|
  00138		 |$M43334|

			 ENDP  ; |?ReadI2C@OMAP2420GPE@@QAAHKKEPAE@Z|, OMAP2420GPE::ReadI2C

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?WriteI2C@OMAP2420GPE@@QAAHKKEE@Z|	; OMAP2420GPE::WriteI2C

  00000			 AREA	 |.pdata|, PDATA
|$T43359| DCD	|$LN10@WriteI2C|
	DCD	0xc0004402

  00000			 AREA	 |.xdata|, DATA
|$T43355| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43355|

  00008		 |?WriteI2C@OMAP2420GPE@@QAAHKKEE@Z| PROC ; OMAP2420GPE::WriteI2C

; 1979 : {

  00008		 |$LN10@WriteI2C|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dde19	 sub         sp, sp, #0x19, 28
  00010		 |$M43356|
  00010	e1a07003	 mov         r7, r3
  00014	e1a05002	 mov         r5, r2
  00018	e1a04001	 mov         r4, r1
  0001c	e1a06000	 mov         r6, r0
  00020	e59fe0ec	 ldr         lr, [pc, #0xEC]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de18c	 str         lr, [sp, #0x18C]

; 1980 :     DWORD                   dwNumBytes;
; 1981 :     I2C_SET_SLAVE_ADDRESS   sI2CAddress;
; 1982 :     I2CTRANS                sI2C_Transaction;
; 1983 : 
; 1984 :     // set the I2C slave address
; 1985 :     sI2CAddress.address = dwAddress;
; 1986 :     sI2CAddress.size = dwAddressSize;
; 1987 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_SET_SLAVE_ADDRESS, (PVOID)&sI2CAddress, sizeof(sI2CAddress), NULL, 0, NULL, NULL))

  0002c	e59600f4	 ldr         r0, [r6, #0xF4]
  00030	e3a01822	 mov         r1, #0x22, 16
  00034	e3a0b000	 mov         r11, #0
  00038	e3811b02	 orr         r1, r1, #2, 22
  0003c	e3a03008	 mov         r3, #8
  00040	e28d2010	 add         r2, sp, #0x10
  00044	e58d4014	 str         r4, [sp, #0x14]
  00048	e58d5010	 str         r5, [sp, #0x10]
  0004c	e58db00c	 str         r11, [sp, #0xC]
  00050	e58db008	 str         r11, [sp, #8]
  00054	e58db004	 str         r11, [sp, #4]
  00058	e58db000	 str         r11, [sp]
  0005c	eb000000	 bl          DeviceIoControl
  00060	e3500000	 cmp         r0, #0
  00064	1a000003	 bne         |$LN3@WriteI2C|
  00068		 |$LN6@WriteI2C|

; 1988 :     {
; 1989 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:ReadI2C: "
; 1990 :             L"Failed (%08X) to set I2C slave address\r\n", GetLastError()));
; 1991 :         return FALSE;

  00068	e59d018c	 ldr         r0, [sp, #0x18C]
  0006c		 |$LN7@WriteI2C|
  0006c	eb000000	 bl          __security_check_cookie
  00070	e3a00000	 mov         r0, #0
  00074	ea000022	 b           |$LN4@WriteI2C|
  00078		 |$LN3@WriteI2C|

; 1992 :     }
; 1993 : 
; 1994 :     ZeroMemory(&sI2C_Transaction,sizeof(sI2C_Transaction));

  00078	e3a02e17	 mov         r2, #0x17, 28
  0007c	e3a01000	 mov         r1, #0
  00080	e28d001c	 add         r0, sp, #0x1C
  00084	eb000000	 bl          memset

; 1995 :     sI2C_Transaction.mClk_HL_Divisor = I2C_CLOCK_DEFAULT;
; 1996 :     sI2C_Transaction.mOpCode[0] = I2C_OPCODE_WRITE;
; 1997 :     sI2C_Transaction.mBufferOffset[0] = 0;
; 1998 :     sI2C_Transaction.mBuffer[0] = ucReg;
; 1999 :     sI2C_Transaction.mBuffer[1] = ucData;

  00088	e5dd31b4	 ldrb        r3, [sp, #0x1B4]

; 2000 :     sI2C_Transaction.mTransLen[0] = 2;
; 2001 : 
; 2002 :     //Issue transaction
; 2003 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_TRANSACT, NULL, 0, &sI2C_Transaction, sizeof(sI2C_Transaction), &dwNumBytes, NULL))

  0008c	e59f107c	 ldr         r1, [pc, #0x7C]
  00090	e59600f4	 ldr         r0, [r6, #0xF4]
  00094	e5cd308d	 strb        r3, [sp, #0x8D]
  00098	e3a0500f	 mov         r5, #0xF
  0009c	e3a06002	 mov         r6, #2
  000a0	e3a08000	 mov         r8, #0
  000a4	e3a09002	 mov         r9, #2
  000a8	e28de018	 add         lr, sp, #0x18
  000ac	e3a0ae17	 mov         r10, #0x17, 28
  000b0	e28d401c	 add         r4, sp, #0x1C
  000b4	e3a03000	 mov         r3, #0
  000b8	e3a02000	 mov         r2, #0
  000bc	e58d5024	 str         r5, [sp, #0x24]
  000c0	e58d6028	 str         r6, [sp, #0x28]
  000c4	e58d8048	 str         r8, [sp, #0x48]
  000c8	e5cd708c	 strb        r7, [sp, #0x8C]
  000cc	e58d9068	 str         r9, [sp, #0x68]
  000d0	e58db00c	 str         r11, [sp, #0xC]
  000d4	e58de008	 str         lr, [sp, #8]
  000d8	e58da004	 str         r10, [sp, #4]
  000dc	e58d4000	 str         r4, [sp]
  000e0	eb000000	 bl          DeviceIoControl
  000e4	e3500000	 cmp         r0, #0

; 2004 :     {
; 2005 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:IOCTL_I2C_TRANSACT: Failed "));
; 2006 :         return FALSE;

  000e8	0affffde	 beq         |$LN6@WriteI2C|

; 2007 :     }
; 2008 : 
; 2009 :     if (sI2C_Transaction.mErrorCode)

  000ec	e59d3088	 ldr         r3, [sp, #0x88]
  000f0	e3530000	 cmp         r3, #0

; 2010 :     {
; 2011 :         DEBUGMSG(GPE_ZONE_ERROR, (L"CMenelaus::ReadData failed with error code 0x%08X\r\n", sI2C_Transaction.mErrorCode));
; 2012 :         return FALSE;

  000f4	e59d018c	 ldr         r0, [sp, #0x18C]
  000f8	1affffdb	 bne         |$LN7@WriteI2C|

; 2013 :     }
; 2014 : 
; 2015 :     return TRUE;

  000fc	eb000000	 bl          __security_check_cookie
  00100	e3a00001	 mov         r0, #1
  00104		 |$LN4@WriteI2C|

; 2016 : }

  00104	e28dde19	 add         sp, sp, #0x19, 28
  00108	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN11@WriteI2C|
  00110		 |$LN12@WriteI2C|
  00110	00220804	 DCD         0x220804
  00114		 |$LN13@WriteI2C|
  00114	00000000	 DCD         |__security_cookie|
  00118		 |$M43357|

			 ENDP  ; |?WriteI2C@OMAP2420GPE@@QAAHKKEE@Z|, OMAP2420GPE::WriteI2C

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?ReadI2CIO@OMAP2420GPE@@QAAHKKPAE@Z|	; OMAP2420GPE::ReadI2CIO

  00000			 AREA	 |.pdata|, PDATA
|$T43383| DCD	|$LN9@ReadI2CIO|
	DCD	0xc0004302

  00000			 AREA	 |.xdata|, DATA
|$T43379| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43379|

  00008		 |?ReadI2CIO@OMAP2420GPE@@QAAHKKPAE@Z| PROC ; OMAP2420GPE::ReadI2CIO

; 2022 : {

  00008		 |$LN9@ReadI2CIO|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dde19	 sub         sp, sp, #0x19, 28
  00010		 |$M43380|
  00010	e1a06003	 mov         r6, r3
  00014	e1a05002	 mov         r5, r2
  00018	e1a04001	 mov         r4, r1
  0001c	e1a07000	 mov         r7, r0
  00020	e59fe0e8	 ldr         lr, [pc, #0xE8]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de18c	 str         lr, [sp, #0x18C]

; 2023 :     DWORD                   dwNumBytes;
; 2024 :     I2C_SET_SLAVE_ADDRESS   sI2CAddress;
; 2025 :     I2CTRANS                sI2C_Transaction;
; 2026 : 
; 2027 :     // set the I2C slave address
; 2028 :     sI2CAddress.address = dwAddress;
; 2029 :     sI2CAddress.size = dwAddressSize;
; 2030 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_SET_SLAVE_ADDRESS, (PVOID)&sI2CAddress, sizeof(sI2CAddress), NULL, 0, NULL, NULL))

  0002c	e59700f4	 ldr         r0, [r7, #0xF4]
  00030	e3a01822	 mov         r1, #0x22, 16
  00034	e3a0b000	 mov         r11, #0
  00038	e3811b02	 orr         r1, r1, #2, 22
  0003c	e3a03008	 mov         r3, #8
  00040	e28d2010	 add         r2, sp, #0x10
  00044	e58d4014	 str         r4, [sp, #0x14]
  00048	e58d5010	 str         r5, [sp, #0x10]
  0004c	e58db00c	 str         r11, [sp, #0xC]
  00050	e58db008	 str         r11, [sp, #8]
  00054	e58db004	 str         r11, [sp, #4]
  00058	e58db000	 str         r11, [sp]
  0005c	eb000000	 bl          DeviceIoControl
  00060	e3500000	 cmp         r0, #0
  00064	1a000003	 bne         |$LN3@ReadI2CIO|
  00068		 |$LN6@ReadI2CIO|

; 2031 :     {
; 2032 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:ReadI2C: "
; 2033 :             L"Failed (%08X) to set I2C slave address\r\n", GetLastError()));
; 2034 :         return FALSE;

  00068	e59d018c	 ldr         r0, [sp, #0x18C]
  0006c	eb000000	 bl          __security_check_cookie
  00070	e3a00000	 mov         r0, #0
  00074	ea000021	 b           |$LN4@ReadI2CIO|
  00078		 |$LN3@ReadI2CIO|

; 2035 :     }
; 2036 : 
; 2037 :     ZeroMemory(&sI2C_Transaction,sizeof(sI2C_Transaction));

  00078	e3a02e17	 mov         r2, #0x17, 28
  0007c	e3a01000	 mov         r1, #0
  00080	e28d001c	 add         r0, sp, #0x1C
  00084	eb000000	 bl          memset

; 2038 :     sI2C_Transaction.mClk_HL_Divisor  = I2C_CLOCK_DEFAULT;
; 2039 :     sI2C_Transaction.mOpCode[0]       = I2C_OPCODE_READ;
; 2040 :     sI2C_Transaction.mTransLen[0]     = 1;
; 2041 :     sI2C_Transaction.mBufferOffset[0] = 0;
; 2042 : 
; 2043 :     //Issue transaction
; 2044 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_TRANSACT, NULL, 0, &sI2C_Transaction, sizeof(sI2C_Transaction), &dwNumBytes, NULL))

  00088	e59f107c	 ldr         r1, [pc, #0x7C]
  0008c	e59700f4	 ldr         r0, [r7, #0xF4]
  00090	e3a07001	 mov         r7, #1
  00094	e28de018	 add         lr, sp, #0x18
  00098	e3a0500f	 mov         r5, #0xF
  0009c	e3a08001	 mov         r8, #1
  000a0	e3a09000	 mov         r9, #0
  000a4	e3a0ae17	 mov         r10, #0x17, 28
  000a8	e28d401c	 add         r4, sp, #0x1C
  000ac	e3a03000	 mov         r3, #0
  000b0	e3a02000	 mov         r2, #0
  000b4	e58d7028	 str         r7, [sp, #0x28]
  000b8	e58de008	 str         lr, [sp, #8]
  000bc	e58d5024	 str         r5, [sp, #0x24]
  000c0	e58d8068	 str         r8, [sp, #0x68]
  000c4	e58d9048	 str         r9, [sp, #0x48]
  000c8	e58db00c	 str         r11, [sp, #0xC]
  000cc	e58da004	 str         r10, [sp, #4]
  000d0	e58d4000	 str         r4, [sp]
  000d4	eb000000	 bl          DeviceIoControl
  000d8	e3500000	 cmp         r0, #0

; 2045 :     {
; 2046 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:IOCTL_I2C_TRANSACT: Failed "));
; 2047 :         return FALSE;

  000dc	0affffe1	 beq         |$LN6@ReadI2CIO|

; 2048 :     }
; 2049 : 
; 2050 :     if (sI2C_Transaction.mErrorCode)

  000e0	e59d3088	 ldr         r3, [sp, #0x88]
  000e4	e3530000	 cmp         r3, #0

; 2051 :     {
; 2052 :         DEBUGMSG(GPE_ZONE_ERROR, (L"CMenelaus::ReadData failed with error code 0x%08X\r\n", sI2C_Transaction.mErrorCode));
; 2053 :         return FALSE;

  000e8	1affffde	 bne         |$LN6@ReadI2CIO|

; 2054 :     }
; 2055 : 
; 2056 :     *pucData = sI2C_Transaction.mBuffer[0];

  000ec	e5dd308c	 ldrb        r3, [sp, #0x8C]
  000f0	e5c63000	 strb        r3, [r6]

; 2057 :     return TRUE;

  000f4	e59d018c	 ldr         r0, [sp, #0x18C]
  000f8	eb000000	 bl          __security_check_cookie
  000fc	e3a00001	 mov         r0, #1
  00100		 |$LN4@ReadI2CIO|

; 2058 : }

  00100	e28dde19	 add         sp, sp, #0x19, 28
  00104	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN10@ReadI2CIO|
  0010c		 |$LN11@ReadI2CIO|
  0010c	00220804	 DCD         0x220804
  00110		 |$LN12@ReadI2CIO|
  00110	00000000	 DCD         |__security_cookie|
  00114		 |$M43381|

			 ENDP  ; |?ReadI2CIO@OMAP2420GPE@@QAAHKKPAE@Z|, OMAP2420GPE::ReadI2CIO

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?WriteI2CIO@OMAP2420GPE@@QAAHKKE@Z|	; OMAP2420GPE::WriteI2CIO

  00000			 AREA	 |.pdata|, PDATA
|$T43406| DCD	|$LN10@WriteI2CIO|
	DCD	0xc0004002

  00000			 AREA	 |.xdata|, DATA
|$T43402| DCD	0xffffffdc
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43402|

  00008		 |?WriteI2CIO@OMAP2420GPE@@QAAHKKE@Z| PROC ; OMAP2420GPE::WriteI2CIO

; 2064 : {

  00008		 |$LN10@WriteI2CIO|
  00008	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  0000c	e24dde19	 sub         sp, sp, #0x19, 28
  00010		 |$M43403|
  00010	e1a07003	 mov         r7, r3
  00014	e1a05002	 mov         r5, r2
  00018	e1a04001	 mov         r4, r1
  0001c	e1a06000	 mov         r6, r0
  00020	e59fe0dc	 ldr         lr, [pc, #0xDC]
  00024	e59ee000	 ldr         lr, [lr]
  00028	e58de18c	 str         lr, [sp, #0x18C]

; 2065 :     DWORD                   dwNumBytes;
; 2066 :     I2C_SET_SLAVE_ADDRESS   sI2CAddress;
; 2067 :     I2CTRANS                sI2C_Transaction;
; 2068 : 
; 2069 :     // set the I2C slave address
; 2070 :     sI2CAddress.address = dwAddress;
; 2071 :     sI2CAddress.size = dwAddressSize;
; 2072 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_SET_SLAVE_ADDRESS, (PVOID)&sI2CAddress, sizeof(sI2CAddress), NULL, 0, NULL, NULL))

  0002c	e59600f4	 ldr         r0, [r6, #0xF4]
  00030	e3a01822	 mov         r1, #0x22, 16
  00034	e3a0a000	 mov         r10, #0
  00038	e3811b02	 orr         r1, r1, #2, 22
  0003c	e3a03008	 mov         r3, #8
  00040	e28d2010	 add         r2, sp, #0x10
  00044	e58d4014	 str         r4, [sp, #0x14]
  00048	e58d5010	 str         r5, [sp, #0x10]
  0004c	e58da00c	 str         r10, [sp, #0xC]
  00050	e58da008	 str         r10, [sp, #8]
  00054	e58da004	 str         r10, [sp, #4]
  00058	e58da000	 str         r10, [sp]
  0005c	eb000000	 bl          DeviceIoControl
  00060	e3500000	 cmp         r0, #0
  00064	1a000003	 bne         |$LN3@WriteI2CIO|
  00068		 |$LN6@WriteI2CIO|

; 2073 :     {
; 2074 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:ReadI2C: "
; 2075 :             L"Failed (%08X) to set I2C slave address\r\n", GetLastError()));
; 2076 :         return FALSE;

  00068	e59d018c	 ldr         r0, [sp, #0x18C]
  0006c		 |$LN7@WriteI2CIO|
  0006c	eb000000	 bl          __security_check_cookie
  00070	e3a00000	 mov         r0, #0
  00074	ea00001e	 b           |$LN4@WriteI2CIO|
  00078		 |$LN3@WriteI2CIO|

; 2077 :     }
; 2078 : 
; 2079 :     ZeroMemory(&sI2C_Transaction,sizeof(sI2C_Transaction));

  00078	e3a02e17	 mov         r2, #0x17, 28
  0007c	e3a01000	 mov         r1, #0
  00080	e28d001c	 add         r0, sp, #0x1C
  00084	eb000000	 bl          memset

; 2080 :     sI2C_Transaction.mOpCode[0]       = I2C_OPCODE_WRITE;
; 2081 :     sI2C_Transaction.mTransLen[0]     = 1;
; 2082 :     sI2C_Transaction.mBufferOffset[0] = 0;
; 2083 :     sI2C_Transaction.mBuffer[0] = ucData;
; 2084 : 
; 2085 :     //Issue transaction
; 2086 :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_TRANSACT, NULL, 0, &sI2C_Transaction, sizeof(sI2C_Transaction), &dwNumBytes, NULL))

  00088	e59f1070	 ldr         r1, [pc, #0x70]
  0008c	e59600f4	 ldr         r0, [r6, #0xF4]
  00090	e3a06001	 mov         r6, #1
  00094	e28de018	 add         lr, sp, #0x18
  00098	e3a05002	 mov         r5, #2
  0009c	e3a08000	 mov         r8, #0
  000a0	e3a09e17	 mov         r9, #0x17, 28
  000a4	e28d401c	 add         r4, sp, #0x1C
  000a8	e3a03000	 mov         r3, #0
  000ac	e3a02000	 mov         r2, #0
  000b0	e58d6068	 str         r6, [sp, #0x68]
  000b4	e58de008	 str         lr, [sp, #8]
  000b8	e58d5028	 str         r5, [sp, #0x28]
  000bc	e58d8048	 str         r8, [sp, #0x48]
  000c0	e5cd708c	 strb        r7, [sp, #0x8C]
  000c4	e58da00c	 str         r10, [sp, #0xC]
  000c8	e58d9004	 str         r9, [sp, #4]
  000cc	e58d4000	 str         r4, [sp]
  000d0	eb000000	 bl          DeviceIoControl
  000d4	e3500000	 cmp         r0, #0

; 2087 :     {
; 2088 :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE:IOCTL_I2C_TRANSACT: Failed "));
; 2089 :         return FALSE;

  000d8	0affffe2	 beq         |$LN6@WriteI2CIO|

; 2090 :     }
; 2091 : 
; 2092 :     if (sI2C_Transaction.mErrorCode)

  000dc	e59d3088	 ldr         r3, [sp, #0x88]
  000e0	e3530000	 cmp         r3, #0

; 2093 :     {
; 2094 :         DEBUGMSG(GPE_ZONE_ERROR, (L"CMenelaus::ReadData failed with error code 0x%08X\r\n", sI2C_Transaction.mErrorCode));
; 2095 :         return FALSE;

  000e4	e59d018c	 ldr         r0, [sp, #0x18C]
  000e8	1affffdf	 bne         |$LN7@WriteI2CIO|

; 2096 :     }
; 2097 : 
; 2098 :     return TRUE;

  000ec	eb000000	 bl          __security_check_cookie
  000f0	e3a00001	 mov         r0, #1
  000f4		 |$LN4@WriteI2CIO|

; 2099 : }

  000f4	e28dde19	 add         sp, sp, #0x19, 28
  000f8	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$LN11@WriteI2CIO|
  00100		 |$LN12@WriteI2CIO|
  00100	00220804	 DCD         0x220804
  00104		 |$LN13@WriteI2CIO|
  00104	00000000	 DCD         |__security_cookie|
  00108		 |$M43404|

			 ENDP  ; |?WriteI2CIO@OMAP2420GPE@@QAAHKKE@Z|, OMAP2420GPE::WriteI2CIO

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T43421| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAP2420GPE@@UAAPAXI@Z| PROC	; OMAP2420GPE::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43418|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAP2420GPE@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43419|

			 ENDP  ; |??_GOMAP2420GPE@@UAAPAXI@Z|, OMAP2420GPE::`scalar deleting destructor'

	EXPORT	|?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z| ; OMAP2420GPE::SetPower
	IMPORT	|LeaveCriticalSection|
	IMPORT	|KernelIoControl|
	IMPORT	|DisplayPddSetPower|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43442| DCD	|$LN20@SetPower|
	DCD	0x4000ac02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z| PROC ; OMAP2420GPE::SetPower

; 1272 : {

  00000		 |$LN20@SetPower|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd070	 sub         sp, sp, #0x70
  00008		 |$M43439|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 1273 :     UCHAR   ucData;
; 1274 :     BOOL    bRetVal = FALSE;
; 1275 :     DWORD   regBit,cbRet;
; 1276 : 
; 1277 : //    DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::SetPower State - %d\r\n",dx));
; 1278 :     
; 1279 :     EnterCriticalSection(&m_powerCS);

  00010	e28400d4	 add         r0, r4, #0xD4
  00014	e3a06000	 mov         r6, #0
  00018	eb000000	 bl          EnterCriticalSection

; 1280 : 
; 1281 :     // Device can't be set to greater power state than external (ceiling)
; 1282 :     if (dx < m_externalDX)

  0001c	e59430b4	 ldr         r3, [r4, #0xB4]
  00020	e1550003	 cmp         r5, r3

; 1283 :     {
; 1284 :         dx = m_externalDX;

  00024	b1a05003	 movlt       r5, r3

; 1285 :     }
; 1286 : 
; 1287 :     // only do something if the state has changed
; 1288 :     if (m_currentDX != dx)

  00028	e59430b0	 ldr         r3, [r4, #0xB0]
  0002c	e1530005	 cmp         r3, r5
  00030	0a000073	 beq         |$LN9@SetPower|

; 1289 :     {
; 1290 :         // Let display hardware set LCD device 
; 1291 :         DisplayPddSetPower(m_hDisplay, dx);

  00034	e5940088	 ldr         r0, [r4, #0x88]
  00038	e1a01005	 mov         r1, r5
  0003c	eb000000	 bl          DisplayPddSetPower

; 1292 :             
; 1293 :         if (dx <= D2) 

  00040	e3550002	 cmp         r5, #2
  00044	ca000032	 bgt         |$LN8@SetPower|

; 1294 :         {        
; 1295 :             //Enable functional clocks
; 1296 :             regBit = PRCM_FCLKEN1_CORE_EN_DSS1;
; 1297 :             KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00048	e59f025c	 ldr         r0, [pc, #0x25C]
  0004c	e3a02001	 mov         r2, #1
  00050	e28d3010	 add         r3, sp, #0x10
  00054	e58d200c	 str         r2, [sp, #0xC]
  00058	e58d3004	 str         r3, [sp, #4]
  0005c	e3a06000	 mov         r6, #0
  00060	e3a03000	 mov         r3, #0
  00064	e3a02004	 mov         r2, #4
  00068	e28d100c	 add         r1, sp, #0xC
  0006c	e58d6000	 str         r6, [sp]
  00070	eb000000	 bl          KernelIoControl

; 1298 :             regBit = PRCM_FCLKEN1_CORE_EN_DSS2;
; 1299 :             KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00074	e59f0230	 ldr         r0, [pc, #0x230]
  00078	e3a02002	 mov         r2, #2
  0007c	e28d3010	 add         r3, sp, #0x10
  00080	e58d200c	 str         r2, [sp, #0xC]
  00084	e58d3004	 str         r3, [sp, #4]
  00088	e3a03000	 mov         r3, #0
  0008c	e3a02004	 mov         r2, #4
  00090	e28d100c	 add         r1, sp, #0xC
  00094	e58d6000	 str         r6, [sp]
  00098	eb000000	 bl          KernelIoControl

; 1300 :             regBit = PRCM_FCLKEN1_CORE_EN_TV;
; 1301 :             KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  0009c	e59f0208	 ldr         r0, [pc, #0x208]
  000a0	e3a02004	 mov         r2, #4
  000a4	e28d3010	 add         r3, sp, #0x10
  000a8	e58d200c	 str         r2, [sp, #0xC]
  000ac	e58d3004	 str         r3, [sp, #4]
  000b0	e3a03000	 mov         r3, #0
  000b4	e3a02004	 mov         r2, #4
  000b8	e28d100c	 add         r1, sp, #0xC
  000bc	e58d6000	 str         r6, [sp]
  000c0	eb000000	 bl          KernelIoControl

; 1302 : 
; 1303 :             //Enable interface clocks
; 1304 :             regBit = PRCM_ICLKEN1_CORE_EN_DSS;
; 1305 :             KernelIoControl(IOCTL_ICLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  000c4	e59f01dc	 ldr         r0, [pc, #0x1DC]
  000c8	e28de010	 add         lr, sp, #0x10
  000cc	e3a07001	 mov         r7, #1
  000d0	e3a03000	 mov         r3, #0
  000d4	e3a02004	 mov         r2, #4
  000d8	e28d100c	 add         r1, sp, #0xC
  000dc	e58de004	 str         lr, [sp, #4]
  000e0	e58d700c	 str         r7, [sp, #0xC]
  000e4	e58d6000	 str         r6, [sp]
  000e8	eb000000	 bl          KernelIoControl

; 1306 :     
; 1307 :             //Enable LCD - These should be a single bit-set operation in the I2C driver
; 1308 :             bRetVal = ReadI2CIO(I2C_DISPLAY_ENABLE_ADDRESS, I2C_DISPLAY_ENABLE_ADDRSIZE, &ucData);

  000ec	e28d3008	 add         r3, sp, #8
  000f0	e3a02007	 mov         r2, #7
  000f4	e3a01020	 mov         r1, #0x20
  000f8	e1a00004	 mov         r0, r4
  000fc	eb000000	 bl          |?ReadI2CIO@OMAP2420GPE@@QAAHKKPAE@Z|
  00100	e3500000	 cmp         r0, #0

; 1309 :             if (bRetVal)

  00104	0a00003c	 beq         |$LN4@SetPower|

; 1310 :             {
; 1311 :                 //set the LCD_ENVDD bit
; 1312 :                 ucData |= (1 << 7);

  00108	e5dd3008	 ldrb        r3, [sp, #8]
  0010c	e3833080	 orr         r3, r3, #0x80

; 1313 : 
; 1314 :                 // write the new value
; 1315 :                 bRetVal = WriteI2CIO(I2C_DISPLAY_ENABLE_ADDRESS, I2C_DISPLAY_ENABLE_ADDRSIZE, ucData);
; 1316 :             }            
; 1317 :         }            

  00110	ea000035	 b           |$LN15@SetPower|
  00114		 |$LN8@SetPower|

; 1318 :         else if (dx >= D3) 

  00114	e3550003	 cmp         r5, #3
  00118	ba000037	 blt         |$LN4@SetPower|

; 1319 :         {        
; 1320 :             //Disable functional clocks
; 1321 :             regBit = PRCM_FCLKEN1_CORE_EN_DSS1;

  0011c	e3a02001	 mov         r2, #1

; 1322 :             KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00120	e28d3010	 add         r3, sp, #0x10
  00124	e3a07822	 mov         r7, #0x22, 16
  00128	e58d200c	 str         r2, [sp, #0xC]
  0012c	e58d3004	 str         r3, [sp, #4]
  00130	e3a06000	 mov         r6, #0
  00134	e3a03000	 mov         r3, #0
  00138	e3a02004	 mov         r2, #4
  0013c	e3870e42	 orr         r0, r7, #0x42, 28
  00140	e28d100c	 add         r1, sp, #0xC
  00144	e58d6000	 str         r6, [sp]
  00148	eb000000	 bl          KernelIoControl

; 1323 :             regBit = PRCM_FCLKEN1_CORE_EN_DSS2;

  0014c	e3a02002	 mov         r2, #2

; 1324 :             KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00150	e28d3010	 add         r3, sp, #0x10
  00154	e58d200c	 str         r2, [sp, #0xC]
  00158	e58d3004	 str         r3, [sp, #4]
  0015c	e3a03000	 mov         r3, #0
  00160	e3a02004	 mov         r2, #4
  00164	e28d100c	 add         r1, sp, #0xC
  00168	e3870e42	 orr         r0, r7, #0x42, 28
  0016c	e58d6000	 str         r6, [sp]
  00170	eb000000	 bl          KernelIoControl

; 1325 :             regBit = PRCM_FCLKEN1_CORE_EN_TV;

  00174	e3a02004	 mov         r2, #4

; 1326 :             KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00178	e28d3010	 add         r3, sp, #0x10
  0017c	e58d200c	 str         r2, [sp, #0xC]
  00180	e58d3004	 str         r3, [sp, #4]
  00184	e3a03000	 mov         r3, #0
  00188	e3a02004	 mov         r2, #4
  0018c	e28d100c	 add         r1, sp, #0xC
  00190	e3870e42	 orr         r0, r7, #0x42, 28
  00194	e58d6000	 str         r6, [sp]
  00198	eb000000	 bl          KernelIoControl
  0019c	e3a03822	 mov         r3, #0x22, 16

; 1327 :     
; 1328 :             //Disable interface clocks
; 1329 :             regBit = PRCM_ICLKEN1_CORE_EN_DSS;
; 1330 :             KernelIoControl(IOCTL_ICLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  001a0	e3830e41	 orr         r0, r3, #0x41, 28
  001a4	e3a07001	 mov         r7, #1
  001a8	e28de010	 add         lr, sp, #0x10
  001ac	e3a03000	 mov         r3, #0
  001b0	e3a02004	 mov         r2, #4
  001b4	e28d100c	 add         r1, sp, #0xC
  001b8	e58d700c	 str         r7, [sp, #0xC]
  001bc	e58de004	 str         lr, [sp, #4]
  001c0	e58d6000	 str         r6, [sp]
  001c4	eb000000	 bl          KernelIoControl

; 1331 :                 
; 1332 :             //Disable LCD - These should be a single bit-clear operation in the I2C driver
; 1333 :             bRetVal = ReadI2CIO(I2C_DISPLAY_ENABLE_ADDRESS, I2C_DISPLAY_ENABLE_ADDRSIZE, &ucData);

  001c8	e28d3008	 add         r3, sp, #8
  001cc	e3a02007	 mov         r2, #7
  001d0	e3a01020	 mov         r1, #0x20
  001d4	e1a00004	 mov         r0, r4
  001d8	eb000000	 bl          |?ReadI2CIO@OMAP2420GPE@@QAAHKKPAE@Z|
  001dc	e3500000	 cmp         r0, #0

; 1334 :             if (bRetVal)

  001e0	0a000005	 beq         |$LN4@SetPower|

; 1335 :             {
; 1336 :                 //set the LCD_ENVDD bit
; 1337 :                 ucData &= ~(1 << 7);

  001e4	e5dd3008	 ldrb        r3, [sp, #8]
  001e8	e203307f	 and         r3, r3, #0x7F
  001ec		 |$LN15@SetPower|

; 1338 : 
; 1339 :                 // write the new value
; 1340 :                 bRetVal = WriteI2CIO(I2C_DISPLAY_ENABLE_ADDRESS, I2C_DISPLAY_ENABLE_ADDRSIZE, ucData);

  001ec	e3a02007	 mov         r2, #7
  001f0	e3a01020	 mov         r1, #0x20
  001f4	e1a00004	 mov         r0, r4
  001f8	eb000000	 bl          |?WriteI2CIO@OMAP2420GPE@@QAAHKKE@Z|
  001fc		 |$LN4@SetPower|

; 1341 :             }            
; 1342 :         }
; 1343 :     
; 1344 :         // Update current power state
; 1345 :         m_currentDX = dx;

  001fc	e58450b0	 str         r5, [r4, #0xB0]

; 1346 :         bRetVal = TRUE;

  00200	e3a06001	 mov         r6, #1
  00204		 |$LN9@SetPower|

; 1347 :     }
; 1348 : 
; 1349 : 
; 1350 :     // If the power is on, there's a visible surface, and the SYNCLOST bug occurs, then reset everything
; 1351 :     // Temporary Black Screen bug fix - See OMAP2420 Silicon Errata - 1.9 and 1.10
; 1352 :     if (m_currentDX <= D2 && m_pVisibleSurface && INREG32(&m_pDISPCRegs->ulDISPC_IRQSTATUS) & DISPC_IRQSTATUS_SYNCLOST)

  00204	e59430b0	 ldr         r3, [r4, #0xB0]
  00208	e3530002	 cmp         r3, #2
  0020c	ca00001f	 bgt         |$LN3@SetPower|
  00210	e594308c	 ldr         r3, [r4, #0x8C]
  00214	e3530000	 cmp         r3, #0
  00218	0a00001c	 beq         |$LN3@SetPower|
  0021c	e5943080	 ldr         r3, [r4, #0x80]
  00220	e2830018	 add         r0, r3, #0x18
  00224	eb000000	 bl          READ_REGISTER_ULONG
  00228	e3100901	 tst         r0, #1, 18
  0022c	0a000017	 beq         |$LN3@SetPower|

; 1353 :     {
; 1354 :         DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::SYNCLOST BUG IRQ: %x\r\n", INREG32(&m_pDISPCRegs->ulDISPC_IRQSTATUS)));
; 1355 : 
; 1356 :         // Get hardware info
; 1357 :         OMAP2420_DISPLAY_MODE_INFO info;
; 1358 :         DisplayPddGetModeInfo(m_hDisplay, 0, &info);

  00230	e5940088	 ldr         r0, [r4, #0x88]
  00234	e28d2014	 add         r2, sp, #0x14
  00238	e3a01000	 mov         r1, #0
  0023c	eb000000	 bl          DisplayPddGetModeInfo

; 1359 : 
; 1360 :         //Need to reset DSS fully to clear the interrupt
; 1361 :         SETREG32(&m_pDSSRegs->ulDSS_SYSCONFIG, DSS_SYSCONFIG_SOFTRESET);

  00240	e594307c	 ldr         r3, [r4, #0x7C]
  00244	e2830010	 add         r0, r3, #0x10
  00248	eb000000	 bl          READ_REGISTER_ULONG
  0024c	e594307c	 ldr         r3, [r4, #0x7C]
  00250	e3801002	 orr         r1, r0, #2
  00254	e2830010	 add         r0, r3, #0x10
  00258	eb000000	 bl          WRITE_REGISTER_ULONG

; 1362 :         while (!(INREG32(&m_pDSSRegs->ulDSS_SYSSTATUS) & DSS_SYSSTATUS_RESETDONE)) Sleep(0);

  0025c	ea000001	 b           |$LN17@SetPower|
  00260		 |$LL2@SetPower|
  00260	e3a00000	 mov         r0, #0
  00264	eb000000	 bl          Sleep
  00268		 |$LN17@SetPower|
  00268	e594307c	 ldr         r3, [r4, #0x7C]
  0026c	e2830014	 add         r0, r3, #0x14
  00270	eb000000	 bl          READ_REGISTER_ULONG
  00274	e3100001	 tst         r0, #1
  00278	0afffff8	 beq         |$LL2@SetPower|

; 1363 : 
; 1364 :         //----------------------------------------------------------------------
; 1365 :         //  Configure OMAP2420 DISP controller
; 1366 :         //----------------------------------------------------------------------
; 1367 : 
; 1368 :         // initialize the display registers
; 1369 :         InitController(&info);

  0027c	e28d1014	 add         r1, sp, #0x14
  00280	e1a00004	 mov         r0, r4
  00284	eb000000	 bl          |?InitController@OMAP2420GPE@@AAAXPAUOMAP2420_DISPLAY_MODE_INFO@@@Z|

; 1370 : 
; 1371 :         // update the video addresses
; 1372 :         SetControllerAddresses();

  00288	e1a00004	 mov         r0, r4
  0028c	eb000000	 bl          |?SetControllerAddresses@OMAP2420GPE@@AAAXXZ|
  00290		 |$LN3@SetPower|

; 1373 :     }
; 1374 : 
; 1375 :     LeaveCriticalSection(&m_powerCS);

  00290	e28400d4	 add         r0, r4, #0xD4
  00294	eb000000	 bl          LeaveCriticalSection

; 1376 : //    DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::SetPower State - %d\r\n",dx));
; 1377 :     return bRetVal;
; 1378 : }

  00298	e1a00006	 mov         r0, r6
  0029c	e28dd070	 add         sp, sp, #0x70
  002a0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  002a4	e12fff1e	 bx          lr
  002a8		 |$LN21@SetPower|
  002a8		 |$LN22@SetPower|
  002a8	0022040c	 DCD         0x22040c
  002ac		 |$LN23@SetPower|
  002ac	0022041c	 DCD         0x22041c
  002b0		 |$M43440|

			 ENDP  ; |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|, OMAP2420GPE::SetPower

	IMPORT	|?DrvEscape@GPE@@UAAKPAU_SURFOBJ@@KKPAXK1@Z| ; GPE::DrvEscape
	IMPORT	|__C_specific_handler|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43554| DCD	|$LN137@DrvEscape|
	DCD	0xc0010704

  00000			 AREA	 |.pdata|, PDATA
|$T43556| DCD	|$LN102@DrvEscape|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43558| DCD	|$LN95@DrvEscape|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43560| DCD	|$LN88@DrvEscape|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43562| DCD	|$LN81@DrvEscape|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43564| DCD	|$LN67@DrvEscape|
	DCD	0x40000502

  00000			 AREA	 |.pdata|, PDATA
|$T43566| DCD	|$LN74@DrvEscape|
	DCD	0x40000802

  00000			 AREA	 |.xdata|, DATA
|$T43552| DCD	0x6
	DCD	|$LN106@DrvEscape|
	DCD	|$LN107@DrvEscape|
	DCD	|$LN102@DrvEscape|
	DCD	|$LN103@DrvEscape|
	DCD	|$LN99@DrvEscape|
	DCD	|$LN100@DrvEscape|
	DCD	|$LN95@DrvEscape|
	DCD	|$LN96@DrvEscape|
	DCD	|$LN92@DrvEscape|
	DCD	|$LN93@DrvEscape|
	DCD	|$LN88@DrvEscape|
	DCD	|$LN89@DrvEscape|
	DCD	|$LN85@DrvEscape|
	DCD	|$LN86@DrvEscape|
	DCD	|$LN81@DrvEscape|
	DCD	|$LN82@DrvEscape|
	DCD	|$LN71@DrvEscape|
	DCD	|$LN72@DrvEscape|
	DCD	|$LN67@DrvEscape|
	DCD	|$LN68@DrvEscape|
	DCD	|$LN78@DrvEscape|
	DCD	|$LN79@DrvEscape|
	DCD	|$LN74@DrvEscape|
	DCD	|$LN75@DrvEscape|
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T43552|

  00008		 |?DrvEscape@OMAP2420GPE@@UAAKPAU_SURFOBJ@@KKPAXK1@Z| PROC ; OMAP2420GPE::DrvEscape

; 1596 : {

  00008		 |$LN137@DrvEscape|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014	e24dd014	 sub         sp, sp, #0x14
  00018		 |$LN135@DrvEscape|
  00018	e1a06003	 mov         r6, r3
  0001c	e1a05002	 mov         r5, r2
  00020	e1a07001	 mov         r7, r1
  00024	e1a04000	 mov         r4, r0

; 1597 : 
; 1598 :     ULONG rc = 0;
; 1599 :     VIDEO_POWER_MANAGEMENT *pvpm;
; 1600 : //    DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::DrvEscape: %08X\r\n", code));
; 1601 : 
; 1602 :     switch (code) {

  00028	e3a03832	 mov         r3, #0x32, 16
  0002c	e383ea01	 orr         lr, r3, #1, 20
  00030	e155000e	 cmp         r5, lr
  00034	e3a00000	 mov         r0, #0
  00038	8a0000ac	 bhi         |$LN65@DrvEscape|
  0003c	0a000096	 beq         |$LN21@DrvEscape|
  00040	e3550008	 cmp         r5, #8
  00044	0a000075	 beq         |$LN58@DrvEscape|
  00048	e3a03b06	 mov         r3, #6, 22
  0004c	e383e003	 orr         lr, r3, #3
  00050	e155000e	 cmp         r5, lr
  00054	0a000034	 beq         |$LN49@DrvEscape|
  00058	e3a03b06	 mov         r3, #6, 22
  0005c	e383e004	 orr         lr, r3, #4
  00060	e155000e	 cmp         r5, lr
  00064	0a00000b	 beq         |$LN32@DrvEscape|
  00068	e3550802	 cmp         r5, #2, 16
  0006c	1a0000a8	 bne         |$LN1@DrvEscape|

; 1623 :         }
; 1624 :         break;
; 1625 : 
; 1626 :     case GETGXINFO:
; 1627 :         rc = GetGameXInfo(code, inSize, pIn, outSize, pOut);

  00070	e59b2008	 ldr         r2, [r11, #8]
  00074	e59b1004	 ldr         r1, [r11, #4]
  00078	e59b3000	 ldr         r3, [r11]
  0007c	e58d2004	 str         r2, [sp, #4]
  00080	e58d1000	 str         r1, [sp]
  00084	e1a02006	 mov         r2, r6
  00088	e3a01802	 mov         r1, #2, 16
  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          |?GetGameXInfo@OMAP2420GPE@@QAAHKKPAXK0@Z|

; 1628 :         break;

  00094	ea0000df	 b           |$cleanUp$42357|
  00098		 |$LN32@DrvEscape|

; 1685 :         }
; 1686 :         break;
; 1687 : 
; 1688 :     case GETPOWERMANAGEMENT:
; 1689 :         DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1690 :             L"GETPOWERMANAGEMENT\r\n"
; 1691 :         ));
; 1692 :         if (pOut == NULL || outSize < sizeof(VIDEO_POWER_MANAGEMENT)) {

  00098	e59b2008	 ldr         r2, [r11, #8]
  0009c	e3520000	 cmp         r2, #0
  000a0	0a0000d9	 beq         |$LN4@DrvEscape|
  000a4	e59b3004	 ldr         r3, [r11, #4]
  000a8	e353000c	 cmp         r3, #0xC
  000ac	3a0000d6	 bcc         |$LN4@DrvEscape|
  000b0		 |$LN78@DrvEscape|

; 1693 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1694 :             rc = ESC_FAILED;
; 1695 :             goto cleanUp;
; 1696 :         }
; 1697 :         __try {
; 1698 :             pvpm = (VIDEO_POWER_MANAGEMENT*)pOut;
; 1699 :             pvpm->Length = sizeof(VIDEO_POWER_MANAGEMENT);

  000b0	e3a0300c	 mov         r3, #0xC
  000b4	e5823000	 str         r3, [r2]

; 1700 :             pvpm->DPMSVersion = 0;

  000b8	e3a03000	 mov         r3, #0
  000bc	e5823004	 str         r3, [r2, #4]

; 1701 :             switch (m_externalDX) {

  000c0	e59430b4	 ldr         r3, [r4, #0xB4]
  000c4	e3530000	 cmp         r3, #0
  000c8	4a000011	 bmi         |$LN129@DrvEscape|
  000cc	e3530001	 cmp         r3, #1
  000d0	da00000c	 ble         |$LN25@DrvEscape|
  000d4	e3530002	 cmp         r3, #2
  000d8	0a000008	 beq         |$LN24@DrvEscape|
  000dc	e3530003	 cmp         r3, #3
  000e0	0a000004	 beq         |$LN23@DrvEscape|
  000e4	e3530004	 cmp         r3, #4
  000e8	1a000009	 bne         |$LN129@DrvEscape|

; 1712 :             case D4:                
; 1713 :                 pvpm->PowerState = VideoPowerOff;

  000ec	e3a03004	 mov         r3, #4
  000f0		 |$LN131@DrvEscape|
  000f0	e5823008	 str         r3, [r2, #8]

; 1714 :                 break;

  000f4	ea000006	 b           |$LN129@DrvEscape|
  000f8		 |$LN23@DrvEscape|

; 1709 :             case D3:
; 1710 :                 pvpm->PowerState = VideoPowerSuspend;

  000f8	e3a03003	 mov         r3, #3

; 1711 :                 break;

  000fc	eafffffb	 b           |$LN131@DrvEscape|
  00100		 |$LN24@DrvEscape|

; 1705 :                 break;
; 1706 :             case D2:
; 1707 :                 pvpm->PowerState = VideoPowerStandBy;

  00100	e3a03002	 mov         r3, #2

; 1708 :                 break;

  00104	eafffff9	 b           |$LN131@DrvEscape|
  00108		 |$LN25@DrvEscape|

; 1702 :             case D0:
; 1703 :             case D1:
; 1704 :                 pvpm->PowerState = VideoPowerOn;

  00108	e3a00001	 mov         r0, #1
  0010c	e5820008	 str         r0, [r2, #8]
  00110	ea000000	 b           |$LN26@DrvEscape|
  00114		 |$LN129@DrvEscape|

; 1714 :                 break;

  00114	e3a00001	 mov         r0, #1
  00118		 |$LN26@DrvEscape|

; 1715 :             }
; 1716 :             rc = ESC_SUCCESS;

  00118	e50b0024	 str         r0, [r11, #-0x24]
  0011c		 |$LN79@DrvEscape|
  0011c	ea0000bd	 b           |$cleanUp$42357|
  00120		 |$LN75@DrvEscape|

; 1718 :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DDI_OMAP2420GPE::DrvEsc: "
; 1719 :                 L"Exception in DrvEscape/GETPOWERMANAGEMENT\r\n"
; 1720 :             ));
; 1721 :             rc = ESC_FAILED;

  00120	e3e00000	 mvn         r0, #0
  00124	e50b0024	 str         r0, [r11, #-0x24]
  00128	ea0000ba	 b           |$cleanUp$42357|
  0012c		 |$LN49@DrvEscape|

; 1629 : 
; 1630 :     case SETPOWERMANAGEMENT:
; 1631 :         DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1632 :             L"SETPOWERMANAGEMENT\r\n"
; 1633 :         ));
; 1634 :         if (pIn == NULL || inSize < sizeof(VIDEO_POWER_MANAGEMENT)) {

  0012c	e59b2000	 ldr         r2, [r11]
  00130	e3520000	 cmp         r2, #0
  00134	0a0000b4	 beq         |$LN4@DrvEscape|
  00138	e356000c	 cmp         r6, #0xC
  0013c	3a0000b2	 bcc         |$LN4@DrvEscape|
  00140		 |$LN71@DrvEscape|

; 1635 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1636 :             rc = ESC_FAILED;
; 1637 :             goto cleanUp;
; 1638 :         }
; 1639 :         __try {
; 1640 :             pvpm = (VIDEO_POWER_MANAGEMENT *)pIn;
; 1641 :             if (pvpm->Length < sizeof(VIDEO_POWER_MANAGEMENT)) {

  00140	e5923000	 ldr         r3, [r2]
  00144	e353000c	 cmp         r3, #0xC
  00148	2a000004	 bcs         |$LN44@DrvEscape|

; 1642 :                 SetLastError(ERROR_INVALID_PARAMETER);

  0014c	e3a00057	 mov         r0, #0x57
  00150	eb000000	 bl          SetLastError

; 1643 :                 rc = ESC_FAILED;

  00154	e3e00000	 mvn         r0, #0
  00158	e50b0024	 str         r0, [r11, #-0x24]

; 1644 :                 goto cleanUp;

  0015c	ea0000ad	 b           |$cleanUp$42357|
  00160		 |$LN44@DrvEscape|

; 1645 :             }
; 1646 :             switch (pvpm->PowerState) {

  00160	e5923008	 ldr         r3, [r2, #8]
  00164	e3530001	 cmp         r3, #1
  00168	0a00001a	 beq         |$LN40@DrvEscape|
  0016c	e3530002	 cmp         r3, #2
  00170	0a000011	 beq         |$LN38@DrvEscape|
  00174	e3530003	 cmp         r3, #3
  00178	0a000008	 beq         |$LN36@DrvEscape|
  0017c	e3530004	 cmp         r3, #4
  00180	1a000022	 bne         |$LN72@DrvEscape|

; 1671 :             case VideoPowerOff:
; 1672 :                 m_externalDX = D4;

  00184	e3a03004	 mov         r3, #4
  00188	e58430b4	 str         r3, [r4, #0xB4]

; 1673 :                 if (m_currentDX < D4 && SetPower(D4)) SetEvent(m_hPowerEvent);

  0018c	e59430b0	 ldr         r3, [r4, #0xB0]
  00190	e3530004	 cmp         r3, #4
  00194	aa00001b	 bge         |$LN109@DrvEscape|
  00198	e3a01004	 mov         r1, #4

; 1674 :                 DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1675 :                     L"SETPOWERMANAGEMENT: display off\r\n"
; 1676 :                 ));
; 1677 :                 rc = ESC_SUCCESS;
; 1678 :                 break;

  0019c	ea000013	 b           |$LN133@DrvEscape|
  001a0		 |$LN36@DrvEscape|

; 1663 :             case VideoPowerSuspend:
; 1664 :                 m_externalDX = D3;

  001a0	e3a03003	 mov         r3, #3
  001a4	e58430b4	 str         r3, [r4, #0xB4]

; 1665 :                 if (m_currentDX < D3 && SetPower(D3)) SetEvent(m_hPowerEvent);

  001a8	e59430b0	 ldr         r3, [r4, #0xB0]
  001ac	e3530003	 cmp         r3, #3
  001b0	aa000014	 bge         |$LN109@DrvEscape|
  001b4	e3a01003	 mov         r1, #3

; 1666 :                 DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1667 :                     L"SETPOWERMANAGEMENT: Display StandBy\r\n"
; 1668 :                 ));
; 1669 :                 rc = ESC_SUCCESS;
; 1670 :                 break;

  001b8	ea00000c	 b           |$LN133@DrvEscape|
  001bc		 |$LN38@DrvEscape|

; 1654 :                 break;
; 1655 :             case VideoPowerStandBy:
; 1656 :                 m_externalDX = D2;

  001bc	e3a03002	 mov         r3, #2
  001c0	e58430b4	 str         r3, [r4, #0xB4]

; 1657 :                 if (m_currentDX < D2 && SetPower(D2)) SetEvent(m_hPowerEvent);

  001c4	e59430b0	 ldr         r3, [r4, #0xB0]
  001c8	e3530002	 cmp         r3, #2
  001cc	aa00000d	 bge         |$LN109@DrvEscape|
  001d0	e3a01002	 mov         r1, #2

; 1658 :                 DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1659 :                     L"SETPOWERMANAGEMENT: Display StandBy\r\n"
; 1660 :                 ));
; 1661 :                 rc = ESC_SUCCESS;
; 1662 :                 break;

  001d4	ea000005	 b           |$LN133@DrvEscape|
  001d8		 |$LN40@DrvEscape|

; 1647 :             case VideoPowerOn:
; 1648 :                 m_externalDX = D0;

  001d8	e3a03000	 mov         r3, #0
  001dc	e58430b4	 str         r3, [r4, #0xB4]

; 1649 :                 if (m_currentDX < D0 && SetPower(D0)) SetEvent(m_hPowerEvent);

  001e0	e59430b0	 ldr         r3, [r4, #0xB0]
  001e4	e3530000	 cmp         r3, #0
  001e8	aa000006	 bge         |$LN109@DrvEscape|
  001ec	e3a01000	 mov         r1, #0
  001f0		 |$LN133@DrvEscape|
  001f0	e1a00004	 mov         r0, r4
  001f4	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|
  001f8	e3500000	 cmp         r0, #0
  001fc	13a01003	 movne       r1, #3
  00200	159400c8	 ldrne       r0, [r4, #0xC8]
  00204	1b000000	 blne        EventModify
  00208		 |$LN109@DrvEscape|

; 1650 :                 DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1651 :                     L"SETPOWERMANAGEMENT: Display PowerOn\r\n"
; 1652 :                 ));
; 1653 :                 rc = ESC_SUCCESS;

  00208	e3a00001	 mov         r0, #1
  0020c	e50b0024	 str         r0, [r11, #-0x24]
  00210		 |$LN72@DrvEscape|

; 1679 :             }

  00210	ea000080	 b           |$cleanUp$42357|
  00214		 |$LN68@DrvEscape|

; 1681 :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DDI_OMAP2420GPE::DrvEsc: "
; 1682 :                 L"Exception in DrvEscape/SETPOWERMANAGEMENT\r\n"
; 1683 :             ));
; 1684 :             rc = ESC_FAILED;

  00214	e3e00000	 mvn         r0, #0
  00218	e50b0024	 str         r0, [r11, #-0x24]
  0021c	ea00007d	 b           |$cleanUp$42357|
  00220		 |$LN58@DrvEscape|

; 1603 :     case QUERYESCSUPPORT:
; 1604 :         if (pIn == NULL || inSize < sizeof(DWORD)) {

  00220	e59b3000	 ldr         r3, [r11]
  00224	e3530000	 cmp         r3, #0
  00228	0a000077	 beq         |$LN4@DrvEscape|
  0022c	e3560004	 cmp         r6, #4
  00230	3a000075	 bcc         |$LN4@DrvEscape|

; 1608 :         }
; 1609 :         switch (*((DWORD*)pIn)) {

  00234	e5932000	 ldr         r2, [r3]
  00238	e3a03b06	 mov         r3, #6, 22
  0023c	e3833003	 orr         r3, r3, #3
  00240	e1520003	 cmp         r2, r3
  00244	3a000012	 bcc         |$LN51@DrvEscape|
  00248	e3a03b06	 mov         r3, #6, 22
  0024c	e3833004	 orr         r3, r3, #4
  00250	e1520003	 cmp         r2, r3
  00254	9a00000c	 bls         |$LN52@DrvEscape|
  00258	e3520802	 cmp         r2, #2, 16
  0025c	0a00000a	 beq         |$LN52@DrvEscape|
  00260	e152000e	 cmp         r2, lr
  00264	0a000008	 beq         |$LN52@DrvEscape|
  00268	e59f3234	 ldr         r3, [pc, #0x234]
  0026c	e1520003	 cmp         r2, r3
  00270	0a000005	 beq         |$LN52@DrvEscape|
  00274	e59f3224	 ldr         r3, [pc, #0x224]
  00278	e1520003	 cmp         r2, r3
  0027c	0a000002	 beq         |$LN52@DrvEscape|
  00280	e59f3214	 ldr         r3, [pc, #0x214]
  00284	e1520003	 cmp         r2, r3
  00288	1a000001	 bne         |$LN51@DrvEscape|
  0028c		 |$LN52@DrvEscape|

; 1610 :         case GETPOWERMANAGEMENT:
; 1611 :         case SETPOWERMANAGEMENT:
; 1612 :         case IOCTL_POWER_CAPABILITIES:
; 1613 :         case IOCTL_POWER_QUERY:
; 1614 :         case IOCTL_POWER_SET:
; 1615 :         case IOCTL_POWER_GET:
; 1616 :         case GETGXINFO:
; 1617 :             rc = ESC_SUCCESS;

  0028c	e3a00001	 mov         r0, #1

; 1618 :             break;

  00290	ea000060	 b           |$cleanUp$42357|
  00294		 |$LN51@DrvEscape|

; 1619 :         case DRVESC_GETSCREENROTATION:
; 1620 :         case DRVESC_SETSCREENROTATION:
; 1621 :         default:
; 1622 :             rc = ESC_NOTIMPLEMENTED;

  00294	e3a00000	 mov         r0, #0

; 1605 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1606 :             rc = ESC_FAILED;
; 1607 :             goto cleanUp;

  00298	ea00005e	 b           |$cleanUp$42357|
  0029c		 |$LN21@DrvEscape|

; 1722 :         }
; 1723 :         break;
; 1724 : 
; 1725 :     case IOCTL_POWER_CAPABILITIES:
; 1726 :         DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1727 :             L"IOCTL_POWER_CAPABILITIES\r\n"
; 1728 :         ));
; 1729 :         if (pOut == NULL || outSize < sizeof(POWER_CAPABILITIES)) {

  0029c	e59b4008	 ldr         r4, [r11, #8]
  002a0	e3540000	 cmp         r4, #0
  002a4	0a000058	 beq         |$LN4@DrvEscape|
  002a8	e59b3004	 ldr         r3, [r11, #4]
  002ac	e3530030	 cmp         r3, #0x30
  002b0	3a000055	 bcc         |$LN4@DrvEscape|
  002b4		 |$LN85@DrvEscape|

; 1730 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1731 :             rc = ESC_FAILED;
; 1732 :             goto cleanUp;
; 1733 :         }
; 1734 :         __try {
; 1735 :             POWER_CAPABILITIES *pPowerCaps = (POWER_CAPABILITIES*)pOut;
; 1736 :             memset(pPowerCaps, 0, sizeof(POWER_CAPABILITIES));

  002b4	e3a02030	 mov         r2, #0x30
  002b8	e3a01000	 mov         r1, #0
  002bc	e1a00004	 mov         r0, r4
  002c0	eb000000	 bl          memset

; 1737 :             pPowerCaps->DeviceDx |= DX_MASK(D0) | DX_MASK(D2);

  002c4	e5d43000	 ldrb        r3, [r4]
  002c8	e3833005	 orr         r3, r3, #5

; 1738 :             pPowerCaps->DeviceDx |= DX_MASK(D3) | DX_MASK(D4);

  002cc	e3832018	 orr         r2, r3, #0x18
  002d0	e5c43000	 strb        r3, [r4]
  002d4	e5c42000	 strb        r2, [r4]

; 1739 :             rc = ESC_SUCCESS;

  002d8	e3a00001	 mov         r0, #1
  002dc	e50b0024	 str         r0, [r11, #-0x24]
  002e0		 |$LN86@DrvEscape|
  002e0	ea00004c	 b           |$cleanUp$42357|
  002e4		 |$LN82@DrvEscape|

; 1741 :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DDI_OMAP2420GPE::DrvEsc: "
; 1742 :                 L"Exception in DrvEscape/IOCTL_POWER_CAPABILITIES\r\n"
; 1743 :             ));
; 1744 :             rc = ESC_FAILED;

  002e4	e3e00000	 mvn         r0, #0
  002e8	e50b0024	 str         r0, [r11, #-0x24]
  002ec	ea000049	 b           |$cleanUp$42357|
  002f0		 |$LN65@DrvEscape|

; 1597 : 
; 1598 :     ULONG rc = 0;
; 1599 :     VIDEO_POWER_MANAGEMENT *pvpm;
; 1600 : //    DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::DrvEscape: %08X\r\n", code));
; 1601 : 
; 1602 :     switch (code) {

  002f0	e59f31ac	 ldr         r3, [pc, #0x1AC]
  002f4	e1550003	 cmp         r5, r3
  002f8	0a000033	 beq         |$LN6@DrvEscape|
  002fc	e59f319c	 ldr         r3, [pc, #0x19C]
  00300	e1550003	 cmp         r5, r3
  00304	0a00001d	 beq         |$LN11@DrvEscape|
  00308	e59f318c	 ldr         r3, [pc, #0x18C]
  0030c	e1550003	 cmp         r5, r3
  00310	0a00000b	 beq         |$LN16@DrvEscape|
  00314		 |$LN1@DrvEscape|

; 1808 :         }
; 1809 :         break;
; 1810 : 
; 1811 : #if defined(TVOUT)
; 1812 :         // get the TV-Out mode
; 1813 :     case DRVESC_GET_TVOUT:
; 1814 :         DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::DrvEscape DRVESC_GET_TVOUT %d\r\n", m_dwTVOut));
; 1815 :         if (pOut == NULL || outSize < sizeof(DWORD))
; 1816 :         {
; 1817 :             DEBUGMSG(GPE_ZONE_ERROR, (L"OMAP2420GPE::DrvEscape GET_TVOUT FAILED: invalid parameter!!!\r\n"));
; 1818 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1819 :             rc = ESC_FAILED;
; 1820 :         }
; 1821 :         else
; 1822 :         {
; 1823 :             *(PDWORD)pOut = m_dwTVOut;
; 1824 :             rc = ESC_SUCCESS;
; 1825 :         }
; 1826 :         break;
; 1827 : 
; 1828 :     // set the TV-Out mode
; 1829 :     case DRVESC_SET_TVOUT:
; 1830 :         DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::DrvEscape DRVESC_SET_TVOUT: %d\r\n", *(PDWORD)pIn));
; 1831 :         if (pIn == NULL || inSize < sizeof(DWORD))
; 1832 :         {
; 1833 :             DEBUGMSG(GPE_ZONE_ERROR, (L"OMAP2420GPE::DrvEscape SET_TVOUT FAILED: invalid parameter!!!\r\n"));
; 1834 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1835 :             rc = ESC_FAILED;
; 1836 :         }
; 1837 :         else
; 1838 :         {
; 1839 :             DWORD dwTVOut = *(PDWORD)pIn;
; 1840 :             if (dwTVOut != TVOUT_NONE && dwTVOut != TVOUT_NTSC && dwTVOut != TVOUT_PAL)
; 1841 :             {
; 1842 :                 DEBUGMSG(GPE_ZONE_ERROR, (L"OMAP2420GPE::DrvEscape SET_TVOUT FAILED: invalid mode!!!\r\n"));
; 1843 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1844 :                 rc = ESC_FAILED;
; 1845 :             }
; 1846 :             else
; 1847 :             {
; 1848 :                 SetTVOut(dwTVOut);
; 1849 :                 rc = ESC_SUCCESS;
; 1850 :             }
; 1851 :         }
; 1852 :     break;
; 1853 : #endif // defined(TVOUT)
; 1854 : 
; 1855 :     default:
; 1856 :         rc = GPE::DrvEscape(pso, code, inSize, pIn, outSize, pOut);

  00314	e59b3008	 ldr         r3, [r11, #8]
  00318	e59b2004	 ldr         r2, [r11, #4]
  0031c	e59b1000	 ldr         r1, [r11]
  00320	e58d3008	 str         r3, [sp, #8]
  00324	e58d2004	 str         r2, [sp, #4]
  00328	e58d1000	 str         r1, [sp]
  0032c	e1a03006	 mov         r3, r6
  00330	e1a02005	 mov         r2, r5
  00334	e1a01007	 mov         r1, r7
  00338	e1a00004	 mov         r0, r4
  0033c	eb000000	 bl          |?DrvEscape@GPE@@UAAKPAU_SURFOBJ@@KKPAXK1@Z|
  00340	ea000034	 b           |$cleanUp$42357|
  00344		 |$LN16@DrvEscape|

; 1745 :         }
; 1746 :         break;
; 1747 : 
; 1748 :     case IOCTL_POWER_QUERY:
; 1749 :         DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1750 :             L"IOCTL_POWER_QUERY\r\n"
; 1751 :         ));
; 1752 :         if (pOut == NULL || outSize < sizeof(CEDEVICE_POWER_STATE)) {

  00344	e59b2008	 ldr         r2, [r11, #8]
  00348	e3520000	 cmp         r2, #0
  0034c	0a00002e	 beq         |$LN4@DrvEscape|
  00350	e59b3004	 ldr         r3, [r11, #4]
  00354	e3530004	 cmp         r3, #4
  00358	3a00002b	 bcc         |$LN4@DrvEscape|
  0035c		 |$LN92@DrvEscape|

; 1753 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1754 :             rc = ESC_FAILED;
; 1755 :             goto cleanUp;
; 1756 :         }
; 1757 :         __try {
; 1758 :             CEDEVICE_POWER_STATE dx = *(CEDEVICE_POWER_STATE*)pOut;

  0035c	e5923000	 ldr         r3, [r2]

; 1759 :             rc = VALID_DX(dx) ? ESC_SUCCESS : ESC_FAILED;

  00360	e3530004	 cmp         r3, #4
  00364	93a00001	 movls       r0, #1
  00368	83e00000	 mvnhi       r0, #0
  0036c	e50b0024	 str         r0, [r11, #-0x24]
  00370		 |$LN93@DrvEscape|
  00370	ea000028	 b           |$cleanUp$42357|
  00374		 |$LN89@DrvEscape|

; 1761 :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DDI_OMAP2420GPE::DrvEsc: "
; 1762 :                 L"Exception in DrvEscape/IOCTL_POWER_QUERY\r\n"
; 1763 :             ));
; 1764 :             rc = ESC_FAILED;

  00374	e3e00000	 mvn         r0, #0
  00378	e50b0024	 str         r0, [r11, #-0x24]
  0037c	ea000025	 b           |$cleanUp$42357|
  00380		 |$LN11@DrvEscape|

; 1765 :         }
; 1766 :         break;
; 1767 : 
; 1768 :     case IOCTL_POWER_SET:
; 1769 :         DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1770 :             L"IOCTL_POWER_SET %d\r\n", *(CEDEVICE_POWER_STATE*)pOut
; 1771 :         ));
; 1772 :         if (pOut == NULL || outSize < sizeof(CEDEVICE_POWER_STATE)) {

  00380	e59b5008	 ldr         r5, [r11, #8]
  00384	e3550000	 cmp         r5, #0
  00388	0a00001f	 beq         |$LN4@DrvEscape|
  0038c	e59b3004	 ldr         r3, [r11, #4]
  00390	e3530004	 cmp         r3, #4
  00394	3a00001c	 bcc         |$LN4@DrvEscape|
  00398		 |$LN99@DrvEscape|

; 1773 :             SetLastError(ERROR_INVALID_PARAMETER);
; 1774 :             rc = ESC_FAILED;
; 1775 :             goto cleanUp;
; 1776 :         }
; 1777 :         __try {
; 1778 :             CEDEVICE_POWER_STATE dx = *(CEDEVICE_POWER_STATE*)pOut;

  00398	e5953000	 ldr         r3, [r5]

; 1779 :             m_externalDX = dx;
; 1780 :             SetPower(dx);

  0039c	e1a00004	 mov         r0, r4
  003a0	e1a01003	 mov         r1, r3
  003a4	e58430b4	 str         r3, [r4, #0xB4]
  003a8	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|

; 1781 :             *(CEDEVICE_POWER_STATE*)pOut = m_externalDX;

  003ac	e59430b4	 ldr         r3, [r4, #0xB4]
  003b0	e5853000	 str         r3, [r5]

; 1782 :             rc = ESC_SUCCESS;

  003b4	e3a00001	 mov         r0, #1
  003b8	e50b0024	 str         r0, [r11, #-0x24]
  003bc		 |$LN100@DrvEscape|
  003bc	ea000015	 b           |$cleanUp$42357|
  003c0		 |$LN96@DrvEscape|

; 1784 :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DDI_OMAP2420GPE::DrvEsc: "
; 1785 :                 L"Exception in DrvEscape/IOCTL_POWER_SET\r\n"
; 1786 :             ));
; 1787 :             rc = ESC_FAILED;

  003c0	e3e00000	 mvn         r0, #0
  003c4	e50b0024	 str         r0, [r11, #-0x24]
  003c8	ea000012	 b           |$cleanUp$42357|
  003cc		 |$LN6@DrvEscape|

; 1788 :         }
; 1789 :         break;
; 1790 : 
; 1791 :     case IOCTL_POWER_GET:
; 1792 :         DEBUGMSG(GPE_ZONE_PM, (L"DDI_OMAP2420GPE::DrvEsc: "
; 1793 :             L"IOCTL_POWER_GET\r\n"
; 1794 :         ));
; 1795 :         if (pOut == NULL || outSize < sizeof(CEDEVICE_POWER_STATE)) {

  003cc	e59b2008	 ldr         r2, [r11, #8]
  003d0	e3520000	 cmp         r2, #0
  003d4	0a00000c	 beq         |$LN4@DrvEscape|
  003d8	e59b3004	 ldr         r3, [r11, #4]
  003dc	e3530004	 cmp         r3, #4
  003e0	3a000009	 bcc         |$LN4@DrvEscape|
  003e4		 |$LN106@DrvEscape|

; 1798 :             goto cleanUp;
; 1799 :         }
; 1800 :         __try {
; 1801 :             *(CEDEVICE_POWER_STATE*)pOut = m_externalDX;

  003e4	e59430b4	 ldr         r3, [r4, #0xB4]
  003e8	e5823000	 str         r3, [r2]

; 1802 :             rc = ESC_SUCCESS;

  003ec	e3a00001	 mov         r0, #1
  003f0	e50b0024	 str         r0, [r11, #-0x24]
  003f4		 |$LN107@DrvEscape|
  003f4	ea000007	 b           |$cleanUp$42357|
  003f8		 |$LN103@DrvEscape|

; 1804 :             DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DDI_OMAP2420GPE::DrvEsc: "
; 1805 :                 L"Exception in DrvEscape/IOCTL_POWER_GET\r\n"
; 1806 :             ));
; 1807 :             rc = ESC_FAILED;

  003f8	e3e00000	 mvn         r0, #0
  003fc	e50b0024	 str         r0, [r11, #-0x24]
  00400	ea000004	 b           |$cleanUp$42357|
  00404		 |$LN130@DrvEscape|

; 1857 :     }
; 1858 : 
; 1859 : cleanUp:
; 1860 : //    DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::DrvEscape: %08X\r\n", rc));
; 1861 :     return rc;

  00404	e51b0020	 ldr         r0, [r11, #-0x20]
  00408	ea000002	 b           |$cleanUp$42357|
  0040c		 |$LN4@DrvEscape|

; 1796 :             SetLastError(ERROR_INVALID_PARAMETER);

  0040c	e3a00057	 mov         r0, #0x57
  00410	eb000000	 bl          SetLastError

; 1797 :             rc = ESC_FAILED;

  00414	e3e00000	 mvn         r0, #0
  00418		 |$cleanUp$42357|

; 1862 : }

  00418	e24bd01c	 sub         sp, r11, #0x1C
  0041c	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  00420	e12fff1e	 bx          lr

			 ENDP  ; |?DrvEscape@OMAP2420GPE@@UAAKPAU_SURFOBJ@@KKPAXK1@Z|, OMAP2420GPE::DrvEscape

  00424		 |$LN102@DrvEscape|
  00424		 |$LN136@DrvEscape|

; 1803 :         } __except(EXCEPTION_EXECUTE_HANDLER) {

  00424	e52de004	 str         lr, [sp, #-4]!
  00428	e24dd00c	 sub         sp, sp, #0xC
  0042c		 |$LN105@DrvEscape|
  0042c		 |$LN144@DrvEscape|
  0042c	e3a00001	 mov         r0, #1
  00430		 |$LN104@DrvEscape|
  00430	e28dd00c	 add         sp, sp, #0xC
  00434	e49df004	 ldr         pc, [sp], #4
  00438		 |$LN145@DrvEscape|
  00438		 |$LN95@DrvEscape|
  00438		 |$LN138@DrvEscape|

; 1783 :         } __except(EXCEPTION_EXECUTE_HANDLER) {

  00438	e52de004	 str         lr, [sp, #-4]!
  0043c	e24dd00c	 sub         sp, sp, #0xC
  00440		 |$LN98@DrvEscape|
  00440		 |$LN146@DrvEscape|
  00440	e3a00001	 mov         r0, #1
  00444		 |$LN97@DrvEscape|
  00444	e28dd00c	 add         sp, sp, #0xC
  00448	e49df004	 ldr         pc, [sp], #4
  0044c		 |$LN147@DrvEscape|
  0044c		 |$LN88@DrvEscape|
  0044c		 |$LN139@DrvEscape|

; 1760 :         } __except(EXCEPTION_EXECUTE_HANDLER) {

  0044c	e52de004	 str         lr, [sp, #-4]!
  00450	e24dd00c	 sub         sp, sp, #0xC
  00454		 |$LN91@DrvEscape|
  00454		 |$LN148@DrvEscape|
  00454	e3a00001	 mov         r0, #1
  00458		 |$LN90@DrvEscape|
  00458	e28dd00c	 add         sp, sp, #0xC
  0045c	e49df004	 ldr         pc, [sp], #4
  00460		 |$LN149@DrvEscape|
  00460		 |$LN81@DrvEscape|
  00460		 |$LN140@DrvEscape|

; 1740 :         } __except(EXCEPTION_EXECUTE_HANDLER) {

  00460	e52de004	 str         lr, [sp, #-4]!
  00464	e24dd00c	 sub         sp, sp, #0xC
  00468		 |$LN84@DrvEscape|
  00468		 |$LN150@DrvEscape|
  00468	e3a00001	 mov         r0, #1
  0046c		 |$LN83@DrvEscape|
  0046c	e28dd00c	 add         sp, sp, #0xC
  00470	e49df004	 ldr         pc, [sp], #4
  00474		 |$LN151@DrvEscape|
  00474		 |$LN67@DrvEscape|
  00474		 |$LN141@DrvEscape|

; 1680 :         } __except(EXCEPTION_EXECUTE_HANDLER) {

  00474	e52de004	 str         lr, [sp, #-4]!
  00478	e24dd00c	 sub         sp, sp, #0xC
  0047c		 |$LN70@DrvEscape|
  0047c		 |$LN152@DrvEscape|
  0047c	e3a00001	 mov         r0, #1
  00480		 |$LN69@DrvEscape|
  00480	e28dd00c	 add         sp, sp, #0xC
  00484	e49df004	 ldr         pc, [sp], #4
  00488		 |$LN153@DrvEscape|
  00488		 |$LN74@DrvEscape|
  00488		 |$LN142@DrvEscape|

; 1717 :         } __except(EXCEPTION_EXECUTE_HANDLER) {

  00488	e52de004	 str         lr, [sp, #-4]!
  0048c	e24dd00c	 sub         sp, sp, #0xC
  00490		 |$LN77@DrvEscape|
  00490		 |$LN154@DrvEscape|
  00490	e3a00001	 mov         r0, #1
  00494		 |$LN76@DrvEscape|
  00494	e28dd00c	 add         sp, sp, #0xC
  00498	e49df004	 ldr         pc, [sp], #4
  0049c		 |$LN156@DrvEscape|
  0049c		 |$LN157@DrvEscape|
  0049c	0032100c	 DCD         0x32100c
  004a0		 |$LN158@DrvEscape|
  004a0	00321008	 DCD         0x321008
  004a4		 |$LN159@DrvEscape|
  004a4	00321004	 DCD         0x321004
  004a8		 |$LN155@DrvEscape|
  004a8		 |$LN143@DrvEscape|
	EXPORT	|?PowerThread@OMAP2420GPE@@AAAKXZ|	; OMAP2420GPE::PowerThread
	IMPORT	|InterlockedExchange|

  00000			 AREA	 |.pdata|, PDATA
|$T43606| DCD	|$LN17@PowerThrea|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerThread@OMAP2420GPE@@AAAKXZ| PROC ; OMAP2420GPE::PowerThread

; 1885 : {

  00000		 |$LN17@PowerThrea|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43603|
  00004	e1a04000	 mov         r4, r0
  00008		 |$LN14@PowerThrea|

; 1886 :     CEDEVICE_POWER_STATE dx = D0;
; 1887 :     DWORD delay = m_powerDelay;
; 1888 :     BOOL updateFlag;
; 1889 :     
; 1890 :     DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::PowerThread++\r\n"));
; 1891 :     while (!m_powerThreadExit) {

  00008	e3a05000	 mov         r5, #0
  0000c	ea000015	 b           |$LN13@PowerThrea|
  00010		 |$LL7@PowerThrea|

; 1892 : 
; 1893 :         // Wait for event or timeout...
; 1894 :         WaitForSingleObject(m_hPowerEvent, delay);

  00010	e59400c8	 ldr         r0, [r4, #0xC8]
  00014	e1a01006	 mov         r1, r6
  00018	eb000000	 bl          WaitForSingleObject

; 1895 :         DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::PwrThread object set++, dx = %d\r\n",dx));
; 1896 :         // Get update flag
; 1897 :         updateFlag = (BOOL)InterlockedExchange(&m_updateFlag, FALSE);

  0001c	e3a01000	 mov         r1, #0
  00020	e28400e8	 add         r0, r4, #0xE8
  00024	eb000000	 bl          InterlockedExchange
  00028	e3500000	 cmp         r0, #0

; 1898 : 
; 1899 :         // If there was update, simply wait next period
; 1900 :         if (updateFlag != 0) {
; 1901 :             dx = D0;
; 1902 :             delay = m_powerDelay;
; 1903 :             continue;

  0002c	1afffff5	 bne         |$LN14@PowerThrea|

; 1904 :         }
; 1905 : 
; 1906 :         // Depending on previous power thread state device
; 1907 :         // will be moved to D2 or D3 (there should be delay
; 1908 :         // to give LCD controller chance to finish frame).
; 1909 :         switch (dx) {

  00030	e3550000	 cmp         r5, #0
  00034	0a000007	 beq         |$LN2@PowerThrea|
  00038	e3550002	 cmp         r5, #2
  0003c	1a00000a	 bne         |$LN3@PowerThrea|

; 1917 :             break;
; 1918 :         case D2:
; 1919 :             SetPower(D3);

  00040	e3a01003	 mov         r1, #3
  00044	e1a00004	 mov         r0, r4
  00048	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|

; 1920 :             dx = D3;

  0004c	e3a05003	 mov         r5, #3

; 1921 :             delay = INFINITE;

  00050	e3e06000	 mvn         r6, #0

; 1922 :             break;

  00054	ea000004	 b           |$LN3@PowerThrea|
  00058		 |$LN2@PowerThrea|

; 1910 :         case D0:            
; 1911 :             // We want to move display driver to D2.
; 1912 :             // This can be overpower by external power
; 1913 :             // state to higher state (e.g. D4)
; 1914 :             SetPower(D2);

  00058	e3a01002	 mov         r1, #2
  0005c	e1a00004	 mov         r0, r4
  00060	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|

; 1915 :             dx = D2;
; 1916 :             delay = m_powerDelay;

  00064	e3a05002	 mov         r5, #2
  00068		 |$LN13@PowerThrea|
  00068	e5946074	 ldr         r6, [r4, #0x74]
  0006c		 |$LN3@PowerThrea|
  0006c	e59430d0	 ldr         r3, [r4, #0xD0]
  00070	e3530000	 cmp         r3, #0
  00074	0affffe5	 beq         |$LL7@PowerThrea|

; 1923 :         }            
; 1924 :     }    
; 1925 : 
; 1926 :     // All is great...
; 1927 :     return ERROR_SUCCESS;

  00078	e3a00000	 mov         r0, #0

; 1928 : }

  0007c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$M43604|

			 ENDP  ; |?PowerThread@OMAP2420GPE@@AAAKXZ|, OMAP2420GPE::PowerThread

	IMPORT	|?SetRotation@GPESurf@@QAAXHHH@Z|	; GPESurf::SetRotation
	IMPORT	|DisplayPddSetMode|
	IMPORT	|EngCreatePalette|
	IMPORT	|memcpy|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43629| DCD	|$LN25@SetMode|
	DCD	0x40007502
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetMode@OMAP2420GPE@@UAAJHPAPAUHPALETTE__@@@Z| PROC ; OMAP2420GPE::SetMode

; 515  : {

  00000		 |$LN25@SetMode|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd07c	 sub         sp, sp, #0x7C
  00008		 |$M43626|
  00008	e1a0a002	 mov         r10, r2
  0000c	e1a09001	 mov         r9, r1
  00010	e1a07000	 mov         r7, r0

; 516  :     SCODE sc = E_FAIL;
; 517  :     OMAP2420_DISPLAY_MODE_INFO info;
; 518  :     GPEMode gpeMode;
; 519  : 
; 520  :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::SetMode.(%d, 0x%08x)\r\n", modeNumber, phPalette));
; 521  : 
; 522  :     // get the hardware info
; 523  :     if (!DisplayPddGetModeInfo(m_hDisplay, modeNumber, &info))

  00014	e5970088	 ldr         r0, [r7, #0x88]
  00018	e3a03116	 mov         r3, #0x16, 2
  0001c	e28d2020	 add         r2, sp, #0x20
  00020	e3838901	 orr         r8, r3, #1, 18
  00024	eb000000	 bl          DisplayPddGetModeInfo
  00028	e3500000	 cmp         r0, #0
  0002c	0a000062	 beq         |$cleanUp$41855|

; 524  :     {
; 525  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::SetMode: "
; 526  :             L"Failed get mode info from display for mode %d\r\n", modeNumber));
; 527  :         goto cleanUp;
; 528  :     }
; 529  : 
; 530  :     // get the mode info
; 531  :     sc = GetModeInfo(&gpeMode, modeNumber);

  00030	e5973000	 ldr         r3, [r7]
  00034	e1a02009	 mov         r2, r9
  00038	e28d1008	 add         r1, sp, #8
  0003c	e5933024	 ldr         r3, [r3, #0x24]
  00040	e1a00007	 mov         r0, r7
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3
  0004c	e1b08000	 movs        r8, r0

; 532  :     if (FAILED(sc))

  00050	4a000059	 bmi         |$cleanUp$41855|

; 533  :     {
; 534  :         goto cleanUp;
; 535  :     }
; 536  :     
; 537  :     // Create palette depending on format
; 538  :     switch (gpeMode.format) {

  00054	e59d301c	 ldr         r3, [sp, #0x1C]
  00058	e3530004	 cmp         r3, #4
  0005c	1a000056	 bne         |$cleanUp$41855|

; 539  :     case gpe16Bpp:
; 540  :         *phPalette = EngCreatePalette(
; 541  :             PAL_BITFIELDS, 0, NULL, info.red, info.green, info.blue
; 542  :         );

  00060	e59f3168	 ldr         r3, [pc, #0x168]
  00064	e59d4030	 ldr         r4, [sp, #0x30]
  00068	e59d502c	 ldr         r5, [sp, #0x2C]
  0006c	e5936000	 ldr         r6, [r3]
  00070	e59d3028	 ldr         r3, [sp, #0x28]
  00074	e3a02000	 mov         r2, #0
  00078	e3a01000	 mov         r1, #0
  0007c	e3a00002	 mov         r0, #2
  00080	e58d4004	 str         r4, [sp, #4]
  00084	e58d5000	 str         r5, [sp]
  00088	e1a0e00f	 mov         lr, pc
  0008c	e12fff16	 bx          r6

; 543  :         g_bitMasks[0] = info.red;

  00090	e59fe134	 ldr         lr, [pc, #0x134]
  00094	e59d1028	 ldr         r1, [sp, #0x28]

; 544  :         g_bitMasks[1] = info.green;

  00098	e59d302c	 ldr         r3, [sp, #0x2C]

; 545  :         g_bitMasks[2] = info.blue;

  0009c	e59d2030	 ldr         r2, [sp, #0x30]
  000a0	e58a0000	 str         r0, [r10]
  000a4	e88e000a	 stmia       lr, {r1, r3}
  000a8	e58e2008	 str         r2, [lr, #8]

; 546  :         break;
; 547  :     default:
; 548  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP730GPE::SetMode: "
; 549  :             L"Unsupported format mode (%d)\r\n", gpeMode.format
; 550  :         ));
; 551  :         goto cleanUp;
; 552  :     }
; 553  :     
; 554  :     if (*phPalette == NULL) {

  000ac	e59a3000	 ldr         r3, [r10]
  000b0	e3530000	 cmp         r3, #0
  000b4	03a0313a	 moveq       r3, #0x3A, 2

; 555  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP730GPE::SetMode: "
; 556  :             L"Palette creation failed\r\n"
; 557  :         ));
; 558  :         sc = E_OUTOFMEMORY;

  000b8	03838807	 orreq       r8, r3, #7, 16
  000bc	0a00003e	 beq         |$cleanUp$41855|

; 559  :         goto cleanUp;
; 560  :     }
; 561  : 
; 562  :     // We want set hardware to D0, but it can be
; 563  :     // overpowered by external state. We have to kick 
; 564  :     // power thread if there was real power change.
; 565  :     m_updateFlag = TRUE;

  000c0	e3a05001	 mov         r5, #1

; 566  :     if (SetPower(D0))

  000c4	e3a01000	 mov         r1, #0
  000c8	e1a00007	 mov         r0, r7
  000cc	e58750e8	 str         r5, [r7, #0xE8]
  000d0	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|
  000d4	e3500000	 cmp         r0, #0

; 567  :     {
; 568  :         SetEvent(m_hPowerEvent);

  000d8	159700c8	 ldrne       r0, [r7, #0xC8]
  000dc	13a01003	 movne       r1, #3
  000e0	1b000000	 blne        EventModify

; 569  :     }
; 570  : 
; 571  :     //----------------------------------------------------------------------
; 572  :     //  Configure LCD hardware
; 573  :     //----------------------------------------------------------------------
; 574  : 
; 575  :     // Set LCD controller to new hardware state
; 576  :     if (!DisplayPddSetMode(m_hDisplay, modeNumber))

  000e4	e5970088	 ldr         r0, [r7, #0x88]
  000e8	e1a01009	 mov         r1, r9
  000ec	eb000000	 bl          DisplayPddSetMode
  000f0	e3500000	 cmp         r0, #0
  000f4	0a000030	 beq         |$cleanUp$41855|

; 577  :     {
; 578  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::SetMode: "
; 579  :             L"LCD failed set mode %d\r\n", modeNumber));
; 580  :         goto cleanUp;
; 581  :     }
; 582  : 
; 583  :     //----------------------------------------------------------------------
; 584  :     //  Create primary surface
; 585  :     //----------------------------------------------------------------------
; 586  : 
; 587  :     // Set mode information
; 588  :     m_gpeMode = gpeMode;

  000f8	e2870098	 add         r0, r7, #0x98
  000fc	e28d1008	 add         r1, sp, #8
  00100	e3a02018	 mov         r2, #0x18
  00104	eb000000	 bl          memcpy

; 589  :     m_pMode = &m_gpeMode;

  00108	e2873098	 add         r3, r7, #0x98
  0010c	e5873010	 str         r3, [r7, #0x10]

; 590  :     m_nScreenWidth  = m_pMode->width;

  00110	e597309c	 ldr         r3, [r7, #0x9C]

; 591  :     m_nScreenHeight = m_pMode->height;
; 592  :     
; 593  :     // Allocate new primary surface
; 594  :     delete m_pPrimarySurface;

  00114	e5972004	 ldr         r2, [r7, #4]
  00118	e5873008	 str         r3, [r7, #8]
  0011c	e59730a0	 ldr         r3, [r7, #0xA0]
  00120	e3520000	 cmp         r2, #0
  00124	13a01001	 movne       r1, #1
  00128	e587300c	 str         r3, [r7, #0xC]
  0012c	15923000	 ldrne       r3, [r2]
  00130	11a00002	 movne       r0, r2
  00134	15933000	 ldrne       r3, [r3]
  00138	11a0e00f	 movne       lr, pc
  0013c	112fff13	 bxne        r3

; 595  :     sc = AllocSurface(&m_pPrimarySurface, m_pMode->width, m_pMode->height, m_pMode->format, GPE_REQUIRE_VIDEO_MEMORY);

  00140	e5972010	 ldr         r2, [r7, #0x10]
  00144	e597e000	 ldr         lr, [r7]
  00148	e2871004	 add         r1, r7, #4
  0014c	e5920014	 ldr         r0, [r2, #0x14]
  00150	e5923008	 ldr         r3, [r2, #8]
  00154	e5922004	 ldr         r2, [r2, #4]
  00158	e59e4010	 ldr         r4, [lr, #0x10]
  0015c	e58d0000	 str         r0, [sp]
  00160	e1a00007	 mov         r0, r7
  00164	e58d5004	 str         r5, [sp, #4]
  00168	e1a0e00f	 mov         lr, pc
  0016c	e12fff14	 bx          r4
  00170	e1b08000	 movs        r8, r0

; 596  : 
; 597  :     // When it failed, there isn't so much we can do
; 598  :     if (FAILED(sc)) {

  00174	4a000010	 bmi         |$cleanUp$41855|

; 599  :         DEBUGMSG(GPE_ZONE_ERROR, (L"OMAP2420GPE::SetMode: "
; 600  : 
; 601  :             L"Couldn't allocate primary surface\r\n"));
; 602  :         goto cleanUp;
; 603  :     }
; 604  : 
; 605  :     // Set base rotation
; 606  :     m_pPrimarySurface->SetRotation(m_nScreenWidth, m_nScreenHeight, DMDO_0);

  00178	e597200c	 ldr         r2, [r7, #0xC]
  0017c	e5971008	 ldr         r1, [r7, #8]
  00180	e5970004	 ldr         r0, [r7, #4]
  00184	e3a03000	 mov         r3, #0
  00188	eb000000	 bl          |?SetRotation@GPESurf@@QAAXHHH@Z|

; 607  :     
; 608  :     //----------------------------------------------------------------------
; 609  :     //  Configure OMAP2420 DISP controller
; 610  :     //----------------------------------------------------------------------
; 611  : 
; 612  :     // initialize the display registers
; 613  :     InitController(&info);

  0018c	e28d1020	 add         r1, sp, #0x20
  00190	e1a00007	 mov         r0, r7
  00194	eb000000	 bl          |?InitController@OMAP2420GPE@@AAAXPAUOMAP2420_DISPLAY_MODE_INFO@@@Z|

; 614  : 
; 615  :     // make the primary surface visible and tell the controller to go with the new values
; 616  :     SetVisibleSurface(m_pPrimarySurface, 0, FALSE);

  00198	e5972000	 ldr         r2, [r7]
  0019c	e5971004	 ldr         r1, [r7, #4]
  001a0	e3a03000	 mov         r3, #0
  001a4	e59240bc	 ldr         r4, [r2, #0xBC]
  001a8	e3a02000	 mov         r2, #0
  001ac	e1a00007	 mov         r0, r7
  001b0	e1a0e00f	 mov         lr, pc
  001b4	e12fff14	 bx          r4

; 617  : 
; 618  :     // reinitialize TV-Out
; 619  : #if defined(TVOUT)
; 620  :     SetTVOut(m_dwTVOut);
; 621  : #endif
; 622  : 
; 623  :     // Done
; 624  :     sc = S_OK;

  001b8	e3a08000	 mov         r8, #0
  001bc		 |$cleanUp$41855|

; 625  : 
; 626  : cleanUp:
; 627  : 
; 628  :     DEBUGMSG(GPE_ZONE_PDD, (L"-OMAP2420GPE::SetMode(sc = 0x%08x)\r\n", sc));
; 629  :     return sc;
; 630  : }

  001bc	e1a00008	 mov         r0, r8
  001c0	e28dd07c	 add         sp, sp, #0x7C
  001c4	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001c8	e12fff1e	 bx          lr
  001cc		 |$LN26@SetMode|
  001cc		 |$LN27@SetMode|
  001cc	00000000	 DCD         |g_bitMasks|
  001d0		 |$LN28@SetMode|
  001d0	00000000	 DCD         |EngCreatePalette|
  001d4		 |$M43627|

			 ENDP  ; |?SetMode@OMAP2420GPE@@UAAJHPAPAUHPALETTE__@@@Z|, OMAP2420GPE::SetMode

; File c:\wince600\public\common\oak\inc\ddgpe.h

  00000			 AREA	 |.pdata|, PDATA
|$T43653| DCD	|$LN17@SetVisible|
	DCD	0x40002401
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetVisibleSurface@OMAP2420GPE@@UAAXPAVGPESurf@@KH@Z| PROC ; OMAP2420GPE::SetVisibleSurface

; 793  : {

  00000		 |$LN17@SetVisible|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43650|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 794  :     OMAP2420Surf *pSurf = (OMAP2420Surf *)pGPESurf;
; 795  : 
; 796  :     DEBUGMSG(GPE_ZONE_PDD, (L"OMAP2420GPE::SetVisibleSurface: %08X %d\r\n", pSurf, pSurf->IsOverlay()));
; 797  : 
; 798  :     // get the buffer address
; 799  :     if (pSurf->OffsetInVideoMemory() == 0)

  0000c	e5953034	 ldr         r3, [r5, #0x34]
  00010	e3530000	 cmp         r3, #0
  00014	0a00001b	 beq         |$LN7@SetVisible|

; 800  :     {
; 801  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::SetVisibleSurface: "
; 802  :             L"Surface physical address is zero...\r\n"));
; 803  :         return;
; 804  :     }
; 805  : 
; 806  :     // We want set hardware to D0, but it can be
; 807  :     // overpowered by external state. We have to kick 
; 808  :     // power thread if there was real power change.
; 809  :     m_updateFlag = TRUE;

  00018	e3a03001	 mov         r3, #1

; 810  :     if (SetPower(D0))

  0001c	e3a01000	 mov         r1, #0
  00020	e58430e8	 str         r3, [r4, #0xE8]
  00024	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|
  00028	e3500000	 cmp         r0, #0

; 811  :     {
; 812  :         SetEvent(m_hPowerEvent);

  0002c	159400c8	 ldrne       r0, [r4, #0xC8]
  00030	13a01003	 movne       r1, #3
  00034	1b000000	 blne        EventModify

; 813  :     }
; 814  : 
; 815  :     // update the visible pointer
; 816  :     if (pSurf->IsOverlay())

  00038	e5953060	 ldr         r3, [r5, #0x60]
  0003c	e3530000	 cmp         r3, #0
  00040	0a00000d	 beq         |$LN4@SetVisible|

; 817  :     {
; 818  :         if (m_pVisibleOverlay)

  00044	e5943090	 ldr         r3, [r4, #0x90]
  00048	e3530000	 cmp         r3, #0

; 819  :         {
; 820  :             pSurf->m_pVidRegs = m_pVisibleOverlay->m_pVidRegs;

  0004c	15933088	 ldrne       r3, [r3, #0x88]

; 821  :             m_pVisibleOverlay->m_pVidRegs = NULL;

  00050	13a02000	 movne       r2, #0
  00054	15853088	 strne       r3, [r5, #0x88]
  00058	15943090	 ldrne       r3, [r4, #0x90]
  0005c	15832088	 strne       r2, [r3, #0x88]

; 822  :         }
; 823  :         else
; 824  :         {
; 825  :             pSurf->m_pVidRegs = &m_pDISPCRegs->tDISPC_VID1;
; 826  :         }
; 827  :         m_pVisibleOverlay = pSurf;

  00060	15845090	 strne       r5, [r4, #0x90]
  00064	1a000005	 bne         |$LN1@SetVisible|
  00068	e5943080	 ldr         r3, [r4, #0x80]
  0006c	e28330bc	 add         r3, r3, #0xBC
  00070	e5853088	 str         r3, [r5, #0x88]
  00074	e5845090	 str         r5, [r4, #0x90]

; 828  :     }
; 829  :     else

  00078	ea000000	 b           |$LN1@SetVisible|
  0007c		 |$LN4@SetVisible|

; 830  :     {
; 831  :         m_pVisibleSurface = pSurf;

  0007c	e584508c	 str         r5, [r4, #0x8C]
  00080		 |$LN1@SetVisible|

; 832  :     }
; 833  : 
; 834  :     // update the video addresses	
; 835  :     SetControllerAddresses();

  00080	e1a00004	 mov         r0, r4
  00084	eb000000	 bl          |?SetControllerAddresses@OMAP2420GPE@@AAAXXZ|
  00088		 |$LN7@SetVisible|

; 836  : }

  00088	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$M43651|

			 ENDP  ; |?SetVisibleSurface@OMAP2420GPE@@UAAXPAVGPESurf@@KH@Z|, OMAP2420GPE::SetVisibleSurface

; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43669| DCD	|$LN10@Line|
	DCD	0x40001601
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Line@OMAP2420GPE@@UAAJPAUGPELineParms@@W4EGPEPhase@@@Z| PROC ; OMAP2420GPE::Line

; 1084 : {

  00000		 |$LN10@Line|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43666|
  00004	e3520000	 cmp         r2, #0
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 1085 :     DEBUGMSG(GPE_ZONE_PDD, (L"+OMAP2420GPE::Line\r\n"));
; 1086 :     if (phase == gpeSingle || phase == gpePrepare)

  00010	0a000001	 beq         |$LN2@Line|
  00014	e3520001	 cmp         r2, #1
  00018	1a00000a	 bne         |$LN3@Line|
  0001c		 |$LN2@Line|

; 1087 :     {
; 1088 :         // We want set hardware to D0, but it can be
; 1089 :         // overpowered by external state. We have to kick 
; 1090 :         // power thread if there was real power change.
; 1091 :         m_updateFlag = TRUE;

  0001c	e3a03001	 mov         r3, #1

; 1092 :         if (SetPower(D0))

  00020	e3a01000	 mov         r1, #0
  00024	e1a00004	 mov         r0, r4
  00028	e58430e8	 str         r3, [r4, #0xE8]
  0002c	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|
  00030	e3500000	 cmp         r0, #0

; 1093 :         {
; 1094 :             SetEvent(m_hPowerEvent);

  00034	159400c8	 ldrne       r0, [r4, #0xC8]
  00038	13a01003	 movne       r1, #3
  0003c	1b000000	 blne        EventModify

; 1095 :         }
; 1096 :         // Use wrapper to make sure that we don't move to low power...
; 1097 :         pLineParms->pLine = (LINEFUNC)&OMAP2420GPE::WrappedEmulatedLine;

  00040	e59f300c	 ldr         r3, [pc, #0xC]
  00044	e5853000	 str         r3, [r5]
  00048		 |$LN3@Line|

; 1098 :     }
; 1099 :     return S_OK;

  00048	e3a00000	 mov         r0, #0

; 1100 : }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN11@Line|
  00054		 |$LN12@Line|
  00054	00000000	 DCD         |?WrappedEmulatedLine@OMAP2420GPE@@AAAJPAUGPELineParms@@@Z|
  00058		 |$M43667|

			 ENDP  ; |?Line@OMAP2420GPE@@UAAJPAUGPELineParms@@W4EGPEPhase@@@Z|, OMAP2420GPE::Line

	IMPORT	|?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z| ; GPE::EmulatedBlt
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43686| DCD	|$LN8@BltPrepare|
	DCD	0x40001201
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\display\omap2420gpe.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?BltPrepare@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z| PROC ; OMAP2420GPE::BltPrepare

; 1127 : {

  00000		 |$LN8@BltPrepare|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43683|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 1128 :     // We want set hardware to D0, but it can be
; 1129 :     // overpowered by external state. We have to kick 
; 1130 :     // power thread/ if there was real power change.
; 1131 :     m_updateFlag = TRUE;

  0000c	e3a06001	 mov         r6, #1

; 1132 :     if (SetPower(D0))

  00010	e3a01000	 mov         r1, #0
  00014	e58460e8	 str         r6, [r4, #0xE8]
  00018	eb000000	 bl          |?SetPower@OMAP2420GPE@@AAAHW4_CEDEVICE_POWER_STATE@@@Z|
  0001c	e3500000	 cmp         r0, #0

; 1133 :     {
; 1134 :         SetEvent(m_hPowerEvent);

  00020	159400c8	 ldrne       r0, [r4, #0xC8]
  00024	13a01003	 movne       r1, #3
  00028	1b000000	 blne        EventModify

; 1135 :     }
; 1136 :     
; 1137 :     pBltParms->pBlt = &GPE::EmulatedBlt;

  0002c	e59f3010	 ldr         r3, [pc, #0x10]

; 1138 : 
; 1139 : #if 0    
; 1140 :     if (pBltParms->pDst->InVideoMemory()) {
; 1141 :         ASSERT( pBltParms->pDst->Format() == gpe16Bpp);
; 1142 : 
; 1143 : // removing this code fixes LTK test 4018, however disables hardware (DMA based) acceleration
; 1144 : /*
; 1145 :         switch(pBltParms->rop4) {
; 1146 :         case 0x0000:  // BLACKNESS
; 1147 :             pBltParms->solidColor = 0;
; 1148 :             pBltParms->pBlt = (BLTFUNC)HWFill16;
; 1149 :             break;
; 1150 : 
; 1151 :         case 0xFFFF:  // WHITENESS
; 1152 :             pBltParms->solidColor = 0x0000FFFF;
; 1153 :             pBltParms->pBlt = (BLTFUNC)HWFill16;
; 1154 :             break;
; 1155 : 
; 1156 :         case 0xF0F0:  // PATCOPY
; 1157 :             // Solid color only
; 1158 :             if (pBltParms->solidColor != -1) {
; 1159 :                 pBltParms->pBlt = (BLTFUNC)HWFill16;
; 1160 :             }
; 1161 :             break;
; 1162 : 
; 1163 :         case 0xCCCC:  // SRCCOPY
; 1164 :             if( (pBltParms->pSrc->InVideoMemory()) &&        // only in SRAM
; 1165 :                 !pBltParms->pLookup  &&                      // No color...
; 1166 :                 !pBltParms->pConvert &&                      // ...conversions
; 1167 :                 !(pBltParms->bltFlags & (BLT_STRETCH |       // No stretch
; 1168 :                                          BLT_TRANSPARENT |   // No transparency
; 1169 :                                          BLT_ALPHABLEND |    // No alpha
; 1170 :                                          BLT_DSTTRANSPARENT)))
; 1171 :             {
; 1172 :                 ASSERT(pBltParms->pSrc->Format()==gpe16Bpp);
; 1173 :                 pBltParms->pBlt = (BLTFUNC)HWSrcCopy1616;
; 1174 :             }
; 1175 :             break;
; 1176 : 
; 1177 :         }
; 1178 : */
; 1179 : 
; 1180 :         if (m_flipBusy) {
; 1181 :             // SurfaceBusyFlipping only blocks the primary and
; 1182 :             // back buffer surface on a flip
; 1183 :             while (SurfaceBusyFlipping(pBltParms->pDst)) Sleep(1);
; 1184 :         }
; 1185 : 
; 1186 :         if (pBltParms->pBlt == EmulatedBlt)
; 1187 :         {
; 1188 :             static_cast<OMAP2420Surf*>(pBltParms->pDst)->InCache();
; 1189 :         }
; 1190 :     }
; 1191 : #endif
; 1192 : 
; 1193 :     // Set update flag
; 1194 :     m_updateFlag = TRUE;
; 1195 : 
; 1196 :     // Done
; 1197 :     return S_OK;

  00030	e3a00000	 mov         r0, #0
  00034	e5853000	 str         r3, [r5]
  00038	e58460e8	 str         r6, [r4, #0xE8]

; 1198 : }

  0003c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN9@BltPrepare|
  00044		 |$LN10@BltPrepare|
  00044	00000000	 DCD         |?EmulatedBlt@GPE@@QAAJPAUGPEBltParms@@@Z|
  00048		 |$M43684|

			 ENDP  ; |?BltPrepare@OMAP2420GPE@@UAAJPAUGPEBltParms@@@Z|, OMAP2420GPE::BltPrepare

	EXPORT	|?PowerThreadStub@OMAP2420GPE@@CAKPAX@Z| ; OMAP2420GPE::PowerThreadStub

  00000			 AREA	 |.pdata|, PDATA
|$T43698| DCD	|$LN5@PowerThrea@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerThreadStub@OMAP2420GPE@@CAKPAX@Z| PROC ; OMAP2420GPE::PowerThreadStub

; 1869 : {

  00000		 |$LN5@PowerThrea@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43695|

; 1870 :     OMAP2420GPE *pOMAP2420GPE = (OMAP2420GPE *)pContext;
; 1871 :     return pOMAP2420GPE->PowerThread();

  00004	eb000000	 bl          |?PowerThread@OMAP2420GPE@@AAAKXZ|

; 1872 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M43696|

			 ENDP  ; |?PowerThreadStub@OMAP2420GPE@@CAKPAX@Z|, OMAP2420GPE::PowerThreadStub

	EXPORT	|?Init@OMAP2420GPE@@QAAHPBG@Z|		; OMAP2420GPE::Init
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|CreateEventW|
	IMPORT	|MmMapIoSpace|
	IMPORT	|DisplayPddInit|
	IMPORT	|GetDeviceRegistryParams|

  00000			 AREA	 |.pdata|, PDATA
|$T43747| DCD	|$LN42@Init|
	DCD	0x40007202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@OMAP2420GPE@@QAAHPBG@Z| PROC	; OMAP2420GPE::Init

; 293  : {

  00000		 |$LN42@Init|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd048	 sub         sp, sp, #0x48
  00008		 |$M43744|
  00008	e1a0e001	 mov         lr, r1
  0000c	e58de024	 str         lr, [sp, #0x24]
  00010	e1a0b000	 mov         r11, r0

; 294  :     BOOL rc = FALSE;
; 295  :     PHYSICAL_ADDRESS pa;
; 296  : #if defined(TVOUT)
; 297  :     I2C_SET_SLAVE_ADDRESS i2c;
; 298  : #endif
; 299  : 
; 300  :     //DEBUGMSG(TRUE,(L"OMAP2420GPE::Init++\r\n"));
; 301  :     // Read device parameters
; 302  :     if (GetDeviceRegistryParams(context,
; 303  :             this,
; 304  :             dimof(g_deviceRegParams),
; 305  :             g_deviceRegParams) != ERROR_SUCCESS)

  00014	e59f31a8	 ldr         r3, [pc, #0x1A8]
  00018	e3a02006	 mov         r2, #6
  0001c	e1a0100b	 mov         r1, r11
  00020	e1a0000e	 mov         r0, lr
  00024	eb000000	 bl          GetDeviceRegistryParams
  00028	e3500000	 cmp         r0, #0
  0002c	1a00005d	 bne         |$LN38@Init|

; 306  :     {
; 307  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 308  :             L"Failed read display driver registry parameters\r\n"));
; 309  :         goto cleanUp;
; 310  :     }
; 311  :     ASSERT(m_bitsPerPixel == 16);
; 312  : 
; 313  :     // Convert display power class to GUID
; 314  :     if (!ConvertStringToGuid(m_szDisplayPowerClass,
; 315  :             &m_powerClassGUID))

  00030	e28b20b8	 add         r2, r11, #0xB8
  00034	e59b0070	 ldr         r0, [r11, #0x70]
  00038	e59f1180	 ldr         r1, [pc, #0x180]
  0003c	e2823006	 add         r3, r2, #6
  00040	e58d3000	 str         r3, [sp]
  00044	e28de044	 add         lr, sp, #0x44
  00048	e28d4040	 add         r4, sp, #0x40
  0004c	e28d503c	 add         r5, sp, #0x3C
  00050	e28d6038	 add         r6, sp, #0x38
  00054	e28d7034	 add         r7, sp, #0x34
  00058	e28d8030	 add         r8, sp, #0x30
  0005c	e28d902c	 add         r9, sp, #0x2C
  00060	e28da028	 add         r10, sp, #0x28
  00064	e2823004	 add         r3, r2, #4
  00068	e58de020	 str         lr, [sp, #0x20]
  0006c	e58d401c	 str         r4, [sp, #0x1C]
  00070	e58d5018	 str         r5, [sp, #0x18]
  00074	e58d6014	 str         r6, [sp, #0x14]
  00078	e58d7010	 str         r7, [sp, #0x10]
  0007c	e58d800c	 str         r8, [sp, #0xC]
  00080	e58d9008	 str         r9, [sp, #8]
  00084	e58da004	 str         r10, [sp, #4]
  00088	eb000000	 bl          swscanf
  0008c	e350000b	 cmp         r0, #0xB
  00090	1a000044	 bne         |$LN38@Init|
  00094	e3a01000	 mov         r1, #0
  00098	e28de028	 add         lr, sp, #0x28
  0009c	e28b00b8	 add         r0, r11, #0xB8
  000a0		 |$LL23@Init|
  000a0	e49e2004	 ldr         r2, [lr], #4
  000a4	e0813000	 add         r3, r1, r0
  000a8	e2811001	 add         r1, r1, #1
  000ac	e3510008	 cmp         r1, #8
  000b0	e5c32008	 strb        r2, [r3, #8]
  000b4	3afffff9	 bcc         |$LL23@Init|

; 316  :     {
; 317  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 318  :             L"Failed convert display power class '%s' to GUID\r\n"));
; 319  :         goto cleanUp;
; 320  :     }
; 321  : 
; 322  :     // Advertise power class interface
; 323  :     if (!AdvertiseInterface(&m_powerClassGUID,
; 324  :             L"DDI",
; 325  :             TRUE))

  000b8	e59f10fc	 ldr         r1, [pc, #0xFC]
  000bc	e3a02001	 mov         r2, #1
  000c0		 |$cleanUp$43711|
  000c0	eb000000	 bl          AdvertiseInterface
  000c4	e3500000	 cmp         r0, #0
  000c8	0a000036	 beq         |$LN38@Init|

; 326  :     {
; 327  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 328  :             L"Failed advertise display power class '%s'\r\n"
; 329  :         ));
; 330  :         goto cleanUp;
; 331  :     }        
; 332  : 
; 333  :     // We don't need string GUID anymore
; 334  :     delete m_szDisplayPowerClass;

  000cc	e59b0070	 ldr         r0, [r11, #0x70]
  000d0	eb000000	 bl          |??3@YAXPAX@Z|

; 335  :     m_szDisplayPowerClass = NULL;
; 336  : 
; 337  :     // First initialize LCD display module connected to the controller
; 338  :     if ((m_hDisplay = DisplayPddInit(context)) == NULL)

  000d4	e59d0024	 ldr         r0, [sp, #0x24]
  000d8	e3a04000	 mov         r4, #0
  000dc	e58b4070	 str         r4, [r11, #0x70]
  000e0	eb000000	 bl          DisplayPddInit
  000e4	e3500000	 cmp         r0, #0
  000e8	e58b0088	 str         r0, [r11, #0x88]
  000ec	0a00002d	 beq         |$LN38@Init|

; 339  :     {
; 340  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 341  :             L"Failed initialize LCD display object\r\n"));
; 342  :         goto cleanUp;
; 343  :     }
; 344  : 
; 345  :     // Map DSS controller registers
; 346  :     pa.QuadPart = m_memBase[MEM_IDX_DSS];

  000f0	e59b0040	 ldr         r0, [r11, #0x40]

; 347  :     if ((m_pDSSRegs = (OMAP2420_DSS_REGS*)MmMapIoSpace(pa, m_memLen[MEM_IDX_DSS], FALSE)) == NULL)

  000f4	e59b2054	 ldr         r2, [r11, #0x54]
  000f8	e3a01000	 mov         r1, #0
  000fc	e3a03000	 mov         r3, #0
  00100	eb000000	 bl          MmMapIoSpace
  00104	e3500000	 cmp         r0, #0
  00108	e58b007c	 str         r0, [r11, #0x7C]
  0010c	0a000025	 beq         |$LN38@Init|

; 348  :     {
; 349  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 350  :             L"Failed to map DSS registers (pa = 0x%08x)\r\n", pa.LowPart));
; 351  :         goto cleanUp;
; 352  :     }
; 353  : 
; 354  :     // Map LCD controller registers
; 355  :     pa.QuadPart = m_memBase[MEM_IDX_LCD];

  00110	e59b0044	 ldr         r0, [r11, #0x44]

; 356  :     if ((m_pDISPCRegs = (OMAP2420_DISPC_REGS*)MmMapIoSpace(pa, m_memLen[MEM_IDX_LCD], FALSE)) == NULL)

  00114	e59b2058	 ldr         r2, [r11, #0x58]
  00118	e3a01000	 mov         r1, #0
  0011c	e3a03000	 mov         r3, #0
  00120	eb000000	 bl          MmMapIoSpace
  00124	e3500000	 cmp         r0, #0
  00128	e58b0080	 str         r0, [r11, #0x80]
  0012c	0a00001d	 beq         |$LN38@Init|

; 357  :     {
; 358  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 359  :             L"Failed to map LCD registers (pa = 0x%08x)\r\n", pa.LowPart));
; 360  :         goto cleanUp;
; 361  :     }
; 362  : 
; 363  :     // Map video encoder registers
; 364  :     pa.QuadPart = m_memBase[MEM_IDX_VENC];

  00130	e59b004c	 ldr         r0, [r11, #0x4C]

; 365  :     if ((m_pVENCRegs = (OMAP2420_VENC_REGS*)MmMapIoSpace(pa, m_memLen[MEM_IDX_VENC], FALSE)) == NULL)

  00134	e59b2060	 ldr         r2, [r11, #0x60]
  00138	e3a01000	 mov         r1, #0
  0013c	e3a03000	 mov         r3, #0
  00140	eb000000	 bl          MmMapIoSpace
  00144	e3500000	 cmp         r0, #0
  00148	e58b0084	 str         r0, [r11, #0x84]

; 366  :     {
; 367  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 368  :             L"Failed to map VENC registers (pa = 0x%08x)\r\n", pa.LowPart));
; 369  :         goto cleanUp;
; 370  :     }
; 371  :    
; 372  : #if defined(TVOUT)
; 373  :     // open I2C bus
; 374  :     m_hI2C = CreateFile(I2C_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
; 375  :                         NULL, OPEN_EXISTING, 0, NULL);
; 376  :     if (m_hI2C == INVALID_HANDLE_VALUE)
; 377  :     {
; 378  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 379  :             L"Failed (%08X) to open I2C device %s (%08X)\r\n", GetLastError(), I2C_DEVICE_NAME));
; 380  :         goto cleanUp;
; 381  :     }
; 382  : 
; 383  :     // set the I2C slave address
; 384  :     i2c.address = I2C_MENELAUS_ADDRESS;
; 385  :     i2c.size = I2C_MENELAUS_ADDRSIZE;
; 386  :     if (!DeviceIoControl(m_hI2C, IOCTL_I2C_SET_SLAVE_ADDRESS, (PVOID)&i2c, sizeof(i2c), NULL, 0, NULL, NULL))
; 387  :     {
; 388  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 389  :             L"Failed (%08X) to set I2C slave address\r\n", GetLastError()));
; 390  :         CloseHandle(m_hI2C);
; 391  :         goto cleanUp;
; 392  :     }
; 393  : #endif // defined(TVOUT)
; 394  : 
; 395  :     // Create power event
; 396  :     if ((m_hPowerEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)

  0014c	e3a00000	 mov         r0, #0
  00150	0a000015	 beq         |$cleanUp$41779|
  00154	e3a03000	 mov         r3, #0
  00158	e3a02000	 mov         r2, #0
  0015c	e3a01000	 mov         r1, #0
  00160	eb000000	 bl          CreateEventW
  00164	e3500000	 cmp         r0, #0
  00168	e58b00c8	 str         r0, [r11, #0xC8]

; 397  :     {
; 398  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 399  :             L"Failed create power event\r\n"));
; 400  :         goto cleanUp;
; 401  :     }
; 402  :     
; 403  :     // Start power thread
; 404  :     if ((m_hPowerThread = CreateThread(NULL, 0, PowerThreadStub, this, 0, NULL)) == NULL)

  0016c	e3a00000	 mov         r0, #0
  00170	0a00000d	 beq         |$cleanUp$41779|
  00174	e59f203c	 ldr         r2, [pc, #0x3C]
  00178	e1a0300b	 mov         r3, r11
  0017c	e3a01000	 mov         r1, #0
  00180	e58d4004	 str         r4, [sp, #4]
  00184	e58d4000	 str         r4, [sp]
  00188	eb000000	 bl          CreateThread
  0018c	e3500000	 cmp         r0, #0
  00190	e58b00cc	 str         r0, [r11, #0xCC]
  00194	0a000003	 beq         |$LN38@Init|

; 405  :     {
; 406  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: OMAP2420GPE::Init: "
; 407  :             L"Failed create power thread\r\n"));
; 408  :         goto cleanUp;
; 409  :     }
; 410  : 
; 411  :     // Set power thread priority
; 412  :     CeSetThreadPriority(m_hPowerThread, m_priority256);

  00198	e59b1078	 ldr         r1, [r11, #0x78]
  0019c	eb000000	 bl          CeSetThreadPriority

; 413  : 
; 414  : #if defined(TVOUT)
; 415  :     // get the TV-Out registers pointer and set the initial TV-Out mode
; 416  :     m_pTVVidRegs = &m_pDISPCRegs->tDISPC_VID2;
; 417  :     m_dwTVOut = TVOUT_NONE;
; 418  : #endif
; 419  : 
; 420  :     // Done
; 421  :     rc = TRUE;

  001a0	e3a00001	 mov         r0, #1
  001a4	ea000000	 b           |$cleanUp$41779|
  001a8		 |$LN38@Init|
  001a8	e3a00000	 mov         r0, #0
  001ac		 |$cleanUp$41779|

; 422  : 
; 423  : cleanUp:
; 424  :     //DEBUGMSG(TRUE,(L"OMAP2420GPE::Init--\r\n"));
; 425  :     return rc;
; 426  : }

  001ac	e28dd048	 add         sp, sp, #0x48
  001b0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001b4	e12fff1e	 bx          lr
  001b8		 |$LN43@Init|
  001b8		 |$LN44@Init|
  001b8	00000000	 DCD         |?PowerThreadStub@OMAP2420GPE@@CAKPAX@Z|
  001bc		 |$LN45@Init|
  001bc	00000000	 DCD         |??_C@_17EFNPLDEM@?$AAD?$AAD?$AAI?$AA?$AA@|
  001c0		 |$LN46@Init|
  001c0	00000000	 DCD         |??_C@_1GI@LBPPMOKF@?$AA?$HL?$AA?$CF?$AA0?$AA8?$AAl?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA4?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0?$AA2?$AAX?$AA?9?$AA?$CF?$AA0?$AA2?$AAX?$AA?$CF?$AA0@|
  001c4		 |$LN47@Init|
  001c4	00000000	 DCD         |g_deviceRegParams|
  001c8		 |$M43745|

			 ENDP  ; |?Init@OMAP2420GPE@@QAAHPBG@Z|, OMAP2420GPE::Init

	EXPORT	|DisplayInit|
	EXPORT	|??_C@_1CG@BEPCNIEH@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?2?$AAG?$AAD?$AAI?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T43768| DCD	|$LN11@DisplayIni|
	DCD	0x40001b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@BEPCNIEH@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?2?$AAG?$AAD?$AAI?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@| DCB "S"
	DCB	0x0, "y", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, "\\"
	DCB	0x0, "G", 0x0, "D", 0x0, "I", 0x0, "\\", 0x0, "D", 0x0, "r"
	DCB	0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DisplayInit| PROC

; 120  : {

  00000		 |$LN11@DisplayIni|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43765|
  00004	e1a05000	 mov         r5, r0

; 121  :     BOOL rc = FALSE;
; 122  :     OMAP2420GPE *pGPE;
; 123  : 
; 124  :     DEBUGMSG(GPE_ZONE_PDD, (L"+DisplayInit(%s, %d)\r\n", context, monitors));
; 125  : 
; 126  :     pGPE = new OMAP2420GPE;

  00008	e3a000fc	 mov         r0, #0xFC
  0000c	e3a06000	 mov         r6, #0
  00010	eb000000	 bl          |??2@YAPAXI@Z|
  00014	e3500000	 cmp         r0, #0
  00018	0a000002	 beq         |$LN7@DisplayIni|
  0001c	eb000000	 bl          |??0OMAP2420GPE@@QAA@XZ|
  00020	e1a04000	 mov         r4, r0
  00024	ea000000	 b           |$LN8@DisplayIni|
  00028		 |$LN7@DisplayIni|
  00028	e3a04000	 mov         r4, #0
  0002c		 |$LN8@DisplayIni|

; 127  :     if (context == NULL)

  0002c	e3550000	 cmp         r5, #0

; 128  :     {
; 129  :         context = L"System\\GDI\\Drivers";

  00030	059f5030	 ldreq       r5, [pc, #0x30]

; 130  :     }
; 131  :     
; 132  :     if (pGPE == NULL || !pGPE->Init(context))

  00034	e3540000	 cmp         r4, #0
  00038	0a000006	 beq         |$cleanUp$41716|
  0003c	e1a01005	 mov         r1, r5
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          |?Init@OMAP2420GPE@@QAAHPBG@Z|
  00048	e3500000	 cmp         r0, #0

; 133  :     {
; 134  :         DEBUGMSG(GPE_ZONE_ERROR, (L"ERROR: DisplayInit: "
; 135  :             L"Failed create and initialize OMAP2420GPE object\r\n"
; 136  :         ));
; 137  :         goto cleanUp;
; 138  :     }
; 139  : 
; 140  :     // Save instance to global variable
; 141  :     g_pGPE = pGPE;

  0004c	159f3010	 ldrne       r3, [pc, #0x10]

; 142  : 
; 143  :     // Done
; 144  :     rc = TRUE;

  00050	13a06001	 movne       r6, #1
  00054	15834000	 strne       r4, [r3]
  00058		 |$cleanUp$41716|

; 145  : 
; 146  : cleanUp:
; 147  :     DEBUGMSG(GPE_ZONE_PDD, (L"-DisplayInit(rc = %d)\r\n", rc));
; 148  :     return rc;
; 149  : }

  00058	e1a00006	 mov         r0, r6
  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN12@DisplayIni|
  00064		 |$LN13@DisplayIni|
  00064	00000000	 DCD         |g_pGPE|
  00068		 |$LN14@DisplayIni|
  00068	00000000	 DCD         |??_C@_1CG@BEPCNIEH@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?2?$AAG?$AAD?$AAI?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AAs?$AA?$AA@|
  0006c		 |$M43766|

			 ENDP  ; |DisplayInit|

	END
