; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\WAVEDEV\dma.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??0OMAP2420DMAContext@@QAA@XZ|		; OMAP2420DMAContext::OMAP2420DMAContext
	EXPORT	|??_7OMAP2420DMAContext@@6B@| [ DATA ]	; OMAP2420DMAContext::`vftable'
	EXPORT	|?HWMapDMAMemory@OMAP2420DMAContext@@UAAHK@Z| ; OMAP2420DMAContext::HWMapDMAMemory
	EXPORT	|?HWInitInputDMA@OMAP2420DMAContext@@UAAXXZ| ; OMAP2420DMAContext::HWInitInputDMA
	EXPORT	|?HWInitOutputDMA@OMAP2420DMAContext@@UAAXXZ| ; OMAP2420DMAContext::HWInitOutputDMA
	EXPORT	|?HWStartOutputDMA@OMAP2420DMAContext@@UAAXXZ| ; OMAP2420DMAContext::HWStartOutputDMA
	EXPORT	|?HWStopOutputDMA@OMAP2420DMAContext@@UAAXXZ| ; OMAP2420DMAContext::HWStopOutputDMA
	EXPORT	|?HWStartInputDMA@OMAP2420DMAContext@@UAAXXZ| ; OMAP2420DMAContext::HWStartInputDMA
	EXPORT	|?HWStopInputDMA@OMAP2420DMAContext@@UAAXXZ| ; OMAP2420DMAContext::HWStopInputDMA
	EXPORT	|?HWTransferInputBuffers@OMAP2420DMAContext@@UAAKXZ| ; OMAP2420DMAContext::HWTransferInputBuffers
	EXPORT	|?HWTransferOutputBuffers@OMAP2420DMAContext@@UAAKXZ| ; OMAP2420DMAContext::HWTransferOutputBuffers
	EXPORT	|?HWDMAMemoryIn@OMAP2420DMAContext@@UAAPAEXZ| ; OMAP2420DMAContext::HWDMAMemoryIn
	EXPORT	|?HWDMAMemoryOut@OMAP2420DMAContext@@UAAPAEXZ| ; OMAP2420DMAContext::HWDMAMemoryOut
	IMPORT	|??0HardwareContext@@QAA@XZ|		; HardwareContext::HardwareContext
	IMPORT	|??_EOMAP2420DMAContext@@UAAPAXI@Z|, WEAK |??_GOMAP2420DMAContext@@UAAPAXI@Z| ; OMAP2420DMAContext::`vector deleting destructor', OMAP2420DMAContext::`scalar deleting destructor'
	IMPORT	|_purecall|
	IMPORT	|?SetupDelayUpdate@HardwareContext@@MAAXXZ| ; HardwareContext::SetupDelayUpdate
	IMPORT	|?DelayedUpdate@HardwareContext@@MAAXXZ| ; HardwareContext::DelayedUpdate
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\dma.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37693| DCD	|$LN5@OMAP2420DM|
	DCD	0x40001101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAP2420DMAContext@@6B@| DCD |??_EOMAP2420DMAContext@@UAAPAXI@Z| ; OMAP2420DMAContext::`vftable'
	DCD	|?HWMapDMAMemory@OMAP2420DMAContext@@UAAHK@Z|
	DCD	|?HWInitInputDMA@OMAP2420DMAContext@@UAAXXZ|
	DCD	|?HWInitOutputDMA@OMAP2420DMAContext@@UAAXXZ|
	DCD	|?HWStartOutputDMA@OMAP2420DMAContext@@UAAXXZ|
	DCD	|?HWStopOutputDMA@OMAP2420DMAContext@@UAAXXZ|
	DCD	|?HWStartInputDMA@OMAP2420DMAContext@@UAAXXZ|
	DCD	|?HWStopInputDMA@OMAP2420DMAContext@@UAAXXZ|
	DCD	|?HWTransferInputBuffers@OMAP2420DMAContext@@UAAKXZ|
	DCD	|?HWTransferOutputBuffers@OMAP2420DMAContext@@UAAKXZ|
	DCD	|?HWDMAMemoryIn@OMAP2420DMAContext@@UAAPAEXZ|
	DCD	|?HWDMAMemoryOut@OMAP2420DMAContext@@UAAPAEXZ|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?SetupDelayUpdate@HardwareContext@@MAAXXZ|
	DCD	|?DelayedUpdate@HardwareContext@@MAAXXZ|
	DCD	|_purecall|
	DCD	|_purecall|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAP2420DMAContext@@QAA@XZ| PROC	; OMAP2420DMAContext::OMAP2420DMAContext

; 44   : {

  00000		 |$LN5@OMAP2420DM|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37690|
  00004	e1a04000	 mov         r4, r0
  00008	eb000000	 bl          |??0HardwareContext@@QAA@XZ|
  0000c	e59f302c	 ldr         r3, [pc, #0x2C]

; 45   :     m_hCont = NULL;

  00010	e3a02000	 mov         r2, #0
  00014	e58420ec	 str         r2, [r4, #0xEC]
  00018	e5843000	 str         r3, [r4]

; 46   :     m_pInDMAReg = NULL;

  0001c	e58420f0	 str         r2, [r4, #0xF0]

; 47   :     m_pOutDMAReg = NULL;

  00020	e58420f4	 str         r2, [r4, #0xF4]

; 48   :     m_paAudioDMA.LowPart = 0;

  00024	e58420f8	 str         r2, [r4, #0xF8]

; 49   :     m_paAudioDMA.HighPart = 0;

  00028	e58420fc	 str         r2, [r4, #0xFC]

; 50   :     m_pbDMABufOut=NULL;

  0002c	e5842104	 str         r2, [r4, #0x104]

; 51   :     m_pbDMABufIn=NULL;

  00030	e5842100	 str         r2, [r4, #0x100]

; 52   : }

  00034	e1a00004	 mov         r0, r4
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN6@OMAP2420DM|
  00040		 |$LN7@OMAP2420DM|
  00040	00000000	 DCD         |??_7OMAP2420DMAContext@@6B@|
  00044		 |$M37691|

			 ENDP  ; |??0OMAP2420DMAContext@@QAA@XZ|, OMAP2420DMAContext::OMAP2420DMAContext

; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\dmactxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37705| DCD	|$LN5@HWDMAMemor|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWDMAMemoryIn@OMAP2420DMAContext@@UAAPAEXZ| PROC ; OMAP2420DMAContext::HWDMAMemoryIn

; 58   :     PBYTE HWDMAMemoryIn( void ) { return m_pbDMABufIn;  }

  00000		 |$LN5@HWDMAMemor|
  00000		 |$M37702|
  00000	e5900100	 ldr         r0, [r0, #0x100]
  00004	e12fff1e	 bx          lr
  00008		 |$M37703|

			 ENDP  ; |?HWDMAMemoryIn@OMAP2420DMAContext@@UAAPAEXZ|, OMAP2420DMAContext::HWDMAMemoryIn


  00000			 AREA	 |.pdata|, PDATA
|$T37715| DCD	|$LN5@HWDMAMemor@2|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWDMAMemoryOut@OMAP2420DMAContext@@UAAPAEXZ| PROC ; OMAP2420DMAContext::HWDMAMemoryOut

; 59   :     PBYTE HWDMAMemoryOut( void ){ return m_pbDMABufOut; }

  00000		 |$LN5@HWDMAMemor@2|
  00000		 |$M37712|
  00000	e5900104	 ldr         r0, [r0, #0x104]
  00004	e12fff1e	 bx          lr
  00008		 |$M37713|

			 ENDP  ; |?HWDMAMemoryOut@OMAP2420DMAContext@@UAAPAEXZ|, OMAP2420DMAContext::HWDMAMemoryOut

	EXPORT	|??1OMAP2420DMAContext@@UAA@XZ|		; OMAP2420DMAContext::~OMAP2420DMAContext
	IMPORT	|??1HardwareContext@@UAA@XZ|		; HardwareContext::~HardwareContext

  00000			 AREA	 |.pdata|, PDATA
|$T37723| DCD	|$LN5@OMAP2420DM@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAP2420DMAContext@@UAA@XZ| PROC	; OMAP2420DMAContext::~OMAP2420DMAContext
  00000		 |$LN5@OMAP2420DM@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37720|
  00004	eb000000	 bl          |??1HardwareContext@@UAA@XZ|
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M37721|

			 ENDP  ; |??1OMAP2420DMAContext@@UAA@XZ|, OMAP2420DMAContext::~OMAP2420DMAContext

	EXPORT	|??_C@_06JIODDOFH@System?$AA@| [ DATA ]	; `string'
	IMPORT	|HalAllocateCommonBuffer|
	IMPORT	|MmMapIoSpace|
	IMPORT	|_stricmp|
	IMPORT	|free|
	IMPORT	|malloc|
	IMPORT	|__imp_DMA_ControllerSet|
	IMPORT	|__imp_DMA_ControllerClose|
	IMPORT	|__imp_DMA_ControllerAcquireChannels|
	IMPORT	|__imp_DMA_ControllerOpen|
	IMPORT	|__imp_DMA_ControllerEnum|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\dma.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T37747| DCD	|$LN30@HWMapDMAMe|
	DCD	0x4000a002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_06JIODDOFH@System?$AA@| DCB "System", 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWMapDMAMemory@OMAP2420DMAContext@@UAAHK@Z| PROC ; OMAP2420DMAContext::HWMapDMAMemory

; 65   : {

  00000		 |$LN30@HWMapDMAMe|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M37744|
  00008	e1a09001	 mov         r9, r1
  0000c	e1a05000	 mov         r5, r0

; 66   :     PBYTE pbDMATemp;
; 67   :     PHYSICAL_ADDRESS pa;
; 68   : 
; 69   :     /* find the system dma controller */
; 70   :     uint bytesToAlloc = 0;
; 71   :     uint err = DMA_ControllerEnum(NULL,&bytesToAlloc);

  00010	e59f3264	 ldr         r3, [pc, #0x264]
  00014	e3a02000	 mov         r2, #0
  00018	e28d1000	 add         r1, sp, #0
  0001c	e5933000	 ldr         r3, [r3]
  00020	e3a00000	 mov         r0, #0
  00024	e58d2000	 str         r2, [sp]
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff13	 bx          r3
  00030	e3a03106	 mov         r3, #6, 2

; 72   :     if (err!=DMAERR_NOTENOUGHSPACE)

  00034	e3833847	 orr         r3, r3, #0x47, 16
  00038	e1530000	 cmp         r3, r0

; 73   :     {
; 74   :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 75   :             L"Could not get size of enumeration of platform dma controllers.\r\n"
; 76   :         ));
; 77   :         return FALSE;

  0003c	1a000084	 bne         |$LN1@HWMapDMAMe|

; 78   :     }
; 79   :     DMACONTROLLER *pContList = (DMACONTROLLER *)malloc(bytesToAlloc);

  00040	e59d0000	 ldr         r0, [sp]
  00044	eb000000	 bl          malloc
  00048	e1b06000	 movs        r6, r0

; 80   :     if (pContList == NULL)
; 81   :     {
; 82   :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 83   :             L"Could not malloc dma controllers.\r\n"
; 84   :         ));
; 85   :         return FALSE;

  0004c	0a000080	 beq         |$LN1@HWMapDMAMe|

; 86   :     }
; 87   :     err = DMA_ControllerEnum(pContList,&bytesToAlloc);

  00050	e59f3224	 ldr         r3, [pc, #0x224]
  00054	e28d1000	 add         r1, sp, #0
  00058	e1a00006	 mov         r0, r6
  0005c	e5933000	 ldr         r3, [r3]
  00060	e1a0e00f	 mov         lr, pc
  00064	e12fff13	 bx          r3
  00068	e3500000	 cmp         r0, #0

; 88   :     if (err)

  0006c	0a000002	 beq         |$LN18@HWMapDMAMe|

; 89   :     {
; 90   :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 91   :             L"Could not enumerate platform dma controllers.\r\n"
; 92   :         ));
; 93   :         free(pContList);

  00070	e1a00006	 mov         r0, r6
  00074		 |$LN27@HWMapDMAMe|
  00074	eb000000	 bl          free

; 94   :         return FALSE;

  00078	ea000075	 b           |$LN1@HWMapDMAMe|
  0007c		 |$LN18@HWMapDMAMe|

; 95   :     }
; 96   :     /* find the system dma controller */
; 97   :     uint numEntries = bytesToAlloc/sizeof(DMACONTROLLER);

  0007c	e59f31f4	 ldr         r3, [pc, #0x1F4]
  00080	e59d1000	 ldr         r1, [sp]

; 98   :     uint i;
; 99   :     for(i=0;i<numEntries;i++)

  00084	e3a04000	 mov         r4, #0
  00088	e0823391	 umull       r3, r2, r1, r3
  0008c	e1b081a2	 movs        r8, r2, lsr #3
  00090	0a000009	 beq         |$LN26@HWMapDMAMe|
  00094	e2867004	 add         r7, r6, #4
  00098		 |$LL17@HWMapDMAMe|

; 100  :     {
; 101  :         if (!_stricmp(pContList[i].mName,"System"))

  00098	e59f11d4	 ldr         r1, [pc, #0x1D4]
  0009c	e1a00007	 mov         r0, r7
  000a0	eb000000	 bl          _stricmp
  000a4	e3500000	 cmp         r0, #0
  000a8	0a000003	 beq         |$LN26@HWMapDMAMe|
  000ac	e2844001	 add         r4, r4, #1
  000b0	e1540008	 cmp         r4, r8
  000b4	e2877024	 add         r7, r7, #0x24
  000b8	3afffff6	 bcc         |$LL17@HWMapDMAMe|
  000bc		 |$LN26@HWMapDMAMe|

; 102  :             break;
; 103  :     }
; 104  :     if (i==numEntries)

  000bc	e1540008	 cmp         r4, r8

; 105  :     {
; 106  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 107  :             L"Could not find \"System\" dma controller.\r\n"
; 108  :         ));
; 109  :         free(pContList);

  000c0	e1a00006	 mov         r0, r6

; 110  :         return FALSE;

  000c4	0affffea	 beq         |$LN27@HWMapDMAMe|

; 111  :     }
; 112  :     uint controllerId = pContList[i].mSysId;

  000c8	e0843184	 add         r3, r4, r4, lsl #3
  000cc	e7964103	 ldr         r4, [r6, +r3, lsl #2]

; 113  :     free(pContList);

  000d0	eb000000	 bl          free

; 114  : 
; 115  :     /* open the controller now */
; 116  :     err = DMA_ControllerOpen(controllerId, &m_hCont);

  000d4	e59f3194	 ldr         r3, [pc, #0x194]
  000d8	e28510ec	 add         r1, r5, #0xEC
  000dc	e1a00004	 mov         r0, r4
  000e0	e5933000	 ldr         r3, [r3]
  000e4	e1a0e00f	 mov         lr, pc
  000e8	e12fff13	 bx          r3
  000ec	e3500000	 cmp         r0, #0

; 117  :     if (err)
; 118  :     {
; 119  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 120  :             L"Could not open \"System\" dma controller.\r\n"
; 121  :         ));
; 122  :         return FALSE;

  000f0	1a000057	 bne         |$LN1@HWMapDMAMe|

; 123  :     }
; 124  : 
; 125  :     /* we need to allocate our input and output channels */
; 126  :     uint chanIO = (1<<AUDIO_INPUT_DMA_CHANNEL) | (1<<AUDIO_OUTPUT_DMA_CHANNEL);
; 127  :     err = DMA_ControllerAcquireChannels(m_hCont, 2, &chanIO);

  000f4	e59f3170	 ldr         r3, [pc, #0x170]
  000f8	e59500ec	 ldr         r0, [r5, #0xEC]
  000fc	e3a0400c	 mov         r4, #0xC
  00100	e5933000	 ldr         r3, [r3]
  00104	e28d2004	 add         r2, sp, #4
  00108	e3a01002	 mov         r1, #2
  0010c	e58d4004	 str         r4, [sp, #4]
  00110	e1a0e00f	 mov         lr, pc
  00114	e12fff13	 bx          r3
  00118	e3500000	 cmp         r0, #0

; 128  :     if (err)

  0011c	0a000007	 beq         |$LN11@HWMapDMAMe|

; 129  :     {
; 130  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 131  :             L"Could not acquire audio i/o channels\r\n"
; 132  :         ));
; 133  :         DMA_ControllerClose(m_hCont);

  00120	e59f313c	 ldr         r3, [pc, #0x13C]
  00124	e59500ec	 ldr         r0, [r5, #0xEC]
  00128	e5933000	 ldr         r3, [r3]
  0012c	e1a0e00f	 mov         lr, pc
  00130	e12fff13	 bx          r3

; 134  :         m_hCont = NULL;

  00134	e3a03000	 mov         r3, #0
  00138	e58530ec	 str         r3, [r5, #0xEC]

; 135  :         return FALSE;

  0013c	ea000044	 b           |$LN1@HWMapDMAMe|
  00140		 |$LN11@HWMapDMAMe|
  00140	e3a03312	 mov         r3, #0x12, 6

; 136  :     }
; 137  : 
; 138  :     /* if we get here, then we have ownership of the two dma channels we need */
; 139  : 
; 140  :     // map DMA registers into driver address space
; 141  :     pa.HighPart= 0;
; 142  :     pa.LowPart = OMAP2420_SDMA_REGS_PA;

  00144	e3830a56	 orr         r0, r3, #0x56, 20

; 143  :     volatile OMAP2420_SDMA_REGS *pDMA_Regs = (OMAP2420_SDMA_REGS *)MmMapIoSpace(pa, sizeof(OMAP2420_SDMA_REGS), FALSE);

  00148	e3a03000	 mov         r3, #0
  0014c	e3a01000	 mov         r1, #0
  00150	e3a02d32	 mov         r2, #0x32, 26
  00154	eb000000	 bl          MmMapIoSpace
  00158	e1b04000	 movs        r4, r0
  0015c	e3a06000	 mov         r6, #0

; 144  :     if (!pDMA_Regs)

  00160	0a00002f	 beq         |$ErrExit$37339|

; 145  :     {
; 146  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 147  :             L"ERROR mapping DMA registers.\n"
; 148  :         ));
; 149  :         goto ErrExit;
; 150  :     }
; 151  : 
; 152  :     // enable input DMA IRQ
; 153  :     err = DMA_ControllerSet(m_hCont, DMACP_L3IntEnb, 1<< AUDIO_INPUT_DMA_CHANNEL);

  00164	e59f30fc	 ldr         r3, [pc, #0xFC]
  00168	e59500ec	 ldr         r0, [r5, #0xEC]
  0016c	e3a02008	 mov         r2, #8
  00170	e5933000	 ldr         r3, [r3]
  00174	e3a01001	 mov         r1, #1
  00178	e1a0e00f	 mov         lr, pc
  0017c	e12fff13	 bx          r3
  00180	e3500000	 cmp         r0, #0

; 154  :     if (err)

  00184	1a000026	 bne         |$ErrExit$37339|

; 155  :     {
; 156  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 157  :             L"ERROR setting IRQ for L3 input dma channel.\r\n"
; 158  :         ));
; 159  :         goto ErrExit;
; 160  :     }
; 161  :     // enable output DMA IRQ
; 162  :     err = DMA_ControllerSet(m_hCont, DMACP_L2IntEnb, 1<< AUDIO_OUTPUT_DMA_CHANNEL);

  00188	e59f30d8	 ldr         r3, [pc, #0xD8]
  0018c	e59500ec	 ldr         r0, [r5, #0xEC]
  00190	e3a02004	 mov         r2, #4
  00194	e5933000	 ldr         r3, [r3]
  00198	e3a01004	 mov         r1, #4
  0019c	e1a0e00f	 mov         lr, pc
  001a0	e12fff13	 bx          r3
  001a4	e3500000	 cmp         r0, #0

; 163  :     if (err)

  001a8	1a00001d	 bne         |$ErrExit$37339|

; 164  :     {
; 165  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 166  :             L"ERROR setting IRQ for L2 output dma channel.\r\n"
; 167  :         ));
; 168  :         goto ErrExit;        
; 169  :     }
; 170  : 
; 171  :     // get the channel register pointers
; 172  :     m_pInDMAReg  = &pDMA_Regs->CHNL_CTRL[AUDIO_INPUT_DMA_CHANNEL];

  001ac	e2843e1a	 add         r3, r4, #0x1A, 28

; 173  :     m_pOutDMAReg = &pDMA_Regs->CHNL_CTRL[AUDIO_OUTPUT_DMA_CHANNEL];

  001b0	e2842d05	 add         r2, r4, #5, 26

; 174  : 
; 175  :     // allocate the DMA pages
; 176  :     DMA_ADAPTER_OBJECT AdapterObject; 
; 177  :     AdapterObject.ObjectSize = sizeof(AdapterObject); 

  001b4	e3a0100c	 mov         r1, #0xC

; 178  :     AdapterObject.InterfaceType = Internal; 

  001b8	e3a00000	 mov         r0, #0

; 179  :     AdapterObject.BusNumber = 0; 

  001bc	e58530f0	 str         r3, [r5, #0xF0]
  001c0	e58520f4	 str         r2, [r5, #0xF4]
  001c4	e1cd10b8	 strh        r1, [sp, #8]
  001c8	e58d000c	 str         r0, [sp, #0xC]
  001cc	e3a0e000	 mov         lr, #0

; 180  :     m_pbDMABufOut = NULL;
; 181  : 
; 182  :     pbDMATemp = (PBYTE)HalAllocateCommonBuffer(&AdapterObject, dwSize, &m_paAudioDMA, FALSE);

  001d0	e3a03000	 mov         r3, #0
  001d4	e28520f8	 add         r2, r5, #0xF8
  001d8	e1a01009	 mov         r1, r9
  001dc	e28d0008	 add         r0, sp, #8
  001e0	e58de010	 str         lr, [sp, #0x10]
  001e4	e5856104	 str         r6, [r5, #0x104]
  001e8	eb000000	 bl          HalAllocateCommonBuffer
  001ec	e1b04000	 movs        r4, r0

; 183  :     if (!pbDMATemp)

  001f0	0a00000b	 beq         |$ErrExit$37339|

; 184  :     {
; 185  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 186  :             L"ERROR mapping DMA memory.\n"
; 187  :         ));
; 188  :         goto ErrExit;
; 189  :     }
; 190  : 
; 191  :     m_pbDMABufOut = m_pbDMABufIn = pbDMATemp;
; 192  : 
; 193  : #ifdef MIXER_CACHEDMEM
; 194  :     // Map DMA buffer also to cached memory for DMA out
; 195  :     // Mixer will call cache flush after block is completed
; 196  :     m_pbDMABufOut = (PBYTE)MmMapIoSpace(m_paAudioDMA, dwSize, TRUE);

  001f4	e59500f8	 ldr         r0, [r5, #0xF8]
  001f8	e59510fc	 ldr         r1, [r5, #0xFC]
  001fc	e3a03001	 mov         r3, #1
  00200	e1a02009	 mov         r2, r9
  00204	e5854100	 str         r4, [r5, #0x100]
  00208	e5854104	 str         r4, [r5, #0x104]
  0020c	eb000000	 bl          MmMapIoSpace
  00210	e3500000	 cmp         r0, #0
  00214	e5850104	 str         r0, [r5, #0x104]

; 197  :     if (!m_pbDMABufOut)
; 198  :     {
; 199  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWMapDMAMemory: "
; 200  :             L"ERROR mapping DMA buffer to cached memory, using uncached.\n"
; 201  :         ));
; 202  :         m_pbDMABufOut = pbDMATemp;

  00218	05854104	 streq       r4, [r5, #0x104]

; 203  :     }
; 204  : #endif
; 205  : 
; 206  :     return TRUE;

  0021c	e3a00001	 mov         r0, #1
  00220	ea00000c	 b           |$LN21@HWMapDMAMe|
  00224		 |$ErrExit$37339|

; 207  : 
; 208  : ErrExit:
; 209  : 
; 210  :     m_pInDMAReg  =NULL;
; 211  :     m_pOutDMAReg =NULL;
; 212  :     m_pbDMABufOut=NULL;
; 213  :     m_pbDMABufIn =NULL;
; 214  : 
; 215  :     if (m_hCont)

  00224	e59530ec	 ldr         r3, [r5, #0xEC]
  00228	e58560f0	 str         r6, [r5, #0xF0]
  0022c	e58560f4	 str         r6, [r5, #0xF4]
  00230	e1b00003	 movs        r0, r3
  00234	e5856104	 str         r6, [r5, #0x104]
  00238	e5856100	 str         r6, [r5, #0x100]
  0023c	0a000004	 beq         |$LN1@HWMapDMAMe|

; 216  :     {
; 217  :         DMA_ControllerClose(m_hCont);

  00240	e59f301c	 ldr         r3, [pc, #0x1C]
  00244	e5933000	 ldr         r3, [r3]
  00248	e1a0e00f	 mov         lr, pc
  0024c	e12fff13	 bx          r3

; 218  :         m_hCont = NULL;

  00250	e58560ec	 str         r6, [r5, #0xEC]
  00254		 |$LN1@HWMapDMAMe|

; 219  :     }
; 220  : 
; 221  :     return FALSE;

  00254	e3a00000	 mov         r0, #0
  00258		 |$LN21@HWMapDMAMe|

; 222  : }

  00258	e28dd014	 add         sp, sp, #0x14
  0025c	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00260	e12fff1e	 bx          lr
  00264		 |$LN31@HWMapDMAMe|
  00264		 |$LN32@HWMapDMAMe|
  00264	00000000	 DCD         |__imp_DMA_ControllerClose|
  00268		 |$LN33@HWMapDMAMe|
  00268	00000000	 DCD         |__imp_DMA_ControllerSet|
  0026c		 |$LN34@HWMapDMAMe|
  0026c	00000000	 DCD         |__imp_DMA_ControllerAcquireChannels|
  00270		 |$LN35@HWMapDMAMe|
  00270	00000000	 DCD         |__imp_DMA_ControllerOpen|
  00274		 |$LN36@HWMapDMAMe|
  00274	00000000	 DCD         |??_C@_06JIODDOFH@System?$AA@|
  00278		 |$LN37@HWMapDMAMe|
  00278	38e38e39	 DCD         0x38e38e39
  0027c		 |$LN38@HWMapDMAMe|
  0027c	00000000	 DCD         |__imp_DMA_ControllerEnum|
  00280		 |$M37745|

			 ENDP  ; |?HWMapDMAMemory@OMAP2420DMAContext@@UAAHK@Z|, OMAP2420DMAContext::HWMapDMAMemory


  00000			 AREA	 |.pdata|, PDATA
|$T37764| DCD	|$LN5@HWInitInpu|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWInitInputDMA@OMAP2420DMAContext@@UAAXXZ| PROC ; OMAP2420DMAContext::HWInitInputDMA

; 280  : {

  00000		 |$LN5@HWInitInpu|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37761|

; 281  :     OMAP2420_DMA_REGS  *pDMAReg;
; 282  :     DWORD   dwAddr, dwVal;
; 283  : 
; 284  :     DEBUGMSG(ZONE_FUNCTION, (L"+OMAP2420DMAContext::HWInitInputDMA()\r\n"));
; 285  : 
; 286  :     pDMAReg = m_pInDMAReg;

  00004	e59010f0	 ldr         r1, [r0, #0xF0]

; 287  : 
; 288  :     // disable the channel, clear the configuration
; 289  :     SETREG32(&pDMAReg->DMA4_CCR, 0);
; 290  : 
; 291  :     // link this channel to itself to get continuous operation
; 292  :     OUTREG32(&pDMAReg->DMA4_CLNK_CTRL, AUDIO_INPUT_DMA_CHANNEL);

  00008	e3a0e003	 mov         lr, #3

; 293  : 
; 294  :     // 16 bits scalar, no pack, no burst
; 295  :     OUTREG32(&pDMAReg->DMA4_CSDP, DMA_CSDP_DATATYPE_16BIT);
; 296  : 
; 297  :     // request number, post incremented destination address, high priority
; 298  :     dwVal = DMA_CCR_SYNC(AUDIO_INPUT_DMA_REQ) | DMA_CCR_DST_AMODE_POST_INC | DMA_CCR_PRIO;
; 299  :     OUTREG32(&pDMAReg->DMA4_CCR, dwVal);
; 300  : 
; 301  :     // source address
; 302  :     OUTREG32(&pDMAReg->DMA4_CSSA, AUDIO_INPUT_DMA_SOURCE);

  0000c	e59f205c	 ldr         r2, [pc, #0x5C]
  00010	e5913000	 ldr         r3, [r1]
  00014	e3a04921	 mov         r4, #0x21, 18
  00018	e5813000	 str         r3, [r1]
  0001c	e581e004	 str         lr, [r1, #4]
  00020	e3a0e001	 mov         lr, #1
  00024	e3843042	 orr         r3, r4, #0x42
  00028	e581e010	 str         lr, [r1, #0x10]
  0002c	e5813000	 str         r3, [r1]
  00030	e581201c	 str         r2, [r1, #0x1C]

; 303  : 
; 304  :     // destination address
; 305  :     dwAddr = m_paAudioDMA.LowPart + AUDIO_DMA_PAGES * AUDIO_DMA_PAGE_SIZE;      

  00034	e59030f8	 ldr         r3, [r0, #0xF8]

; 306  :     OUTREG32(&pDMAReg->DMA4_CDSA, dwAddr);
; 307  : 
; 308  :     // interrupt conditions
; 309  :     dwVal = DMA_CICR_FRAME_IE | DMA_CICR_HALF_IE | DMA_CICR_DROP_IE;
; 310  :     OUTREG32(&pDMAReg->DMA4_CICR, dwVal);

  00038	e2833901	 add         r3, r3, #1, 18
  0003c	e5813020	 str         r3, [r1, #0x20]
  00040	e3a0300e	 mov         r3, #0xE
  00044	e5813008	 str         r3, [r1, #8]

; 311  : 
; 312  :     // number of samples per frame
; 313  :     OUTREG32(&pDMAReg->DMA4_CEN, AUDIO_DMA_PAGE_SIZE);

  00048	e3a03a02	 mov         r3, #2, 20
  0004c	e5813014	 str         r3, [r1, #0x14]

; 314  : 
; 315  :     // number of frames per block
; 316  :     OUTREG32(&pDMAReg->DMA4_CFN, 1);
; 317  : 
; 318  :     // source frame index and element index
; 319  :     OUTREG32(&pDMAReg->DMA4_CSFI, 0);

  00050	e3a03000	 mov         r3, #0
  00054	e581e018	 str         lr, [r1, #0x18]
  00058	e5813028	 str         r3, [r1, #0x28]

; 320  :     OUTREG32(&pDMAReg->DMA4_CSEI, 0);

  0005c	e5813024	 str         r3, [r1, #0x24]

; 321  : 
; 322  :     // destination frame index and element index
; 323  :     OUTREG32(&pDMAReg->DMA4_CDFI, 0);

  00060	e5813030	 str         r3, [r1, #0x30]

; 324  :     OUTREG32(&pDMAReg->DMA4_CDEI, 0);

  00064	e581302c	 str         r3, [r1, #0x2C]

; 325  : 
; 326  : #if defined(DEBUG)
; 327  :     DumpDMA_LC(L"Init Input", pDMAReg);
; 328  : #endif
; 329  : 
; 330  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::HWInitInputDMA()\r\n"));
; 331  : }

  00068	e8bd4010	 ldmia       sp!, {r4, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN6@HWInitInpu|
  00070		 |$LN7@HWInitInpu|
  00070	48076004	 DCD         0x48076004
  00074		 |$M37762|

			 ENDP  ; |?HWInitInputDMA@OMAP2420DMAContext@@UAAXXZ|, OMAP2420DMAContext::HWInitInputDMA


  00000			 AREA	 |.pdata|, PDATA
|$T37775| DCD	|$LN5@HWInitOutp|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWInitOutputDMA@OMAP2420DMAContext@@UAAXXZ| PROC ; OMAP2420DMAContext::HWInitOutputDMA

; 342  : {

  00000		 |$LN5@HWInitOutp|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37772|

; 343  :     OMAP2420_DMA_REGS  *pDMAReg;
; 344  :     DWORD   dwAddr, dwVal;
; 345  : 
; 346  :     DEBUGMSG(ZONE_FUNCTION, (L"+OMAP2420DMAContext::HWInitOutputDMA()\r\n"));
; 347  : 
; 348  :     pDMAReg = m_pOutDMAReg;

  00004	e59010f4	 ldr         r1, [r0, #0xF4]

; 349  : 
; 350  :     // disable the channel, clear the configuration
; 351  :     SETREG32(&pDMAReg->DMA4_CCR, 0);
; 352  : 
; 353  :     // link this channel to itself to get continuous operation
; 354  :     OUTREG32(&pDMAReg->DMA4_CLNK_CTRL, AUDIO_OUTPUT_DMA_CHANNEL);

  00008	e3a02002	 mov         r2, #2
  0000c	e3a0ea81	 mov         lr, #0x81, 20
  00010	e5913000	 ldr         r3, [r1]

; 355  : 
; 356  :     // 16 bits scalar, no pack, no burst
; 357  :     OUTREG32(&pDMAReg->DMA4_CSDP, DMA_CSDP_DATATYPE_16BIT);

  00014	e3a04001	 mov         r4, #1
  00018	e5813000	 str         r3, [r1]
  0001c	e5812004	 str         r2, [r1, #4]

; 358  : 
; 359  :     // request number, post incremented source address, high priority
; 360  :     dwVal = DMA_CCR_SYNC(AUDIO_OUTPUT_DMA_REQ) | DMA_CCR_SRC_AMODE_POST_INC | DMA_CCR_PRIO;
; 361  :     OUTREG32(&pDMAReg->DMA4_CCR, dwVal);

  00020	e38e3041	 orr         r3, lr, #0x41
  00024	e5814010	 str         r4, [r1, #0x10]
  00028	e5813000	 str         r3, [r1]

; 362  : 
; 363  :     // source address
; 364  :     dwAddr = m_paAudioDMA.LowPart;     

  0002c	e59030f8	 ldr         r3, [r0, #0xF8]

; 365  :     OUTREG32(&pDMAReg->DMA4_CSSA, dwAddr);
; 366  : 
; 367  :     // destination address
; 368  :     OUTREG32(&pDMAReg->DMA4_CDSA, AUDIO_OUTPUT_DMA_DEST);

  00030	e59f2034	 ldr         r2, [pc, #0x34]
  00034	e581301c	 str         r3, [r1, #0x1C]

; 369  : 
; 370  :     // interrupt conditions
; 371  :     dwVal = DMA_CICR_FRAME_IE | DMA_CICR_HALF_IE | DMA_CICR_DROP_IE;
; 372  :     OUTREG32(&pDMAReg->DMA4_CICR, dwVal);

  00038	e3a0300e	 mov         r3, #0xE
  0003c	e5812020	 str         r2, [r1, #0x20]
  00040	e5813008	 str         r3, [r1, #8]

; 373  : 
; 374  :     // number of samples per frame
; 375  :     OUTREG32(&pDMAReg->DMA4_CEN, AUDIO_DMA_PAGE_SIZE);

  00044	e3a03a02	 mov         r3, #2, 20
  00048	e5813014	 str         r3, [r1, #0x14]

; 376  : 
; 377  :     // number of frames per block
; 378  :     OUTREG32(&pDMAReg->DMA4_CFN, 1);
; 379  : 
; 380  :     // source frame index and element index
; 381  :     OUTREG32(&pDMAReg->DMA4_CSFI, 0);

  0004c	e3a03000	 mov         r3, #0
  00050	e5814018	 str         r4, [r1, #0x18]
  00054	e5813028	 str         r3, [r1, #0x28]

; 382  :     OUTREG32(&pDMAReg->DMA4_CSEI, 0);

  00058	e5813024	 str         r3, [r1, #0x24]

; 383  : 
; 384  :     // destination frame index and element index
; 385  :     OUTREG32(&pDMAReg->DMA4_CDFI, 0);

  0005c	e5813030	 str         r3, [r1, #0x30]

; 386  :     OUTREG32(&pDMAReg->DMA4_CDEI, 0);

  00060	e581302c	 str         r3, [r1, #0x2C]

; 387  : 
; 388  : #if defined(DEBUG)
; 389  :     DumpDMA_LC(L"Init Output", pDMAReg);
; 390  : #endif
; 391  : 
; 392  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::WInitOutputDMA()\r\n"));
; 393  : }

  00064	e8bd4010	 ldmia       sp!, {r4, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN6@HWInitOutp|
  0006c		 |$LN7@HWInitOutp|
  0006c	4807600c	 DCD         0x4807600c
  00070		 |$M37773|

			 ENDP  ; |?HWInitOutputDMA@OMAP2420DMAContext@@UAAXXZ|, OMAP2420DMAContext::HWInitOutputDMA


  00000			 AREA	 |.pdata|, PDATA
|$T37786| DCD	|$LN5@HWStartInp|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWStartInputDMA@OMAP2420DMAContext@@UAAXXZ| PROC ; OMAP2420DMAContext::HWStartInputDMA

; 404  : {

  00000		 |$LN5@HWStartInp|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37783|
  00004	e1a04000	 mov         r4, r0

; 405  :     OMAP2420_DMA_REGS  *pDMAReg;
; 406  : 
; 407  :     DEBUGMSG(ZONE_FUNCTION, (L"OMAP2420DMAContext::HWStartInputDMA()\r\n"));
; 408  : 
; 409  :     pDMAReg = m_pInDMAReg;

  00008	e59420f0	 ldr         r2, [r4, #0xF0]

; 410  : 
; 411  : #ifdef PROFILE_MIXER
; 412  :     GetInputDeviceContext(0)->StartMixerProfiler();
; 413  : #endif
; 414  : 
; 415  :     // enable the channel
; 416  :     SETREG32(&pDMAReg->DMA4_CLNK_CTRL, DMA_CLNK_CTRL_ENABLE_LINK);
; 417  :     SETREG32(&pDMAReg->DMA4_CCR, DMA_CCR_ENABLE);
; 418  : 
; 419  : #if defined(DEBUG)
; 420  :     DumpDMA_LC(L"Start Input", pDMAReg);
; 421  :     CheckDMAStatus(pDMAReg, TRUE);
; 422  : #endif
; 423  : 
; 424  :     HWEnableInputChannel(TRUE);

  0000c	e3a01001	 mov         r1, #1
  00010	e5923004	 ldr         r3, [r2, #4]
  00014	e3833902	 orr         r3, r3, #2, 18
  00018	e5823004	 str         r3, [r2, #4]
  0001c	e5923000	 ldr         r3, [r2]
  00020	e3833080	 orr         r3, r3, #0x80
  00024	e5823000	 str         r3, [r2]
  00028	e5943000	 ldr         r3, [r4]
  0002c	e5933080	 ldr         r3, [r3, #0x80]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 425  : 
; 426  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::HWStartInputDMA()\r\n"));
; 427  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M37784|

			 ENDP  ; |?HWStartInputDMA@OMAP2420DMAContext@@UAAXXZ|, OMAP2420DMAContext::HWStartInputDMA

	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T37799| DCD	|$LN10@HWStopInpu|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWStopInputDMA@OMAP2420DMAContext@@UAAXXZ| PROC ; OMAP2420DMAContext::HWStopInputDMA

; 438  : {

  00000		 |$LN10@HWStopInpu|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37796|
  00004	e1a06000	 mov         r6, r0

; 439  :     OMAP2420_DMA_REGS  *pDMAReg;
; 440  :     DWORD i, dwVal;
; 441  : 
; 442  :     DEBUGMSG(ZONE_FUNCTION, (L"+OMAP2420DMAContext::HWStopInputDMA()\r\n"));
; 443  : 
; 444  :     pDMAReg = m_pInDMAReg;

  00008	e59640f0	 ldr         r4, [r6, #0xF0]

; 445  : 
; 446  :     // disable the DMA channel link and wait for reading to finish
; 447  :     CLRREG32(&pDMAReg->DMA4_CLNK_CTRL, DMA_CLNK_CTRL_ENABLE_LINK);
; 448  :     dwVal = INREG32(&pDMAReg->DMA4_CCR);
; 449  :     for (i = 0; (i < DMA_SAFETY_LOOP_NUM) && (dwVal & DMA_CCR_RD_ACTIVE); i++)

  0000c	e3a05000	 mov         r5, #0
  00010	e5943004	 ldr         r3, [r4, #4]
  00014	e3c33902	 bic         r3, r3, #2, 18
  00018	e5843004	 str         r3, [r4, #4]
  0001c	e5943000	 ldr         r3, [r4]
  00020		 |$LL3@HWStopInpu|
  00020	e3130c02	 tst         r3, #2, 24
  00024	0a000005	 beq         |$LN1@HWStopInpu|

; 450  :     {
; 451  :         Sleep(1);

  00028	e3a00001	 mov         r0, #1
  0002c	eb000000	 bl          Sleep
  00030	e2855001	 add         r5, r5, #1

; 452  :         dwVal = INREG32(&pDMAReg->DMA4_CCR);

  00034	e5943000	 ldr         r3, [r4]
  00038	e3550064	 cmp         r5, #0x64
  0003c	3afffff7	 bcc         |$LL3@HWStopInpu|
  00040		 |$LN1@HWStopInpu|

; 453  :     }
; 454  : 
; 455  :     // disable DMA on the channel
; 456  :     CLRREG32(&pDMAReg->DMA4_CCR, DMA_CCR_ENABLE);

  00040	e5943000	 ldr         r3, [r4]

; 457  : 
; 458  :     // clear pending interrupts
; 459  :     OUTREG32(&pDMAReg->DMA4_CSR, INREG32(&pDMAReg->DMA4_CSR));
; 460  :     DMA_ControllerSet(m_hCont, DMACP_L3IntAck, 1 << AUDIO_INPUT_DMA_CHANNEL);

  00044	e59fe044	 ldr         lr, [pc, #0x44]
  00048	e3a02008	 mov         r2, #8
  0004c	e3c33080	 bic         r3, r3, #0x80
  00050	e5843000	 str         r3, [r4]
  00054	e5b4300c	 ldr         r3, [r4, #0xC]!
  00058	e3a01003	 mov         r1, #3
  0005c	e5843000	 str         r3, [r4]
  00060	e59600ec	 ldr         r0, [r6, #0xEC]
  00064	e59e3000	 ldr         r3, [lr]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3

; 461  : 
; 462  :     // disable the rest of the channel
; 463  :     HWEnableInputChannel(FALSE);

  00070	e5963000	 ldr         r3, [r6]
  00074	e3a01000	 mov         r1, #0
  00078	e1a00006	 mov         r0, r6
  0007c	e5933080	 ldr         r3, [r3, #0x80]
  00080	e1a0e00f	 mov         lr, pc
  00084	e12fff13	 bx          r3

; 464  : 
; 465  : #if defined(DEBUG)
; 466  :     DumpDMA_LC(L"Stop Input", pDMAReg);
; 467  :     CheckDMAStatus(pDMAReg, FALSE);
; 468  : #endif
; 469  : 
; 470  : #ifdef PROFILE_MIXER
; 471  :     LARGE_INTEGER liTotalTime; 
; 472  :     LARGE_INTEGER liMixerTime;
; 473  : 
; 474  :     GetInputDeviceContext(0)->StopMixerProfiler(&liTotalTime,&liMixerTime);
; 475  : 
; 476  :     DEBUGMSG(ZONE_DMA, (L"OMAP2420DMAContext::HWStopInputDMA: "
; 477  :         L"Total capture time: %dms, %dms while mixing\r\n", (DWORD) (liTotalTime.QuadPart), (DWORD) (liMixerTime.QuadPart)
; 478  :     ));
; 479  : #endif
; 480  : 
; 481  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::HWStopInputDMA()\r\n"));
; 482  : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN11@HWStopInpu|
  00090		 |$LN12@HWStopInpu|
  00090	00000000	 DCD         |__imp_DMA_ControllerSet|
  00094		 |$M37797|

			 ENDP  ; |?HWStopInputDMA@OMAP2420DMAContext@@UAAXXZ|, OMAP2420DMAContext::HWStopInputDMA


  00000			 AREA	 |.pdata|, PDATA
|$T37810| DCD	|$LN5@HWStartOut|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWStartOutputDMA@OMAP2420DMAContext@@UAAXXZ| PROC ; OMAP2420DMAContext::HWStartOutputDMA

; 493  : {

  00000		 |$LN5@HWStartOut|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37807|
  00004	e1a04000	 mov         r4, r0

; 494  :     OMAP2420_DMA_REGS  *pDMAReg;
; 495  :     
; 496  :     DEBUGMSG(ZONE_FUNCTION, (L"+OMAP2420DMAContext::HWStartOutputDMA()\r\n"));
; 497  : 
; 498  : #ifdef PROFILE_MIXER
; 499  :     GetOutputDeviceContext(0)->StartMixerProfiler();
; 500  : #endif
; 501  : 
; 502  :     pDMAReg = m_pOutDMAReg;

  00008	e59420f4	 ldr         r2, [r4, #0xF4]

; 503  : 
; 504  :     // enable the channel
; 505  :     SETREG32(&pDMAReg->DMA4_CLNK_CTRL, DMA_CLNK_CTRL_ENABLE_LINK);
; 506  :     SETREG32(&pDMAReg->DMA4_CCR, DMA_CCR_ENABLE);
; 507  : 
; 508  : #if defined(DEBUG)
; 509  :     DumpDMA_LC(L"Start Output", pDMAReg);
; 510  :     CheckDMAStatus(pDMAReg, TRUE);
; 511  : #endif
; 512  : 
; 513  :     HWEnableOutputChannel(TRUE);

  0000c	e3a01001	 mov         r1, #1
  00010	e5923004	 ldr         r3, [r2, #4]
  00014	e3833902	 orr         r3, r3, #2, 18
  00018	e5823004	 str         r3, [r2, #4]
  0001c	e5923000	 ldr         r3, [r2]
  00020	e3833080	 orr         r3, r3, #0x80
  00024	e5823000	 str         r3, [r2]
  00028	e5943000	 ldr         r3, [r4]
  0002c	e5933084	 ldr         r3, [r3, #0x84]
  00030	e1a0e00f	 mov         lr, pc
  00034	e12fff13	 bx          r3

; 514  : 
; 515  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::HWStartOutputDMA()\r\n"));
; 516  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M37808|

			 ENDP  ; |?HWStartOutputDMA@OMAP2420DMAContext@@UAAXXZ|, OMAP2420DMAContext::HWStartOutputDMA


  00000			 AREA	 |.pdata|, PDATA
|$T37823| DCD	|$LN10@HWStopOutp|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWStopOutputDMA@OMAP2420DMAContext@@UAAXXZ| PROC ; OMAP2420DMAContext::HWStopOutputDMA

; 527  : {

  00000		 |$LN10@HWStopOutp|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37820|
  00004	e1a06000	 mov         r6, r0

; 528  :     OMAP2420_DMA_REGS  *pDMAReg;
; 529  :     DWORD i, dwVal;
; 530  : 
; 531  :     DEBUGMSG(ZONE_FUNCTION, (L"+OMAP2420DMAContext::HWStopOutputDMA()\r\n"));
; 532  : 
; 533  :     pDMAReg = m_pOutDMAReg;

  00008	e59640f4	 ldr         r4, [r6, #0xF4]

; 534  : 
; 535  :     // disable the DMA channel link and wait for writing to finish
; 536  :     CLRREG32(&pDMAReg->DMA4_CLNK_CTRL, DMA_CLNK_CTRL_ENABLE_LINK);
; 537  :     dwVal = INREG32(&pDMAReg->DMA4_CCR);
; 538  :     for (i = 0; (i < DMA_SAFETY_LOOP_NUM) && (dwVal & DMA_CCR_WR_ACTIVE); i++)

  0000c	e3a05000	 mov         r5, #0
  00010	e5943004	 ldr         r3, [r4, #4]
  00014	e3c33902	 bic         r3, r3, #2, 18
  00018	e5843004	 str         r3, [r4, #4]
  0001c	e5943000	 ldr         r3, [r4]
  00020		 |$LL3@HWStopOutp|
  00020	e3130b01	 tst         r3, #1, 22
  00024	0a000005	 beq         |$LN1@HWStopOutp|

; 539  :     {
; 540  :         Sleep(1);

  00028	e3a00001	 mov         r0, #1
  0002c	eb000000	 bl          Sleep
  00030	e2855001	 add         r5, r5, #1

; 541  :         dwVal = INREG32(&pDMAReg->DMA4_CCR);

  00034	e5943000	 ldr         r3, [r4]
  00038	e3550064	 cmp         r5, #0x64
  0003c	3afffff7	 bcc         |$LL3@HWStopOutp|
  00040		 |$LN1@HWStopOutp|

; 542  :     }
; 543  : 
; 544  :     // disable DMA on the channel
; 545  :     CLRREG32(&pDMAReg->DMA4_CCR, DMA_CCR_ENABLE);

  00040	e5943000	 ldr         r3, [r4]

; 546  : 
; 547  :     // clear pending interrupts
; 548  :     OUTREG32(&pDMAReg->DMA4_CSR, INREG32(&pDMAReg->DMA4_CSR));
; 549  :     DMA_ControllerSet(m_hCont, DMACP_L2IntAck, 1 << AUDIO_OUTPUT_DMA_CHANNEL);

  00044	e59fe044	 ldr         lr, [pc, #0x44]
  00048	e3a02004	 mov         r2, #4
  0004c	e3c33080	 bic         r3, r3, #0x80
  00050	e5843000	 str         r3, [r4]
  00054	e5b4300c	 ldr         r3, [r4, #0xC]!
  00058	e3a01006	 mov         r1, #6
  0005c	e5843000	 str         r3, [r4]
  00060	e59600ec	 ldr         r0, [r6, #0xEC]
  00064	e59e3000	 ldr         r3, [lr]
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3

; 550  : 
; 551  :     // disable the rest of the channel
; 552  :     HWEnableOutputChannel(FALSE);

  00070	e5963000	 ldr         r3, [r6]
  00074	e3a01000	 mov         r1, #0
  00078	e1a00006	 mov         r0, r6
  0007c	e5933084	 ldr         r3, [r3, #0x84]
  00080	e1a0e00f	 mov         lr, pc
  00084	e12fff13	 bx          r3

; 553  : 
; 554  : #if defined(DEBUG)
; 555  :     DumpDMA_LC(L"Stop Output", pDMAReg);
; 556  :     CheckDMAStatus(pDMAReg, FALSE);
; 557  : #endif
; 558  : 
; 559  : #ifdef PROFILE_MIXER
; 560  :     LARGE_INTEGER liTotalTime; 
; 561  :     LARGE_INTEGER liMixerTime;
; 562  : 
; 563  :     GetOutputDeviceContext(0)->StopMixerProfiler(&liTotalTime,&liMixerTime);
; 564  : 
; 565  :     DEBUGMSG(ZONE_DMA,(L"OMAP2420DMAContext::HWStopOutputDMA: "
; 566  :         L"Total play time: %dms, %dms while mixing\r\n", (DWORD) (liTotalTime.QuadPart), (DWORD) (liMixerTime.QuadPart)
; 567  :     ));
; 568  : #endif
; 569  : 
; 570  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::HWStopOutputDMA()\r\n"));
; 571  : }

  00088	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0008c	e12fff1e	 bx          lr
  00090		 |$LN11@HWStopOutp|
  00090		 |$LN12@HWStopOutp|
  00090	00000000	 DCD         |__imp_DMA_ControllerSet|
  00094		 |$M37821|

			 ENDP  ; |?HWStopOutputDMA@OMAP2420DMAContext@@UAAXXZ|, OMAP2420DMAContext::HWStopOutputDMA

	IMPORT	|?StopInputDMA@HardwareContext@@QAAXXZ|	; HardwareContext::StopInputDMA
	IMPORT	|?TransferInputBuffer@HardwareContext@@QAAKK@Z| ; HardwareContext::TransferInputBuffer

  00000			 AREA	 |.pdata|, PDATA
|$T37841| DCD	|$LN13@HWTransfer|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWTransferInputBuffers@OMAP2420DMAContext@@UAAKXZ| PROC ; OMAP2420DMAContext::HWTransferInputBuffers

; 582  : {

  00000		 |$LN13@HWTransfer|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M37838|
  00004	e1a06000	 mov         r6, r0

; 583  :     ULONG BytesTransferred=0;
; 584  :     OMAP2420_DMA_REGS  *pDMAReg;
; 585  :     DWORD dwVal, dwOffset;
; 586  : 
; 587  :     pDMAReg = m_pInDMAReg;

  00008	e59670f0	 ldr         r7, [r6, #0xF0]

; 588  : 
; 589  :     // read the CSR register, clear interrupt bits
; 590  :     dwVal = INREG32(&pDMAReg->DMA4_CSR);
; 591  :     OUTREG32(&pDMAReg->DMA4_CSR, dwVal);
; 592  :     DMA_ControllerSet(m_hCont, DMACP_L3IntAck, 1 << AUDIO_INPUT_DMA_CHANNEL);

  0000c	e59f3094	 ldr         r3, [pc, #0x94]
  00010	e3a02008	 mov         r2, #8
  00014	e597500c	 ldr         r5, [r7, #0xC]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e3a01003	 mov         r1, #3
  00020	e587500c	 str         r5, [r7, #0xC]
  00024	e59600ec	 ldr         r0, [r6, #0xEC]
  00028	e3a04000	 mov         r4, #0
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 593  : 
; 594  :     DEBUGMSG(ZONE_FUNCTION, (L"+OMAP2420DMAContext::HWTransferInputBuffers() %08X\n", dwVal));
; 595  : 
; 596  :     // an error occured
; 597  :     if (dwVal & DMA_CSR_DROP)
; 598  :     {
; 599  :         DEBUGMSG(ZONE_ERROR|ZONE_DMA, (L"OMAP2420DMAContext::HWTransferInputBuffers: "
; 600  :             L"RX DMA CSR error = 0x%x\r\n", dwVal
; 601  :         ));
; 602  :     }
; 603  : 
; 604  :     // make sure this is a HALF or FRAME interrupt
; 605  :     if (!(dwVal & (DMA_CSR_HALF|DMA_CSR_FRAME)))

  00034	e215300c	 ands        r3, r5, #0xC

; 606  :     {
; 607  :         DEBUGMSG(ZONE_DMA, (L"OMAP2420DMAContext::HWTransferInputBuffers: "
; 608  :             L"NOT input interrupt %08X\n", dwVal
; 609  :         ));
; 610  :         return BytesTransferred;

  00038	03a04000	 moveq       r4, #0
  0003c	0a000016	 beq         |$LN1@HWTransfer|

; 611  :     }
; 612  : 
; 613  :     // if both HALF and FRAME are on, then we lost one of them
; 614  :     if ((dwVal & (DMA_CSR_HALF|DMA_CSR_FRAME)) == (DMA_CSR_HALF|DMA_CSR_FRAME))

  00040	e353000c	 cmp         r3, #0xC
  00044	1a000005	 bne         |$LN10@HWTransfer|

; 615  :     {
; 616  :         DEBUGMSG(ZONE_ERROR, (L"OMAP2420DMAContext::HWTransferInputBuffers: "
; 617  :             L"Input buffer interrupt lost\r\n"
; 618  :         ));
; 619  : 
; 620  :         // pick HALF or FRAME based on which half of the frame the read pointer is in
; 621  :         dwOffset = INREG32(&pDMAReg->DMA4_CSAC) - INREG32(&pDMAReg->DMA4_CSSA);

  00048	e5972034	 ldr         r2, [r7, #0x34]
  0004c	e597301c	 ldr         r3, [r7, #0x1C]
  00050	e0423003	 sub         r3, r2, r3

; 622  :         dwVal = (dwOffset >= AUDIO_DMA_PAGE_SIZE) ? DMA_CSR_HALF : DMA_CSR_FRAME;

  00054	e3530a02	 cmp         r3, #2, 20
  00058	23a05004	 movcs       r5, #4
  0005c	33a05008	 movcc       r5, #8
  00060		 |$LN10@HWTransfer|

; 623  :     }
; 624  : 
; 625  :     // HALF interrupt, reload page 0
; 626  :     if (dwVal & DMA_CSR_HALF)

  00060	e3150004	 tst         r5, #4
  00064	0a000003	 beq         |$LN3@HWTransfer|

; 627  :     {
; 628  :         BytesTransferred += TransferInputBuffer(0);

  00068	e3a01000	 mov         r1, #0
  0006c	e1a00006	 mov         r0, r6
  00070	eb000000	 bl          |?TransferInputBuffer@HardwareContext@@QAAKK@Z|
  00074	e1a04000	 mov         r4, r0
  00078		 |$LN3@HWTransfer|

; 629  :     }
; 630  : 
; 631  :     // FRAME interrupt, reload page 1
; 632  :     if (dwVal & DMA_CSR_FRAME)

  00078	e3150008	 tst         r5, #8
  0007c	0a000003	 beq         |$LN2@HWTransfer|

; 633  :     {
; 634  :         BytesTransferred += TransferInputBuffer(1);

  00080	e3a01001	 mov         r1, #1
  00084	e1a00006	 mov         r0, r6
  00088	eb000000	 bl          |?TransferInputBuffer@HardwareContext@@QAAKK@Z|
  0008c	e0844000	 add         r4, r4, r0
  00090		 |$LN2@HWTransfer|

; 635  :     }
; 636  : 
; 637  :     // stop DMA when there's no more data
; 638  :     if (BytesTransferred == 0)

  00090	e3540000	 cmp         r4, #0

; 639  :     {
; 640  :         StopInputDMA();

  00094	01a00006	 moveq       r0, r6
  00098	0b000000	 bleq        |?StopInputDMA@HardwareContext@@QAAXXZ|
  0009c		 |$LN1@HWTransfer|

; 641  :     }
; 642  : 
; 643  :     return BytesTransferred;
; 644  : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN14@HWTransfer|
  000a8		 |$LN15@HWTransfer|
  000a8	00000000	 DCD         |__imp_DMA_ControllerSet|
  000ac		 |$M37839|

			 ENDP  ; |?HWTransferInputBuffers@OMAP2420DMAContext@@UAAKXZ|, OMAP2420DMAContext::HWTransferInputBuffers

	IMPORT	|?StopOutputDMA@HardwareContext@@QAAXXZ| ; HardwareContext::StopOutputDMA
	IMPORT	|?TransferOutputBuffer@HardwareContext@@QAAKK@Z| ; HardwareContext::TransferOutputBuffer

  00000			 AREA	 |.pdata|, PDATA
|$T37859| DCD	|$LN13@HWTransfer@2|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWTransferOutputBuffers@OMAP2420DMAContext@@UAAKXZ| PROC ; OMAP2420DMAContext::HWTransferOutputBuffers

; 655  : {

  00000		 |$LN13@HWTransfer@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M37856|
  00004	e1a06000	 mov         r6, r0

; 656  :     ULONG BytesTransferred=0;
; 657  :     OMAP2420_DMA_REGS  *pDMAReg;
; 658  :     DWORD dwVal, dwOffset;
; 659  : 
; 660  :     pDMAReg = m_pOutDMAReg;

  00008	e59670f4	 ldr         r7, [r6, #0xF4]

; 661  : 
; 662  :     // read the DMA CSR register, clear interrupt bits.
; 663  :     dwVal = INREG32(&pDMAReg->DMA4_CSR);
; 664  :     OUTREG32(&pDMAReg->DMA4_CSR, dwVal);
; 665  :     DMA_ControllerSet(m_hCont, DMACP_L2IntAck, 1 << AUDIO_OUTPUT_DMA_CHANNEL);

  0000c	e59f3094	 ldr         r3, [pc, #0x94]
  00010	e3a02004	 mov         r2, #4
  00014	e597500c	 ldr         r5, [r7, #0xC]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e3a01006	 mov         r1, #6
  00020	e587500c	 str         r5, [r7, #0xC]
  00024	e59600ec	 ldr         r0, [r6, #0xEC]
  00028	e3a04000	 mov         r4, #0
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 666  : 
; 667  :     DEBUGMSG(ZONE_FUNCTION, (L"OMAP2420DMAContext::HWTransferOutputBuffers() %08X\n", dwVal));
; 668  : 
; 669  :     // an error occured
; 670  :     if (dwVal & DMA_CSR_DROP)
; 671  :     {
; 672  :         DEBUGMSG(ZONE_ERROR|ZONE_DMA, (L"OMAP2420DMAContext::HWTransferOutputBuffers: "
; 673  :             L"TX DMA CSR error = 0x%x\r\n", dwVal
; 674  :         ));
; 675  :     }
; 676  : 
; 677  :     // make sure this is a HALF or FRAME interrupt
; 678  :     if (!(dwVal & (DMA_CSR_HALF|DMA_CSR_FRAME)))

  00034	e215300c	 ands        r3, r5, #0xC

; 679  :     {
; 680  :         DEBUGMSG(ZONE_DMA, (L"OMAP2420DMAContext::HWTransferOutputBuffers: "
; 681  :             L"NOT output interrupt %08X\n", dwVal
; 682  :         ));
; 683  :         return BytesTransferred;

  00038	03a04000	 moveq       r4, #0
  0003c	0a000016	 beq         |$LN1@HWTransfer@2|

; 684  :     }
; 685  : 
; 686  :     // if both HALF and FRAME are on, then we lost an interrupt
; 687  :     if ((dwVal & (DMA_CSR_HALF|DMA_CSR_FRAME)) == (DMA_CSR_HALF|DMA_CSR_FRAME))

  00040	e353000c	 cmp         r3, #0xC
  00044	1a000005	 bne         |$LN10@HWTransfer@2|

; 688  :     {   
; 689  :         DEBUGMSG(ZONE_ERROR|ZONE_DMA, (L"OMAP2420DMAContext::HWTransferOutputBuffers: "
; 690  :             L"Ooutput buffer interrupt lost\r\n"
; 691  :         ));
; 692  : 
; 693  :         // pick HALF or FRAME based on which half of the frame the write pointer is in
; 694  :         dwOffset = INREG32(&pDMAReg->DMA4_CSAC) - INREG32(&pDMAReg->DMA4_CSSA);

  00048	e5972034	 ldr         r2, [r7, #0x34]
  0004c	e597301c	 ldr         r3, [r7, #0x1C]
  00050	e0423003	 sub         r3, r2, r3

; 695  :         dwVal = (dwOffset >= AUDIO_DMA_PAGE_SIZE) ? DMA_CSR_HALF : DMA_CSR_FRAME;

  00054	e3530a02	 cmp         r3, #2, 20
  00058	23a05004	 movcs       r5, #4
  0005c	33a05008	 movcc       r5, #8
  00060		 |$LN10@HWTransfer@2|

; 696  :     }
; 697  : 
; 698  :     // HALF interrupt, reload page 0
; 699  :     if (dwVal & DMA_CSR_HALF)

  00060	e3150004	 tst         r5, #4
  00064	0a000003	 beq         |$LN3@HWTransfer@2|

; 700  :     {
; 701  :         BytesTransferred += TransferOutputBuffer(0);

  00068	e3a01000	 mov         r1, #0
  0006c	e1a00006	 mov         r0, r6
  00070	eb000000	 bl          |?TransferOutputBuffer@HardwareContext@@QAAKK@Z|
  00074	e1a04000	 mov         r4, r0
  00078		 |$LN3@HWTransfer@2|

; 702  :     }
; 703  : 
; 704  :     // FRAME interrupt, reload page 1
; 705  :     if (dwVal & DMA_CSR_FRAME)

  00078	e3150008	 tst         r5, #8
  0007c	0a000003	 beq         |$LN2@HWTransfer@2|

; 706  :     {   
; 707  :         BytesTransferred += TransferOutputBuffer(1);

  00080	e3a01001	 mov         r1, #1
  00084	e1a00006	 mov         r0, r6
  00088	eb000000	 bl          |?TransferOutputBuffer@HardwareContext@@QAAKK@Z|
  0008c	e0844000	 add         r4, r4, r0
  00090		 |$LN2@HWTransfer@2|

; 708  :     }
; 709  : 
; 710  :     // stop DMA when there's no more data
; 711  :     if (BytesTransferred == 0)

  00090	e3540000	 cmp         r4, #0

; 712  :     {
; 713  :         StopOutputDMA();

  00094	01a00006	 moveq       r0, r6
  00098	0b000000	 bleq        |?StopOutputDMA@HardwareContext@@QAAXXZ|
  0009c		 |$LN1@HWTransfer@2|

; 714  :     }
; 715  : 
; 716  :     DEBUGMSG(ZONE_FUNCTION, (L"-OMAP2420DMAContext::HWTransferOutputBuffers() %08X %d\r\n", dwVal, BytesTransferred));
; 717  : 
; 718  :     return BytesTransferred;
; 719  : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN14@HWTransfer@2|
  000a8		 |$LN15@HWTransfer@2|
  000a8	00000000	 DCD         |__imp_DMA_ControllerSet|
  000ac		 |$M37857|

			 ENDP  ; |?HWTransferOutputBuffers@OMAP2420DMAContext@@UAAKXZ|, OMAP2420DMAContext::HWTransferOutputBuffers

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T37875| DCD	|$LN8@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAP2420DMAContext@@UAAPAXI@Z| PROC ; OMAP2420DMAContext::`scalar deleting destructor'
  00000		 |$LN8@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37872|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1HardwareContext@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37873|

			 ENDP  ; |??_GOMAP2420DMAContext@@UAAPAXI@Z|, OMAP2420DMAContext::`scalar deleting destructor'

	END
