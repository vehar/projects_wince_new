; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\WAVEDEV\audioctl.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|DEVICE_IFC_SPI_GUID| [ DATA ]
	EXPORT	|SPIOpen|
	EXPORT	|??_C@_1M@BALJCCCP@?$AAS?$AAP?$AAI?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|LocalFree|
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\spi.h

  00000			 AREA	 |.pdata|, PDATA
|$T37792| DCD	|$LN11@SPIOpen|
	DCD	0x40003002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@BALJCCCP@?$AAS?$AAP?$AAI?$AA1?$AA?3?$AA?$AA@| DCB "S", 0x0, "P", 0x0
	DCB	"I", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPIOpen| PROC

; 75   : {

  00000		 |$LN11@SPIOpen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37789|

; 76   :     HANDLE hDevice;
; 77   :     DEVICE_CONTEXT_SPI *pContext = NULL;
; 78   : 
; 79   :     hDevice = CreateFile(SPI_DEVICE_NAME, 0, 0, NULL, 0, 0, NULL);

  00008	e59f00ac	 ldr         r0, [pc, #0xAC]
  0000c	e3a06000	 mov         r6, #0
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	e3a04000	 mov         r4, #0
  00020	e58d6008	 str         r6, [sp, #8]
  00024	e58d6004	 str         r6, [sp, #4]
  00028	e58d6000	 str         r6, [sp]
  0002c	eb000000	 bl          CreateFileW
  00030	e1a05000	 mov         r5, r0

; 80   :     if (hDevice == INVALID_HANDLE_VALUE) goto clean;

  00034	e3750001	 cmn         r5, #1
  00038	0a00001a	 beq         |$clean$37280|

; 81   : 
; 82   :     // Allocate memory for our handler...
; 83   :     if ((pContext = (DEVICE_CONTEXT_SPI *)LocalAlloc(
; 84   :         LPTR, sizeof(DEVICE_CONTEXT_SPI)
; 85   :     )) == NULL) {

  0003c	e3a01010	 mov         r1, #0x10
  00040	e3a00040	 mov         r0, #0x40
  00044	eb000000	 bl          LocalAlloc
  00048	e1b04000	 movs        r4, r0

; 86   :         CloseHandle(hDevice);

  0004c	e1a00005	 mov         r0, r5
  00050	1a000001	 bne         |$LN4@SPIOpen|
  00054	eb000000	 bl          CloseHandle

; 104  : 
; 105  : clean:

  00058	ea000012	 b           |$clean$37280|
  0005c		 |$LN4@SPIOpen|

; 87   :         goto clean;
; 88   :     }
; 89   : 
; 90   :     // Get function pointers, fail when IOCTL isn't supported...
; 91   :     if (!DeviceIoControl(
; 92   :         hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_SPI_GUID,
; 93   :         sizeof(DEVICE_IFC_SPI_GUID), &pContext->ifc, sizeof(DEVICE_IFC_SPI),
; 94   :         NULL, NULL
; 95   :     )) {

  0005c	e59f2054	 ldr         r2, [pc, #0x54]
  00060	e3a03822	 mov         r3, #0x22, 16
  00064	e3831b01	 orr         r1, r3, #1, 22
  00068	e3a0e00c	 mov         lr, #0xC
  0006c	e3a03010	 mov         r3, #0x10
  00070	e58d600c	 str         r6, [sp, #0xC]
  00074	e58d6008	 str         r6, [sp, #8]
  00078	e58de004	 str         lr, [sp, #4]
  0007c	e58d4000	 str         r4, [sp]
  00080	eb000000	 bl          DeviceIoControl
  00084	e3500000	 cmp         r0, #0
  00088	1a000005	 bne         |$LN2@SPIOpen|

; 96   :         CloseHandle(hDevice);

  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          CloseHandle

; 97   :         LocalFree(pContext);

  00094	e1a00004	 mov         r0, r4
  00098	eb000000	 bl          LocalFree

; 98   :         pContext = NULL;

  0009c	e3a04000	 mov         r4, #0

; 104  : 
; 105  : clean:

  000a0	ea000000	 b           |$clean$37280|
  000a4		 |$LN2@SPIOpen|

; 99   :         goto clean;
; 100  :     }
; 101  : 
; 102  :     // Save device handle
; 103  :     pContext->hDevice = hDevice;

  000a4	e584500c	 str         r5, [r4, #0xC]
  000a8		 |$clean$37280|

; 106  :     return pContext;
; 107  : }

  000a8	e1a00004	 mov         r0, r4
  000ac	e28dd010	 add         sp, sp, #0x10
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN12@SPIOpen|
  000b8		 |$LN13@SPIOpen|
  000b8	00000000	 DCD         |DEVICE_IFC_SPI_GUID|
  000bc		 |$LN14@SPIOpen|
  000bc	00000000	 DCD         |??_C@_1M@BALJCCCP@?$AAS?$AAP?$AAI?$AA1?$AA?3?$AA?$AA@|
  000c0		 |$M37790|

			 ENDP  ; |SPIOpen|

	EXPORT	|SPISetSlaveAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T37806| DCD	|$LN5@SPISetSlav|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPISetSlaveAddress| PROC

; 117  : {

  00000		 |$LN5@SPISetSlav|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37803|
  00004	e1a03000	 mov         r3, r0

; 118  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 119  :     return pContext->ifc.pfnSetSlaveAddress(pContext->ifc.context, address);

  00008	e5930000	 ldr         r0, [r3]
  0000c	e5933004	 ldr         r3, [r3, #4]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 120  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M37804|

			 ENDP  ; |SPISetSlaveAddress|

	EXPORT	|SPITransfer|

  00000			 AREA	 |.pdata|, PDATA
|$T37817| DCD	|$LN5@SPITransfe|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPITransfer| PROC

; 123  : {

  00000		 |$LN5@SPITransfe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37814|
  00004	e1a03000	 mov         r3, r0

; 124  :     DEVICE_CONTEXT_SPI *pContext = (DEVICE_CONTEXT_SPI *)hContext;
; 125  :     return pContext->ifc.pfnTransfer(pContext->ifc.context, pBuffer);

  00008	e5930000	 ldr         r0, [r3]
  0000c	e5933008	 ldr         r3, [r3, #8]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 126  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M37815|

			 ENDP  ; |SPITransfer|


  00000			 AREA	 |.pdata|, PDATA
|$T37831| DCD	|$LN7@TSC2101Wri|
	DCD	0x40000e02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\audioctl.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TSC2101Write@@YAXPAXGG@Z| PROC	; TSC2101Write

; 61   : {

  00000		 |$LN7@TSC2101Wri|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37828|
  00008	e1a0e000	 mov         lr, r0

; 62   :     DWORD   dwCommand;
; 63   : 
; 64   :     dwCommand = ((DWORD)(TSC2101_PAGE2 | wReg) << 16) | wData;

  0000c	e3813a01	 orr         r3, r1, #1, 20

; 65   :     SPITransfer(hSPI, &dwCommand);

  00010	e1823803	 orr         r3, r2, r3, lsl #16
  00014	e59e0000	 ldr         r0, [lr]
  00018	e59e4008	 ldr         r4, [lr, #8]
  0001c	e58d3000	 str         r3, [sp]
  00020	e28d1000	 add         r1, sp, #0
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff14	 bx          r4

; 66   : }

  0002c	e28dd004	 add         sp, sp, #4
  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M37829|

			 ENDP  ; |?TSC2101Write@@YAXPAXGG@Z|, TSC2101Write

; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\spi.h

  00000			 AREA	 |.pdata|, PDATA
|$T37846| DCD	|$LN7@TSC2101Rea|
	DCD	0x40001302
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\audioctl.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TSC2101Read@@YAGPAXG@Z| PROC		; TSC2101Read

; 74   : {

  00000		 |$LN7@TSC2101Rea|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M37843|
  00008	e1a02000	 mov         r2, r0
  0000c	e3e03c6f	 mvn         r3, #0x6F, 24

; 75   :     DWORD   dwCommand;
; 76   : 
; 77   :     dwCommand = (DWORD)(TSC2101_READ | TSC2101_PAGE2 | wReg) << 16;

  00010	e22330ff	 eor         r3, r3, #0xFF
  00014	e1813003	 orr         r3, r1, r3

; 78   :     SPITransfer(hSPI, &dwCommand);

  00018	e5920000	 ldr         r0, [r2]
  0001c	e1a03803	 mov         r3, r3, lsl #16
  00020	e5922008	 ldr         r2, [r2, #8]
  00024	e58d3000	 str         r3, [sp]
  00028	e28d1000	 add         r1, sp, #0
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff12	 bx          r2

; 79   :     return (WORD)dwCommand;

  00034	e59d3000	 ldr         r3, [sp]
  00038	e1a00803	 mov         r0, r3, lsl #16
  0003c	e1a00820	 mov         r0, r0, lsr #16

; 80   : }

  00040	e28dd004	 add         sp, sp, #4
  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$M37844|

			 ENDP  ; |?TSC2101Read@@YAGPAXG@Z|, TSC2101Read

	EXPORT	|?CreateHWContext@HardwareContext@@SAHK@Z| ; HardwareContext::CreateHWContext
	IMPORT	|?Init@HardwareContext@@QAAHK@Z|	; HardwareContext::Init
	IMPORT	|??0ACAudioHWContext@@QAA@PAG@Z|	; ACAudioHWContext::ACAudioHWContext
	IMPORT	|??2@YAPAXI@Z|				; operator new
	IMPORT	|?g_pHWContext@@3PAVHardwareContext@@A|	; g_pHWContext

  00000			 AREA	 |.pdata|, PDATA
|$T37861| DCD	|$LN10@CreateHWCo|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateHWContext@HardwareContext@@SAHK@Z| PROC ; HardwareContext::CreateHWContext

; 268  : {

  00000		 |$LN10@CreateHWCo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37858|
  00004	e1a05000	 mov         r5, r0

; 269  :     if (g_pHWContext)

  00008	e59f4054	 ldr         r4, [pc, #0x54]
  0000c	e5943000	 ldr         r3, [r4]
  00010	e3530000	 cmp         r3, #0

; 270  :     {
; 271  :         return TRUE;

  00014	13a00001	 movne       r0, #1

; 282  : }

  00018	18bd4030	 ldmneia     sp!, {r4, r5, lr}
  0001c	112fff1e	 bxne        lr

; 272  :     }
; 273  : 
; 274  :     g_pHWContext = new ACAudioHWContext((LPTSTR)Index);

  00020	e3a00e19	 mov         r0, #0x19, 28
  00024	eb000000	 bl          |??2@YAPAXI@Z|
  00028	e3500000	 cmp         r0, #0
  0002c	0a000002	 beq         |$LN5@CreateHWCo|
  00030	e1a01005	 mov         r1, r5
  00034	eb000000	 bl          |??0ACAudioHWContext@@QAA@PAG@Z|
  00038	ea000000	 b           |$LN7@CreateHWCo|
  0003c		 |$LN5@CreateHWCo|
  0003c	e3a00000	 mov         r0, #0
  00040		 |$LN7@CreateHWCo|

; 275  : 
; 276  :     if (!g_pHWContext)

  00040	e3500000	 cmp         r0, #0
  00044	e5840000	 str         r0, [r4]

; 277  :     {
; 278  :         return FALSE;

  00048	03a00000	 moveq       r0, #0

; 282  : }

  0004c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00050	012fff1e	 bxeq        lr

; 279  :     }
; 280  :     
; 281  :     return g_pHWContext->Init(Index);

  00054	e1a01005	 mov         r1, r5
  00058	eb000000	 bl          |?Init@HardwareContext@@QAAHK@Z|

; 282  : }

  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN11@CreateHWCo|
  00064		 |$LN12@CreateHWCo|
  00064	00000000	 DCD         |?g_pHWContext@@3PAVHardwareContext@@A|
  00068		 |$M37859|

			 ENDP  ; |?CreateHWContext@HardwareContext@@SAHK@Z|, HardwareContext::CreateHWContext

	EXPORT	|?HWMapControllerRegs@ACAudioHWContext@@UAAHXZ| ; ACAudioHWContext::HWMapControllerRegs
	IMPORT	|MmMapIoSpace|
	IMPORT	|SetDevicePowerState|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\spi.h

  00000			 AREA	 |.pdata|, PDATA
|$T37882| DCD	|$LN17@HWMapContr|
	DCD	0x40003101
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\audioctl.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWMapControllerRegs@ACAudioHWContext@@UAAHXZ| PROC ; ACAudioHWContext::HWMapControllerRegs

; 293  : {

  00000		 |$LN17@HWMapContr|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37879|
  00004	e1a04000	 mov         r4, r0

; 294  :     PHYSICAL_ADDRESS pa;
; 295  : 
; 296  :     DEBUGMSG(ZONE_AC, (L"+ACAudioHWContext::HWMapControllerRegs()\r\n"));
; 297  : 
; 298  :     // set the power state
; 299  :     if (!m_hParent)

  00008	e5943054	 ldr         r3, [r4, #0x54]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000024	 beq         |$ErrExit$37476|

; 300  :     {
; 301  :         DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::HWMapControllerRegs: "
; 302  :             L"ERROR setting the power state.\r\n"
; 303  :         ));
; 304  :         goto ErrExit;
; 305  :     }
; 306  :     m_CurPowerState = D2; 

  00014	e3a02002	 mov         r2, #2
  00018	e5842050	 str         r2, [r4, #0x50]

; 307  :     SetDevicePowerState(m_hParent, D2 , NULL);

  0001c	e3a02000	 mov         r2, #0
  00020	e3a01002	 mov         r1, #2
  00024	e1a00003	 mov         r0, r3
  00028	eb000000	 bl          SetDevicePowerState
  0002c	e3a03312	 mov         r3, #0x12, 6

; 308  : 
; 309  :     // get the McBSP pointer
; 310  :     pa.HighPart= 0;
; 311  :     pa.LowPart = AUDIO_MCBSP_REGS_PA;

  00030	e3830a76	 orr         r0, r3, #0x76, 20

; 312  :     m_pMCBSPRegisters = (OMAP2420_McBSP_REGS *)MmMapIoSpace(pa, N1KB, FALSE);

  00034	e3a03000	 mov         r3, #0
  00038	e3a02b01	 mov         r2, #1, 22
  0003c	e3a01000	 mov         r1, #0
  00040	eb000000	 bl          MmMapIoSpace
  00044	e3500000	 cmp         r0, #0
  00048	e5840160	 str         r0, [r4, #0x160]

; 313  :     if (!m_pMCBSPRegisters)

  0004c	0a000015	 beq         |$ErrExit$37476|
  00050	e3a03312	 mov         r3, #0x12, 6

; 314  :     {
; 315  :         DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::HWMapControllerRegs: "
; 316  :             L"ERROR mapping MCBSP registers.\r\n"
; 317  :         ));
; 318  :         goto ErrExit;
; 319  :     }
; 320  : 
; 321  :     // get the PRCM registers pointer
; 322  :     pa.LowPart = OMAP2420_PRCM_REGS_PA;

  00054	e3830902	 orr         r0, r3, #2, 18

; 323  :     m_pPRCMRegs = (OMAP2420_PRCM_REGS *)MmMapIoSpace(pa, sizeof(OMAP2420_PRCM_REGS), FALSE);

  00058	e3a03000	 mov         r3, #0
  0005c	e3a02c09	 mov         r2, #9, 24
  00060	e3a01000	 mov         r1, #0
  00064	eb000000	 bl          MmMapIoSpace
  00068	e3500000	 cmp         r0, #0
  0006c	e5840164	 str         r0, [r4, #0x164]

; 324  :     if (!m_pPRCMRegs)

  00070	0a00000c	 beq         |$ErrExit$37476|

; 325  :     {
; 326  :         DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::HWMapControllerRegs: "
; 327  :             L"Allocating PRCM register failed.\r\n"
; 328  :         ));
; 329  :         goto ErrExit;
; 330  :     }
; 331  : 
; 332  :     // open the SPI device
; 333  :     m_hSPI = SPIOpen();

  00074	eb000000	 bl          SPIOpen
  00078	e1b03000	 movs        r3, r0
  0007c	e5843168	 str         r3, [r4, #0x168]

; 334  :     if (!m_hSPI)

  00080	0a000008	 beq         |$ErrExit$37476|

; 335  :     {
; 336  :         DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::HWMapControllerRegs: "
; 337  :             L"Failed to open the SPI device driver.\r\n"
; 338  :         ));
; 339  :         goto ErrExit;
; 340  :     }
; 341  : 
; 342  :     // configure the SPI device
; 343  :     if (!SPISetSlaveAddress(m_hSPI, 0))

  00084	e5930000	 ldr         r0, [r3]
  00088	e5933004	 ldr         r3, [r3, #4]
  0008c	e3a01000	 mov         r1, #0
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff13	 bx          r3
  00098	e3500000	 cmp         r0, #0

; 344  :     {
; 345  :         DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::HWMapControllerRegs: "
; 346  :             L"Failed to set the SPI slave address.\r\n"
; 347  :         ));
; 348  :         goto ErrExit;
; 349  :     }
; 350  : 
; 351  :     return TRUE;

  0009c	13a00001	 movne       r0, #1

; 359  : }

  000a0	18bd4010	 ldmneia     sp!, {r4, lr}
  000a4	112fff1e	 bxne        lr
  000a8		 |$ErrExit$37476|

; 352  : 
; 353  : ErrExit:
; 354  :     // reset all mappings in case of error
; 355  :     m_pMCBSPRegisters = NULL;

  000a8	e3a03000	 mov         r3, #0
  000ac	e5843160	 str         r3, [r4, #0x160]

; 356  :     m_pPRCMRegs = NULL;

  000b0	e5843164	 str         r3, [r4, #0x164]

; 357  :     m_hSPI = NULL; 

  000b4	e5843168	 str         r3, [r4, #0x168]

; 358  :     return FALSE;

  000b8	e3a00000	 mov         r0, #0

; 359  : }

  000bc	e8bd4010	 ldmia       sp!, {r4, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M37880|

			 ENDP  ; |?HWMapControllerRegs@ACAudioHWContext@@UAAHXZ|, ACAudioHWContext::HWMapControllerRegs

	EXPORT	|?SetCodecPower@ACAudioHWContext@@AAAXH@Z| ; ACAudioHWContext::SetCodecPower

  00000			 AREA	 |.pdata|, PDATA
|$T37891| DCD	|$LN7@SetCodecPo|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetCodecPower@ACAudioHWContext@@AAAXH@Z| PROC ; ACAudioHWContext::SetCodecPower

; 370  : {

  00000		 |$LN7@SetCodecPo|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37888|
  00004	e3510000	 cmp         r1, #0
  00008	e1a04000	 mov         r4, r0

; 371  :     DEBUGMSG(ZONE_AC, (L"+ACAudioHWContext::SetCodecPower(%x)\r\n", fPowerOn));
; 372  : 
; 373  :     // power on or off the BSP and CODEC
; 374  :     if (fPowerOn)

  0000c	0a00000c	 beq         |$LN2@SetCodecPo|

; 375  :     {
; 376  :         CLRREG16(&m_pMCBSPRegisters->usMCBSP_PCR, MCBSP_IDLEEN);

  00010	e594e160	 ldr         lr, [r4, #0x160]
  00014	e3a03cbf	 mov         r3, #0xBF, 24
  00018	e38310ff	 orr         r1, r3, #0xFF
  0001c	e1de34b8	 ldrh        r3, [lr, #0x48]
  00020	e3a05a01	 mov         r5, #1, 20

; 377  :         TSC2101Write(m_hSPI, TSC2101_AUDCTRL_POWER, CPC_SP1PWDN | CPC_SP2PWDN);

  00024	e3a02b06	 mov         r2, #6, 22
  00028	e0033001	 and         r3, r3, r1
  0002c	e1ce34b8	 strh        r3, [lr, #0x48]
  00030	e5940168	 ldr         r0, [r4, #0x168]
  00034	e38510a0	 orr         r1, r5, #0xA0
  00038	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 385  :     }
; 386  : }

  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN2@SetCodecPo|

; 378  :     }
; 379  :     else
; 380  :     {
; 381  :         TSC2101Write(m_hSPI, TSC2101_AUDCTRL_POWER, CPC_MBIAS_HND | CPC_MBIAS_HED | CPC_ASTPWD |
; 382  :                     CPC_SP1PWDN | CPC_SP2PWDN | CPC_DAPWDN | CPC_ADPWDN | CPC_VGPWDN |
; 383  :                     CPC_COPWDN | CPC_LSPWDN);

  00044	e5940168	 ldr         r0, [r4, #0x168]
  00048	e3a03cff	 mov         r3, #0xFF, 24
  0004c	e3a01a01	 mov         r1, #1, 20
  00050	e38320c0	 orr         r2, r3, #0xC0
  00054	e38110a0	 orr         r1, r1, #0xA0
  00058	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 384  :         SETREG16(&m_pMCBSPRegisters->usMCBSP_PCR, MCBSP_IDLEEN);

  0005c	e5942160	 ldr         r2, [r4, #0x160]
  00060	e1d234b8	 ldrh        r3, [r2, #0x48]
  00064	e3833901	 orr         r3, r3, #1, 18
  00068	e1c234b8	 strh        r3, [r2, #0x48]

; 385  :     }
; 386  : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M37889|

			 ENDP  ; |?SetCodecPower@ACAudioHWContext@@AAAXH@Z|, ACAudioHWContext::SetCodecPower

	EXPORT	|?InitCodecPort@ACAudioHWContext@@AAAXXZ| ; ACAudioHWContext::InitCodecPort
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T37899| DCD	|$LN19@InitCodecP|
	DCD	0x40005f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitCodecPort@ACAudioHWContext@@AAAXXZ| PROC ; ACAudioHWContext::InitCodecPort

; 397  : {

  00000		 |$LN19@InitCodecP|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37896|
  00004	e1a04000	 mov         r4, r0

; 398  :     UINT16 uiTmp;
; 399  : 
; 400  :     DEBUGMSG(ZONE_AC, (L"+ACAudioHWContext::InitCodecPort()\r\n"));
; 401  : 
; 402  :     // power down everything
; 403  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_POWER, CPC_MBIAS_HND | CPC_MBIAS_HED | CPC_ASTPWD |
; 404  :                     CPC_SP1PWDN | CPC_SP2PWDN | CPC_DAPWDN | CPC_ADPWDN | CPC_VGPWDN |
; 405  :                     CPC_COPWDN | CPC_LSPWDN);

  00008	e5940168	 ldr         r0, [r4, #0x168]
  0000c	e3a03cff	 mov         r3, #0xFF, 24
  00010	e3a05a01	 mov         r5, #1, 20
  00014	e38320c0	 orr         r2, r3, #0xC0
  00018	e38510a0	 orr         r1, r5, #0xA0
  0001c	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 406  : 
; 407  :     // headset input not muted, AGC for Headset In off
; 408  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_HEADSET, HGC_ADPGA_HED(0x7F));

  00020	e5940168	 ldr         r0, [r4, #0x168]
  00024	e3a02c7f	 mov         r2, #0x7F, 24
  00028	e3851020	 orr         r1, r5, #0x20
  0002c	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 409  : 
; 410  :     // handset input not muted, AGC for Handset In off
; 411  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_HANDSET, HNGC_ADPGA_HND(0x7F));

  00030	e5940168	 ldr         r0, [r4, #0x168]
  00034	e3a02c7f	 mov         r2, #0x7F, 24
  00038	e3a01d4f	 mov         r1, #0x4F, 26
  0003c	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 412  : 
; 413  :     // mute analog sidetone, select MIC_INHED input for headset
; 414  :     // Cell Phone In not connected
; 415  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_MIXER, MPC_ASTMU | MPC_ASTG(0x600) | MPC_MICADC |
; 416  :                     MPC_MICSEL(1));

  00040	e5940168	 ldr         r0, [r4, #0x168]
  00044	e3a06902	 mov         r6, #2, 18
  00048	e3862030	 orr         r2, r6, #0x30
  0004c	e3851060	 orr         r1, r5, #0x60
  00050	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 417  : 
; 418  :     // ADC, DAC, Analog Sidetone, cellphone, buzzer
; 419  :     // softstepping enabled, 1dB AGC hysteresis, MICes bias 2V 
; 420  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_4, AC4_MB_HED(0));

  00054	e5940168	 ldr         r0, [r4, #0x168]
  00058	e3a05c13	 mov         r5, #0x13, 24
  0005c	e38510a0	 orr         r1, r5, #0xA0
  00060	e3a02000	 mov         r2, #0
  00064	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 421  : 
; 422  :     // Set codec output volume
; 423  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_DAC, DGC_DALVL(0) | DGC_DARVL(0));

  00068	e5940168	 ldr         r0, [r4, #0x168]
  0006c	e3a02000	 mov         r2, #0
  00070	e3a01d41	 mov         r1, #0x41, 26
  00074	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 424  : 
; 425  :     // DAC left and right routed to SPK2, SPK1/2 unmuted
; 426  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_5, AC5_DAC2SPK1(3) | AC5_AST2SPK1 | AC5_KCL2SPK1 |
; 427  :                     AC5_DAC2SPK2(3) | AC5_AST2SPK2 | AC5_KCL2SPK2 | AC5_HDSCPTC);

  00078	e5940168	 ldr         r0, [r4, #0x168]
  0007c	e3a03c75	 mov         r3, #0x75, 24
  00080	e38320d1	 orr         r2, r3, #0xD1
  00084	e3a01b05	 mov         r1, #5, 22
  00088	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 428  : 
; 429  :     // OUT8P/N muted, CPOUT muted
; 430  : //  TSC2101Write(m_hSPI, TSC2101_AUDCTRL_6, AC6_MUTSPK2 |
; 431  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_6, AC6_MUTSPK2 | AC6_SPL2LSK | AC6_AST2LSK |
; 432  :                     AC6_LDSCPTC | AC6_VGNDSCPTC);

  0008c	e5940168	 ldr         r0, [r4, #0x168]
  00090	e3a03903	 mov         r3, #3, 18
  00094	e3a01b05	 mov         r1, #5, 22
  00098	e3832070	 orr         r2, r3, #0x70
  0009c	e3811020	 orr         r1, r1, #0x20
  000a0	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 433  : 
; 434  :     // Headset/Hook switch detect disabled
; 435  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_7, 0);

  000a4	e5940168	 ldr         r0, [r4, #0x168]
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01d51	 mov         r1, #0x51, 26
  000b0	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 436  : 
; 437  :     // set I2S, word length, and reference sampling rate (RFS) divisor
; 438  :     if (BITSPERSAMPLE == 20) uiTmp = 1;
; 439  :     else if (BITSPERSAMPLE == 24) uiTmp = 2;
; 440  :     else if (BITSPERSAMPLE == 32) uiTmp = 3;
; 441  :     else uiTmp = 0;
; 442  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_1, AC1_WLEN(uiTmp) | AC1_DACFS(0) | AC1_ADCFS(0));

  000b4	e5940168	 ldr         r0, [r4, #0x168]
  000b8	e3a02000	 mov         r2, #0
  000bc	e3a01a01	 mov         r1, #1, 20
  000c0	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 443  : 
; 444  :     // make the TSC2101 the master vs. the McBSP, set the RFS to 44100 or 48000
; 445  :     uiTmp = AC3_SLVMS | ((SAMPLERATE == 44100) ? AC3_REFFS : 0);
; 446  :     TSC2101Write(m_hSPI, TSC2101_AUDCTRL_3, uiTmp);

  000c4	e5940168	 ldr         r0, [r4, #0x168]
  000c8	e3a02b0a	 mov         r2, #0xA, 22
  000cc	e3a01d43	 mov         r1, #0x43, 26
  000d0	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 447  : 
; 448  :     // program the PLL's
; 449  :     if (SAMPLERATE == 44100)
; 450  :     {
; 451  :         // 44.1 KHz, 12 MHz MCLK, 5264 D_VAL
; 452  :         TSC2101Write(m_hSPI, TSC2101_AUDCTRL_PLL0, PLL1_PLLSEL | PLL1_PVAL(1) | PLL1_I_VAL(7));

  000d4	e5940168	 ldr         r0, [r4, #0x168]
  000d8	e3a03c81	 mov         r3, #0x81, 24
  000dc	e383201c	 orr         r2, r3, #0x1C
  000e0	e3851060	 orr         r1, r5, #0x60
  000e4	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 453  :         TSC2101Write(m_hSPI, TSC2101_AUDCTRL_PLL1, PLL2_D_VAL(5264));

  000e8	e5940168	 ldr         r0, [r4, #0x168]
  000ec	e3a03c52	 mov         r3, #0x52, 24
  000f0	e3832040	 orr         r2, r3, #0x40
  000f4	e3a01d4e	 mov         r1, #0x4E, 26
  000f8	eb000000	 bl          |?TSC2101Write@@YAXPAXGG@Z|

; 454  :     }
; 455  :     else
; 456  :     {
; 457  :         // 48 KHz, 12 MHz MCLK, 1920 D_VAL
; 458  :         TSC2101Write(m_hSPI, TSC2101_AUDCTRL_PLL0, PLL1_PLLSEL | PLL1_PVAL(1) | PLL1_I_VAL(8));
; 459  :         TSC2101Write(m_hSPI, TSC2101_AUDCTRL_PLL1, PLL2_D_VAL(1920));
; 460  :     }
; 461  : 
; 462  :     // go into idle mode and configure the clocks
; 463  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_PCR, MCBSP_IDLEEN | MCBSP_CLKRM | MCBSP_SCLKME |
; 464  :                 MCBSP_FSXP | MCBSP_FSRP | MCBSP_CLKXP | MCBSP_CLKRP);

  000fc	e5942160	 ldr         r2, [r4, #0x160]
  00100	e3a03c41	 mov         r3, #0x41, 24
  00104	e383308f	 orr         r3, r3, #0x8F
  00108	e1c234b8	 strh        r3, [r2, #0x48]

; 465  : 
; 466  :     if (BITSPERSAMPLE == 20) uiTmp = MCBSP_WORD_20;
; 467  :     else if (BITSPERSAMPLE == 24) uiTmp = MCBSP_WORD_24;
; 468  :     else if (BITSPERSAMPLE == 32) uiTmp = MCBSP_WORD_32;
; 469  :     else uiTmp = MCBSP_WORD_16;
; 470  : 
; 471  :     // receive 1 word of BITSPERSAMPLE in a frame,
; 472  :     // in 2 phases (1 word each) with a 1-bit delay
; 473  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_RCR1, MCBSP_RFRLEN1(0) | MCBSP_RWDLEN1(uiTmp));

  0010c	e5943160	 ldr         r3, [r4, #0x160]
  00110	e3a00040	 mov         r0, #0x40

; 474  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_RCR2, MCBSP_RPHASE | MCBSP_RFRLEN2(0) |
; 475  :                 MCBSP_RWDLEN2(uiTmp) | MCBSP_RDATDLY(1));

  00114	e3862041	 orr         r2, r6, #0x41
  00118	e1c301bc	 strh        r0, [r3, #0x1C]
  0011c	e5943160	 ldr         r3, [r4, #0x160]

; 476  : 
; 477  :     // transmit 1 word of BITSPERSAMPLE in a frame,
; 478  :     // in 2 phases (1 word each) with a 1-bit delay
; 479  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_XCR1, MCBSP_XFRLEN1(0) | MCBSP_XWDLEN1(uiTmp));
; 480  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_XCR2, MCBSP_XPHASE | MCBSP_XFRLEN2(0) |
; 481  :                 MCBSP_XWDLEN2(uiTmp) | MCBSP_XDATDLY(1) | MCBSP_XFIG);

  00120	e3861045	 orr         r1, r6, #0x45
  00124	e1c321b8	 strh        r2, [r3, #0x18]
  00128	e5943160	 ldr         r3, [r4, #0x160]

; 482  : 
; 483  :     // set the clocks
; 484  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_SRGR1, MCBSP_FWID(BITSPERSAMPLE - 1) |
; 485  :                 MCBSP_CLKGDV(0));

  0012c	e3a02c0f	 mov         r2, #0xF, 24
  00130	e1c302b4	 strh        r0, [r3, #0x24]
  00134	e5943160	 ldr         r3, [r4, #0x160]
  00138	e1c312b0	 strh        r1, [r3, #0x20]
  0013c	e5943160	 ldr         r3, [r4, #0x160]
  00140	e3a01a0d	 mov         r1, #0xD, 20
  00144	e1c322bc	 strh        r2, [r3, #0x2C]

; 486  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_SRGR2, MCBSP_GSYNC | MCBSP_CLKSP |
; 487  :                 MCBSP_FSGM | MCBSP_FPER(BITSPERSAMPLE * 2 - 1));

  00148	e5942160	 ldr         r2, [r4, #0x160]
  0014c	e381301f	 orr         r3, r1, #0x1F

; 488  : 
; 489  :     //Left Justify, Clockstop with no delay, Receiver Disabled
; 490  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_SPCR1, MCBSP_RINTM(3));

  00150	e3a01030	 mov         r1, #0x30
  00154	e1c232b8	 strh        r3, [r2, #0x28]
  00158	e5943160	 ldr         r3, [r4, #0x160]

; 491  : 
; 492  :     // Set transmit interrupt on XSYNCERR.
; 493  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_SPCR2, MCBSP_FREE | MCBSP_XINTM(3));

  0015c	e3a02e23	 mov         r2, #0x23, 28

; 494  : 
; 495  :     // Delay while new divisors take effect.
; 496  :     Sleep(100);

  00160	e3a00064	 mov         r0, #0x64
  00164	e1c311b4	 strh        r1, [r3, #0x14]
  00168	e5943160	 ldr         r3, [r4, #0x160]
  0016c	e1c321b0	 strh        r2, [r3, #0x10]
  00170	eb000000	 bl          Sleep

; 497  : }

  00174	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00178	e12fff1e	 bx          lr
  0017c		 |$M37897|

			 ENDP  ; |?InitCodecPort@ACAudioHWContext@@AAAXXZ|, ACAudioHWContext::InitCodecPort

	EXPORT	|?InitModemPort@ACAudioHWContext@@AAAXXZ| ; ACAudioHWContext::InitModemPort

  00000			 AREA	 |.pdata|, PDATA
|$T37906| DCD	|$LN5@InitModemP|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitModemPort@ACAudioHWContext@@AAAXXZ| PROC ; ACAudioHWContext::InitModemPort

; 508  : {

  00000		 |$LN5@InitModemP|
  00000		 |$M37903|

; 509  :     DEBUGMSG(ZONE_AC, (L"+ACAudioHWContext::InitModemPort()\r\n"));
; 510  : 
; 511  :     // Modem Port Control register
; 512  : /*    USHORT usVal = 0;
; 513  : 
; 514  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_MPCTR,usVal);
; 515  : 
; 516  :     // Modem Main Port Configuration register
; 517  :     usVal = INREG16(&m_pMCBSPRegisters->usMCBSP_MPMCCFR);
; 518  :     usVal &= 8000;
; 519  :                     //  Data justify left, filled with zero 
; 520  :                     //  Expand and compand disabled.
; 521  : #ifndef NO_EAC_MIXING
; 522  :     usVal |= BIT8;  //  Master mode(Lead2 GSM voice is slave)
; 523  : #endif
; 524  :     usVal |= BIT7;  //  Frame Sync rising
; 525  :     usVal |= BIT6;  //  Frame Sync active high
; 526  :     usVal |= BIT5;  //  Bit clock polarity rising
; 527  :     usVal |= 0x0F;  //  16 bit
; 528  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_MPMCCFR,usVal);
; 529  : 
; 530  :     // Set the registers first before enabling the 
; 531  :     // channel, otherwise 
; 532  :     usVal = INREG16(&m_pMCBSPRegisters->usMCBSP_MPCTR);
; 533  :     usVal |= BIT3;  // Prescale clock divisor
; 534  :     usVal |= BIT7;  // Enable main channel
; 535  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_MPCTR,usVal);
; 536  : 
; 537  :     // Enable the clock at the last step
; 538  :     usVal |= BIT0;  // Clock running
; 539  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_MPCTR,usVal);
; 540  : */
; 541  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37904|

			 ENDP  ; |?InitModemPort@ACAudioHWContext@@AAAXXZ|, ACAudioHWContext::InitModemPort

	EXPORT	|?InitBluetoothPort@ACAudioHWContext@@AAAXXZ| ; ACAudioHWContext::InitBluetoothPort

  00000			 AREA	 |.pdata|, PDATA
|$T37913| DCD	|$LN5@InitBlueto|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitBluetoothPort@ACAudioHWContext@@AAAXXZ| PROC ; ACAudioHWContext::InitBluetoothPort

; 553  : {

  00000		 |$LN5@InitBlueto|
  00000		 |$M37910|

; 554  :     DEBUGMSG(ZONE_AC, (L"ACAudioHWContext::InitBluetoothPort()\r\n"));
; 555  : 
; 556  :     // Bluetooth Port Control register
; 557  : /*    USHORT usVal = 0;
; 558  : 
; 559  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_BPCTR,usVal);
; 560  : 
; 561  :     // Bluetooth Main Port Configuration register
; 562  :     usVal = INREG16(&m_pMCBSPRegisters->usMCBSP_BPMCCFR);
; 563  :     usVal &= 8000;
; 564  :                     //  Data justify left, filled with zero 
; 565  :                     //  Expand and compand disabled.
; 566  :                     //  Slave mode (Syren is master)
; 567  :     usVal |= BIT7;  //  Frame Sync rising
; 568  :     usVal |= BIT6;  //  Frame Sync active high
; 569  :     usVal |= BIT5;  //  Clock Sync rising
; 570  :     usVal |= 0x0F;  //  16 bit,
; 571  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_BPMCCFR,usVal);
; 572  : 
; 573  :     // Set the registers first before enabling the 
; 574  :     // channel
; 575  :     usVal = INREG16(&m_pMCBSPRegisters->usMCBSP_BPCTR);
; 576  :     usVal |= BIT3;  // Prescale clock divisor 16
; 577  :     usVal |= BIT7;  // Enable main channel
; 578  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_BPCTR,usVal);
; 579  : 
; 580  :     // Enable the clock at the last step
; 581  :     usVal |= BIT0;  // Clock running
; 582  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_BPCTR,usVal);
; 583  : */    
; 584  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37911|

			 ENDP  ; |?InitBluetoothPort@ACAudioHWContext@@AAAXXZ|, ACAudioHWContext::InitBluetoothPort

	EXPORT	|?HWInitController@ACAudioHWContext@@UAAXXZ| ; ACAudioHWContext::HWInitController

  00000			 AREA	 |.pdata|, PDATA
|$T37927| DCD	|$LN9@HWInitCont|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWInitController@ACAudioHWContext@@UAAXXZ| PROC ; ACAudioHWContext::HWInitController

; 597  : {

  00000		 |$LN9@HWInitCont|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37924|
  00004	e1a04000	 mov         r4, r0

; 598  :     DEBUGMSG(ZONE_AC, (L"+ACAudioHWContext::HWInitController()\r\n"));
; 599  : 
; 600  :     // power everything up and configure it
; 601  :     HWPowerUp();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e593304c	 ldr         r3, [r3, #0x4C]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 602  :     InitCodecPort();

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          |?InitCodecPort@ACAudioHWContext@@AAAXXZ|

; 603  :     InitModemPort();
; 604  :     InitBluetoothPort();
; 605  : 
; 606  : #if defined(TEST_TONE)
; 607  :     HWEnableInputChannel(TRUE);
; 608  :     HWEnableOutputChannel(TRUE);
; 609  :     TestTone(m_pMCBSPRegisters);
; 610  :     HWEnableInputChannel(FALSE);
; 611  :     HWEnableOutputChannel(FALSE);
; 612  : #endif
; 613  : 
; 614  : #ifdef DEBUG
; 615  :     DumpMCBSPRegisters();
; 616  : #endif
; 617  : }

  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M37925|

			 ENDP  ; |?HWInitController@ACAudioHWContext@@UAAXXZ|, ACAudioHWContext::HWInitController

	EXPORT	|?SetControllerClocks@ACAudioHWContext@@AAAXH@Z| ; ACAudioHWContext::SetControllerClocks
	IMPORT	|KernelIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T37935| DCD	|$LN7@SetControl|
	DCD	0x40002e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetControllerClocks@ACAudioHWContext@@AAAXH@Z| PROC ; ACAudioHWContext::SetControllerClocks

; 658  : {

  00000		 |$LN7@SetControl|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M37932|
  00008	e3510000	 cmp         r1, #0

; 659  :     DEBUGMSG(ZONE_AC,(L"AC: SetControllerClocks (%x)\r\n", fOn));
; 660  : 
; 661  :     DWORD regBit, cbRet;
; 662  : 
; 663  :     if (fOn)
; 664  :     {
; 665  :         // enable the McBSP clocks
; 666  :         regBit = AUDIO_PRCM_FCLKEN_MCBSP;
; 667  :         KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  0000c	e3a05801	 mov         r5, #1, 16
  00010	e58d5008	 str         r5, [sp, #8]
  00014	e28de00c	 add         lr, sp, #0xC
  00018	e3a04000	 mov         r4, #0
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02004	 mov         r2, #4
  00024	e28d1008	 add         r1, sp, #8
  00028	0a00000e	 beq         |$LN2@SetControl|
  0002c	e59f0080	 ldr         r0, [pc, #0x80]
  00030	e58de004	 str         lr, [sp, #4]
  00034	e58d4000	 str         r4, [sp]
  00038	eb000000	 bl          KernelIoControl

; 668  :         regBit = AUDIO_PRCM_ICLKEN_MCBSP;
; 669  :         KernelIoControl(IOCTL_ICLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  0003c	e59f006c	 ldr         r0, [pc, #0x6C]
  00040	e28de00c	 add         lr, sp, #0xC
  00044	e3a05801	 mov         r5, #1, 16
  00048	e3a03000	 mov         r3, #0
  0004c	e3a02004	 mov         r2, #4
  00050	e28d1008	 add         r1, sp, #8
  00054	e58de004	 str         lr, [sp, #4]
  00058	e58d5008	 str         r5, [sp, #8]
  0005c	e58d4000	 str         r4, [sp]
  00060	eb000000	 bl          KernelIoControl

; 670  :     }
; 671  :     else 

  00064	ea00000e	 b           |$LN1@SetControl|
  00068		 |$LN2@SetControl|
  00068	e3a06822	 mov         r6, #0x22, 16

; 672  :     {
; 673  :         // disable the McBSP clocks
; 674  :         regBit = AUDIO_PRCM_FCLKEN_MCBSP;
; 675  :         KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  0006c	e3860e42	 orr         r0, r6, #0x42, 28
  00070	e58de004	 str         lr, [sp, #4]
  00074	e58d4000	 str         r4, [sp]
  00078	eb000000	 bl          KernelIoControl

; 676  :         regBit = AUDIO_PRCM_ICLKEN_MCBSP;

  0007c	e3a02801	 mov         r2, #1, 16

; 677  :         KernelIoControl(IOCTL_ICLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00080	e28d300c	 add         r3, sp, #0xC
  00084	e58d2008	 str         r2, [sp, #8]
  00088	e58d3004	 str         r3, [sp, #4]
  0008c	e3a03000	 mov         r3, #0
  00090	e3a02004	 mov         r2, #4
  00094	e28d1008	 add         r1, sp, #8
  00098	e3860e41	 orr         r0, r6, #0x41, 28
  0009c	e58d4000	 str         r4, [sp]
  000a0	eb000000	 bl          KernelIoControl
  000a4		 |$LN1@SetControl|

; 678  :     }
; 679  : }

  000a4	e28dd010	 add         sp, sp, #0x10
  000a8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN8@SetControl|
  000b0		 |$LN9@SetControl|
  000b0	0022040c	 DCD         0x22040c
  000b4		 |$LN10@SetControl|
  000b4	0022041c	 DCD         0x22041c
  000b8		 |$M37933|

			 ENDP  ; |?SetControllerClocks@ACAudioHWContext@@AAAXH@Z|, ACAudioHWContext::SetControllerClocks

	EXPORT	|?SetRecordMemoPath@ACAudioHWContext@@UAAXH@Z| ; ACAudioHWContext::SetRecordMemoPath

  00000			 AREA	 |.pdata|, PDATA
|$T37945| DCD	|$LN5@SetRecordM|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetRecordMemoPath@ACAudioHWContext@@UAAXH@Z| PROC ; ACAudioHWContext::SetRecordMemoPath

; 691  : {

  00000		 |$LN5@SetRecordM|
  00000		 |$M37942|

; 692  :     DEBUGMSG(ZONE_AC,(L"AC: SetRecordMemoPath(%x)\r\n", 1));
; 693  : 
; 694  : /*    USHORT usVal;
; 695  :  
; 696  :     usVal = INREG16(&m_pMCBSPRegisters->usMCBSP_AMSCFR);
; 697  :     
; 698  :     // Let a memo or talk get through
; 699  :     if(fSetOn)
; 700  :     {
; 701  :         usVal |= BIT5;
; 702  :         usVal |= BIT7;  
; 703  :         usVal &=~BIT1; // we must turn off K2 here due to sidetone
; 704  : 
; 705  :         // dev note: enabling K8 may cause extensive sideton feedback on some devices
; 706  :         // it may be necessary to open K2 to avoid this effect
; 707  :     }
; 708  :     else
; 709  :     {
; 710  :         usVal &= ~BIT5;
; 711  :         usVal &= ~BIT7;
; 712  :         usVal |=  BIT1;
; 713  :     }
; 714  : 
; 715  :     OUTREG16(&m_pMCBSPRegisters->usMCBSP_AMSCFR,usVal);
; 716  : */
; 717  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37943|

			 ENDP  ; |?SetRecordMemoPath@ACAudioHWContext@@UAAXH@Z|, ACAudioHWContext::SetRecordMemoPath

	EXPORT	|?HWEnableInputChannel@ACAudioHWContext@@UAAXH@Z| ; ACAudioHWContext::HWEnableInputChannel

  00000			 AREA	 |.pdata|, PDATA
|$T37954| DCD	|$LN7@HWEnableIn|
	DCD	0x40000c00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWEnableInputChannel@ACAudioHWContext@@UAAXH@Z| PROC ; ACAudioHWContext::HWEnableInputChannel

; 730  : {

  00000		 |$LN7@HWEnableIn|
  00000		 |$M37951|
  00000	e3510000	 cmp         r1, #0

; 731  :     DEBUGMSG(ZONE_AC,(L"AC: HWEnableInputChannel (%x)\r\n", 1));
; 732  : 
; 733  :     // enable or disable the receiver
; 734  :     if (fEnable)
; 735  :     {
; 736  :         SETREG16(&m_pMCBSPRegisters->usMCBSP_SPCR1, MCBSP_RRST);

  00004	15902160	 ldrne       r2, [r0, #0x160]
  00008	11d231b4	 ldrneh      r3, [r2, #0x14]
  0000c	13833001	 orrne       r3, r3, #1
  00010	11c231b4	 strneh      r3, [r2, #0x14]

; 737  :     }
; 738  :     else
; 739  :     {
; 740  :         CLRREG16(&m_pMCBSPRegisters->usMCBSP_SPCR1, MCBSP_RRST);

  00014	05901160	 ldreq       r1, [r0, #0x160]
  00018	03a03cff	 moveq       r3, #0xFF, 24
  0001c	038320fe	 orreq       r2, r3, #0xFE
  00020	01d131b4	 ldreqh      r3, [r1, #0x14]
  00024	00033002	 andeq       r3, r3, r2
  00028	01c131b4	 streqh      r3, [r1, #0x14]

; 741  :     }
; 742  : }

  0002c	e12fff1e	 bx          lr
  00030		 |$M37952|

			 ENDP  ; |?HWEnableInputChannel@ACAudioHWContext@@UAAXH@Z|, ACAudioHWContext::HWEnableInputChannel

	EXPORT	|?HWEnableOutputChannel@ACAudioHWContext@@UAAXH@Z| ; ACAudioHWContext::HWEnableOutputChannel

  00000			 AREA	 |.pdata|, PDATA
|$T37963| DCD	|$LN7@HWEnableOu|
	DCD	0x40000c00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWEnableOutputChannel@ACAudioHWContext@@UAAXH@Z| PROC ; ACAudioHWContext::HWEnableOutputChannel

; 754  : {

  00000		 |$LN7@HWEnableOu|
  00000		 |$M37960|
  00000	e3510000	 cmp         r1, #0

; 755  :     DEBUGMSG(ZONE_AC,(L"AC: HWEnableOutputChannel (%x)\r\n", fEnable));
; 756  : 
; 757  :     // enable or disable the transmitter
; 758  :     if (fEnable)
; 759  :     {
; 760  :         SETREG16(&m_pMCBSPRegisters->usMCBSP_SPCR2, MCBSP_XRST | MCBSP_GRST | MCBSP_FRST);

  00004	15902160	 ldrne       r2, [r0, #0x160]
  00008	11d231b0	 ldrneh      r3, [r2, #0x10]
  0000c	138330c1	 orrne       r3, r3, #0xC1
  00010	11c231b0	 strneh      r3, [r2, #0x10]

; 761  :     }
; 762  :     else
; 763  :     {
; 764  :         CLRREG16(&m_pMCBSPRegisters->usMCBSP_SPCR2, MCBSP_XRST);

  00014	05901160	 ldreq       r1, [r0, #0x160]
  00018	03a03cff	 moveq       r3, #0xFF, 24
  0001c	038320fe	 orreq       r2, r3, #0xFE
  00020	01d131b0	 ldreqh      r3, [r1, #0x10]
  00024	00033002	 andeq       r3, r3, r2
  00028	01c131b0	 streqh      r3, [r1, #0x10]

; 765  :     }
; 766  : }

  0002c	e12fff1e	 bx          lr
  00030		 |$M37961|

			 ENDP  ; |?HWEnableOutputChannel@ACAudioHWContext@@UAAXH@Z|, ACAudioHWContext::HWEnableOutputChannel

	EXPORT	|?ConfigEacBTAuSpiPins@ACAudioHWContext@@AAAXW4PIN_FUNC@@@Z| ; ACAudioHWContext::ConfigEacBTAuSpiPins

  00000			 AREA	 |.pdata|, PDATA
|$T37970| DCD	|$LN5@ConfigEacB|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ConfigEacBTAuSpiPins@ACAudioHWContext@@AAAXW4PIN_FUNC@@@Z| PROC ; ACAudioHWContext::ConfigEacBTAuSpiPins

; 777  : {

  00000		 |$LN5@ConfigEacB|
  00000		 |$M37967|

; 778  :     DEBUGMSG(ZONE_AC, (L"ACAudioHWContext::ConfigEacBTAuSpiPins(%x)\r\n", PinFunction));
; 779  : /*
; 780  :     // Disable AuSpi clock
; 781  :     CLRREG16(&m_pMCBSPRegisters->usMCBSP_BPCTR,BIT0);
; 782  : 
; 783  :     switch(PinFunction)
; 784  :     {
; 785  :     case V3U3V2T4_TO_EAC_BT_AUSPI:
; 786  :         CLRREG32(&m_pCFGRegs->MODE1,MODE1_INTERNAL_BTAUSPI_SOURCE_BITS); 
; 787  :         SETREG32(&m_pCFGRegs->MODE1,MODE1_V3U3V2T4_AS_BTAUSPI_SOURCE); 
; 788  :         break;
; 789  :         
; 790  :     case W6R9Y6Y5_TO_EAC_BT_AUSPI:
; 791  :         CLRREG32(&m_pCFGRegs->MODE1, MODE1_INTERNAL_BTAUSPI_SOURCE_BITS); 
; 792  :         SETREG32(&m_pCFGRegs->MODE1, MODE1_W6R9Y6Y5_AS_BTAUSPI_SOURCE);         
; 793  :         break;  
; 794  :     } 
; 795  : 
; 796  :     // Enable AuSpi clocks
; 797  :     SETREG16(&m_pMCBSPRegisters->usMCBSP_BPCTR,BIT0);
; 798  : */    
; 799  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M37968|

			 ENDP  ; |?ConfigEacBTAuSpiPins@ACAudioHWContext@@AAAXW4PIN_FUNC@@@Z|, ACAudioHWContext::ConfigEacBTAuSpiPins

	EXPORT	|?SetAMRcapture@ACAudioHWContext@@AAAHH@Z| ; ACAudioHWContext::SetAMRcapture

  00000			 AREA	 |.pdata|, PDATA
|$T37979| DCD	|$LN5@SetAMRcapt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetAMRcapture@ACAudioHWContext@@AAAHH@Z| PROC ; ACAudioHWContext::SetAMRcapture

; 808  : {

  00000		 |$LN5@SetAMRcapt|
  00000		 |$M37976|

; 809  :     DEBUGMSG(ZONE_AC, (L"ACAudioHWContext::SetAMRcapture(%d)\r\n", fStart));
; 810  : 
; 811  : /*    // Start AMR capture. 
; 812  :     if (fStart)
; 813  :     {
; 814  :         CLRREG32(&m_pCFGRegs->IO_CONFIG2,(BIT7|BIT6|BIT5));       // Bt port
; 815  : 
; 816  :         // GSM SYREN VOICE.
; 817  :         SETREG32(&m_pCFGRegs->IO_CONFIG2, BIT5);                    
; 818  : 
; 819  :         // Select Bt pins to lead2 vspi port.
; 820  :         CLRREG32(&m_pCFGRegs->MODE1,(BIT1|BIT0));               
; 821  :     }
; 822  : 
; 823  :     // Stop AMR capture. 
; 824  :     else
; 825  :     {
; 826  :         CLRREG32(&m_pCFGRegs->IO_CONFIG2,(BIT7|BIT6|BIT5));       // Bt port
; 827  : 
; 828  :         // Select Bt pins to lead2 vspi port.
; 829  :         SETREG32(&m_pCFGRegs->MODE1,(BIT1|BIT0));                      
; 830  : 
; 831  :         // Select EAC modem to lead2 vspi port.
; 832  :         SETREG32(&m_pCFGRegs->MODE1,BIT0);                       
; 833  :     }
; 834  : */
; 835  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 836  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37977|

			 ENDP  ; |?SetAMRcapture@ACAudioHWContext@@AAAHH@Z|, ACAudioHWContext::SetAMRcapture

	EXPORT	|?DumpMCBSPRegisters@ACAudioHWContext@@AAAXXZ| ; ACAudioHWContext::DumpMCBSPRegisters
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\spi.h

  00000			 AREA	 |.pdata|, PDATA
|$T38003| DCD	|$LN14@DumpMCBSPR|
	DCD	0x40001702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\audioctl.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DumpMCBSPRegisters@ACAudioHWContext@@AAAXXZ| PROC ; ACAudioHWContext::DumpMCBSPRegisters

; 847  : {

  00000		 |$LN14@DumpMCBSPR|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M38000|
  00008	e1a05000	 mov         r5, r0

; 848  :     WORD    wReg, wData;
; 849  : 
; 850  :     DEBUGMSG(ZONE_AC, (L"AC: McBSP Registers\r\n"));
; 851  :     DEBUGMSG(ZONE_AC, (L"AC:    DRR2:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_DRR2)));
; 852  :     DEBUGMSG(ZONE_AC, (L"AC:    DRR1:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_DRR1)));
; 853  :     DEBUGMSG(ZONE_AC, (L"AC:    DXR2:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_DXR2)));
; 854  :     DEBUGMSG(ZONE_AC, (L"AC:    DXR1:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_DXR1)));
; 855  :     DEBUGMSG(ZONE_AC, (L"AC:    SPCR1: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_SPCR1)));
; 856  :     DEBUGMSG(ZONE_AC, (L"AC:    SPCR2: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_SPCR2)));
; 857  :     DEBUGMSG(ZONE_AC, (L"AC:    PCR:   %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_PCR)));
; 858  :     DEBUGMSG(ZONE_AC, (L"AC:    RCR1:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCR1)));
; 859  :     DEBUGMSG(ZONE_AC, (L"AC:    RCR2:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCR2)));
; 860  :     DEBUGMSG(ZONE_AC, (L"AC:    XCR1:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCR1)));
; 861  :     DEBUGMSG(ZONE_AC, (L"AC:    XCR2:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCR2)));
; 862  :     DEBUGMSG(ZONE_AC, (L"AC:    SRGR1: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_SRGR1)));
; 863  :     DEBUGMSG(ZONE_AC, (L"AC:    SRGR2: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_SRGR2)));
; 864  :     DEBUGMSG(ZONE_AC, (L"AC:    MCR1:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_MCR1)));
; 865  :     DEBUGMSG(ZONE_AC, (L"AC:    MCR2:  %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_MCR2)));
; 866  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERA: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERA)));
; 867  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERB: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERB)));
; 868  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERC: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERC)));
; 869  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERD: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERD)));
; 870  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERE: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERE)));
; 871  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERF: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERF)));
; 872  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERG: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERG)));
; 873  :     DEBUGMSG(ZONE_AC, (L"AC:    RCERH: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_RCERH)));
; 874  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERA: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERA)));
; 875  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERB: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERB)));
; 876  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERC: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERC)));
; 877  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERD: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERD)));
; 878  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERE: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERE)));
; 879  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERF: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERF)));
; 880  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERG: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERG)));
; 881  :     DEBUGMSG(ZONE_AC, (L"AC:    XCERH: %04X\r\n", INREG16(&m_pMCBSPRegisters->usMCBSP_XCERH)));
; 882  :     DEBUGMSG(ZONE_AC, (L"AC: TSC2101 Page 2 Registers:\r\n"));
; 883  :     for (wReg = 0; wReg < 0x28; wReg++)

  0000c	e3e03c6f	 mvn         r3, #0x6F, 24
  00010	e22360ff	 eor         r6, r3, #0xFF
  00014	e3a04000	 mov         r4, #0
  00018		 |$LL3@DumpMCBSPR|

; 884  :     {
; 885  :         wData = TSC2101Read(m_hSPI, wReg << 5);

  00018	e5952168	 ldr         r2, [r5, #0x168]
  0001c	e1863284	 orr         r3, r6, r4, lsl #5
  00020	e1a03803	 mov         r3, r3, lsl #16
  00024	e58d3000	 str         r3, [sp]
  00028	e5920000	 ldr         r0, [r2]
  0002c	e5923008	 ldr         r3, [r2, #8]
  00030	e28d1000	 add         r1, sp, #0
  00034	e1a0e00f	 mov         lr, pc
  00038	e12fff13	 bx          r3
  0003c	e2843001	 add         r3, r4, #1
  00040	e1a04803	 mov         r4, r3, lsl #16
  00044	e1a04824	 mov         r4, r4, lsr #16
  00048	e3540028	 cmp         r4, #0x28
  0004c	3afffff1	 bcc         |$LL3@DumpMCBSPR|

; 886  :         DEBUGMSG(ZONE_AC, (L"AC:    Register[%02X] = %04X\r\n", wReg, wData));
; 887  :     }
; 888  : }

  00050	e28dd004	 add         sp, sp, #4
  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M38001|

			 ENDP  ; |?DumpMCBSPRegisters@ACAudioHWContext@@AAAXXZ|, ACAudioHWContext::DumpMCBSPRegisters

	EXPORT	|?HWPowerUp@ACAudioHWContext@@UAAXXZ|	; ACAudioHWContext::HWPowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T38011| DCD	|$LN5@HWPowerUp|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWPowerUp@ACAudioHWContext@@UAAXXZ| PROC ; ACAudioHWContext::HWPowerUp

; 628  : {

  00000		 |$LN5@HWPowerUp|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38008|

; 629  :     DEBUGMSG(ZONE_AC, (L"+ACAudioHWContext::HWPowerUp()\r\n"));
; 630  : 
; 631  :     SetControllerClocks(TRUE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          |?SetControllerClocks@ACAudioHWContext@@AAAXH@Z|

; 632  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38009|

			 ENDP  ; |?HWPowerUp@ACAudioHWContext@@UAAXXZ|, ACAudioHWContext::HWPowerUp

	EXPORT	|?HWPowerDown@ACAudioHWContext@@UAAXXZ|	; ACAudioHWContext::HWPowerDown

  00000			 AREA	 |.pdata|, PDATA
|$T38019| DCD	|$LN5@HWPowerDow|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?HWPowerDown@ACAudioHWContext@@UAAXXZ| PROC ; ACAudioHWContext::HWPowerDown

; 643  : {

  00000		 |$LN5@HWPowerDow|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38016|

; 644  :     DEBUGMSG(ZONE_AC,(L"AC: HWPowerDown()\r\n"));
; 645  : 
; 646  :     SetControllerClocks(FALSE);

  00004	e3a01000	 mov         r1, #0
  00008	eb000000	 bl          |?SetControllerClocks@ACAudioHWContext@@AAAXH@Z|

; 647  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38017|

			 ENDP  ; |?HWPowerDown@ACAudioHWContext@@UAAXXZ|, ACAudioHWContext::HWPowerDown

	END
