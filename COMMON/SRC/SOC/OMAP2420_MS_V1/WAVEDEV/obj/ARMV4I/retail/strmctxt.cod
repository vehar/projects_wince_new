; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\WAVEDEV\strmctxt.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|GainMap| DCW	0xf1ad
	DCW	0xe429
	DCW	0xd765
	DCW	0xcb59
	DCW	0xbff9
	DCW	0xb53b
	DCW	0xab18
	DCW	0xa186
	DCW	0x987d
	DCW	0x8ff5
	DCW	0x87e8
	DCW	0x804d
	DCW	0x7920
	DCW	0x7259
	DCW	0x6bf4
	DCW	0x65ea
	DCW	0x6036
	DCW	0x5ad5
	DCW	0x55c0
	DCW	0x50f4
	DCW	0x4c6d
	DCW	0x4826
	DCW	0x441d
	DCW	0x404d
	DCW	0x3cb5
	DCW	0x394f
	DCW	0x361a
	DCW	0x3314
	DCW	0x3038
	DCW	0x2d86
	DCW	0x2afa
	DCW	0x2892
	DCW	0x264d
	DCW	0x2429
	DCW	0x2223
	DCW	0x203a
	DCW	0x1e6c
	DCW	0x1cb9
	DCW	0x1b1d
	DCW	0x1999
	DCW	0x182a
	DCW	0x16d0
	DCW	0x158a
	DCW	0x1455
	DCW	0x1332
	DCW	0x121f
	DCW	0x111c
	DCW	0x1027
	DCW	0xf3f
	DCW	0xe65
	DCW	0xd97
	DCW	0xcd4
	DCW	0xc1c
	DCW	0xb6f
	DCW	0xacb
	DCW	0xa31
	DCW	0x99f
	DCW	0x915
	DCW	0x893
	DCW	0x818
	DCW	0x7a4
	DCW	0x737
	DCW	0x6cf
	DCW	0x66e
	DCW	0x612
	DCW	0x5bb
	DCW	0x569
	DCW	0x51b
	DCW	0x4d2
	DCW	0x48d
	DCW	0x44c
	DCW	0x40e
	DCW	0x3d4
	DCW	0x39d
	DCW	0x369
	DCW	0x339
	DCW	0x30a
	DCW	0x2df
	DCW	0x2b6
	DCW	0x28f
	DCW	0x26a
	DCW	0x248
	DCW	0x227
	DCW	0x208
	DCW	0x1eb
	DCW	0x1cf
	DCW	0x1b6
	DCW	0x19d
	DCW	0x186
	DCW	0x170
	DCW	0x15b
	DCW	0x148
	DCW	0x136
	DCW	0x124
	DCW	0x114
	DCW	0x104
	DCW	0xf6
	DCW	0xe8
	DCW	0xdb
	DCW	0xcf
	DCW	0xc3
	DCW	0xb8
	DCW	0xae
	DCW	0xa4
	DCW	0x9b
	DCW	0x92
	DCW	0x8a
	DCW	0x82
	DCW	0x7b
	DCW	0x74
	DCW	0x6e
	DCW	0x67
	DCW	0x62
	DCW	0x5c
	DCW	0x57
	DCW	0x52
	DCW	0x4d
	DCW	0x49
	DCW	0x45
	DCW	0x41
	DCW	0x3d
	DCW	0x3a
	DCW	0x37
	DCW	0x34
	DCW	0x31
	DCW	0x2e
	DCW	0x2b
	DCW	0x29
	DCW	0x27
	DCW	0x24
	DCW	0x22
	DCW	0x20
	DCW	0x1f
	DCW	0x1d
	DCW	0x1b
	DCW	0x1a
	DCW	0x18
	DCW	0x17
	DCW	0x15
	DCW	0x14
	DCW	0x13
	DCW	0x12
	DCW	0x11
	DCW	0x10
	DCW	0xf
	DCW	0xe
	DCW	0xd
	DCW	0xd
	DCW	0xc
	DCW	0xb
	DCW	0xb
	DCW	0xa
	DCW	0x9
	DCW	0x9
	DCW	0x8
	DCW	0x8
	DCW	0x7
	DCW	0x7
	DCW	0x6
	DCW	0x6
	DCW	0x6
	DCW	0x5
	DCW	0x5
	DCW	0x5
	DCW	0x4
	DCW	0x4
	DCW	0x4
	DCW	0x4
	DCW	0x3
	DCW	0x3
	DCW	0x3
	DCW	0x3
	DCW	0x3
	DCW	0x2
	DCW	0x2
	DCW	0x2
	DCW	0x2
	DCW	0x2
	DCW	0x2
	DCW	0x2
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x1
	DCW	0x0
	DCW	0x0
	DCW	0x0
	DCW	0x0
	DCW	0x0
	DCW	0x0
	DCW	0x0
	DCW	0x0
	EXPORT	|?GetGain@DeviceContext@@QAAKXZ|	; DeviceContext::GetGain
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\devctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37513| DCD	|$LN5@GetGain|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetGain@DeviceContext@@QAAKXZ| PROC	; DeviceContext::GetGain

; 56   :     {

  00000		 |$LN5@GetGain|
  00000		 |$M37510|

; 57   :         return m_dwGain;

  00000	e590000c	 ldr         r0, [r0, #0xC]

; 58   :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37511|

			 ENDP  ; |?GetGain@DeviceContext@@QAAKXZ|, DeviceContext::GetGain

	EXPORT	|?GetDefaultStreamGain@DeviceContext@@QAAKXZ| ; DeviceContext::GetDefaultStreamGain

  00000			 AREA	 |.pdata|, PDATA
|$T37523| DCD	|$LN5@GetDefault|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDefaultStreamGain@DeviceContext@@QAAKXZ| PROC ; DeviceContext::GetDefaultStreamGain

; 68   :     {

  00000		 |$LN5@GetDefault|
  00000		 |$M37520|

; 69   :         return m_dwDefaultStreamGain;

  00000	e5900010	 ldr         r0, [r0, #0x10]

; 70   :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37521|

			 ENDP  ; |?GetDefaultStreamGain@DeviceContext@@QAAKXZ|, DeviceContext::GetDefaultStreamGain

	EXPORT	|?GetSecondaryGainLimit@DeviceContext@@QAAKK@Z| ; DeviceContext::GetSecondaryGainLimit

  00000			 AREA	 |.pdata|, PDATA
|$T37534| DCD	|$LN5@GetSeconda|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSecondaryGainLimit@DeviceContext@@QAAKK@Z| PROC ; DeviceContext::GetSecondaryGainLimit

; 79   :     {

  00000		 |$LN5@GetSeconda|
  00000		 |$M37531|

; 80   :         return m_dwSecondaryGainLimit[GainClass];

  00000	e2813005	 add         r3, r1, #5
  00004	e7900103	 ldr         r0, [r0, +r3, lsl #2]

; 81   :     }

  00008	e12fff1e	 bx          lr
  0000c		 |$M37532|

			 ENDP  ; |?GetSecondaryGainLimit@DeviceContext@@QAAKK@Z|, DeviceContext::GetSecondaryGainLimit

	EXPORT	|?GetStreamAttenMax@HardwareContext@@QAAKXZ| ; HardwareContext::GetStreamAttenMax
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\hwctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37544| DCD	|$LN5@GetStreamA|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetStreamAttenMax@HardwareContext@@QAAKXZ| PROC ; HardwareContext::GetStreamAttenMax

; 99   :     {

  00000		 |$LN5@GetStreamA|
  00000		 |$M37541|

; 100  :         return m_dwStreamAttenMax;

  00000	e59000e0	 ldr         r0, [r0, #0xE0]

; 101  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37542|

			 ENDP  ; |?GetStreamAttenMax@HardwareContext@@QAAKXZ|, HardwareContext::GetStreamAttenMax

	EXPORT	|?GetDeviceAttenMax@HardwareContext@@QAAKXZ| ; HardwareContext::GetDeviceAttenMax

  00000			 AREA	 |.pdata|, PDATA
|$T37554| DCD	|$LN5@GetDeviceA|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetDeviceAttenMax@HardwareContext@@QAAKXZ| PROC ; HardwareContext::GetDeviceAttenMax

; 107  :     {

  00000		 |$LN5@GetDeviceA|
  00000		 |$M37551|

; 108  :         return m_dwDeviceAttenMax;

  00000	e59000e4	 ldr         r0, [r0, #0xE4]

; 109  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37552|

			 ENDP  ; |?GetDeviceAttenMax@HardwareContext@@QAAKXZ|, HardwareContext::GetDeviceAttenMax

	EXPORT	|?GetSecondAttenMax@HardwareContext@@QAAKXZ| ; HardwareContext::GetSecondAttenMax

  00000			 AREA	 |.pdata|, PDATA
|$T37564| DCD	|$LN5@GetSecondA|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetSecondAttenMax@HardwareContext@@QAAKXZ| PROC ; HardwareContext::GetSecondAttenMax

; 116  :     {

  00000		 |$LN5@GetSecondA|
  00000		 |$M37561|

; 117  :         return m_dwSecondAttenMax;

  00000	e59000e8	 ldr         r0, [r0, #0xE8]

; 118  :     }

  00004	e12fff1e	 bx          lr
  00008		 |$M37562|

			 ENDP  ; |?GetSecondAttenMax@HardwareContext@@QAAKXZ|, HardwareContext::GetSecondAttenMax

	EXPORT	|?StillPlaying@StreamContext@@QAAHXZ|	; StreamContext::StillPlaying
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37576| DCD	|$LN7@StillPlayi|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StillPlaying@StreamContext@@QAAHXZ| PROC ; StreamContext::StillPlaying

; 91   :     BOOL StillPlaying() {return (m_lpWaveHdrHead!=NULL);}

  00000		 |$LN7@StillPlayi|
  00000		 |$M37573|
  00000	e5903038	 ldr         r3, [r0, #0x38]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0
  00010	e12fff1e	 bx          lr
  00014		 |$M37574|

			 ENDP  ; |?StillPlaying@StreamContext@@QAAHXZ|, StreamContext::StillPlaying

	EXPORT	|?ReturnBuffer@StreamContext@@QAAXPAUwavehdr_tag@@@Z| ; StreamContext::ReturnBuffer

  00000			 AREA	 |.pdata|, PDATA
|$T37585| DCD	|$LN5@ReturnBuff|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReturnBuffer@StreamContext@@QAAXPAUwavehdr_tag@@@Z| PROC ; StreamContext::ReturnBuffer

; 122  :     {

  00000		 |$LN5@ReturnBuff|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37582|
  00004	e1a02001	 mov         r2, r1

; 123  :         lpHdr->dwFlags &= ~WHDR_INQUEUE;

  00008	e5923010	 ldr         r3, [r2, #0x10]

; 124  :         lpHdr->dwFlags |= WHDR_DONE;
; 125  :         DEBUGMSG(ZONE_WODM && ZONE_VERBOSE,(TEXT("WODM: DoCallbackStreamClosed\r\n")));
; 126  :         DoCallbackReturnBuffer(lpHdr);

  0000c	e3c33010	 bic         r3, r3, #0x10
  00010	e3833001	 orr         r3, r3, #1
  00014	e5823010	 str         r3, [r2, #0x10]
  00018	e5903000	 ldr         r3, [r0]
  0001c	e5933020	 ldr         r3, [r3, #0x20]
  00020	e1a0e00f	 mov         lr, pc
  00024	e12fff13	 bx          r3

; 127  :     }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M37583|

			 ENDP  ; |?ReturnBuffer@StreamContext@@QAAXPAUwavehdr_tag@@@Z|, StreamContext::ReturnBuffer

	EXPORT	|?SetGain@StreamContext@@QAAKK@Z|	; StreamContext::SetGain

  00000			 AREA	 |.pdata|, PDATA
|$T37596| DCD	|$LN5@SetGain|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetGain@StreamContext@@QAAKK@Z| PROC	; StreamContext::SetGain

; 135  :     {

  00000		 |$LN5@SetGain|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37593|
  00004	e1a02000	 mov         r2, r0

; 136  :         m_dwGain = dwGain;
; 137  :         GainChange();

  00008	e5923000	 ldr         r3, [r2]
  0000c	e5821058	 str         r1, [r2, #0x58]
  00010	e5933030	 ldr         r3, [r3, #0x30]
  00014	e1a0e00f	 mov         lr, pc
  00018	e12fff13	 bx          r3

; 138  :         return MMSYSERR_NOERROR;

  0001c	e3a00000	 mov         r0, #0

; 139  :     }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M37594|

			 ENDP  ; |?SetGain@StreamContext@@QAAKK@Z|, StreamContext::SetGain

	EXPORT	|?Open@StreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| ; StreamContext::Open
	IMPORT	|?NewStream@DeviceContext@@QAAXPAVStreamContext@@@Z| ; DeviceContext::NewStream
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T37620| DCD	|$LN11@Open|
	DCD	0x40004f01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@StreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| PROC ; StreamContext::Open

; 27   : {

  00000		 |$LN11@Open|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M37617|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a0a001	 mov         r10, r1
  00010	e1a09000	 mov         r9, r0

; 28   :     m_RefCount = 1;

  00014	e3a03001	 mov         r3, #1
  00018	e589300c	 str         r3, [r9, #0xC]

; 29   :     m_pDeviceContext = pDeviceContext;

  0001c	e589a050	 str         r10, [r9, #0x50]

; 30   :     m_pfnCallback = (DRVCALLBACK *)lpWOD->dwCallback;

  00020	e5d86008	 ldrb        r6, [r8, #8]
  00024	e5d8e009	 ldrb        lr, [r8, #9]
  00028	e5d8400a	 ldrb        r4, [r8, #0xA]
  0002c	e5d8500b	 ldrb        r5, [r8, #0xB]
  00030	e186e40e	 orr         lr, r6, lr, lsl #8
  00034	e18ee804	 orr         lr, lr, r4, lsl #16
  00038	e18eec05	 orr         lr, lr, r5, lsl #24
  0003c	e589e01c	 str         lr, [r9, #0x1C]

; 31   :     m_dwInstance  = lpWOD->dwInstance;

  00040	e5d8600c	 ldrb        r6, [r8, #0xC]
  00044	e5d8e00d	 ldrb        lr, [r8, #0xD]
  00048	e5d8400e	 ldrb        r4, [r8, #0xE]
  0004c	e5d8500f	 ldrb        r5, [r8, #0xF]
  00050	e186e40e	 orr         lr, r6, lr, lsl #8
  00054	e18ee804	 orr         lr, lr, r4, lsl #16
  00058	e18eec05	 orr         lr, lr, r5, lsl #24
  0005c	e589e020	 str         lr, [r9, #0x20]

; 32   :     m_hWave       = lpWOD->hWave;

  00060	e5d8e000	 ldrb        lr, [r8]
  00064	e5d83001	 ldrb        r3, [r8, #1]
  00068	e5d82002	 ldrb        r2, [r8, #2]
  0006c	e5d81003	 ldrb        r1, [r8, #3]
  00070	e18e3403	 orr         r3, lr, r3, lsl #8
  00074	e1833802	 orr         r3, r3, r2, lsl #16
  00078	e1833c01	 orr         r3, r3, r1, lsl #24

; 33   :     m_dwFlags     = dwFlags;
; 34   :     m_bRunning    = FALSE;

  0007c	e3a04000	 mov         r4, #0
  00080	e5893018	 str         r3, [r9, #0x18]
  00084	e5897014	 str         r7, [r9, #0x14]
  00088	e5894010	 str         r4, [r9, #0x10]

; 35   :     m_bForceSpeaker = FALSE;

  0008c	e5894064	 str         r4, [r9, #0x64]

; 36   : 
; 37   :     // If it's a PCMWAVEFORMAT struct, it's smaller than a WAVEFORMATEX struct (it doesn't have the cbSize field),
; 38   :     // so don't copy too much or we risk a fault if the structure is located on the end of a page.
; 39   :     // All other non-PCM wave formats share the WAVEFORMATEX base structure
; 40   :     // Note: I don't keep around anything after the cbSize of the WAVEFORMATEX struct so that I don't need to
; 41   :     // worry about allocating additional space. If we need to keep this info around in the future, we can either
; 42   :     // allocate it dynamically here, or keep the information in any derived format-specific classes.
; 43   :     DWORD dwSize;
; 44   :     WAVEFORMATEX *pwfx = lpWOD->lpFormat;

  00090	e5d80004	 ldrb        r0, [r8, #4]
  00094	e5d83005	 ldrb        r3, [r8, #5]
  00098	e5d82006	 ldrb        r2, [r8, #6]
  0009c	e5d81007	 ldrb        r1, [r8, #7]
  000a0	e1803403	 orr         r3, r0, r3, lsl #8
  000a4	e1833802	 orr         r3, r3, r2, lsl #16
  000a8	e1831c01	 orr         r1, r3, r1, lsl #24

; 45   :     if (pwfx->wFormatTag == WAVE_FORMAT_PCM)

  000ac	e5d12000	 ldrb        r2, [r1]
  000b0	e5d13001	 ldrb        r3, [r1, #1]

; 46   :     {
; 47   :         dwSize = sizeof(PCMWAVEFORMAT);
; 48   :         m_WaveFormat.cbSize = 0;
; 49   :     }
; 50   :     else
; 51   :     {
; 52   :         dwSize = sizeof(WAVEFORMATEX);
; 53   :     }
; 54   : 
; 55   :     memcpy(&m_WaveFormat,pwfx,dwSize);

  000b4	e2890024	 add         r0, r9, #0x24
  000b8	e1823403	 orr         r3, r2, r3, lsl #8
  000bc	e3530001	 cmp         r3, #1
  000c0	03a02010	 moveq       r2, #0x10
  000c4	13a02012	 movne       r2, #0x12
  000c8	05c94034	 streqb      r4, [r9, #0x34]
  000cc	05c94035	 streqb      r4, [r9, #0x35]
  000d0	eb000000	 bl          memcpy

; 56   : 
; 57   :     m_lpWaveHdrHead    = NULL;
; 58   :     m_lpWaveHdrTail    = NULL;
; 59   :     m_lpWaveHdrCurrent = NULL;
; 60   :     m_lpCurrData       = NULL;
; 61   :     m_lpCurrDataEnd    = NULL;
; 62   :     m_dwByteCount      = 0;
; 63   :     m_dwLoopCount = 0;
; 64   : 
; 65   :     m_SecondaryGainClass=0;
; 66   :     SetGain(pDeviceContext->GetDefaultStreamGain()); // Set gain to default value

  000d4	e5992000	 ldr         r2, [r9]
  000d8	e5894038	 str         r4, [r9, #0x38]
  000dc	e5894040	 str         r4, [r9, #0x40]
  000e0	e589403c	 str         r4, [r9, #0x3C]
  000e4	e5894044	 str         r4, [r9, #0x44]
  000e8	e5894048	 str         r4, [r9, #0x48]
  000ec	e589404c	 str         r4, [r9, #0x4C]
  000f0	e5894054	 str         r4, [r9, #0x54]
  000f4	e589405c	 str         r4, [r9, #0x5C]
  000f8	e59a3010	 ldr         r3, [r10, #0x10]
  000fc	e5922030	 ldr         r2, [r2, #0x30]
  00100	e1a00009	 mov         r0, r9
  00104	e5893058	 str         r3, [r9, #0x58]
  00108	e1a0e00f	 mov         lr, pc
  0010c	e12fff12	 bx          r2

; 67   : 
; 68   :     DEBUGMSG(ZONE_MDD, (TEXT("Opening stream 0x%x\r\n"),this));
; 69   : 
; 70   :     // Add stream to list. This will start playback.
; 71   :     pDeviceContext->NewStream(this);

  00110	e1a01009	 mov         r1, r9
  00114	e1a0000a	 mov         r0, r10
  00118	eb000000	 bl          |?NewStream@DeviceContext@@QAAXPAVStreamContext@@@Z|

; 72   : 
; 73   :     DoCallbackStreamOpened();

  0011c	e5993000	 ldr         r3, [r9]
  00120	e1a00009	 mov         r0, r9
  00124	e5933024	 ldr         r3, [r3, #0x24]
  00128	e1a0e00f	 mov         lr, pc
  0012c	e12fff13	 bx          r3

; 74   : 
; 75   :     return S_OK;

  00130	e3a00000	 mov         r0, #0

; 76   : }

  00134	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$M37618|

			 ENDP  ; |?Open@StreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|, StreamContext::Open

	EXPORT	|?AddRef@StreamContext@@QAAJXZ|		; StreamContext::AddRef

  00000			 AREA	 |.pdata|, PDATA
|$T37630| DCD	|$LN5@AddRef|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AddRef@StreamContext@@QAAJXZ| PROC	; StreamContext::AddRef

; 110  : {

  00000		 |$LN5@AddRef|
  00000		 |$M37627|
  00000	e1a02000	 mov         r2, r0

; 111  :     LONG RefCount = ++m_RefCount;

  00004	e592300c	 ldr         r3, [r2, #0xC]
  00008	e2830001	 add         r0, r3, #1
  0000c	e582000c	 str         r0, [r2, #0xC]

; 112  : 
; 113  :     DEBUGMSG(ZONE_MDD, (TEXT("AddRef stream 0x%x, RefCount=%d\r\n"),this,RefCount));
; 114  : 
; 115  :     return RefCount;
; 116  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M37628|

			 ENDP  ; |?AddRef@StreamContext@@QAAJXZ|, StreamContext::AddRef

	EXPORT	|?Release@StreamContext@@QAAJXZ|	; StreamContext::Release
	IMPORT	|?DeleteStream@DeviceContext@@QAAXPAVStreamContext@@@Z| ; DeviceContext::DeleteStream

  00000			 AREA	 |.pdata|, PDATA
|$T37645| DCD	|$LN8@Release|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Release@StreamContext@@QAAJXZ| PROC	; StreamContext::Release

; 127  : {

  00000		 |$LN8@Release|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37642|
  00004	e1a04000	 mov         r4, r0

; 128  :     LONG RefCount = --m_RefCount;

  00008	e594300c	 ldr         r3, [r4, #0xC]
  0000c	e2433001	 sub         r3, r3, #1
  00010	e584300c	 str         r3, [r4, #0xC]
  00014	e1b05003	 movs        r5, r3

; 129  : 
; 130  : //    DEBUGMSG(ZONE_MDD, (TEXT("Releasing stream 0x%x, RefCount=%d\r\n"),this,RefCount));
; 131  :     if (RefCount==0)

  00018	1a000008	 bne         |$LN4@Release|

; 132  :     {
; 133  :         DEBUGMSG(ZONE_MDD, (TEXT("Deleting stream 0x%x\r\n"),this));
; 134  :         // Only remove stream from list when all refcounts are gone.
; 135  :         m_pDeviceContext->DeleteStream(this);

  0001c	e5940050	 ldr         r0, [r4, #0x50]
  00020	e1a01004	 mov         r1, r4
  00024	eb000000	 bl          |?DeleteStream@DeviceContext@@QAAXPAVStreamContext@@@Z|

; 136  :         delete this;

  00028	e5943000	 ldr         r3, [r4]
  0002c	e3a01001	 mov         r1, #1
  00030	e1a00004	 mov         r0, r4
  00034	e5933000	 ldr         r3, [r3]
  00038	e1a0e00f	 mov         lr, pc
  0003c	e12fff13	 bx          r3
  00040		 |$LN4@Release|

; 137  :     }
; 138  :     return RefCount;
; 139  : }

  00040	e1a00005	 mov         r0, r5
  00044	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$M37643|

			 ENDP  ; |?Release@StreamContext@@QAAJXZ|, StreamContext::Release

	EXPORT	|?QueueBuffer@StreamContext@@UAAKPAUwavehdr_tag@@@Z| ; StreamContext::QueueBuffer

  00000			 AREA	 |.pdata|, PDATA
|$T37656| DCD	|$LN11@QueueBuffe|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?QueueBuffer@StreamContext@@UAAKPAUwavehdr_tag@@@Z| PROC ; StreamContext::QueueBuffer

; 150  : {

  00000		 |$LN11@QueueBuffe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37653|
  00004	e1a0e001	 mov         lr, r1
  00008	e1a01000	 mov         r1, r0

; 151  :     if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))

  0000c	e59e3010	 ldr         r3, [lr, #0x10]
  00010	e3130002	 tst         r3, #2

; 152  :     {
; 153  :         return WAVERR_UNPREPARED;

  00014	03a00022	 moveq       r0, #0x22

; 192  : }

  00018	049de004	 ldreq       lr, [sp], #4
  0001c	012fff1e	 bxeq        lr

; 154  :     }
; 155  : 
; 156  :     lpWaveHdr->dwFlags |= WHDR_INQUEUE;
; 157  :     lpWaveHdr->dwFlags &= ~WHDR_DONE;

  00020	e3c33001	 bic         r3, r3, #1
  00024	e3833010	 orr         r3, r3, #0x10
  00028	e58e3010	 str         r3, [lr, #0x10]

; 158  :     lpWaveHdr->lpNext=NULL;

  0002c	e3a03000	 mov         r3, #0
  00030	e58e3018	 str         r3, [lr, #0x18]

; 159  :     lpWaveHdr->dwBytesRecorded=0;

  00034	e58e3008	 str         r3, [lr, #8]

; 160  : 
; 161  :     if (!m_lpWaveHdrHead)

  00038	e5913038	 ldr         r3, [r1, #0x38]
  0003c	e3530000	 cmp         r3, #0

; 162  :     {
; 163  :         m_lpWaveHdrHead = lpWaveHdr;

  00040	0581e038	 streq       lr, [r1, #0x38]

; 164  :     }
; 165  :     else
; 166  :     {
; 167  :         m_lpWaveHdrTail->lpNext=lpWaveHdr;

  00044	15913040	 ldrne       r3, [r1, #0x40]
  00048	1583e018	 strne       lr, [r3, #0x18]

; 168  :     }
; 169  : 
; 170  :     m_lpWaveHdrTail=lpWaveHdr;
; 171  : 
; 172  :     // Note: Even if head & tail are valid, current may be NULL if we're in the middle of
; 173  :     // a loop and ran out of data. So, we need to check specifically against current to
; 174  :     // decide if we need to initialize it.
; 175  :     if (!m_lpWaveHdrCurrent)

  0004c	e591303c	 ldr         r3, [r1, #0x3C]
  00050	e581e040	 str         lr, [r1, #0x40]
  00054	e3530000	 cmp         r3, #0
  00058	1a00000a	 bne         |$LN2@QueueBuffe|

; 176  :     {
; 177  :         m_lpWaveHdrCurrent = lpWaveHdr;

  0005c	e581e03c	 str         lr, [r1, #0x3C]

; 178  :         m_lpCurrData    = (PBYTE)lpWaveHdr->lpData;

  00060	e59e3000	 ldr         r3, [lr]
  00064	e5813044	 str         r3, [r1, #0x44]

; 179  :         m_lpCurrDataEnd = (PBYTE)lpWaveHdr->lpData + lpWaveHdr->dwBufferLength;

  00068	e59e2004	 ldr         r2, [lr, #4]
  0006c	e59e3000	 ldr         r3, [lr]
  00070	e0823003	 add         r3, r2, r3
  00074	e5813048	 str         r3, [r1, #0x48]

; 180  :         if (lpWaveHdr->dwFlags & WHDR_BEGINLOOP)    // if this is the start of a loop block

  00078	e59e3010	 ldr         r3, [lr, #0x10]
  0007c	e3130004	 tst         r3, #4

; 181  :         {
; 182  :             m_dwLoopCount = lpWaveHdr->dwLoops;     // save # of loops

  00080	159e3014	 ldrne       r3, [lr, #0x14]
  00084	15813054	 strne       r3, [r1, #0x54]
  00088		 |$LN2@QueueBuffe|

; 183  :         }
; 184  :     }
; 185  : 
; 186  :     if (m_bRunning)

  00088	e5913010	 ldr         r3, [r1, #0x10]
  0008c	e3530000	 cmp         r3, #0

; 187  :     {
; 188  :         m_pDeviceContext->StreamReadyToRender(this);

  00090	15910050	 ldrne       r0, [r1, #0x50]
  00094	15903000	 ldrne       r3, [r0]
  00098	1593300c	 ldrne       r3, [r3, #0xC]
  0009c	11a0e00f	 movne       lr, pc
  000a0	112fff13	 bxne        r3

; 189  :     }
; 190  : 
; 191  :     return MMSYSERR_NOERROR;

  000a4	e3a00000	 mov         r0, #0

; 192  : }

  000a8	e49de004	 ldr         lr, [sp], #4
  000ac	e12fff1e	 bx          lr
  000b0		 |$M37654|

			 ENDP  ; |?QueueBuffer@StreamContext@@UAAKPAUwavehdr_tag@@@Z|, StreamContext::QueueBuffer

	EXPORT	|?GetNextBuffer@StreamContext@@QAAPAEXZ| ; StreamContext::GetNextBuffer
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37671| DCD	|$LN19@GetNextBuf|
	DCD	0x40003701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetNextBuffer@StreamContext@@QAAPAEXZ| PROC ; StreamContext::GetNextBuffer

; 215  : {

  00000		 |$LN19@GetNextBuf|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37668|
  00004	e1a04000	 mov         r4, r0

; 216  :     LPWAVEHDR lpOldHdr;
; 217  :     LPWAVEHDR lpNewHdr;
; 218  :     LPSTR pNewBuf=NULL;
; 219  : 
; 220  :     // Get a pointer to the current buffer which is now done being processed
; 221  :     lpOldHdr=m_lpWaveHdrCurrent;

  00008	e594303c	 ldr         r3, [r4, #0x3C]
  0000c	e1b00003	 movs        r0, r3

; 222  : 
; 223  :     if (!lpOldHdr)
; 224  :     {
; 225  :         return NULL;

  00010	03a00000	 moveq       r0, #0

; 290  : }

  00014	08bd4010	 ldmeqia     sp!, {r4, lr}
  00018	012fff1e	 bxeq        lr

; 226  :     }
; 227  : 
; 228  :     // Are we in a loop
; 229  :     // Note: a loopcount of 1 means we're not really in a loop
; 230  :     if (m_dwLoopCount>1)

  0001c	e5942054	 ldr         r2, [r4, #0x54]
  00020	e3a0e000	 mov         lr, #0
  00024	e3520001	 cmp         r2, #1
  00028	9a00000b	 bls         |$LN11@GetNextBuf|

; 231  :     {
; 232  :         // We're in a loop!
; 233  :         if (lpOldHdr->dwFlags & WHDR_ENDLOOP)

  0002c	e5903010	 ldr         r3, [r0, #0x10]
  00030	e3130008	 tst         r3, #8
  00034	0a000005	 beq         |$LN10@GetNextBuf|

; 234  :         {
; 235  :            // In loop, last buffer
; 236  :             // If dwLoopCount was set to INFINITE, loop forever
; 237  :             // (Note: this is not explicitly in the wave driver API spec)
; 238  :             if (m_dwLoopCount!=INFINITE)

  00038	e3720001	 cmn         r2, #1

; 239  :             {
; 240  :            m_dwLoopCount--;                    // decrement loop count

  0003c	12423001	 subne       r3, r2, #1

; 241  :             }
; 242  :            lpNewHdr=m_lpWaveHdrHead;           // go back to start of loop

  00040	e5941038	 ldr         r1, [r4, #0x38]
  00044	15843054	 strne       r3, [r4, #0x54]

; 248  :         }
; 249  : 
; 250  :         lpOldHdr=NULL;

  00048	e3a00000	 mov         r0, #0

; 251  :     }
; 252  :     else

  0004c	ea00000a	 b           |$LN4@GetNextBuf|
  00050		 |$LN10@GetNextBuf|

; 243  :         }
; 244  :         else
; 245  :         {
; 246  :            // In loop, intermediate buffer
; 247  :            lpNewHdr=lpOldHdr->lpNext;          // just go to next buffer in loop block

  00050	e5901018	 ldr         r1, [r0, #0x18]

; 248  :         }
; 249  : 
; 250  :         lpOldHdr=NULL;

  00054	e3a00000	 mov         r0, #0

; 251  :     }
; 252  :     else

  00058	ea000007	 b           |$LN4@GetNextBuf|
  0005c		 |$LN11@GetNextBuf|

; 253  :     {
; 254  :         // Not in a loop; return old buffer and get new buffer
; 255  :         lpNewHdr=lpOldHdr->lpNext;

  0005c	e5903018	 ldr         r3, [r0, #0x18]
  00060	e1b01003	 movs        r1, r3

; 256  : 
; 257  :         m_lpWaveHdrHead = lpNewHdr;           // reset list head

  00064	e5841038	 str         r1, [r4, #0x38]

; 258  :         if (!lpNewHdr)
; 259  :         {
; 260  :             m_lpWaveHdrTail=NULL;             // no new buffer, reset tail to NULL

  00068	0584e040	 streq       lr, [r4, #0x40]

; 261  :         }
; 262  :         else if (lpNewHdr->dwFlags & WHDR_BEGINLOOP)    // if new buffer is start of a loop block

  0006c	15913010	 ldrne       r3, [r1, #0x10]
  00070	13130004	 tstne       r3, #4

; 263  :         {
; 264  :             m_dwLoopCount=lpNewHdr->dwLoops;  // save # of loops

  00074	15913014	 ldrne       r3, [r1, #0x14]
  00078	15843054	 strne       r3, [r4, #0x54]
  0007c		 |$LN4@GetNextBuf|

; 265  :         }
; 266  :     }
; 267  : 
; 268  :     m_lpWaveHdrCurrent=lpNewHdr;              // save current buffer pointer
; 269  : 
; 270  :     if (lpNewHdr)

  0007c	e3510000	 cmp         r1, #0
  00080	e584103c	 str         r1, [r4, #0x3C]

; 271  :     {
; 272  :         m_lpCurrData    = (PBYTE)lpNewHdr->lpData;  // reinitialize data pointer

  00084	15912000	 ldrne       r2, [r1]
  00088	15842044	 strne       r2, [r4, #0x44]

; 273  :         m_lpCurrDataEnd = m_lpCurrData + lpNewHdr->dwBufferLength;

  0008c	15913004	 ldrne       r3, [r1, #4]

; 274  :     }
; 275  :     else
; 276  :     {
; 277  :         m_lpCurrData  = NULL;

  00090	0584e044	 streq       lr, [r4, #0x44]
  00094	10833002	 addne       r3, r3, r2
  00098	15843048	 strne       r3, [r4, #0x48]

; 278  :         m_lpCurrDataEnd = NULL;

  0009c	0584e048	 streq       lr, [r4, #0x48]

; 279  :     }
; 280  : 
; 281  :     // Return the old buffer
; 282  :     // This may cause the stream to be destroyed, so make sure that any calls to this function
; 283  :     // are within an AddRef/Release block
; 284  :     if (lpOldHdr)

  000a0	e3500000	 cmp         r0, #0
  000a4	0a000009	 beq         |$LN15@GetNextBuf|

; 285  :     {
; 286  :         ReturnBuffer(lpOldHdr);

  000a8	e5903010	 ldr         r3, [r0, #0x10]
  000ac	e1a01000	 mov         r1, r0
  000b0	e3c33010	 bic         r3, r3, #0x10
  000b4	e3833001	 orr         r3, r3, #1
  000b8	e5803010	 str         r3, [r0, #0x10]
  000bc	e5943000	 ldr         r3, [r4]
  000c0	e1a00004	 mov         r0, r4
  000c4	e5933020	 ldr         r3, [r3, #0x20]
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff13	 bx          r3
  000d0		 |$LN15@GetNextBuf|

; 287  :     }
; 288  : 
; 289  :     return m_lpCurrData;

  000d0	e5940044	 ldr         r0, [r4, #0x44]

; 290  : }

  000d4	e8bd4010	 ldmia       sp!, {r4, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$M37669|

			 ENDP  ; |?GetNextBuffer@StreamContext@@QAAPAEXZ|, StreamContext::GetNextBuffer

	EXPORT	|?BreakLoop@StreamContext@@QAAKXZ|	; StreamContext::BreakLoop
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37693| DCD	|$LN17@BreakLoop|
	DCD	0x40002301
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?BreakLoop@StreamContext@@QAAKXZ| PROC ; StreamContext::BreakLoop

; 301  : {

  00000		 |$LN17@BreakLoop|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37690|
  00004	e1a04000	 mov         r4, r0

; 302  :     AddRef();

  00008	e594300c	 ldr         r3, [r4, #0xC]

; 303  : 
; 304  :     if (m_dwLoopCount>0)

  0000c	e5942054	 ldr         r2, [r4, #0x54]
  00010	e2833001	 add         r3, r3, #1
  00014	e584300c	 str         r3, [r4, #0xC]
  00018	e3520000	 cmp         r2, #0
  0001c	9a000015	 bls         |$LN2@BreakLoop|

; 305  :     {
; 306  :         m_dwLoopCount = 0;
; 307  : 
; 308  :         LPWAVEHDR lpHdr;
; 309  :         while (m_lpWaveHdrHead!=m_lpWaveHdrCurrent)

  00020	e3a05000	 mov         r5, #0
  00024	e5845054	 str         r5, [r4, #0x54]
  00028	ea00000e	 b           |$LN14@BreakLoop|
  0002c		 |$LL3@BreakLoop|

; 310  :         {
; 311  :             lpHdr = m_lpWaveHdrHead;

  0002c	e5942038	 ldr         r2, [r4, #0x38]

; 312  :             m_lpWaveHdrHead = lpHdr->lpNext;
; 313  :             if (m_lpWaveHdrHead==NULL)
; 314  :             {
; 315  :                 m_lpWaveHdrTail=NULL;
; 316  :             }
; 317  :             ReturnBuffer(lpHdr);

  00030	e1a00004	 mov         r0, r4
  00034	e5923018	 ldr         r3, [r2, #0x18]
  00038	e1a01002	 mov         r1, r2
  0003c	e3530000	 cmp         r3, #0
  00040	05845040	 streq       r5, [r4, #0x40]
  00044	e5843038	 str         r3, [r4, #0x38]
  00048	e5923010	 ldr         r3, [r2, #0x10]
  0004c	e3c33010	 bic         r3, r3, #0x10
  00050	e3833001	 orr         r3, r3, #1
  00054	e5823010	 str         r3, [r2, #0x10]
  00058	e5943000	 ldr         r3, [r4]
  0005c	e5933020	 ldr         r3, [r3, #0x20]
  00060	e1a0e00f	 mov         lr, pc
  00064	e12fff13	 bx          r3
  00068		 |$LN14@BreakLoop|
  00068	e594303c	 ldr         r3, [r4, #0x3C]
  0006c	e5942038	 ldr         r2, [r4, #0x38]
  00070	e1520003	 cmp         r2, r3
  00074	1affffec	 bne         |$LL3@BreakLoop|
  00078		 |$LN2@BreakLoop|

; 318  :         }
; 319  :     }
; 320  : 
; 321  :     Release();

  00078	e1a00004	 mov         r0, r4
  0007c	eb000000	 bl          |?Release@StreamContext@@QAAJXZ|

; 322  : 
; 323  :     return MMSYSERR_NOERROR;

  00080	e3a00000	 mov         r0, #0

; 324  : }

  00084	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M37691|

			 ENDP  ; |?BreakLoop@StreamContext@@QAAKXZ|, StreamContext::BreakLoop

	EXPORT	|?MapGain@StreamContext@@QAAKK@Z|	; StreamContext::MapGain
	IMPORT	|?g_pHWContext@@3PAVHardwareContext@@A|	; g_pHWContext
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\hwctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37729| DCD	|$LN24@MapGain|
	DCD	0x40003001
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MapGain@StreamContext@@QAAKK@Z| PROC	; StreamContext::MapGain

; 560  : {

  00000		 |$LN24@MapGain|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37726|

; 561  :     // Get correct stream gain based on channel
; 562  :     StreamGain &= 0xFFFF;
; 563  : 
; 564  :     // Get Device gain
; 565  :     DWORD DeviceGain;
; 566  :     if (m_SecondaryGainClass >= SECONDARYDEVICEGAINCLASSMAX)

  00004	e590e05c	 ldr         lr, [r0, #0x5C]
  00008	e3a03cff	 mov         r3, #0xFF, 24
  0000c	e38320ff	 orr         r2, r3, #0xFF
  00010	e35e0002	 cmp         lr, #2

; 567  :     {
; 568  :         DeviceGain = 0xFFFF;
; 569  :     }
; 570  :     else
; 571  :     {
; 572  :         // Apply device gain
; 573  :         DeviceGain = m_pDeviceContext->GetGain();
; 574  :         DeviceGain &= 0xFFFF;

  00014	35903050	 ldrcc       r3, [r0, #0x50]
  00018	e0015002	 and         r5, r1, r2
  0001c	21a01002	 movcs       r1, r2
  00020	3593300c	 ldrcc       r3, [r3, #0xC]
  00024	30031002	 andcc       r1, r3, r2

; 575  :     }
; 576  : 
; 577  :     // Get Secondary gain
; 578  :     DWORD SecondaryGain;
; 579  :     SecondaryGain = m_pDeviceContext->GetSecondaryGainLimit(m_SecondaryGainClass);
; 580  :     SecondaryGain &= 0xFFFF; // For now, only use lowest 16 bits for both channels

  00028	e5903050	 ldr         r3, [r0, #0x50]

; 581  : 
; 582  :     DWORD fGainMultiplier;
; 583  : 
; 584  :     // Special handling- if any gain is totally 0, mute the output
; 585  :     if ((StreamGain==0) || (DeviceGain==0) || (SecondaryGain==0))

  0002c	e3550000	 cmp         r5, #0
  00030	e083310e	 add         r3, r3, lr, lsl #2
  00034	e5933014	 ldr         r3, [r3, #0x14]
  00038	e0030002	 and         r0, r3, r2
  0003c	0a00001a	 beq         |$LN6@MapGain|
  00040	e3510000	 cmp         r1, #0
  00044	0a000018	 beq         |$LN6@MapGain|
  00048	e3500000	 cmp         r0, #0
  0004c	0a000016	 beq         |$LN6@MapGain|

; 588  :     }
; 589  :     else
; 590  :     {
; 591  :         // Now calculate attenuation of each in dB using appropriate ranges
; 592  : 
; 593  :         // Stream volume is normalized to the range from 0 to -100 dB
; 594  :         // Device and secondary gain are normalized from 0 to -35 dB
; 595  :         // These can be modified in hwctxt.h
; 596  : 
; 597  :         DWORD dBAttenStream, dBAttenDevice, dBAttenSecondary, dBAttenTotal;
; 598  : 
; 599  :         dBAttenStream    = ((0xFFFF - StreamGain)    * 
; 600  :             g_pHWContext->GetStreamAttenMax());

  00050	e59f3064	 ldr         r3, [pc, #0x64]

; 601  :         dBAttenDevice    = ((0xFFFF - DeviceGain)    * 
; 602  :             g_pHWContext->GetDeviceAttenMax());
; 603  :         dBAttenSecondary = ((0xFFFF - SecondaryGain) * 
; 604  :             g_pHWContext->GetSecondAttenMax());

  00054	e0614002	 rsb         r4, r1, r2
  00058	e060e002	 rsb         lr, r0, r2
  0005c	e5931000	 ldr         r1, [r3]
  00060	e0650002	 rsb         r0, r5, r2
  00064	e59130e8	 ldr         r3, [r1, #0xE8]
  00068	e59120e4	 ldr         r2, [r1, #0xE4]
  0006c	e59110e0	 ldr         r1, [r1, #0xE0]

; 605  : 
; 606  :         // Add together
; 607  :         dBAttenTotal = dBAttenStream + dBAttenDevice + dBAttenSecondary;
; 608  : 
; 609  :         // Multiply result by 2 for .5 dB steps in the table
; 610  :         dBAttenTotal *= 2;
; 611  : 
; 612  :         // Round up to account for rounding errors in lower 16 bits
; 613  :         dBAttenTotal += 0x8000;
; 614  : 
; 615  :         // Now shift back to the lowest 16 bits to get an index into the table
; 616  :         dBAttenTotal >>= 16;

  00070	e003039e	 mul         r3, lr, r3
  00074	e0233294	 mla         r3, r4, r2, r3
  00078	e0233190	 mla         r3, r0, r1, r3
  0007c	e2833901	 add         r3, r3, #1, 18
  00080	e1a03083	 mov         r3, r3, lsl #1
  00084	e1b02823	 movs        r2, r3, lsr #16

; 617  : 
; 618  :         // dBAttenTotal should range from 0 to something like 340 (if all terms were close to 0)
; 619  : 
; 620  :         // Special case 0 as totally muted. The table starts at -.5dB, rather than 0dB, since
; 621  :         // 0dB would take more than the 16-bits we allowed per entry.
; 622  :         if (dBAttenTotal==0)
; 623  :         {
; 624  :             fGainMultiplier = 0x10000;

  00088	03a00801	 moveq       r0, #1, 16

; 633  :         }
; 634  :     }
; 635  : 
; 636  :     return fGainMultiplier;
; 637  : }

  0008c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00090	012fff1e	 bxeq        lr

; 625  :         }
; 626  :         else if (dBAttenTotal>200)

  00094	e35200c8	 cmp         r2, #0xC8

; 627  :         {
; 628  :             fGainMultiplier = 0;
; 629  :         }
; 630  :         else
; 631  :         {
; 632  :             fGainMultiplier = (DWORD)GainMap[dBAttenTotal-1];

  00098	959f3018	 ldrls       r3, [pc, #0x18]
  0009c	90833082	 addls       r3, r3, r2, lsl #1
  000a0	915300b2	 ldrlsh      r0, [r3, #-2]

; 633  :         }
; 634  :     }
; 635  : 
; 636  :     return fGainMultiplier;
; 637  : }

  000a4	98bd4030	 ldmlsia     sp!, {r4, r5, lr}
  000a8	912fff1e	 bxls        lr
  000ac		 |$LN6@MapGain|

; 586  :     {
; 587  :         fGainMultiplier = 0;

  000ac	e3a00000	 mov         r0, #0

; 633  :         }
; 634  :     }
; 635  : 
; 636  :     return fGainMultiplier;
; 637  : }

  000b0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN25@MapGain|
  000b8		 |$LN26@MapGain|
  000b8	00000000	 DCD         |GainMap|
  000bc		 |$LN27@MapGain|
  000bc	00000000	 DCD         |?g_pHWContext@@3PAVHardwareContext@@A|
  000c0		 |$M37727|

			 ENDP  ; |?MapGain@StreamContext@@QAAKK@Z|, StreamContext::MapGain

	EXPORT	|?GetPos@StreamContext@@UAAKPAUmmtime_tag@@@Z| ; StreamContext::GetPos
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T37746| DCD	|$LN14@GetPos|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetPos@StreamContext@@UAAKPAUmmtime_tag@@@Z| PROC ; StreamContext::GetPos

; 648  : {

  00000		 |$LN14@GetPos|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M37743|
  00004	e1a05001	 mov         r5, r1
  00008	e1a06000	 mov         r6, r0

; 649  :     switch (pmmt->wType)

  0000c	e5d54000	 ldrb        r4, [r5]
  00010	e5d53001	 ldrb        r3, [r5, #1]
  00014	e5d52002	 ldrb        r2, [r5, #2]
  00018	e5d5e003	 ldrb        lr, [r5, #3]
  0001c	e1843403	 orr         r3, r4, r3, lsl #8
  00020	e1833802	 orr         r3, r3, r2, lsl #16
  00024	e1833c0e	 orr         r3, r3, lr, lsl #24
  00028	e3530001	 cmp         r3, #1
  0002c	0a00001f	 beq         |$LN4@GetPos|
  00030	e3530002	 cmp         r3, #2
  00034	0a000012	 beq         |$LN5@GetPos|
  00038	e3530004	 cmp         r3, #4
  0003c	0a000005	 beq         |$LN1@GetPos|
  00040		 |$LN3@GetPos|

; 661  :             break;
; 662  :         }
; 663  :         // If we don't know avg bytes per sec, fall through to TIME_BYTES
; 664  : 
; 665  :     default:
; 666  :         // Anything else, return TIME_BYTES instead.
; 667  :         pmmt->wType = TIME_BYTES;

  00040	e3a03004	 mov         r3, #4
  00044	e5c53000	 strb        r3, [r5]
  00048	e3a03000	 mov         r3, #0
  0004c	e5c53001	 strb        r3, [r5, #1]
  00050	e5c53002	 strb        r3, [r5, #2]
  00054	e5c53003	 strb        r3, [r5, #3]
  00058		 |$LN1@GetPos|

; 668  : 
; 669  :         // Fall through to TIME_BYTES
; 670  :     case TIME_BYTES:
; 671  :         pmmt->u.cb = m_dwByteCount;

  00058	e596004c	 ldr         r0, [r6, #0x4C]
  0005c		 |$LN10@GetPos|
  0005c	e1a03420	 mov         r3, r0, lsr #8
  00060	e1a02820	 mov         r2, r0, lsr #16
  00064	e1a01c20	 mov         r1, r0, lsr #24
  00068	e5c50004	 strb        r0, [r5, #4]
  0006c	e5c53005	 strb        r3, [r5, #5]
  00070	e5c52006	 strb        r2, [r5, #6]
  00074	e5c51007	 strb        r1, [r5, #7]

; 672  :     }
; 673  : 
; 674  :     return MMSYSERR_NOERROR;

  00078	e3a00000	 mov         r0, #0

; 675  : }

  0007c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN5@GetPos|

; 650  :     {
; 651  : 
; 652  :     case TIME_SAMPLES:
; 653  :         pmmt->u.sample = (m_dwByteCount * 8) /
; 654  :                          (m_WaveFormat.nChannels * m_WaveFormat.wBitsPerSample);

  00084	e5d61032	 ldrb        r1, [r6, #0x32]
  00088	e5d63033	 ldrb        r3, [r6, #0x33]
  0008c	e5d60026	 ldrb        r0, [r6, #0x26]
  00090	e5d62027	 ldrb        r2, [r6, #0x27]
  00094	e181e403	 orr         lr, r1, r3, lsl #8
  00098	e596304c	 ldr         r3, [r6, #0x4C]
  0009c	e1802402	 orr         r2, r0, r2, lsl #8
  000a0	e000029e	 mul         r0, lr, r2
  000a4	e1a01183	 mov         r1, r3, lsl #3
  000a8	eb000000	 bl          __rt_udiv

; 655  :         break;

  000ac	eaffffea	 b           |$LN10@GetPos|
  000b0		 |$LN4@GetPos|

; 656  : 
; 657  :     case TIME_MS:
; 658  :         if (m_WaveFormat.nAvgBytesPerSec != 0)

  000b0	e5d6002c	 ldrb        r0, [r6, #0x2C]
  000b4	e5d6302d	 ldrb        r3, [r6, #0x2D]
  000b8	e5d6202e	 ldrb        r2, [r6, #0x2E]
  000bc	e5d6102f	 ldrb        r1, [r6, #0x2F]
  000c0	e1803403	 orr         r3, r0, r3, lsl #8
  000c4	e1833802	 orr         r3, r3, r2, lsl #16
  000c8	e1930c01	 orrs        r0, r3, r1, lsl #24
  000cc	0affffdb	 beq         |$LN3@GetPos|

; 659  :         {
; 660  :             pmmt->u.ms = (m_dwByteCount * 1000) / m_WaveFormat.nAvgBytesPerSec;

  000d0	e596304c	 ldr         r3, [r6, #0x4C]
  000d4	e3a02ffa	 mov         r2, #0xFA, 30
  000d8	e0010293	 mul         r1, r3, r2
  000dc	eb000000	 bl          __rt_udiv
  000e0	eaffffdd	 b           |$LN10@GetPos|
  000e4		 |$M37744|

			 ENDP  ; |?GetPos@StreamContext@@UAAKPAUmmtime_tag@@@Z|, StreamContext::GetPos

	EXPORT	|?Open@WaveStreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| ; WaveStreamContext::Open

  00000			 AREA	 |.pdata|, PDATA
|$T37764| DCD	|$LN19@Open@2|
	DCD	0x40002f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Open@WaveStreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z| PROC ; WaveStreamContext::Open

; 686  : {

  00000		 |$LN19@Open@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37761|
  00004	e1a04000	 mov         r4, r0

; 687  :     HRESULT Result;
; 688  :     Result = StreamContext::Open(pDeviceContext,lpWOD,dwFlags);

  00008	eb000000	 bl          |?Open@StreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|
  0000c	e3500000	 cmp         r0, #0

; 689  :     if (FAILED(Result))
; 690  :     {
; 691  :         return Result;

  00010	4a000027	 bmi         |$LN11@Open@2|

; 692  :     }
; 693  : 
; 694  :     if (m_WaveFormat.wBitsPerSample == 8)

  00014	e5d42032	 ldrb        r2, [r4, #0x32]
  00018	e5d43033	 ldrb        r3, [r4, #0x33]
  0001c	e3a05000	 mov         r5, #0
  00020	e1823403	 orr         r3, r2, r3, lsl #8

; 695  :     {
; 696  :         if (m_WaveFormat.nChannels == 1)

  00024	e5d42026	 ldrb        r2, [r4, #0x26]
  00028	e3530008	 cmp         r3, #8
  0002c	e5d43027	 ldrb        r3, [r4, #0x27]
  00030	e1823403	 orr         r3, r2, r3, lsl #8
  00034	1a000007	 bne         |$LN9@Open@2|
  00038	e3530001	 cmp         r3, #1

; 697  :         {
; 698  :             m_SampleType = PCM_TYPE_M8;
; 699  :             m_SampleSize = 1;

  0003c	03a03001	 moveq       r3, #1
  00040	0584306c	 streq       r3, [r4, #0x6C]
  00044	05845068	 streq       r5, [r4, #0x68]
  00048	0a000009	 beq         |$LN4@Open@2|

; 700  :         }
; 701  :         else
; 702  :         {
; 703  :             m_SampleType = PCM_TYPE_S8;

  0004c	e3a03002	 mov         r3, #2

; 704  :             m_SampleSize = 2;

  00050	e584306c	 str         r3, [r4, #0x6C]

; 705  :         }
; 706  :     }
; 707  :     else

  00054	ea000005	 b           |$LN15@Open@2|
  00058		 |$LN9@Open@2|

; 708  :     {
; 709  :         if (m_WaveFormat.nChannels == 1)

  00058	e3530001	 cmp         r3, #1

; 710  :         {
; 711  :             m_SampleType = PCM_TYPE_M16;
; 712  :             m_SampleSize = 2;

  0005c	03a02002	 moveq       r2, #2

; 713  :         }
; 714  :         else
; 715  :         {
; 716  :             m_SampleType = PCM_TYPE_S16;
; 717  :             m_SampleSize = 4;

  00060	13a02004	 movne       r2, #4
  00064	03a03001	 moveq       r3, #1
  00068	e584206c	 str         r2, [r4, #0x6C]
  0006c	13a03003	 movne       r3, #3
  00070		 |$LN15@Open@2|
  00070	e5843068	 str         r3, [r4, #0x68]
  00074		 |$LN4@Open@2|

; 718  :         }
; 719  :     }
; 720  : 
; 721  :     SetRate(0x10000);

  00074	e5943000	 ldr         r3, [r4]
  00078	e3a01801	 mov         r1, #1, 16
  0007c	e1a00004	 mov         r0, r4
  00080	e5933034	 ldr         r3, [r3, #0x34]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3
  0008c	e1a03004	 mov         r3, r4
  00090	e3a02002	 mov         r2, #2
  00094		 |$LL3@Open@2|

; 722  : 
; 723  :     int i;
; 724  :     for (i=0;i<OUTCHANNELS;i++)
; 725  :     {
; 726  :         m_PrevSamp[i] = 0;

  00094	e5835078	 str         r5, [r3, #0x78]

; 727  :         m_CurrSamp[i] = 0;

  00098	e5835080	 str         r5, [r3, #0x80]
  0009c	e2833004	 add         r3, r3, #4
  000a0	e2522001	 subs        r2, r2, #1
  000a4	1afffffa	 bne         |$LL3@Open@2|

; 728  :     }
; 729  :     m_CurrT    = 0x200;   // Initializing to this ensures we get the 1st sample.

  000a8	e3a03c02	 mov         r3, #2, 24
  000ac	e5843088	 str         r3, [r4, #0x88]

; 730  : 
; 731  :     return S_OK;

  000b0	e3a00000	 mov         r0, #0
  000b4		 |$LN11@Open@2|

; 732  : }

  000b4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M37762|

			 ENDP  ; |?Open@WaveStreamContext@@UAAJPAVDeviceContext@@PAUwaveopendesc_tag@@K@Z|, WaveStreamContext::Open

	EXPORT	|?GetRate@WaveStreamContext@@QAAKPAK@Z|	; WaveStreamContext::GetRate

  00000			 AREA	 |.pdata|, PDATA
|$T37775| DCD	|$LN5@GetRate|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRate@WaveStreamContext@@QAAKPAK@Z| PROC ; WaveStreamContext::GetRate

; 742  : {

  00000		 |$LN5@GetRate|
  00000		 |$M37772|

; 743  :     *pdwMultiplier = m_dwMultiplier;

  00000	e5903074	 ldr         r3, [r0, #0x74]

; 744  :     return MMSYSERR_NOERROR;

  00004	e3a00000	 mov         r0, #0
  00008	e5813000	 str         r3, [r1]

; 745  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M37773|

			 ENDP  ; |?GetRate@WaveStreamContext@@QAAKPAK@Z|, WaveStreamContext::GetRate

	EXPORT	|?Run@StreamContext@@UAAKXZ|		; StreamContext::Run

  00000			 AREA	 |.pdata|, PDATA
|$T37785| DCD	|$LN6@Run|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Run@StreamContext@@UAAKXZ| PROC	; StreamContext::Run

; 755  : {

  00000		 |$LN6@Run|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37782|
  00004	e1a01000	 mov         r1, r0

; 756  :     m_bRunning=TRUE;
; 757  :     if (m_lpCurrData)

  00008	e5913044	 ldr         r3, [r1, #0x44]
  0000c	e3a02001	 mov         r2, #1
  00010	e5812010	 str         r2, [r1, #0x10]
  00014	e3530000	 cmp         r3, #0

; 758  :     {
; 759  :         m_pDeviceContext->StreamReadyToRender(this);

  00018	15910050	 ldrne       r0, [r1, #0x50]
  0001c	15903000	 ldrne       r3, [r0]
  00020	1593300c	 ldrne       r3, [r3, #0xC]
  00024	11a0e00f	 movne       lr, pc
  00028	112fff13	 bxne        r3

; 760  :     }
; 761  : 
; 762  :     return MMSYSERR_NOERROR;

  0002c	e3a00000	 mov         r0, #0

; 763  : }

  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$M37783|

			 ENDP  ; |?Run@StreamContext@@UAAKXZ|, StreamContext::Run

	EXPORT	|?Stop@StreamContext@@UAAKXZ|		; StreamContext::Stop

  00000			 AREA	 |.pdata|, PDATA
|$T37795| DCD	|$LN5@Stop|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Stop@StreamContext@@UAAKXZ| PROC	; StreamContext::Stop

; 772  : {

  00000		 |$LN5@Stop|
  00000		 |$M37792|

; 773  :     m_bRunning=FALSE;

  00000	e3a03000	 mov         r3, #0
  00004	e5803010	 str         r3, [r0, #0x10]

; 774  :     return MMSYSERR_NOERROR;

  00008	e3a00000	 mov         r0, #0

; 775  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M37793|

			 ENDP  ; |?Stop@StreamContext@@UAAKXZ|, StreamContext::Stop

	EXPORT	|?Reset@StreamContext@@UAAKXZ|		; StreamContext::Reset
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37817| DCD	|$LN16@Reset|
	DCD	0x40002701
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\strmctxt.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Reset@StreamContext@@UAAKXZ| PROC	; StreamContext::Reset

; 784  : {

  00000		 |$LN16@Reset|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M37814|
  00004	e1a04000	 mov         r4, r0

; 785  :     AddRef();
; 786  : 
; 787  :     // Stop stream for now.
; 788  :     Stop();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e594200c	 ldr         r2, [r4, #0xC]
  00010	e5931014	 ldr         r1, [r3, #0x14]
  00014	e2823001	 add         r3, r2, #1
  00018	e584300c	 str         r3, [r4, #0xC]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff11	 bx          r1

; 789  : 
; 790  :     m_lpWaveHdrCurrent  = NULL;
; 791  :     m_lpCurrData       = NULL;
; 792  :     m_lpCurrDataEnd    = NULL;
; 793  :     m_dwByteCount      = 0;
; 794  :     m_dwLoopCount      = 0;
; 795  : 
; 796  :     LPWAVEHDR lpHdr;
; 797  :     while (m_lpWaveHdrHead)

  00024	e3a05000	 mov         r5, #0
  00028	e584503c	 str         r5, [r4, #0x3C]
  0002c	e5845044	 str         r5, [r4, #0x44]
  00030	e5845048	 str         r5, [r4, #0x48]
  00034	e584504c	 str         r5, [r4, #0x4C]
  00038	e5845054	 str         r5, [r4, #0x54]
  0003c	ea00000e	 b           |$LN13@Reset|
  00040		 |$LL3@Reset|

; 798  :     {
; 799  :         lpHdr = m_lpWaveHdrHead;

  00040	e5942038	 ldr         r2, [r4, #0x38]

; 800  :         m_lpWaveHdrHead = lpHdr->lpNext;
; 801  :         if (m_lpWaveHdrHead==NULL)
; 802  :         {
; 803  :             m_lpWaveHdrTail=NULL;
; 804  :         }
; 805  :         ReturnBuffer(lpHdr);

  00044	e1a00004	 mov         r0, r4
  00048	e5923018	 ldr         r3, [r2, #0x18]
  0004c	e1a01002	 mov         r1, r2
  00050	e3530000	 cmp         r3, #0
  00054	05845040	 streq       r5, [r4, #0x40]
  00058	e5843038	 str         r3, [r4, #0x38]
  0005c	e5923010	 ldr         r3, [r2, #0x10]
  00060	e3c33010	 bic         r3, r3, #0x10
  00064	e3833001	 orr         r3, r3, #1
  00068	e5823010	 str         r3, [r2, #0x10]
  0006c	e5943000	 ldr         r3, [r4]
  00070	e5933020	 ldr         r3, [r3, #0x20]
  00074	e1a0e00f	 mov         lr, pc
  00078	e12fff13	 bx          r3
  0007c		 |$LN13@Reset|
  0007c	e5943038	 ldr         r3, [r4, #0x38]
  00080	e3530000	 cmp         r3, #0
  00084	1affffed	 bne         |$LL3@Reset|

; 806  :     }
; 807  : 
; 808  :     Release();

  00088	e1a00004	 mov         r0, r4
  0008c	eb000000	 bl          |?Release@StreamContext@@QAAJXZ|

; 809  : 
; 810  :     return MMSYSERR_NOERROR;

  00090	e3a00000	 mov         r0, #0

; 811  : }

  00094	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$M37815|

			 ENDP  ; |?Reset@StreamContext@@UAAKXZ|, StreamContext::Reset

	EXPORT	|?ForceSpeaker@StreamContext@@QAAKH@Z|	; StreamContext::ForceSpeaker
	IMPORT	|?ForceSpeaker@HardwareContext@@QAAKH@Z| ; HardwareContext::ForceSpeaker

  00000			 AREA	 |.pdata|, PDATA
|$T37831| DCD	|$LN8@ForceSpeak|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ForceSpeaker@StreamContext@@QAAKH@Z| PROC ; StreamContext::ForceSpeaker

; 820  : {

  00000		 |$LN8@ForceSpeak|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37828|
  00004	e3510000	 cmp         r1, #0

; 821  :     // Normalize to 0 or 1
; 822  :     bForceSpeaker = (bForceSpeaker!=0);
; 823  :     if (bForceSpeaker==m_bForceSpeaker)

  00008	e5903064	 ldr         r3, [r0, #0x64]
  0000c	13a01001	 movne       r1, #1
  00010	03a01000	 moveq       r1, #0
  00014	e1510003	 cmp         r1, r3

; 824  :     {
; 825  :         return MMSYSERR_NOERROR;

  00018	03a00000	 moveq       r0, #0

; 829  : }

  0001c	049de004	 ldreq       lr, [sp], #4
  00020	012fff1e	 bxeq        lr

; 826  :     }
; 827  :     m_bForceSpeaker = bForceSpeaker;
; 828  :     return g_pHWContext->ForceSpeaker(bForceSpeaker);

  00024	e59f3010	 ldr         r3, [pc, #0x10]
  00028	e5801064	 str         r1, [r0, #0x64]
  0002c	e5930000	 ldr         r0, [r3]
  00030	eb000000	 bl          |?ForceSpeaker@HardwareContext@@QAAKH@Z|

; 829  : }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN9@ForceSpeak|
  0003c		 |$LN10@ForceSpeak|
  0003c	00000000	 DCD         |?g_pHWContext@@3PAVHardwareContext@@A|
  00040		 |$M37829|

			 ENDP  ; |?ForceSpeaker@StreamContext@@QAAKH@Z|, StreamContext::ForceSpeaker

	EXPORT	|?Close@StreamContext@@UAAKXZ|		; StreamContext::Close

  00000			 AREA	 |.pdata|, PDATA
|$T37860| DCD	|$LN16@Close|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Close@StreamContext@@UAAKXZ| PROC	; StreamContext::Close

; 86   : {

  00000		 |$LN16@Close|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37857|
  00004	e1a04000	 mov         r4, r0

; 87   :     if (StillPlaying())

  00008	e5943038	 ldr         r3, [r4, #0x38]
  0000c	e3530000	 cmp         r3, #0

; 88   :     {
; 89   :         return WAVERR_STILLPLAYING;

  00010	13a00021	 movne       r0, #0x21

; 100  : }

  00014	18bd4010	 ldmneia     sp!, {r4, lr}
  00018	112fff1e	 bxne        lr

; 90   :     }
; 91   : 
; 92   :     // Be sure to turn off speaker if we turned it on.
; 93   :     ForceSpeaker(FALSE);

  0001c	e5943064	 ldr         r3, [r4, #0x64]
  00020	e3530000	 cmp         r3, #0
  00024	159f3030	 ldrne       r3, [pc, #0x30]
  00028	13a02000	 movne       r2, #0
  0002c	15842064	 strne       r2, [r4, #0x64]
  00030	15930000	 ldrne       r0, [r3]
  00034	13a01000	 movne       r1, #0
  00038	1b000000	 blne        |?ForceSpeaker@HardwareContext@@QAAKH@Z|

; 94   : 
; 95   :     DEBUGMSG(ZONE_MDD, (TEXT("Closing stream 0x%x\r\n"),this));
; 96   : 
; 97   :     DoCallbackStreamClosed();

  0003c	e5943000	 ldr         r3, [r4]
  00040	e1a00004	 mov         r0, r4
  00044	e5933028	 ldr         r3, [r3, #0x28]
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff13	 bx          r3

; 98   : 
; 99   :     return MMSYSERR_NOERROR;

  00050	e3a00000	 mov         r0, #0

; 100  : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN17@Close|
  0005c		 |$LN18@Close|
  0005c	00000000	 DCD         |?g_pHWContext@@3PAVHardwareContext@@A|
  00060		 |$M37858|

			 ENDP  ; |?Close@StreamContext@@UAAKXZ|, StreamContext::Close

	END
