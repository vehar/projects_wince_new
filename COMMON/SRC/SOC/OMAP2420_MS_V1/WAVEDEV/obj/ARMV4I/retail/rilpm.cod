; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\WAVEDEV\rilpm.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?g_hKeyPressEvent@@3PAXA| [ DATA ]	; g_hKeyPressEvent

  00000			 AREA	 |.bss|, NOINIT
|?g_hKeyPressEvent@@3PAXA| % 0x4			; g_hKeyPressEvent
	EXPORT	|?Lock@HardwareContext@@QAAXXZ|		; HardwareContext::Lock
	IMPORT	|EnterCriticalSection|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\hwctxt.h

  00000			 AREA	 |.pdata|, PDATA
|$T37506| DCD	|$LN5@Lock|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@HardwareContext@@QAAXXZ| PROC	; HardwareContext::Lock

; 82   :     void Lock()   {EnterCriticalSection(&m_Lock);}

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37503|
  00004	e2800004	 add         r0, r0, #4
  00008	eb000000	 bl          EnterCriticalSection
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37504|

			 ENDP  ; |?Lock@HardwareContext@@QAAXXZ|, HardwareContext::Lock

	EXPORT	|?Unlock@HardwareContext@@QAAXXZ|	; HardwareContext::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T37514| DCD	|$LN5@Unlock|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@HardwareContext@@QAAXXZ| PROC	; HardwareContext::Unlock

; 83   :     void Unlock() {LeaveCriticalSection(&m_Lock);}

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M37511|
  00004	e2800004	 add         r0, r0, #4
  00008	eb000000	 bl          LeaveCriticalSection
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M37512|

			 ENDP  ; |?Unlock@HardwareContext@@QAAXXZ|, HardwareContext::Unlock

	EXPORT	|?PmControlMessage@ACAudioHWContext@@UAAHKPAEK0KPAK@Z| ; ACAudioHWContext::PmControlMessage
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T37540| DCD	|$LN34@PmControlM|
	DCD	0x40006202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\wavedev\rilpm.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PmControlMessage@ACAudioHWContext@@UAAHKPAEK0KPAK@Z| PROC ; ACAudioHWContext::PmControlMessage

; 47   : {

  00000		 |$LN34@PmControlM|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd034	 sub         sp, sp, #0x34
  00008		 |$M37537|
  00008	e1a04000	 mov         r4, r0
  0000c	e3a03832	 mov         r3, #0x32, 16

; 48   :     BOOL bRetVal = FALSE;
; 49   : 
; 50   :     switch (dwCode)

  00010	e3833a01	 orr         r3, r3, #1, 20
  00014	e1510003	 cmp         r1, r3
  00018	e3a05000	 mov         r5, #0
  0001c	0a00003b	 beq         |$LN22@PmControlM|
  00020	e59f315c	 ldr         r3, [pc, #0x15C]
  00024	e1510003	 cmp         r1, r3
  00028	0a000017	 beq         |$LN10@PmControlM|
  0002c	e59f314c	 ldr         r3, [pc, #0x14C]
  00030	e1510003	 cmp         r1, r3
  00034	1a00004d	 bne         |$LN20@PmControlM|

; 81   :         break;
; 82   :     }
; 83   : 
; 84   :     // Indicate if the device is ready to enter a new device power state.
; 85   :     case IOCTL_POWER_QUERY:
; 86   :     {
; 87   :         // Check arguments.
; 88   :         if (pBufOut == NULL || dwLenOut < sizeof(CEDEVICE_POWER_STATE))

  00038	e59d0040	 ldr         r0, [sp, #0x40]
  0003c	e3500000	 cmp         r0, #0
  00040	0a00004a	 beq         |$LN20@PmControlM|
  00044	e59d3044	 ldr         r3, [sp, #0x44]
  00048	e3530004	 cmp         r3, #4
  0004c	3a000047	 bcc         |$LN20@PmControlM|

; 89   :         {
; 90   :             DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::PmControlMessage: "
; 91   :                 L"Invalid parameter.\r\n"
; 92   :             ));
; 93   :             break;
; 94   :         }
; 95   : 
; 96   :         if (CeSafeCopyMemory( pBufOut, &m_ExternPowerStateRequired, sizeof(CEDEVICE_POWER_STATE)) == 0)

  00050	e3a02004	 mov         r2, #4
  00054	e2841f42	 add         r1, r4, #0x42, 30
  00058	eb000000	 bl          CeSafeCopyMemory
  0005c	e3500000	 cmp         r0, #0
  00060	0a000042	 beq         |$LN20@PmControlM|

; 97   :             break;
; 98   : 
; 99   :         DEBUGMSG(ZONE_POWER, (L"ACAudioHWContext::PmControlMessage: "
; 100  :             L"IOCTL_POWER_QUERY = %d\r\n", m_ExternPowerStateRequired
; 101  :         ));
; 102  : 
; 103  :         if (!VALID_DX(m_ExternPowerStateRequired))

  00064	e5943108	 ldr         r3, [r4, #0x108]
  00068	e3730001	 cmn         r3, #1
  0006c	da00003f	 ble         |$LN20@PmControlM|
  00070	e3530005	 cmp         r3, #5
  00074	aa00003d	 bge         |$LN20@PmControlM|

; 104  :         {
; 105  :             DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::PmControlMessage: "
; 106  :                 L"IOCTL_POWER_QUERY invalid power state.\r\n"));
; 107  :             break;
; 108  :         }
; 109  : 
; 110  :         if (pdwActualOut) *pdwActualOut = sizeof(CEDEVICE_POWER_STATE);

  00078	e59d3048	 ldr         r3, [sp, #0x48]
  0007c	e3530000	 cmp         r3, #0
  00080	0a000039	 beq         |$LN18@PmControlM|
  00084	e3a02004	 mov         r2, #4

; 111  :         bRetVal = TRUE;
; 112  :         break;

  00088	ea000036	 b           |$LN31@PmControlM|
  0008c		 |$LN10@PmControlM|

; 113  :     }
; 114  : 
; 115  :     // Request a change from one device power state to another.
; 116  :     case IOCTL_POWER_SET:
; 117  :     {
; 118  :         CEDEVICE_POWER_STATE dxState;
; 119  : 
; 120  :         // Check arguments.
; 121  :         if (pBufOut == NULL || dwLenOut < sizeof(CEDEVICE_POWER_STATE))

  0008c	e59d1040	 ldr         r1, [sp, #0x40]
  00090	e3510000	 cmp         r1, #0
  00094	0a000035	 beq         |$LN20@PmControlM|
  00098	e59d3044	 ldr         r3, [sp, #0x44]
  0009c	e3530004	 cmp         r3, #4
  000a0	3a000032	 bcc         |$LN20@PmControlM|

; 122  :         {
; 123  :             DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::PmControlMessage: "
; 124  :                 L"Invalid parameter.\r\n"
; 125  :             ));
; 126  :             break;
; 127  :         }
; 128  : 
; 129  :         if (CeSafeCopyMemory(&dxState, pBufOut, sizeof(dxState)) == 0) break;

  000a4	e3a02004	 mov         r2, #4
  000a8	e28d0000	 add         r0, sp, #0
  000ac	eb000000	 bl          CeSafeCopyMemory
  000b0	e3500000	 cmp         r0, #0
  000b4	0a00002d	 beq         |$LN20@PmControlM|

; 130  : 
; 131  :         DEBUGMSG(ZONE_POWER, (L"ACAudioHWContext::PmControlMessage: "
; 132  :             L"IOCTL_POWER_SET = %d.\r\n", dxState
; 133  :         ));
; 134  : 
; 135  :         // Check for any valid power state.
; 136  :         if (VALID_DX(dxState))

  000b8	e59d3000	 ldr         r3, [sp]
  000bc	e3530004	 cmp         r3, #4
  000c0	8a00002a	 bhi         |$LN20@PmControlM|

; 137  :         {
; 138  :             Lock();

  000c4	e2840004	 add         r0, r4, #4
  000c8	eb000000	 bl          EnterCriticalSection

; 139  :             m_ExternPowerStateRequired = dxState ;

  000cc	e59d3000	 ldr         r3, [sp]

; 140  :             // Power off.
; 141  :             if ( dxState == D4 )
; 142  :             {
; 143  :                 HWAudioPowerTimeout (TRUE);

  000d0	e1a00004	 mov         r0, r4
  000d4	e5843108	 str         r3, [r4, #0x108]
  000d8	e3530004	 cmp         r3, #4
  000dc	e5943000	 ldr         r3, [r4]
  000e0	e5933044	 ldr         r3, [r3, #0x44]
  000e4	1a000003	 bne         |$LN5@PmControlM|
  000e8	e3a01001	 mov         r1, #1
  000ec	e1a0e00f	 mov         lr, pc
  000f0	e12fff13	 bx          r3

; 144  :             }
; 145  :             // Power on.
; 146  :             else

  000f4	ea000002	 b           |$LN4@PmControlM|
  000f8		 |$LN5@PmControlM|

; 147  :             {
; 148  :                 HWAudioPowerTimeout (FALSE);

  000f8	e3a01000	 mov         r1, #0
  000fc	e1a0e00f	 mov         lr, pc
  00100	e12fff13	 bx          r3
  00104		 |$LN4@PmControlM|

; 149  :             }
; 150  : 
; 151  :             Unlock();

  00104	e2840004	 add         r0, r4, #4
  00108	eb000000	 bl          LeaveCriticalSection

; 152  : 
; 153  :             bRetVal = TRUE;
; 154  :         }
; 155  :         else
; 156  :         {
; 157  :             DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::PmControlMessage: "
; 158  :                 L"IOCTL_POWER_SET invalid power state.\r\n"
; 159  :             ));
; 160  :         }
; 161  :         break;

  0010c	ea000016	 b           |$LN18@PmControlM|
  00110		 |$LN22@PmControlM|

; 51   :     {
; 52   :     // Return device specific power capabilities.
; 53   :     case IOCTL_POWER_CAPABILITIES:
; 54   :     {
; 55   :         POWER_CAPABILITIES pc;
; 56   : 
; 57   :         // Check arguments.
; 58   :         if ( pBufOut == NULL || dwLenOut < sizeof(POWER_CAPABILITIES))

  00110	e59d4040	 ldr         r4, [sp, #0x40]
  00114	e3540000	 cmp         r4, #0
  00118	0a000014	 beq         |$LN20@PmControlM|
  0011c	e59d3044	 ldr         r3, [sp, #0x44]
  00120	e3530030	 cmp         r3, #0x30
  00124	3a000011	 bcc         |$LN20@PmControlM|

; 59   :         {
; 60   :             DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::PmControlMessage: "
; 61   :                 L"Invalid parameter.\r\n"
; 62   :             ));
; 63   :             break;
; 64   :         }
; 65   : 
; 66   :         // Clear capabilities structure.
; 67   :         memset(&pc, 0, sizeof(POWER_CAPABILITIES));

  00128	e3a02030	 mov         r2, #0x30
  0012c	e3a01000	 mov         r1, #0
  00130	e28d0004	 add         r0, sp, #4
  00134	eb000000	 bl          memset

; 68   : 
; 69   :         // Set power capabilities. Supports D0 and D4.
; 70   :         pc.DeviceDx = DX_MASK(D0)|DX_MASK(D4);

  00138	e3a03011	 mov         r3, #0x11

; 71   : 
; 72   :         DEBUGMSG(ZONE_POWER, (L"ACAudioHWContext::PmControlMessage: "
; 73   :             L"IOCTL_POWER_CAPABILITIES = 0x%x\r\n", pc.DeviceDx
; 74   :         ));
; 75   : 
; 76   :         if (CeSafeCopyMemory(pBufOut, &pc, sizeof(pc)) == 0) break;

  0013c	e3a02030	 mov         r2, #0x30
  00140	e28d1004	 add         r1, sp, #4
  00144	e1a00004	 mov         r0, r4
  00148	e5cd3004	 strb        r3, [sp, #4]
  0014c	eb000000	 bl          CeSafeCopyMemory
  00150	e3500000	 cmp         r0, #0
  00154	0a000005	 beq         |$LN20@PmControlM|

; 77   : 
; 78   :         // Update returned data size.
; 79   :         if (pdwActualOut) *pdwActualOut = sizeof(pc);

  00158	e59d3048	 ldr         r3, [sp, #0x48]
  0015c	e3530000	 cmp         r3, #0
  00160	0a000001	 beq         |$LN18@PmControlM|
  00164	e3a02030	 mov         r2, #0x30
  00168		 |$LN31@PmControlM|
  00168	e5832000	 str         r2, [r3]
  0016c		 |$LN18@PmControlM|

; 80   :         bRetVal = TRUE;

  0016c	e3a05001	 mov         r5, #1
  00170		 |$LN20@PmControlM|

; 162  :     }
; 163  : 
; 164  :     // Return the current device power state.
; 165  :     case IOCTL_POWER_GET:
; 166  :     {
; 167  :         DEBUGMSG(ZONE_POWER, (L"ACAudioHWContext::PmControlMessage: "
; 168  :             L"IOCTL_POWER_GET -- not supported!\r\n"
; 169  :         ));
; 170  :         break;
; 171  :     }
; 172  : 
; 173  :     default:
; 174  :         DEBUGMSG(ZONE_ERROR, (L"ACAudioHWContext::PmControlMessage: "
; 175  :             L"Unknown IOCTL_xxx(0x%0.8X) \r\n", dwCode
; 176  :         ));
; 177  :         break;
; 178  :     }
; 179  : 
; 180  :     return bRetVal;
; 181  : }

  00170	e1a00005	 mov         r0, r5
  00174	e28dd034	 add         sp, sp, #0x34
  00178	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0017c	e12fff1e	 bx          lr
  00180		 |$LN35@PmControlM|
  00180		 |$LN36@PmControlM|
  00180	0032100c	 DCD         0x32100c
  00184		 |$LN37@PmControlM|
  00184	00321008	 DCD         0x321008
  00188		 |$M37538|

			 ENDP  ; |?PmControlMessage@ACAudioHWContext@@UAAHKPAEK0KPAK@Z|, ACAudioHWContext::PmControlMessage

	EXPORT	|?RegisterRilCallback@ACAudioHWContext@@EAAHPAPAX@Z| ; ACAudioHWContext::RegisterRilCallback
	EXPORT	|??_C@_1BM@HHFFFLNI@?$AAK?$AAe?$AAy?$AAP?$AAr?$AAe?$AAs?$AAs?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CreateEventW|

  00000			 AREA	 |.pdata|, PDATA
|$T37553| DCD	|$LN5@RegisterRi|
	DCD	0x40001101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@HHFFFLNI@?$AAK?$AAe?$AAy?$AAP?$AAr?$AAe?$AAs?$AAs?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@| DCB "K"
	DCB	0x0, "e", 0x0, "y", 0x0, "P", 0x0, "r", 0x0, "e", 0x0, "s"
	DCB	0x0, "s", 0x0, "E", 0x0, "v", 0x0, "e", 0x0, "n", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RegisterRilCallback@ACAudioHWContext@@EAAHPAPAX@Z| PROC ; ACAudioHWContext::RegisterRilCallback

; 193  : {

  00000		 |$LN5@RegisterRi|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M37550|
  00004	e1a0e001	 mov         lr, r1

; 194  :     // Try to initialize RIL
; 195  :     DEBUGMSG(ZONE_FUNCTION, (L">>>>> Calling RIL_Initialize()\r\n"));
; 196  :     *phRil = NULL;
; 197  : 
; 198  : #if defined( BSP_SMARTPHONE) || defined( BSP_POCKETPC )
; 199  :     HRESULT hr;
; 200  : 
; 201  :     // RIL port 1
; 202  :     hr = RIL_Initialize(1, ResultCallback, NotifyCallback,
; 203  :                     RIL_NCLASS_CALLCTRL, NULL, phRil);
; 204  : 
; 205  :     if (FAILED(hr)) {
; 206  :         DEBUGMSG(ZONE_ERROR, (L"RIL_Initialize call failed, code = %x", hr));
; 207  :         return FALSE;
; 208  :     }
; 209  : #endif
; 210  : 
; 211  :     // Create key press event;
; 212  :     g_hKeyPressEvent = CreateEvent( NULL, FALSE, TRUE, TEXT( "KeyPressEvent" ) );

  00008	e59f3030	 ldr         r3, [pc, #0x30]
  0000c	e3a04000	 mov         r4, #0
  00010	e3a02001	 mov         r2, #1
  00014	e3a01000	 mov         r1, #0
  00018	e3a00000	 mov         r0, #0
  0001c	e58e4000	 str         r4, [lr]
  00020	eb000000	 bl          CreateEventW
  00024	e59f2010	 ldr         r2, [pc, #0x10]
  00028	e1a03000	 mov         r3, r0

; 213  : 
; 214  :     return TRUE;

  0002c	e3a00001	 mov         r0, #1
  00030	e5823000	 str         r3, [r2]

; 215  : }

  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN6@RegisterRi|
  0003c		 |$LN7@RegisterRi|
  0003c	00000000	 DCD         |?g_hKeyPressEvent@@3PAXA|
  00040		 |$LN8@RegisterRi|
  00040	00000000	 DCD         |??_C@_1BM@HHFFFLNI@?$AAK?$AAe?$AAy?$AAP?$AAr?$AAe?$AAs?$AAs?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@|
  00044		 |$M37551|

			 ENDP  ; |?RegisterRilCallback@ACAudioHWContext@@EAAHPAPAX@Z|, ACAudioHWContext::RegisterRilCallback

	EXPORT	|?UnregisterRilCallback@ACAudioHWContext@@AAAHPAX@Z| ; ACAudioHWContext::UnregisterRilCallback

  00000			 AREA	 |.pdata|, PDATA
|$T37565| DCD	|$LN5@Unregister|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UnregisterRilCallback@ACAudioHWContext@@AAAHPAX@Z| PROC ; ACAudioHWContext::UnregisterRilCallback

; 226  : {

  00000		 |$LN5@Unregister|
  00000		 |$M37562|

; 227  :     // Try to initialize RIL
; 228  :     DEBUGMSG(ZONE_FUNCTION, (L">>>>> Calling RIL_Deinitialize()\r\n"));
; 229  : 
; 230  : #if defined( BSP_SMARTPHONE) || defined( BSP_POCKETPC )
; 231  :     HRESULT hr;
; 232  : 
; 233  :     if (hRil) {
; 234  :         hr = RIL_Deinitialize(hRil);
; 235  : 
; 236  :         if (FAILED(hr)) {
; 237  :             DEBUGMSG(ZONE_ERROR, (L"RIL_Deinitialize call failed, code = %x", hr));
; 238  :             return FALSE;
; 239  :         }
; 240  :     }
; 241  : #endif
; 242  : 
; 243  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 244  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M37563|

			 ENDP  ; |?UnregisterRilCallback@ACAudioHWContext@@AAAHPAX@Z|, ACAudioHWContext::UnregisterRilCallback

	END
