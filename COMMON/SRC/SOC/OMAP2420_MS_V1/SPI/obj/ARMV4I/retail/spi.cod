; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\SPI\spi.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.data|, DATA
	 COMMON	|DEVICE_IFC_SPI_GUID|, 0x10


  00000			 AREA	 |.rdata|, DATA, READONLY
|g_deviceRegParams| DCD |??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x8
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x34
	DCD	0x4
	DCD	0x1f4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@BKONPLFM@?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "T", 0x0
	DCB	"i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| DCB "I", 0x0, "r", 0x0, "q", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "M", 0x0
	DCB	"e", 0x0, "m", 0x0, "B", 0x0, "a", 0x0, "s", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'
	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43263| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43260|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43261|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|SPI_Open|
	IMPORT	|InterlockedIncrement|
	IMPORT	|LocalAlloc|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\spi\spi.c

  00000			 AREA	 |.pdata|, PDATA
|$T43275| DCD	|$LN8@SPI_Open|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Open| PROC

; 316  : {

  00000		 |$LN8@SPI_Open|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43272|
  00004	e1b04000	 movs        r4, r0

; 317  :     DWORD rc = (DWORD)NULL;

  00008	e3a06000	 mov         r6, #0

; 318  :     SPI_DEVICE *pDevice = (SPI_DEVICE*)context;
; 319  :     SPI_INSTANCE *pInstance = NULL;
; 320  : 
; 321  :     DEBUGMSG(ZONE_FUNCTION, (
; 322  :         L"+SPI_Open(0x%08x, 0x%08x, 0x%08x\r\n", context, accessCode, shareMode
; 323  :     ));
; 324  : 
; 325  :     // Check if we get correct context
; 326  :     if (pDevice == NULL || pDevice->cookie != SPI_DEVICE_COOKIE) {

  0000c	0a00000d	 beq         |$cleanUp$42941|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f303c	 ldr         r3, [pc, #0x3C]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000009	 bne         |$cleanUp$42941|

; 327  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Open: "
; 328  :             L"Incorrect context parameter\r\n"
; 329  :         ));
; 330  :         goto cleanUp;
; 331  :     }
; 332  : 
; 333  :     // Create device structure
; 334  :     pInstance = (SPI_INSTANCE*)LocalAlloc(LPTR, sizeof(SPI_INSTANCE));

  00020	e3a0100c	 mov         r1, #0xC
  00024	e3a00040	 mov         r0, #0x40
  00028	eb000000	 bl          LocalAlloc
  0002c	e1b05000	 movs        r5, r0

; 335  :     if (pInstance == NULL) {

  00030	0a000004	 beq         |$cleanUp$42941|

; 336  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Open: "
; 337  :             L"Failed allocate SPI instance structure\r\n"
; 338  :         ));
; 339  :         goto cleanUp;
; 340  :     }
; 341  : 
; 342  :     // Set cookie
; 343  :     pInstance->cookie = SPI_INSTANCE_COOKIE;

  00034	e59f3018	 ldr         r3, [pc, #0x18]

; 344  : 
; 345  :     // Save device reference
; 346  :     pInstance->pDevice = pDevice;
; 347  : 
; 348  :     // Increment number of open instances
; 349  :     InterlockedIncrement(&pDevice->instances);

  00038	e284000c	 add         r0, r4, #0xC
  0003c	e8850018	 stmia       r5, {r3, r4}
  00040	eb000000	 bl          InterlockedIncrement

; 350  : 
; 351  :     // sanity check number of instances
; 352  :     ASSERT(pDevice->instances > 0);
; 353  : 
; 354  :     // Done...
; 355  :     rc = (DWORD)pInstance;

  00044	e1a06005	 mov         r6, r5
  00048		 |$cleanUp$42941|

; 356  : 
; 357  : cleanUp:
; 358  :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_Open(rc = 0x%08x)\r\n", rc));
; 359  :     return rc;
; 360  : }

  00048	e1a00006	 mov         r0, r6
  0004c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN9@SPI_Open|
  00054		 |$LN10@SPI_Open|
  00054	73706949	 DCD         0x73706949
  00058		 |$LN11@SPI_Open|
  00058	73706944	 DCD         0x73706944
  0005c		 |$M43273|

			 ENDP  ; |SPI_Open|

	EXPORT	|SPI_Close|
	IMPORT	|LocalFree|
	IMPORT	|InterlockedDecrement|

  00000			 AREA	 |.pdata|, PDATA
|$T43289| DCD	|$LN7@SPI_Close|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Close| PROC

; 369  : {

  00000		 |$LN7@SPI_Close|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43286|
  00004	e1b04000	 movs        r4, r0

; 370  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 371  :     SPI_DEVICE *pDevice;
; 372  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 373  : 
; 374  :     DEBUGMSG(ZONE_FUNCTION, (L"+SPI_Close(0x%08x)\r\n", context));
; 375  : 
; 376  :     // Check if we get correct context
; 377  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000009	 beq         |$cleanUp$42963|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3024	 ldr         r3, [pc, #0x24]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000005	 bne         |$cleanUp$42963|

; 378  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Transfer: "
; 379  :             L"Incorrect context paramer\r\n"
; 380  :         ));
; 381  :         goto cleanUp;
; 382  :     }
; 383  : 
; 384  :     // Get device context
; 385  :     pDevice = pInstance->pDevice;
; 386  : 
; 387  :     // sanity check number of instances
; 388  :     ASSERT(pDevice->instances > 0);
; 389  : 
; 390  :     // Decrement number of open instances
; 391  :     InterlockedDecrement(&pDevice->instances);

  00020	e5943004	 ldr         r3, [r4, #4]
  00024	e283000c	 add         r0, r3, #0xC
  00028	eb000000	 bl          InterlockedDecrement

; 392  : 
; 393  :     // Free instance structure
; 394  :     LocalFree(pInstance);

  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          LocalFree

; 395  : 
; 396  :     // Done...
; 397  :     rc = TRUE;

  00034	e3a00001	 mov         r0, #1
  00038		 |$cleanUp$42963|

; 398  : 
; 399  : cleanUp:
; 400  :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_Close(rc = %d)\r\n", rc));
; 401  :     return rc;
; 402  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN8@SPI_Close|
  00040		 |$LN9@SPI_Close|
  00040	73706949	 DCD         0x73706949
  00044		 |$M43287|

			 ENDP  ; |SPI_Close|

	EXPORT	|SPI_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T43298| DCD	|$LN5@SPI_PowerU|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_PowerUp| PROC

; 692  : {

  00000		 |$LN5@SPI_PowerU|
  00000		 |$M43295|

; 693  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43296|

			 ENDP  ; |SPI_PowerUp|

	EXPORT	|SPI_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T43305| DCD	|$LN5@SPI_PowerD|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_PowerDown| PROC

; 702  : {

  00000		 |$LN5@SPI_PowerD|
  00000		 |$M43302|

; 703  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43303|

			 ENDP  ; |SPI_PowerDown|

	EXPORT	|SPI_SetupMCSPI_Channel|

  00000			 AREA	 |.pdata|, PDATA
|$T43317| DCD	|$LN7@SPI_SetupM|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_SetupMCSPI_Channel| PROC

; 756  : {

  00000		 |$LN7@SPI_SetupM|
  00000		 |$M43314|
  00000	e3510000	 cmp         r1, #0
  00004	e1a02000	 mov         r2, r0

; 757  :     BOOL rc = FALSE;
; 758  :     //DEBUGMSG(ZONE_FUNCTION, (L"SPI_SetupMCSPI_Channel 0x%x\r\n", address));
; 759  :     // Config the channel:
; 760  :     if (address == 0)

  00008	03a03a11	 moveq       r3, #0x11, 20

; 761  :     {
; 762  :         //BIT0 = 0 Data are latched on odd numbered edges 
; 763  :         //BIT1 = 1 Active Low Clock 
; 764  :         //BIT5-2 = 6 Clock Divider =64 divide from 48MHz
; 765  :         //BIT6 = 1 EPOL Active Low CS
; 766  :         //BIT11-7 = F, SPI Word = 16 bit
; 767  :         //BIT11-7 = 1F, SPI Word = 16 bit
; 768  :         //BIT13-12 = 0, Transmit AND Receive mode
; 769  :         //BIT14 = 0, DMA Write req disabled
; 770  :         //BIT15 = 0, DMA Read req disabled
; 771  :         //BIT16 = 1, transmission on SOMI disabled
; 772  :         //BIT17 = 0, transmission on SIMO enabled
; 773  :         //BIT18 = 0, reception on SOMI enabled
; 774  :         //BIT19 = 0, TURBO deactivated
; 775  :         //BIT20 = 0, FORCE HIGH between words
; 776  :         //BIT21-31 = 0 reserved
; 777  :         OUTREG32(&pSPIRegs->ulMCSPI_CHCONF0, 0x00010FDA);

  0000c	02433026	 subeq       r3, r3, #0x26
  00010	e3a00000	 mov         r0, #0
  00014	0582302c	 streq       r3, [r2, #0x2C]

; 778  :     }
; 779  :     else
; 780  :     {
; 781  :         goto cleanUp;
; 782  :     }
; 783  :     rc = TRUE;

  00018	03a00001	 moveq       r0, #1
  0001c		 |$cleanUp$43154|

; 784  : 
; 785  : cleanUp:
; 786  :     return rc;
; 787  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M43315|

			 ENDP  ; |SPI_SetupMCSPI_Channel|

	EXPORT	|SPI_ClockOn|
	IMPORT	|KernelIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T43325| DCD	|$LN7@SPI_ClockO|
	DCD	0x40003102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_ClockOn| PROC

; 793  : {

  00000		 |$LN7@SPI_ClockO|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43322|

; 794  :     DWORD regBit,cbRet;
; 795  : 
; 796  :     //Check if it's SPI1 or SPI2
; 797  :     if(OMAP2420_MCSPI1_REGS_PA == pDevice->memBase)

  00008	e5902004	 ldr         r2, [r0, #4]
  0000c	e3a03312	 mov         r3, #0x12, 6
  00010	e3833926	 orr         r3, r3, #0x26, 18

; 798  :     {
; 799  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI1: SPI_ClockOn\r\n") ));
; 800  :         regBit = PRCM_FCLKEN1_CORE_EN_MCSPI1;
; 801  :         KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00014	e59f00a4	 ldr         r0, [pc, #0xA4]
  00018	e1520003	 cmp         r2, r3
  0001c	e3a03000	 mov         r3, #0
  00020	e3a02004	 mov         r2, #4
  00024	e28de00c	 add         lr, sp, #0xC
  00028	e3a04000	 mov         r4, #0
  0002c	e28d1008	 add         r1, sp, #8
  00030	1a00000f	 bne         |$LN2@SPI_ClockO|
  00034	e3a05802	 mov         r5, #2, 16
  00038	e58d5008	 str         r5, [sp, #8]
  0003c	e58de004	 str         lr, [sp, #4]
  00040	e58d4000	 str         r4, [sp]
  00044	eb000000	 bl          KernelIoControl

; 802  :         regBit = PRCM_ICLKEN1_CORE_EN_MCSPI1;
; 803  :         KernelIoControl(IOCTL_ICLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00048	e59f006c	 ldr         r0, [pc, #0x6C]
  0004c	e28de00c	 add         lr, sp, #0xC
  00050	e3a05802	 mov         r5, #2, 16
  00054	e3a03000	 mov         r3, #0
  00058	e3a02004	 mov         r2, #4
  0005c	e28d1008	 add         r1, sp, #8
  00060	e58de004	 str         lr, [sp, #4]
  00064	e58d5008	 str         r5, [sp, #8]
  00068	e58d4000	 str         r4, [sp]
  0006c	eb000000	 bl          KernelIoControl

; 804  :     }
; 805  :     else

  00070	ea00000e	 b           |$LN1@SPI_ClockO|
  00074		 |$LN2@SPI_ClockO|

; 806  :     {
; 807  :         //Assume SPI2
; 808  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI2: SPI_ClockOn\r\n") ));
; 809  :         regBit = PRCM_FCLKEN1_CORE_EN_MCSPI2;
; 810  :         KernelIoControl(IOCTL_FCLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00074	e3a05701	 mov         r5, #1, 14
  00078	e58d5008	 str         r5, [sp, #8]
  0007c	e58de004	 str         lr, [sp, #4]
  00080	e58d4000	 str         r4, [sp]
  00084	eb000000	 bl          KernelIoControl

; 811  :         regBit = PRCM_ICLKEN1_CORE_EN_MCSPI2;
; 812  :         KernelIoControl(IOCTL_ICLK1_ENB, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00088	e59f002c	 ldr         r0, [pc, #0x2C]
  0008c	e28de00c	 add         lr, sp, #0xC
  00090	e3a05701	 mov         r5, #1, 14
  00094	e3a03000	 mov         r3, #0
  00098	e3a02004	 mov         r2, #4
  0009c	e28d1008	 add         r1, sp, #8
  000a0	e58de004	 str         lr, [sp, #4]
  000a4	e58d5008	 str         r5, [sp, #8]
  000a8	e58d4000	 str         r4, [sp]
  000ac	eb000000	 bl          KernelIoControl
  000b0		 |$LN1@SPI_ClockO|

; 813  :     }
; 814  : }

  000b0	e28dd010	 add         sp, sp, #0x10
  000b4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$LN8@SPI_ClockO|
  000bc		 |$LN9@SPI_ClockO|
  000bc	0022040c	 DCD         0x22040c
  000c0		 |$LN10@SPI_ClockO|
  000c0	0022041c	 DCD         0x22041c
  000c4		 |$M43323|

			 ENDP  ; |SPI_ClockOn|

	EXPORT	|SPI_ClockOff|

  00000			 AREA	 |.pdata|, PDATA
|$T43336| DCD	|$LN7@SPI_ClockO@2|
	DCD	0x40003002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_ClockOff| PROC

; 818  : {

  00000		 |$LN7@SPI_ClockO@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43333|

; 819  :     DWORD regBit,cbRet;
; 820  : 
; 821  :     //Check if it's SPI1 or SPI2
; 822  :     if(OMAP2420_MCSPI1_REGS_PA== pDevice->memBase)

  00008	e5902004	 ldr         r2, [r0, #4]
  0000c	e3a03312	 mov         r3, #0x12, 6
  00010	e3833926	 orr         r3, r3, #0x26, 18
  00014	e3a06822	 mov         r6, #0x22, 16
  00018	e1520003	 cmp         r2, r3

; 823  :     {
; 824  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI1: SPI_ClockOff\r\n") ));
; 825  :         regBit = PRCM_FCLKEN1_CORE_EN_MCSPI1;
; 826  :         KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  0001c	e3a03000	 mov         r3, #0
  00020	e3a02004	 mov         r2, #4
  00024	e28de00c	 add         lr, sp, #0xC
  00028	e3a04000	 mov         r4, #0
  0002c	e28d1008	 add         r1, sp, #8
  00030	e3860e42	 orr         r0, r6, #0x42, 28
  00034	1a00000f	 bne         |$LN2@SPI_ClockO@2|
  00038	e3a05802	 mov         r5, #2, 16
  0003c	e58d5008	 str         r5, [sp, #8]
  00040	e58de004	 str         lr, [sp, #4]
  00044	e58d4000	 str         r4, [sp]
  00048	eb000000	 bl          KernelIoControl

; 827  :         regBit = PRCM_ICLKEN1_CORE_EN_MCSPI1;

  0004c	e3a02802	 mov         r2, #2, 16

; 828  :         KernelIoControl(IOCTL_ICLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00050	e28d300c	 add         r3, sp, #0xC
  00054	e58d2008	 str         r2, [sp, #8]
  00058	e58d3004	 str         r3, [sp, #4]
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02004	 mov         r2, #4
  00064	e28d1008	 add         r1, sp, #8
  00068	e3860e41	 orr         r0, r6, #0x41, 28
  0006c	e58d4000	 str         r4, [sp]
  00070	eb000000	 bl          KernelIoControl

; 829  :     }
; 830  :     else

  00074	ea00000e	 b           |$LN1@SPI_ClockO@2|
  00078		 |$LN2@SPI_ClockO@2|

; 831  :     {
; 832  :         //Assume SPI2
; 833  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI2: SPI_ClockOff\r\n") ));
; 834  :         regBit = PRCM_FCLKEN1_CORE_EN_MCSPI2;

  00078	e3a05701	 mov         r5, #1, 14

; 835  :         KernelIoControl(IOCTL_FCLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  0007c	e58d5008	 str         r5, [sp, #8]
  00080	e58de004	 str         lr, [sp, #4]
  00084	e58d4000	 str         r4, [sp]
  00088	eb000000	 bl          KernelIoControl

; 836  :         regBit = PRCM_ICLKEN1_CORE_EN_MCSPI2;

  0008c	e3a02701	 mov         r2, #1, 14

; 837  :         KernelIoControl(IOCTL_ICLK1_DIS, (VOID *)&regBit, sizeof(DWORD), NULL, 0, &cbRet);

  00090	e28d300c	 add         r3, sp, #0xC
  00094	e58d2008	 str         r2, [sp, #8]
  00098	e58d3004	 str         r3, [sp, #4]
  0009c	e3a03000	 mov         r3, #0
  000a0	e3a02004	 mov         r2, #4
  000a4	e28d1008	 add         r1, sp, #8
  000a8	e3860e41	 orr         r0, r6, #0x41, 28
  000ac	e58d4000	 str         r4, [sp]
  000b0	eb000000	 bl          KernelIoControl
  000b4		 |$LN1@SPI_ClockO@2|

; 838  :     }
; 839  : }

  000b4	e28dd010	 add         sp, sp, #0x10
  000b8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$M43334|

			 ENDP  ; |SPI_ClockOff|

	EXPORT	|SPI_Deinit|
	IMPORT	|CloseHandle|
	IMPORT	|InterruptDisable|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|SetDevicePowerState|

  00000			 AREA	 |.pdata|, PDATA
|$T43347| DCD	|$LN12@SPI_Deinit|
	DCD	0x40003702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Deinit| PROC

; 243  : {

  00000		 |$LN12@SPI_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43344|
  00008	e1b04000	 movs        r4, r0

; 244  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 245  :     SPI_DEVICE *pDevice = (SPI_DEVICE*)context;
; 246  : 
; 247  :     DEBUGMSG(ZONE_INIT, (L"+SPI_Deinit(0x%08x)\r\n", context));
; 248  : 
; 249  :     // Check if we get correct context
; 250  :     if (pDevice == NULL || pDevice->cookie != SPI_DEVICE_COOKIE) {

  00010	0a00002c	 beq         |$cleanUp$42905|
  00014	e5942000	 ldr         r2, [r4]
  00018	e59f30b8	 ldr         r3, [pc, #0xB8]
  0001c	e1520003	 cmp         r2, r3
  00020	1a000028	 bne         |$cleanUp$42905|

; 251  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Deinit: "
; 252  :             L"Incorrect context paramer\r\n"
; 253  :         ));
; 254  :         goto cleanUp;
; 255  :     }
; 256  : 
; 257  :     // Check for open instances
; 258  :     if (pDevice->instances > 0) {

  00024	e594300c	 ldr         r3, [r4, #0xC]
  00028	e3530000	 cmp         r3, #0
  0002c	ca000025	 bgt         |$cleanUp$42905|

; 259  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Deinit: "
; 260  :             L"Deinit with active instance (%d instances active)\r\n",
; 261  :             pDevice->instances
; 262  :         ));
; 263  :         goto cleanUp;
; 264  :     }
; 265  : 
; 266  :     // Set hardware to D4 and close parent bus driver
; 267  :     if (pDevice->hParentBus!= NULL) 

  00030	e5943010	 ldr         r3, [r4, #0x10]
  00034	e3530000	 cmp         r3, #0
  00038	0a000005	 beq         |$LN4@SPI_Deinit|

; 268  :     {
; 269  :         SetDevicePowerState(pDevice->hParentBus, D4,NULL);

  0003c	e3a02000	 mov         r2, #0
  00040	e3a01004	 mov         r1, #4
  00044	e1a00003	 mov         r0, r3
  00048	eb000000	 bl          SetDevicePowerState

; 270  :         CloseBusAccessHandle(pDevice->hParentBus);

  0004c	e5940010	 ldr         r0, [r4, #0x10]
  00050	eb000000	 bl          CloseBusAccessHandle
  00054		 |$LN4@SPI_Deinit|

; 271  :     }
; 272  : 
; 273  :     // Delete critical section
; 274  :     DeleteCriticalSection(&pDevice->cs);

  00054	e2840018	 add         r0, r4, #0x18
  00058	eb000000	 bl          DeleteCriticalSection

; 275  : 
; 276  :     // Unmap SPI controller registers
; 277  :     if (pDevice->pSPIRegs != NULL)

  0005c	e5943014	 ldr         r3, [r4, #0x14]
  00060	e3530000	 cmp         r3, #0

; 278  :     {
; 279  :         MmUnmapIoSpace((VOID*)pDevice->pSPIRegs, sizeof(OMAP2420_MCSPI_REGS));

  00064	13a0107c	 movne       r1, #0x7C
  00068	11a00003	 movne       r0, r3
  0006c	1b000000	 blne        MmUnmapIoSpace

; 280  :     }
; 281  : 
; 282  :     //Turn clocks off
; 283  :     SPI_ClockOff(pDevice);

  00070	e1a00004	 mov         r0, r4
  00074	eb000000	 bl          SPI_ClockOff

; 284  : 
; 285  :     // Release SPI controller interrupt
; 286  :     if (pDevice->sysIntr != 0) 

  00078	e594302c	 ldr         r3, [r4, #0x2C]
  0007c	e3530000	 cmp         r3, #0
  00080	0a000009	 beq         |$LN2@SPI_Deinit|

; 287  :     {
; 288  :         InterruptDisable(pDevice->sysIntr);

  00084	e1a00003	 mov         r0, r3
  00088	eb000000	 bl          InterruptDisable

; 289  :         KernelIoControl(
; 290  :             IOCTL_HAL_RELEASE_SYSINTR, &pDevice->sysIntr,
; 291  :             sizeof(pDevice->sysIntr), NULL, 0, NULL
; 292  :         );

  0008c	e59f0040	 ldr         r0, [pc, #0x40]
  00090	e3a0e000	 mov         lr, #0
  00094	e3a03000	 mov         r3, #0
  00098	e3a02004	 mov         r2, #4
  0009c	e284102c	 add         r1, r4, #0x2C
  000a0	e58de004	 str         lr, [sp, #4]
  000a4	e58de000	 str         lr, [sp]
  000a8	eb000000	 bl          KernelIoControl
  000ac		 |$LN2@SPI_Deinit|

; 293  :     }
; 294  : 
; 295  :     // Close interrupt handler
; 296  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  000ac	e5943030	 ldr         r3, [r4, #0x30]
  000b0	e3530000	 cmp         r3, #0
  000b4	11a00003	 movne       r0, r3
  000b8	1b000000	 blne        CloseHandle

; 297  : 
; 298  :     // Free device structure
; 299  :     LocalFree(pDevice);

  000bc	e1a00004	 mov         r0, r4
  000c0	eb000000	 bl          LocalFree

; 300  : 
; 301  :     // Done
; 302  :     rc = TRUE;

  000c4	e3a00001	 mov         r0, #1
  000c8		 |$cleanUp$42905|

; 303  : 
; 304  : cleanUp:
; 305  :     DEBUGMSG(ZONE_INIT, (L"-SPI_Deinit(rc = %d)\r\n", rc));
; 306  :     return rc;
; 307  : }

  000c8	e28dd008	 add         sp, sp, #8
  000cc	e8bd4010	 ldmia       sp!, {r4, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN13@SPI_Deinit|
  000d4		 |$LN14@SPI_Deinit|
  000d4	010100d8	 DCD         0x10100d8
  000d8		 |$LN15@SPI_Deinit|
  000d8	73706944	 DCD         0x73706944
  000dc		 |$M43345|

			 ENDP  ; |SPI_Deinit|

	EXPORT	|SPI_Transfer|
	EXPORT	|??_C@_1HO@LHOFFFL@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GM@EEKFJEJ@?$AAS?$AAP?$AAI?$AA_?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAS?$AAP?$AAI?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd@| [ DATA ] ; `string'
	IMPORT	|LeaveCriticalSection|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43368| DCD	|$LN17@SPI_Transf|
	DCD	0x40005102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@LHOFFFL@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "O"
	DCB	0x0, "M", 0x0, "A", 0x0, "P", 0x0, "2", 0x0, "4", 0x0, "2"
	DCB	0x0, "0", 0x0, "_", 0x0, "M", 0x0, "S", 0x0, "_", 0x0, "V"
	DCB	0x0, "1", 0x0, "\\", 0x0, "S", 0x0, "P", 0x0, "I", 0x0, "\\"
	DCB	0x0, ".", 0x0, "\\", 0x0, "s", 0x0, "p", 0x0, "i", 0x0, "."
	DCB	0x0, "c", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@EEKFJEJ@?$AAS?$AAP?$AAI?$AA_?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAS?$AAP?$AAI?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, "_", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "S", 0x0, "P", 0x0, "I", 0x0, " ", 0x0, "i"
	DCB	0x0, "s", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "p", 0x0, "o", 0x0, "n"
	DCB	0x0, "d", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " ", 0x0, "C"
	DCB	0x0, "H", 0x0, "S", 0x0, "T", 0x0, "A", 0x0, "T", 0x0, "U"
	DCB	0x0, "S", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Transfer| PROC

; 411  : {

  00000		 |$LN17@SPI_Transf|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43365|
  00008	e1a07001	 mov         r7, r1
  0000c	e1b05000	 movs        r5, r0

; 412  : 
; 413  :     DWORD rc = 0;

  00010	e3a08000	 mov         r8, #0

; 414  :     SPI_DEVICE *pDevice;
; 415  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 416  :     OMAP2420_MCSPI_REGS *pSPIRegs;
; 417  :     UINT32* pData = (UINT32*)pBuffer;
; 418  :     DWORD dwCount;
; 419  : 
; 420  : //    DEBUGMSG(ZONE_FUNCTION, ( L"+SPI_Transfer(0x%08x, 0x%08x\r\n", context, *pData));
; 421  : 
; 422  :     // Check if we get correct context
; 423  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  00014	0a000033	 beq         |$LN14@SPI_Transf|
  00018	e5952000	 ldr         r2, [r5]
  0001c	e59f311c	 ldr         r3, [pc, #0x11C]
  00020	e1520003	 cmp         r2, r3
  00024	1a00002f	 bne         |$LN14@SPI_Transf|

; 424  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Transfer: "
; 425  :             L"Incorrect context paramer\r\n"
; 426  :         ));
; 427  :         goto clean;
; 428  :     }
; 429  :     pDevice = pInstance->pDevice;

  00028	e5956004	 ldr         r6, [r5, #4]

; 430  :     pSPIRegs = pDevice->pSPIRegs;
; 431  :     // Get hardware
; 432  :     EnterCriticalSection(&pDevice->cs);

  0002c	e5964014	 ldr         r4, [r6, #0x14]
  00030	e2860018	 add         r0, r6, #0x18
  00034	eb000000	 bl          EnterCriticalSection

; 433  :     
; 434  :     // Set this driver to Active Mode
; 435  :     SPI_ClockOn(pDevice);

  00038	e1a00006	 mov         r0, r6
  0003c	eb000000	 bl          SPI_ClockOn

; 436  :     SetDevicePowerState(pDevice->hParentBus, pDevice->powerState = D0, NULL);

  00040	e5960010	 ldr         r0, [r6, #0x10]
  00044	e3a03000	 mov         r3, #0
  00048	e3a02000	 mov         r2, #0
  0004c	e3a01000	 mov         r1, #0
  00050	e5863038	 str         r3, [r6, #0x38]
  00054	eb000000	 bl          SetDevicePowerState

; 437  :     switch (pInstance->address) {

  00058	e5953008	 ldr         r3, [r5, #8]
  0005c	e3530000	 cmp         r3, #0
  00060	1a000022	 bne         |$clean$42984|

; 438  :     case 0:
; 439  :         // Enable the channel
; 440  :         SETREG32(&pSPIRegs->ulMCSPI_CHCTRL0, BIT0);

  00064	e5943034	 ldr         r3, [r4, #0x34]

; 441  : 
; 442  :         OUTREG32(&pSPIRegs->ulMCSPI_TX0, *pData);
; 443  :         // Wait for transfer to finish.
; 444  :         dwCount = 0;
; 445  :         while(!(INREG32(&pSPIRegs->ulMCSPI_CHSTATUS0) & BIT2))

  00068	e3a02000	 mov         r2, #0
  0006c	e3833001	 orr         r3, r3, #1
  00070	e5843034	 str         r3, [r4, #0x34]
  00074	e5973000	 ldr         r3, [r7]
  00078	e5843038	 str         r3, [r4, #0x38]
  0007c	e5943030	 ldr         r3, [r4, #0x30]
  00080	e3130004	 tst         r3, #4
  00084	1a000007	 bne         |$LN3@SPI_Transf|
  00088	e3e034ff	 mvn         r3, #0xFF, 8
  0008c	e22318fe	 eor         r1, r3, #0xFE, 16
  00090		 |$LL4@SPI_Transf|

; 446  :         {
; 447  :             if (dwCount++>0x1ffff)

  00090	e1520001	 cmp         r2, r1
  00094	e2822001	 add         r2, r2, #1
  00098	8a000009	 bhi         |$LN13@SPI_Transf|
  0009c	e5943030	 ldr         r3, [r4, #0x30]
  000a0	e3130004	 tst         r3, #4
  000a4	0afffff9	 beq         |$LL4@SPI_Transf|
  000a8		 |$LN3@SPI_Transf|

; 452  :             }
; 453  :         }
; 454  :         *pData = 0xFFFF & INREG32(&pSPIRegs->ulMCSPI_RX0);

  000a8	e594203c	 ldr         r2, [r4, #0x3C]
  000ac	e3a03cff	 mov         r3, #0xFF, 24
  000b0	e38330ff	 orr         r3, r3, #0xFF
  000b4	e0023003	 and         r3, r2, r3
  000b8	e5873000	 str         r3, [r7]

; 455  :         break;
; 456  : 
; 457  :     default:
; 458  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Transfer: Incorrect channel address\r\n"));
; 459  :         goto clean;
; 460  :     }
; 461  :     rc = 1;

  000bc	e3a08001	 mov         r8, #1
  000c0	ea00000a	 b           |$clean$42984|
  000c4		 |$LN13@SPI_Transf|

; 448  :             {
; 449  :                 // Break out dead lock, something is wrong.
; 450  :                 ERRORMSG (1, (L"SPI_Transfer: SPI is not responding CHSTATUS = 0x%x\r\n",INREG32(&pSPIRegs->ulMCSPI_CHSTATUS0)));

  000c4	e59f1070	 ldr         r1, [pc, #0x70]
  000c8	e59f0068	 ldr         r0, [pc, #0x68]
  000cc	e3a03c01	 mov         r3, #1, 24
  000d0	e38320c2	 orr         r2, r3, #0xC2
  000d4	eb000000	 bl          NKDbgPrintfW
  000d8	e5941030	 ldr         r1, [r4, #0x30]
  000dc	e59f0050	 ldr         r0, [pc, #0x50]
  000e0	eb000000	 bl          NKDbgPrintfW

; 451  :                 goto clean;

  000e4	ea000001	 b           |$clean$42984|
  000e8		 |$LN14@SPI_Transf|

; 455  :         break;
; 456  : 
; 457  :     default:
; 458  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Transfer: Incorrect channel address\r\n"));
; 459  :         goto clean;
; 460  :     }
; 461  :     rc = 1;

  000e8	e59d6000	 ldr         r6, [sp]
  000ec	e59d4000	 ldr         r4, [sp]
  000f0		 |$clean$42984|

; 462  : 
; 463  : clean:
; 464  :     // Disable the channel.
; 465  :     CLRREG32(&pSPIRegs->ulMCSPI_CHCTRL0, BIT0);

  000f0	e5943034	 ldr         r3, [r4, #0x34]

; 466  : 
; 467  :     // Set this driver to Suspend Mode
; 468  :     SPI_ClockOff(pDevice);

  000f4	e1a00006	 mov         r0, r6
  000f8	e3c33001	 bic         r3, r3, #1
  000fc	e5843034	 str         r3, [r4, #0x34]
  00100	eb000000	 bl          SPI_ClockOff

; 469  :     SetDevicePowerState(pDevice->hParentBus, pDevice->powerState = D4, NULL);

  00104	e5960010	 ldr         r0, [r6, #0x10]
  00108	e3a03004	 mov         r3, #4
  0010c	e3a02000	 mov         r2, #0
  00110	e3a01004	 mov         r1, #4
  00114	e5863038	 str         r3, [r6, #0x38]
  00118	eb000000	 bl          SetDevicePowerState

; 470  :     
; 471  :     // Release hardware
; 472  :     LeaveCriticalSection(&pDevice->cs);

  0011c	e2860018	 add         r0, r6, #0x18
  00120	eb000000	 bl          LeaveCriticalSection

; 473  : //    DEBUGMSG(ZONE_FUNCTION, (L"-SPI_Transfer(rc = %d)\r\n", rc));
; 474  :     return rc;
; 475  : }

  00124	e1a00008	 mov         r0, r8
  00128	e28dd004	 add         sp, sp, #4
  0012c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN18@SPI_Transf|
  00134		 |$LN19@SPI_Transf|
  00134	00000000	 DCD         |??_C@_1GM@EEKFJEJ@?$AAS?$AAP?$AAI?$AA_?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAS?$AAP?$AAI?$AA?5?$AAi?$AAs?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAr?$AAe?$AAs?$AAp?$AAo?$AAn?$AAd@|
  00138		 |$LN20@SPI_Transf|
  00138	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0013c		 |$LN21@SPI_Transf|
  0013c	00000000	 DCD         |??_C@_1HO@LHOFFFL@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00140		 |$LN22@SPI_Transf|
  00140	73706949	 DCD         0x73706949
  00144		 |$M43366|

			 ENDP  ; |SPI_Transfer|

	EXPORT	|SPI_SetSlaveAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T43395| DCD	|$LN11@SPI_SetSla|
	DCD	0x40002901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_SetSlaveAddress| PROC

; 708  : {

  00000		 |$LN11@SPI_SetSla|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43392|
  00004	e1b04000	 movs        r4, r0

; 709  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 710  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 711  :     SPI_DEVICE *pDevice;
; 712  : 
; 713  :     DEBUGMSG(ZONE_FUNCTION, (L"SPI_SetSlaveAddress 0x%x\r\n", address));
; 714  : 
; 715  :     // Check if we get correct context
; 716  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0000c	0a000021	 beq         |$cleanUp$43140|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3084	 ldr         r3, [pc, #0x84]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00001d	 bne         |$cleanUp$43140|

; 717  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_SetSlaveAddress: "
; 718  :             L"Incorrect context paramer\r\n"
; 719  :         ));
; 720  :         goto cleanUp;
; 721  :     }
; 722  : 
; 723  :     //Get Device
; 724  :     pDevice = pInstance->pDevice;

  00020	e5945004	 ldr         r5, [r4, #4]

; 725  : 
; 726  :     //Set Address
; 727  :     pInstance->address = address;

  00024	e5841008	 str         r1, [r4, #8]

; 728  : 
; 729  :     // Get hardware
; 730  :     EnterCriticalSection(&pDevice->cs);

  00028	e2850018	 add         r0, r5, #0x18
  0002c	eb000000	 bl          EnterCriticalSection

; 731  :     
; 732  :     // Set this driver to Active Mode
; 733  :     SPI_ClockOn(pDevice);

  00030	e1a00005	 mov         r0, r5
  00034	eb000000	 bl          SPI_ClockOn

; 734  :     SetDevicePowerState(pDevice->hParentBus, pDevice->powerState = D0, NULL);

  00038	e5950010	 ldr         r0, [r5, #0x10]
  0003c	e3a03000	 mov         r3, #0
  00040	e3a02000	 mov         r2, #0
  00044	e3a01000	 mov         r1, #0
  00048	e5853038	 str         r3, [r5, #0x38]
  0004c	eb000000	 bl          SetDevicePowerState

; 735  : 
; 736  :     //Set channel address
; 737  :     SPI_SetupMCSPI_Channel(pInstance->pDevice->pSPIRegs, pInstance->address);

  00050	e5943008	 ldr         r3, [r4, #8]
  00054	e3530000	 cmp         r3, #0
  00058	05943004	 ldreq       r3, [r4, #4]
  0005c	03a02a11	 moveq       r2, #0x11, 20
  00060	02422026	 subeq       r2, r2, #0x26
  00064	05933014	 ldreq       r3, [r3, #0x14]
  00068	0583202c	 streq       r2, [r3, #0x2C]
  0006c		 |$cleanUp$43382|

; 738  : 
; 739  :     // Set this driver to Suspend Mode
; 740  :     SPI_ClockOff(pDevice);

  0006c	e1a00005	 mov         r0, r5
  00070	eb000000	 bl          SPI_ClockOff

; 741  :     SetDevicePowerState(pDevice->hParentBus, pDevice->powerState = D4, NULL);

  00074	e5950010	 ldr         r0, [r5, #0x10]
  00078	e3a03004	 mov         r3, #4
  0007c	e3a02000	 mov         r2, #0
  00080	e3a01004	 mov         r1, #4
  00084	e5853038	 str         r3, [r5, #0x38]
  00088	eb000000	 bl          SetDevicePowerState

; 742  :     
; 743  :     // Release hardware
; 744  :     LeaveCriticalSection(&pDevice->cs);    

  0008c	e2850018	 add         r0, r5, #0x18
  00090	eb000000	 bl          LeaveCriticalSection

; 745  :     
; 746  :     rc = TRUE;

  00094	e3a00001	 mov         r0, #1
  00098		 |$cleanUp$43140|

; 747  : 
; 748  : cleanUp:
; 749  :     return rc;
; 750  : }

  00098	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN12@SPI_SetSla|
  000a0		 |$LN13@SPI_SetSla|
  000a0	73706949	 DCD         0x73706949
  000a4		 |$M43393|

			 ENDP  ; |SPI_SetSlaveAddress|

	EXPORT	|SPI_Init|
	EXPORT	|??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|Sleep|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|MmMapIoSpace|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43417| DCD	|$LN21@SPI_Init|
	DCD	0x40007702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "E", 0x0, "R"
	DCB	0x0, "R", 0x0, "O", 0x0, "R", 0x0, " ", 0x0, "h", 0x0, "o"
	DCB	0x0, "l", 0x0, "d", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "s"
	DCB	0x0, "e", 0x0, "t", 0x0, ".", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_Init| PROC

; 98   : {

  00000		 |$LN21@SPI_Init|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43414|
  00008	e1a06000	 mov         r6, r0

; 99   :     DWORD rc = (DWORD)NULL;
; 100  :     SPI_DEVICE *pDevice = NULL;
; 101  :     PHYSICAL_ADDRESS pa;
; 102  :     DWORD dwCount=0;
; 103  : 
; 104  :     DEBUGMSG(ZONE_INIT, (
; 105  :         L"+SPI_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 106  :     ));
; 107  : 
; 108  :     // Create device structure
; 109  :     pDevice = (SPI_DEVICE *)LocalAlloc(LPTR, sizeof(SPI_DEVICE));

  0000c	e3a0103c	 mov         r1, #0x3C
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a07000	 mov         r7, #0
  00018	e3a05000	 mov         r5, #0
  0001c	eb000000	 bl          LocalAlloc
  00020	e1b04000	 movs        r4, r0

; 110  :     if (pDevice == NULL) {

  00024	0a000060	 beq         |$LN16@SPI_Init|

; 111  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 112  :             L"Failed allocate SPI controller structure\r\n"
; 113  :         ));
; 114  :         goto cleanUp;
; 115  :     }
; 116  : 
; 117  :     // Set cookie
; 118  :     pDevice->cookie = SPI_DEVICE_COOKIE;

  00028	e59f31a8	 ldr         r3, [pc, #0x1A8]

; 119  : 
; 120  :     // Initalize critical section
; 121  :     InitializeCriticalSection(&pDevice->cs);

  0002c	e1a00004	 mov         r0, r4
  00030	e4803018	 str         r3, [r0], #0x18
  00034	eb000000	 bl          InitializeCriticalSection

; 122  : 
; 123  :     // Read device parameters
; 124  :     if (GetDeviceRegistryParams(
; 125  :         szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams
; 126  :     ) != ERROR_SUCCESS) {

  00038	e59f3194	 ldr         r3, [pc, #0x194]
  0003c	e3a02003	 mov         r2, #3
  00040	e1a01004	 mov         r1, r4
  00044	e1a00006	 mov         r0, r6
  00048	eb000000	 bl          GetDeviceRegistryParams
  0004c	e3500000	 cmp         r0, #0
  00050	1a000055	 bne         |$LN16@SPI_Init|

; 127  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 128  :             L"Failed read SPI driver registry parameters\r\n"
; 129  :         ));
; 130  :         goto cleanUp;
; 131  :     }
; 132  : 
; 133  :     // Open parent bus
; 134  :     pDevice->hParentBus = CreateBusAccessHandle(szContext);

  00054	e1a00006	 mov         r0, r6
  00058	eb000000	 bl          CreateBusAccessHandle
  0005c	e3500000	 cmp         r0, #0
  00060	e5840010	 str         r0, [r4, #0x10]

; 135  :     if (pDevice->hParentBus == NULL) {

  00064	0a000050	 beq         |$LN16@SPI_Init|

; 136  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 137  :             L"Failed open parent bus driver\r\n"
; 138  :         ));
; 139  :         goto cleanUp;
; 140  :     }
; 141  : 
; 142  :     // Set hardware to full power
; 143  :     pDevice->powerState = D0;

  00068	e3a06000	 mov         r6, #0

; 144  :     SPI_ClockOn(pDevice);

  0006c	e1a00004	 mov         r0, r4
  00070	e5846038	 str         r6, [r4, #0x38]
  00074	eb000000	 bl          SPI_ClockOn

; 145  :     SetDevicePowerState(pDevice->hParentBus, D0, NULL);

  00078	e5940010	 ldr         r0, [r4, #0x10]
  0007c	e3a02000	 mov         r2, #0
  00080	e3a01000	 mov         r1, #0
  00084	eb000000	 bl          SetDevicePowerState

; 146  : 
; 147  :     // Map SPI controller
; 148  :     pa.QuadPart = pDevice->memBase;

  00088	e5940004	 ldr         r0, [r4, #4]
  0008c	e3a01000	 mov         r1, #0

; 149  :     pDevice->pSPIRegs = MmMapIoSpace(pa, sizeof(OMAP2420_MCSPI_REGS), FALSE);

  00090	e3a03000	 mov         r3, #0
  00094	e3a0207c	 mov         r2, #0x7C
  00098	eb000000	 bl          MmMapIoSpace
  0009c	e3500000	 cmp         r0, #0
  000a0	e5840014	 str         r0, [r4, #0x14]

; 150  :     if (pDevice->pSPIRegs == NULL) {

  000a4	0a000040	 beq         |$LN16@SPI_Init|

; 151  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 152  :             L"Failed map SPI controller registers\r\n"
; 153  :         ));
; 154  :         goto cleanUp;
; 155  :     }
; 156  : 
; 157  :     // Map SPI interrupt
; 158  :     if (!KernelIoControl(
; 159  :         IOCTL_HAL_REQUEST_SYSINTR, &pDevice->irq, sizeof(pDevice->irq), 
; 160  :         &pDevice->sysIntr, sizeof(pDevice->sysIntr), NULL
; 161  :     )) {

  000a8	e59f0120	 ldr         r0, [pc, #0x120]
  000ac	e3a08004	 mov         r8, #4
  000b0	e284302c	 add         r3, r4, #0x2C
  000b4	e3a02004	 mov         r2, #4
  000b8	e2841008	 add         r1, r4, #8
  000bc	e58d6004	 str         r6, [sp, #4]
  000c0	e58d8000	 str         r8, [sp]
  000c4	eb000000	 bl          KernelIoControl
  000c8	e3500000	 cmp         r0, #0
  000cc	0a000036	 beq         |$LN16@SPI_Init|

; 162  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 163  :             L"Failed map SPI controller interrupt\r\n"
; 164  :         ));
; 165  :         goto cleanUp;
; 166  :     }
; 167  : 
; 168  :     // Create interrupt event
; 169  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  000d0	e3a03000	 mov         r3, #0
  000d4	e3a02000	 mov         r2, #0
  000d8	e3a01000	 mov         r1, #0
  000dc	e3a00000	 mov         r0, #0
  000e0	eb000000	 bl          CreateEventW
  000e4	e1b01000	 movs        r1, r0
  000e8	e5841030	 str         r1, [r4, #0x30]

; 170  :     if (pDevice->hIntrEvent == NULL) {

  000ec	0a00002e	 beq         |$LN16@SPI_Init|

; 171  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_Init: "
; 172  :             L"Failed create interrupt event\r\n"
; 173  :         ));
; 174  :         goto cleanUp;
; 175  :     }
; 176  : 
; 177  :     // Initialize interrupt
; 178  :     if (!InterruptInitialize(pDevice->sysIntr, pDevice->hIntrEvent, NULL, 0)) {

  000f0	e594002c	 ldr         r0, [r4, #0x2C]
  000f4	e3a03000	 mov         r3, #0
  000f8	e3a02000	 mov         r2, #0
  000fc	eb000000	 bl          InterruptInitialize
  00100	e3500000	 cmp         r0, #0
  00104	0a000028	 beq         |$LN16@SPI_Init|

; 179  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: SPI_Init: "
; 180  :             L"InterruptInitialize failed\r\n"
; 181  :         ));
; 182  :         goto cleanUp;
; 183  :     }
; 184  : 
; 185  :     // Reset the SPI controller
; 186  :     SETREG32(&pDevice->pSPIRegs->ulMCSPI_SYSCONFIG, SPI_SYSC_SRST);

  00108	e5942014	 ldr         r2, [r4, #0x14]
  0010c	e5923010	 ldr         r3, [r2, #0x10]
  00110	e3833002	 orr         r3, r3, #2
  00114	e5823010	 str         r3, [r2, #0x10]

; 187  : 
; 188  :     // TODO: Get base clock from kernel & read L/H periods from registry
; 189  : 
; 190  :     // Wait until resetting is done
; 191  :     while ( !(INREG32(&pDevice->pSPIRegs->ulMCSPI_SYSSTATUS) & BIT0)) {

  00118	ea000004	 b           |$LN18@SPI_Init|
  0011c		 |$LL4@SPI_Init|

; 192  :         Sleep (1);

  0011c	e3a00001	 mov         r0, #1
  00120	eb000000	 bl          Sleep

; 193  : 
; 194  :         if (dwCount++>0x100)

  00124	e3550c01	 cmp         r5, #1, 24
  00128	e2855001	 add         r5, r5, #1
  0012c	8a000018	 bhi         |$LN15@SPI_Init|
  00130		 |$LN18@SPI_Init|
  00130	e5943014	 ldr         r3, [r4, #0x14]
  00134	e5933014	 ldr         r3, [r3, #0x14]
  00138	e3130001	 tst         r3, #1
  0013c	0afffff6	 beq         |$LL4@SPI_Init|

; 198  :             goto cleanUp;
; 199  :         }
; 200  :     }
; 201  : 
; 202  :     // Disable all interrupts.
; 203  :     OUTREG32(&pDevice->pSPIRegs->ulMCSPI_IRQENABLE, 0);

  00140	e5943014	 ldr         r3, [r4, #0x14]
  00144	e3a02cff	 mov         r2, #0xFF, 24

; 204  : 
; 205  :     // Clear interrupts.
; 206  :     OUTREG32(&pDevice->pSPIRegs->ulMCSPI_IRQSTATUS, 0xFFFF);

  00148	e38200ff	 orr         r0, r2, #0xFF
  0014c	e583601c	 str         r6, [r3, #0x1C]
  00150	e5943014	 ldr         r3, [r4, #0x14]

; 207  : 
; 208  : 
; 209  :     // Setup Module Control as master
; 210  :     OUTREG32(&pDevice->pSPIRegs->ulMCSPI_MODULCTRL, 0);
; 211  : 
; 212  :     // Turn on the clock on default 1M rate.
; 213  :     // Reset the SPI controller
; 214  :     SETREG32(&pDevice->pSPIRegs->ulMCSPI_SYSCONFIG, 0x308);
; 215  : //    g_pSpiRegs->ulSET1 &= ~0x001E;
; 216  : //    g_pSpiRegs->ulSET1 |= (GetClockParams(INIT_CLOCK_RATE) << 1);
; 217  : //    g_pSpiRegs->ulSET1 |= BIT0;
; 218  : 
; 219  : 
; 220  :     // Enable the SPI
; 221  : //    SETREG16(&pDevice->pSPIRegs->CON, SPI_CON_EN);
; 222  : 
; 223  :     // Return non-null value
; 224  :     rc = (DWORD)pDevice;
; 225  : 
; 226  :     // Set this driver to internal suspend mode
; 227  :     SetDevicePowerState(pDevice->hParentBus, pDevice->powerState = D4, NULL);

  00154	e3a02000	 mov         r2, #0
  00158	e3a01004	 mov         r1, #4
  0015c	e5830018	 str         r0, [r3, #0x18]
  00160	e5943014	 ldr         r3, [r4, #0x14]
  00164	e1a07004	 mov         r7, r4
  00168	e5836028	 str         r6, [r3, #0x28]
  0016c	e5940014	 ldr         r0, [r4, #0x14]
  00170	e5903010	 ldr         r3, [r0, #0x10]
  00174	e3833fc2	 orr         r3, r3, #0xC2, 30
  00178	e5803010	 str         r3, [r0, #0x10]
  0017c	e5940010	 ldr         r0, [r4, #0x10]
  00180	e5848038	 str         r8, [r4, #0x38]
  00184	eb000000	 bl          SetDevicePowerState

; 228  :     SPI_ClockOff(pDevice);

  00188	e1a00004	 mov         r0, r4
  0018c	eb000000	 bl          SPI_ClockOff
  00190		 |$cleanUp$42839|

; 229  : 
; 230  : cleanUp:
; 231  :     if (rc == 0) SPI_Deinit((DWORD)pDevice);

  00190	ea000007	 b           |$LN1@SPI_Init|
  00194		 |$LN15@SPI_Init|

; 195  :         {
; 196  :             // Break out dead lock, something is wrong.
; 197  :             ERRORMSG (TRUE, (TEXT("SPI: ERROR holding in reset.\n")));

  00194	e59f1030	 ldr         r1, [pc, #0x30]
  00198	e59f0028	 ldr         r0, [pc, #0x28]
  0019c	e3a020c5	 mov         r2, #0xC5
  001a0	eb000000	 bl          NKDbgPrintfW
  001a4	e59f0018	 ldr         r0, [pc, #0x18]
  001a8	eb000000	 bl          NKDbgPrintfW
  001ac		 |$LN16@SPI_Init|

; 229  : 
; 230  : cleanUp:
; 231  :     if (rc == 0) SPI_Deinit((DWORD)pDevice);

  001ac	e1a00004	 mov         r0, r4
  001b0	eb000000	 bl          SPI_Deinit
  001b4		 |$LN1@SPI_Init|

; 232  :     DEBUGMSG(ZONE_INIT, (L"-SPI_Init(rc = %d)\r\n", rc));
; 233  :     return rc;
; 234  : }

  001b4	e1a00007	 mov         r0, r7
  001b8	e28dd008	 add         sp, sp, #8
  001bc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$LN22@SPI_Init|
  001c4		 |$LN23@SPI_Init|
  001c4	00000000	 DCD         |??_C@_1DM@JFMOKFBI@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?5?$AAh?$AAo?$AAl?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAn?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?4?$AA?6?$AA?$AA@|
  001c8		 |$LN24@SPI_Init|
  001c8	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  001cc		 |$LN25@SPI_Init|
  001cc	00000000	 DCD         |??_C@_1HO@LHOFFFL@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  001d0		 |$LN26@SPI_Init|
  001d0	01010098	 DCD         0x1010098
  001d4		 |$LN27@SPI_Init|
  001d4	00000000	 DCD         |g_deviceRegParams|
  001d8		 |$LN28@SPI_Init|
  001d8	73706944	 DCD         0x73706944
  001dc		 |$M43415|

			 ENDP  ; |SPI_Init|

	EXPORT	|SPI_IOControl|
	EXPORT	|??_C@_1GG@NBABJICD@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAC?$AAA?$AAP?$AAA?$AAB?$AAI?$AAL?$AAI?$AAT?$AAI?$AAE?$AAS?$AA?5?$AAI?$AAn@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FE@ONJIKFBL@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAG?$AAE?$AAT?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAa?$AAr@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DO@MLBDJCHL@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAC?$AAe?$AAS?$AAa?$AAf?$AAe?$AAC?$AAo?$AAp?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FC@FNIABNAM@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS?$AAE?$AAT?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAa?$AAr?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@ONBGFDOB@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS?$AAE?$AAT?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo?$AAw@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EG@CDHLAJIG@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAx?$AAx?$AAx?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA?4?$AA8?$AAX?$AA?$CJ?$AA?5@| [ DATA ] ; `string'
	IMPORT	|SetLastError|
	IMPORT	|GetCallerProcess|
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|memcmp|
	IMPORT	|memset|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43459| DCD	|$LN50@SPI_IOCont|
	DCD	0x4000d502

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GG@NBABJICD@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAC?$AAA?$AAP?$AAA?$AAB?$AAI?$AAL?$AAI?$AAT?$AAI?$AAE?$AAS?$AA?5?$AAI?$AAn@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "O"
	DCB	0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_", 0x0, "P", 0x0, "O"
	DCB	0x0, "W", 0x0, "E", 0x0, "R", 0x0, "_", 0x0, "C", 0x0, "A"
	DCB	0x0, "P", 0x0, "A", 0x0, "B", 0x0, "I", 0x0, "L", 0x0, "I"
	DCB	0x0, "T", 0x0, "I", 0x0, "E", 0x0, "S", 0x0, " ", 0x0, "I"
	DCB	0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d"
	DCB	0x0, " ", 0x0, "p", 0x0, "a", 0x0, "r", 0x0, "a", 0x0, "m"
	DCB	0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, ".", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FE@ONJIKFBL@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAG?$AAE?$AAT?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAa?$AAr@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "O"
	DCB	0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_", 0x0, "P", 0x0, "O"
	DCB	0x0, "W", 0x0, "E", 0x0, "R", 0x0, "_", 0x0, "G", 0x0, "E"
	DCB	0x0, "T", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "v", 0x0, "a"
	DCB	0x0, "l", 0x0, "i", 0x0, "d", 0x0, " ", 0x0, "p", 0x0, "a"
	DCB	0x0, "r", 0x0, "a", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, ".", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@MLBDJCHL@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAC?$AAe?$AAS?$AAa?$AAf?$AAe?$AAC?$AAo?$AAp?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "e"
	DCB	0x0, "S", 0x0, "a", 0x0, "f", 0x0, "e", 0x0, "C", 0x0, "o"
	DCB	0x0, "p", 0x0, "y", 0x0, "M", 0x0, "e", 0x0, "m", 0x0, "o"
	DCB	0x0, "r", 0x0, "y", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FC@FNIABNAM@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS?$AAE?$AAT?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAa?$AAr?$AAa@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "O"
	DCB	0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_", 0x0, "P", 0x0, "O"
	DCB	0x0, "W", 0x0, "E", 0x0, "R", 0x0, "_", 0x0, "S", 0x0, "E"
	DCB	0x0, "T", 0x0, "I", 0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l"
	DCB	0x0, "i", 0x0, "d", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "r"
	DCB	0x0, "a", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, ".", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@ONBGFDOB@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS?$AAE?$AAT?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo?$AAw@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "O"
	DCB	0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_", 0x0, "P", 0x0, "O"
	DCB	0x0, "W", 0x0, "E", 0x0, "R", 0x0, "_", 0x0, "S", 0x0, "E"
	DCB	0x0, "T", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "v", 0x0, "a"
	DCB	0x0, "l", 0x0, "i", 0x0, "d", 0x0, " ", 0x0, "p", 0x0, "o"
	DCB	0x0, "w", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "t"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, ".", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EG@CDHLAJIG@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAx?$AAx?$AAx?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA?4?$AA8?$AAX?$AA?$CJ?$AA?5@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, ":", 0x0, " ", 0x0, "U", 0x0, "n"
	DCB	0x0, "k", 0x0, "n", 0x0, "o", 0x0, "w", 0x0, "n", 0x0, " "
	DCB	0x0, "I", 0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L", 0x0, "_"
	DCB	0x0, "x", 0x0, "x", 0x0, "x", 0x0, "(", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, ".", 0x0, "8", 0x0, "X", 0x0, ")"
	DCB	0x0, " ", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\spi\spi.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SPI_IOControl| PROC

; 486  : ) {

  00000		 |$LN50@SPI_IOCont|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd040	 sub         sp, sp, #0x40
  00008		 |$M43456|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a06001	 mov         r6, r1
  00014	e1b09000	 movs        r9, r0

; 487  :     BOOL bRetVal = FALSE;

  00018	e3a05000	 mov         r5, #0

; 488  :     SPI_DEVICE *pDevice = NULL;
; 489  :     SPI_INSTANCE *pInstance = (SPI_INSTANCE*)context;
; 490  :     DEVICE_IFC_SPI ifc;
; 491  : 
; 492  :     DEBUGMSG(ZONE_FUNCTION, (
; 493  :         L"+SPI_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 494  :         context, dwCode, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 495  :     ));
; 496  : 
; 497  :     // Check if we get correct context
; 498  :     if (pInstance == NULL || pInstance->cookie != SPI_INSTANCE_COOKIE) {

  0001c	0a0000b9	 beq         |$clean$43045|
  00020	e5994000	 ldr         r4, [r9]
  00024	e59fe324	 ldr         lr, [pc, #0x324]
  00028	e154000e	 cmp         r4, lr
  0002c	1a0000b5	 bne         |$clean$43045|
  00030	e3a03822	 mov         r3, #0x22, 16

; 499  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_IOControl: "
; 500  :             L"Incorrect context paramer\r\n"
; 501  :         ));
; 502  :         goto clean;
; 503  :     }
; 504  : 
; 505  :     //Get Device
; 506  :     pDevice = pInstance->pDevice;
; 507  : 
; 508  :     switch (dwCode) {

  00034	e383eb01	 orr         lr, r3, #1, 22
  00038	e5994004	 ldr         r4, [r9, #4]
  0003c	e156000e	 cmp         r6, lr
  00040	0a000089	 beq         |$LN33@SPI_IOCont|
  00044	e3a03822	 mov         r3, #0x22, 16
  00048	e383eb02	 orr         lr, r3, #2, 22
  0004c	e156000e	 cmp         r6, lr
  00050	0a000078	 beq         |$LN24@SPI_IOCont|
  00054	e3a03832	 mov         r3, #0x32, 16
  00058	e3833a01	 orr         r3, r3, #1, 20
  0005c	e1560003	 cmp         r6, r3
  00060	0a00004b	 beq         |$LN20@SPI_IOCont|
  00064	e59f32e0	 ldr         r3, [pc, #0x2E0]
  00068	e1560003	 cmp         r6, r3
  0006c	0a00002f	 beq         |$LN6@SPI_IOCont|
  00070	e59f32d0	 ldr         r3, [pc, #0x2D0]
  00074	e1560003	 cmp         r6, r3
  00078	0a00000c	 beq         |$LN14@SPI_IOCont|
  0007c	e59f32c0	 ldr         r3, [pc, #0x2C0]
  00080	e1560003	 cmp         r6, r3
  00084	0a000007	 beq         |$LN15@SPI_IOCont|

; 672  :     }
; 673  : 
; 674  : 
; 675  :     default:
; 676  :         ERRORMSG(1, (TEXT("SPI: Unknown IOCTL_xxx(0x%0.8X) \r\n"), dwCode));

  00088	e59f129c	 ldr         r1, [pc, #0x29C]
  0008c	e59f0294	 ldr         r0, [pc, #0x294]
  00090	e3a02fa9	 mov         r2, #0xA9, 30
  00094	eb000000	 bl          NKDbgPrintfW
  00098	e59f02a0	 ldr         r0, [pc, #0x2A0]
  0009c	e1a01006	 mov         r1, r6
  000a0	eb000000	 bl          NKDbgPrintfW

; 677  :         break;

  000a4	ea000097	 b           |$clean$43045|
  000a8		 |$LN15@SPI_IOCont|

; 588  :     }
; 589  : 
; 590  :     // Indicate if the device is ready to enter a new device power state.
; 591  :     case IOCTL_POWER_QUERY:
; 592  :     {
; 593  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI: IOCTL_POWER_QUERY"
; 594  :             L"Deprecated Function Called\r\n")));
; 595  :         bRetVal = FALSE;

  000a8	e3a05000	 mov         r5, #0

; 596  :         break;

  000ac	ea000095	 b           |$clean$43045|
  000b0		 |$LN14@SPI_IOCont|

; 597  :     }
; 598  : 
; 599  :     // Request a change from one device power state to another
; 600  :     // This driver self-manages it's internal power state by controlling
; 601  :     // functional and interface clocks as needed in the Read and Write
; 602  :     // functions rather than waiting for PM to tell it to save power
; 603  :     // So the set calls below just update the power state variable
; 604  :     case IOCTL_POWER_SET:
; 605  :     {
; 606  :         CEDEVICE_POWER_STATE dxState;
; 607  : 
; 608  :         // Check arguments.
; 609  :         if (pOutBuffer == NULL || outSize < sizeof(CEDEVICE_POWER_STATE))

  000b0	e59d105c	 ldr         r1, [sp, #0x5C]
  000b4	e3510000	 cmp         r1, #0
  000b8	0a000015	 beq         |$LN12@SPI_IOCont|
  000bc	e59d3060	 ldr         r3, [sp, #0x60]
  000c0	e3530004	 cmp         r3, #4
  000c4	3a000012	 bcc         |$LN12@SPI_IOCont|

; 613  :             break;
; 614  :         }
; 615  : 
; 616  :         if (CeSafeCopyMemory(&dxState, pOutBuffer, sizeof(dxState)) == 0) break;

  000c8	e3a02004	 mov         r2, #4
  000cc	e28d0000	 add         r0, sp, #0
  000d0	eb000000	 bl          CeSafeCopyMemory
  000d4	e3500000	 cmp         r0, #0
  000d8	0a00008a	 beq         |$clean$43045|

; 617  : 
; 618  :         DEBUGMSG(ZONE_POWER, ( TEXT( "SPI: IOCTL_POWER_SET = %d.\r\n"), dxState));
; 619  : 
; 620  :         // Check for any valid power state.
; 621  :         if (VALID_DX(dxState))

  000dc	e59d3000	 ldr         r3, [sp]
  000e0	e3530004	 cmp         r3, #4
  000e4	8a000003	 bhi         |$LN10@SPI_IOCont|

; 622  :         {
; 623  :             // Power off
; 624  :             if ( dxState == D4 )
; 625  :             {
; 626  :                 // Set this driver to low power mode external state
; 627  :                 pDevice->powerState = dxState;

  000e8	03a03004	 moveq       r3, #4

; 628  :             }
; 629  :             // Power on.
; 630  :             else
; 631  :             {
; 632  :                 //Set to high power external state
; 633  :                 pDevice->powerState = dxState;

  000ec	e5843038	 str         r3, [r4, #0x38]
  000f0	e3a05001	 mov         r5, #1
  000f4	ea000083	 b           |$clean$43045|
  000f8		 |$LN10@SPI_IOCont|

; 634  :             }
; 635  :             bRetVal = TRUE;
; 636  :         }
; 637  :         else
; 638  :         {
; 639  :             ERRORMSG( TRUE, ( TEXT( "SPI: IOCTL_POWER_SET "
; 640  :                 L"Invalid power state.\r\n" ) ) );

  000f8	e59f122c	 ldr         r1, [pc, #0x22C]
  000fc	e59f0224	 ldr         r0, [pc, #0x224]
  00100	e3a02d0a	 mov         r2, #0xA, 26
  00104	eb000000	 bl          NKDbgPrintfW
  00108	e59f022c	 ldr         r0, [pc, #0x22C]
  0010c	eb000000	 bl          NKDbgPrintfW
  00110	ea00007c	 b           |$clean$43045|
  00114		 |$LN12@SPI_IOCont|

; 610  :         {
; 611  :             ERRORMSG( TRUE, ( TEXT( "SPI: IOCTL_POWER_SET"
; 612  :                 L"Invalid parameter.\r\n" ) ) );

  00114	e59f1210	 ldr         r1, [pc, #0x210]
  00118	e59f0208	 ldr         r0, [pc, #0x208]
  0011c	e3a02f99	 mov         r2, #0x99, 30
  00120	eb000000	 bl          NKDbgPrintfW
  00124	e59f020c	 ldr         r0, [pc, #0x20C]
  00128	eb000000	 bl          NKDbgPrintfW
  0012c	ea000075	 b           |$clean$43045|
  00130		 |$LN6@SPI_IOCont|

; 641  :         }
; 642  :         break;
; 643  :     }
; 644  : 
; 645  :     // Return the current device power state.
; 646  :     case IOCTL_POWER_GET:
; 647  :     {
; 648  :         // Check arguments.
; 649  :         if (pOutBuffer == NULL || outSize < sizeof(CEDEVICE_POWER_STATE))

  00130	e59d005c	 ldr         r0, [sp, #0x5C]
  00134	e3500000	 cmp         r0, #0
  00138	0a00000e	 beq         |$LN4@SPI_IOCont|
  0013c	e59d3060	 ldr         r3, [sp, #0x60]
  00140	e3530004	 cmp         r3, #4
  00144	3a00000b	 bcc         |$LN4@SPI_IOCont|

; 653  :             break;
; 654  :         }
; 655  : 
; 656  :         //Copy current state
; 657  :         if (CeSafeCopyMemory(pOutBuffer, &pDevice->powerState, sizeof(pDevice->powerState)) == 0)

  00148	e3a02004	 mov         r2, #4
  0014c	e2841038	 add         r1, r4, #0x38
  00150	eb000000	 bl          CeSafeCopyMemory
  00154	e3500000	 cmp         r0, #0

; 658  :         {
; 659  :             ERRORMSG( TRUE, ( TEXT( "SPI: CeSafeCopyMemory Failed\r\n" ) ) );

  00158	03a03c02	 moveq       r3, #2, 24
  0015c	03832093	 orreq       r2, r3, #0x93
  00160	0a00001f	 beq         |$LN47@SPI_IOCont|

; 660  :             break;
; 661  :         }
; 662  : 
; 663  :         // Update returned data size.
; 664  :         if (pOutSize)

  00164	e59d3064	 ldr         r3, [sp, #0x64]
  00168	e3530000	 cmp         r3, #0
  0016c	0a000027	 beq         |$LN16@SPI_IOCont|

; 665  :         {
; 666  :             *pOutSize = sizeof(pDevice->powerState);

  00170	e3a02004	 mov         r2, #4

; 667  :         }
; 668  : 
; 669  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI: IOCTL_POWER_GET: %d\r\n"), pDevice->powerState));
; 670  :         bRetVal = TRUE;
; 671  :         break;

  00174	ea000024	 b           |$LN45@SPI_IOCont|
  00178		 |$LN4@SPI_IOCont|

; 650  :         {
; 651  :             ERRORMSG( TRUE, ( TEXT( "SPI: IOCTL_POWER_GET "
; 652  :                 L"Invalid parameter.\r\n" ) ) );

  00178	e59f11ac	 ldr         r1, [pc, #0x1AC]
  0017c	e59f01a4	 ldr         r0, [pc, #0x1A4]
  00180	e3a02fa3	 mov         r2, #0xA3, 30
  00184	eb000000	 bl          NKDbgPrintfW
  00188	e59f01a4	 ldr         r0, [pc, #0x1A4]
  0018c	eb000000	 bl          NKDbgPrintfW
  00190	ea00005c	 b           |$clean$43045|
  00194		 |$LN20@SPI_IOCont|

; 550  :         break;
; 551  : 
; 552  : 
; 553  :     // Power management functions.
; 554  :     // Return device specific power capabilities.
; 555  :     case IOCTL_POWER_CAPABILITIES:
; 556  :     {
; 557  :         POWER_CAPABILITIES pc;
; 558  : 
; 559  :         // Check arguments.
; 560  :         if ( pOutBuffer == NULL || outSize < sizeof(POWER_CAPABILITIES))

  00194	e59d405c	 ldr         r4, [sp, #0x5C]
  00198	e3540000	 cmp         r4, #0
  0019c	0a00001d	 beq         |$LN18@SPI_IOCont|
  001a0	e59d3060	 ldr         r3, [sp, #0x60]
  001a4	e3530030	 cmp         r3, #0x30
  001a8	3a00001a	 bcc         |$LN18@SPI_IOCont|

; 565  :         }
; 566  : 
; 567  :         // Clear capabilities structure.
; 568  :         memset(&pc, 0, sizeof(POWER_CAPABILITIES));

  001ac	e3a02030	 mov         r2, #0x30
  001b0	e3a01000	 mov         r1, #0
  001b4	e28d0010	 add         r0, sp, #0x10
  001b8	eb000000	 bl          memset

; 569  : 
; 570  :         // Set power capabilities. Supports D0 and D4.
; 571  :         pc.DeviceDx = DX_MASK(D0)|DX_MASK(D4);

  001bc	e3a03011	 mov         r3, #0x11

; 572  : 
; 573  :         DEBUGMSG(ZONE_POWER, (TEXT("SPI: IOCTL_POWER_CAPABILITIES = 0x%x\r\n"), pc.DeviceDx));
; 574  : 
; 575  :         if (CeSafeCopyMemory(pOutBuffer, &pc, sizeof(pc)) == 0)

  001c0	e3a02030	 mov         r2, #0x30
  001c4	e28d1010	 add         r1, sp, #0x10
  001c8	e1a00004	 mov         r0, r4
  001cc	e5cd3010	 strb        r3, [sp, #0x10]
  001d0	eb000000	 bl          CeSafeCopyMemory
  001d4	e3500000	 cmp         r0, #0
  001d8	1a000007	 bne         |$LN17@SPI_IOCont|

; 576  :         {
; 577  :             ERRORMSG( TRUE, ( TEXT( "SPI: CeSafeCopyMemory Failed\r\n" ) ) );

  001dc	e3a03c02	 mov         r3, #2, 24
  001e0	e3832041	 orr         r2, r3, #0x41
  001e4		 |$LN47@SPI_IOCont|
  001e4	e59f013c	 ldr         r0, [pc, #0x13C]
  001e8	e59f113c	 ldr         r1, [pc, #0x13C]
  001ec	eb000000	 bl          NKDbgPrintfW
  001f0	e59f0138	 ldr         r0, [pc, #0x138]
  001f4	eb000000	 bl          NKDbgPrintfW
  001f8	ea000042	 b           |$clean$43045|
  001fc		 |$LN17@SPI_IOCont|

; 578  :             break;
; 579  :         }
; 580  : 
; 581  :         // Update returned data size.
; 582  :         if (pOutSize)

  001fc	e59d3064	 ldr         r3, [sp, #0x64]
  00200	e3530000	 cmp         r3, #0
  00204	0a000001	 beq         |$LN16@SPI_IOCont|

; 583  :         {
; 584  :             *pOutSize = sizeof(pc);

  00208	e3a02030	 mov         r2, #0x30
  0020c		 |$LN45@SPI_IOCont|
  0020c	e5832000	 str         r2, [r3]
  00210		 |$LN16@SPI_IOCont|

; 585  :         }
; 586  :         bRetVal = TRUE;

  00210	e3a05001	 mov         r5, #1

; 587  :         break;

  00214	ea00003b	 b           |$clean$43045|
  00218		 |$LN18@SPI_IOCont|

; 561  :         {
; 562  :             ERRORMSG( TRUE, ( TEXT( "SPI: IOCTL_POWER_CAPABILITIES "
; 563  :                 L"Invalid parameter.\r\n" ) ) );

  00218	e59f110c	 ldr         r1, [pc, #0x10C]
  0021c	e59f0104	 ldr         r0, [pc, #0x104]
  00220	e3a03c02	 mov         r3, #2, 24
  00224	e3832033	 orr         r2, r3, #0x33
  00228	eb000000	 bl          NKDbgPrintfW
  0022c	e59f00f0	 ldr         r0, [pc, #0xF0]
  00230	eb000000	 bl          NKDbgPrintfW

; 564  :             break;

  00234	ea000033	 b           |$clean$43045|
  00238		 |$LN24@SPI_IOCont|

; 535  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 536  :                 break;
; 537  :             }
; 538  :             bRetVal = TRUE;
; 539  :             break;
; 540  :         }
; 541  :         SetLastError(ERROR_INVALID_PARAMETER);
; 542  :         break;
; 543  :     case IOCTL_SPI_SET_SLAVE_ADDRESS:
; 544  :         if (pOutSize != NULL) *pOutSize = sizeof(DWORD);

  00238	e59d3064	 ldr         r3, [sp, #0x64]
  0023c	e3530000	 cmp         r3, #0
  00240	13a02004	 movne       r2, #4
  00244	15832000	 strne       r2, [r3]

; 545  :         if (pInBuffer == NULL || inSize < sizeof(DWORD)) {

  00248	e3570000	 cmp         r7, #0
  0024c	0a00002b	 beq         |$LN30@SPI_IOCont|
  00250	e3580004	 cmp         r8, #4
  00254	3a000029	 bcc         |$LN30@SPI_IOCont|

; 546  :             SetLastError(ERROR_INVALID_PARAMETER);
; 547  :             break;
; 548  :         }
; 549  :         bRetVal = SPI_SetSlaveAddress(context, (DWORD)*pInBuffer);

  00258	e5d71000	 ldrb        r1, [r7]
  0025c	e1a00009	 mov         r0, r9
  00260	eb000000	 bl          SPI_SetSlaveAddress
  00264	e1a05000	 mov         r5, r0
  00268	ea000026	 b           |$clean$43045|
  0026c		 |$LN33@SPI_IOCont|

; 509  :     case IOCTL_DDK_GET_DRIVER_IFC:
; 510  :         // We can give interface only to our peer in device process
; 511  :         if (GetCurrentProcessId() != (DWORD)GetCallerProcess()) {

  0026c	e3a0000c	 mov         r0, #0xC
  00270	eb000000	 bl          __GetUserKData
  00274	e1a04000	 mov         r4, r0
  00278	eb000000	 bl          GetCallerProcess
  0027c	e1540000	 cmp         r4, r0

; 512  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: SPI_IOControl: "
; 513  :                 L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 514  :                 L"device process (caller process id 0x%08x)\r\n",
; 515  :                 GetCallerProcess()
; 516  :             ));
; 517  :             SetLastError(ERROR_ACCESS_DENIED);

  00280	13a00005	 movne       r0, #5
  00284	1a00001e	 bne         |$LN43@SPI_IOCont|

; 518  :             goto clean;
; 519  :         }
; 520  :         // Check input parameters
; 521  :         if (pInBuffer == NULL || inSize < sizeof(GUID)) {

  00288	e3570000	 cmp         r7, #0
  0028c	0a00001b	 beq         |$LN30@SPI_IOCont|
  00290	e3580010	 cmp         r8, #0x10
  00294	3a000019	 bcc         |$LN30@SPI_IOCont|

; 523  :             break;
; 524  :         }
; 525  :         if (IsEqualGUID(pInBuffer, &DEVICE_IFC_SPI_GUID)) {

  00298	e59f1080	 ldr         r1, [pc, #0x80]
  0029c	e3a02010	 mov         r2, #0x10
  002a0	e1a00007	 mov         r0, r7
  002a4	eb000000	 bl          memcmp
  002a8	e3500000	 cmp         r0, #0
  002ac	1a000013	 bne         |$LN30@SPI_IOCont|

; 526  :             if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_SPI);

  002b0	e59d3064	 ldr         r3, [sp, #0x64]

; 527  :             if (pOutBuffer == NULL || outSize < sizeof(DEVICE_IFC_SPI)) {

  002b4	e59d005c	 ldr         r0, [sp, #0x5C]
  002b8	e3530000	 cmp         r3, #0
  002bc	13a0200c	 movne       r2, #0xC
  002c0	15832000	 strne       r2, [r3]
  002c4	e3500000	 cmp         r0, #0
  002c8	0a00000c	 beq         |$LN30@SPI_IOCont|
  002cc	e59d3060	 ldr         r3, [sp, #0x60]
  002d0	e353000c	 cmp         r3, #0xC
  002d4	3a000009	 bcc         |$LN30@SPI_IOCont|

; 528  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 529  :                 break;
; 530  :             }
; 531  :             ifc.context = context;
; 532  :             ifc.pfnSetSlaveAddress = SPI_SetSlaveAddress;
; 533  :             ifc.pfnTransfer = SPI_Transfer;

  002d8	e59f103c	 ldr         r1, [pc, #0x3C]
  002dc	e59f3034	 ldr         r3, [pc, #0x34]

; 534  :             if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_SPI))) {

  002e0	e3a0200c	 mov         r2, #0xC
  002e4	e58d100c	 str         r1, [sp, #0xC]
  002e8	e28d1004	 add         r1, sp, #4
  002ec	e58d3008	 str         r3, [sp, #8]
  002f0	e58d9004	 str         r9, [sp, #4]
  002f4	eb000000	 bl          CeSafeCopyMemory
  002f8	e3500000	 cmp         r0, #0
  002fc	1affffc3	 bne         |$LN16@SPI_IOCont|
  00300		 |$LN30@SPI_IOCont|

; 522  :             SetLastError(ERROR_INVALID_PARAMETER);

  00300	e3a00057	 mov         r0, #0x57
  00304		 |$LN43@SPI_IOCont|
  00304	eb000000	 bl          SetLastError
  00308		 |$clean$43045|

; 678  :     }
; 679  : 
; 680  : clean:
; 681  :     DEBUGMSG(ZONE_FUNCTION, (L"-SPI_IOControl(rc = %d)\r\n", bRetVal));
; 682  :     return bRetVal;
; 683  : }

  00308	e1a00005	 mov         r0, r5
  0030c	e28dd040	 add         sp, sp, #0x40
  00310	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00314	e12fff1e	 bx          lr
  00318		 |$LN51@SPI_IOCont|
  00318		 |$LN52@SPI_IOCont|
  00318	00000000	 DCD         |SPI_SetSlaveAddress|
  0031c		 |$LN53@SPI_IOCont|
  0031c	00000000	 DCD         |SPI_Transfer|
  00320		 |$LN54@SPI_IOCont|
  00320	00000000	 DCD         |DEVICE_IFC_SPI_GUID|
  00324		 |$LN55@SPI_IOCont|
  00324	00000000	 DCD         |??_C@_1GG@NBABJICD@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAC?$AAA?$AAP?$AAA?$AAB?$AAI?$AAL?$AAI?$AAT?$AAI?$AAE?$AAS?$AA?5?$AAI?$AAn@|
  00328		 |$LN56@SPI_IOCont|
  00328	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  0032c		 |$LN57@SPI_IOCont|
  0032c	00000000	 DCD         |??_C@_1HO@LHOFFFL@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00330		 |$LN58@SPI_IOCont|
  00330	00000000	 DCD         |??_C@_1DO@MLBDJCHL@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAC?$AAe?$AAS?$AAa?$AAf?$AAe?$AAC?$AAo?$AAp?$AAy?$AAM?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00334		 |$LN59@SPI_IOCont|
  00334	00000000	 DCD         |??_C@_1FE@ONJIKFBL@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAG?$AAE?$AAT?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAa?$AAr@|
  00338		 |$LN60@SPI_IOCont|
  00338	00000000	 DCD         |??_C@_1FC@FNIABNAM@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS?$AAE?$AAT?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAa?$AAr?$AAa@|
  0033c		 |$LN61@SPI_IOCont|
  0033c	00000000	 DCD         |??_C@_1FI@ONBGFDOB@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAS?$AAE?$AAT?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAp?$AAo?$AAw@|
  00340		 |$LN62@SPI_IOCont|
  00340	00000000	 DCD         |??_C@_1EG@CDHLAJIG@?$AAS?$AAP?$AAI?$AA?3?$AA?5?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAx?$AAx?$AAx?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA?4?$AA8?$AAX?$AA?$CJ?$AA?5@|
  00344		 |$LN63@SPI_IOCont|
  00344	0032100c	 DCD         0x32100c
  00348		 |$LN64@SPI_IOCont|
  00348	00321008	 DCD         0x321008
  0034c		 |$LN65@SPI_IOCont|
  0034c	00321004	 DCD         0x321004
  00350		 |$LN66@SPI_IOCont|
  00350	73706949	 DCD         0x73706949
  00354		 |$M43457|

			 ENDP  ; |SPI_IOControl|

	END
