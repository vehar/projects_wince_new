; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\CEDDK\BASE\registry.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	IMPORT	|LocalAlloc|
	IMPORT	|RegQueryValueExW|
	IMPORT	|memcpy|
	IMPORT	|wcslen|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\ceddk\base\registry.c

  00000			 AREA	 |.pdata|, PDATA
|$T39380| DCD	|$LN18@GetStringP|
	DCD	0x40005202
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetStringParam| PROC

; 25   : ) {

  00000		 |$LN18@GetStringP|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M39377|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a05000	 mov         r5, r0

; 26   :     DWORD status, size, type;
; 27   :     WCHAR *pName;
; 28   :     UCHAR *pBuffer, *pValue;
; 29   : 
; 30   :     pName = pParam->name;
; 31   :     pValue = (UCHAR*)pBase + pParam->offset;
; 32   :     size = pParam->size;

  00010	e5943010	 ldr         r3, [r4, #0x10]
  00014	e594e00c	 ldr         lr, [r4, #0xC]
  00018	e5947000	 ldr         r7, [r4]
  0001c	e3530000	 cmp         r3, #0
  00020	e58d3008	 str         r3, [sp, #8]
  00024	e08e6001	 add         r6, lr, r1

; 33   : 
; 34   :     // If there is parameter size we simply try to read value or used default
; 35   :     if (size > 0) {
; 36   : 
; 37   :         status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00028	e28d3008	 add         r3, sp, #8
  0002c	e1a01007	 mov         r1, r7
  00030	e3a02000	 mov         r2, #0
  00034	0a000016	 beq         |$LN11@GetStringP|
  00038	e58d3004	 str         r3, [sp, #4]
  0003c	e28d300c	 add         r3, sp, #0xC
  00040	e58d6000	 str         r6, [sp]
  00044	eb000000	 bl          RegQueryValueExW
  00048	e3500000	 cmp         r0, #0

; 38   :         if (status == ERROR_SUCCESS || pParam->required) goto cleanUp;

  0004c	0a00003a	 beq         |$cleanUp$39158|
  00050	e5943008	 ldr         r3, [r4, #8]
  00054	e3530000	 cmp         r3, #0
  00058	1a000037	 bne         |$cleanUp$39158|

; 39   :         size = (wcslen((WCHAR*)pParam->pDefault) + 1) * sizeof(WCHAR);

  0005c	e5940014	 ldr         r0, [r4, #0x14]
  00060	eb000000	 bl          wcslen

; 40   :         if (size > pParam->size) {

  00064	e5942010	 ldr         r2, [r4, #0x10]
  00068	e2803001	 add         r3, r0, #1
  0006c	e1a03083	 mov         r3, r3, lsl #1
  00070	e58d3008	 str         r3, [sp, #8]
  00074	e1530002	 cmp         r3, r2

; 41   :             status = ERROR_OUTOFMEMORY;
; 42   :         } else {

  00078	8a000018	 bhi         |$LN14@GetStringP|

; 43   :             memcpy(pValue, pParam->pDefault, size);

  0007c	e5941014	 ldr         r1, [r4, #0x14]
  00080	e1a02003	 mov         r2, r3
  00084	e1a00006	 mov         r0, r6
  00088	eb000000	 bl          memcpy

; 62   :             status = ERROR_SUCCESS;

  0008c	e3a00000	 mov         r0, #0

; 63   :         } else {

  00090	ea000029	 b           |$cleanUp$39158|
  00094		 |$LN11@GetStringP|

; 44   :             status = ERROR_SUCCESS;
; 45   :         }            
; 46   : 
; 47   :     } else {
; 48   : 
; 49   :         // First find if value is there
; 50   :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  00094	e58d3004	 str         r3, [sp, #4]
  00098	e58d2000	 str         r2, [sp]
  0009c	e28d300c	 add         r3, sp, #0xC
  000a0	e3a02000	 mov         r2, #0
  000a4	eb000000	 bl          RegQueryValueExW
  000a8	e3500000	 cmp         r0, #0

; 51   :         // Value isn't in registry, break or use default
; 52   :         if (status != ERROR_SUCCESS) {

  000ac	0a000014	 beq         |$LN5@GetStringP|

; 53   :             if (pParam->required) goto cleanUp;

  000b0	e5943008	 ldr         r3, [r4, #8]
  000b4	e3530000	 cmp         r3, #0
  000b8	1a00001f	 bne         |$cleanUp$39158|

; 54   :             size = (wcslen((WCHAR*)pParam->pDefault) + 1) * sizeof(WCHAR);

  000bc	e5940014	 ldr         r0, [r4, #0x14]
  000c0	eb000000	 bl          wcslen
  000c4	e2803001	 add         r3, r0, #1
  000c8	e1a01083	 mov         r1, r3, lsl #1

; 55   :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  000cc	e3a00000	 mov         r0, #0
  000d0	e58d1008	 str         r1, [sp, #8]
  000d4	eb000000	 bl          LocalAlloc
  000d8	e1b05000	 movs        r5, r0

; 56   :             if (pBuffer == NULL) {

  000dc	1a000001	 bne         |$LN3@GetStringP|
  000e0		 |$LN14@GetStringP|

; 57   :                 status = ERROR_OUTOFMEMORY;

  000e0	e3a0000e	 mov         r0, #0xE

; 58   :                 goto cleanUp;

  000e4	ea000014	 b           |$cleanUp$39158|
  000e8		 |$LN3@GetStringP|

; 59   :             }                        
; 60   :             memcpy(pBuffer, pParam->pDefault, size);

  000e8	e59d2008	 ldr         r2, [sp, #8]
  000ec	e5941014	 ldr         r1, [r4, #0x14]
  000f0	e1a00005	 mov         r0, r5
  000f4	eb000000	 bl          memcpy

; 61   :             *(VOID**)pValue = pBuffer;

  000f8	e5865000	 str         r5, [r6]

; 62   :             status = ERROR_SUCCESS;

  000fc	e3a00000	 mov         r0, #0

; 63   :         } else {

  00100	ea00000d	 b           |$cleanUp$39158|
  00104		 |$LN5@GetStringP|

; 64   :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  00104	e59d1008	 ldr         r1, [sp, #8]
  00108	e3a00000	 mov         r0, #0
  0010c	eb000000	 bl          LocalAlloc
  00110	e1b04000	 movs        r4, r0

; 65   :             if (pBuffer == NULL) {
; 66   :                 status = ERROR_OUTOFMEMORY;
; 67   :                 goto cleanUp;

  00114	0afffff1	 beq         |$LN14@GetStringP|

; 68   :             }                        
; 69   :             status = RegQueryValueEx(hKey, pName, NULL, &type, pBuffer, &size);

  00118	e28d3008	 add         r3, sp, #8
  0011c	e58d3004	 str         r3, [sp, #4]
  00120	e28d300c	 add         r3, sp, #0xC
  00124	e3a02000	 mov         r2, #0
  00128	e1a01007	 mov         r1, r7
  0012c	e1a00005	 mov         r0, r5
  00130	e58d4000	 str         r4, [sp]
  00134	eb000000	 bl          RegQueryValueExW

; 70   :             *(VOID**)pValue = pBuffer;

  00138	e5864000	 str         r4, [r6]
  0013c		 |$cleanUp$39158|

; 71   :         }
; 72   :     }        
; 73   : 
; 74   : cleanUp:
; 75   :     return status;
; 76   : }

  0013c	e28dd010	 add         sp, sp, #0x10
  00140	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$M39378|

			 ENDP  ; |GetStringParam|


  00000			 AREA	 |.pdata|, PDATA
|$T39395| DCD	|$LN7@GetDWordPa|
	DCD	0x40001902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDWordParam| PROC

; 82   : ) {

  00000		 |$LN7@GetDWordPa|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M39392|
  00008	e1a05002	 mov         r5, r2
  0000c	e1a0e001	 mov         lr, r1

; 83   :     DWORD status, size, type;
; 84   :     WCHAR *pName;
; 85   :     UCHAR *pValue;
; 86   : 
; 87   :     pName = pParam->name;
; 88   :     pValue = (UCHAR*)pBase + pParam->offset;

  00010	e595300c	 ldr         r3, [r5, #0xC]

; 89   :     size = pParam->size;

  00014	e5954010	 ldr         r4, [r5, #0x10]
  00018	e5951000	 ldr         r1, [r5]
  0001c	e083600e	 add         r6, r3, lr

; 90   :     
; 91   :     status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00020	e28de008	 add         lr, sp, #8
  00024	e28d300c	 add         r3, sp, #0xC
  00028	e3a02000	 mov         r2, #0
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d6000	 str         r6, [sp]
  00034	e58d4008	 str         r4, [sp, #8]
  00038	eb000000	 bl          RegQueryValueExW
  0003c	e3500000	 cmp         r0, #0

; 92   :     if (status == ERROR_SUCCESS || pParam->required) goto cleanUp;

  00040	0a000004	 beq         |$cleanUp$39197|
  00044	e5953008	 ldr         r3, [r5, #8]
  00048	e3530000	 cmp         r3, #0

; 93   : 
; 94   :     *(DWORD*)pValue = (DWORD)pParam->pDefault;

  0004c	05953014	 ldreq       r3, [r5, #0x14]

; 95   :     status = ERROR_SUCCESS;

  00050	03a00000	 moveq       r0, #0
  00054	05863000	 streq       r3, [r6]
  00058		 |$cleanUp$39197|

; 96   : 
; 97   : cleanUp:
; 98   :     return status;
; 99   : }

  00058	e28dd010	 add         sp, sp, #0x10
  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M39393|

			 ENDP  ; |GetDWordParam|

	IMPORT	|LocalFree|
	IMPORT	|wcstoul|

  00000			 AREA	 |.pdata|, PDATA
|$T39426| DCD	|$LN33@GetMultiDW|
	DCD	0x40007002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetMultiDWordParam| PROC

; 105  : ) {

  00000		 |$LN33@GetMultiDW|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M39423|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a08000	 mov         r8, r0

; 106  :     DWORD status, size, type;
; 107  :     WCHAR *pName, *pBuffer = NULL, *pPos;
; 108  :     UCHAR *pValue, *pDefault;
; 109  : 
; 110  : 
; 111  :     pName = pParam->name;

  00014	e5969000	 ldr         r9, [r6]

; 112  :     pValue = (UCHAR*)pBase + pParam->offset;

  00018	e596e00c	 ldr         lr, [r6, #0xC]

; 113  :     pDefault = (UCHAR*)pParam->pDefault;
; 114  : 
; 115  :     // Get registry value type and size
; 116  :     status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  0001c	e28d4008	 add         r4, sp, #8
  00020	e3a0b000	 mov         r11, #0
  00024	e5967014	 ldr         r7, [r6, #0x14]
  00028	e1a01009	 mov         r1, r9
  0002c	e28d3010	 add         r3, sp, #0x10
  00030	e3a02000	 mov         r2, #0
  00034	e08ea005	 add         r10, lr, r5
  00038	e58d4004	 str         r4, [sp, #4]
  0003c	e58db000	 str         r11, [sp]
  00040	eb000000	 bl          RegQueryValueExW
  00044	e1b04000	 movs        r4, r0

; 117  :     if (status != ERROR_SUCCESS) {

  00048	0a000009	 beq         |$LN19@GetMultiDW|

; 118  :         // If value doesn't exists use default value if optional
; 119  :         if (pParam->required) goto cleanUp;

  0004c	e5963008	 ldr         r3, [r6, #8]
  00050	e3530000	 cmp         r3, #0
  00054	1a000055	 bne         |$LN1@GetMultiDW|

; 120  :         if (pDefault != NULL) memcpy(pValue, pDefault, pParam->size);

  00058	e3570000	 cmp         r7, #0
  0005c	15962010	 ldrne       r2, [r6, #0x10]
  00060	11a01007	 movne       r1, r7
  00064	11a0000a	 movne       r0, r10
  00068	1b000000	 blne        memcpy

; 121  :         status = ERROR_SUCCESS;

  0006c	e3a04000	 mov         r4, #0

; 122  :         goto cleanUp;

  00070	ea00004e	 b           |$LN1@GetMultiDW|
  00074		 |$LN19@GetMultiDW|

; 123  :     }        
; 124  : 
; 125  :     // If type is DWORD and we expect it, simply read it
; 126  :     if (type == REG_DWORD) {

  00074	e59d3010	 ldr         r3, [sp, #0x10]
  00078	e3530004	 cmp         r3, #4
  0007c	1a00000d	 bne         |$LN16@GetMultiDW|

; 127  :         if (size == sizeof(DWORD)) {

  00080	e59d3008	 ldr         r3, [sp, #8]
  00084	e3530004	 cmp         r3, #4
  00088	1a000008	 bne         |$LN15@GetMultiDW|

; 128  :             status = RegQueryValueEx(hKey, pName, NULL, NULL, pValue, NULL);

  0008c	e3a03000	 mov         r3, #0
  00090	e3a02000	 mov         r2, #0
  00094	e1a01009	 mov         r1, r9
  00098	e1a00008	 mov         r0, r8
  0009c	e58db004	 str         r11, [sp, #4]
  000a0	e58da000	 str         r10, [sp]
  000a4	eb000000	 bl          RegQueryValueExW
  000a8	e1a04000	 mov         r4, r0

; 129  :         } else {

  000ac	ea00003f	 b           |$LN1@GetMultiDW|
  000b0		 |$LN15@GetMultiDW|

; 130  :             status = ERROR_BAD_LENGTH;

  000b0	e3a04018	 mov         r4, #0x18

; 131  :         }

  000b4	ea00003d	 b           |$LN1@GetMultiDW|
  000b8		 |$LN16@GetMultiDW|

; 132  :     } else if (type == REG_SZ || type == REG_MULTI_SZ) {

  000b8	e3530001	 cmp         r3, #1
  000bc	13530007	 cmpne       r3, #7

; 154  :     } else {
; 155  :         status = ERROR_BAD_FORMAT;

  000c0	13a0400b	 movne       r4, #0xB
  000c4	1a000039	 bne         |$LN1@GetMultiDW|
  000c8	e59d1008	 ldr         r1, [sp, #8]
  000cc	e3a00040	 mov         r0, #0x40
  000d0	eb000000	 bl          LocalAlloc
  000d4	e1b05000	 movs        r5, r0
  000d8	03a0400e	 moveq       r4, #0xE
  000dc	0a000030	 beq         |$cleanUp$39223|
  000e0	e28d3008	 add         r3, sp, #8
  000e4	e58d3004	 str         r3, [sp, #4]
  000e8	e3a03000	 mov         r3, #0
  000ec	e3a02000	 mov         r2, #0
  000f0	e1a01009	 mov         r1, r9
  000f4	e1a00008	 mov         r0, r8
  000f8	e58d5000	 str         r5, [sp]
  000fc	eb000000	 bl          RegQueryValueExW
  00100	e1b04000	 movs        r4, r0
  00104	1a000026	 bne         |$cleanUp$39223|
  00108	e5962010	 ldr         r2, [r6, #0x10]
  0010c	e1a00005	 mov         r0, r5
  00110	e58d500c	 str         r5, [sp, #0xC]
  00114	e58d2008	 str         r2, [sp, #8]
  00118	e3520004	 cmp         r2, #4
  0011c	3a00001d	 bcc         |$LN30@GetMultiDW|

; 133  :         // Allocate buffer for key
; 134  :         pBuffer = LocalAlloc(LPTR, size);
; 135  :         if (pBuffer == NULL) {
; 136  :             status = ERROR_OUTOFMEMORY;
; 137  :             goto cleanUp;
; 138  :         }
; 139  :         // Read registry value (in most cases it should not fail)
; 140  :         status = RegQueryValueEx(
; 141  :             hKey, pName, NULL, NULL, (UCHAR*)pBuffer, &size
; 142  :         );
; 143  :         if (status != ERROR_SUCCESS) goto cleanUp;
; 144  :         pPos = pBuffer;
; 145  :         size = pParam->size;
; 146  :         while (size >= sizeof(DWORD) && *pPos != L'\0') {

  00120	e59d1010	 ldr         r1, [sp, #0x10]
  00124		 |$LL8@GetMultiDW|
  00124	e1d030b0	 ldrh        r3, [r0]
  00128	e3530000	 cmp         r3, #0
  0012c	0a000019	 beq         |$LN30@GetMultiDW|
  00130		 |$LL6@GetMultiDW|

; 147  :             while (*pPos == L' ' || (type == REG_SZ && *pPos == L',')) pPos++;

  00130	e1d030b0	 ldrh        r3, [r0]
  00134	e3530020	 cmp         r3, #0x20
  00138	0a000003	 beq         |$LN4@GetMultiDW|
  0013c	e3510001	 cmp         r1, #1
  00140	1a000004	 bne         |$LN5@GetMultiDW|
  00144	e353002c	 cmp         r3, #0x2C
  00148	1a000002	 bne         |$LN5@GetMultiDW|
  0014c		 |$LN4@GetMultiDW|
  0014c	e2800002	 add         r0, r0, #2
  00150	e58d000c	 str         r0, [sp, #0xC]
  00154	eafffff5	 b           |$LL6@GetMultiDW|
  00158		 |$LN5@GetMultiDW|

; 148  :             *(DWORD*)pValue = wcstoul(pPos, &pPos, 16);

  00158	e3a02010	 mov         r2, #0x10
  0015c	e28d100c	 add         r1, sp, #0xC
  00160	eb000000	 bl          wcstoul
  00164	e48a0004	 str         r0, [r10], #4

; 149  :             pValue += sizeof(DWORD);
; 150  :             size -= sizeof(DWORD);

  00168	e59d3008	 ldr         r3, [sp, #8]

; 151  :             if (type == REG_MULTI_SZ && *pPos == L'\0') pPos++;

  0016c	e59d1010	 ldr         r1, [sp, #0x10]
  00170	e59d000c	 ldr         r0, [sp, #0xC]
  00174	e2432004	 sub         r2, r3, #4
  00178	e3510007	 cmp         r1, #7
  0017c	e58d2008	 str         r2, [sp, #8]
  00180	01d030b0	 ldreqh      r3, [r0]
  00184	03530000	 cmpeq       r3, #0
  00188	02800002	 addeq       r0, r0, #2
  0018c	058d000c	 streq       r0, [sp, #0xC]
  00190	e3520004	 cmp         r2, #4
  00194	2affffe2	 bcs         |$LL8@GetMultiDW|
  00198		 |$LN30@GetMultiDW|

; 152  :         }
; 153  :         status = size == 0 ? ERROR_SUCCESS : ERROR_BAD_FORMAT;

  00198	e3520000	 cmp         r2, #0
  0019c	03a04000	 moveq       r4, #0
  001a0	13a0400b	 movne       r4, #0xB
  001a4		 |$cleanUp$39223|

; 156  :     }        
; 157  : 
; 158  : cleanUp:
; 159  :     if (pBuffer != NULL) LocalFree(pBuffer);

  001a4	e3550000	 cmp         r5, #0
  001a8	11a00005	 movne       r0, r5
  001ac	1b000000	 blne        LocalFree
  001b0		 |$LN1@GetMultiDW|

; 160  :     return status;
; 161  : }

  001b0	e1a00004	 mov         r0, r4
  001b4	e28dd014	 add         sp, sp, #0x14
  001b8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001bc	e12fff1e	 bx          lr
  001c0		 |$M39424|

			 ENDP  ; |GetMultiDWordParam|


  00000			 AREA	 |.pdata|, PDATA
|$T39443| DCD	|$LN14@GetBinPara|
	DCD	0x40003c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetBinParam| PROC

; 167  : ) {

  00000		 |$LN14@GetBinPara|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M39440|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a06000	 mov         r6, r0

; 168  :     DWORD status, size, type;
; 169  :     WCHAR *pName;
; 170  :     UCHAR *pBuffer, *pValue;
; 171  : 
; 172  :     pName = pParam->name;
; 173  :     pValue = (UCHAR*)pBase + pParam->offset;
; 174  :     size = pParam->size;

  00010	e5943010	 ldr         r3, [r4, #0x10]
  00014	e594e00c	 ldr         lr, [r4, #0xC]
  00018	e5947000	 ldr         r7, [r4]
  0001c	e3530000	 cmp         r3, #0
  00020	e58d3008	 str         r3, [sp, #8]
  00024	e08e5001	 add         r5, lr, r1

; 175  : 
; 176  :     // If there is parameter size we simply try to read value or used default
; 177  :     if (size > 0) {
; 178  : 
; 179  :         status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00028	e28d3008	 add         r3, sp, #8
  0002c	e1a01007	 mov         r1, r7
  00030	e3a02000	 mov         r2, #0
  00034	0a00000e	 beq         |$LN8@GetBinPara|
  00038	e58d3004	 str         r3, [sp, #4]
  0003c	e28d300c	 add         r3, sp, #0xC
  00040	e58d5000	 str         r5, [sp]
  00044	eb000000	 bl          RegQueryValueExW
  00048	e3500000	 cmp         r0, #0

; 180  :         if (status == ERROR_SUCCESS || pParam->required) goto cleanUp;

  0004c	0a000024	 beq         |$cleanUp$39276|
  00050	e5943008	 ldr         r3, [r4, #8]
  00054	e3530000	 cmp         r3, #0
  00058	1a000021	 bne         |$cleanUp$39276|

; 181  :         memcpy(pValue, pParam->pDefault, pParam->size);

  0005c	e5942010	 ldr         r2, [r4, #0x10]
  00060	e5941014	 ldr         r1, [r4, #0x14]
  00064	e1a00005	 mov         r0, r5
  00068	eb000000	 bl          memcpy

; 192  :             status = ERROR_SUCCESS;

  0006c	e3a00000	 mov         r0, #0

; 193  :         } else {

  00070	ea00001b	 b           |$cleanUp$39276|
  00074		 |$LN8@GetBinPara|

; 182  :         status = ERROR_SUCCESS;
; 183  : 
; 184  :     } else {
; 185  : 
; 186  :         // First find if value is there
; 187  :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  00074	e58d3004	 str         r3, [sp, #4]
  00078	e3a08000	 mov         r8, #0
  0007c	e28d300c	 add         r3, sp, #0xC
  00080	e58d8000	 str         r8, [sp]
  00084	eb000000	 bl          RegQueryValueExW
  00088	e3500000	 cmp         r0, #0

; 188  :         // Value isn't in registry, break or use default
; 189  :         if (status != ERROR_SUCCESS) {

  0008c	0a000005	 beq         |$LN4@GetBinPara|

; 190  :             if (pParam->required) goto cleanUp;

  00090	e5943008	 ldr         r3, [r4, #8]
  00094	e3530000	 cmp         r3, #0
  00098	1a000011	 bne         |$cleanUp$39276|

; 191  :             *(VOID**)pValue = NULL;

  0009c	e5858000	 str         r8, [r5]

; 192  :             status = ERROR_SUCCESS;

  000a0	e3a00000	 mov         r0, #0

; 193  :         } else {

  000a4	ea00000e	 b           |$cleanUp$39276|
  000a8		 |$LN4@GetBinPara|

; 194  :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  000a8	e59d1008	 ldr         r1, [sp, #8]
  000ac	e3a00000	 mov         r0, #0
  000b0	eb000000	 bl          LocalAlloc
  000b4	e1b04000	 movs        r4, r0

; 195  :             if (pBuffer == NULL) {
; 196  :                 status = ERROR_OUTOFMEMORY;

  000b8	03a0000e	 moveq       r0, #0xE
  000bc	0a000008	 beq         |$cleanUp$39276|

; 197  :                 goto cleanUp;
; 198  :             }                        
; 199  :             status = RegQueryValueEx(hKey, pName, NULL, &type, pBuffer, &size);

  000c0	e28d3008	 add         r3, sp, #8
  000c4	e58d3004	 str         r3, [sp, #4]
  000c8	e28d300c	 add         r3, sp, #0xC
  000cc	e3a02000	 mov         r2, #0
  000d0	e1a01007	 mov         r1, r7
  000d4	e1a00006	 mov         r0, r6
  000d8	e58d4000	 str         r4, [sp]
  000dc	eb000000	 bl          RegQueryValueExW

; 200  :             *(VOID**)pValue = pBuffer;

  000e0	e5854000	 str         r4, [r5]
  000e4		 |$cleanUp$39276|

; 201  :         }
; 202  :     }        
; 203  : 
; 204  : cleanUp:
; 205  :     return status;
; 206  : }

  000e4	e28dd010	 add         sp, sp, #0x10
  000e8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$M39441|

			 ENDP  ; |GetBinParam|

	EXPORT	|GetDeviceRegistryParams|
	IMPORT	|RegCloseKey|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|OpenDeviceKey|

  00000			 AREA	 |.pdata|, PDATA
|$T39483| DCD	|$LN34@GetDeviceR|
	DCD	0x40006802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDeviceRegistryParams| PROC

; 213  : ) {

  00000		 |$LN34@GetDeviceR|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M39480|
  00008	e1a0a003	 mov         r10, r3
  0000c	e1a09002	 mov         r9, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a04000	 mov         r4, r0

; 214  :     DWORD status = ERROR_SUCCESS;
; 215  :     HKEY hKey;
; 216  :     DWORD i;
; 217  : 
; 218  :     // Open registry context to read parameters
; 219  :     if ((hKey = OpenDeviceKey(context)) == NULL) {

  00018	e3a05000	 mov         r5, #0
  0001c	eb000000	 bl          OpenDeviceKey
  00020	e3500000	 cmp         r0, #0
  00024	e58d0008	 str         r0, [sp, #8]
  00028	1a000009	 bne         |$LN18@GetDeviceR|

; 220  :         // It looks like we didn't get active registry key,
; 221  :         // try open key directly
; 222  :         if ((status = RegOpenKeyEx(
; 223  :             HKEY_LOCAL_MACHINE, context, 0, 0, &hKey
; 224  :         )) != ERROR_SUCCESS) goto cleanUp;

  0002c	e28de008	 add         lr, sp, #8
  00030	e3a03000	 mov         r3, #0
  00034	e3a02000	 mov         r2, #0
  00038	e1a01004	 mov         r1, r4
  0003c	e3a0010a	 mov         r0, #0xA, 2
  00040	e58de000	 str         lr, [sp]
  00044	eb000000	 bl          RegOpenKeyExW
  00048	e1b05000	 movs        r5, r0
  0004c	1a00004f	 bne         |$cleanUp$39307|
  00050	e59d0008	 ldr         r0, [sp, #8]
  00054		 |$LN18@GetDeviceR|

; 225  : 
; 226  :     }
; 227  : 
; 228  :     // For all members of array
; 229  :     for (i = 0; i < count && status == ERROR_SUCCESS; i++) {

  00054	e3a04000	 mov         r4, #0
  00058	e3590000	 cmp         r9, #0
  0005c	0a000034	 beq         |$LN30@GetDeviceR|
  00060	e1a0600a	 mov         r6, r10
  00064	e3a02107	 mov         r2, #7, 2
  00068	e28db00c	 add         r11, sp, #0xC
  0006c		 |$LL17@GetDeviceR|
  0006c	e3550000	 cmp         r5, #0
  00070	1a00002f	 bne         |$LN30@GetDeviceR|

; 230  :         switch (params[i].type) {

  00074	e5963004	 ldr         r3, [r6, #4]
  00078	e3530001	 cmp         r3, #1
  0007c	0a000015	 beq         |$LN12@GetDeviceR|
  00080	e3530002	 cmp         r3, #2
  00084	0a00000e	 beq         |$LN11@GetDeviceR|
  00088	e3530003	 cmp         r3, #3
  0008c	0a000007	 beq         |$LN10@GetDeviceR|
  00090	e3530004	 cmp         r3, #4

; 243  :         default:
; 244  :             status = STATUS_FAIL_CHECK;

  00094	13825f8a	 orrne       r5, r2, #0x8A, 30
  00098	1a000021	 bne         |$LN16@GetDeviceR|
  0009c	e1a02006	 mov         r2, r6
  000a0	e1a01007	 mov         r1, r7
  000a4	eb000000	 bl          GetBinParam
  000a8	e1a05000	 mov         r5, r0
  000ac	ea00001a	 b           |$cleanUp$39456|
  000b0		 |$LN10@GetDeviceR|

; 236  :             break;
; 237  :         case PARAM_MULTIDWORD:
; 238  :             status = GetMultiDWordParam(hKey, pBase, &params[i]);

  000b0	e1a02006	 mov         r2, r6
  000b4	e1a01007	 mov         r1, r7
  000b8	eb000000	 bl          GetMultiDWordParam

; 239  :             break;
; 240  :         case PARAM_BIN:
; 241  :             status = GetBinParam(hKey, pBase, &params[i]);

  000bc	e1a05000	 mov         r5, r0

; 242  :             break;

  000c0	ea000015	 b           |$cleanUp$39456|
  000c4		 |$LN11@GetDeviceR|

; 233  :             break;
; 234  :         case PARAM_STRING:
; 235  :             status = GetStringParam(hKey, pBase, &params[i]);

  000c4	e1a02006	 mov         r2, r6
  000c8	e1a01007	 mov         r1, r7
  000cc	eb000000	 bl          GetStringParam

; 239  :             break;
; 240  :         case PARAM_BIN:
; 241  :             status = GetBinParam(hKey, pBase, &params[i]);

  000d0	e1a05000	 mov         r5, r0

; 242  :             break;

  000d4	ea000010	 b           |$cleanUp$39456|
  000d8		 |$LN12@GetDeviceR|

; 231  :         case PARAM_DWORD:
; 232  :             status = GetDWordParam(hKey, pBase, &params[i]);

  000d8	e596300c	 ldr         r3, [r6, #0xC]
  000dc	e596e010	 ldr         lr, [r6, #0x10]
  000e0	e5961000	 ldr         r1, [r6]
  000e4	e0838007	 add         r8, r3, r7
  000e8	e28d3010	 add         r3, sp, #0x10
  000ec	e3a02000	 mov         r2, #0
  000f0	e58d8000	 str         r8, [sp]
  000f4	e58de00c	 str         lr, [sp, #0xC]
  000f8	e58db004	 str         r11, [sp, #4]
  000fc	eb000000	 bl          RegQueryValueExW
  00100	e1b05000	 movs        r5, r0
  00104	0a000004	 beq         |$cleanUp$39456|
  00108	e5963008	 ldr         r3, [r6, #8]
  0010c	e3530000	 cmp         r3, #0
  00110	05963014	 ldreq       r3, [r6, #0x14]
  00114	03a05000	 moveq       r5, #0
  00118	05883000	 streq       r3, [r8]
  0011c		 |$cleanUp$39456|
  0011c	e59d0008	 ldr         r0, [sp, #8]
  00120	e3a02107	 mov         r2, #7, 2
  00124		 |$LN16@GetDeviceR|
  00124	e2844001	 add         r4, r4, #1
  00128	e1540009	 cmp         r4, r9
  0012c	e2866018	 add         r6, r6, #0x18
  00130	3affffcd	 bcc         |$LL17@GetDeviceR|
  00134		 |$LN30@GetDeviceR|

; 245  :             break;
; 246  :         }
; 247  :     }
; 248  : 
; 249  :     // Close key
; 250  :     RegCloseKey(hKey);

  00134	eb000000	 bl          RegCloseKey

; 251  : 
; 252  :     // Release allocated memory in case of failure
; 253  :     if (status != ERROR_SUCCESS) {

  00138	e3550000	 cmp         r5, #0
  0013c	0a000013	 beq         |$cleanUp$39307|

; 254  :         UCHAR *pBuffer, *pValue;
; 255  : 
; 256  :         while (i-- > 0) {

  00140	e3540000	 cmp         r4, #0
  00144	0a000011	 beq         |$cleanUp$39307|
  00148	e0843084	 add         r3, r4, r4, lsl #1
  0014c	e08a6183	 add         r6, r10, r3, lsl #3
  00150	e3a08000	 mov         r8, #0
  00154		 |$LL6@GetDeviceR|
  00154	e2466018	 sub         r6, r6, #0x18

; 257  :             pValue = (UCHAR*)pBase + params[i].offset;
; 258  :             switch (params[i].type) {

  00158	e5963004	 ldr         r3, [r6, #4]
  0015c	e596200c	 ldr         r2, [r6, #0xC]
  00160	e2444001	 sub         r4, r4, #1
  00164	e3530002	 cmp         r3, #2
  00168	0a000001	 beq         |$LN2@GetDeviceR|
  0016c	e3530004	 cmp         r3, #4
  00170	1a000004	 bne         |$LN1@GetDeviceR|
  00174		 |$LN2@GetDeviceR|

; 259  :             case PARAM_STRING:
; 260  :             case PARAM_BIN:                
; 261  :                 if (params[i].size == 0) {

  00174	e5963010	 ldr         r3, [r6, #0x10]
  00178	e3530000	 cmp         r3, #0

; 262  :                     pBuffer = (UCHAR*)(*(VOID**)pValue);

  0017c	07920007	 ldreq       r0, [r2, +r7]

; 263  :                     *(VOID**)pValue = NULL;

  00180	07828007	 streq       r8, [r2, +r7]

; 264  :                     LocalFree(pBuffer);

  00184	0b000000	 bleq        LocalFree
  00188		 |$LN1@GetDeviceR|

; 254  :         UCHAR *pBuffer, *pValue;
; 255  : 
; 256  :         while (i-- > 0) {

  00188	e3540000	 cmp         r4, #0
  0018c	1afffff0	 bne         |$LL6@GetDeviceR|
  00190		 |$cleanUp$39307|

; 265  :                 }                   
; 266  :                 break;                    
; 267  :             }            
; 268  :         }
; 269  :     }
; 270  : 
; 271  : cleanUp:
; 272  :     return status;
; 273  : }

  00190	e1a00005	 mov         r0, r5
  00194	e28dd014	 add         sp, sp, #0x14
  00198	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0019c	e12fff1e	 bx          lr
  001a0		 |$M39481|

			 ENDP  ; |GetDeviceRegistryParams|

	END
