; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\CEDDK\BASE\registry.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|GetDeviceRegistryParams|
	IMPORT	|LocalFree|
	IMPORT	|RegCloseKey|
	IMPORT	|RegOpenKeyExW|
	IMPORT	|OpenDeviceKey|

  00000			 AREA	 |.pdata|, PDATA
|$T39332| DCD	|$LN30@GetDeviceR|
	DCD	0x4000b004
; Function compile flags: /Odtp
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\ceddk\base\registry.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetDeviceRegistryParams| PROC

; 213  : ) {

  00000		 |$LN30@GetDeviceR|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd040	 sub         sp, sp, #0x40
  00010		 |$M39329|

; 214  :     DWORD status = ERROR_SUCCESS;

  00010	e3a03000	 mov         r3, #0
  00014	e58d300c	 str         r3, [sp, #0xC]

; 215  :     HKEY hKey;
; 216  :     DWORD i;
; 217  : 
; 218  :     // Open registry context to read parameters
; 219  :     if ((hKey = OpenDeviceKey(context)) == NULL) {

  00018	e59d0048	 ldr         r0, [sp, #0x48]
  0001c	eb000000	 bl          OpenDeviceKey
  00020	e58d0020	 str         r0, [sp, #0x20]
  00024	e59d3020	 ldr         r3, [sp, #0x20]
  00028	e58d3008	 str         r3, [sp, #8]
  0002c	e59d3008	 ldr         r3, [sp, #8]
  00030	e3530000	 cmp         r3, #0
  00034	1a00000d	 bne         |$LN19@GetDeviceR|

; 220  :         // It looks like we didn't get active registry key,
; 221  :         // try open key directly
; 222  :         if ((status = RegOpenKeyEx(
; 223  :             HKEY_LOCAL_MACHINE, context, 0, 0, &hKey
; 224  :         )) != ERROR_SUCCESS) goto cleanUp;

  00038	e28d3008	 add         r3, sp, #8
  0003c	e58d3000	 str         r3, [sp]
  00040	e3a03000	 mov         r3, #0
  00044	e3a02000	 mov         r2, #0
  00048	e59d1048	 ldr         r1, [sp, #0x48]
  0004c	e3a0010a	 mov         r0, #0xA, 2
  00050	eb000000	 bl          RegOpenKeyExW
  00054	e58d0024	 str         r0, [sp, #0x24]
  00058	e59d3024	 ldr         r3, [sp, #0x24]
  0005c	e58d300c	 str         r3, [sp, #0xC]
  00060	e59d300c	 ldr         r3, [sp, #0xC]
  00064	e3530000	 cmp         r3, #0
  00068	0a000000	 beq         |$LN18@GetDeviceR|
  0006c	ea00008d	 b           |$cleanUp$39284|
  00070		 |$LN18@GetDeviceR|
  00070		 |$LN19@GetDeviceR|

; 225  : 
; 226  :     }
; 227  : 
; 228  :     // For all members of array
; 229  :     for (i = 0; i < count && status == ERROR_SUCCESS; i++) {

  00070	e3a03000	 mov         r3, #0
  00074	e58d3004	 str         r3, [sp, #4]
  00078	ea000002	 b           |$LN17@GetDeviceR|
  0007c		 |$LN16@GetDeviceR|
  0007c	e59d3004	 ldr         r3, [sp, #4]
  00080	e2833001	 add         r3, r3, #1
  00084	e58d3004	 str         r3, [sp, #4]
  00088		 |$LN17@GetDeviceR|
  00088	e59d2004	 ldr         r2, [sp, #4]
  0008c	e59d3050	 ldr         r3, [sp, #0x50]
  00090	e1520003	 cmp         r2, r3
  00094	2a00004d	 bcs         |$LN15@GetDeviceR|
  00098	e59d300c	 ldr         r3, [sp, #0xC]
  0009c	e3530000	 cmp         r3, #0
  000a0	1a00004a	 bne         |$LN15@GetDeviceR|

; 230  :         switch (params[i].type) {

  000a4	e59d1004	 ldr         r1, [sp, #4]
  000a8	e3a03018	 mov         r3, #0x18
  000ac	e0020391	 mul         r2, r1, r3
  000b0	e59d3054	 ldr         r3, [sp, #0x54]
  000b4	e0833002	 add         r3, r3, r2
  000b8	e2833004	 add         r3, r3, #4
  000bc	e5933000	 ldr         r3, [r3]
  000c0	e58d3028	 str         r3, [sp, #0x28]
  000c4	e59d3028	 ldr         r3, [sp, #0x28]
  000c8	e2433001	 sub         r3, r3, #1
  000cc	e58d3028	 str         r3, [sp, #0x28]
  000d0	e59d3028	 ldr         r3, [sp, #0x28]
  000d4	e3530003	 cmp         r3, #3
  000d8	8a000038	 bhi         |$LN8@GetDeviceR|
  000dc	e59d2028	 ldr         r2, [sp, #0x28]
  000e0	e1a03102	 mov         r3, r2, lsl #2
  000e4	e083300f	 add         r3, r3, pc
  000e8	e5933004	 ldr         r3, [r3, #4]
  000ec	e08ff003	 add         pc, pc, r3
  000f0		 |$LN23@GetDeviceR|
  000f0		 |$LN22@GetDeviceR|
  000f0		 |$LN24@GetDeviceR|
  000f0	0000000c	 DCD         0xc
  000f4		 |$LN25@GetDeviceR|
  000f4	0000003c	 DCD         0x3c
  000f8		 |$LN26@GetDeviceR|
  000f8	0000006c	 DCD         0x6c
  000fc		 |$LN27@GetDeviceR|
  000fc	0000009c	 DCD         0x9c
  00100		 |$LN12@GetDeviceR|

; 231  :         case PARAM_DWORD:
; 232  :             status = GetDWordParam(hKey, pBase, &params[i]);

  00100	e59d1004	 ldr         r1, [sp, #4]
  00104	e3a03018	 mov         r3, #0x18
  00108	e0020391	 mul         r2, r1, r3
  0010c	e59d3054	 ldr         r3, [sp, #0x54]
  00110	e0832002	 add         r2, r3, r2
  00114	e59d104c	 ldr         r1, [sp, #0x4C]
  00118	e59d0008	 ldr         r0, [sp, #8]
  0011c	eb000000	 bl          GetDWordParam
  00120	e58d002c	 str         r0, [sp, #0x2C]
  00124	e59d302c	 ldr         r3, [sp, #0x2C]
  00128	e58d300c	 str         r3, [sp, #0xC]

; 233  :             break;

  0012c	ea000026	 b           |$LN13@GetDeviceR|
  00130		 |$LN11@GetDeviceR|

; 234  :         case PARAM_STRING:
; 235  :             status = GetStringParam(hKey, pBase, &params[i]);

  00130	e59d1004	 ldr         r1, [sp, #4]
  00134	e3a03018	 mov         r3, #0x18
  00138	e0020391	 mul         r2, r1, r3
  0013c	e59d3054	 ldr         r3, [sp, #0x54]
  00140	e0832002	 add         r2, r3, r2
  00144	e59d104c	 ldr         r1, [sp, #0x4C]
  00148	e59d0008	 ldr         r0, [sp, #8]
  0014c	eb000000	 bl          GetStringParam
  00150	e58d0030	 str         r0, [sp, #0x30]
  00154	e59d3030	 ldr         r3, [sp, #0x30]
  00158	e58d300c	 str         r3, [sp, #0xC]

; 236  :             break;

  0015c	ea00001a	 b           |$LN13@GetDeviceR|
  00160		 |$LN10@GetDeviceR|

; 237  :         case PARAM_MULTIDWORD:
; 238  :             status = GetMultiDWordParam(hKey, pBase, &params[i]);

  00160	e59d1004	 ldr         r1, [sp, #4]
  00164	e3a03018	 mov         r3, #0x18
  00168	e0020391	 mul         r2, r1, r3
  0016c	e59d3054	 ldr         r3, [sp, #0x54]
  00170	e0832002	 add         r2, r3, r2
  00174	e59d104c	 ldr         r1, [sp, #0x4C]
  00178	e59d0008	 ldr         r0, [sp, #8]
  0017c	eb000000	 bl          GetMultiDWordParam
  00180	e58d0034	 str         r0, [sp, #0x34]
  00184	e59d3034	 ldr         r3, [sp, #0x34]
  00188	e58d300c	 str         r3, [sp, #0xC]

; 239  :             break;

  0018c	ea00000e	 b           |$LN13@GetDeviceR|
  00190		 |$LN9@GetDeviceR|

; 240  :         case PARAM_BIN:
; 241  :             status = GetBinParam(hKey, pBase, &params[i]);

  00190	e59d1004	 ldr         r1, [sp, #4]
  00194	e3a03018	 mov         r3, #0x18
  00198	e0020391	 mul         r2, r1, r3
  0019c	e59d3054	 ldr         r3, [sp, #0x54]
  001a0	e0832002	 add         r2, r3, r2
  001a4	e59d104c	 ldr         r1, [sp, #0x4C]
  001a8	e59d0008	 ldr         r0, [sp, #8]
  001ac	eb000000	 bl          GetBinParam
  001b0	e58d0038	 str         r0, [sp, #0x38]
  001b4	e59d3038	 ldr         r3, [sp, #0x38]
  001b8	e58d300c	 str         r3, [sp, #0xC]

; 242  :             break;

  001bc	ea000002	 b           |$LN13@GetDeviceR|
  001c0		 |$LN8@GetDeviceR|

; 243  :         default:
; 244  :             status = STATUS_FAIL_CHECK;

  001c0	e3a03107	 mov         r3, #7, 2
  001c4	e3833f8a	 orr         r3, r3, #0x8A, 30
  001c8	e58d300c	 str         r3, [sp, #0xC]
  001cc		 |$LN13@GetDeviceR|

; 245  :             break;
; 246  :         }
; 247  :     }

  001cc	eaffffaa	 b           |$LN16@GetDeviceR|
  001d0		 |$LN15@GetDeviceR|

; 248  : 
; 249  :     // Close key
; 250  :     RegCloseKey(hKey);

  001d0	e59d0008	 ldr         r0, [sp, #8]
  001d4	eb000000	 bl          RegCloseKey

; 251  : 
; 252  :     // Release allocated memory in case of failure
; 253  :     if (status != ERROR_SUCCESS) {

  001d8	e59d300c	 ldr         r3, [sp, #0xC]
  001dc	e3530000	 cmp         r3, #0
  001e0	0a000030	 beq         |$LN7@GetDeviceR|
  001e4		 |$LN6@GetDeviceR|

; 254  :         UCHAR *pBuffer, *pValue;
; 255  : 
; 256  :         while (i-- > 0) {

  001e4	e59d3004	 ldr         r3, [sp, #4]
  001e8	e3530000	 cmp         r3, #0
  001ec	e59d3004	 ldr         r3, [sp, #4]
  001f0	e2433001	 sub         r3, r3, #1
  001f4	e58d3004	 str         r3, [sp, #4]
  001f8	9a00002a	 bls         |$LN5@GetDeviceR|

; 257  :             pValue = (UCHAR*)pBase + params[i].offset;

  001fc	e59d1004	 ldr         r1, [sp, #4]
  00200	e3a03018	 mov         r3, #0x18
  00204	e0020391	 mul         r2, r1, r3
  00208	e59d3054	 ldr         r3, [sp, #0x54]
  0020c	e0833002	 add         r3, r3, r2
  00210	e283300c	 add         r3, r3, #0xC
  00214	e59d204c	 ldr         r2, [sp, #0x4C]
  00218	e5933000	 ldr         r3, [r3]
  0021c	e0823003	 add         r3, r2, r3
  00220	e58d3014	 str         r3, [sp, #0x14]

; 258  :             switch (params[i].type) {

  00224	e59d1004	 ldr         r1, [sp, #4]
  00228	e3a03018	 mov         r3, #0x18
  0022c	e0020391	 mul         r2, r1, r3
  00230	e59d3054	 ldr         r3, [sp, #0x54]
  00234	e0833002	 add         r3, r3, r2
  00238	e2833004	 add         r3, r3, #4
  0023c	e5933000	 ldr         r3, [r3]
  00240	e58d303c	 str         r3, [sp, #0x3C]
  00244	e59d303c	 ldr         r3, [sp, #0x3C]
  00248	e3530002	 cmp         r3, #2
  0024c	0a000003	 beq         |$LN2@GetDeviceR|
  00250	e59d303c	 ldr         r3, [sp, #0x3C]
  00254	e3530004	 cmp         r3, #4
  00258	0a000000	 beq         |$LN2@GetDeviceR|
  0025c	ea000010	 b           |$LN3@GetDeviceR|
  00260		 |$LN2@GetDeviceR|

; 259  :             case PARAM_STRING:
; 260  :             case PARAM_BIN:                
; 261  :                 if (params[i].size == 0) {

  00260	e59d1004	 ldr         r1, [sp, #4]
  00264	e3a03018	 mov         r3, #0x18
  00268	e0020391	 mul         r2, r1, r3
  0026c	e59d3054	 ldr         r3, [sp, #0x54]
  00270	e0833002	 add         r3, r3, r2
  00274	e2833010	 add         r3, r3, #0x10
  00278	e5933000	 ldr         r3, [r3]
  0027c	e3530000	 cmp         r3, #0
  00280	1a000007	 bne         |$LN1@GetDeviceR|

; 262  :                     pBuffer = (UCHAR*)(*(VOID**)pValue);

  00284	e59d3014	 ldr         r3, [sp, #0x14]
  00288	e5933000	 ldr         r3, [r3]
  0028c	e58d3010	 str         r3, [sp, #0x10]

; 263  :                     *(VOID**)pValue = NULL;

  00290	e59d2014	 ldr         r2, [sp, #0x14]
  00294	e3a03000	 mov         r3, #0
  00298	e5823000	 str         r3, [r2]

; 264  :                     LocalFree(pBuffer);

  0029c	e59d0010	 ldr         r0, [sp, #0x10]
  002a0	eb000000	 bl          LocalFree
  002a4		 |$LN1@GetDeviceR|
  002a4		 |$LN3@GetDeviceR|

; 265  :                 }                   
; 266  :                 break;                    
; 267  :             }            
; 268  :         }

  002a4	eaffffce	 b           |$LN6@GetDeviceR|
  002a8		 |$LN5@GetDeviceR|
  002a8		 |$LN7@GetDeviceR|
  002a8		 |$cleanUp$39284|

; 269  :     }
; 270  : 
; 271  : cleanUp:
; 272  :     return status;

  002a8	e59d300c	 ldr         r3, [sp, #0xC]
  002ac	e58d301c	 str         r3, [sp, #0x1C]

; 273  : }

  002b0	e59d001c	 ldr         r0, [sp, #0x1C]
  002b4	e28dd040	 add         sp, sp, #0x40
  002b8	e89d6000	 ldmia       sp, {sp, lr}
  002bc	e12fff1e	 bx          lr
  002c0		 |$M39330|

			 ENDP  ; |GetDeviceRegistryParams|

	IMPORT	|LocalAlloc|
	IMPORT	|memcpy|
	IMPORT	|wcslen|
	IMPORT	|RegQueryValueExW|

  00008			 AREA	 |.pdata|, PDATA
|$T39344| DCD	|$LN16@GetStringP|
	DCD	0x40009d04
; Function compile flags: /Odtp

  002c0			 AREA	 |.text|, CODE, ARM

  002c0		 |GetStringParam| PROC

; 25   : ) {

  002c0		 |$LN16@GetStringP|
  002c0	e1a0c00d	 mov         r12, sp
  002c4	e92d0007	 stmdb       sp!, {r0 - r2}
  002c8	e92d5000	 stmdb       sp!, {r12, lr}
  002cc	e24dd058	 sub         sp, sp, #0x58
  002d0		 |$M39341|

; 26   :     DWORD status, size, type;
; 27   :     WCHAR *pName;
; 28   :     UCHAR *pBuffer, *pValue;
; 29   : 
; 30   :     pName = pParam->name;

  002d0	e59d3068	 ldr         r3, [sp, #0x68]
  002d4	e5933000	 ldr         r3, [r3]
  002d8	e58d3014	 str         r3, [sp, #0x14]

; 31   :     pValue = (UCHAR*)pBase + pParam->offset;

  002dc	e59d3068	 ldr         r3, [sp, #0x68]
  002e0	e283300c	 add         r3, r3, #0xC
  002e4	e59d2064	 ldr         r2, [sp, #0x64]
  002e8	e5933000	 ldr         r3, [r3]
  002ec	e0823003	 add         r3, r2, r3
  002f0	e58d3010	 str         r3, [sp, #0x10]

; 32   :     size = pParam->size;

  002f4	e59d3068	 ldr         r3, [sp, #0x68]
  002f8	e2833010	 add         r3, r3, #0x10
  002fc	e5933000	 ldr         r3, [r3]
  00300	e58d3018	 str         r3, [sp, #0x18]

; 33   : 
; 34   :     // If there is parameter size we simply try to read value or used default
; 35   :     if (size > 0) {

  00304	e59d3018	 ldr         r3, [sp, #0x18]
  00308	e3530000	 cmp         r3, #0
  0030c	9a000030	 bls         |$LN11@GetStringP|

; 36   : 
; 37   :         status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00310	e28d3018	 add         r3, sp, #0x18
  00314	e58d3004	 str         r3, [sp, #4]
  00318	e59d3010	 ldr         r3, [sp, #0x10]
  0031c	e58d3000	 str         r3, [sp]
  00320	e28d300c	 add         r3, sp, #0xC
  00324	e3a02000	 mov         r2, #0
  00328	e59d1014	 ldr         r1, [sp, #0x14]
  0032c	e59d0060	 ldr         r0, [sp, #0x60]
  00330	eb000000	 bl          RegQueryValueExW
  00334	e58d003c	 str         r0, [sp, #0x3C]
  00338	e59d303c	 ldr         r3, [sp, #0x3C]
  0033c	e58d301c	 str         r3, [sp, #0x1C]

; 38   :         if (status == ERROR_SUCCESS || pParam->required) goto cleanUp;

  00340	e59d301c	 ldr         r3, [sp, #0x1C]
  00344	e3530000	 cmp         r3, #0
  00348	0a000004	 beq         |$LN9@GetStringP|
  0034c	e59d3068	 ldr         r3, [sp, #0x68]
  00350	e2833008	 add         r3, r3, #8
  00354	e5933000	 ldr         r3, [r3]
  00358	e3530000	 cmp         r3, #0
  0035c	0a000000	 beq         |$LN10@GetStringP|
  00360		 |$LN9@GetStringP|
  00360	ea00006d	 b           |$cleanUp$39135|
  00364		 |$LN10@GetStringP|

; 39   :         size = (wcslen((WCHAR*)pParam->pDefault) + 1) * sizeof(WCHAR);

  00364	e59d3068	 ldr         r3, [sp, #0x68]
  00368	e2833014	 add         r3, r3, #0x14
  0036c	e5930000	 ldr         r0, [r3]
  00370	eb000000	 bl          wcslen
  00374	e58d0040	 str         r0, [sp, #0x40]
  00378	e59d3040	 ldr         r3, [sp, #0x40]
  0037c	e2832001	 add         r2, r3, #1
  00380	e3a03002	 mov         r3, #2
  00384	e0030392	 mul         r3, r2, r3
  00388	e58d3018	 str         r3, [sp, #0x18]

; 40   :         if (size > pParam->size) {

  0038c	e59d3068	 ldr         r3, [sp, #0x68]
  00390	e2833010	 add         r3, r3, #0x10
  00394	e59d2018	 ldr         r2, [sp, #0x18]
  00398	e5933000	 ldr         r3, [r3]
  0039c	e1520003	 cmp         r2, r3
  003a0	9a000002	 bls         |$LN8@GetStringP|

; 41   :             status = ERROR_OUTOFMEMORY;

  003a4	e3a0300e	 mov         r3, #0xE
  003a8	e58d301c	 str         r3, [sp, #0x1C]

; 42   :         } else {

  003ac	ea000007	 b           |$LN7@GetStringP|
  003b0		 |$LN8@GetStringP|

; 43   :             memcpy(pValue, pParam->pDefault, size);

  003b0	e59d2018	 ldr         r2, [sp, #0x18]
  003b4	e59d3068	 ldr         r3, [sp, #0x68]
  003b8	e2833014	 add         r3, r3, #0x14
  003bc	e5931000	 ldr         r1, [r3]
  003c0	e59d0010	 ldr         r0, [sp, #0x10]
  003c4	eb000000	 bl          memcpy

; 44   :             status = ERROR_SUCCESS;

  003c8	e3a03000	 mov         r3, #0
  003cc	e58d301c	 str         r3, [sp, #0x1C]
  003d0		 |$LN7@GetStringP|

; 45   :         }            
; 46   : 
; 47   :     } else {

  003d0	ea000051	 b           |$LN6@GetStringP|
  003d4		 |$LN11@GetStringP|

; 48   : 
; 49   :         // First find if value is there
; 50   :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  003d4	e28d3018	 add         r3, sp, #0x18
  003d8	e58d3004	 str         r3, [sp, #4]
  003dc	e3a03000	 mov         r3, #0
  003e0	e58d3000	 str         r3, [sp]
  003e4	e28d300c	 add         r3, sp, #0xC
  003e8	e3a02000	 mov         r2, #0
  003ec	e59d1014	 ldr         r1, [sp, #0x14]
  003f0	e59d0060	 ldr         r0, [sp, #0x60]
  003f4	eb000000	 bl          RegQueryValueExW
  003f8	e58d0044	 str         r0, [sp, #0x44]
  003fc	e59d3044	 ldr         r3, [sp, #0x44]
  00400	e58d301c	 str         r3, [sp, #0x1C]

; 51   :         // Value isn't in registry, break or use default
; 52   :         if (status != ERROR_SUCCESS) {

  00404	e59d301c	 ldr         r3, [sp, #0x1C]
  00408	e3530000	 cmp         r3, #0
  0040c	0a000027	 beq         |$LN5@GetStringP|

; 53   :             if (pParam->required) goto cleanUp;

  00410	e59d3068	 ldr         r3, [sp, #0x68]
  00414	e2833008	 add         r3, r3, #8
  00418	e5933000	 ldr         r3, [r3]
  0041c	e3530000	 cmp         r3, #0
  00420	0a000000	 beq         |$LN4@GetStringP|
  00424	ea00003c	 b           |$cleanUp$39135|
  00428		 |$LN4@GetStringP|

; 54   :             size = (wcslen((WCHAR*)pParam->pDefault) + 1) * sizeof(WCHAR);

  00428	e59d3068	 ldr         r3, [sp, #0x68]
  0042c	e2833014	 add         r3, r3, #0x14
  00430	e5930000	 ldr         r0, [r3]
  00434	eb000000	 bl          wcslen
  00438	e58d0048	 str         r0, [sp, #0x48]
  0043c	e59d3048	 ldr         r3, [sp, #0x48]
  00440	e2832001	 add         r2, r3, #1
  00444	e3a03002	 mov         r3, #2
  00448	e0030392	 mul         r3, r2, r3
  0044c	e58d3018	 str         r3, [sp, #0x18]

; 55   :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  00450	e59d1018	 ldr         r1, [sp, #0x18]
  00454	e3a00000	 mov         r0, #0
  00458	eb000000	 bl          LocalAlloc
  0045c	e58d004c	 str         r0, [sp, #0x4C]
  00460	e59d304c	 ldr         r3, [sp, #0x4C]
  00464	e58d3008	 str         r3, [sp, #8]

; 56   :             if (pBuffer == NULL) {

  00468	e59d3008	 ldr         r3, [sp, #8]
  0046c	e3530000	 cmp         r3, #0
  00470	1a000002	 bne         |$LN3@GetStringP|

; 57   :                 status = ERROR_OUTOFMEMORY;

  00474	e3a0300e	 mov         r3, #0xE
  00478	e58d301c	 str         r3, [sp, #0x1C]

; 58   :                 goto cleanUp;

  0047c	ea000026	 b           |$cleanUp$39135|
  00480		 |$LN3@GetStringP|

; 59   :             }                        
; 60   :             memcpy(pBuffer, pParam->pDefault, size);

  00480	e59d2018	 ldr         r2, [sp, #0x18]
  00484	e59d3068	 ldr         r3, [sp, #0x68]
  00488	e2833014	 add         r3, r3, #0x14
  0048c	e5931000	 ldr         r1, [r3]
  00490	e59d0008	 ldr         r0, [sp, #8]
  00494	eb000000	 bl          memcpy

; 61   :             *(VOID**)pValue = pBuffer;

  00498	e59d2008	 ldr         r2, [sp, #8]
  0049c	e59d3010	 ldr         r3, [sp, #0x10]
  004a0	e5832000	 str         r2, [r3]

; 62   :             status = ERROR_SUCCESS;

  004a4	e3a03000	 mov         r3, #0
  004a8	e58d301c	 str         r3, [sp, #0x1C]

; 63   :         } else {

  004ac	ea00001a	 b           |$LN2@GetStringP|
  004b0		 |$LN5@GetStringP|

; 64   :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  004b0	e59d1018	 ldr         r1, [sp, #0x18]
  004b4	e3a00000	 mov         r0, #0
  004b8	eb000000	 bl          LocalAlloc
  004bc	e58d0050	 str         r0, [sp, #0x50]
  004c0	e59d3050	 ldr         r3, [sp, #0x50]
  004c4	e58d3008	 str         r3, [sp, #8]

; 65   :             if (pBuffer == NULL) {

  004c8	e59d3008	 ldr         r3, [sp, #8]
  004cc	e3530000	 cmp         r3, #0
  004d0	1a000002	 bne         |$LN1@GetStringP|

; 66   :                 status = ERROR_OUTOFMEMORY;

  004d4	e3a0300e	 mov         r3, #0xE
  004d8	e58d301c	 str         r3, [sp, #0x1C]

; 67   :                 goto cleanUp;

  004dc	ea00000e	 b           |$cleanUp$39135|
  004e0		 |$LN1@GetStringP|

; 68   :             }                        
; 69   :             status = RegQueryValueEx(hKey, pName, NULL, &type, pBuffer, &size);

  004e0	e28d3018	 add         r3, sp, #0x18
  004e4	e58d3004	 str         r3, [sp, #4]
  004e8	e59d3008	 ldr         r3, [sp, #8]
  004ec	e58d3000	 str         r3, [sp]
  004f0	e28d300c	 add         r3, sp, #0xC
  004f4	e3a02000	 mov         r2, #0
  004f8	e59d1014	 ldr         r1, [sp, #0x14]
  004fc	e59d0060	 ldr         r0, [sp, #0x60]
  00500	eb000000	 bl          RegQueryValueExW
  00504	e58d0054	 str         r0, [sp, #0x54]
  00508	e59d3054	 ldr         r3, [sp, #0x54]
  0050c	e58d301c	 str         r3, [sp, #0x1C]

; 70   :             *(VOID**)pValue = pBuffer;

  00510	e59d2008	 ldr         r2, [sp, #8]
  00514	e59d3010	 ldr         r3, [sp, #0x10]
  00518	e5832000	 str         r2, [r3]
  0051c		 |$LN2@GetStringP|
  0051c		 |$LN6@GetStringP|
  0051c		 |$cleanUp$39135|

; 71   :         }
; 72   :     }        
; 73   : 
; 74   : cleanUp:
; 75   :     return status;

  0051c	e59d301c	 ldr         r3, [sp, #0x1C]
  00520	e58d3038	 str         r3, [sp, #0x38]

; 76   : }

  00524	e59d0038	 ldr         r0, [sp, #0x38]
  00528	e28dd058	 add         sp, sp, #0x58
  0052c	e89d6000	 ldmia       sp, {sp, lr}
  00530	e12fff1e	 bx          lr
  00534		 |$M39342|

			 ENDP  ; |GetStringParam|


  00010			 AREA	 |.pdata|, PDATA
|$T39352| DCD	|$LN7@GetDWordPa|
	DCD	0x40003304
; Function compile flags: /Odtp

  00534			 AREA	 |.text|, CODE, ARM

  00534		 |GetDWordParam| PROC

; 82   : ) {

  00534		 |$LN7@GetDWordPa|
  00534	e1a0c00d	 mov         r12, sp
  00538	e92d0007	 stmdb       sp!, {r0 - r2}
  0053c	e92d5000	 stmdb       sp!, {r12, lr}
  00540	e24dd02c	 sub         sp, sp, #0x2C
  00544		 |$M39349|

; 83   :     DWORD status, size, type;
; 84   :     WCHAR *pName;
; 85   :     UCHAR *pValue;
; 86   : 
; 87   :     pName = pParam->name;

  00544	e59d303c	 ldr         r3, [sp, #0x3C]
  00548	e5933000	 ldr         r3, [r3]
  0054c	e58d3010	 str         r3, [sp, #0x10]

; 88   :     pValue = (UCHAR*)pBase + pParam->offset;

  00550	e59d303c	 ldr         r3, [sp, #0x3C]
  00554	e283300c	 add         r3, r3, #0xC
  00558	e59d2038	 ldr         r2, [sp, #0x38]
  0055c	e5933000	 ldr         r3, [r3]
  00560	e0823003	 add         r3, r2, r3
  00564	e58d300c	 str         r3, [sp, #0xC]

; 89   :     size = pParam->size;

  00568	e59d303c	 ldr         r3, [sp, #0x3C]
  0056c	e2833010	 add         r3, r3, #0x10
  00570	e5933000	 ldr         r3, [r3]
  00574	e58d3014	 str         r3, [sp, #0x14]

; 90   :     
; 91   :     status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00578	e28d3014	 add         r3, sp, #0x14
  0057c	e58d3004	 str         r3, [sp, #4]
  00580	e59d300c	 ldr         r3, [sp, #0xC]
  00584	e58d3000	 str         r3, [sp]
  00588	e28d3008	 add         r3, sp, #8
  0058c	e3a02000	 mov         r2, #0
  00590	e59d1010	 ldr         r1, [sp, #0x10]
  00594	e59d0034	 ldr         r0, [sp, #0x34]
  00598	eb000000	 bl          RegQueryValueExW
  0059c	e58d0028	 str         r0, [sp, #0x28]
  005a0	e59d3028	 ldr         r3, [sp, #0x28]
  005a4	e58d3018	 str         r3, [sp, #0x18]

; 92   :     if (status == ERROR_SUCCESS || pParam->required) goto cleanUp;

  005a8	e59d3018	 ldr         r3, [sp, #0x18]
  005ac	e3530000	 cmp         r3, #0
  005b0	0a000004	 beq         |$LN1@GetDWordPa|
  005b4	e59d303c	 ldr         r3, [sp, #0x3C]
  005b8	e2833008	 add         r3, r3, #8
  005bc	e5933000	 ldr         r3, [r3]
  005c0	e3530000	 cmp         r3, #0
  005c4	0a000000	 beq         |$LN2@GetDWordPa|
  005c8		 |$LN1@GetDWordPa|
  005c8	ea000006	 b           |$cleanUp$39174|
  005cc		 |$LN2@GetDWordPa|

; 93   : 
; 94   :     *(DWORD*)pValue = (DWORD)pParam->pDefault;

  005cc	e59d303c	 ldr         r3, [sp, #0x3C]
  005d0	e2833014	 add         r3, r3, #0x14
  005d4	e5932000	 ldr         r2, [r3]
  005d8	e59d300c	 ldr         r3, [sp, #0xC]
  005dc	e5832000	 str         r2, [r3]

; 95   :     status = ERROR_SUCCESS;

  005e0	e3a03000	 mov         r3, #0
  005e4	e58d3018	 str         r3, [sp, #0x18]
  005e8		 |$cleanUp$39174|

; 96   : 
; 97   : cleanUp:
; 98   :     return status;

  005e8	e59d3018	 ldr         r3, [sp, #0x18]
  005ec	e58d3024	 str         r3, [sp, #0x24]

; 99   : }

  005f0	e59d0024	 ldr         r0, [sp, #0x24]
  005f4	e28dd02c	 add         sp, sp, #0x2C
  005f8	e89d6000	 ldmia       sp, {sp, lr}
  005fc	e12fff1e	 bx          lr
  00600		 |$M39350|

			 ENDP  ; |GetDWordParam|

	IMPORT	|wcstoul|

  00018			 AREA	 |.pdata|, PDATA
|$T39366| DCD	|$LN26@GetMultiDW|
	DCD	0x4000b904
; Function compile flags: /Odtp

  00600			 AREA	 |.text|, CODE, ARM

  00600		 |GetMultiDWordParam| PROC

; 105  : ) {

  00600		 |$LN26@GetMultiDW|
  00600	e1a0c00d	 mov         r12, sp
  00604	e92d0007	 stmdb       sp!, {r0 - r2}
  00608	e92d5000	 stmdb       sp!, {r12, lr}
  0060c	e24dd05c	 sub         sp, sp, #0x5C
  00610		 |$M39363|

; 106  :     DWORD status, size, type;
; 107  :     WCHAR *pName, *pBuffer = NULL, *pPos;

  00610	e3a03000	 mov         r3, #0
  00614	e58d3008	 str         r3, [sp, #8]

; 108  :     UCHAR *pValue, *pDefault;
; 109  : 
; 110  : 
; 111  :     pName = pParam->name;

  00618	e59d306c	 ldr         r3, [sp, #0x6C]
  0061c	e5933000	 ldr         r3, [r3]
  00620	e58d3014	 str         r3, [sp, #0x14]

; 112  :     pValue = (UCHAR*)pBase + pParam->offset;

  00624	e59d306c	 ldr         r3, [sp, #0x6C]
  00628	e283300c	 add         r3, r3, #0xC
  0062c	e59d2068	 ldr         r2, [sp, #0x68]
  00630	e5933000	 ldr         r3, [r3]
  00634	e0823003	 add         r3, r2, r3
  00638	e58d3010	 str         r3, [sp, #0x10]

; 113  :     pDefault = (UCHAR*)pParam->pDefault;

  0063c	e59d306c	 ldr         r3, [sp, #0x6C]
  00640	e2833014	 add         r3, r3, #0x14
  00644	e5933000	 ldr         r3, [r3]
  00648	e58d301c	 str         r3, [sp, #0x1C]

; 114  : 
; 115  :     // Get registry value type and size
; 116  :     status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  0064c	e28d3018	 add         r3, sp, #0x18
  00650	e58d3004	 str         r3, [sp, #4]
  00654	e3a03000	 mov         r3, #0
  00658	e58d3000	 str         r3, [sp]
  0065c	e28d300c	 add         r3, sp, #0xC
  00660	e3a02000	 mov         r2, #0
  00664	e59d1014	 ldr         r1, [sp, #0x14]
  00668	e59d0064	 ldr         r0, [sp, #0x64]
  0066c	eb000000	 bl          RegQueryValueExW
  00670	e58d0044	 str         r0, [sp, #0x44]
  00674	e59d3044	 ldr         r3, [sp, #0x44]
  00678	e58d3020	 str         r3, [sp, #0x20]

; 117  :     if (status != ERROR_SUCCESS) {

  0067c	e59d3020	 ldr         r3, [sp, #0x20]
  00680	e3530000	 cmp         r3, #0
  00684	0a000011	 beq         |$LN19@GetMultiDW|

; 118  :         // If value doesn't exists use default value if optional
; 119  :         if (pParam->required) goto cleanUp;

  00688	e59d306c	 ldr         r3, [sp, #0x6C]
  0068c	e2833008	 add         r3, r3, #8
  00690	e5933000	 ldr         r3, [r3]
  00694	e3530000	 cmp         r3, #0
  00698	0a000000	 beq         |$LN18@GetMultiDW|
  0069c	ea000085	 b           |$cleanUp$39200|
  006a0		 |$LN18@GetMultiDW|

; 120  :         if (pDefault != NULL) memcpy(pValue, pDefault, pParam->size);

  006a0	e59d301c	 ldr         r3, [sp, #0x1C]
  006a4	e3530000	 cmp         r3, #0
  006a8	0a000005	 beq         |$LN17@GetMultiDW|
  006ac	e59d306c	 ldr         r3, [sp, #0x6C]
  006b0	e2833010	 add         r3, r3, #0x10
  006b4	e5932000	 ldr         r2, [r3]
  006b8	e59d101c	 ldr         r1, [sp, #0x1C]
  006bc	e59d0010	 ldr         r0, [sp, #0x10]
  006c0	eb000000	 bl          memcpy
  006c4		 |$LN17@GetMultiDW|

; 121  :         status = ERROR_SUCCESS;

  006c4	e3a03000	 mov         r3, #0
  006c8	e58d3020	 str         r3, [sp, #0x20]

; 122  :         goto cleanUp;

  006cc	ea000079	 b           |$cleanUp$39200|
  006d0		 |$LN19@GetMultiDW|

; 123  :     }        
; 124  : 
; 125  :     // If type is DWORD and we expect it, simply read it
; 126  :     if (type == REG_DWORD) {

  006d0	e59d300c	 ldr         r3, [sp, #0xC]
  006d4	e3530004	 cmp         r3, #4
  006d8	1a000012	 bne         |$LN16@GetMultiDW|

; 127  :         if (size == sizeof(DWORD)) {

  006dc	e59d3018	 ldr         r3, [sp, #0x18]
  006e0	e3530004	 cmp         r3, #4
  006e4	1a00000c	 bne         |$LN15@GetMultiDW|

; 128  :             status = RegQueryValueEx(hKey, pName, NULL, NULL, pValue, NULL);

  006e8	e3a03000	 mov         r3, #0
  006ec	e58d3004	 str         r3, [sp, #4]
  006f0	e59d3010	 ldr         r3, [sp, #0x10]
  006f4	e58d3000	 str         r3, [sp]
  006f8	e3a03000	 mov         r3, #0
  006fc	e3a02000	 mov         r2, #0
  00700	e59d1014	 ldr         r1, [sp, #0x14]
  00704	e59d0064	 ldr         r0, [sp, #0x64]
  00708	eb000000	 bl          RegQueryValueExW
  0070c	e58d0048	 str         r0, [sp, #0x48]
  00710	e59d3048	 ldr         r3, [sp, #0x48]
  00714	e58d3020	 str         r3, [sp, #0x20]

; 129  :         } else {

  00718	ea000001	 b           |$LN14@GetMultiDW|
  0071c		 |$LN15@GetMultiDW|

; 130  :             status = ERROR_BAD_LENGTH;

  0071c	e3a03018	 mov         r3, #0x18
  00720	e58d3020	 str         r3, [sp, #0x20]
  00724		 |$LN14@GetMultiDW|

; 131  :         }

  00724	ea000063	 b           |$LN13@GetMultiDW|
  00728		 |$LN16@GetMultiDW|

; 132  :     } else if (type == REG_SZ || type == REG_MULTI_SZ) {

  00728	e59d300c	 ldr         r3, [sp, #0xC]
  0072c	e3530001	 cmp         r3, #1
  00730	0a000002	 beq         |$LN11@GetMultiDW|
  00734	e59d300c	 ldr         r3, [sp, #0xC]
  00738	e3530007	 cmp         r3, #7
  0073c	1a00005b	 bne         |$LN12@GetMultiDW|
  00740		 |$LN11@GetMultiDW|

; 133  :         // Allocate buffer for key
; 134  :         pBuffer = LocalAlloc(LPTR, size);

  00740	e59d1018	 ldr         r1, [sp, #0x18]
  00744	e3a00040	 mov         r0, #0x40
  00748	eb000000	 bl          LocalAlloc
  0074c	e58d004c	 str         r0, [sp, #0x4C]
  00750	e59d304c	 ldr         r3, [sp, #0x4C]
  00754	e58d3008	 str         r3, [sp, #8]

; 135  :         if (pBuffer == NULL) {

  00758	e59d3008	 ldr         r3, [sp, #8]
  0075c	e3530000	 cmp         r3, #0
  00760	1a000002	 bne         |$LN10@GetMultiDW|

; 136  :             status = ERROR_OUTOFMEMORY;

  00764	e3a0300e	 mov         r3, #0xE
  00768	e58d3020	 str         r3, [sp, #0x20]

; 137  :             goto cleanUp;

  0076c	ea000051	 b           |$cleanUp$39200|
  00770		 |$LN10@GetMultiDW|

; 138  :         }
; 139  :         // Read registry value (in most cases it should not fail)
; 140  :         status = RegQueryValueEx(
; 141  :             hKey, pName, NULL, NULL, (UCHAR*)pBuffer, &size
; 142  :         );

  00770	e28d3018	 add         r3, sp, #0x18
  00774	e58d3004	 str         r3, [sp, #4]
  00778	e59d3008	 ldr         r3, [sp, #8]
  0077c	e58d3000	 str         r3, [sp]
  00780	e3a03000	 mov         r3, #0
  00784	e3a02000	 mov         r2, #0
  00788	e59d1014	 ldr         r1, [sp, #0x14]
  0078c	e59d0064	 ldr         r0, [sp, #0x64]
  00790	eb000000	 bl          RegQueryValueExW
  00794	e58d0050	 str         r0, [sp, #0x50]
  00798	e59d3050	 ldr         r3, [sp, #0x50]
  0079c	e58d3020	 str         r3, [sp, #0x20]

; 143  :         if (status != ERROR_SUCCESS) goto cleanUp;

  007a0	e59d3020	 ldr         r3, [sp, #0x20]
  007a4	e3530000	 cmp         r3, #0
  007a8	0a000000	 beq         |$LN9@GetMultiDW|
  007ac	ea000041	 b           |$cleanUp$39200|
  007b0		 |$LN9@GetMultiDW|

; 144  :         pPos = pBuffer;

  007b0	e59d3008	 ldr         r3, [sp, #8]
  007b4	e58d3024	 str         r3, [sp, #0x24]

; 145  :         size = pParam->size;

  007b8	e59d306c	 ldr         r3, [sp, #0x6C]
  007bc	e2833010	 add         r3, r3, #0x10
  007c0	e5933000	 ldr         r3, [r3]
  007c4	e58d3018	 str         r3, [sp, #0x18]
  007c8		 |$LN8@GetMultiDW|

; 146  :         while (size >= sizeof(DWORD) && *pPos != L'\0') {

  007c8	e59d3018	 ldr         r3, [sp, #0x18]
  007cc	e3530004	 cmp         r3, #4
  007d0	3a00002b	 bcc         |$LN7@GetMultiDW|
  007d4	e59d3024	 ldr         r3, [sp, #0x24]
  007d8	e1d330b0	 ldrh        r3, [r3]
  007dc	e3530000	 cmp         r3, #0
  007e0	0a000027	 beq         |$LN7@GetMultiDW|
  007e4		 |$LN6@GetMultiDW|

; 147  :             while (*pPos == L' ' || (type == REG_SZ && *pPos == L',')) pPos++;

  007e4	e59d3024	 ldr         r3, [sp, #0x24]
  007e8	e1d330b0	 ldrh        r3, [r3]
  007ec	e3530020	 cmp         r3, #0x20
  007f0	0a000006	 beq         |$LN4@GetMultiDW|
  007f4	e59d300c	 ldr         r3, [sp, #0xC]
  007f8	e3530001	 cmp         r3, #1
  007fc	1a000007	 bne         |$LN5@GetMultiDW|
  00800	e59d3024	 ldr         r3, [sp, #0x24]
  00804	e1d330b0	 ldrh        r3, [r3]
  00808	e353002c	 cmp         r3, #0x2C
  0080c	1a000003	 bne         |$LN5@GetMultiDW|
  00810		 |$LN4@GetMultiDW|
  00810	e59d3024	 ldr         r3, [sp, #0x24]
  00814	e2833002	 add         r3, r3, #2
  00818	e58d3024	 str         r3, [sp, #0x24]
  0081c	eafffff0	 b           |$LN6@GetMultiDW|
  00820		 |$LN5@GetMultiDW|

; 148  :             *(DWORD*)pValue = wcstoul(pPos, &pPos, 16);

  00820	e3a02010	 mov         r2, #0x10
  00824	e28d1024	 add         r1, sp, #0x24
  00828	e59d0024	 ldr         r0, [sp, #0x24]
  0082c	eb000000	 bl          wcstoul
  00830	e58d0054	 str         r0, [sp, #0x54]
  00834	e59d2054	 ldr         r2, [sp, #0x54]
  00838	e59d3010	 ldr         r3, [sp, #0x10]
  0083c	e5832000	 str         r2, [r3]

; 149  :             pValue += sizeof(DWORD);

  00840	e59d3010	 ldr         r3, [sp, #0x10]
  00844	e2833004	 add         r3, r3, #4
  00848	e58d3010	 str         r3, [sp, #0x10]

; 150  :             size -= sizeof(DWORD);

  0084c	e59d3018	 ldr         r3, [sp, #0x18]
  00850	e2433004	 sub         r3, r3, #4
  00854	e58d3018	 str         r3, [sp, #0x18]

; 151  :             if (type == REG_MULTI_SZ && *pPos == L'\0') pPos++;

  00858	e59d300c	 ldr         r3, [sp, #0xC]
  0085c	e3530007	 cmp         r3, #7
  00860	1a000006	 bne         |$LN3@GetMultiDW|
  00864	e59d3024	 ldr         r3, [sp, #0x24]
  00868	e1d330b0	 ldrh        r3, [r3]
  0086c	e3530000	 cmp         r3, #0
  00870	1a000002	 bne         |$LN3@GetMultiDW|
  00874	e59d3024	 ldr         r3, [sp, #0x24]
  00878	e2833002	 add         r3, r3, #2
  0087c	e58d3024	 str         r3, [sp, #0x24]
  00880		 |$LN3@GetMultiDW|

; 152  :         }

  00880	eaffffd0	 b           |$LN8@GetMultiDW|
  00884		 |$LN7@GetMultiDW|

; 153  :         status = size == 0 ? ERROR_SUCCESS : ERROR_BAD_FORMAT;

  00884	e59d3018	 ldr         r3, [sp, #0x18]
  00888	e3530000	 cmp         r3, #0
  0088c	1a000002	 bne         |$LN22@GetMultiDW|
  00890	e3a03000	 mov         r3, #0
  00894	e58d3058	 str         r3, [sp, #0x58]
  00898	ea000001	 b           |$LN23@GetMultiDW|
  0089c		 |$LN22@GetMultiDW|
  0089c	e3a0300b	 mov         r3, #0xB
  008a0	e58d3058	 str         r3, [sp, #0x58]
  008a4		 |$LN23@GetMultiDW|
  008a4	e59d3058	 ldr         r3, [sp, #0x58]
  008a8	e58d3020	 str         r3, [sp, #0x20]

; 154  :     } else {

  008ac	ea000001	 b           |$LN2@GetMultiDW|
  008b0		 |$LN12@GetMultiDW|

; 155  :         status = ERROR_BAD_FORMAT;

  008b0	e3a0300b	 mov         r3, #0xB
  008b4	e58d3020	 str         r3, [sp, #0x20]
  008b8		 |$LN2@GetMultiDW|
  008b8		 |$LN13@GetMultiDW|
  008b8		 |$cleanUp$39200|

; 156  :     }        
; 157  : 
; 158  : cleanUp:
; 159  :     if (pBuffer != NULL) LocalFree(pBuffer);

  008b8	e59d3008	 ldr         r3, [sp, #8]
  008bc	e3530000	 cmp         r3, #0
  008c0	0a000001	 beq         |$LN1@GetMultiDW|
  008c4	e59d0008	 ldr         r0, [sp, #8]
  008c8	eb000000	 bl          LocalFree
  008cc		 |$LN1@GetMultiDW|

; 160  :     return status;

  008cc	e59d3020	 ldr         r3, [sp, #0x20]
  008d0	e58d3040	 str         r3, [sp, #0x40]

; 161  : }

  008d4	e59d0040	 ldr         r0, [sp, #0x40]
  008d8	e28dd05c	 add         sp, sp, #0x5C
  008dc	e89d6000	 ldmia       sp, {sp, lr}
  008e0	e12fff1e	 bx          lr
  008e4		 |$M39364|

			 ENDP  ; |GetMultiDWordParam|


  00020			 AREA	 |.pdata|, PDATA
|$T39378| DCD	|$LN13@GetBinPara|
	DCD	0x40007004
; Function compile flags: /Odtp

  008e4			 AREA	 |.text|, CODE, ARM

  008e4		 |GetBinParam| PROC

; 167  : ) {

  008e4		 |$LN13@GetBinPara|
  008e4	e1a0c00d	 mov         r12, sp
  008e8	e92d0007	 stmdb       sp!, {r0 - r2}
  008ec	e92d5000	 stmdb       sp!, {r12, lr}
  008f0	e24dd04c	 sub         sp, sp, #0x4C
  008f4		 |$M39375|

; 168  :     DWORD status, size, type;
; 169  :     WCHAR *pName;
; 170  :     UCHAR *pBuffer, *pValue;
; 171  : 
; 172  :     pName = pParam->name;

  008f4	e59d305c	 ldr         r3, [sp, #0x5C]
  008f8	e5933000	 ldr         r3, [r3]
  008fc	e58d3014	 str         r3, [sp, #0x14]

; 173  :     pValue = (UCHAR*)pBase + pParam->offset;

  00900	e59d305c	 ldr         r3, [sp, #0x5C]
  00904	e283300c	 add         r3, r3, #0xC
  00908	e59d2058	 ldr         r2, [sp, #0x58]
  0090c	e5933000	 ldr         r3, [r3]
  00910	e0823003	 add         r3, r2, r3
  00914	e58d3010	 str         r3, [sp, #0x10]

; 174  :     size = pParam->size;

  00918	e59d305c	 ldr         r3, [sp, #0x5C]
  0091c	e2833010	 add         r3, r3, #0x10
  00920	e5933000	 ldr         r3, [r3]
  00924	e58d3018	 str         r3, [sp, #0x18]

; 175  : 
; 176  :     // If there is parameter size we simply try to read value or used default
; 177  :     if (size > 0) {

  00928	e59d3018	 ldr         r3, [sp, #0x18]
  0092c	e3530000	 cmp         r3, #0
  00930	9a00001f	 bls         |$LN8@GetBinPara|

; 178  : 
; 179  :         status = RegQueryValueEx(hKey, pName, NULL, &type, pValue, &size);

  00934	e28d3018	 add         r3, sp, #0x18
  00938	e58d3004	 str         r3, [sp, #4]
  0093c	e59d3010	 ldr         r3, [sp, #0x10]
  00940	e58d3000	 str         r3, [sp]
  00944	e28d300c	 add         r3, sp, #0xC
  00948	e3a02000	 mov         r2, #0
  0094c	e59d1014	 ldr         r1, [sp, #0x14]
  00950	e59d0054	 ldr         r0, [sp, #0x54]
  00954	eb000000	 bl          RegQueryValueExW
  00958	e58d003c	 str         r0, [sp, #0x3C]
  0095c	e59d303c	 ldr         r3, [sp, #0x3C]
  00960	e58d301c	 str         r3, [sp, #0x1C]

; 180  :         if (status == ERROR_SUCCESS || pParam->required) goto cleanUp;

  00964	e59d301c	 ldr         r3, [sp, #0x1C]
  00968	e3530000	 cmp         r3, #0
  0096c	0a000004	 beq         |$LN6@GetBinPara|
  00970	e59d305c	 ldr         r3, [sp, #0x5C]
  00974	e2833008	 add         r3, r3, #8
  00978	e5933000	 ldr         r3, [r3]
  0097c	e3530000	 cmp         r3, #0
  00980	0a000000	 beq         |$LN7@GetBinPara|
  00984		 |$LN6@GetBinPara|
  00984	ea000040	 b           |$cleanUp$39253|
  00988		 |$LN7@GetBinPara|

; 181  :         memcpy(pValue, pParam->pDefault, pParam->size);

  00988	e59d305c	 ldr         r3, [sp, #0x5C]
  0098c	e2833010	 add         r3, r3, #0x10
  00990	e5932000	 ldr         r2, [r3]
  00994	e59d305c	 ldr         r3, [sp, #0x5C]
  00998	e2833014	 add         r3, r3, #0x14
  0099c	e5931000	 ldr         r1, [r3]
  009a0	e59d0010	 ldr         r0, [sp, #0x10]
  009a4	eb000000	 bl          memcpy

; 182  :         status = ERROR_SUCCESS;

  009a8	e3a03000	 mov         r3, #0
  009ac	e58d301c	 str         r3, [sp, #0x1C]

; 183  : 
; 184  :     } else {

  009b0	ea000035	 b           |$LN5@GetBinPara|
  009b4		 |$LN8@GetBinPara|

; 185  : 
; 186  :         // First find if value is there
; 187  :         status = RegQueryValueEx(hKey, pName, NULL, &type, NULL, &size);

  009b4	e28d3018	 add         r3, sp, #0x18
  009b8	e58d3004	 str         r3, [sp, #4]
  009bc	e3a03000	 mov         r3, #0
  009c0	e58d3000	 str         r3, [sp]
  009c4	e28d300c	 add         r3, sp, #0xC
  009c8	e3a02000	 mov         r2, #0
  009cc	e59d1014	 ldr         r1, [sp, #0x14]
  009d0	e59d0054	 ldr         r0, [sp, #0x54]
  009d4	eb000000	 bl          RegQueryValueExW
  009d8	e58d0040	 str         r0, [sp, #0x40]
  009dc	e59d3040	 ldr         r3, [sp, #0x40]
  009e0	e58d301c	 str         r3, [sp, #0x1C]

; 188  :         // Value isn't in registry, break or use default
; 189  :         if (status != ERROR_SUCCESS) {

  009e4	e59d301c	 ldr         r3, [sp, #0x1C]
  009e8	e3530000	 cmp         r3, #0
  009ec	0a00000b	 beq         |$LN4@GetBinPara|

; 190  :             if (pParam->required) goto cleanUp;

  009f0	e59d305c	 ldr         r3, [sp, #0x5C]
  009f4	e2833008	 add         r3, r3, #8
  009f8	e5933000	 ldr         r3, [r3]
  009fc	e3530000	 cmp         r3, #0
  00a00	0a000000	 beq         |$LN3@GetBinPara|
  00a04	ea000020	 b           |$cleanUp$39253|
  00a08		 |$LN3@GetBinPara|

; 191  :             *(VOID**)pValue = NULL;

  00a08	e59d2010	 ldr         r2, [sp, #0x10]
  00a0c	e3a03000	 mov         r3, #0
  00a10	e5823000	 str         r3, [r2]

; 192  :             status = ERROR_SUCCESS;

  00a14	e3a03000	 mov         r3, #0
  00a18	e58d301c	 str         r3, [sp, #0x1C]

; 193  :         } else {

  00a1c	ea00001a	 b           |$LN2@GetBinPara|
  00a20		 |$LN4@GetBinPara|

; 194  :             pBuffer = (UCHAR*)LocalAlloc(LMEM_FIXED, size);

  00a20	e59d1018	 ldr         r1, [sp, #0x18]
  00a24	e3a00000	 mov         r0, #0
  00a28	eb000000	 bl          LocalAlloc
  00a2c	e58d0044	 str         r0, [sp, #0x44]
  00a30	e59d3044	 ldr         r3, [sp, #0x44]
  00a34	e58d3008	 str         r3, [sp, #8]

; 195  :             if (pBuffer == NULL) {

  00a38	e59d3008	 ldr         r3, [sp, #8]
  00a3c	e3530000	 cmp         r3, #0
  00a40	1a000002	 bne         |$LN1@GetBinPara|

; 196  :                 status = ERROR_OUTOFMEMORY;

  00a44	e3a0300e	 mov         r3, #0xE
  00a48	e58d301c	 str         r3, [sp, #0x1C]

; 197  :                 goto cleanUp;

  00a4c	ea00000e	 b           |$cleanUp$39253|
  00a50		 |$LN1@GetBinPara|

; 198  :             }                        
; 199  :             status = RegQueryValueEx(hKey, pName, NULL, &type, pBuffer, &size);

  00a50	e28d3018	 add         r3, sp, #0x18
  00a54	e58d3004	 str         r3, [sp, #4]
  00a58	e59d3008	 ldr         r3, [sp, #8]
  00a5c	e58d3000	 str         r3, [sp]
  00a60	e28d300c	 add         r3, sp, #0xC
  00a64	e3a02000	 mov         r2, #0
  00a68	e59d1014	 ldr         r1, [sp, #0x14]
  00a6c	e59d0054	 ldr         r0, [sp, #0x54]
  00a70	eb000000	 bl          RegQueryValueExW
  00a74	e58d0048	 str         r0, [sp, #0x48]
  00a78	e59d3048	 ldr         r3, [sp, #0x48]
  00a7c	e58d301c	 str         r3, [sp, #0x1C]

; 200  :             *(VOID**)pValue = pBuffer;

  00a80	e59d2008	 ldr         r2, [sp, #8]
  00a84	e59d3010	 ldr         r3, [sp, #0x10]
  00a88	e5832000	 str         r2, [r3]
  00a8c		 |$LN2@GetBinPara|
  00a8c		 |$LN5@GetBinPara|
  00a8c		 |$cleanUp$39253|

; 201  :         }
; 202  :     }        
; 203  : 
; 204  : cleanUp:
; 205  :     return status;

  00a8c	e59d301c	 ldr         r3, [sp, #0x1C]
  00a90	e58d3038	 str         r3, [sp, #0x38]

; 206  : }

  00a94	e59d0038	 ldr         r0, [sp, #0x38]
  00a98	e28dd04c	 add         sp, sp, #0x4C
  00a9c	e89d6000	 ldmia       sp, {sp, lr}
  00aa0	e12fff1e	 bx          lr
  00aa4		 |$M39376|

			 ENDP  ; |GetBinParam|

	END
