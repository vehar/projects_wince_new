; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\CEDDK\MAP\map.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|g_pTIPB| %	0x4
	EXPORT	|MmMapIoSpace|
	IMPORT	|VirtualFree|
	IMPORT	|VirtualCopy|
	IMPORT	|VirtualAlloc|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\ceddk\map\map.c

  00000			 AREA	 |.pdata|, PDATA
|$T42716| DCD	|$LN15@MmMapIoSpa|
	DCD	0x40005401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MmMapIoSpace| PROC

; 39   : {

  00000		 |$LN15@MmMapIoSpa|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M42713|
  00004	e1a08002	 mov         r8, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 40   :     VOID *pAddress = NULL;

  00010	e3a04000	 mov         r4, #0

; 41   :     UINT64 phSource;
; 42   :     UINT32 sourceSize, offset;
; 43   :     BOOL rc;
; 44   : 
; 45   :     // Check if we can use common mapping for device registers (test is
; 46   :     // simplified as long as we know that we support only 32 bit addressing).
; 47   :     if (
; 48   :         !cacheEnable && phAddress.HighPart == 0 && 
; 49   :         phAddress.LowPart >= OMAP2420_REGS_PA
; 50   :     ) {

  00014	e1b07003	 movs        r7, r3
  00018	1a000021	 bne         |$LN7@MmMapIoSpa|
  0001c	e3550000	 cmp         r5, #0
  00020	1a00001f	 bne         |$LN7@MmMapIoSpa|
  00024	e3560312	 cmp         r6, #0x12, 6
  00028	3a00001d	 bcc         |$LN7@MmMapIoSpa|

; 51   : 
; 52   :         // Create mapping when it doesn't exist yet
; 53   :         if (g_pTIPB == NULL) {

  0002c	e59f5118	 ldr         r5, [pc, #0x118]
  00030	e5953000	 ldr         r3, [r5]
  00034	e3530000	 cmp         r3, #0
  00038	1a000016	 bne         |$LN4@MmMapIoSpa|

; 54   :             
; 55   :             g_pTIPB = VirtualAlloc(
; 56   :                 0, OMAP2420_REGS_SIZE, MEM_RESERVE, PAGE_NOACCESS
; 57   :             );

  0003c	e3a03001	 mov         r3, #1
  00040	e3a02a02	 mov         r2, #2, 20
  00044	e3a01302	 mov         r1, #2, 6
  00048	e3a00000	 mov         r0, #0
  0004c	eb000000	 bl          VirtualAlloc
  00050	e3500000	 cmp         r0, #0
  00054	e5850000	 str         r0, [r5]

; 58   :             if (g_pTIPB == NULL) {

  00058	0a000038	 beq         |$cleanUp$42580|
  0005c	e3a03c06	 mov         r3, #6, 24

; 59   :                 DEBUGMSG(TRUE, (
; 60   :                     L"ERROR: MmMapIoSpace failed reserve registers memory\r\n"
; 61   :                 ));
; 62   :                 goto cleanUp;
; 63   :             }
; 64   :             rc = VirtualCopy(
; 65   :                 g_pTIPB, (PVOID)(OMAP2420_REGS_PA >> 8), 
; 66   :                 OMAP2420_REGS_SIZE, PAGE_PHYSICAL|PAGE_READWRITE|PAGE_NOCACHE
; 67   :             );

  00060	e3833004	 orr         r3, r3, #4
  00064	e3a02302	 mov         r2, #2, 6
  00068	e3a01712	 mov         r1, #0x12, 14
  0006c	eb000000	 bl          VirtualCopy
  00070	e3500000	 cmp         r0, #0

; 68   :             if (!rc) {

  00074	1a000006	 bne         |$LN12@MmMapIoSpa|

; 69   :                 DEBUGMSG(TRUE, (
; 70   :                     L"ERROR: MmMapIoSpace failed allocate registers memory\r\n"
; 71   :                 ));
; 72   :                 VirtualFree(g_pTIPB, 0, MEM_RELEASE);

  00078	e5950000	 ldr         r0, [r5]
  0007c	e3a02902	 mov         r2, #2, 18
  00080	e3a01000	 mov         r1, #0
  00084	eb000000	 bl          VirtualFree

; 73   :                 g_pTIPB = NULL;

  00088	e3a03000	 mov         r3, #0
  0008c	e5853000	 str         r3, [r5]

; 74   :                 goto cleanUp;

  00090	ea00002a	 b           |$cleanUp$42580|
  00094		 |$LN12@MmMapIoSpa|
  00094	e5953000	 ldr         r3, [r5]
  00098		 |$LN4@MmMapIoSpa|

; 75   :             }
; 76   :         }
; 77   : 
; 78   :         // Calculate offset
; 79   :         offset = phAddress.LowPart - OMAP2420_REGS_PA;
; 80   :         (UINT32)pAddress = (UINT32)g_pTIPB + offset;

  00098	e0833006	 add         r3, r3, r6
  0009c	e2434312	 sub         r4, r3, #0x12, 6

; 81   :         
; 82   :     } else {

  000a0	ea000026	 b           |$cleanUp$42580|
  000a4		 |$LN7@MmMapIoSpa|

; 83   : 
; 84   :         phSource = phAddress.QuadPart & ~(PAGE_SIZE - 1);

  000a4	e3e03b0d	 mvn         r3, #0xD, 22
  000a8	e22390fb	 eor         r9, r3, #0xFB
  000ac	e5990000	 ldr         r0, [r9]

; 85   :         sourceSize = size + (phAddress.LowPart & (PAGE_SIZE - 1));
; 86   : 
; 87   :         pAddress = VirtualAlloc(0, sourceSize, MEM_RESERVE, PAGE_NOACCESS);

  000b0	e3a03001	 mov         r3, #1
  000b4	e3a02a02	 mov         r2, #2, 20
  000b8	e2401001	 sub         r1, r0, #1
  000bc	e001a006	 and         r10, r1, r6
  000c0	e2401001	 sub         r1, r0, #1
  000c4	e1e0e001	 mvn         lr, r1
  000c8	e08a1008	 add         r1, r10, r8
  000cc	e3a00000	 mov         r0, #0
  000d0	e00eb006	 and         r11, lr, r6
  000d4	e0055fce	 and         r5, r5, lr, asr #31
  000d8	eb000000	 bl          VirtualAlloc
  000dc	e1b04000	 movs        r4, r0

; 88   :         if (pAddress == NULL) {

  000e0	0a000016	 beq         |$cleanUp$42580|

; 89   :             DEBUGMSG(TRUE, (
; 90   :                 L"ERROR: MmMapIoSpace failed reserve memory\r\n"
; 91   :             ));
; 92   :             goto cleanUp;
; 93   :         }            
; 94   :         rc = VirtualCopy(
; 95   :             pAddress, (PVOID)(phSource >> 8), sourceSize,
; 96   :             PAGE_PHYSICAL | PAGE_READWRITE | (cacheEnable ? 0 : PAGE_NOCACHE)
; 97   :         );

  000e4	e3570000	 cmp         r7, #0
  000e8	e3a03b01	 mov         r3, #1, 22
  000ec	13a02000	 movne       r2, #0
  000f0	03a02c02	 moveq       r2, #2, 24
  000f4	e3833004	 orr         r3, r3, #4
  000f8	e1a01c05	 mov         r1, r5, lsl #24
  000fc	e1823003	 orr         r3, r2, r3
  00100	e08a2008	 add         r2, r10, r8
  00104	e181142b	 orr         r1, r1, r11, lsr #8
  00108	e1a00004	 mov         r0, r4
  0010c	eb000000	 bl          VirtualCopy
  00110	e3500000	 cmp         r0, #0

; 98   :         if (!rc) {

  00114	1a000005	 bne         |$LN1@MmMapIoSpa|

; 99   :             DEBUGMSG(TRUE, (
; 100  :                 L"ERROR: MmMapIoSpace failed allocate memory\r\n"
; 101  :             ));
; 102  :             VirtualFree(pAddress, 0, MEM_RELEASE);

  00118	e3a02902	 mov         r2, #2, 18
  0011c	e3a01000	 mov         r1, #0
  00120	e1a00004	 mov         r0, r4
  00124	eb000000	 bl          VirtualFree

; 103  :             pAddress = NULL;

  00128	e3a04000	 mov         r4, #0

; 104  :             goto cleanUp;

  0012c	ea000003	 b           |$cleanUp$42580|
  00130		 |$LN1@MmMapIoSpa|

; 105  :         }
; 106  :         (UINT32)pAddress += phAddress.LowPart & (PAGE_SIZE - 1);

  00130	e5993000	 ldr         r3, [r9]
  00134	e2433001	 sub         r3, r3, #1
  00138	e0033006	 and         r3, r3, r6
  0013c	e0844003	 add         r4, r4, r3
  00140		 |$cleanUp$42580|

; 107  :     }
; 108  : 
; 109  : cleanUp:
; 110  :     return pAddress;
; 111  : }

  00140	e1a00004	 mov         r0, r4
  00144	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00148	e12fff1e	 bx          lr
  0014c		 |$LN16@MmMapIoSpa|
  0014c		 |$LN17@MmMapIoSpa|
  0014c	00000000	 DCD         |g_pTIPB|
  00150		 |$M42714|

			 ENDP  ; |MmMapIoSpace|

	EXPORT	|MmUnmapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T42726| DCD	|$LN7@MmUnmapIoS|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MmUnmapIoSpace| PROC

; 121  : {

  00000		 |$LN7@MmUnmapIoS|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M42723|

; 122  :     // We want unmap only in case that memory wasn't mapped from common
; 123  :     // mapping.
; 124  :     if (
; 125  :         g_pTIPB == NULL || 
; 126  :         (UINT32)pAddress < (UINT32)g_pTIPB ||
; 127  :         (UINT32)pAddress >= (UINT32)g_pTIPB + OMAP2420_REGS_SIZE
; 128  :     ) {

  00004	e59f3044	 ldr         r3, [pc, #0x44]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000004	 beq         |$LN1@MmUnmapIoS|
  00014	e1500003	 cmp         r0, r3
  00018	3a000002	 bcc         |$LN1@MmUnmapIoS|
  0001c	e2833302	 add         r3, r3, #2, 6
  00020	e1500003	 cmp         r0, r3
  00024	3a000007	 bcc         |$LN2@MmUnmapIoS|
  00028		 |$LN1@MmUnmapIoS|
  00028	e3e03b0d	 mvn         r3, #0xD, 22

; 129  :         VirtualFree(
; 130  :             (VOID*)((UINT32)pAddress & ~(PAGE_SIZE - 1)), 0, MEM_RELEASE
; 131  :         );

  0002c	e22330fb	 eor         r3, r3, #0xFB
  00030	e5933000	 ldr         r3, [r3]
  00034	e3a02902	 mov         r2, #2, 18
  00038	e3a01000	 mov         r1, #0
  0003c	e2433001	 sub         r3, r3, #1
  00040	e1c00003	 bic         r0, r0, r3
  00044	eb000000	 bl          VirtualFree
  00048		 |$LN2@MmUnmapIoS|

; 132  :     }
; 133  : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$LN8@MmUnmapIoS|
  00050		 |$LN9@MmUnmapIoS|
  00050	00000000	 DCD         |g_pTIPB|
  00054		 |$M42724|

			 ENDP  ; |MmUnmapIoSpace|

	EXPORT	|TransBusAddrToVirtual|
	IMPORT	|HalTranslateBusAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T42744| DCD	|$LN12@TransBusAd|
	DCD	0x40002304
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TransBusAddrToVirtual| PROC

; 142  : ) {

  00000		 |$LN12@TransBusAd|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5030	 stmdb       sp!, {r4, r5, r12, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M42741|

; 143  :     BOOL rc = FALSE;
; 144  :     PHYSICAL_ADDRESS phAddress; 
; 145  : 
; 146  :     if (!HalTranslateBusAddress(
; 147  :         ifcType, busNumber, busAddress, pAddressSpace, &phAddress
; 148  :     )) {

  00010	e59d5034	 ldr         r5, [sp, #0x34]
  00014	e28de008	 add         lr, sp, #8
  00018	e3a04000	 mov         r4, #0
  0001c	e58d5000	 str         r5, [sp]
  00020	e58de004	 str         lr, [sp, #4]
  00024	eb000000	 bl          HalTranslateBusAddress
  00028	e3500000	 cmp         r0, #0
  0002c	0a000012	 beq         |$cleanUp$42634|

; 149  :         goto cleanUp;
; 150  :     }
; 151  : 
; 152  :     switch (*pAddressSpace) {

  00030	e5953000	 ldr         r3, [r5]
  00034	e3530000	 cmp         r3, #0
  00038	0a000005	 beq         |$LN3@TransBusAd|
  0003c	e3530001	 cmp         r3, #1
  00040	1a00000d	 bne         |$cleanUp$42634|

; 157  :         break;
; 158  :     case 1:        
; 159  :         // I/O port
; 160  :         *ppMappedAddress = (VOID*)phAddress.LowPart;

  00044	e59d2038	 ldr         r2, [sp, #0x38]
  00048	e59d3008	 ldr         r3, [sp, #8]

; 161  :         rc = TRUE;

  0004c	e5823000	 str         r3, [r2]

; 162  :         break;

  00050	ea000008	 b           |$LN9@TransBusAd|
  00054		 |$LN3@TransBusAd|

; 153  :     case 0:
; 154  :         // Memory-mapped I/O, get virtual address for translated address
; 155  :         *ppMappedAddress = MmMapIoSpace(phAddress, length, FALSE);

  00054	e59d2030	 ldr         r2, [sp, #0x30]
  00058	e59d0008	 ldr         r0, [sp, #8]
  0005c	e59d100c	 ldr         r1, [sp, #0xC]
  00060	e3a03000	 mov         r3, #0
  00064	eb000000	 bl          MmMapIoSpace
  00068	e59d3038	 ldr         r3, [sp, #0x38]
  0006c	e3500000	 cmp         r0, #0
  00070	e5830000	 str         r0, [r3]

; 156  :         if (*ppMappedAddress != NULL) rc = TRUE;

  00074	0a000000	 beq         |$cleanUp$42634|
  00078		 |$LN9@TransBusAd|
  00078	e3a04001	 mov         r4, #1
  0007c		 |$cleanUp$42634|

; 163  :     }
; 164  : 
; 165  : cleanUp:
; 166  :     return rc;
; 167  : }

  0007c	e1a00004	 mov         r0, r4
  00080	e28dd010	 add         sp, sp, #0x10
  00084	e89d6030	 ldmia       sp, {r4, r5, sp, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M42742|

			 ENDP  ; |TransBusAddrToVirtual|

	EXPORT	|TransBusAddrToStatic|
	IMPORT	|CreateStaticMapping|

  00000			 AREA	 |.pdata|, PDATA
|$T42765| DCD	|$LN12@TransBusAd@2|
	DCD	0x40003404
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TransBusAddrToStatic| PROC

; 176  : ) {

  00000		 |$LN12@TransBusAd@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5070	 stmdb       sp!, {r4 - r6, r12, lr}
  0000c	e24dd010	 sub         sp, sp, #0x10
  00010		 |$M42762|

; 177  :     BOOL rc = FALSE;
; 178  :     PHYSICAL_ADDRESS phAddress;
; 179  :     UINT64 address;
; 180  :     UINT32 size;
; 181  : 
; 182  :     if (!HalTranslateBusAddress(
; 183  :         ifcType, busNumber, busAddress, pAddressSpace, &phAddress
; 184  :     )) goto cleanUp;

  00010	e59d4038	 ldr         r4, [sp, #0x38]
  00014	e28de008	 add         lr, sp, #8
  00018	e3a05000	 mov         r5, #0
  0001c	e58d4000	 str         r4, [sp]
  00020	e58de004	 str         lr, [sp, #4]
  00024	eb000000	 bl          HalTranslateBusAddress
  00028	e3500000	 cmp         r0, #0
  0002c	0a000023	 beq         |$cleanUp$42662|

; 185  : 
; 186  :     switch (*pAddressSpace) {

  00030	e5943000	 ldr         r3, [r4]
  00034	e3530000	 cmp         r3, #0
  00038	0a000005	 beq         |$LN3@TransBusAd@2|
  0003c	e3530001	 cmp         r3, #1
  00040	1a00001e	 bne         |$cleanUp$42662|

; 197  :         }
; 198  :         break;
; 199  :     case 1:        
; 200  :         // I/O port
; 201  :         *ppAddress = (VOID*)phAddress.LowPart;

  00044	e59d203c	 ldr         r2, [sp, #0x3C]
  00048	e59d3008	 ldr         r3, [sp, #8]

; 202  :         rc = TRUE;

  0004c	e5823000	 str         r3, [r2]

; 203  :         break;

  00050	ea000019	 b           |$LN9@TransBusAd@2|
  00054		 |$LN3@TransBusAd@2|

; 187  :     case 0:        
; 188  :         // Memory-mapped I/O, get statically-mapped virtual address
; 189  :         // for translated physical address
; 190  :         address = phAddress.QuadPart & ~(PAGE_SIZE - 1);

  00054	e3e03b0d	 mvn         r3, #0xD, 22
  00058	e22360fb	 eor         r6, r3, #0xFB
  0005c	e5961000	 ldr         r1, [r6]
  00060	e59d200c	 ldr         r2, [sp, #0xC]

; 191  :         size = length + (phAddress.LowPart & (PAGE_SIZE - 1));

  00064	e59d4034	 ldr         r4, [sp, #0x34]
  00068	e2413001	 sub         r3, r1, #1
  0006c	e1e0e003	 mvn         lr, r3
  00070	e0023fce	 and         r3, r2, lr, asr #31
  00074	e59d2008	 ldr         r2, [sp, #8]
  00078	e2410001	 sub         r0, r1, #1

; 192  :         *ppAddress = CreateStaticMapping((UINT32)(address >> 8), size);

  0007c	e1a01c03	 mov         r1, r3, lsl #24
  00080	e00e3002	 and         r3, lr, r2
  00084	e0002002	 and         r2, r0, r2
  00088	e1810423	 orr         r0, r1, r3, lsr #8
  0008c	e0821004	 add         r1, r2, r4
  00090	eb000000	 bl          CreateStaticMapping
  00094	e59d103c	 ldr         r1, [sp, #0x3C]
  00098	e3500000	 cmp         r0, #0
  0009c	e5810000	 str         r0, [r1]

; 193  :         if (*ppAddress != NULL) {

  000a0	0a000006	 beq         |$cleanUp$42662|

; 194  :             rc = TRUE;
; 195  :             // Adjust with offset from page
; 196  :             (UINT32)*ppAddress += phAddress.LowPart & (PAGE_SIZE - 1);

  000a4	e5963000	 ldr         r3, [r6]
  000a8	e59d2008	 ldr         r2, [sp, #8]
  000ac	e2433001	 sub         r3, r3, #1
  000b0	e0033002	 and         r3, r3, r2
  000b4	e0833000	 add         r3, r3, r0
  000b8	e5813000	 str         r3, [r1]
  000bc		 |$LN9@TransBusAd@2|
  000bc	e3a05001	 mov         r5, #1
  000c0		 |$cleanUp$42662|

; 204  :     }
; 205  : 
; 206  : cleanUp:
; 207  :     return rc;
; 208  : }

  000c0	e1a00005	 mov         r0, r5
  000c4	e28dd010	 add         sp, sp, #0x10
  000c8	e89d6070	 ldmia       sp, {r4 - r6, sp, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$M42763|

			 ENDP  ; |TransBusAddrToStatic|

	END
