; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\HDQ\hdq.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BE@DIEKGMHP@?$AAR?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@LMGJPBKK@?$AAT?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@KPFHKDCL@?$AAB?$AAr?$AAe?$AAa?$AAk?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|cliDelay1| [ DATA ]
	EXPORT	|cliDelay2| [ DATA ]
	EXPORT	|cliDelay2A| [ DATA ]
	EXPORT	|cliDelay3| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|DEVICE_IFC_HDQ_GUID|, 0x10


  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@DIEKGMHP@?$AAR?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "R"
	DCB	0x0, "x", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@LMGJPBKK@?$AAT?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "T"
	DCB	0x0, "x", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o"
	DCB	0x0, "u", 0x0, "t", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@KPFHKDCL@?$AAB?$AAr?$AAe?$AAa?$AAk?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "B"
	DCB	0x0, "r", 0x0, "e", 0x0, "a", 0x0, "k", 0x0, "T", 0x0, "i"
	DCB	0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| DCB "I", 0x0, "r", 0x0, "q", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@| DCB "M", 0x0, "e"
	DCB	0x0, "m", 0x0, "L", 0x0, "e", 0x0, "n", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "M", 0x0
	DCB	"e", 0x0, "m", 0x0, "B", 0x0, "a", 0x0, "s", 0x0, "e", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|cliDelay1| DCD	0x64
|cliDelay2| DCD	0x64
|cliDelay2A| DCD 0x64
|cliDelay3| DCD	0x64
|g_deviceRegParams| DCD |??_C@_1BA@INLDIDEN@?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1O@LBBNFMDB@?$AAM?$AAe?$AAm?$AAL?$AAe?$AAn?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x8
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0xc
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BK@KPFHKDCL@?$AAB?$AAr?$AAe?$AAa?$AAk?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BE@LMGJPBKK@?$AAT?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x5
	DCD	|??_C@_1BE@DIEKGMHP@?$AAR?$AAx?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18
	DCD	0x4
	DCD	0x5
	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43470| DCD	|$LN5@GetCurrent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43467|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43468|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\hdq\hdq.c

  00000			 AREA	 |.pdata|, PDATA
|$T43481| DCD	|$LN8@DllMain|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 210  : {

  00000		 |$LN8@DllMain|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43478|

; 211  :     switch (reason) {

  00004	e3510001	 cmp         r1, #1

; 212  :     case DLL_PROCESS_ATTACH:
; 213  :         DEBUGREGISTER(hDLL);
; 214  :         DisableThreadLibraryCalls((HMODULE)hDLL);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 215  :         break;
; 216  :     }
; 217  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 218  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M43479|

			 ENDP  ; |DllMain|

	EXPORT	|bDumpOmapHdqRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T43491| DCD	|$LN5@bDumpOmapH|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |bDumpOmapHdqRegs| PROC

; 380  : {

  00000		 |$LN5@bDumpOmapH|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43488|

; 381  :     DWORD dwReg=0;
; 382  :     DEBUGMSG(ZONE_INFO, (L"+++bDumpOmapHdqRegs()\r\n- - - - - - Hdq Registers - - - - - - - -\r\n"));
; 383  : 
; 384  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_REVISION);

  00004	e5903020	 ldr         r3, [r0, #0x20]

; 385  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_REVISION=%08lXh\r\n",dwReg));
; 386  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_TX_DATA);
; 387  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_TX_DATA=%08lXh\r\n",dwReg));
; 388  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_RX_DATA);
; 389  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_RX_DATA=%08lXh\r\n",dwReg));
; 390  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS);
; 391  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_CTRL_STATUS=%08lXh\r\n",dwReg));
; 392  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_INT_STATUS);
; 393  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_INT_STATUS=%08lXh\r\n",dwReg));
; 394  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_SYSCONFIG);
; 395  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_SYSCONFIG=%08lXh\r\n",dwReg));
; 396  :     dwReg=INREG32(&pDevice->pHDQRegs->ulHDQ_SYSSTATUS);
; 397  :     DEBUGMSG(ZONE_INFO, (L"\tHDQ_SYSSTATUS=%08lXh\r\n",dwReg));
; 398  : 
; 399  :     DEBUGMSG(ZONE_INFO, (L"---bDumpOmapHdqRegs()\r\n"));
; 400  :     return TRUE;

  00008	e3a00001	 mov         r0, #1
  0000c	e5935000	 ldr         r5, [r3]
  00010	e593e004	 ldr         lr, [r3, #4]
  00014	e5936008	 ldr         r6, [r3, #8]
  00018	e593400c	 ldr         r4, [r3, #0xC]
  0001c	e5931010	 ldr         r1, [r3, #0x10]
  00020	e5932014	 ldr         r2, [r3, #0x14]
  00024	e5933018	 ldr         r3, [r3, #0x18]

; 401  : }

  00028	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M43489|

			 ENDP  ; |bDumpOmapHdqRegs|

	EXPORT	|HDQ_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|CloseHandle|
	IMPORT	|KernelIoControl|
	IMPORT	|InterruptDisable|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|SetDevicePowerState|

  00000			 AREA	 |.pdata|, PDATA
|$T43502| DCD	|$LN12@HDQ_Deinit|
	DCD	0x40003c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Deinit| PROC

; 410  : {

  00000		 |$LN12@HDQ_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43499|
  00008	e1b04000	 movs        r4, r0

; 411  :     BOOL rc=FALSE;

  0000c	e3a00000	 mov         r0, #0

; 412  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 413  : 
; 414  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+HDQ_Deinit(0x%08x)\r\n", context));
; 415  : 
; 416  : // Check if we get correct context
; 417  :     if(pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE)

  00010	0a000031	 beq         |$cleanUp$43021|
  00014	e5942000	 ldr         r2, [r4]
  00018	e59f30cc	 ldr         r3, [pc, #0xCC]
  0001c	e1520003	 cmp         r2, r3
  00020	1a00002d	 bne         |$cleanUp$43021|

; 418  :     {
; 419  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Deinit: "
; 420  :             L"Incorrect context paramer\r\n"));
; 421  :         goto cleanUp;
; 422  :     };
; 423  : 
; 424  : // Disable and clear the interrupt
; 425  :     CLRREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_INTERRUPTMASK);

  00024	e5942020	 ldr         r2, [r4, #0x20]
  00028	e592300c	 ldr         r3, [r2, #0xC]
  0002c	e3c33040	 bic         r3, r3, #0x40
  00030	e582300c	 str         r3, [r2, #0xC]

; 426  :     INREG32(&pDevice->pHDQRegs->ulHDQ_INT_STATUS);

  00034	e5943020	 ldr         r3, [r4, #0x20]

; 427  : 
; 428  : // Set hardware to D4 and close parent bus driver
; 429  :     if(pDevice->hParentBus!=NULL)

  00038	e5942024	 ldr         r2, [r4, #0x24]
  0003c	e5933010	 ldr         r3, [r3, #0x10]
  00040	e1b00002	 movs        r0, r2
  00044	0a000004	 beq         |$LN5@HDQ_Deinit|

; 430  :     {
; 431  :         SetDevicePowerState(pDevice->hParentBus, D4, NULL);

  00048	e3a02000	 mov         r2, #0
  0004c	e3a01004	 mov         r1, #4
  00050	eb000000	 bl          SetDevicePowerState

; 432  :         CloseBusAccessHandle(pDevice->hParentBus);

  00054	e5940024	 ldr         r0, [r4, #0x24]
  00058	eb000000	 bl          CloseBusAccessHandle
  0005c		 |$LN5@HDQ_Deinit|

; 433  :     };
; 434  : 
; 435  : // Delete critical section
; 436  :     DeleteCriticalSection(&pDevice->cs);

  0005c	e284002c	 add         r0, r4, #0x2C
  00060	eb000000	 bl          DeleteCriticalSection

; 437  : 
; 438  : // Unmap PRCM controller registers
; 439  :     if(pDevice->pPRCMRegs!=NULL)

  00064	e594301c	 ldr         r3, [r4, #0x1C]
  00068	e3530000	 cmp         r3, #0

; 440  :     {
; 441  :         MmUnmapIoSpace((VOID*)pDevice->pPRCMRegs, sizeof(OMAP2420_PRCM_REGS));

  0006c	13a01c09	 movne       r1, #9, 24
  00070	11a00003	 movne       r0, r3
  00074	1b000000	 blne        MmUnmapIoSpace

; 442  :     };
; 443  : 
; 444  : // Unmap HDQ_1Wire controller registers
; 445  :     if(pDevice->pHDQRegs != NULL)

  00078	e5943020	 ldr         r3, [r4, #0x20]
  0007c	e3530000	 cmp         r3, #0

; 446  :     {
; 447  :         MmUnmapIoSpace((VOID*)pDevice->pHDQRegs, pDevice->memLen);

  00080	15941008	 ldrne       r1, [r4, #8]
  00084	11a00003	 movne       r0, r3
  00088	1b000000	 blne        MmUnmapIoSpace

; 448  :     };
; 449  : 
; 450  : // Release HDQ_1Wire controller interrupt
; 451  :     if(pDevice->sysIntr != 0)

  0008c	e5943040	 ldr         r3, [r4, #0x40]
  00090	e3530000	 cmp         r3, #0
  00094	0a000009	 beq         |$LN2@HDQ_Deinit|

; 452  :     {
; 453  :         InterruptDisable(pDevice->sysIntr);

  00098	e1a00003	 mov         r0, r3
  0009c	eb000000	 bl          InterruptDisable

; 454  :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, &pDevice->sysIntr,sizeof(pDevice->sysIntr), NULL, 0, NULL);

  000a0	e59f0040	 ldr         r0, [pc, #0x40]
  000a4	e3a0e000	 mov         lr, #0
  000a8	e3a03000	 mov         r3, #0
  000ac	e3a02004	 mov         r2, #4
  000b0	e2841040	 add         r1, r4, #0x40
  000b4	e58de004	 str         lr, [sp, #4]
  000b8	e58de000	 str         lr, [sp]
  000bc	eb000000	 bl          KernelIoControl
  000c0		 |$LN2@HDQ_Deinit|

; 455  :     };
; 456  : 
; 457  : // Close interrupt handler
; 458  :     if(pDevice->hIntrEvent!=NULL)

  000c0	e5943044	 ldr         r3, [r4, #0x44]
  000c4	e3530000	 cmp         r3, #0

; 459  :     {
; 460  :         CloseHandle(pDevice->hIntrEvent);

  000c8	11a00003	 movne       r0, r3
  000cc	1b000000	 blne        CloseHandle

; 461  :     };
; 462  : 
; 463  : // Free device structure
; 464  :     LocalFree(pDevice);

  000d0	e1a00004	 mov         r0, r4
  000d4	eb000000	 bl          LocalFree

; 465  : 
; 466  : // Done
; 467  :     rc=TRUE;

  000d8	e3a00001	 mov         r0, #1
  000dc		 |$cleanUp$43021|

; 468  : 
; 469  : cleanUp:
; 470  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_Deinit(rc = %d)\r\n", rc));
; 471  :     return rc;
; 472  : }

  000dc	e28dd008	 add         sp, sp, #8
  000e0	e8bd4010	 ldmia       sp!, {r4, lr}
  000e4	e12fff1e	 bx          lr
  000e8		 |$LN13@HDQ_Deinit|
  000e8		 |$LN14@HDQ_Deinit|
  000e8	010100d8	 DCD         0x10100d8
  000ec		 |$LN15@HDQ_Deinit|
  000ec	68647144	 DCD         0x68647144
  000f0		 |$M43500|

			 ENDP  ; |HDQ_Deinit|

	EXPORT	|HDQ_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T43515| DCD	|$LN7@HDQ_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Open| PROC

; 481  : {

  00000		 |$LN7@HDQ_Open|
  00000		 |$M43512|
  00000		 |$cleanUp$43062|

; 482  :     DWORD rc=(DWORD)-1;
; 483  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 484  : 
; 485  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+++HDQ_Open(0x%08x, 0x%08x, 0x%08x\r\n", context, accessCode, shareMode));
; 486  : 
; 487  : // Check if we get correct context
; 488  :     if(pDevice==NULL || pDevice->cookie!=HDQ_DEVICE_COOKIE)
; 489  :     {
; 490  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Open: "
; 491  :             L"Incorrect context paramer\r\n"));
; 492  :         goto cleanUp;
; 493  :     };
; 494  : 
; 495  : // Return device context
; 496  :     rc=context;
; 497  : 
; 498  : cleanUp:
; 499  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_Open()\r\n"));
; 500  :     return context;
; 501  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43513|

			 ENDP  ; |HDQ_Open|

	EXPORT	|HDQ_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T43526| DCD	|$LN7@HDQ_Close|
	DCD	0x40000900
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Close| PROC

; 510  : {

  00000		 |$LN7@HDQ_Close|
  00000		 |$M43523|
  00000	e1b03000	 movs        r3, r0

; 511  :     BOOL rc=FALSE;

  00004	e3a00000	 mov         r0, #0

; 512  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 513  : 
; 514  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+++HDQ_Close(0x%08x)\r\n", context));
; 515  : 
; 516  : // Check if we get correct context
; 517  :     if(pDevice==NULL || pDevice->cookie!=HDQ_DEVICE_COOKIE)

  00008	0a000003	 beq         |$cleanUp$43076|
  0000c	e5932000	 ldr         r2, [r3]
  00010	e59f3008	 ldr         r3, [pc, #8]
  00014	e1520003	 cmp         r2, r3

; 518  :     {
; 519  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Close: "
; 520  :             L"Incorrect context paramer\r\n"));
; 521  :         goto cleanUp;
; 522  :     };
; 523  : 
; 524  : // Done
; 525  :     rc=TRUE;

  00018	03a00001	 moveq       r0, #1
  0001c		 |$cleanUp$43076|

; 526  : 
; 527  : cleanUp:
; 528  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_Close(rc = %d)\r\n", rc));
; 529  :     return rc;
; 530  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$LN8@HDQ_Close|
  00020		 |$LN9@HDQ_Close|
  00020	68647144	 DCD         0x68647144
  00024		 |$M43524|

			 ENDP  ; |HDQ_Close|

	EXPORT	|HDQ_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T43536| DCD	|$LN5@HDQ_PowerU|
	DCD	0x40002802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_PowerUp| PROC

; 615  : {

  00000		 |$LN5@HDQ_PowerU|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43533|
  00008	e1a04000	 mov         r4, r0

; 616  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 617  :     DWORD dwRegValue=0;
; 618  :     DWORD cbRet=0;
; 619  : // enable the HDQ clocks
; 620  : #if 0
; 621  :     SETREG32(&pDevice->pPRCMRegs->ulCM_FCLKEN1_CORE, PRCM_FCLKEN1_CORE_EN_HDQ);
; 622  :     SETREG32(&pDevice->pPRCMRegs->ulCM_ICLKEN1_CORE, PRCM_ICLKEN1_CORE_EN_HDQ);
; 623  : #else
; 624  : // Enable the 1WIRE functional and interface clocks.
; 625  :     dwRegValue=PRCM_FCLKEN1_CORE_EN_HDQ;
; 626  :     KernelIoControl(IOCTL_FCLK1_ENB, (VOID*)&dwRegValue, sizeof(DWORD), NULL, 0, &cbRet);

  0000c	e59f0088	 ldr         r0, [pc, #0x88]
  00010	e3a05000	 mov         r5, #0
  00014	e3a06502	 mov         r6, #2, 10
  00018	e28de00c	 add         lr, sp, #0xC
  0001c	e3a07000	 mov         r7, #0
  00020	e3a03000	 mov         r3, #0
  00024	e3a02004	 mov         r2, #4
  00028	e28d1008	 add         r1, sp, #8
  0002c	e58d500c	 str         r5, [sp, #0xC]
  00030	e58d6008	 str         r6, [sp, #8]
  00034	e58de004	 str         lr, [sp, #4]
  00038	e58d7000	 str         r7, [sp]
  0003c	eb000000	 bl          KernelIoControl

; 627  : 
; 628  :     dwRegValue=PRCM_ICLKEN1_CORE_EN_HDQ;
; 629  :     KernelIoControl(IOCTL_ICLK1_ENB, (VOID*)&dwRegValue, sizeof(DWORD), NULL, 0, &cbRet);

  00040	e59f0050	 ldr         r0, [pc, #0x50]
  00044	e28de00c	 add         lr, sp, #0xC
  00048	e3a05502	 mov         r5, #2, 10
  0004c	e3a03000	 mov         r3, #0
  00050	e3a02004	 mov         r2, #4
  00054	e28d1008	 add         r1, sp, #8
  00058	e58de004	 str         lr, [sp, #4]
  0005c	e58d5008	 str         r5, [sp, #8]
  00060	e58d7000	 str         r7, [sp]
  00064	eb000000	 bl          KernelIoControl

; 630  : #endif
; 631  : // enable the HDQ
; 632  :     SETREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_CLOCKENABLE);

  00068	e5942020	 ldr         r2, [r4, #0x20]
  0006c	e592300c	 ldr         r3, [r2, #0xC]
  00070	e3833020	 orr         r3, r3, #0x20
  00074	e582300c	 str         r3, [r2, #0xC]

; 633  : 
; 634  : // clear and enable interrupts
; 635  :     INREG32(&pDevice->pHDQRegs->ulHDQ_INT_STATUS);

  00078	e5941020	 ldr         r1, [r4, #0x20]
  0007c	e5912010	 ldr         r2, [r1, #0x10]

; 636  :     SETREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_INTERRUPTMASK);

  00080	e591300c	 ldr         r3, [r1, #0xC]
  00084	e3833040	 orr         r3, r3, #0x40
  00088	e581300c	 str         r3, [r1, #0xC]

; 637  : }

  0008c	e28dd010	 add         sp, sp, #0x10
  00090	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$LN6@HDQ_PowerU|
  00098		 |$LN7@HDQ_PowerU|
  00098	0022040c	 DCD         0x22040c
  0009c		 |$LN8@HDQ_PowerU|
  0009c	0022041c	 DCD         0x22041c
  000a0		 |$M43534|

			 ENDP  ; |HDQ_PowerUp|

	EXPORT	|HDQ_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T43547| DCD	|$LN5@HDQ_PowerD|
	DCD	0x40002802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_PowerDown| PROC

; 646  : {

  00000		 |$LN5@HDQ_PowerD|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43544|

; 647  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 648  :     DWORD dwRegValue=0;
; 649  :     DWORD cbRet=0;
; 650  : 
; 651  : // disable and clear interrupts
; 652  :     CLRREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_INTERRUPTMASK);

  00008	e5902020	 ldr         r2, [r0, #0x20]
  0000c	e3a03000	 mov         r3, #0
  00010	e3a01000	 mov         r1, #0
  00014	e58d3008	 str         r3, [sp, #8]
  00018	e58d100c	 str         r1, [sp, #0xC]
  0001c	e592300c	 ldr         r3, [r2, #0xC]

; 653  :     INREG32(&pDevice->pHDQRegs->ulHDQ_INT_STATUS);
; 654  : 
; 655  : // disable the HDQ
; 656  :     CLRREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_CLOCKENABLE);
; 657  : 
; 658  : // disable the HDQ clocks
; 659  : #if 0
; 660  :     CLRREG32(&pDevice->pPRCMRegs->ulCM_FCLKEN1_CORE, PRCM_FCLKEN1_CORE_EN_HDQ);
; 661  :     CLRREG32(&pDevice->pPRCMRegs->ulCM_ICLKEN1_CORE, PRCM_ICLKEN1_CORE_EN_HDQ); 
; 662  : #else
; 663  : // Disable the 1WIRE functional and interface clocks.
; 664  :     dwRegValue=PRCM_FCLKEN1_CORE_EN_HDQ;

  00020	e3a01502	 mov         r1, #2, 10
  00024	e3a06822	 mov         r6, #0x22, 16
  00028	e3c33040	 bic         r3, r3, #0x40
  0002c	e582300c	 str         r3, [r2, #0xC]
  00030	e5902020	 ldr         r2, [r0, #0x20]

; 665  :     KernelIoControl(IOCTL_FCLK1_DIS, (VOID*)&dwRegValue, sizeof(DWORD), NULL, 0, &cbRet);

  00034	e28de00c	 add         lr, sp, #0xC
  00038	e3a05000	 mov         r5, #0
  0003c	e5924010	 ldr         r4, [r2, #0x10]
  00040	e592300c	 ldr         r3, [r2, #0xC]
  00044	e3860e42	 orr         r0, r6, #0x42, 28
  00048	e58de004	 str         lr, [sp, #4]
  0004c	e3c33020	 bic         r3, r3, #0x20
  00050	e582300c	 str         r3, [r2, #0xC]
  00054	e58d1008	 str         r1, [sp, #8]
  00058	e28d1008	 add         r1, sp, #8
  0005c	e3a03000	 mov         r3, #0
  00060	e3a02004	 mov         r2, #4
  00064	e58d5000	 str         r5, [sp]
  00068	eb000000	 bl          KernelIoControl

; 666  : 
; 667  :     dwRegValue=PRCM_ICLKEN1_CORE_EN_HDQ;

  0006c	e3a02502	 mov         r2, #2, 10

; 668  :     KernelIoControl(IOCTL_ICLK1_DIS, (VOID*)&dwRegValue, sizeof(DWORD), NULL, 0, &cbRet);

  00070	e28d300c	 add         r3, sp, #0xC
  00074	e58d2008	 str         r2, [sp, #8]
  00078	e58d3004	 str         r3, [sp, #4]
  0007c	e3a03000	 mov         r3, #0
  00080	e3a02004	 mov         r2, #4
  00084	e28d1008	 add         r1, sp, #8
  00088	e3860e41	 orr         r0, r6, #0x41, 28
  0008c	e58d5000	 str         r5, [sp]
  00090	eb000000	 bl          KernelIoControl

; 669  : #endif
; 670  :     return;
; 671  : }

  00094	e28dd010	 add         sp, sp, #0x10
  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M43545|

			 ENDP  ; |HDQ_PowerDown|

	EXPORT	|HDQ_Write|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|WaitForSingleObject|
	IMPORT	|InterruptDone|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43569| DCD	|$LN22@HDQ_Write|
	DCD	0x40005e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Write| PROC

; 680  : {

  00000		 |$LN22@HDQ_Write|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43566|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1b05000	 movs        r5, r0

; 681  :     BOOL rc=FALSE;

  00014	e3a09000	 mov         r9, #0

; 682  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 683  :     OMAP2420_HDQ_REGS* pHDQRegs;
; 684  :     DWORD status, i, count;
; 685  :     UCHAR buffer[3];
; 686  : 
; 687  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+++HDQ_Write(0x%08x, 0x%02x, 0x%x)\r\n", context, address, data));
; 688  : 
; 689  : // Check if we get correct context
; 690  :     if(pDevice==NULL || pDevice->cookie!=HDQ_DEVICE_COOKIE)

  00018	0a000051	 beq         |$exit$43202|
  0001c	e595e000	 ldr         lr, [r5]
  00020	e59f314c	 ldr         r3, [pc, #0x14C]
  00024	e15e0003	 cmp         lr, r3
  00028	1a00004d	 bne         |$exit$43202|

; 691  :     {
; 692  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_Write: "
; 693  :             L"Incorrect context parameter\r\n"));
; 694  :         goto exit;
; 695  :     };
; 696  : 
; 697  : // Get hardware
; 698  :     pHDQRegs=pDevice->pHDQRegs;
; 699  :     EnterCriticalSection(&pDevice->cs);

  0002c	e5958020	 ldr         r8, [r5, #0x20]
  00030	e285002c	 add         r0, r5, #0x2C
  00034	eb000000	 bl          EnterCriticalSection

; 700  : 
; 701  : // Make sure that clock is present
; 702  :     SetDevicePowerState(pDevice->hParentBus, D0, NULL);

  00038	e5950024	 ldr         r0, [r5, #0x24]
  0003c	e3a02000	 mov         r2, #0
  00040	e3a01000	 mov         r1, #0
  00044	eb000000	 bl          SetDevicePowerState

; 703  :     HDQ_PowerUp(context);

  00048	e1a00005	 mov         r0, r5
  0004c	eb000000	 bl          HDQ_PowerUp

; 704  : 
; 705  : // Clear the interrupt
; 706  :     status=INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 707  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Write: "
; 708  :         L"Interrupt status (1) was 0x%02x\r\n", status));
; 709  : 
; 710  : // Need to notify InterruptDone right away
; 711  :     InterruptDone(pDevice->sysIntr);

  00050	e5950040	 ldr         r0, [r5, #0x40]
  00054	e5983010	 ldr         r3, [r8, #0x10]
  00058	eb000000	 bl          InterruptDone

; 712  : 
; 713  : // Send initialization pulse in 1-wire mode
; 714  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);

  0005c	e598300c	 ldr         r3, [r8, #0xC]
  00060	e3833001	 orr         r3, r3, #1
  00064	e588300c	 str         r3, [r8, #0xC]

; 715  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_INITIALIZATION);

  00068	e598300c	 ldr         r3, [r8, #0xC]
  0006c	e3833004	 orr         r3, r3, #4
  00070	e588300c	 str         r3, [r8, #0xC]

; 716  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_GO);

  00074	e598300c	 ldr         r3, [r8, #0xC]
  00078	e3833010	 orr         r3, r3, #0x10
  0007c	e588300c	 str         r3, [r8, #0xC]

; 717  : 
; 718  : // Wait on completion interrupt (not documented)
; 719  :     if(WaitForSingleObject(pDevice->hIntrEvent, pDevice->breakTimeout) == WAIT_TIMEOUT)

  00080	e5951010	 ldr         r1, [r5, #0x10]
  00084	e5950044	 ldr         r0, [r5, #0x44]
  00088	eb000000	 bl          WaitForSingleObject

; 720  :     {
; 721  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_Write: "
; 722  :             L"Timeout in init pulse\r\n"));
; 723  :     }
; 724  : 
; 725  : // Clear the interrupt
; 726  :     status=INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 727  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Write: "
; 728  :         L"Interrupt status (2) was 0x%02x\r\n", status));
; 729  : 
; 730  : // Need to notify InterruptDone right away
; 731  :     InterruptDone(pDevice->sysIntr);

  0008c	e5950040	 ldr         r0, [r5, #0x40]
  00090	e5983010	 ldr         r3, [r8, #0x10]
  00094	eb000000	 bl          InterruptDone

; 732  : 
; 733  : // Back to HDQ mode.
; 734  :     CLRREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);

  00098	e598300c	 ldr         r3, [r8, #0xC]

; 735  : 
; 736  : // We are going to do a write so set write bit in the address
; 737  :     buffer[0]=address|0x80;

  0009c	e3862080	 orr         r2, r6, #0x80

; 738  :     buffer[1]=(UCHAR)data;
; 739  :     switch(pDevice->mode)

  000a0	e5cd2000	 strb        r2, [sp]
  000a4	e3c33001	 bic         r3, r3, #1
  000a8	e588300c	 str         r3, [r8, #0xC]
  000ac	e5953048	 ldr         r3, [r5, #0x48]
  000b0	e5cd4001	 strb        r4, [sp, #1]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000006	 beq         |$LN7@HDQ_Write|
  000bc	e3530001	 cmp         r3, #1

; 743  :         break;
; 744  :     case HDQ_MODE_HDQ16:
; 745  :         buffer[2]=(UCHAR)(data >> 8);

  000c0	01a03424	 moveq       r3, r4, lsr #8
  000c4	05cd3002	 streqb      r3, [sp, #2]

; 746  :         count=3;

  000c8	03a06003	 moveq       r6, #3
  000cc	0a000002	 beq         |$LN8@HDQ_Write|

; 740  :     {
; 741  :     case HDQ_MODE_HDQ8:
; 742  :         count=2;

  000d0	e59d6000	 ldr         r6, [sp]
  000d4	ea000000	 b           |$LN8@HDQ_Write|
  000d8		 |$LN7@HDQ_Write|
  000d8	e3a06002	 mov         r6, #2
  000dc		 |$LN8@HDQ_Write|

; 747  :         break;
; 748  :     }
; 749  : // Two write cycles required
; 750  :     for(i=0; i < count; i++)

  000dc	e3a07000	 mov         r7, #0
  000e0	e3560000	 cmp         r6, #0
  000e4	0a000017	 beq         |$LN3@HDQ_Write|
  000e8	e3a03c01	 mov         r3, #1, 24
  000ec	e383a002	 orr         r10, r3, #2
  000f0	e28db000	 add         r11, sp, #0
  000f4		 |$LL5@HDQ_Write|

; 751  :     {
; 752  : // Write the value, set the direction and go
; 753  :         OUTREG32(&pHDQRegs->ulHDQ_TX_DATA, buffer[i]);

  000f4	e7d7300b	 ldrb        r3, [r7, +r11]
  000f8	e5883004	 str         r3, [r8, #4]

; 754  :         SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_DIR); //sr

  000fc	e598300c	 ldr         r3, [r8, #0xC]
  00100	e3833002	 orr         r3, r3, #2
  00104	e588300c	 str         r3, [r8, #0xC]

; 755  :         SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_GO);

  00108	e598300c	 ldr         r3, [r8, #0xC]
  0010c	e3833010	 orr         r3, r3, #0x10
  00110	e588300c	 str         r3, [r8, #0xC]

; 756  : 
; 757  : // Wait on TX complete interrupt.
; 758  :         if (WaitForSingleObject(pDevice->hIntrEvent, pDevice->txTimeout)==WAIT_TIMEOUT)

  00114	e5951014	 ldr         r1, [r5, #0x14]
  00118	e5950044	 ldr         r0, [r5, #0x44]
  0011c	eb000000	 bl          WaitForSingleObject
  00120	e150000a	 cmp         r0, r10
  00124	0a000008	 beq         |$cleanUp$43258|

; 759  :         {
; 760  :             DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_Write: "
; 761  :                 L"Timeout in Tx\r\n"));
; 762  :             goto cleanUp;
; 763  :         }
; 764  : 
; 765  : // Clear the interrupt
; 766  :         status=INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 767  :         InterruptDone(pDevice->sysIntr);

  00128	e5950040	 ldr         r0, [r5, #0x40]
  0012c	e5984010	 ldr         r4, [r8, #0x10]
  00130	eb000000	 bl          InterruptDone

; 768  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Write: "
; 769  :             L"Interrupt status (%d) was 0x%x\r\n", 3 + i, status));
; 770  : 
; 771  : // Verify interrupt source
; 772  :         if((status & HDQ_INT_STATUS_TXCOMPLETE)==0)

  00134	e3140004	 tst         r4, #4
  00138	0a000003	 beq         |$cleanUp$43258|
  0013c	e2877001	 add         r7, r7, #1
  00140	e1570006	 cmp         r7, r6
  00144	3affffea	 bcc         |$LL5@HDQ_Write|
  00148		 |$LN3@HDQ_Write|

; 773  :         {
; 774  :             DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_Write: "
; 775  :                 L"TX complete expected (0x%x)\r\n", status));
; 776  :             goto cleanUp;
; 777  :         }
; 778  :     };
; 779  : 
; 780  : // Done
; 781  :     rc=TRUE;

  00148	e3a09001	 mov         r9, #1
  0014c		 |$cleanUp$43258|

; 782  : 
; 783  : cleanUp:
; 784  :     SetDevicePowerState(pDevice->hParentBus, D4, NULL);

  0014c	e5950024	 ldr         r0, [r5, #0x24]
  00150	e3a02000	 mov         r2, #0
  00154	e3a01004	 mov         r1, #4
  00158	eb000000	 bl          SetDevicePowerState

; 785  :     LeaveCriticalSection(&pDevice->cs);

  0015c	e285002c	 add         r0, r5, #0x2C
  00160	eb000000	 bl          LeaveCriticalSection
  00164		 |$exit$43202|

; 786  : 
; 787  : exit:    
; 788  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_Write(rc = %d)\r\n", rc));
; 789  :     return rc;
; 790  : }

  00164	e1a00009	 mov         r0, r9
  00168	e28dd004	 add         sp, sp, #4
  0016c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$LN23@HDQ_Write|
  00174		 |$LN24@HDQ_Write|
  00174	68647144	 DCD         0x68647144
  00178		 |$M43567|

			 ENDP  ; |HDQ_Write|

	EXPORT	|HDQ_Read|
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T43591| DCD	|$LN28@HDQ_Read|
	DCD	0x40007102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Read| PROC

; 799  : {

  00000		 |$LN28@HDQ_Read|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43588|
  00008	e1a09002	 mov         r9, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 800  :     BOOL rc=FALSE;
; 801  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 802  :     OMAP2420_HDQ_REGS* pHDQRegs=NULL;
; 803  :     DWORD status, count, i;
; 804  :     UCHAR buffer[2];
; 805  : //
; 806  : 
; 807  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+++HDQ_Read(0x%08x, 0x%02x, 0x%08x)\r\n", context, address, pData));
; 808  : 
; 809  :     Sleep(cliDelay1); // tentaive

  00014	e3a00064	 mov         r0, #0x64
  00018	e3a08000	 mov         r8, #0
  0001c	eb000000	 bl          Sleep

; 810  : // Check if we get correct context
; 811  :     if(pDevice==NULL || pDevice->cookie!=HDQ_DEVICE_COOKIE)

  00020	e3540000	 cmp         r4, #0
  00024	0a000061	 beq         |$exit$43287|
  00028	e594e000	 ldr         lr, [r4]
  0002c	e59f318c	 ldr         r3, [pc, #0x18C]
  00030	e15e0003	 cmp         lr, r3
  00034	1a00005d	 bne         |$exit$43287|

; 812  :     {
; 813  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_Read: "
; 814  :             L"Incorrect context parameter\r\n"));
; 815  :         goto exit;
; 816  :     }
; 817  : 
; 818  : // Get hardware
; 819  :     pHDQRegs=pDevice->pHDQRegs;
; 820  :     EnterCriticalSection(&pDevice->cs);

  00038	e5945020	 ldr         r5, [r4, #0x20]
  0003c	e284002c	 add         r0, r4, #0x2C
  00040	eb000000	 bl          EnterCriticalSection

; 821  : 
; 822  : // Make sure that clock is present
; 823  :     SetDevicePowerState(pDevice->hParentBus, D0, NULL);

  00044	e5940024	 ldr         r0, [r4, #0x24]
  00048	e3a02000	 mov         r2, #0
  0004c	e3a01000	 mov         r1, #0
  00050	eb000000	 bl          SetDevicePowerState

; 824  :     HDQ_PowerUp(context);

  00054	e1a00004	 mov         r0, r4
  00058	eb000000	 bl          HDQ_PowerUp

; 825  : 
; 826  :     switch(pDevice->mode)

  0005c	e5943048	 ldr         r3, [r4, #0x48]
  00060	e3530000	 cmp         r3, #0
  00064	0a000004	 beq         |$LN15@HDQ_Read|
  00068	e3530001	 cmp         r3, #1

; 830  :         break;
; 831  :     case HDQ_MODE_HDQ16:
; 832  :         count=2;

  0006c	03a06002	 moveq       r6, #2
  00070	0a000002	 beq         |$LN16@HDQ_Read|

; 827  :     {
; 828  :     case HDQ_MODE_HDQ8:
; 829  :         count=1;

  00074	e59d6000	 ldr         r6, [sp]
  00078	ea000000	 b           |$LN16@HDQ_Read|
  0007c		 |$LN15@HDQ_Read|
  0007c	e3a06001	 mov         r6, #1
  00080		 |$LN16@HDQ_Read|

; 833  :         break;
; 834  :     };
; 835  : 
; 836  : // Clear the interrupt.
; 837  :     status=INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 838  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Read: "
; 839  :         L"Interrupt status (1) was 0x%02x\r\n", status));
; 840  : 
; 841  : // Need to notify InterruptDone right away
; 842  :     InterruptDone(pDevice->sysIntr);

  00080	e5940040	 ldr         r0, [r4, #0x40]
  00084	e5953010	 ldr         r3, [r5, #0x10]
  00088	eb000000	 bl          InterruptDone

; 843  : // Step 0: send break pulse
; 844  : // get into status mode; Send break pulse in HDQ mode
; 845  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);

  0008c	e595300c	 ldr         r3, [r5, #0xC]

; 846  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_INITIALIZATION);
; 847  : //    DEBUGMSG(ZONE_HDQ_1WIRE, (L"\tHDQ_Read: 1) Will Send out the break pulse and wait for %ld msec.\r\n",pDevice->breakTimeout));
; 848  : //    DEBUGMSG(ZONE_HDQ_1WIRE, (L"\tHDQ_Read: 2) Next switch to Write mode, send out register Nr and wait for %ld msec.\r\n",pDevice->txTimeout));
; 849  : //    DEBUGMSG(ZONE_HDQ_1WIRE, (L"\tHDQ_Read: 3) Then switch to Read mode and wait for %ld msec.\r\n",pDevice->rxTimeout));
; 850  : // switch to go mode
; 851  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_GO);
; 852  : 
; 853  : // Wait for completion of break pulse to be sent out
; 854  : // there are no interrupts set on break pulse, so just wait for it to be sent out
; 855  :     Sleep(cliDelay2); // was Sleep(pDevice->breakTimeout);  0.32 msec or so

  00090	e3a00064	 mov         r0, #0x64
  00094	e3833001	 orr         r3, r3, #1
  00098	e585300c	 str         r3, [r5, #0xC]
  0009c	e595300c	 ldr         r3, [r5, #0xC]
  000a0	e3833004	 orr         r3, r3, #4
  000a4	e585300c	 str         r3, [r5, #0xC]
  000a8	e595300c	 ldr         r3, [r5, #0xC]
  000ac	e3833010	 orr         r3, r3, #0x10
  000b0	e585300c	 str         r3, [r5, #0xC]
  000b4	eb000000	 bl          Sleep

; 856  : // Back to HDQ mode.
; 857  :     CLRREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);

  000b8	e595300c	 ldr         r3, [r5, #0xC]

; 858  : // Step 1:
; 859  : // Write the value, 
; 860  :     OUTREG32(&pHDQRegs->ulHDQ_TX_DATA, address); // 

  000bc	e3c33001	 bic         r3, r3, #1
  000c0	e585300c	 str         r3, [r5, #0xC]
  000c4	e5857004	 str         r7, [r5, #4]

; 861  : // Step 2: set the direction as Write and go
; 862  :     CLRREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_DIR); // was SET

  000c8	e595300c	 ldr         r3, [r5, #0xC]
  000cc	e3c33002	 bic         r3, r3, #2
  000d0	e585300c	 str         r3, [r5, #0xC]

; 863  :     SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_GO);

  000d4	e595300c	 ldr         r3, [r5, #0xC]
  000d8	e3833010	 orr         r3, r3, #0x10
  000dc	e585300c	 str         r3, [r5, #0xC]

; 864  : //
; 865  : // Wait on completion on transmit data 
; 866  :     if(WaitForSingleObject(pDevice->hIntrEvent, pDevice->txTimeout)==WAIT_TIMEOUT)

  000e0	e5941014	 ldr         r1, [r4, #0x14]
  000e4	e5940044	 ldr         r0, [r4, #0x44]
  000e8	eb000000	 bl          WaitForSingleObject

; 867  :     {
; 868  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"ERROR !! HDQ_Read(): "
; 869  :             L"Timeout in TX for %ld msec.\r\n",pDevice->txTimeout));
; 870  : //      goto cleanUp;
; 871  :     }
; 872  : 
; 873  : // Clear interrupt
; 874  :     status=INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 875  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Read: "
; 876  :         L"Interrupt status (3) was 0x%02x\r\n", status));
; 877  : 
; 878  : // Need to notify InterruptDone right away
; 879  :     InterruptDone(pDevice->sysIntr);

  000ec	e5940040	 ldr         r0, [r4, #0x40]
  000f0	e5953010	 ldr         r3, [r5, #0x10]
  000f4	eb000000	 bl          InterruptDone

; 880  : 
; 881  : // Verify that register address was sent out completely.
; 882  :     if((status & HDQ_INT_STATUS_TXCOMPLETE)==0)
; 883  :     { // sr further timing adjustment may be helpful. It works with current settings well so disregard this msg
; 884  :         DEBUGMSG(ZONE_HDQ_1WIRE, (L"ERROR: HDQ_Read: "
; 885  :             L"TX complete expected (0x%02x)\r\n", status));
; 886  : //        goto cleanUp;
; 887  :     }
; 888  :     else
; 889  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"\tHDQ_Read: "
; 890  :         L"TX completed (0x%02x) ok.\r\n", status));
; 891  : // pre-Step 3:
; 892  :     status=0; // INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 893  : 
; 894  :     for(i=0; i<count; i++)

  000f8	e3a07000	 mov         r7, #0
  000fc	e3560000	 cmp         r6, #0
  00100	0a000017	 beq         |$LN8@HDQ_Read|
  00104	e3a03c01	 mov         r3, #1, 24
  00108	e383b002	 orr         r11, r3, #2
  0010c	e28da000	 add         r10, sp, #0
  00110		 |$LL10@HDQ_Read|

; 895  :     {
; 896  : // The RX is slave driven, if we are slow byte can be already done.
; 897  :         if((status & HDQ_INT_STATUS_RXCOMPLETE)==0)
; 898  :         {
; 899  : // Indicate read & go: 0 to Read bit, 1 to GO bit
; 900  : // Step 3:
; 901  :             SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_DIR); // was CLR

  00110	e595300c	 ldr         r3, [r5, #0xC]

; 902  :             SETREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_GO);
; 903  :             Sleep(cliDelay3);

  00114	e3a00064	 mov         r0, #0x64
  00118	e3833002	 orr         r3, r3, #2
  0011c	e585300c	 str         r3, [r5, #0xC]
  00120	e595300c	 ldr         r3, [r5, #0xC]
  00124	e3833010	 orr         r3, r3, #0x10
  00128	e585300c	 str         r3, [r5, #0xC]
  0012c	eb000000	 bl          Sleep

; 904  : // Wait on RX complete interrupt
; 905  :             if(WaitForSingleObject(pDevice->hIntrEvent, pDevice->rxTimeout)==WAIT_TIMEOUT)

  00130	e5941018	 ldr         r1, [r4, #0x18]
  00134	e5940044	 ldr         r0, [r4, #0x44]
  00138	eb000000	 bl          WaitForSingleObject
  0013c	e150000b	 cmp         r0, r11
  00140	0a000014	 beq         |$cleanUp$43356|

; 906  :             {
; 907  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Read: "
; 908  :                     L"Timeout on RX at %ld msec\r\n",pDevice->rxTimeout));
; 909  :                 goto cleanUp;
; 910  :             }
; 911  : // Clear interrupt
; 912  :             status=INREG32(&pHDQRegs->ulHDQ_INT_STATUS);
; 913  :             DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Read: "
; 914  :                 L"Interrupt status (5) was 0x%02x\r\n", status));
; 915  : 
; 916  : // Reenable interrupt
; 917  :             InterruptDone(pDevice->sysIntr);

  00144	e5940040	 ldr         r0, [r4, #0x40]
  00148	e5953010	 ldr         r3, [r5, #0x10]
  0014c	eb000000	 bl          InterruptDone

; 918  :         }
; 919  : 
; 920  : // Verify interrupt source
; 921  :         if((status & HDQ_INT_STATUS_RXCOMPLETE)==0)
; 922  :         {
; 923  :             DEBUGMSG(ZONE_HDQ_1WIRE, (L"ERROR: HDQ_Read: "
; 924  :                 L"RX complete expected (0x%02x)\r\n", status));
; 925  : //            goto cleanUp;
; 926  :         }
; 927  : // Get data
; 928  :         buffer[i]=(UCHAR)INREG32(&pHDQRegs->ulHDQ_RX_DATA);

  00150	e5953008	 ldr         r3, [r5, #8]
  00154	e7c7300a	 strb        r3, [r7, +r10]
  00158	e2877001	 add         r7, r7, #1
  0015c	e1570006	 cmp         r7, r6
  00160	3affffea	 bcc         |$LL10@HDQ_Read|
  00164		 |$LN8@HDQ_Read|

; 929  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"\tHDQ_Read: "
; 930  :             L"RX completed data=0x%02x\r\n", buffer[i]));
; 931  : // Make sure we set GO bit on next byte
; 932  :         status=0;
; 933  :     };
; 934  : 
; 935  :     switch (pDevice->mode)

  00164	e5943048	 ldr         r3, [r4, #0x48]
  00168	e3530000	 cmp         r3, #0
  0016c	0a000006	 beq         |$LN2@HDQ_Read|
  00170	e3530001	 cmp         r3, #1
  00174	1a000006	 bne         |$LN3@HDQ_Read|

; 939  :         break;
; 940  :     case HDQ_MODE_HDQ16:
; 941  :         *pData=buffer[0]|(buffer[1] << 8);

  00178	e5dd2001	 ldrb        r2, [sp, #1]
  0017c	e5dd3000	 ldrb        r3, [sp]
  00180	e1833402	 orr         r3, r3, r2, lsl #8
  00184	e1c930b0	 strh        r3, [r9]

; 942  :         break;

  00188	ea000001	 b           |$LN3@HDQ_Read|
  0018c		 |$LN2@HDQ_Read|

; 936  :     {
; 937  :     case HDQ_MODE_HDQ8:
; 938  :         *pData=buffer[0];

  0018c	e5dd3000	 ldrb        r3, [sp]
  00190	e1c930b0	 strh        r3, [r9]
  00194		 |$LN3@HDQ_Read|

; 943  :     }
; 944  : 
; 945  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_Read: "
; 946  :         L"Address:=0x%02x, Data:=0x%02x\r\n", address, *pData));
; 947  : 
; 948  : // Done
; 949  :     rc=TRUE;

  00194	e3a08001	 mov         r8, #1
  00198		 |$cleanUp$43356|

; 950  : //
; 951  : cleanUp:
; 952  :     SetDevicePowerState(pDevice->hParentBus, D4, NULL); // power off the hdq device

  00198	e5940024	 ldr         r0, [r4, #0x24]
  0019c	e3a02000	 mov         r2, #0
  001a0	e3a01004	 mov         r1, #4
  001a4	eb000000	 bl          SetDevicePowerState

; 953  :     LeaveCriticalSection(&pDevice->cs);

  001a8	e284002c	 add         r0, r4, #0x2C
  001ac	eb000000	 bl          LeaveCriticalSection
  001b0		 |$exit$43287|

; 954  : //
; 955  : exit:    
; 956  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_Read(rc=%01ld)\r\n", rc));
; 957  :     return rc;
; 958  : }

  001b0	e1a00008	 mov         r0, r8
  001b4	e28dd004	 add         sp, sp, #4
  001b8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001bc	e12fff1e	 bx          lr
  001c0		 |$LN29@HDQ_Read|
  001c0		 |$LN30@HDQ_Read|
  001c0	68647144	 DCD         0x68647144
  001c4		 |$M43589|

			 ENDP  ; |HDQ_Read|

	EXPORT	|HDQ_SetMode|

  00000			 AREA	 |.pdata|, PDATA
|$T43607| DCD	|$LN13@HDQ_SetMod|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_SetMode| PROC

; 965  : {

  00000		 |$LN13@HDQ_SetMod|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43604|
  00004	e3500000	 cmp         r0, #0

; 966  :     BOOL rc = FALSE;

  00008	e3a0e000	 mov         lr, #0

; 967  :     HDQ_DEVICE *pDevice = (HDQ_DEVICE*)context;
; 968  :     OMAP2420_HDQ_REGS *pHDQRegs;
; 969  : 
; 970  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+HDQ_SetMode(0x%08x, %d)\r\n", context, mode));
; 971  : 
; 972  : // Check if we get correct context
; 973  :     if (pDevice == NULL || pDevice->cookie != HDQ_DEVICE_COOKIE)

  0000c	0a000010	 beq         |$cleanUp$43389|
  00010	e5902000	 ldr         r2, [r0]
  00014	e59f3044	 ldr         r3, [pc, #0x44]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00000c	 bne         |$cleanUp$43389|

; 974  :     {
; 975  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_SetMode: "
; 976  :             L"Incorrect context paramer\r\n"));
; 977  :         goto cleanUp;
; 978  :     };
; 979  :     pHDQRegs = pDevice->pHDQRegs;

  00020	e5902020	 ldr         r2, [r0, #0x20]

; 980  : 
; 981  :     switch (mode)

  00024	e3510000	 cmp         r1, #0
  00028	0a000003	 beq         |$LN3@HDQ_SetMod|
  0002c	e3510001	 cmp         r1, #1
  00030	1a000007	 bne         |$cleanUp$43389|

; 989  :         break;
; 990  :     case HDQ_MODE_HDQ16:
; 991  :         CLRREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);
; 992  :         pDevice->mode = HDQ_MODE_HDQ16;

  00034	e3a01001	 mov         r1, #1

; 993  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_SetMode: "
; 994  :             L"New mode HDQ16\r\n"));
; 995  :         rc = TRUE;
; 996  :         break;

  00038	ea000000	 b           |$LN10@HDQ_SetMod|
  0003c		 |$LN3@HDQ_SetMod|

; 985  :         pDevice->mode = HDQ_MODE_HDQ8;

  0003c	e3a01000	 mov         r1, #0
  00040		 |$LN10@HDQ_SetMod|

; 982  :     {
; 983  :     case HDQ_MODE_HDQ8:
; 984  :         CLRREG32(&pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);

  00040	e592300c	 ldr         r3, [r2, #0xC]

; 986  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_INFO, (L"HDQ_SetMode: "
; 987  :             L"New mode HDQ8\r\n"));
; 988  :         rc = TRUE;

  00044	e3a0e001	 mov         lr, #1
  00048	e3c33001	 bic         r3, r3, #1
  0004c	e582300c	 str         r3, [r2, #0xC]
  00050	e5801048	 str         r1, [r0, #0x48]
  00054		 |$cleanUp$43389|

; 997  :     default:
; 998  :         DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_ERROR, (L"ERROR: HDQ_SetMode: "
; 999  :             L"Unsupported mode requested (mode = 0x%x)\r\n", mode));
; 1000 :     }
; 1001 : 
; 1002 : cleanUp:
; 1003 :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"-HDQ_SetMode(rc = 0x%x)\r\n", rc));
; 1004 :     return rc;
; 1005 : }

  00054	e1a0000e	 mov         r0, lr
  00058	e49de004	 ldr         lr, [sp], #4
  0005c	e12fff1e	 bx          lr
  00060		 |$LN14@HDQ_SetMod|
  00060		 |$LN15@HDQ_SetMod|
  00060	68647144	 DCD         0x68647144
  00064		 |$M43605|

			 ENDP  ; |HDQ_SetMode|

	EXPORT	|HDQ_Init|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|MmMapIoSpace|
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|GetLastError|
	IMPORT	|LocalAlloc|

  00000			 AREA	 |.pdata|, PDATA
|$T43629| DCD	|$LN17@HDQ_Init|
	DCD	0x40007002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_Init| PROC

; 228  : {

  00000		 |$LN17@HDQ_Init|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43626|
  00008	e1a05000	 mov         r5, r0

; 229  :     DWORD rc=(DWORD)NULL;
; 230  :     HDQ_DEVICE* pDevice=NULL;
; 231  :     PHYSICAL_ADDRESS pa;
; 232  :     int i=0;
; 233  : 
; 234  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+HDQ_Init(%s, 0x%08x)\r\n", szContext, pBusContext));
; 235  : 
; 236  : // Create device structure
; 237  :     pDevice=(HDQ_DEVICE*)LocalAlloc(LPTR, sizeof(HDQ_DEVICE));

  0000c	e3a01050	 mov         r1, #0x50
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a06000	 mov         r6, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 238  :     if(pDevice==NULL)

  00020	1a000006	 bne         |$LN9@HDQ_Init|

; 239  :     {
; 240  :         DWORD dwEr=GetLastError();

  00024	eb000000	 bl          GetLastError
  00028		 |$LN14@HDQ_Init|

; 372  :     {
; 373  :         HDQ_Deinit((DWORD)pDevice);

  00028	e1a00004	 mov         r0, r4
  0002c	eb000000	 bl          HDQ_Deinit
  00030		 |$LN1@HDQ_Init|

; 374  :     };    
; 375  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_Init(rc=0x%x) and HDQ power is OFF now.\r\n", rc));
; 376  :     return rc;
; 377  : }

  00030	e1a00006	 mov         r0, r6
  00034	e28dd010	 add         sp, sp, #0x10
  00038	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN9@HDQ_Init|

; 241  :         DEBUGMSG(ZONE_ERROR, (L"ERROR %lu: HDQ_Init: "
; 242  :             L"Failed allocate HDQ controller structure\r\n",dwEr
; 243  :         ));
; 244  :         goto cleanUp;
; 245  :     };
; 246  : 
; 247  : // Set cookie
; 248  :     pDevice->cookie=HDQ_DEVICE_COOKIE;

  00040	e59f3174	 ldr         r3, [pc, #0x174]

; 249  : 
; 250  : // Initalize critical section
; 251  :     InitializeCriticalSection(&pDevice->cs);

  00044	e1a00004	 mov         r0, r4
  00048	e480302c	 str         r3, [r0], #0x2C
  0004c	eb000000	 bl          InitializeCriticalSection

; 252  : 
; 253  : // Read device parameters
; 254  :     if(GetDeviceRegistryParams(szContext, pDevice, 
; 255  :             dimof(g_deviceRegParams), g_deviceRegParams) != ERROR_SUCCESS)

  00050	e59f3160	 ldr         r3, [pc, #0x160]
  00054	e3a02006	 mov         r2, #6
  00058	e1a01004	 mov         r1, r4
  0005c	e1a00005	 mov         r0, r5
  00060	eb000000	 bl          GetDeviceRegistryParams
  00064	e3500000	 cmp         r0, #0
  00068	1affffee	 bne         |$LN14@HDQ_Init|

; 256  :     {
; 257  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 258  :             L"Failed read HDQ driver registry parameters\r\n"
; 259  :         ));
; 260  :         goto cleanUp;
; 261  :     };
; 262  : 
; 263  : // Open parent bus
; 264  :     pDevice->hParentBus=CreateBusAccessHandle(szContext);

  0006c	e1a00005	 mov         r0, r5
  00070	eb000000	 bl          CreateBusAccessHandle
  00074	e3500000	 cmp         r0, #0
  00078	e5840024	 str         r0, [r4, #0x24]

; 265  :     if(pDevice->hParentBus==NULL)

  0007c	0affffe9	 beq         |$LN14@HDQ_Init|

; 266  :     {
; 267  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 268  :             L"Failed open parent bus driver\r\n"
; 269  :         ));
; 270  :         goto cleanUp;
; 271  :     };
; 272  : 
; 273  : // Set hardware to full power
; 274  :     SetDevicePowerState(pDevice->hParentBus, D0, NULL);

  00080	e3a02000	 mov         r2, #0
  00084	e3a01000	 mov         r1, #0
  00088	eb000000	 bl          SetDevicePowerState

; 275  : 
; 276  : // Map the PRCM registers
; 277  :     pa.LowPart=OMAP2420_PRCM_REGS_PA;
; 278  :     pDevice->pPRCMRegs=(OMAP2420_PRCM_REGS*)MmMapIoSpace(pa,
; 279  :         sizeof(OMAP2420_PRCM_REGS), FALSE);

  0008c	e59d100c	 ldr         r1, [sp, #0xC]
  00090	e3a03312	 mov         r3, #0x12, 6
  00094	e3830902	 orr         r0, r3, #2, 18
  00098	e3a03000	 mov         r3, #0
  0009c	e3a02c09	 mov         r2, #9, 24
  000a0	eb000000	 bl          MmMapIoSpace
  000a4	e3500000	 cmp         r0, #0
  000a8	e584001c	 str         r0, [r4, #0x1C]

; 280  :     if(pDevice->pPRCMRegs==NULL)

  000ac	0affffdd	 beq         |$LN14@HDQ_Init|

; 281  :     {
; 282  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 283  :             L"Failed to map PRCM registers\n"
; 284  :         ));
; 285  :         goto cleanUp;
; 286  :     };
; 287  : 
; 288  : // Map the HDQ registers
; 289  :     pa.QuadPart=pDevice->memBase;

  000b0	e5940004	 ldr         r0, [r4, #4]
  000b4	e3a01000	 mov         r1, #0

; 290  :     pDevice->pHDQRegs=(OMAP2420_HDQ_REGS*)MmMapIoSpace(pa, 
; 291  :         sizeof(OMAP2420_HDQ_REGS), FALSE);

  000b8	e3a03000	 mov         r3, #0
  000bc	e3a0201c	 mov         r2, #0x1C
  000c0	eb000000	 bl          MmMapIoSpace
  000c4	e3500000	 cmp         r0, #0
  000c8	e5840020	 str         r0, [r4, #0x20]

; 292  :     if(pDevice->pHDQRegs==NULL)

  000cc	0affffd5	 beq         |$LN14@HDQ_Init|

; 293  :     {
; 294  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 295  :             L"Failed map HDQ controller registers\r\n"
; 296  :         ));
; 297  :         goto cleanUp;
; 298  :     };
; 299  : 
; 300  : // Map HDQ_1WIRE interrupt
; 301  :     if(KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, &pDevice->irq, 
; 302  :         sizeof(pDevice->irq), &pDevice->sysIntr,
; 303  :         sizeof(pDevice->sysIntr), NULL)==0)

  000d0	e59f00dc	 ldr         r0, [pc, #0xDC]
  000d4	e3a0e004	 mov         lr, #4
  000d8	e3a05000	 mov         r5, #0
  000dc	e2843040	 add         r3, r4, #0x40
  000e0	e3a02004	 mov         r2, #4
  000e4	e284100c	 add         r1, r4, #0xC
  000e8	e58d5004	 str         r5, [sp, #4]
  000ec	e58de000	 str         lr, [sp]
  000f0	eb000000	 bl          KernelIoControl
  000f4	e3500000	 cmp         r0, #0
  000f8	0affffca	 beq         |$LN14@HDQ_Init|

; 304  :     {
; 305  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 306  :             L"Failed map HDQ/1WIRE controller interrupt\r\n"
; 307  :         ));
; 308  :         goto cleanUp;
; 309  :     };
; 310  : 
; 311  : // Create interrupt event
; 312  :     pDevice->hIntrEvent=CreateEvent(NULL, FALSE, FALSE, NULL);

  000fc	e3a03000	 mov         r3, #0
  00100	e3a02000	 mov         r2, #0
  00104	e3a01000	 mov         r1, #0
  00108	e3a00000	 mov         r0, #0
  0010c	eb000000	 bl          CreateEventW
  00110	e1b01000	 movs        r1, r0
  00114	e5841044	 str         r1, [r4, #0x44]

; 313  :     if(pDevice->hIntrEvent==NULL)

  00118	0affffc2	 beq         |$LN14@HDQ_Init|

; 314  :     {
; 315  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 316  :             L"Failed create interrupt event\r\n"
; 317  :         ));
; 318  :         goto cleanUp;
; 319  :     };
; 320  : 
; 321  : // Initialize interrupt
; 322  :     if(InterruptInitialize(pDevice->sysIntr, 
; 323  :         pDevice->hIntrEvent, NULL, 0)==0)

  0011c	e5940040	 ldr         r0, [r4, #0x40]
  00120	e3a03000	 mov         r3, #0
  00124	e3a02000	 mov         r2, #0
  00128	eb000000	 bl          InterruptInitialize
  0012c	e3500000	 cmp         r0, #0
  00130	0affffbc	 beq         |$LN14@HDQ_Init|

; 324  :     {
; 325  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: HDQ_Init: "
; 326  :             L"InterruptInitialize failed\r\n"
; 327  :         ));
; 328  :         goto cleanUp;
; 329  :     };
; 330  : 
; 331  :     DEBUGMSG(ZONE_ERROR, (L"\tHDQ_Init: "
; 332  :         L"Resetting OMAP HDQ module...\r\n"
; 333  :     ));
; 334  : // reset the hdq device
; 335  : /*  SETREG32(&pDevice->pHDQRegs->ulHDQ_SYSCONFIG,HDQ_SYSCONFIG_SOFTRESET);
; 336  : // wait for the reset to be completed
; 337  :     for(; i<50; i++)
; 338  :     {
; 339  :         Sleep(10);
; 340  :         if( INREG32(&pDevice->pHDQRegs->ulHDQ_SYSSTATUS) & HDQ_SYSSTATUS_RESETDONE)
; 341  :         break;
; 342  :     };
; 343  :     if(i>=50)
; 344  :         DEBUGMSG(ZONE_HDQ_1WIRE, (L"\tHDQ_Init: "
; 345  :             L"Reset of OMAP HDQ module failed !!\r\n"
; 346  :         ));
; 347  :     else
; 348  :         DEBUGMSG(ZONE_HDQ_1WIRE, (L"\tHDQ_Init: "
; 349  :             L"Reset of OMAP HDQ module done. Dur=%ld\r\n", i*10
; 350  :         ));
; 351  : */
; 352  : // set the HDQ mode of operation - it is the default for OMAP HDQ, but must be sure
; 353  :     CLRREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS,HDQ_CTRL_STATUS_1_WIRE_SINGLE_BIT);

  00134	e5940020	 ldr         r0, [r4, #0x20]

; 354  : // Enable the clock and set the mode
; 355  :     SETREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_CLOCKENABLE);
; 356  :     CLRREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_MODE);
; 357  :     pDevice->mode=HDQ_MODE_HDQ8;
; 358  : 
; 359  : // Clear and enable interrupts
; 360  :     INREG32(&pDevice->pHDQRegs->ulHDQ_INT_STATUS);
; 361  :     SETREG32(&pDevice->pHDQRegs->ulHDQ_CTRL_STATUS, HDQ_CTRL_STATUS_INTERRUPTMASK);
; 362  : 
; 363  : // Set hardware to power-off
; 364  :     SetDevicePowerState(pDevice->hParentBus, D4, NULL);

  00138	e3a02000	 mov         r2, #0
  0013c	e3a01004	 mov         r1, #4
  00140	e590300c	 ldr         r3, [r0, #0xC]
  00144	e3c33080	 bic         r3, r3, #0x80
  00148	e580300c	 str         r3, [r0, #0xC]
  0014c	e5940020	 ldr         r0, [r4, #0x20]
  00150	e590300c	 ldr         r3, [r0, #0xC]
  00154	e3833020	 orr         r3, r3, #0x20
  00158	e580300c	 str         r3, [r0, #0xC]
  0015c	e5940020	 ldr         r0, [r4, #0x20]
  00160	e590300c	 ldr         r3, [r0, #0xC]
  00164	e3c33001	 bic         r3, r3, #1
  00168	e580300c	 str         r3, [r0, #0xC]
  0016c	e594e020	 ldr         lr, [r4, #0x20]
  00170	e5845048	 str         r5, [r4, #0x48]
  00174	e59e0010	 ldr         r0, [lr, #0x10]
  00178	e59e300c	 ldr         r3, [lr, #0xC]
  0017c	e3833040	 orr         r3, r3, #0x40
  00180	e58e300c	 str         r3, [lr, #0xC]
  00184	e5940024	 ldr         r0, [r4, #0x24]
  00188	eb000000	 bl          SetDevicePowerState

; 365  : 
; 366  : // Return non-null value - hdq init completed successfully
; 367  :     rc=(DWORD)pDevice;
; 368  : // sr dump hdq registers
; 369  :     bDumpOmapHdqRegs(pDevice);

  0018c	e5943020	 ldr         r3, [r4, #0x20]
  00190	e1a06004	 mov         r6, r4
  00194		 |$cleanUp$42927|
  00194	e5934000	 ldr         r4, [r3]
  00198	e5930004	 ldr         r0, [r3, #4]
  0019c	e5935008	 ldr         r5, [r3, #8]
  001a0	e593e00c	 ldr         lr, [r3, #0xC]
  001a4	e5931010	 ldr         r1, [r3, #0x10]
  001a8	e5932014	 ldr         r2, [r3, #0x14]
  001ac	e5933018	 ldr         r3, [r3, #0x18]

; 370  : cleanUp:
; 371  :     if(rc==0)

  001b0	eaffff9e	 b           |$LN1@HDQ_Init|
  001b4		 |$LN18@HDQ_Init|
  001b4		 |$LN19@HDQ_Init|
  001b4	01010098	 DCD         0x1010098
  001b8		 |$LN20@HDQ_Init|
  001b8	00000000	 DCD         |g_deviceRegParams|
  001bc		 |$LN21@HDQ_Init|
  001bc	68647144	 DCD         0x68647144
  001c0		 |$M43627|

			 ENDP  ; |HDQ_Init|

	EXPORT	|HDQ_IOControl|
	IMPORT	|SetLastError|
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|GetCallerProcess|
	IMPORT	|memcmp|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43655| DCD	|$LN23@HDQ_IOCont|
	DCD	0x40004202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\hdq\hdq.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HDQ_IOControl| PROC

; 539  : {

  00000		 |$LN23@HDQ_IOCont|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43652|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1b08000	 movs        r8, r0

; 540  :     BOOL rc=FALSE;

  00014	e3a05000	 mov         r5, #0

; 541  :     HDQ_DEVICE* pDevice=(HDQ_DEVICE*)context;
; 542  :     DEVICE_IFC_HDQ ifc;
; 543  : 
; 544  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"+++HDQ_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 545  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize));
; 546  : 
; 547  : // Check if we get correct context
; 548  :     if(pDevice==NULL || pDevice->cookie!=HDQ_DEVICE_COOKIE)

  00018	0a000031	 beq         |$cleanUp$43103|
  0001c	e5984000	 ldr         r4, [r8]
  00020	e59fe0dc	 ldr         lr, [pc, #0xDC]
  00024	e154000e	 cmp         r4, lr
  00028	1a00002d	 bne         |$cleanUp$43103|
  0002c	e3a03822	 mov         r3, #0x22, 16

; 549  :     {
; 550  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_IOControl: "
; 551  :             L"Incorrect context paramer\r\n"));
; 552  :         goto cleanUp;
; 553  :     };
; 554  : 
; 555  :     switch (code)

  00030	e383eb01	 orr         lr, r3, #1, 22
  00034	e151000e	 cmp         r1, lr

; 592  :             break;
; 593  :         };
; 594  :         SetLastError(ERROR_INVALID_PARAMETER);
; 595  :         break;
; 596  :     default:
; 597  :         DEBUGMSG(ZONE_WARN, (L"WARN: HDQ_IOControl: "
; 598  :             L"Unsupported code 0x%08x\r\n", code));
; 599  :         SetLastError(ERROR_INVALID_PARAMETER);
; 600  :         break;

  00038	1a000027	 bne         |$LN7@HDQ_IOCont|
  0003c	e3a0000c	 mov         r0, #0xC
  00040	eb000000	 bl          __GetUserKData
  00044	e1a04000	 mov         r4, r0
  00048	eb000000	 bl          GetCallerProcess
  0004c	e1540000	 cmp         r4, r0
  00050	13a00005	 movne       r0, #5
  00054	1a000021	 bne         |$LN19@HDQ_IOCont|

; 556  :     {
; 557  :     case IOCTL_DDK_GET_DRIVER_IFC:
; 558  : // We can give interface only to our peer in device process
; 559  :         if(GetCurrentProcessId()!=(DWORD)GetCallerProcess())
; 560  :         {
; 561  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: HDQ_IOControl: IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 562  :                 L"device process (caller process id 0x%08x)\r\n", GetCallerProcess()));
; 563  :             SetLastError(ERROR_ACCESS_DENIED);
; 564  :             break;
; 565  :         }
; 566  :         if(pInBuffer==NULL || inSize < sizeof(GUID))

  00058	e3560000	 cmp         r6, #0
  0005c	0a00001e	 beq         |$LN7@HDQ_IOCont|
  00060	e3570010	 cmp         r7, #0x10
  00064	3a00001c	 bcc         |$LN7@HDQ_IOCont|

; 569  :             break;
; 570  :         };
; 571  :         if(IsEqualGUID(pInBuffer, &DEVICE_IFC_HDQ_GUID))

  00068	e59f1090	 ldr         r1, [pc, #0x90]
  0006c	e3a02010	 mov         r2, #0x10
  00070	e1a00006	 mov         r0, r6
  00074	eb000000	 bl          memcmp
  00078	e3500000	 cmp         r0, #0
  0007c	1a000016	 bne         |$LN7@HDQ_IOCont|

; 572  :         {
; 573  :             if(pOutSize!=NULL)

  00080	e59d3030	 ldr         r3, [sp, #0x30]

; 574  :             {
; 575  :                 *pOutSize=sizeof(DEVICE_IFC_HDQ);
; 576  :             }
; 577  :             if(pOutBuffer==NULL || outSize < sizeof(DEVICE_IFC_HDQ))

  00084	e59d0028	 ldr         r0, [sp, #0x28]
  00088	e3530000	 cmp         r3, #0
  0008c	13a02010	 movne       r2, #0x10
  00090	15832000	 strne       r2, [r3]
  00094	e3500000	 cmp         r0, #0
  00098	0a00000f	 beq         |$LN7@HDQ_IOCont|
  0009c	e59d302c	 ldr         r3, [sp, #0x2C]
  000a0	e3530010	 cmp         r3, #0x10
  000a4	3a00000c	 bcc         |$LN7@HDQ_IOCont|

; 578  :             {
; 579  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 580  :                 break;
; 581  :             }
; 582  :             ifc.context=context;
; 583  :             ifc.pfnWrite=HDQ_Write;
; 584  :             ifc.pfnRead=HDQ_Read;

  000a8	e59f204c	 ldr         r2, [pc, #0x4C]

; 585  :             ifc.pfnSetMode=HDQ_SetMode;

  000ac	e59f1044	 ldr         r1, [pc, #0x44]
  000b0	e59f303c	 ldr         r3, [pc, #0x3C]
  000b4	e58d2008	 str         r2, [sp, #8]
  000b8	e58d100c	 str         r1, [sp, #0xC]

; 586  :             if(!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_HDQ)))

  000bc	e3a02010	 mov         r2, #0x10
  000c0	e28d1000	 add         r1, sp, #0
  000c4	e58d3004	 str         r3, [sp, #4]
  000c8	e58d8000	 str         r8, [sp]
  000cc	eb000000	 bl          CeSafeCopyMemory
  000d0	e3500000	 cmp         r0, #0

; 587  :             {
; 588  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 589  :                 break;
; 590  :             }
; 591  :             rc=TRUE;

  000d4	13a05001	 movne       r5, #1
  000d8	1a000001	 bne         |$cleanUp$43103|
  000dc		 |$LN7@HDQ_IOCont|

; 567  :         {
; 568  :             SetLastError(ERROR_INVALID_PARAMETER);

  000dc	e3a00057	 mov         r0, #0x57
  000e0		 |$LN19@HDQ_IOCont|
  000e0	eb000000	 bl          SetLastError
  000e4		 |$cleanUp$43103|

; 601  :     };
; 602  : 
; 603  : cleanUp:
; 604  :     DEBUGMSG(ZONE_HDQ_1WIRE | ZONE_FUNCTION, (L"---HDQ_IOControl(rc = %d)\r\n", rc));
; 605  :     return rc;
; 606  : }

  000e4	e1a00005	 mov         r0, r5
  000e8	e28dd010	 add         sp, sp, #0x10
  000ec	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$LN24@HDQ_IOCont|
  000f4		 |$LN25@HDQ_IOCont|
  000f4	00000000	 DCD         |HDQ_Write|
  000f8		 |$LN26@HDQ_IOCont|
  000f8	00000000	 DCD         |HDQ_SetMode|
  000fc		 |$LN27@HDQ_IOCont|
  000fc	00000000	 DCD         |HDQ_Read|
  00100		 |$LN28@HDQ_IOCont|
  00100	00000000	 DCD         |DEVICE_IFC_HDQ_GUID|
  00104		 |$LN29@HDQ_IOCont|
  00104	68647144	 DCD         0x68647144
  00108		 |$M43653|

			 ENDP  ; |HDQ_IOControl|

	END
