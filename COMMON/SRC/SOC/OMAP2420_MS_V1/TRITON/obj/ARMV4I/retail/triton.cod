; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP2420_MS_V1\TRITON\triton.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BG@PDLELEPB@?$AAI?$AA2?$AAC?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|dpCurSettings| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
	%	32
|s_deviceRegParams| DCD |??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x4
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x64
	DCD	|??_C@_1BG@PDLELEPB@?$AAI?$AA2?$AAC?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x2d

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@PDLELEPB@?$AAI?$AA2?$AAC?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?$AA@| DCB "I"
	DCB	0x0, "2", 0x0, "C", 0x0, "A", 0x0, "d", 0x0, "d", 0x0, "r"
	DCB	0x0, "e", 0x0, "s", 0x0, "s", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17DJGGJCGD@?$AAI?$AAr?$AAq?$AA?$AA@| DCB "I", 0x0, "r", 0x0, "q", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "T", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "o", 0x0, "n", 0x0
	DCB	" ", 0x0, "(", 0x0, "T", 0x0, "W", 0x0, "L", 0x0, ")", 0x0
	DCB	0x0, 0x0
	%	38
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"R", 0x0, "T", 0x0, "C", 0x0, 0x0, 0x0
	%	56
	DCD	0x8003
	EXPORT	|PulseEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43487| DCD	|$LN5@PulseEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PulseEvent| PROC

; 211  : _inline BOOL PulseEvent(HANDLE h) {

  00000		 |$LN5@PulseEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43484|

; 212  : 	return EventModify(h,EVENT_PULSE);

  00004	e3a01001	 mov         r1, #1
  00008	eb000000	 bl          EventModify

; 213  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43485|

			 ENDP  ; |PulseEvent|

	EXPORT	|SetEvent|

  00000			 AREA	 |.pdata|, PDATA
|$T43497| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43494|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43495|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentProcess|

  00000			 AREA	 |.pdata|, PDATA
|$T43506| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcess| PROC

; 361  : _inline HANDLE GetCurrentProcess(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M43503|

; 362  : 	return ((HANDLE)(SH_CURPROC+SYS_HANDLE_BASE));

  00000	e3a00042	 mov         r0, #0x42

; 363  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43504|

			 ENDP  ; |GetCurrentProcess|

	EXPORT	|GetCurrentProcessId|
	IMPORT	|__GetUserKData|

  00000			 AREA	 |.pdata|, PDATA
|$T43515| DCD	|$LN5@GetCurrent@2|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentProcessId| PROC

; 373  : _inline DWORD GetCurrentProcessId(void) {

  00000		 |$LN5@GetCurrent@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43512|

; 374  :     return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));

  00004	e3a0000c	 mov         r0, #0xC
  00008	eb000000	 bl          __GetUserKData

; 375  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M43513|

			 ENDP  ; |GetCurrentProcessId|

	EXPORT	|I2COpen|
	IMPORT	|LocalFree|
	IMPORT	|DeviceIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|LocalAlloc|
	IMPORT	|CreateFileW|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43527| DCD	|$LN8@I2COpen|
	DCD	0x40002e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2COpen| PROC

; 86   : {

  00000		 |$LN8@I2COpen|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43524|

; 87   :     HANDLE hDevice;
; 88   :     DEVICE_CONTEXT_I2C *pContext = NULL;
; 89   : 
; 90   :     hDevice = CreateFile(devicename, 0, 0, NULL, 0, 0, NULL);

  00008	e3a06000	 mov         r6, #0
  0000c	e3a03000	 mov         r3, #0
  00010	e3a02000	 mov         r2, #0
  00014	e3a01000	 mov         r1, #0
  00018	e58d6008	 str         r6, [sp, #8]
  0001c	e58d6004	 str         r6, [sp, #4]
  00020	e58d6000	 str         r6, [sp]
  00024	e3a04000	 mov         r4, #0
  00028	eb000000	 bl          CreateFileW
  0002c	e1a05000	 mov         r5, r0

; 91   :     if (hDevice == INVALID_HANDLE_VALUE) goto clean;

  00030	e3750001	 cmn         r5, #1
  00034	0a00001a	 beq         |$clean$42746|

; 92   : 
; 93   :     // Allocate memory for our handler...
; 94   :     if ((pContext = (DEVICE_CONTEXT_I2C *)LocalAlloc(
; 95   :         LPTR, sizeof(DEVICE_CONTEXT_I2C)
; 96   :     )) == NULL) {

  00038	e3a01010	 mov         r1, #0x10
  0003c	e3a00040	 mov         r0, #0x40
  00040	eb000000	 bl          LocalAlloc
  00044	e1b04000	 movs        r4, r0

; 97   :         CloseHandle(hDevice);

  00048	e1a00005	 mov         r0, r5
  0004c	1a000001	 bne         |$LN2@I2COpen|
  00050	eb000000	 bl          CloseHandle

; 98   :         goto clean;

  00054	ea000012	 b           |$clean$42746|
  00058		 |$LN2@I2COpen|

; 99   :     }
; 100  : 
; 101  :     // Get function pointers, fail when IOCTL isn't supported...
; 102  :     if (!DeviceIoControl(
; 103  :         hDevice, IOCTL_DDK_GET_DRIVER_IFC, (VOID*)&DEVICE_IFC_I2C_GUID,
; 104  :         sizeof(DEVICE_IFC_I2C_GUID), &pContext->ifc, sizeof(DEVICE_IFC_I2C),
; 105  :         NULL, NULL
; 106  :     )) {

  00058	e59f2054	 ldr         r2, [pc, #0x54]
  0005c	e3a03822	 mov         r3, #0x22, 16
  00060	e3831b01	 orr         r1, r3, #1, 22
  00064	e3a0e00c	 mov         lr, #0xC
  00068	e3a03010	 mov         r3, #0x10
  0006c	e58d600c	 str         r6, [sp, #0xC]
  00070	e58d6008	 str         r6, [sp, #8]
  00074	e58de004	 str         lr, [sp, #4]
  00078	e58d4000	 str         r4, [sp]
  0007c	eb000000	 bl          DeviceIoControl
  00080	e3500000	 cmp         r0, #0
  00084	1a000005	 bne         |$LN1@I2COpen|

; 107  :         CloseHandle(hDevice);

  00088	e1a00005	 mov         r0, r5
  0008c	eb000000	 bl          CloseHandle

; 108  :         LocalFree(pContext);

  00090	e1a00004	 mov         r0, r4
  00094	eb000000	 bl          LocalFree

; 109  :         pContext = NULL;

  00098	e3a04000	 mov         r4, #0

; 110  :         goto clean;

  0009c	ea000000	 b           |$clean$42746|
  000a0		 |$LN1@I2COpen|

; 111  :     }
; 112  : 
; 113  :     // Save device handle
; 114  :     pContext->hDevice = hDevice;

  000a0	e584500c	 str         r5, [r4, #0xC]
  000a4		 |$clean$42746|

; 115  : 
; 116  : clean:
; 117  :     return pContext;
; 118  : }

  000a4	e1a00004	 mov         r0, r4
  000a8	e28dd010	 add         sp, sp, #0x10
  000ac	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN9@I2COpen|
  000b4		 |$LN10@I2COpen|
  000b4	00000000	 DCD         |DEVICE_IFC_I2C_GUID|
  000b8		 |$M43525|

			 ENDP  ; |I2COpen|

	EXPORT	|I2CClose|

  00000			 AREA	 |.pdata|, PDATA
|$T43537| DCD	|$LN7@I2CClose|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2CClose| PROC

; 121  : {

  00000		 |$LN7@I2CClose|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M43534|
  00004	e1b04000	 movs        r4, r0

; 122  :     DEVICE_CONTEXT_I2C *pContext = (DEVICE_CONTEXT_I2C *)hContext;
; 123  : 
; 124  :     if ( (pContext != NULL) && (pContext->hDevice != INVALID_HANDLE_VALUE) )

  00008	0a000004	 beq         |$LN1@I2CClose|
  0000c	e594000c	 ldr         r0, [r4, #0xC]
  00010	e3700001	 cmn         r0, #1

; 125  :         CloseHandle(pContext->hDevice);

  00014	1b000000	 blne        CloseHandle

; 126  : 
; 127  :     if (pContext != NULL)
; 128  :         LocalFree(pContext);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          LocalFree
  00020		 |$LN1@I2CClose|

; 129  : }

  00020	e8bd4010	 ldmia       sp!, {r4, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M43535|

			 ENDP  ; |I2CClose|

	EXPORT	|I2CSetSlaveAddress|

  00000			 AREA	 |.pdata|, PDATA
|$T43549| DCD	|$LN5@I2CSetSlav|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2CSetSlaveAddress| PROC

; 132  : {

  00000		 |$LN5@I2CSetSlav|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43546|
  00004	e1a03000	 mov         r3, r0

; 133  :     DEVICE_CONTEXT_I2C *pContext = (DEVICE_CONTEXT_I2C *)hContext;
; 134  :     return pContext->ifc.pfnSetSlaveAddress(pContext->ifc.context, size, address);

  00008	e5930000	 ldr         r0, [r3]
  0000c	e5933004	 ldr         r3, [r3, #4]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 135  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M43547|

			 ENDP  ; |I2CSetSlaveAddress|

	EXPORT	|I2CTransact|

  00000			 AREA	 |.pdata|, PDATA
|$T43560| DCD	|$LN5@I2CTransac|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |I2CTransact| PROC

; 138  : {

  00000		 |$LN5@I2CTransac|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43557|
  00004	e1a03000	 mov         r3, r0

; 139  :     DEVICE_CONTEXT_I2C *pContext = (DEVICE_CONTEXT_I2C *)hContext;
; 140  :     return pContext->ifc.pfnTransact(pContext->ifc.context, pTrans);

  00008	e5930000	 ldr         r0, [r3]
  0000c	e5933008	 ldr         r3, [r3, #8]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3

; 141  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M43558|

			 ENDP  ; |I2CTransact|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|GetTritonIrqStatus|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T43587| DCD	|$LN8@GetTritonI|
	DCD	0xc0004102

  00000			 AREA	 |.xdata|, DATA
|$T43583| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43583|

  00008		 |GetTritonIrqStatus| PROC

; 74   : {

  00008		 |$LN8@GetTritonI|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf5d	 sub         sp, sp, #0x5D, 30
  00010		 |$M43584|
  00010	e1a05001	 mov         r5, r1
  00014	e1a04000	 mov         r4, r0
  00018	e59f30e8	 ldr         r3, [pc, #0xE8]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3170	 str         r3, [sp, #0x170]

; 75   :     Device_t *pDevice = (Device_t*)pContext;
; 76   :     I2CTRANS trans;
; 77   : 
; 78   :     ZeroMemory(&trans,sizeof(trans));

  00024	e3a02e17	 mov         r2, #0x17, 28
  00028	e3a01000	 mov         r1, #0
  0002c	e28d0000	 add         r0, sp, #0
  00030	eb000000	 bl          memset

; 79   :     
; 80   :     trans.mClk_HL_Divisor = I2C_CLOCK_100Khz;
; 81   :     
; 82   :     /* write out the register address to read from */
; 83   :     trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 84   :     trans.mBufferOffset[0] = 0;
; 85   :     trans.mTransLen[0] = 1;
; 86   :     trans.mBuffer[0] = MENELAUS_INTSTATUS1_OFFSET;
; 87   :     /* now read the byte at that location */
; 88   :     trans.mOpCode[1] = I2C_OPCODE_READ;
; 89   :     trans.mBufferOffset[1] = 0;
; 90   :     trans.mTransLen[1] = 1;
; 91   :     /* write out the second address to read from */
; 92   :     trans.mOpCode[2] = I2C_OPCODE_WRITE;
; 93   :     trans.mBufferOffset[2] = 1;
; 94   :     trans.mTransLen[2] = 1;
; 95   :     trans.mBuffer[1] = MENELAUS_INTSTATUS2_OFFSET;
; 96   :     /* now read back the byte at that location */
; 97   :     trans.mOpCode[3] = I2C_OPCODE_READ;
; 98   :     trans.mBufferOffset[3] = 1;
; 99   :     trans.mTransLen[3] = 1;
; 100  : 
; 101  :     I2CTransact(pDevice->hI2C, &trans);

  00034	e3a0203c	 mov         r2, #0x3C
  00038	e58d2008	 str         r2, [sp, #8]
  0003c	e3a0201a	 mov         r2, #0x1A
  00040	e5cd2071	 strb        r2, [sp, #0x71]
  00044	e3a02001	 mov         r2, #1
  00048	e58d2018	 str         r2, [sp, #0x18]
  0004c	e3a02001	 mov         r2, #1
  00050	e5943010	 ldr         r3, [r4, #0x10]
  00054	e58d2038	 str         r2, [sp, #0x38]
  00058	e3a02001	 mov         r2, #1
  0005c	e3a01002	 mov         r1, #2
  00060	e3a00000	 mov         r0, #0
  00064	e3a0e001	 mov         lr, #1
  00068	e3a04019	 mov         r4, #0x19
  0006c	e3a06001	 mov         r6, #1
  00070	e3a07000	 mov         r7, #0
  00074	e3a08001	 mov         r8, #1
  00078	e3a09002	 mov         r9, #2
  0007c	e3a0a001	 mov         r10, #1
  00080	e3a0b001	 mov         r11, #1
  00084	e58d2058	 str         r2, [sp, #0x58]
  00088	e58d100c	 str         r1, [sp, #0xC]
  0008c	e58d002c	 str         r0, [sp, #0x2C]
  00090	e58de04c	 str         lr, [sp, #0x4C]
  00094	e5cd4070	 strb        r4, [sp, #0x70]
  00098	e58d6010	 str         r6, [sp, #0x10]
  0009c	e58d7030	 str         r7, [sp, #0x30]
  000a0	e58d8050	 str         r8, [sp, #0x50]
  000a4	e58d9014	 str         r9, [sp, #0x14]
  000a8	e58da034	 str         r10, [sp, #0x34]
  000ac	e58db054	 str         r11, [sp, #0x54]
  000b0	e5930000	 ldr         r0, [r3]
  000b4	e5933008	 ldr         r3, [r3, #8]
  000b8	e28d1000	 add         r1, sp, #0
  000bc	e1a0e00f	 mov         lr, pc
  000c0	e12fff13	 bx          r3

; 102  : 
; 103  :     if (trans.mErrorCode)

  000c4	e59d306c	 ldr         r3, [sp, #0x6C]
  000c8	e3530000	 cmp         r3, #0
  000cc	0a000003	 beq         |$LN1@GetTritonI|

; 104  :         return FALSE;

  000d0	e59d0170	 ldr         r0, [sp, #0x170]
  000d4	eb000000	 bl          __security_check_cookie
  000d8	e3a00000	 mov         r0, #0
  000dc	ea000006	 b           |$LN2@GetTritonI|
  000e0		 |$LN1@GetTritonI|

; 105  : 
; 106  :     *pStatus = (((UINT16)trans.mBuffer[1])<<8) | trans.mBuffer[0];

  000e0	e5dd2071	 ldrb        r2, [sp, #0x71]
  000e4	e5dd3070	 ldrb        r3, [sp, #0x70]
  000e8	e1833402	 orr         r3, r3, r2, lsl #8
  000ec	e1c530b0	 strh        r3, [r5]

; 107  : 	
; 108  : 	return TRUE;

  000f0	e59d0170	 ldr         r0, [sp, #0x170]
  000f4	eb000000	 bl          __security_check_cookie
  000f8	e3a00001	 mov         r0, #1
  000fc		 |$LN2@GetTritonI|

; 109  : }

  000fc	e28ddf5d	 add         sp, sp, #0x5D, 30
  00100	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00104	e12fff1e	 bx          lr
  00108		 |$LN9@GetTritonI|
  00108		 |$LN10@GetTritonI|
  00108	00000000	 DCD         |__security_cookie|
  0010c		 |$M43585|

			 ENDP  ; |GetTritonIrqStatus|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|GetTritonIrqMask|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43615| DCD	|$LN9@GetTritonI@2|
	DCD	0xc0003e02

  00000			 AREA	 |.xdata|, DATA
|$T43611| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43611|

  00008		 |GetTritonIrqMask| PROC

; 117  : {

  00008		 |$LN9@GetTritonI@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf5d	 sub         sp, sp, #0x5D, 30
  00010		 |$M43612|
  00010	e1a05001	 mov         r5, r1
  00014	e1a04000	 mov         r4, r0
  00018	e59f30dc	 ldr         r3, [pc, #0xDC]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3170	 str         r3, [sp, #0x170]

; 118  :     Device_t *pDevice = (Device_t*)pContext;
; 119  :     I2CTRANS trans;
; 120  : 
; 121  :     ZeroMemory(&trans,sizeof(trans));

  00024	e3a02e17	 mov         r2, #0x17, 28
  00028	e3a01000	 mov         r1, #0
  0002c	e28d0000	 add         r0, sp, #0
  00030	eb000000	 bl          memset

; 122  :     
; 123  :     trans.mClk_HL_Divisor = I2C_CLOCK_100Khz;
; 124  :     
; 125  :     // write out the register address to read from 
; 126  :     trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 127  :     trans.mBufferOffset[0] = 0;
; 128  :     trans.mTransLen[0] = 1;
; 129  :     trans.mBuffer[0] = MENELAUS_INTMASK1_OFFSET;
; 130  :     // now read the byte at that location 
; 131  :     trans.mOpCode[1] = I2C_OPCODE_READ;
; 132  :     trans.mBufferOffset[1] = 0;
; 133  :     trans.mTransLen[1] = 1;
; 134  :     // write out the second address to read from 
; 135  :     trans.mOpCode[2] = I2C_OPCODE_WRITE;
; 136  :     trans.mBufferOffset[2] = 1;
; 137  :     trans.mTransLen[2] = 1;
; 138  :     trans.mBuffer[1] = MENELAUS_INTMASK2_OFFSET;
; 139  :     // now read back the byte at that location 
; 140  :     trans.mOpCode[3] = I2C_OPCODE_READ;
; 141  :     trans.mBufferOffset[3] = 1;
; 142  :     trans.mTransLen[3] = 1;
; 143  : 
; 144  :     I2CTransact(pDevice->hI2C, &trans);

  00034	e3a0203c	 mov         r2, #0x3C
  00038	e58d2008	 str         r2, [sp, #8]
  0003c	e3a02018	 mov         r2, #0x18
  00040	e5cd2071	 strb        r2, [sp, #0x71]
  00044	e3a02001	 mov         r2, #1
  00048	e58d2018	 str         r2, [sp, #0x18]
  0004c	e3a02001	 mov         r2, #1
  00050	e5943010	 ldr         r3, [r4, #0x10]
  00054	e58d2038	 str         r2, [sp, #0x38]
  00058	e3a02001	 mov         r2, #1
  0005c	e3a01002	 mov         r1, #2
  00060	e3a00000	 mov         r0, #0
  00064	e3a0e001	 mov         lr, #1
  00068	e3a04017	 mov         r4, #0x17
  0006c	e3a06001	 mov         r6, #1
  00070	e3a07000	 mov         r7, #0
  00074	e3a08001	 mov         r8, #1
  00078	e3a09002	 mov         r9, #2
  0007c	e3a0a001	 mov         r10, #1
  00080	e3a0b001	 mov         r11, #1
  00084	e58d2058	 str         r2, [sp, #0x58]
  00088	e58d100c	 str         r1, [sp, #0xC]
  0008c	e58d002c	 str         r0, [sp, #0x2C]
  00090	e58de04c	 str         lr, [sp, #0x4C]
  00094	e5cd4070	 strb        r4, [sp, #0x70]
  00098	e58d6010	 str         r6, [sp, #0x10]
  0009c	e58d7030	 str         r7, [sp, #0x30]
  000a0	e58d8050	 str         r8, [sp, #0x50]
  000a4	e58d9014	 str         r9, [sp, #0x14]
  000a8	e58da034	 str         r10, [sp, #0x34]
  000ac	e58db054	 str         r11, [sp, #0x54]
  000b0	e5930000	 ldr         r0, [r3]
  000b4	e5933008	 ldr         r3, [r3, #8]
  000b8	e28d1000	 add         r1, sp, #0
  000bc	e1a0e00f	 mov         lr, pc
  000c0	e12fff13	 bx          r3

; 145  : 
; 146  :     *pStatus = (((UINT16)trans.mBuffer[1])<<8) | trans.mBuffer[0];
; 147  : 
; 148  :     return (trans.mErrorCode == 0);

  000c4	e59d106c	 ldr         r1, [sp, #0x6C]
  000c8	e5dd2071	 ldrb        r2, [sp, #0x71]
  000cc	e5dd3070	 ldrb        r3, [sp, #0x70]
  000d0	e3510000	 cmp         r1, #0
  000d4	03a04001	 moveq       r4, #1
  000d8	e1833402	 orr         r3, r3, r2, lsl #8
  000dc	13a04000	 movne       r4, #0
  000e0	e1c530b0	 strh        r3, [r5]
  000e4	e59d0170	 ldr         r0, [sp, #0x170]
  000e8	eb000000	 bl          __security_check_cookie

; 149  : }

  000ec	e1a00004	 mov         r0, r4
  000f0	e28ddf5d	 add         sp, sp, #0x5D, 30
  000f4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$LN10@GetTritonI@2|
  000fc		 |$LN11@GetTritonI@2|
  000fc	00000000	 DCD         |__security_cookie|
  00100		 |$M43613|

			 ENDP  ; |GetTritonIrqMask|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SetTritonIrqMask|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43663| DCD	|$LN17@SetTritonI|
	DCD	0xc0006702

  00000			 AREA	 |.xdata|, DATA
|$T43659| DCD	0xffffffe0
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43659|

  00008		 |SetTritonIrqMask| PROC

; 152  : {

  00008		 |$LN17@SetTritonI|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24ddf5d	 sub         sp, sp, #0x5D, 30
  00010		 |$M43660|
  00010	e1a04001	 mov         r4, r1
  00014	e1a05000	 mov         r5, r0
  00018	e59f3180	 ldr         r3, [pc, #0x180]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3170	 str         r3, [sp, #0x170]

; 153  :     Device_t *pDevice = (Device_t*)pContext;
; 154  :     I2CTRANS trans;
; 155  :     UCHAR mask;
; 156  : 
; 157  :     ZeroMemory(&trans,sizeof(trans));

  00024	e3a02e17	 mov         r2, #0x17, 28
  00028	e3a01000	 mov         r1, #0
  0002c	e28d0000	 add         r0, sp, #0
  00030	eb000000	 bl          memset

; 158  :     trans.mClk_HL_Divisor = I2C_CLOCK_100Khz;

  00034	e3a0303c	 mov         r3, #0x3C

; 159  :     
; 160  :     mask = status & 0xff;

  00038	e58d3008	 str         r3, [sp, #8]

; 161  :     if (mask) {

  0003c	e21460ff	 ands        r6, r4, #0xFF
  00040	0a000024	 beq         |$LN9@SetTritonI|

; 162  :         // read current mask setting
; 163  :         // write out the register address to read from
; 164  :         trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 165  :         trans.mBufferOffset[0] = 0;
; 166  :         trans.mTransLen[0] = 1;
; 167  :         trans.mBuffer[0] = MENELAUS_INTMASK1_OFFSET;
; 168  :         // now read the byte at that location 
; 169  :         trans.mOpCode[1] = I2C_OPCODE_READ;
; 170  :         trans.mBufferOffset[1] = 0;
; 171  :         trans.mTransLen[1] = 1;
; 172  : 
; 173  :         I2CTransact(pDevice->hI2C, &trans);

  00044	e5953010	 ldr         r3, [r5, #0x10]
  00048	e3a02002	 mov         r2, #2
  0004c	e3a01000	 mov         r1, #0
  00050	e3a00001	 mov         r0, #1
  00054	e3a0e017	 mov         lr, #0x17
  00058	e3a07001	 mov         r7, #1
  0005c	e3a08000	 mov         r8, #0
  00060	e3a09001	 mov         r9, #1
  00064	e58d200c	 str         r2, [sp, #0xC]
  00068	e58d102c	 str         r1, [sp, #0x2C]
  0006c	e58d004c	 str         r0, [sp, #0x4C]
  00070	e5cde070	 strb        lr, [sp, #0x70]
  00074	e58d7010	 str         r7, [sp, #0x10]
  00078	e58d8030	 str         r8, [sp, #0x30]
  0007c	e58d9050	 str         r9, [sp, #0x50]
  00080	e5930000	 ldr         r0, [r3]
  00084	e5933008	 ldr         r3, [r3, #8]
  00088	e28d1000	 add         r1, sp, #0
  0008c	e1a0e00f	 mov         lr, pc
  00090	e12fff13	 bx          r3

; 174  : 
; 175  :         // mask the pending interrupt
; 176  :         mask |= trans.mBuffer[0];

  00094	e5dd3070	 ldrb        r3, [sp, #0x70]

; 177  :         trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 178  :         trans.mBufferOffset[0] = 0;
; 179  :         trans.mTransLen[0] = 2;
; 180  :         trans.mBuffer[0] = MENELAUS_INTMASK1_OFFSET;
; 181  :         trans.mBuffer[1] = mask;
; 182  : 
; 183  :         I2CTransact(pDevice->hI2C, &trans);

  00098	e5952010	 ldr         r2, [r5, #0x10]
  0009c	e3a07002	 mov         r7, #2
  000a0	e1833006	 orr         r3, r3, r6
  000a4	e3a01000	 mov         r1, #0
  000a8	e3a00002	 mov         r0, #2
  000ac	e3a0e017	 mov         lr, #0x17
  000b0	e5cd3071	 strb        r3, [sp, #0x71]
  000b4	e58d700c	 str         r7, [sp, #0xC]
  000b8	e58d102c	 str         r1, [sp, #0x2C]
  000bc	e58d004c	 str         r0, [sp, #0x4C]
  000c0	e5cde070	 strb        lr, [sp, #0x70]
  000c4	e5920000	 ldr         r0, [r2]
  000c8	e5923008	 ldr         r3, [r2, #8]
  000cc	e28d1000	 add         r1, sp, #0
  000d0	e1a0e00f	 mov         lr, pc
  000d4	e12fff13	 bx          r3
  000d8		 |$LN9@SetTritonI|

; 184  :     }
; 185  : 
; 186  :     mask = (status >> 8) & 0xff;

  000d8	e1a03424	 mov         r3, r4, lsr #8

; 187  :     if (mask) {

  000dc	e21340ff	 ands        r4, r3, #0xFF
  000e0	0a000024	 beq         |$LN13@SetTritonI|

; 188  :         // read current mask setting
; 189  :         // write out the register address to read from
; 190  :         trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 191  :         trans.mBufferOffset[0] = 0;
; 192  :         trans.mTransLen[0] = 1;
; 193  :         trans.mBuffer[0] = MENELAUS_INTMASK2_OFFSET;
; 194  :         // now read the byte at that location
; 195  :         trans.mOpCode[1] = I2C_OPCODE_READ;
; 196  :         trans.mBufferOffset[1] = 0;
; 197  :         trans.mTransLen[1] = 1;
; 198  : 
; 199  :         I2CTransact(pDevice->hI2C, &trans);

  000e4	e5953010	 ldr         r3, [r5, #0x10]
  000e8	e3a02002	 mov         r2, #2
  000ec	e3a01000	 mov         r1, #0
  000f0	e3a00001	 mov         r0, #1
  000f4	e3a0e018	 mov         lr, #0x18
  000f8	e3a06001	 mov         r6, #1
  000fc	e3a07000	 mov         r7, #0
  00100	e3a08001	 mov         r8, #1
  00104	e58d200c	 str         r2, [sp, #0xC]
  00108	e58d102c	 str         r1, [sp, #0x2C]
  0010c	e58d004c	 str         r0, [sp, #0x4C]
  00110	e5cde070	 strb        lr, [sp, #0x70]
  00114	e58d6010	 str         r6, [sp, #0x10]
  00118	e58d7030	 str         r7, [sp, #0x30]
  0011c	e58d8050	 str         r8, [sp, #0x50]
  00120	e5930000	 ldr         r0, [r3]
  00124	e5933008	 ldr         r3, [r3, #8]
  00128	e28d1000	 add         r1, sp, #0
  0012c	e1a0e00f	 mov         lr, pc
  00130	e12fff13	 bx          r3

; 200  : 
; 201  :         // mask the pending interrupt
; 202  :         mask |= trans.mBuffer[0];

  00134	e5dd3070	 ldrb        r3, [sp, #0x70]

; 203  :         trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 204  :         trans.mBufferOffset[0] = 0;
; 205  :         trans.mTransLen[0] = 2;
; 206  :         trans.mBuffer[0] = MENELAUS_INTMASK2_OFFSET;
; 207  :         trans.mBuffer[1] = mask;
; 208  : 
; 209  :         I2CTransact(pDevice->hI2C, &trans);

  00138	e5952010	 ldr         r2, [r5, #0x10]
  0013c	e3a05002	 mov         r5, #2
  00140	e1833004	 orr         r3, r3, r4
  00144	e3a01000	 mov         r1, #0
  00148	e3a00002	 mov         r0, #2
  0014c	e3a0e018	 mov         lr, #0x18
  00150	e5cd3071	 strb        r3, [sp, #0x71]
  00154	e58d500c	 str         r5, [sp, #0xC]
  00158	e58d102c	 str         r1, [sp, #0x2C]
  0015c	e58d004c	 str         r0, [sp, #0x4C]
  00160	e5cde070	 strb        lr, [sp, #0x70]
  00164	e5920000	 ldr         r0, [r2]
  00168	e5923008	 ldr         r3, [r2, #8]
  0016c	e28d1000	 add         r1, sp, #0
  00170	e1a0e00f	 mov         lr, pc
  00174	e12fff13	 bx          r3
  00178		 |$LN13@SetTritonI|

; 210  :     }
; 211  : 
; 212  :     return (trans.mErrorCode == 0);

  00178	e59d306c	 ldr         r3, [sp, #0x6C]
  0017c	e3530000	 cmp         r3, #0
  00180	03a04001	 moveq       r4, #1
  00184	13a04000	 movne       r4, #0
  00188	e59d0170	 ldr         r0, [sp, #0x170]
  0018c	eb000000	 bl          __security_check_cookie

; 213  : }

  00190	e1a00004	 mov         r0, r4
  00194	e28ddf5d	 add         sp, sp, #0x5D, 30
  00198	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0019c	e12fff1e	 bx          lr
  001a0		 |$LN18@SetTritonI|
  001a0		 |$LN19@SetTritonI|
  001a0	00000000	 DCD         |__security_cookie|
  001a4		 |$M43661|

			 ENDP  ; |SetTritonIrqMask|

	EXPORT	|InitializeTritonInterrupts|

  00000			 AREA	 |.pdata|, PDATA
|$T43676| DCD	|$LN5@Initialize|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializeTritonInterrupts| PROC

; 221  : {

  00000		 |$LN5@Initialize|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43673|
  00004	e3a03cff	 mov         r3, #0xFF, 24

; 222  :     // Disable all interrupts
; 223  :     return SetTritonIrqMask(pDevice, 0xffff);

  00008	e38310ff	 orr         r1, r3, #0xFF
  0000c	eb000000	 bl          SetTritonIrqMask

; 224  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M43674|

			 ENDP  ; |InitializeTritonInterrupts|

	EXPORT	|TWL_Deinit|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|KernelIoControl|
	IMPORT	|InterruptDisable|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43699| DCD	|$LN18@TWL_Deinit|
	DCD	0x40003d02
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_Deinit| PROC

; 352  : {

  00000		 |$LN18@TWL_Deinit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43696|
  00008	e1b04000	 movs        r4, r0

; 353  :     BOOL rc = FALSE;

  0000c	e3a00000	 mov         r0, #0

; 354  :     Device_t *pDevice = (Device_t*)context;
; 355  : 
; 356  : 
; 357  :     DEBUGMSG(ZONE_FUNCTION, (L"+TWL_Deinit(0x%08x)\r\n", context));
; 358  : 
; 359  :     // Check if we get correct context
; 360  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  00010	0a000032	 beq         |$cleanUp$43126|
  00014	e5942000	 ldr         r2, [r4]
  00018	e59f30d0	 ldr         r3, [pc, #0xD0]
  0001c	e1520003	 cmp         r2, r3
  00020	1a00002e	 bne         |$cleanUp$43126|

; 361  :         {
; 362  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Deinit: "
; 363  :             L"Incorrect context paramer\r\n"
; 364  :             ));
; 365  :         goto cleanUp;
; 366  :         }
; 367  : 
; 368  :     // Close interrupt thread
; 369  :     if (pDevice->hIntrThread != NULL)

  00024	e5943034	 ldr         r3, [r4, #0x34]
  00028	e3530000	 cmp         r3, #0
  0002c	0a000009	 beq         |$LN5@TWL_Deinit|

; 370  :         {
; 371  :         // Signal stop to thread
; 372  :         pDevice->intrThreadExit = TRUE;
; 373  :         // Set event to wake it
; 374  :         SetEvent(pDevice->hIntrEvent);

  00030	e5940030	 ldr         r0, [r4, #0x30]
  00034	e3a03001	 mov         r3, #1
  00038	e3a01003	 mov         r1, #3
  0003c	e5843038	 str         r3, [r4, #0x38]
  00040	eb000000	 bl          EventModify

; 375  :         // Wait until thread exits
; 376  :         WaitForSingleObject(pDevice->hIntrThread, INFINITE);

  00044	e5940034	 ldr         r0, [r4, #0x34]
  00048	e3e01000	 mvn         r1, #0
  0004c	eb000000	 bl          WaitForSingleObject

; 377  :         // Close handle
; 378  :         CloseHandle(pDevice->hIntrThread);

  00050	e5940034	 ldr         r0, [r4, #0x34]
  00054	eb000000	 bl          CloseHandle
  00058		 |$LN5@TWL_Deinit|

; 379  :         }
; 380  : 
; 381  :     // Disable interrupt
; 382  :     if (pDevice->sysIntr != 0)

  00058	e594302c	 ldr         r3, [r4, #0x2C]
  0005c	e3530000	 cmp         r3, #0
  00060	0a000009	 beq         |$LN4@TWL_Deinit|

; 383  :         {
; 384  :         InterruptDisable(pDevice->sysIntr);

  00064	e1a00003	 mov         r0, r3
  00068	eb000000	 bl          InterruptDisable

; 385  :         KernelIoControl(
; 386  :             IOCTL_HAL_RELEASE_SYSINTR, &pDevice->sysIntr,
; 387  :             sizeof(pDevice->sysIntr), NULL, 0, NULL
; 388  :             );

  0006c	e59f0078	 ldr         r0, [pc, #0x78]
  00070	e3a0e000	 mov         lr, #0
  00074	e3a03000	 mov         r3, #0
  00078	e3a02004	 mov         r2, #4
  0007c	e284102c	 add         r1, r4, #0x2C
  00080	e58de004	 str         lr, [sp, #4]
  00084	e58de000	 str         lr, [sp]
  00088	eb000000	 bl          KernelIoControl
  0008c		 |$LN4@TWL_Deinit|

; 389  :         }
; 390  : 
; 391  :     // Close interrupt handler
; 392  :     if (pDevice->hIntrEvent != NULL) CloseHandle(pDevice->hIntrEvent);

  0008c	e5943030	 ldr         r3, [r4, #0x30]
  00090	e3530000	 cmp         r3, #0
  00094	11a00003	 movne       r0, r3
  00098	1b000000	 blne        CloseHandle

; 393  : 
; 394  :     // Close I2C bus
; 395  :     if (pDevice->hI2C != NULL) I2CClose(pDevice->hI2C);

  0009c	e5943010	 ldr         r3, [r4, #0x10]
  000a0	e1b05003	 movs        r5, r3
  000a4	0a000004	 beq         |$LN12@TWL_Deinit|
  000a8	e595000c	 ldr         r0, [r5, #0xC]
  000ac	e3700001	 cmn         r0, #1
  000b0	1b000000	 blne        CloseHandle
  000b4	e1a00005	 mov         r0, r5
  000b8	eb000000	 bl          LocalFree
  000bc		 |$LN12@TWL_Deinit|

; 396  :     if (pDevice->hICX != NULL) CloseHandle(pDevice->hICX);

  000bc	e5943014	 ldr         r3, [r4, #0x14]
  000c0	e3530000	 cmp         r3, #0
  000c4	11a00003	 movne       r0, r3
  000c8	1b000000	 blne        CloseHandle

; 397  : 
; 398  :     // Delete critical section
; 399  :     DeleteCriticalSection(&pDevice->cs);

  000cc	e2840018	 add         r0, r4, #0x18
  000d0	eb000000	 bl          DeleteCriticalSection

; 400  : 
; 401  :     // Free device structure
; 402  :     LocalFree(pDevice);

  000d4	e1a00004	 mov         r0, r4
  000d8	eb000000	 bl          LocalFree

; 403  : 
; 404  :     // Done
; 405  :     rc = TRUE;

  000dc	e3a00001	 mov         r0, #1
  000e0		 |$cleanUp$43126|

; 406  : 
; 407  : cleanUp:
; 408  :     DEBUGMSG(ZONE_FUNCTION, (L"-TWL_Deinit(rc = %d)\r\n", rc));
; 409  :     return rc;
; 410  : }

  000e0	e28dd008	 add         sp, sp, #8
  000e4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$LN19@TWL_Deinit|
  000ec		 |$LN20@TWL_Deinit|
  000ec	010100d8	 DCD         0x10100d8
  000f0		 |$LN21@TWL_Deinit|
  000f0	74776c44	 DCD         0x74776c44
  000f4		 |$M43697|

			 ENDP  ; |TWL_Deinit|

	EXPORT	|TWL_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T43712| DCD	|$LN5@TWL_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_Open| PROC

; 424  : {

  00000		 |$LN5@TWL_Open|
  00000		 |$M43709|

; 425  :     return context;
; 426  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43710|

			 ENDP  ; |TWL_Open|

	EXPORT	|TWL_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T43721| DCD	|$LN5@TWL_Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_Close| PROC

; 438  : {

  00000		 |$LN5@TWL_Close|
  00000		 |$M43718|

; 439  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 440  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M43719|

			 ENDP  ; |TWL_Close|

	IMPORT	|InterruptDone|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43748| DCD	|$LN25@TWL_IntrTh|
	DCD	0x40004702
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_IntrThread| PROC

; 574  : {

  00000		 |$LN25@TWL_IntrTh|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M43745|
  00008	e1a05000	 mov         r5, r0

; 575  :     Device_t *pDevice = (Device_t*)pContext;
; 576  :     DWORD id;
; 577  :     UINT16 status;
; 578  :     UINT16 currMask;
; 579  : 
; 580  :     // Loop until we are stopped...
; 581  :     while (!pDevice->intrThreadExit) {

  0000c	e5953038	 ldr         r3, [r5, #0x38]
  00010	e3530000	 cmp         r3, #0
  00014	1a00003b	 bne         |$LN22@TWL_IntrTh|
  00018	e3a07000	 mov         r7, #0
  0001c		 |$LL10@TWL_IntrTh|

; 582  :         // Wait for event
; 583  :         WaitForSingleObject(pDevice->hIntrEvent, INFINITE);

  0001c	e5950030	 ldr         r0, [r5, #0x30]
  00020	e3e01000	 mvn         r1, #0
  00024	eb000000	 bl          WaitForSingleObject

; 584  :         if (pDevice->intrThreadExit) break;

  00028	e5953038	 ldr         r3, [r5, #0x38]
  0002c	e3530000	 cmp         r3, #0
  00030	1a000034	 bne         |$LN22@TWL_IntrTh|

; 585  : 
; 586  :         // Get interrupt status register
; 587  :         if (GetTritonIrqStatus(pDevice, &status) && GetTritonIrqMask(pDevice, &currMask)) {

  00034	e28d1008	 add         r1, sp, #8
  00038	e1a00005	 mov         r0, r5
  0003c	eb000000	 bl          GetTritonIrqStatus
  00040	e3500000	 cmp         r0, #0
  00044	0a000025	 beq         |$LN5@TWL_IntrTh|
  00048	e28d100a	 add         r1, sp, #0xA
  0004c	e1a00005	 mov         r0, r5
  00050	eb000000	 bl          GetTritonIrqMask
  00054	e3500000	 cmp         r0, #0
  00058	0a000020	 beq         |$LN5@TWL_IntrTh|

; 588  :             // Diable all interrupts
; 589  :             SetTritonIrqMask(pDevice, status);

  0005c	e1dd40b8	 ldrh        r4, [sp, #8]
  00060	e1a00005	 mov         r0, r5
  00064	e1a01004	 mov         r1, r4
  00068	eb000000	 bl          SetTritonIrqMask

; 590  : 
; 591  :             // Process each unmasked interrupt
; 592  :             status &= ~currMask;

  0006c	e1dd30ba	 ldrh        r3, [sp, #0xA]

; 593  :             id = 0;

  00070	e3a06000	 mov         r6, #0
  00074	e1c44003	 bic         r4, r4, r3
  00078	e1cd40b8	 strh        r4, [sp, #8]

; 594  :             while (status != 0) {

  0007c	e1b03004	 movs        r3, r4
  00080	0a000016	 beq         |$LN5@TWL_IntrTh|
  00084		 |$LL6@TWL_IntrTh|

; 595  :                 if ((status & 0x0001) != 0) {

  00084	e3130001	 tst         r3, #1
  00088	0a00000d	 beq         |$LN2@TWL_IntrTh|

; 596  :                     if (pDevice->hSetIntrEvent[id] != NULL) {

  0008c	e0853106	 add         r3, r5, r6, lsl #2
  00090	e593303c	 ldr         r3, [r3, #0x3C]
  00094	e3530000	 cmp         r3, #0

; 597  :                         SetEvent(pDevice->hSetIntrEvent[id]);

  00098	13a01003	 movne       r1, #3
  0009c	11a00003	 movne       r0, r3
  000a0	1b000000	 blne        EventModify

; 598  :                     }
; 599  : 
; 600  :                     // If this is a RTC alarm interrupt, let oal handle the interrupt.
; 601  :                     if (id == TWL_INTR_RTCALM) {

  000a4	e3560009	 cmp         r6, #9

; 602  :                         KernelIoControl(IOCTL_HAL_RTC_ALARM, NULL, 0, NULL, 0, NULL);

  000a8	059f0068	 ldreq       r0, [pc, #0x68]
  000ac	03a03000	 moveq       r3, #0
  000b0	03a02000	 moveq       r2, #0
  000b4	03a01000	 moveq       r1, #0
  000b8	058d7004	 streq       r7, [sp, #4]
  000bc	058d7000	 streq       r7, [sp]
  000c0	0b000000	 bleq        KernelIoControl
  000c4		 |$LN2@TWL_IntrTh|

; 603  :                     }
; 604  :                 }
; 605  :                 status >>= 1;

  000c4	e1a030a4	 mov         r3, r4, lsr #1
  000c8	e1a04803	 mov         r4, r3, lsl #16
  000cc	e1a04824	 mov         r4, r4, lsr #16
  000d0	e1b03004	 movs        r3, r4

; 606  :                 id++;

  000d4	e2866001	 add         r6, r6, #1
  000d8	1affffe9	 bne         |$LL6@TWL_IntrTh|

; 603  :                     }
; 604  :                 }
; 605  :                 status >>= 1;

  000dc	e1cd40b8	 strh        r4, [sp, #8]
  000e0		 |$LN5@TWL_IntrTh|

; 607  :             }
; 608  :         }
; 609  :         // Set fake interrupt event
; 610  :         if (pDevice->hSetIntrEvent[16] != NULL) {

  000e0	e595307c	 ldr         r3, [r5, #0x7C]
  000e4	e3530000	 cmp         r3, #0

; 611  :             // Use pulse event there in case that event is already
; 612  :             // signaled as associated with some interrupt...
; 613  :             PulseEvent(pDevice->hSetIntrEvent[16]);

  000e8	13a01001	 movne       r1, #1
  000ec	11a00003	 movne       r0, r3
  000f0	1b000000	 blne        EventModify

; 614  :         }
; 615  :         
; 616  :         InterruptDone(pDevice->sysIntr);

  000f4	e595002c	 ldr         r0, [r5, #0x2C]
  000f8	eb000000	 bl          InterruptDone
  000fc	e5953038	 ldr         r3, [r5, #0x38]
  00100	e3530000	 cmp         r3, #0
  00104	0affffc4	 beq         |$LL10@TWL_IntrTh|
  00108		 |$LN22@TWL_IntrTh|

; 617  :     }
; 618  : 
; 619  :     return ERROR_SUCCESS;

  00108	e3a00000	 mov         r0, #0

; 620  : }

  0010c	e28dd00c	 add         sp, sp, #0xC
  00110	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00114	e12fff1e	 bx          lr
  00118		 |$LN26@TWL_IntrTh|
  00118		 |$LN27@TWL_IntrTh|
  00118	01011008	 DCD         0x1011008
  0011c		 |$M43746|

			 ENDP  ; |TWL_IntrThread|

	IMPORT	|DuplicateHandle|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43770| DCD	|$LN19@TWL_SetInt|
	DCD	0x40003002
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_SetIntrEvent| PROC

; 692  : {

  00000		 |$LN19@TWL_SetInt|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M43767|
  00008	e1a04002	 mov         r4, r2
  0000c	e3500000	 cmp         r0, #0

; 693  :     BOOL rc = FALSE;

  00010	e3a05000	 mov         r5, #0

; 694  :     Device_t *pDevice = (Device_t*)context;
; 695  : 
; 696  :     // Check if we get correct context
; 697  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE)) {

  00014	0a000024	 beq         |$cleanUp$43298|
  00018	e590e000	 ldr         lr, [r0]
  0001c	e59f3098	 ldr         r3, [pc, #0x98]
  00020	e15e0003	 cmp         lr, r3
  00024	1a000020	 bne         |$cleanUp$43298|

; 698  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_SetIntrEvent: "
; 699  :             L"Incorrect context parameter\r\n"
; 700  :             ));
; 701  :         goto cleanUp;
; 702  :     }
; 703  : 
; 704  :     if ((intrId > 16) && (intrId != (-1))) {

  00028	e3510010	 cmp         r1, #0x10
  0002c	9a000001	 bls         |$LN7@TWL_SetInt|
  00030	e3710001	 cmn         r1, #1
  00034	1a00001c	 bne         |$cleanUp$43298|
  00038		 |$LN7@TWL_SetInt|

; 705  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_SetIntrEvent: "
; 706  :             L"Incorrect interrupt Id %d\r\n", intrId
; 707  :             ));
; 708  :         goto cleanUp;
; 709  :     }
; 710  : 
; 711  :     // Common interrupt is stored in last position
; 712  :     if (intrId == (-1)) intrId = 16;

  00038	e3710001	 cmn         r1, #1
  0003c	03a01010	 moveq       r1, #0x10

; 713  : 
; 714  :     // If handle isn't NULL we set new association, 
; 715  :     // otherwise we delete it....
; 716  :     if (hEvent != NULL) {

  00040	e3540000	 cmp         r4, #0
  00044	0a00000f	 beq         |$LN5@TWL_SetInt|

; 717  :         if (pDevice->hSetIntrEvent[intrId] != NULL) {

  00048	e0803101	 add         r3, r0, r1, lsl #2
  0004c	e593303c	 ldr         r3, [r3, #0x3C]
  00050	e3530000	 cmp         r3, #0
  00054	1a000014	 bne         |$cleanUp$43298|

; 718  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_SetIntrEvent: "
; 719  :                 L"Interrupt Id %d already associated with event\r\n"
; 720  :                 ));
; 721  :             goto cleanUp;
; 722  :         }
; 723  :         rc = DuplicateHandle(
; 724  :             GetCurrentProcess(), hEvent, GetCurrentProcess(),
; 725  :             &pDevice->hSetIntrEvent[intrId], 0, FALSE, DUPLICATE_SAME_ACCESS
; 726  :             );

  00058	e281300f	 add         r3, r1, #0xF
  0005c	e0803103	 add         r3, r0, r3, lsl #2
  00060	e3a0e002	 mov         lr, #2
  00064	e3a05000	 mov         r5, #0
  00068	e3a00042	 mov         r0, #0x42
  0006c	e3a02042	 mov         r2, #0x42
  00070	e1a01004	 mov         r1, r4
  00074	e58de008	 str         lr, [sp, #8]
  00078	e58d5004	 str         r5, [sp, #4]
  0007c	e58d5000	 str         r5, [sp]
  00080	eb000000	 bl          DuplicateHandle

; 727  : 
; 728  :         if (!rc) {
; 729  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_SetIntrEvent: "
; 730  :                 L"Event handler duplication failed\r\n"
; 731  :                 ));
; 732  :             goto cleanUp;
; 733  :         }
; 734  :     }
; 735  :     else {

  00084	ea000007	 b           |$LN16@TWL_SetInt|
  00088		 |$LN5@TWL_SetInt|

; 736  :         if (pDevice->hSetIntrEvent[intrId] == NULL) {

  00088	e0804101	 add         r4, r0, r1, lsl #2
  0008c	e594303c	 ldr         r3, [r4, #0x3C]
  00090	e3530000	 cmp         r3, #0
  00094	0a000004	 beq         |$cleanUp$43298|

; 737  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_SetIntrEvent: "
; 738  :                 L"Interrupt Id %d isn't associated with event\r\n"
; 739  :                 ));
; 740  :             goto cleanUp;
; 741  :         }
; 742  :         rc = CloseHandle(pDevice->hSetIntrEvent[intrId]);

  00098	e1a00003	 mov         r0, r3
  0009c	eb000000	 bl          CloseHandle

; 743  :         pDevice->hSetIntrEvent[intrId] = NULL;

  000a0	e3a03000	 mov         r3, #0
  000a4	e584303c	 str         r3, [r4, #0x3C]
  000a8		 |$LN16@TWL_SetInt|
  000a8	e1a05000	 mov         r5, r0
  000ac		 |$cleanUp$43298|

; 744  :     }
; 745  :             
; 746  : cleanUp:
; 747  :     return rc;
; 748  : }

  000ac	e1a00005	 mov         r0, r5
  000b0	e28dd00c	 add         sp, sp, #0xC
  000b4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$LN20@TWL_SetInt|
  000bc		 |$LN21@TWL_SetInt|
  000bc	74776c44	 DCD         0x74776c44
  000c0		 |$M43768|

			 ENDP  ; |TWL_SetIntrEvent|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|ReadRegs|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43798| DCD	|$LN9@ReadRegs|
	DCD	0xc0002e02

  00000			 AREA	 |.xdata|, DATA
|$T43794| DCD	0xffffffe4
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43794|

  00008		 |ReadRegs| PROC

; 891  : {

  00008		 |$LN9@ReadRegs|
  00008	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  0000c	e24ddf5d	 sub         sp, sp, #0x5D, 30
  00010		 |$M43795|
  00010	e1a06002	 mov         r6, r2
  00014	e1a05001	 mov         r5, r1
  00018	e1a04000	 mov         r4, r0
  0001c	e59f3098	 ldr         r3, [pc, #0x98]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3170	 str         r3, [sp, #0x170]

; 892  :     I2CTRANS trans;
; 893  : 
; 894  :     ZeroMemory(&trans,sizeof(trans));

  00028	e3a02e17	 mov         r2, #0x17, 28
  0002c	e3a01000	 mov         r1, #0
  00030	e28d0000	 add         r0, sp, #0
  00034	eb000000	 bl          memset

; 895  : 
; 896  :     trans.mClk_HL_Divisor = I2C_CLOCK_100Khz;
; 897  :     /* first write register address */
; 898  :     trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 899  :     trans.mBufferOffset[0] = 0;
; 900  :     trans.mTransLen[0] = 1;
; 901  :     trans.mBuffer[0] = (BYTE)address;
; 902  :     /* then read back data from that address */
; 903  :     trans.mOpCode[1] = I2C_OPCODE_READ;
; 904  :     trans.mBufferOffset[1] = 0;
; 905  :     trans.mTransLen[1] = 1;
; 906  : 
; 907  :     I2CTransact(pDevice->hI2C, &trans);

  00038	e5943010	 ldr         r3, [r4, #0x10]
  0003c	e3a0e001	 mov         lr, #1
  00040	e3a04001	 mov         r4, #1
  00044	e3a0203c	 mov         r2, #0x3C
  00048	e3a01002	 mov         r1, #2
  0004c	e3a00000	 mov         r0, #0
  00050	e3a07000	 mov         r7, #0
  00054	e3a08001	 mov         r8, #1
  00058	e58de04c	 str         lr, [sp, #0x4C]
  0005c	e58d4010	 str         r4, [sp, #0x10]
  00060	e58d2008	 str         r2, [sp, #8]
  00064	e58d100c	 str         r1, [sp, #0xC]
  00068	e58d002c	 str         r0, [sp, #0x2C]
  0006c	e5cd5070	 strb        r5, [sp, #0x70]
  00070	e58d7030	 str         r7, [sp, #0x30]
  00074	e58d8050	 str         r8, [sp, #0x50]
  00078	e5930000	 ldr         r0, [r3]
  0007c	e5933008	 ldr         r3, [r3, #8]
  00080	e28d1000	 add         r1, sp, #0
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 908  : 
; 909  :     *pBuffer = trans.mBuffer[0];
; 910  : 
; 911  :     return (trans.mErrorCode == 0);

  0008c	e59d206c	 ldr         r2, [sp, #0x6C]
  00090	e5dd3070	 ldrb        r3, [sp, #0x70]
  00094	e3520000	 cmp         r2, #0
  00098	03a04001	 moveq       r4, #1
  0009c	13a04000	 movne       r4, #0
  000a0	e5c63000	 strb        r3, [r6]
  000a4	e59d0170	 ldr         r0, [sp, #0x170]
  000a8	eb000000	 bl          __security_check_cookie

; 912  : }

  000ac	e1a00004	 mov         r0, r4
  000b0	e28ddf5d	 add         sp, sp, #0x5D, 30
  000b4	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$LN10@ReadRegs|
  000bc		 |$LN11@ReadRegs|
  000bc	00000000	 DCD         |__security_cookie|
  000c0		 |$M43796|

			 ENDP  ; |ReadRegs|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|WriteRegs|
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\inc\i2c.h

  00000			 AREA	 |.pdata|, PDATA
|$T43827| DCD	|$LN9@WriteRegs|
	DCD	0xc0002802

  00000			 AREA	 |.xdata|, DATA
|$T43823| DCD	0xffffffec
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T43823|

  00008		 |WriteRegs| PROC

; 923  : {

  00008		 |$LN9@WriteRegs|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24ddf5d	 sub         sp, sp, #0x5D, 30
  00010		 |$M43824|
  00010	e1a05002	 mov         r5, r2
  00014	e1a06001	 mov         r6, r1
  00018	e1a04000	 mov         r4, r0
  0001c	e59f3080	 ldr         r3, [pc, #0x80]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3170	 str         r3, [sp, #0x170]

; 924  :     I2CTRANS trans;
; 925  : 
; 926  :     ZeroMemory(&trans,sizeof(trans));

  00028	e3a02e17	 mov         r2, #0x17, 28
  0002c	e3a01000	 mov         r1, #0
  00030	e28d0000	 add         r0, sp, #0
  00034	eb000000	 bl          memset

; 927  :     
; 928  :     trans.mClk_HL_Divisor = I2C_CLOCK_100Khz;
; 929  : 
; 930  :     /* just write the register # then the data in one shot */
; 931  :     trans.mOpCode[0] = I2C_OPCODE_WRITE;
; 932  :     trans.mBufferOffset[0] = 0;
; 933  :     trans.mTransLen[0] = 2;
; 934  :     trans.mBuffer[0] = (BYTE)address;
; 935  :     trans.mBuffer[1] = ((UCHAR*)pBuffer)[0];

  00038	e5d53000	 ldrb        r3, [r5]

; 936  : 
; 937  :     I2CTransact(pDevice->hI2C, &trans);

  0003c	e5942010	 ldr         r2, [r4, #0x10]
  00040	e3a0103c	 mov         r1, #0x3C
  00044	e3a00002	 mov         r0, #2
  00048	e3a0e000	 mov         lr, #0
  0004c	e3a04002	 mov         r4, #2
  00050	e5cd3071	 strb        r3, [sp, #0x71]
  00054	e58d1008	 str         r1, [sp, #8]
  00058	e58d000c	 str         r0, [sp, #0xC]
  0005c	e58de02c	 str         lr, [sp, #0x2C]
  00060	e58d404c	 str         r4, [sp, #0x4C]
  00064	e5cd6070	 strb        r6, [sp, #0x70]
  00068	e5920000	 ldr         r0, [r2]
  0006c	e5923008	 ldr         r3, [r2, #8]
  00070	e28d1000	 add         r1, sp, #0
  00074	e1a0e00f	 mov         lr, pc
  00078	e12fff13	 bx          r3

; 938  : 
; 939  :     return (trans.mErrorCode == 0);

  0007c	e59d306c	 ldr         r3, [sp, #0x6C]
  00080	e3530000	 cmp         r3, #0
  00084	03a04001	 moveq       r4, #1
  00088	13a04000	 movne       r4, #0
  0008c	e59d0170	 ldr         r0, [sp, #0x170]
  00090	eb000000	 bl          __security_check_cookie

; 940  : }

  00094	e1a00004	 mov         r0, r4
  00098	e28ddf5d	 add         sp, sp, #0x5D, 30
  0009c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN10@WriteRegs|
  000a4		 |$LN11@WriteRegs|
  000a4	00000000	 DCD         |__security_cookie|
  000a8		 |$M43825|

			 ENDP  ; |WriteRegs|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|

  00000			 AREA	 |.pdata|, PDATA
|$T43841| DCD	|$LN8@DllMain|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 956  : {

  00000		 |$LN8@DllMain|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43838|

; 957  :     switch (reason)

  00004	e3510001	 cmp         r1, #1

; 958  :         {
; 959  :         case DLL_PROCESS_ATTACH:
; 960  :             DEBUGREGISTER(hDLL);
; 961  :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00008	0b000000	 bleq        DisableThreadLibraryCalls

; 962  :             break;
; 963  :         }
; 964  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 965  : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M43839|

			 ENDP  ; |DllMain|

	EXPORT	|TWL_Init|
	EXPORT	|??_C@_1M@LCEEOPDH@?$AAI?$AA2?$AAC?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43863| DCD	|$LN20@TWL_Init|
	DCD	0x40005c02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@LCEEOPDH@?$AAI?$AA2?$AAC?$AA1?$AA?3?$AA?$AA@| DCB "I", 0x0, "2", 0x0
	DCB	"C", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_Init| PROC

; 237  : {

  00000		 |$LN20@TWL_Init|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M43860|
  00008	e1a06000	 mov         r6, r0

; 238  :     DWORD rc = (DWORD)NULL;
; 239  :     Device_t *pDevice = NULL;
; 240  : 
; 241  :     DEBUGMSG(ZONE_FUNCTION, (
; 242  :         L"+TWL_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 243  :         ));
; 244  : 
; 245  :     // Create device structure
; 246  :     pDevice = (Device_t *)LocalAlloc(LPTR, sizeof(Device_t));

  0000c	e3a01080	 mov         r1, #0x80
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a05000	 mov         r5, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 247  :     if (pDevice == NULL)

  00020	0a000047	 beq         |$LN17@TWL_Init|

; 248  :         {
; 249  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 250  :             L"Failed allocate TWL controller structure\r\n"
; 251  :             ));
; 252  :         goto cleanUp;
; 253  :         }
; 254  : 
; 255  :     // Set cookie
; 256  :     pDevice->cookie = TWL_DEVICE_COOKIE;

  00024	e59f3140	 ldr         r3, [pc, #0x140]

; 257  : 
; 258  :     // Initalize critical section
; 259  :     InitializeCriticalSection(&pDevice->cs);

  00028	e1a00004	 mov         r0, r4
  0002c	e4803018	 str         r3, [r0], #0x18
  00030	eb000000	 bl          InitializeCriticalSection

; 260  : 
; 261  :     // Read device parameters
; 262  :     if (GetDeviceRegistryParams(
; 263  :             szContext, pDevice, dimof(s_deviceRegParams), s_deviceRegParams
; 264  :             ) != ERROR_SUCCESS)

  00034	e59f312c	 ldr         r3, [pc, #0x12C]
  00038	e3a02003	 mov         r2, #3
  0003c	e1a01004	 mov         r1, r4
  00040	e1a00006	 mov         r0, r6
  00044	eb000000	 bl          GetDeviceRegistryParams
  00048	e3500000	 cmp         r0, #0
  0004c	1a00003c	 bne         |$LN17@TWL_Init|

; 265  :         {
; 266  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 267  :             L"Failed read TWL driver registry parameters\r\n"
; 268  :             ));
; 269  :         goto cleanUp;
; 270  :         }
; 271  : 
; 272  :     // Open parent bus
; 273  :     pDevice->hI2C = I2COpen(I2C_DEVICE_NAME);

  00050	e59f010c	 ldr         r0, [pc, #0x10C]
  00054	eb000000	 bl          I2COpen
  00058	e1b03000	 movs        r3, r0
  0005c	e5843010	 str         r3, [r4, #0x10]

; 274  :     if (pDevice->hI2C == NULL) {

  00060	0a000037	 beq         |$LN17@TWL_Init|

; 275  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 276  :             L"Failed open I2C bus driver\r\n"
; 277  :             ));
; 278  :         goto cleanUp;
; 279  :     }
; 280  : 
; 281  :     // Set Triton I2C address
; 282  :     if (!I2CSetSlaveAddress(pDevice->hI2C, 7, I2C_MENELAUS_ADDRESS)) {

  00064	e5930000	 ldr         r0, [r3]
  00068	e5933004	 ldr         r3, [r3, #4]
  0006c	e3a02072	 mov         r2, #0x72
  00070	e3a01007	 mov         r1, #7
  00074	e1a0e00f	 mov         lr, pc
  00078	e12fff13	 bx          r3
  0007c	e3500000	 cmp         r0, #0
  00080	0a00002f	 beq         |$LN17@TWL_Init|
  00084	e3a03cff	 mov         r3, #0xFF, 24

; 283  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 284  :             L"Failed set I2C bus slave address\r\n"
; 285  :             ));
; 286  :         goto cleanUp;
; 287  :     }
; 288  : 
; 289  :     // Disable all interrupts
; 290  :     if (InitializeTritonInterrupts(pDevice) == FALSE) goto cleanUp;

  00088	e38310ff	 orr         r1, r3, #0xFF
  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          SetTritonIrqMask
  00094	e3500000	 cmp         r0, #0
  00098	0a000029	 beq         |$LN17@TWL_Init|

; 291  : 
; 292  :     pDevice->irq = IRQ_SYS_NIRQ;
; 293  :     // Map interrupt
; 294  :     if (!KernelIoControl(
; 295  :             IOCTL_HAL_REQUEST_SYSINTR, &pDevice->irq, sizeof(pDevice->irq),
; 296  :             &pDevice->sysIntr, sizeof(pDevice->sysIntr), NULL) ) {

  0009c	e59f00bc	 ldr         r0, [pc, #0xBC]
  000a0	e3a0e007	 mov         lr, #7
  000a4	e3a06004	 mov         r6, #4
  000a8	e3a07000	 mov         r7, #0
  000ac	e284302c	 add         r3, r4, #0x2C
  000b0	e3a02004	 mov         r2, #4
  000b4	e2841004	 add         r1, r4, #4
  000b8	e584e004	 str         lr, [r4, #4]
  000bc	e58d7004	 str         r7, [sp, #4]
  000c0	e58d6000	 str         r6, [sp]
  000c4	eb000000	 bl          KernelIoControl
  000c8	e3500000	 cmp         r0, #0
  000cc	0a00001c	 beq         |$LN17@TWL_Init|

; 297  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 298  :             L"Failed map Triton interrupt (%d)\r\n", pDevice->irq
; 299  :             ));
; 300  :         goto cleanUp;
; 301  :     }
; 302  : 
; 303  :     // Create interrupt event
; 304  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  000d0	e3a03000	 mov         r3, #0
  000d4	e3a02000	 mov         r2, #0
  000d8	e3a01000	 mov         r1, #0
  000dc	e3a00000	 mov         r0, #0
  000e0	eb000000	 bl          CreateEventW
  000e4	e1b01000	 movs        r1, r0
  000e8	e5841030	 str         r1, [r4, #0x30]

; 305  :     if (pDevice->hIntrEvent == NULL) {

  000ec	0a000014	 beq         |$LN17@TWL_Init|

; 306  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_Init: "
; 307  :             L"Failed create interrupt event\r\n"
; 308  :             ));
; 309  :         goto cleanUp;
; 310  :     }
; 311  : 
; 312  :     // Initialize interrupt
; 313  :     if (!InterruptInitialize(pDevice->sysIntr, pDevice->hIntrEvent, NULL, 0)) {

  000f0	e594002c	 ldr         r0, [r4, #0x2C]
  000f4	e3a03000	 mov         r3, #0
  000f8	e3a02000	 mov         r2, #0
  000fc	eb000000	 bl          InterruptInitialize
  00100	e3500000	 cmp         r0, #0
  00104	0a00000e	 beq         |$LN17@TWL_Init|

; 314  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Init: "
; 315  :             L"InterruptInitialize failed\r\n"
; 316  :             ));
; 317  :         goto cleanUp;
; 318  :     }
; 319  : 
; 320  :     // Start interrupt service thread
; 321  :     pDevice->intrThreadExit = FALSE;
; 322  :     pDevice->hIntrThread = CreateThread(NULL, 0, TWL_IntrThread, pDevice, 0,NULL);

  00108	e59f204c	 ldr         r2, [pc, #0x4C]
  0010c	e1a03004	 mov         r3, r4
  00110	e3a01000	 mov         r1, #0
  00114	e3a00000	 mov         r0, #0
  00118	e5847038	 str         r7, [r4, #0x38]
  0011c	e58d7004	 str         r7, [sp, #4]
  00120	e58d7000	 str         r7, [sp]
  00124	eb000000	 bl          CreateThread
  00128	e3500000	 cmp         r0, #0
  0012c	e5840034	 str         r0, [r4, #0x34]

; 323  :     if (!pDevice->hIntrThread) {

  00130	0a000003	 beq         |$LN17@TWL_Init|

; 324  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: TWL_Init: "
; 325  :             L"Failed create interrupt thread\r\n"
; 326  :             ));
; 327  :         goto cleanUp;
; 328  :     }
; 329  : 
; 330  :     // Set thread priority
; 331  :     CeSetThreadPriority(pDevice->hIntrThread, pDevice->priority256);

  00134	e594100c	 ldr         r1, [r4, #0xC]
  00138	eb000000	 bl          CeSetThreadPriority

; 332  : 
; 333  :     // Return non-null value
; 334  :     rc = (DWORD)pDevice;

  0013c	e1a05004	 mov         r5, r4
  00140		 |$cleanUp$43086|

; 335  :     
; 336  : cleanUp:
; 337  :     if (rc == 0) TWL_Deinit((DWORD)pDevice);

  00140	ea000001	 b           |$LN1@TWL_Init|
  00144		 |$LN17@TWL_Init|
  00144	e1a00004	 mov         r0, r4
  00148	eb000000	 bl          TWL_Deinit
  0014c		 |$LN1@TWL_Init|

; 338  :     DEBUGMSG(ZONE_FUNCTION, (L"-TWL_Init(rc = %d\r\n", rc));
; 339  :     return rc;
; 340  : }

  0014c	e1a00005	 mov         r0, r5
  00150	e28dd008	 add         sp, sp, #8
  00154	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00158	e12fff1e	 bx          lr
  0015c		 |$LN21@TWL_Init|
  0015c		 |$LN22@TWL_Init|
  0015c	00000000	 DCD         |TWL_IntrThread|
  00160		 |$LN23@TWL_Init|
  00160	01010098	 DCD         0x1010098
  00164		 |$LN24@TWL_Init|
  00164	00000000	 DCD         |??_C@_1M@LCEEOPDH@?$AAI?$AA2?$AAC?$AA1?$AA?3?$AA?$AA@|
  00168		 |$LN25@TWL_Init|
  00168	00000000	 DCD         |s_deviceRegParams|
  0016c		 |$LN26@TWL_Init|
  0016c	74776c44	 DCD         0x74776c44
  00170		 |$M43861|

			 ENDP  ; |TWL_Init|


  00000			 AREA	 |.pdata|, PDATA
|$T43883| DCD	|$LN7@TWL_ReadRe|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_ReadRegs| PROC

; 632  : {

  00000		 |$LN7@TWL_ReadRe|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43880|
  00004	e1b05000	 movs        r5, r0

; 633  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 634  :     Device_t *pDevice = (Device_t*)context;
; 635  : 
; 636  :     // Check if we get correct context
; 637  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  0000c	0a000004	 beq         |$cleanUp$43266|
  00010	e5954000	 ldr         r4, [r5]
  00014	e59fe010	 ldr         lr, [pc, #0x10]
  00018	e154000e	 cmp         r4, lr

; 638  :         {
; 639  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_ReadRegs: "
; 640  :             L"Incorrect context parameter\r\n"
; 641  :             ));
; 642  :         goto cleanUp;
; 643  :         }
; 644  : 
; 645  :     rc = ReadRegs(pDevice, address, pBuffer, size);

  0001c	01a00005	 moveq       r0, r5
  00020	0b000000	 bleq        ReadRegs
  00024		 |$cleanUp$43266|

; 646  :     
; 647  : cleanUp:
; 648  :     return rc;
; 649  : }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN8@TWL_ReadRe|
  0002c		 |$LN9@TWL_ReadRe|
  0002c	74776c44	 DCD         0x74776c44
  00030		 |$M43881|

			 ENDP  ; |TWL_ReadRegs|


  00000			 AREA	 |.pdata|, PDATA
|$T43899| DCD	|$LN7@TWL_WriteR|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_WriteRegs| PROC

; 661  : {

  00000		 |$LN7@TWL_WriteR|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M43896|
  00004	e1b05000	 movs        r5, r0

; 662  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 663  :     Device_t *pDevice = (Device_t*)context;
; 664  : 
; 665  :     // Check if we get correct context
; 666  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  0000c	0a000004	 beq         |$cleanUp$43283|
  00010	e5954000	 ldr         r4, [r5]
  00014	e59fe010	 ldr         lr, [pc, #0x10]
  00018	e154000e	 cmp         r4, lr

; 667  :         {
; 668  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_WriteRegs: "
; 669  :             L"Incorrect context parameter\r\n"
; 670  :             ));
; 671  :         goto cleanUp;
; 672  :         }
; 673  : 
; 674  :     rc = WriteRegs(pDevice, address, pBuffer, size);

  0001c	01a00005	 moveq       r0, r5
  00020	0b000000	 bleq        WriteRegs
  00024		 |$cleanUp$43283|

; 675  :     
; 676  : cleanUp:
; 677  :     return rc;
; 678  : }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN8@TWL_WriteR|
  0002c		 |$LN9@TWL_WriteR|
  0002c	74776c44	 DCD         0x74776c44
  00030		 |$M43897|

			 ENDP  ; |TWL_WriteRegs|

	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T43915| DCD	|$LN12@TWL_IntrEn|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_IntrEnable| PROC

; 759  : {

  00000		 |$LN12@TWL_IntrEn|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43912|
  00008	e1a04001	 mov         r4, r1
  0000c	e1b05000	 movs        r5, r0

; 760  :     BOOL rc = FALSE;

  00010	e3a06000	 mov         r6, #0

; 761  :     Device_t *pDevice = (Device_t*)context;
; 762  :     BYTE   mask;
; 763  :     BYTE   offset;
; 764  : 
; 765  :     // Check if we get correct context
; 766  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE)) {

  00014	0a00001d	 beq         |$cleanUp$43328|
  00018	e5952000	 ldr         r2, [r5]
  0001c	e59f3084	 ldr         r3, [pc, #0x84]
  00020	e1520003	 cmp         r2, r3
  00024	1a000019	 bne         |$cleanUp$43328|

; 767  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IntrEnable: "
; 768  :             L"Incorrect context parameter\r\n"
; 769  :             ));
; 770  :         goto cleanUp;
; 771  :     }
; 772  : 
; 773  :     if (intrId > 16)

  00028	e3540010	 cmp         r4, #0x10
  0002c	8a000017	 bhi         |$cleanUp$43328|

; 774  :         {
; 775  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IntrEnable: "
; 776  :             L"Incorrect interrupt Id %d\r\n", intrId
; 777  :             ));
; 778  :         goto cleanUp;
; 779  :         }
; 780  : 
; 781  :     // We have take critical section there to avoid concurrent
; 782  :     // enable register modification
; 783  : 
; 784  :     if (intrId < 8) {

  00030	e3540008	 cmp         r4, #8

; 785  :         offset = MENELAUS_INTMASK1_OFFSET;

  00034	33a07017	 movcc       r7, #0x17

; 786  :     }
; 787  :     else {
; 788  :         offset = MENELAUS_INTMASK2_OFFSET;
; 789  :         intrId -= 8;
; 790  :     }
; 791  : 
; 792  :     EnterCriticalSection(&pDevice->cs);

  00038	e2850018	 add         r0, r5, #0x18
  0003c	23a07018	 movcs       r7, #0x18
  00040	22444008	 subcs       r4, r4, #8
  00044	eb000000	 bl          EnterCriticalSection

; 793  : 
; 794  :     // Get actual mask
; 795  :     if (!ReadRegs(pDevice, offset, &mask, sizeof(mask))) {

  00048	e3a03001	 mov         r3, #1
  0004c	e28d2000	 add         r2, sp, #0
  00050	e1a01007	 mov         r1, r7
  00054	e1a00005	 mov         r0, r5
  00058	eb000000	 bl          ReadRegs
  0005c	e3500000	 cmp         r0, #0
  00060	0a00000a	 beq         |$cleanUp$43328|

; 796  :         goto cleanUp;
; 797  :     }
; 798  : 
; 799  :     // Enable interrupt
; 800  :     mask &= ~(1 << intrId);

  00064	e5dd3000	 ldrb        r3, [sp]
  00068	e3a02001	 mov         r2, #1

; 801  : 
; 802  :     // Write it back
; 803  :     if (!WriteRegs(pDevice, offset, &mask, sizeof(mask))) {

  0006c	e1a01007	 mov         r1, r7
  00070	e1c33412	 bic         r3, r3, r2, lsl r4
  00074	e28d2000	 add         r2, sp, #0
  00078	e5cd3000	 strb        r3, [sp]
  0007c	e3a03001	 mov         r3, #1
  00080	e1a00005	 mov         r0, r5
  00084	eb000000	 bl          WriteRegs
  00088	e3500000	 cmp         r0, #0

; 804  :         goto cleanUp;
; 805  :     }
; 806  : 
; 807  :     rc = TRUE;

  0008c	13a06001	 movne       r6, #1
  00090		 |$cleanUp$43328|

; 808  :     
; 809  : cleanUp:
; 810  :     LeaveCriticalSection(&pDevice->cs);

  00090	e2850018	 add         r0, r5, #0x18
  00094	eb000000	 bl          LeaveCriticalSection

; 811  :     return rc;
; 812  : }

  00098	e1a00006	 mov         r0, r6
  0009c	e28dd004	 add         sp, sp, #4
  000a0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN13@TWL_IntrEn|
  000a8		 |$LN14@TWL_IntrEn|
  000a8	74776c44	 DCD         0x74776c44
  000ac		 |$M43913|

			 ENDP  ; |TWL_IntrEnable|


  00000			 AREA	 |.pdata|, PDATA
|$T43930| DCD	|$LN12@TWL_IntrDi|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_IntrDisable| PROC

; 823  : {

  00000		 |$LN12@TWL_IntrDi|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M43927|
  00008	e1a04001	 mov         r4, r1
  0000c	e1b05000	 movs        r5, r0

; 824  :     BOOL rc = FALSE;

  00010	e3a06000	 mov         r6, #0

; 825  :     Device_t *pDevice = (Device_t*)context;
; 826  :     BYTE   mask;
; 827  :     BYTE   offset;
; 828  : 
; 829  :     // Check if we get correct context
; 830  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE)) {

  00014	0a00001d	 beq         |$cleanUp$43349|
  00018	e5952000	 ldr         r2, [r5]
  0001c	e59f3084	 ldr         r3, [pc, #0x84]
  00020	e1520003	 cmp         r2, r3
  00024	1a000019	 bne         |$cleanUp$43349|

; 831  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IntrDisable: "
; 832  :             L"Incorrect context parameter\r\n"
; 833  :             ));
; 834  :         goto cleanUp;
; 835  :     }
; 836  : 
; 837  :     if (intrId > 16)

  00028	e3540010	 cmp         r4, #0x10
  0002c	8a000017	 bhi         |$cleanUp$43349|

; 838  :         {
; 839  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IntrDisable: "
; 840  :             L"Incorrect interrupt Id %d\r\n", intrId
; 841  :             ));
; 842  :         goto cleanUp;
; 843  :         }
; 844  :     
; 845  :     if (intrId < 8)

  00030	e3540008	 cmp         r4, #8

; 846  :         {
; 847  :         offset = MENELAUS_INTMASK1_OFFSET;

  00034	33a07017	 movcc       r7, #0x17

; 848  :         }
; 849  :     else
; 850  :         {
; 851  :         offset = MENELAUS_INTMASK2_OFFSET;
; 852  :         intrId -= 8;
; 853  :         }
; 854  : 
; 855  :     // We have take critical section there to avoid concurrent
; 856  :     // enable register modification
; 857  :     EnterCriticalSection(&pDevice->cs);

  00038	e2850018	 add         r0, r5, #0x18
  0003c	23a07018	 movcs       r7, #0x18
  00040	22444008	 subcs       r4, r4, #8
  00044	eb000000	 bl          EnterCriticalSection

; 858  : 
; 859  :     // Get actual mask
; 860  :     if (!ReadRegs(pDevice, offset, &mask, sizeof(mask))) {

  00048	e3a03001	 mov         r3, #1
  0004c	e28d2000	 add         r2, sp, #0
  00050	e1a01007	 mov         r1, r7
  00054	e1a00005	 mov         r0, r5
  00058	eb000000	 bl          ReadRegs
  0005c	e3500000	 cmp         r0, #0
  00060	0a00000a	 beq         |$cleanUp$43349|

; 861  :         goto cleanUp;
; 862  :     }
; 863  : 
; 864  :     // Disable interrupt
; 865  :     mask |= (1 << intrId);

  00064	e5dd2000	 ldrb        r2, [sp]
  00068	e3a01001	 mov         r1, #1

; 866  : 
; 867  :     // Write it back
; 868  :     if (!WriteRegs(pDevice, offset, &mask, sizeof(mask))) {

  0006c	e3a03001	 mov         r3, #1
  00070	e1820411	 orr         r0, r2, r1, lsl r4
  00074	e28d2000	 add         r2, sp, #0
  00078	e5cd0000	 strb        r0, [sp]
  0007c	e1a00005	 mov         r0, r5
  00080	e1a01007	 mov         r1, r7
  00084	eb000000	 bl          WriteRegs
  00088	e3500000	 cmp         r0, #0

; 869  :         goto cleanUp;
; 870  :     }
; 871  : 
; 872  :     rc = TRUE;

  0008c	13a06001	 movne       r6, #1
  00090		 |$cleanUp$43349|

; 873  :     
; 874  : cleanUp:
; 875  :     LeaveCriticalSection(&pDevice->cs);

  00090	e2850018	 add         r0, r5, #0x18
  00094	eb000000	 bl          LeaveCriticalSection

; 876  :     return rc;
; 877  : }

  00098	e1a00006	 mov         r0, r6
  0009c	e28dd004	 add         sp, sp, #4
  000a0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN13@TWL_IntrDi|
  000a8		 |$LN14@TWL_IntrDi|
  000a8	74776c44	 DCD         0x74776c44
  000ac		 |$M43928|

			 ENDP  ; |TWL_IntrDisable|

	EXPORT	|TWL_IOControl|
	IMPORT	|SetLastError|
	IMPORT	|CeSafeCopyMemory|
	IMPORT	|GetCallerProcess|
	IMPORT	|memcmp|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T43961| DCD	|$LN33@TWL_IOCont|
	DCD	0x40007202
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\omap2420_ms_v1\triton\triton.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TWL_IOControl| PROC

; 458  : {

  00000		 |$LN33@TWL_IOCont|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M43958|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a05002	 mov         r5, r2
  00010	e1b08000	 movs        r8, r0

; 459  :     BOOL rc = FALSE;

  00014	e3a07000	 mov         r7, #0

; 460  :     Device_t *pDevice = (Device_t*)context;
; 461  :     DEVICE_IFC_TWL ifc;
; 462  :     DWORD address, size;
; 463  : 
; 464  : 
; 465  :     DEBUGMSG(ZONE_FUNCTION, (
; 466  :         L"+TWL_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 467  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 468  :         ));
; 469  : 
; 470  :     // Check if we get correct context
; 471  :     if ((pDevice == NULL) || (pDevice->cookie != TWL_DEVICE_COOKIE))

  00018	0a00005e	 beq         |$cleanUp$43178|
  0001c	e5984000	 ldr         r4, [r8]
  00020	e59fe19c	 ldr         lr, [pc, #0x19C]
  00024	e154000e	 cmp         r4, lr
  00028	1a00005a	 bne         |$cleanUp$43178|
  0002c	e3a03822	 mov         r3, #0x22, 16

; 472  :         {
; 473  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IOControl: "
; 474  :             L"Incorrect context paramer\r\n"
; 475  :             ));
; 476  :         goto cleanUp;
; 477  :         }
; 478  : 
; 479  :     switch (code)

  00030	e383eb01	 orr         lr, r3, #1, 22
  00034	e151000e	 cmp         r1, lr
  00038	0a000028	 beq         |$LN19@TWL_IOCont|
  0003c	e3a03822	 mov         r3, #0x22, 16
  00040	e383eb03	 orr         lr, r3, #3, 22
  00044	e151000e	 cmp         r1, lr
  00048	0a000011	 beq         |$LN10@TWL_IOCont|
  0004c	e59fe16c	 ldr         lr, [pc, #0x16C]
  00050	e151000e	 cmp         r1, lr
  00054	1a00004f	 bne         |$cleanUp$43178|

; 539  :             break;
; 540  :         case IOCTL_TWL_WRITEREGS:
; 541  :             if ((pInBuffer == NULL) || 
; 542  :                 (inSize < sizeof(IOCTL_TWL_WRITEREGS_IN)))

  00058	e3550000	 cmp         r5, #0
  0005c	0a00004b	 beq         |$LN16@TWL_IOCont|
  00060	e3560008	 cmp         r6, #8
  00064	3a000049	 bcc         |$LN16@TWL_IOCont|

; 543  :                 {
; 544  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 545  :                 break;
; 546  :                 }
; 547  :             address = ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)->address;
; 548  :             size = ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)->size;

  00068	e5952004	 ldr         r2, [r5, #4]
  0006c	e5951000	 ldr         r1, [r5]

; 549  :             if (inSize < (sizeof(IOCTL_TWL_WRITEREGS_IN) + size))

  00070	e2823008	 add         r3, r2, #8
  00074	e1560003	 cmp         r6, r3

; 550  :                 {
; 551  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 552  :                 break;

  00078	3a000044	 bcc         |$LN16@TWL_IOCont|

; 553  :                 }
; 554  :             ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)++;
; 555  :             rc = WriteRegs(pDevice, address, pInBuffer, size);

  0007c	e1a03002	 mov         r3, r2
  00080	e2852008	 add         r2, r5, #8
  00084	e1a00008	 mov         r0, r8
  00088	eb000000	 bl          WriteRegs
  0008c	e1a07000	 mov         r7, r0
  00090	ea000040	 b           |$cleanUp$43178|
  00094		 |$LN10@TWL_IOCont|

; 519  :                 break;
; 520  :                 }
; 521  :             SetLastError(ERROR_INVALID_PARAMETER);
; 522  :             break;
; 523  :         case IOCTL_TWL_READREGS:
; 524  :             if ((pInBuffer == NULL) || 
; 525  :                 (inSize < sizeof(IOCTL_TWL_READREGS_IN)))

  00094	e3550000	 cmp         r5, #0
  00098	0a00003c	 beq         |$LN16@TWL_IOCont|
  0009c	e3560008	 cmp         r6, #8
  000a0	3a00003a	 bcc         |$LN16@TWL_IOCont|

; 526  :                 {
; 527  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 528  :                 break;
; 529  :                 }
; 530  :             address = ((IOCTL_TWL_READREGS_IN*)pInBuffer)->address;
; 531  :             size = ((IOCTL_TWL_READREGS_IN*)pInBuffer)->size;
; 532  :             if (pOutSize != NULL) *pOutSize = size;

  000a4	e59d203c	 ldr         r2, [sp, #0x3C]
  000a8	e5953004	 ldr         r3, [r5, #4]
  000ac	e5951000	 ldr         r1, [r5]
  000b0	e3520000	 cmp         r2, #0
  000b4	15823000	 strne       r3, [r2]

; 533  :             if ((pOutBuffer == NULL) || (outSize < size))

  000b8	e59d2034	 ldr         r2, [sp, #0x34]
  000bc	e3520000	 cmp         r2, #0
  000c0	0a000032	 beq         |$LN16@TWL_IOCont|
  000c4	e59d0038	 ldr         r0, [sp, #0x38]
  000c8	e1500003	 cmp         r0, r3
  000cc	3a00002f	 bcc         |$LN16@TWL_IOCont|

; 534  :                 {
; 535  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 536  :                 break;
; 537  :                 }
; 538  :             rc = ReadRegs(pDevice, address, pOutBuffer, size);

  000d0	e1a00008	 mov         r0, r8
  000d4	eb000000	 bl          ReadRegs

; 553  :                 }
; 554  :             ((IOCTL_TWL_WRITEREGS_IN*)pInBuffer)++;
; 555  :             rc = WriteRegs(pDevice, address, pInBuffer, size);

  000d8	e1a07000	 mov         r7, r0
  000dc	ea00002d	 b           |$cleanUp$43178|
  000e0		 |$LN19@TWL_IOCont|

; 480  :         {
; 481  :         case IOCTL_DDK_GET_DRIVER_IFC:
; 482  :             // We can give interface only to our peer in device process
; 483  :             if (GetCurrentProcessId() != (DWORD)GetCallerProcess())

  000e0	e3a0000c	 mov         r0, #0xC
  000e4	eb000000	 bl          __GetUserKData
  000e8	e1a04000	 mov         r4, r0
  000ec	eb000000	 bl          GetCallerProcess
  000f0	e1540000	 cmp         r4, r0

; 484  :                 {
; 485  :                 DEBUGMSG(ZONE_ERROR, (L"ERROR: TWL_IOControl: "
; 486  :                     L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 487  :                     L"device process (caller process id 0x%08x)\r\n",
; 488  :                     GetCallerProcess()
; 489  :                     ));
; 490  :                 SetLastError(ERROR_ACCESS_DENIED);

  000f4	13a00005	 movne       r0, #5
  000f8	1a000025	 bne         |$LN29@TWL_IOCont|

; 491  :                 break;
; 492  :                 }
; 493  :             // Check input parameters
; 494  :             if ((pInBuffer == NULL) || (inSize < sizeof(GUID)))

  000fc	e3550000	 cmp         r5, #0
  00100	0a000022	 beq         |$LN16@TWL_IOCont|
  00104	e3560010	 cmp         r6, #0x10
  00108	3a000020	 bcc         |$LN16@TWL_IOCont|

; 497  :                 break;
; 498  :                 }
; 499  :             if (IsEqualGUID(pInBuffer, &DEVICE_IFC_TWL_GUID))

  0010c	e59f10a8	 ldr         r1, [pc, #0xA8]
  00110	e3a02010	 mov         r2, #0x10
  00114	e1a00005	 mov         r0, r5
  00118	eb000000	 bl          memcmp
  0011c	e3500000	 cmp         r0, #0
  00120	1a00001a	 bne         |$LN16@TWL_IOCont|

; 500  :                 {
; 501  :                 if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_TWL);

  00124	e59d303c	 ldr         r3, [sp, #0x3C]

; 502  :                 if (pOutBuffer == NULL || outSize < sizeof(DEVICE_IFC_TWL))

  00128	e59d0034	 ldr         r0, [sp, #0x34]
  0012c	e3530000	 cmp         r3, #0
  00130	13a0201c	 movne       r2, #0x1C
  00134	15832000	 strne       r2, [r3]
  00138	e3500000	 cmp         r0, #0
  0013c	0a000013	 beq         |$LN16@TWL_IOCont|
  00140	e59d3038	 ldr         r3, [sp, #0x38]
  00144	e353001c	 cmp         r3, #0x1C
  00148	3a000010	 bcc         |$LN16@TWL_IOCont|

; 503  :                     {
; 504  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 505  :                     break;
; 506  :                     }
; 507  :                 ifc.context = context;
; 508  :                 ifc.pfnReadRegs = TWL_ReadRegs;
; 509  :                 ifc.pfnWriteRegs = TWL_WriteRegs;

  0014c	e59f2064	 ldr         r2, [pc, #0x64]

; 510  :                 ifc.pfnSetIntrEvent = TWL_SetIntrEvent;

  00150	e59f105c	 ldr         r1, [pc, #0x5C]
  00154	e59f3054	 ldr         r3, [pc, #0x54]

; 511  :                 ifc.pfnIntrEnable = TWL_IntrEnable;

  00158	e59fe04c	 ldr         lr, [pc, #0x4C]

; 512  :                 ifc.pfnIntrDisable = TWL_IntrDisable;

  0015c	e59f4044	 ldr         r4, [pc, #0x44]
  00160	e58d2008	 str         r2, [sp, #8]
  00164	e58d100c	 str         r1, [sp, #0xC]

; 513  :                 if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(DEVICE_IFC_TWL)))

  00168	e3a0201c	 mov         r2, #0x1C
  0016c	e28d1000	 add         r1, sp, #0
  00170	e58d3004	 str         r3, [sp, #4]
  00174	e58de010	 str         lr, [sp, #0x10]
  00178	e58d4014	 str         r4, [sp, #0x14]
  0017c	e58d8000	 str         r8, [sp]
  00180	eb000000	 bl          CeSafeCopyMemory
  00184	e3500000	 cmp         r0, #0

; 514  :                     {
; 515  :                     SetLastError(ERROR_INVALID_PARAMETER);
; 516  :                     break;
; 517  :                     }
; 518  :                 rc = TRUE;

  00188	13a07001	 movne       r7, #1
  0018c	1a000001	 bne         |$cleanUp$43178|
  00190		 |$LN16@TWL_IOCont|

; 495  :                 {
; 496  :                 SetLastError(ERROR_INVALID_PARAMETER);

  00190	e3a00057	 mov         r0, #0x57
  00194		 |$LN29@TWL_IOCont|
  00194	eb000000	 bl          SetLastError
  00198		 |$cleanUp$43178|

; 556  :             break;
; 557  :         }
; 558  : 
; 559  : cleanUp:
; 560  :     DEBUGMSG(ZONE_FUNCTION, (L"-TWL_IOControl(rc = %d)\r\n", rc));
; 561  :     return rc;
; 562  : }

  00198	e1a00007	 mov         r0, r7
  0019c	e28dd01c	 add         sp, sp, #0x1C
  001a0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  001a4	e12fff1e	 bx          lr
  001a8		 |$LN34@TWL_IOCont|
  001a8		 |$LN35@TWL_IOCont|
  001a8	00000000	 DCD         |TWL_IntrDisable|
  001ac		 |$LN36@TWL_IOCont|
  001ac	00000000	 DCD         |TWL_IntrEnable|
  001b0		 |$LN37@TWL_IOCont|
  001b0	00000000	 DCD         |TWL_ReadRegs|
  001b4		 |$LN38@TWL_IOCont|
  001b4	00000000	 DCD         |TWL_SetIntrEvent|
  001b8		 |$LN39@TWL_IOCont|
  001b8	00000000	 DCD         |TWL_WriteRegs|
  001bc		 |$LN40@TWL_IOCont|
  001bc	00000000	 DCD         |DEVICE_IFC_TWL_GUID|
  001c0		 |$LN41@TWL_IOCont|
  001c0	00220c04	 DCD         0x220c04
  001c4		 |$LN42@TWL_IOCont|
  001c4	74776c44	 DCD         0x74776c44
  001c8		 |$M43959|

			 ENDP  ; |TWL_IOControl|

	END
