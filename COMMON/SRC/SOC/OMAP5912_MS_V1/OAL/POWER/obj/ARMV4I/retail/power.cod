; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP5912_MS_V1\OAL\POWER\power.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OEMInterruptPending|
	EXPORT	|??_C@_1EA@LOAJIJJI@?$AA?9?$AAO?$AAE?$AAM?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAP?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DG@KCFEDALK@?$AA?$CL?$AAO?$AAE?$AAM?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAP?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OALIntrIsIrqPending|
	IMPORT	|OALIntrTranslateSysIntr|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|
; File c:\wince600\platform\common\src\soc\omap5912_ms_v1\oal\power\power.c

  00000			 AREA	 |.pdata|, PDATA
|$T44072| DCD	|$LN16@OEMInterru|
	DCD	0x40002a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@LOAJIJJI@?$AA?9?$AAO?$AAE?$AAM?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAP?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t"
	DCB	0x0, "P", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "="
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DG@KCFEDALK@?$AA?$CL?$AAO?$AAE?$AAM?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAP?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t"
	DCB	0x0, "P", 0x0, "e", 0x0, "n", 0x0, "d", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMInterruptPending| PROC

; 39   : {

  00000		 |$LN16@OEMInterru|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44069|
  00008	e1a05000	 mov         r5, r0

; 40   :     BOOL pending = FALSE;
; 41   :     const UINT32 *pIrqs;
; 42   :     UINT32 ix, count;
; 43   : 
; 44   :     OALMSG(OAL_INTR&&OAL_VERBOSE, (
; 45   :         L"+OEMInterruptPending(%d)\r\n", sysIntr
; 46   :     ));

  0000c	e59f6090	 ldr         r6, [pc, #0x90]
  00010	e3a04000	 mov         r4, #0
  00014	e5963440	 ldr         r3, [r6, #0x440]
  00018	e3130901	 tst         r3, #1, 18
  0001c	13130902	 tstne       r3, #2, 18
  00020	159f0078	 ldrne       r0, [pc, #0x78]
  00024	11a01005	 movne       r1, r5
  00028	1b000000	 blne        NKDbgPrintfW

; 47   : 
; 48   :     if (OALIntrTranslateSysIntr(sysIntr, &count, &pIrqs)) {

  0002c	e28d2004	 add         r2, sp, #4
  00030	e28d1000	 add         r1, sp, #0
  00034	e1a00005	 mov         r0, r5
  00038	eb000000	 bl          OALIntrTranslateSysIntr
  0003c	e3500000	 cmp         r0, #0
  00040	0a00000b	 beq         |$LN1@OEMInterru|

; 49   :         for (ix = 0; ix < count; ix++ && !pending) {

  00044	e59d3000	 ldr         r3, [sp]
  00048	e3a05000	 mov         r5, #0
  0004c	e3530000	 cmp         r3, #0
  00050	0a000007	 beq         |$LN1@OEMInterru|
  00054		 |$LL9@OEMInterru|

; 50   :             pending = OALIntrIsIrqPending(pIrqs[ix]);

  00054	e59d3004	 ldr         r3, [sp, #4]
  00058	e7930105	 ldr         r0, [r3, +r5, lsl #2]
  0005c	eb000000	 bl          OALIntrIsIrqPending
  00060	e59d3000	 ldr         r3, [sp]
  00064	e2855001	 add         r5, r5, #1
  00068	e1a04000	 mov         r4, r0
  0006c	e1550003	 cmp         r5, r3
  00070	3afffff7	 bcc         |$LL9@OEMInterru|
  00074		 |$LN1@OEMInterru|

; 51   :         }            
; 52   :     }
; 53   : 
; 54   :     OALMSG(OAL_INTR&&OAL_VERBOSE, (
; 55   :         L"-OEMInterruptPending(rc = %d)\r\n", pending
; 56   :     ));

  00074	e5963440	 ldr         r3, [r6, #0x440]
  00078	e3130901	 tst         r3, #1, 18
  0007c	13130902	 tstne       r3, #2, 18
  00080	159f0014	 ldrne       r0, [pc, #0x14]
  00084	11a01004	 movne       r1, r4
  00088	1b000000	 blne        NKDbgPrintfW

; 57   :     return pending;
; 58   : }

  0008c	e1a00004	 mov         r0, r4
  00090	e28dd008	 add         sp, sp, #8
  00094	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$LN17@OEMInterru|
  0009c		 |$LN18@OEMInterru|
  0009c	00000000	 DCD         |??_C@_1EA@LOAJIJJI@?$AA?9?$AAO?$AAE?$AAM?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAP?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000a0		 |$LN19@OEMInterru|
  000a0	00000000	 DCD         |??_C@_1DG@KCFEDALK@?$AA?$CL?$AAO?$AAE?$AAM?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAP?$AAe?$AAn?$AAd?$AAi?$AAn?$AAg?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000a4		 |$LN20@OEMInterru|
  000a4	00000000	 DCD         |dpCurSettings|
  000a8		 |$M44070|

			 ENDP  ; |OEMInterruptPending|

	EXPORT	|OEMPowerOff|
	IMPORT	|BSPPowerOn|
	IMPORT	|OALCPUIdle|
	IMPORT	|OEMInterruptEnable|
	IMPORT	|OALPowerWakeSource|
	IMPORT	|OALStall|
	IMPORT	|BSPPowerOff|
	IMPORT	|OALPAtoVA|
	IMPORT	|g_oalWakeSource|

  00000			 AREA	 |.pdata|, PDATA
|$T44112| DCD	|$LN21@OEMPowerOf|
	DCD	0x4000a702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMPowerOff| PROC

; 67   : {

  00000		 |$LN21@OEMPowerOf|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd038	 sub         sp, sp, #0x38
  00008		 |$M44109|
  00008	e3e03b4d	 mvn         r3, #0x4D, 22

; 68   :     OMAP5912_INTC_REGS *pIntcL1Regs = OALPAtoUA(OMAP5912_INTC_L1_REGS_PA);

  0000c	e22300ff	 eor         r0, r3, #0xFF
  00010	e3a01000	 mov         r1, #0
  00014	eb000000	 bl          OALPAtoVA
  00018	e3a034ff	 mov         r3, #0xFF, 8
  0001c	e1a08000	 mov         r8, r0

; 69   :     OMAP5912_INTC_REGS *pIntcL2ARegs = OALPAtoUA(OMAP5912_INTC_L2A_REGS_PA);

  00020	e38308fe	 orr         r0, r3, #0xFE, 16
  00024	e3a01000	 mov         r1, #0
  00028	eb000000	 bl          OALPAtoVA
  0002c	e3a03c01	 mov         r3, #1, 24
  00030	e1a09000	 mov         r9, r0

; 70   :     OMAP5912_INTC_REGS *pIntcL2BRegs = OALPAtoUA(OMAP5912_INTC_L2B_REGS_PA);

  00034	e2430802	 sub         r0, r3, #2, 16
  00038	e3a01000	 mov         r1, #0
  0003c	eb000000	 bl          OALPAtoVA
  00040	e3a03c02	 mov         r3, #2, 24
  00044	e1a0a000	 mov         r10, r0

; 71   :     OMAP5912_INTC_REGS *pIntcL2CRegs = OALPAtoUA(OMAP5912_INTC_L2C_REGS_PA);

  00048	e2430802	 sub         r0, r3, #2, 16
  0004c	e3a01000	 mov         r1, #0
  00050	eb000000	 bl          OALPAtoVA
  00054	e3e03b7f	 mvn         r3, #0x7F, 22
  00058	e1a0b000	 mov         r11, r0

; 72   :     OMAP5912_INTC_REGS *pIntcL2DRegs = OALPAtoUA(OMAP5912_INTC_L2D_REGS_PA);

  0005c	e22300ff	 eor         r0, r3, #0xFF
  00060	e3a01000	 mov         r1, #0
  00064	eb000000	 bl          OALPAtoVA
  00068	e3a07b01	 mov         r7, #1, 22
  0006c	e1a04000	 mov         r4, r0

; 73   :     OMAP5912_GPIO_REGS *pGPIO1Regs = OALPAtoUA(OMAP5912_GPIO1_REGS_PA);

  00070	e2470a42	 sub         r0, r7, #0x42, 20
  00074	e3a01000	 mov         r1, #0
  00078	e58d4020	 str         r4, [sp, #0x20]
  0007c	eb000000	 bl          OALPAtoVA
  00080	e3a06b03	 mov         r6, #3, 22
  00084	e1a05000	 mov         r5, r0

; 74   :     OMAP5912_GPIO_REGS *pGPIO2Regs = OALPAtoUA(OMAP5912_GPIO2_REGS_PA);

  00088	e2460a42	 sub         r0, r6, #0x42, 20
  0008c	e3a01000	 mov         r1, #0
  00090	e58d5000	 str         r5, [sp]
  00094	eb000000	 bl          OALPAtoVA
  00098	e58d0004	 str         r0, [sp, #4]

; 75   :     OMAP5912_GPIO_REGS *pGPIO3Regs = OALPAtoUA(OMAP5912_GPIO3_REGS_PA);

  0009c	e2470a45	 sub         r0, r7, #0x45, 20
  000a0	e3a01000	 mov         r1, #0
  000a4	eb000000	 bl          OALPAtoVA
  000a8	e58d0008	 str         r0, [sp, #8]

; 76   :     OMAP5912_GPIO_REGS *pGPIO4Regs = OALPAtoUA(OMAP5912_GPIO4_REGS_PA);

  000ac	e2460a45	 sub         r0, r6, #0x45, 20
  000b0	e3a01000	 mov         r1, #0
  000b4	eb000000	 bl          OALPAtoVA

; 77   :     OMAP5912_ULPD_REGS *pULPDRegs = OALPAtoUA(OMAP5912_ULPD_REGS_PA);

  000b8	e3a01000	 mov         r1, #0
  000bc	e58d000c	 str         r0, [sp, #0xC]
  000c0	e2410b7e	 sub         r0, r1, #0x7E, 22
  000c4	eb000000	 bl          OALPAtoVA
  000c8	e3a03b02	 mov         r3, #2, 22
  000cc	e1a06000	 mov         r6, r0

; 78   :     OMAP5912_RTC_REGS *pRTCRegs = OALPAtoUA(OMAP5912_RTC_REGS_PA);

  000d0	e2430913	 sub         r0, r3, #0x13, 18
  000d4	e3a01000	 mov         r1, #0
  000d8	eb000000	 bl          OALPAtoVA
  000dc	e1a07000	 mov         r7, r0

; 79   :     UINT32 intcL1, intcL2A, intcL2B, intcL2C, intcL2D;
; 80   :     UINT32 gpio1, gpio2, gpio3, gpio4;
; 81   :     UINT32 sysIntr;
; 82   :     UINT8 rtcIntrReg;
; 83   : 
; 84   :     // Give chance to do board specific stuff
; 85   :     BSPPowerOff();

  000e0	eb000000	 bl          BSPPowerOff

; 86   : 
; 87   :     OALStall(1000000);

  000e4	e3a0393d	 mov         r3, #0x3D, 18
  000e8	e3830d09	 orr         r0, r3, #9, 26
  000ec	eb000000	 bl          OALStall

; 88   : 
; 89   :     // Save existing interrupt masks and peripheral states
; 90   :     intcL1 = INREG32(&pIntcL1Regs->MIR);

  000f0	e5983004	 ldr         r3, [r8, #4]

; 91   :     intcL2A = INREG32(&pIntcL2ARegs->MIR); 
; 92   :     intcL2B = INREG32(&pIntcL2BRegs->MIR); 
; 93   :     intcL2C = INREG32(&pIntcL2CRegs->MIR); 
; 94   :     intcL2D = INREG32(&pIntcL2DRegs->MIR); 
; 95   :     gpio1 = INREG32(&pGPIO1Regs->IRQENABLE1);
; 96   :     gpio2 = INREG32(&pGPIO2Regs->IRQENABLE1);

  000f4	e59d2004	 ldr         r2, [sp, #4]

; 97   :     gpio3 = INREG32(&pGPIO3Regs->IRQENABLE1);

  000f8	e59d1008	 ldr         r1, [sp, #8]
  000fc	e58d3010	 str         r3, [sp, #0x10]
  00100	e5993004	 ldr         r3, [r9, #4]

; 98   :     gpio4 = INREG32(&pGPIO4Regs->IRQENABLE1);

  00104	e59d000c	 ldr         r0, [sp, #0xC]
  00108	e58d3014	 str         r3, [sp, #0x14]
  0010c	e59a3004	 ldr         r3, [r10, #4]
  00110	e58d3018	 str         r3, [sp, #0x18]
  00114	e59b3004	 ldr         r3, [r11, #4]
  00118	e58d301c	 str         r3, [sp, #0x1C]
  0011c	e5943004	 ldr         r3, [r4, #4]
  00120	e58d3024	 str         r3, [sp, #0x24]
  00124	e595301c	 ldr         r3, [r5, #0x1C]
  00128	e58d3028	 str         r3, [sp, #0x28]
  0012c	e592301c	 ldr         r3, [r2, #0x1C]
  00130	e58d302c	 str         r3, [sp, #0x2C]
  00134	e591301c	 ldr         r3, [r1, #0x1C]
  00138	e58d3030	 str         r3, [sp, #0x30]
  0013c	e590301c	 ldr         r3, [r0, #0x1C]

; 99   :     rtcIntrReg = INREG8(&pRTCRegs->INTR);

  00140	e5d75048	 ldrb        r5, [r7, #0x48]
  00144	e58d3034	 str         r3, [sp, #0x34]

; 100  : 
; 101  :     // Disable most interrupts including RTC (left IRQ_L2FIQ/IRQ_L2IRQ enabled) 
; 102  :     OUTREG32(&pIntcL1Regs->MIR, 0xFFFFFFFC);

  00148	e3e03003	 mvn         r3, #3
  0014c	e5883004	 str         r3, [r8, #4]

; 103  :     OUTREG32(&pIntcL2ARegs->MIR, 0xFFFFFFFF);

  00150	e3e03000	 mvn         r3, #0
  00154	e5893004	 str         r3, [r9, #4]

; 104  :     OUTREG32(&pIntcL2BRegs->MIR, 0xFFFFFFFF);

  00158	e58a3004	 str         r3, [r10, #4]

; 105  :     OUTREG32(&pIntcL2CRegs->MIR, 0xFFFFFFFF);

  0015c	e58b3004	 str         r3, [r11, #4]

; 106  :     OUTREG32(&pIntcL2DRegs->MIR, 0xFFFFFFFF);

  00160	e5843004	 str         r3, [r4, #4]

; 107  :     OUTREG32(&pGPIO1Regs->IRQENABLE1, 0);

  00164	e59d3000	 ldr         r3, [sp]
  00168	e3a0e000	 mov         lr, #0
  0016c	e583e01c	 str         lr, [r3, #0x1C]

; 108  :     OUTREG32(&pGPIO2Regs->IRQENABLE1, 0);

  00170	e582e01c	 str         lr, [r2, #0x1C]

; 109  :     OUTREG32(&pGPIO3Regs->IRQENABLE1, 0);

  00174	e581e01c	 str         lr, [r1, #0x1C]

; 110  :     OUTREG32(&pGPIO4Regs->IRQENABLE1, 0);
; 111  :     OUTREG8(&pRTCRegs->INTR, rtcIntrReg & ~RTC_INTR_ALARM);

  00178	e20530f7	 and         r3, r5, #0xF7
  0017c	e580e01c	 str         lr, [r0, #0x1C]
  00180	e5c73048	 strb        r3, [r7, #0x48]

; 112  : 
; 113  :     OALStall(1000000);

  00184	e3a0393d	 mov         r3, #0x3D, 18
  00188	e3830d09	 orr         r0, r3, #9, 26
  0018c	eb000000	 bl          OALStall

; 114  : 
; 115  :     // Enable wake sources interrupts
; 116  :     for (sysIntr = SYSINTR_FIRMWARE; sysIntr < SYSINTR_MAXIMUM; sysIntr++) {

  00190	e3a04010	 mov         r4, #0x10
  00194		 |$LL10@OEMPowerOf|

; 117  :         // Skip if sysIntr isn't allowed as wake source
; 118  :         if (!OALPowerWakeSource(sysIntr)) continue;

  00194	e1a00004	 mov         r0, r4
  00198	eb000000	 bl          OALPowerWakeSource
  0019c	e3500000	 cmp         r0, #0
  001a0	0a000007	 beq         |$LN9@OEMPowerOf|

; 119  :         // Enable it as interrupt
; 120  :         OEMInterruptEnable(sysIntr, NULL, 0);

  001a4	e3a02000	 mov         r2, #0
  001a8	e3a01000	 mov         r1, #0
  001ac	e1a00004	 mov         r0, r4
  001b0	eb000000	 bl          OEMInterruptEnable

; 121  : 
; 122  :         if( (SYSINTR_RTC_ALARM == sysIntr) && (rtcIntrReg & RTC_INTR_ALARM) )

  001b4	e354000d	 cmp         r4, #0xD
  001b8	1a000001	 bne         |$LN9@OEMPowerOf|
  001bc	e3150008	 tst         r5, #8

; 123  :         {
; 124  :             // In the case where we want the RTC to act as a wakeup source we will restore the RTC device's original interrupt
; 125  :             // control state.  We do not force the RTC to be generating interrupts here because we assume the RTC module has already
; 126  :             // been properly setup.
; 127  : 
; 128  :             OUTREG8(&pRTCRegs->INTR, rtcIntrReg);

  001c0	15c75048	 strneb      r5, [r7, #0x48]
  001c4		 |$LN9@OEMPowerOf|
  001c4	e2844001	 add         r4, r4, #1
  001c8	e3540048	 cmp         r4, #0x48
  001cc	3afffff0	 bcc         |$LL10@OEMPowerOf|

; 129  :         }
; 130  :     }
; 131  : 
; 132  :     // Enable deep sleep
; 133  :     SETREG16(&pULPDRegs->POWER_CTRL, POWER_CTRL_DEEP_SLEEP_EN);

  001d0	e1d635b0	 ldrh        r3, [r6, #0x50]

; 134  : 
; 135  :     OALStall(1000000);

  001d4	e3a0293d	 mov         r2, #0x3D, 18
  001d8	e3820d09	 orr         r0, r2, #9, 26
  001dc	e3833010	 orr         r3, r3, #0x10
  001e0	e1c635b0	 strh        r3, [r6, #0x50]
  001e4	eb000000	 bl          OALStall

; 136  : 
; 137  :     // Move SoC/CPU to idle mode, there is no special power-off
; 138  :     // mode on OMAP5912 (but deep sleep is very similar to it)
; 139  :     OALCPUIdle();

  001e8	eb000000	 bl          OALCPUIdle

; 140  : 
; 141  :     // Find wakeup source
; 142  :     for (sysIntr = SYSINTR_FIRMWARE; sysIntr < SYSINTR_MAXIMUM; sysIntr++) {

  001ec	e3a04010	 mov         r4, #0x10
  001f0		 |$LL5@OEMPowerOf|

; 143  :         // Skip if sysIntr isn't allowed as wake source
; 144  :         if (!OALPowerWakeSource(sysIntr)) continue;

  001f0	e1a00004	 mov         r0, r4
  001f4	eb000000	 bl          OALPowerWakeSource
  001f8	e3500000	 cmp         r0, #0
  001fc	0a000003	 beq         |$LN4@OEMPowerOf|

; 145  :         // When this sysIntr is pending we find wake source
; 146  :         if (OEMInterruptPending(sysIntr)) {

  00200	e1a00004	 mov         r0, r4
  00204	eb000000	 bl          OEMInterruptPending
  00208	e3500000	 cmp         r0, #0
  0020c	1a000003	 bne         |$LN15@OEMPowerOf|
  00210		 |$LN4@OEMPowerOf|

; 140  : 
; 141  :     // Find wakeup source
; 142  :     for (sysIntr = SYSINTR_FIRMWARE; sysIntr < SYSINTR_MAXIMUM; sysIntr++) {

  00210	e2844001	 add         r4, r4, #1
  00214	e3540048	 cmp         r4, #0x48
  00218	3afffff4	 bcc         |$LL5@OEMPowerOf|
  0021c	ea000001	 b           |$LN18@OEMPowerOf|
  00220		 |$LN15@OEMPowerOf|

; 147  :             g_oalWakeSource = sysIntr;

  00220	e59f3070	 ldr         r3, [pc, #0x70]
  00224	e5834000	 str         r4, [r3]
  00228		 |$LN18@OEMPowerOf|

; 148  :             break;
; 149  :         }
; 150  :     }
; 151  : 
; 152  :     // Do board specific stuff    
; 153  :     BSPPowerOn();

  00228	eb000000	 bl          BSPPowerOn

; 154  : 
; 155  :     // Restore interrupt masks and peripheral states
; 156  :     OUTREG8(&pRTCRegs->INTR, rtcIntrReg);
; 157  :     OUTREG32(&pIntcL1Regs->MIR, intcL1);

  0022c	e59d3010	 ldr         r3, [sp, #0x10]
  00230	e5c75048	 strb        r5, [r7, #0x48]

; 158  :     OUTREG32(&pIntcL2ARegs->MIR, intcL2A);
; 159  :     OUTREG32(&pIntcL2BRegs->MIR, intcL2B);
; 160  :     OUTREG32(&pIntcL2CRegs->MIR, intcL2C);
; 161  :     OUTREG32(&pIntcL2DRegs->MIR, intcL2D);

  00234	e59d2024	 ldr         r2, [sp, #0x24]
  00238	e5883004	 str         r3, [r8, #4]
  0023c	e59d3014	 ldr         r3, [sp, #0x14]
  00240	e5893004	 str         r3, [r9, #4]
  00244	e59d3018	 ldr         r3, [sp, #0x18]
  00248	e58a3004	 str         r3, [r10, #4]
  0024c	e59d301c	 ldr         r3, [sp, #0x1C]
  00250	e58b3004	 str         r3, [r11, #4]
  00254	e59d3020	 ldr         r3, [sp, #0x20]
  00258	e5832004	 str         r2, [r3, #4]

; 162  :     OUTREG32(&pGPIO1Regs->IRQENABLE1, gpio1);

  0025c	e59d3000	 ldr         r3, [sp]
  00260	e59d2028	 ldr         r2, [sp, #0x28]
  00264	e583201c	 str         r2, [r3, #0x1C]

; 163  :     OUTREG32(&pGPIO2Regs->IRQENABLE1, gpio2);

  00268	e59d3004	 ldr         r3, [sp, #4]
  0026c	e59d202c	 ldr         r2, [sp, #0x2C]
  00270	e583201c	 str         r2, [r3, #0x1C]

; 164  :     OUTREG32(&pGPIO3Regs->IRQENABLE1, gpio3);

  00274	e59d3008	 ldr         r3, [sp, #8]
  00278	e59d2030	 ldr         r2, [sp, #0x30]
  0027c	e583201c	 str         r2, [r3, #0x1C]

; 165  :     OUTREG32(&pGPIO4Regs->IRQENABLE1, gpio4);

  00280	e59d300c	 ldr         r3, [sp, #0xC]
  00284	e59d2034	 ldr         r2, [sp, #0x34]
  00288	e583201c	 str         r2, [r3, #0x1C]

; 166  : }

  0028c	e28dd038	 add         sp, sp, #0x38
  00290	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00294	e12fff1e	 bx          lr
  00298		 |$LN22@OEMPowerOf|
  00298		 |$LN23@OEMPowerOf|
  00298	00000000	 DCD         |g_oalWakeSource|
  0029c		 |$M44110|

			 ENDP  ; |OEMPowerOff|

	END
