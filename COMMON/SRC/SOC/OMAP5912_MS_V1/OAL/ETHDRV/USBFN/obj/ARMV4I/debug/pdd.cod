; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\OMAP5912_MS_V1\OAL\ETHDRV\USBFN\pdd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
	 COMMON	|g_usbfnpdd|, 0x128


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|InterruptThread|
	EXPORT	|??_C@_1GA@IKKIFCFC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|

  00000			 AREA	 |.pdata|, PDATA
|$T45672| DCD	|$LN21@InterruptT|
	DCD	0x40004a01
; File c:\wince600\platform\common\src\soc\omap5912_ms_v1\oal\ethdrv\usbfn\pdd.c

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@IKKIFCFC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, "T"
	DCB	0x0, "h", 0x0, "r", 0x0, "e", 0x0, "a", 0x0, "d", 0x0, ":"
	DCB	0x0, " ", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, " ", 0x0, "s"
	DCB	0x0, "o", 0x0, "u", 0x0, "r", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InterruptThread| PROC

; 484  : {

  00000		 |$LN21@InterruptT|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45669|
  00004	e1a07000	 mov         r7, r0

; 485  :     USBFN_PDD *pPdd = pPddContext;
; 486  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00008	e5978008	 ldr         r8, [r7, #8]
  0000c	e59f9110	 ldr         r9, [pc, #0x110]
  00010	e3a0b000	 mov         r11, #0
  00014	e3a0a008	 mov         r10, #8
  00018		 |$LL11@InterruptT|
  00018	e5993440	 ldr         r3, [r9, #0x440]

; 487  :     DWORD source, ep;
; 488  : 
; 489  : 
; 490  :     while (TRUE) {
; 491  :         BOOL fInterrupt = FALSE;
; 492  : 
; 493  :         // Get interrupt source
; 494  :         source = INREG32(&pUSBDRegs->IRQ_SRC);

  0001c	e5984030	 ldr         r4, [r8, #0x30]
  00020	e3a05000	 mov         r5, #0

; 495  : 
; 496  :         OALMSG(OAL_ETHER&&OAL_FUNC, (
; 497  :             L"UsbFnPdd!InterruptThread: Interrupt source %x\r\n", source
; 498  :         ));

  00024	e3130a02	 tst         r3, #2, 20
  00028	0a000004	 beq         |$LN14@InterruptT|
  0002c	e3130004	 tst         r3, #4
  00030	0a000002	 beq         |$LN14@InterruptT|
  00034	e59f00e4	 ldr         r0, [pc, #0xE4]
  00038	e1a01004	 mov         r1, r4
  0003c	eb000000	 bl          NKDbgPrintfW
  00040		 |$LN14@InterruptT|

; 499  : 
; 500  :         // Device state
; 501  :         if ((source & USBD_INT_DS_CHG) != 0 || pPdd->fakeDsChange) {

  00040	e2146008	 ands        r6, r4, #8
  00044	1a000002	 bne         |$LN8@InterruptT|
  00048	e5973124	 ldr         r3, [r7, #0x124]
  0004c	e3530000	 cmp         r3, #0
  00050	0a000005	 beq         |$LN9@InterruptT|
  00054		 |$LN8@InterruptT|

; 502  :             // Handle device state change
; 503  :             DevStatEvent(pPdd);

  00054	e1a00007	 mov         r0, r7
  00058	eb000000	 bl          DevStatEvent

; 504  :             // Clear fake DsChange flag
; 505  :             pPdd->fakeDsChange = FALSE;
; 506  :             if (( source & USBD_INT_DS_CHG) != 0 )

  0005c	e3560000	 cmp         r6, #0
  00060	e587b124	 str         r11, [r7, #0x124]

; 507  :                 OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_DS_CHG);

  00064	1588a030	 strne       r10, [r8, #0x30]

; 508  :             fInterrupt = TRUE;

  00068	e3a05001	 mov         r5, #1
  0006c		 |$LN9@InterruptT|

; 509  :         }
; 510  : 
; 511  :         // EP0 RX interrupt
; 512  :         if ((source & USBD_INT_EP0_RX) != 0) {

  0006c	e3140002	 tst         r4, #2
  00070	0a000005	 beq         |$LN6@InterruptT|

; 513  :             // Clear source bit
; 514  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP0_RX);
; 515  :             // Issue next Rx transfer
; 516  :             IssueRxTransfer(pPdd, 0);

  00074	e3a03002	 mov         r3, #2
  00078	e3a01000	 mov         r1, #0
  0007c	e1a00007	 mov         r0, r7
  00080	e5883030	 str         r3, [r8, #0x30]
  00084	eb000000	 bl          IssueRxTransfer

; 517  :             fInterrupt = TRUE;

  00088	e3a05001	 mov         r5, #1
  0008c		 |$LN6@InterruptT|

; 518  :         }
; 519  : 
; 520  :         // EP0 TX interrupt
; 521  :         if ((source & USBD_INT_EP0_TX) != 0) {

  0008c	e3140001	 tst         r4, #1
  00090	0a000005	 beq         |$LN5@InterruptT|

; 522  :             // Clear source bit
; 523  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP0_TX);
; 524  :             // Issue next Tx transfer
; 525  :             IssueTxTransfer(pPdd, 0);

  00094	e3a03001	 mov         r3, #1
  00098	e3a01000	 mov         r1, #0
  0009c	e1a00007	 mov         r0, r7
  000a0	e5883030	 str         r3, [r8, #0x30]
  000a4	eb000000	 bl          IssueTxTransfer

; 526  :             fInterrupt = TRUE;

  000a8	e3a05001	 mov         r5, #1
  000ac		 |$LN5@InterruptT|

; 527  :         }
; 528  : 
; 529  :         // EPn RX interrupt
; 530  :         if ((source & USBD_INT_EP_RX) != 0) {

  000ac	e3140020	 tst         r4, #0x20
  000b0	0a000007	 beq         |$LN4@InterruptT|

; 531  :             // Get EP number
; 532  :             ep = (INREG32(&pUSBDRegs->EP_STAT) >> 8) & USBD_EP_NUM;

  000b4	e5983034	 ldr         r3, [r8, #0x34]

; 533  :             // Clear source bit
; 534  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP_RX);
; 535  :             // Handle event
; 536  :             IssueRxTransfer(pPdd, ep);

  000b8	e3a02020	 mov         r2, #0x20
  000bc	e1a00007	 mov         r0, r7
  000c0	e1a03a03	 mov         r3, r3, lsl #20
  000c4	e1a01e23	 mov         r1, r3, lsr #28
  000c8	e5882030	 str         r2, [r8, #0x30]
  000cc	eb000000	 bl          IssueRxTransfer

; 537  :             fInterrupt = TRUE;

  000d0	e3a05001	 mov         r5, #1
  000d4		 |$LN4@InterruptT|

; 538  :         }
; 539  : 
; 540  :         // EPn TX interrupt
; 541  :         if ((source & USBD_INT_EP_TX) != 0) {

  000d4	e3140010	 tst         r4, #0x10
  000d8	0a000006	 beq         |$LN3@InterruptT|

; 542  :             // Get EP number
; 543  :             ep = INREG32(&pUSBDRegs->EP_STAT) & USBD_EP_NUM;

  000dc	e5983034	 ldr         r3, [r8, #0x34]

; 544  :             // Clear source bit
; 545  :             OUTREG32(&pUSBDRegs->IRQ_SRC, USBD_INT_EP_TX);
; 546  :             // Handle event
; 547  :             IssueTxTransfer(pPdd, ep);

  000e0	e3a02010	 mov         r2, #0x10
  000e4	e1a00007	 mov         r0, r7
  000e8	e203100f	 and         r1, r3, #0xF
  000ec	e5882030	 str         r2, [r8, #0x30]
  000f0	eb000000	 bl          IssueTxTransfer

; 548  :             fInterrupt = TRUE;

  000f4	e3a05001	 mov         r5, #1
  000f8		 |$LN3@InterruptT|

; 549  :         }
; 550  : 
; 551  :         // Setup Packet
; 552  :         if ((source & USBD_INT_SETUP) != 0) {

  000f8	e3140004	 tst         r4, #4
  000fc	0a000002	 beq         |$LN2@InterruptT|

; 553  :             // Reading setup FIFO clears interrupt
; 554  :             SetupEvent(pPdd);

  00100	e1a00007	 mov         r0, r7
  00104	eb000000	 bl          SetupEvent

; 555  :             fInterrupt = TRUE;
; 556  :         }
; 557  : 
; 558  :         if( !fInterrupt )

  00108	eaffffc2	 b           |$LL11@InterruptT|
  0010c		 |$LN2@InterruptT|
  0010c	e3550000	 cmp         r5, #0
  00110	1affffc0	 bne         |$LL11@InterruptT|

; 559  :         {
; 560  :             break;
; 561  :         }
; 562  :     }
; 563  : 
; 564  :     return ERROR_SUCCESS;

  00114	e3a00000	 mov         r0, #0

; 565  : }

  00118	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN22@InterruptT|
  00120		 |$LN23@InterruptT|
  00120	00000000	 DCD         |??_C@_1GA@IKKIFCFC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr@|
  00124		 |$LN24@InterruptT|
  00124	00000000	 DCD         |dpCurSettings|
  00128		 |$M45670|

			 ENDP  ; |InterruptThread|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00008			 AREA	 |.pdata|, PDATA
|$T45692| DCD	|$LN16@SetupEvent|
	DCD	0xc0003f02

  00000			 AREA	 |.xdata|, DATA
|$T45688| DCD	0xfffffff8
; Function compile flags: /Ogtp

  00128			 AREA	 |.text|, CODE, ARM

  00128	00000000	 DCD         |__GSHandlerCheck|
  0012c	00000000	 DCD         |$T45688|

  00130		 |SetupEvent| PROC

; 116  : {

  00130		 |$LN16@SetupEvent|
  00130	e52de004	 str         lr, [sp, #-4]!
  00134	e24dd00c	 sub         sp, sp, #0xC
  00138		 |$M45689|
  00138	e1a01000	 mov         r1, r0
  0013c	e59f30e4	 ldr         r3, [pc, #0xE4]
  00140	e5933000	 ldr         r3, [r3]
  00144	e58d3008	 str         r3, [sp, #8]

; 117  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00148	e5912008	 ldr         r2, [r1, #8]
  0014c	e3a00040	 mov         r0, #0x40
  00150	e3a0e000	 mov         lr, #0
  00154		 |$LL8@SetupEvent|

; 118  :     WORD data[4];
; 119  :     USB_DEVICE_REQUEST *pSetup = (USB_DEVICE_REQUEST*)data;
; 120  : 
; 121  :     do {
; 122  : 
; 123  :         // Select setup FIFO (this clears USBD_INT_SETUP flag)
; 124  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SETUP);

  00154	e5820004	 str         r0, [r2, #4]

; 125  : 
; 126  :         // Read setup data
; 127  :         data[0] = (WORD)INREG32(&pUSBDRegs->DATA);

  00158	e5923008	 ldr         r3, [r2, #8]
  0015c	e1cd30b0	 strh        r3, [sp]

; 128  :         data[1] = (WORD)INREG32(&pUSBDRegs->DATA);

  00160	e5923008	 ldr         r3, [r2, #8]
  00164	e1cd30b2	 strh        r3, [sp, #2]

; 129  :         data[2] = (WORD)INREG32(&pUSBDRegs->DATA);

  00168	e5923008	 ldr         r3, [r2, #8]
  0016c	e1cd30b4	 strh        r3, [sp, #4]

; 130  :         data[3] = (WORD)INREG32(&pUSBDRegs->DATA);

  00170	e5923008	 ldr         r3, [r2, #8]
  00174	e1cd30b6	 strh        r3, [sp, #6]

; 131  : 
; 132  :         // Deselect setup FIFO
; 133  :         OUTREG32(&pUSBDRegs->EP_NUM, 0);

  00178	e582e004	 str         lr, [r2, #4]

; 134  : 
; 135  :     } while ((INREG32(&pUSBDRegs->IRQ_SRC) & USBD_INT_SETUP) != 0);

  0017c	e5923030	 ldr         r3, [r2, #0x30]
  00180	e3130004	 tst         r3, #4
  00184	1afffff2	 bne         |$LL8@SetupEvent|

; 136  : 
; 137  :     // Save setup packet direction & size for later use
; 138  :     pPdd->setupDirRx = (pSetup->bmRequestType & 0x80) == 0;

  00188	e5dde000	 ldrb        lr, [sp]

; 139  :     pPdd->setupCount = pSetup->wLength;

  0018c	e1dd30b6	 ldrh        r3, [sp, #6]
  00190	e31e0080	 tst         lr, #0x80
  00194	03a00001	 moveq       r0, #1
  00198	13a00000	 movne       r0, #0
  0019c	e5810018	 str         r0, [r1, #0x18]

; 140  : 
; 141  :     // MDD doesn't call PDD back on configure message
; 142  :     if (
; 143  :         pSetup->bmRequestType == 0 &&
; 144  :         pSetup->bRequest == USB_REQUEST_SET_CONFIGURATION
; 145  :     ) {

  001a0	e35e0000	 cmp         lr, #0
  001a4	e1c131bc	 strh        r3, [r1, #0x1C]
  001a8	1a000013	 bne         |$LN1@SetupEvent|
  001ac	e5dd3001	 ldrb        r3, [sp, #1]
  001b0	e3530009	 cmp         r3, #9
  001b4	1a000010	 bne         |$LN1@SetupEvent|

; 146  :         if (pSetup->wValue != 0) {

  001b8	e1dd30b2	 ldrh        r3, [sp, #2]
  001bc	e3530000	 cmp         r3, #0
  001c0	0a00000b	 beq         |$LN4@SetupEvent|

; 147  :             // Move device to configured state
; 148  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_DEV_CFG);

  001c4	e3a03008	 mov         r3, #8
  001c8	e582301c	 str         r3, [r2, #0x1C]

; 149  :             // Set self powered flag
; 150  :             if (pPdd->selfPowered) {

  001cc	e5913014	 ldr         r3, [r1, #0x14]
  001d0	e3530000	 cmp         r3, #0

; 151  :                 SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_SELF_PWR);

  001d4	e5923018	 ldr         r3, [r2, #0x18]
  001d8	0a000002	 beq         |$LN3@SetupEvent|
  001dc	e3833004	 orr         r3, r3, #4
  001e0	e5823018	 str         r3, [r2, #0x18]

; 152  :             } else {

  001e4	ea000004	 b           |$LN1@SetupEvent|
  001e8		 |$LN3@SetupEvent|

; 153  :                 CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_SELF_PWR);

  001e8	e3c33004	 bic         r3, r3, #4
  001ec	e5823018	 str         r3, [r2, #0x18]

; 154  :             }
; 155  :         } else {

  001f0	ea000001	 b           |$LN1@SetupEvent|
  001f4		 |$LN4@SetupEvent|

; 156  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);

  001f4	e3a03004	 mov         r3, #4
  001f8	e582301c	 str         r3, [r2, #0x1C]
  001fc		 |$LN1@SetupEvent|

; 157  :         }
; 158  :     }
; 159  : 
; 160  :     // Let MDD process message
; 161  :     pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SETUP_PACKET, (DWORD)data);

  001fc	e5910000	 ldr         r0, [r1]
  00200	e5913004	 ldr         r3, [r1, #4]
  00204	e3a01004	 mov         r1, #4
  00208	e28d2000	 add         r2, sp, #0
  0020c	e1a0e00f	 mov         lr, pc
  00210	e12fff13	 bx          r3
  00214	e59d0008	 ldr         r0, [sp, #8]
  00218	eb000000	 bl          __security_check_cookie

; 162  : 
; 163  : }

  0021c	e28dd00c	 add         sp, sp, #0xC
  00220	e49de004	 ldr         lr, [sp], #4
  00224	e12fff1e	 bx          lr
  00228		 |$LN17@SetupEvent|
  00228		 |$LN18@SetupEvent|
  00228	00000000	 DCD         |__security_cookie|
  0022c		 |$M45690|

			 ENDP  ; |SetupEvent|

	EXPORT	|??_C@_1HM@LNNMMNAI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| [ DATA ] ; `string'

  00010			 AREA	 |.pdata|, PDATA
|$T45722| DCD	|$LN27@IssueTxTra|
	DCD	0x40006d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@LNNMMNAI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "I", 0x0, "s", 0x0, "s", 0x0, "u"
	DCB	0x0, "e", 0x0, "T", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, " ", 0x0, "p", 0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n"
	DCB	0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, " ", 0x0, "(", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  0022c			 AREA	 |.text|, CODE, ARM

  0022c		 |IssueTxTransfer| PROC

; 173  : {

  0022c		 |$LN27@IssueTxTra|
  0022c	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00230	e24dd008	 sub         sp, sp, #8
  00234		 |$M45719|
  00234	e1a06001	 mov         r6, r1
  00238	e1a08000	 mov         r8, r0

; 174  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 175  :     STransfer *pTransfer;
; 176  :     BOOL complete = FALSE;
; 177  :     DWORD epNum, stat, space, count, remain;
; 178  :     UCHAR *pBuffer;
; 179  :     WORD data;
; 180  : 
; 181  :     // Get active transfer
; 182  :     pTransfer = pPdd->ep[endPoint].pTransfer;
; 183  : 
; 184  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 185  :         L"UsbFnPdd!IssueTxTransfer: EP %d pTransfer 0x%x (%d, %d, %d)\r\n",
; 186  :         endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 187  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 188  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 189  :     ));

  0023c	e59f3198	 ldr         r3, [pc, #0x198]
  00240	e0889206	 add         r9, r8, r6, lsl #4
  00244	e5987008	 ldr         r7, [r8, #8]
  00248	e5933440	 ldr         r3, [r3, #0x440]
  0024c	e5994030	 ldr         r4, [r9, #0x30]
  00250	e3a0a000	 mov         r10, #0
  00254	e3130a02	 tst         r3, #2, 20
  00258	0a000010	 beq         |$LN13@IssueTxTra|
  0025c	e3130004	 tst         r3, #4
  00260	0a00000e	 beq         |$LN13@IssueTxTra|
  00264	e3540000	 cmp         r4, #0
  00268	0a000003	 beq         |$LN14@IssueTxTra|
  0026c	e594e014	 ldr         lr, [r4, #0x14]
  00270	e5945010	 ldr         r5, [r4, #0x10]
  00274	e594300c	 ldr         r3, [r4, #0xC]
  00278	ea000002	 b           |$LN19@IssueTxTra|
  0027c		 |$LN14@IssueTxTra|
  0027c	e3e0e000	 mvn         lr, #0
  00280	e3a05000	 mov         r5, #0
  00284	e3a03000	 mov         r3, #0
  00288		 |$LN19@IssueTxTra|
  00288	e59f0148	 ldr         r0, [pc, #0x148]
  0028c	e1a02004	 mov         r2, r4
  00290	e1a01006	 mov         r1, r6
  00294	e58de004	 str         lr, [sp, #4]
  00298	e58d5000	 str         r5, [sp]
  0029c	eb000000	 bl          NKDbgPrintfW
  002a0		 |$LN13@IssueTxTra|

; 190  : 
; 191  :     // Select EP
; 192  :     epNum = (USBD_EP_NUM & endPoint) | USBD_EP_NUM_DIRIN;

  002a0	e206300f	 and         r3, r6, #0xF
  002a4	e383b010	 orr         r11, r3, #0x10

; 193  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  002a8	e38b3020	 orr         r3, r11, #0x20
  002ac	e5873004	 str         r3, [r7, #4]

; 194  : 
; 195  :     // Get EP status
; 196  :     stat = INREG32(&pUSBDRegs->STAT_FLG);

  002b0	e5973010	 ldr         r3, [r7, #0x10]

; 197  : 
; 198  :     // Depending on EP status
; 199  :     if ((stat & USBD_STAT_STALL) != 0) {

  002b4	e3a0e000	 mov         lr, #0
  002b8	e3130020	 tst         r3, #0x20
  002bc	0a000002	 beq         |$LN10@IssueTxTra|

; 200  :         // We issued stall, remove it...
; 201  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT);

  002c0	e3a03080	 mov         r3, #0x80
  002c4	e587300c	 str         r3, [r7, #0xC]

; 202  :         // We are done
; 203  :         goto clean;

  002c8	ea000035	 b           |$clean$45039|
  002cc		 |$LN10@IssueTxTra|

; 204  :     }
; 205  : 
; 206  :     // When transfer is NULL it is handshake ACK
; 207  :     if (pTransfer == NULL) goto clean;

  002cc	e3540000	 cmp         r4, #0
  002d0	0a000033	 beq         |$clean$45039|

; 208  : 
; 209  :     // Is this final interrupt of transfer? 
; 210  :     if (
; 211  :         pTransfer->cbTransferred == pTransfer->cbBuffer && 
; 212  :         !pPdd->ep[endPoint].zeroLength
; 213  :     ) {

  002d4	e5941010	 ldr         r1, [r4, #0x10]
  002d8	e594200c	 ldr         r2, [r4, #0xC]
  002dc	e1510002	 cmp         r1, r2
  002e0	1a000005	 bne         |$LN8@IssueTxTra|
  002e4	e599302c	 ldr         r3, [r9, #0x2C]
  002e8	e3530000	 cmp         r3, #0
  002ec	1a000002	 bne         |$LN8@IssueTxTra|

; 214  :         pTransfer->dwUsbError = UFN_NO_ERROR;

  002f0	e584e014	 str         lr, [r4, #0x14]

; 215  :         complete = TRUE;

  002f4	e3a0a001	 mov         r10, #1

; 216  :         goto clean;

  002f8	ea000029	 b           |$clean$45039|
  002fc		 |$LN8@IssueTxTra|

; 217  :     }
; 218  : 
; 219  :     pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;

  002fc	e5943004	 ldr         r3, [r4, #4]

; 220  :     space = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 221  : 
; 222  :     if (endPoint != 0) {

  00300	e3560000	 cmp         r6, #0
  00304	e0420001	 sub         r0, r2, r1
  00308	e0835001	 add         r5, r3, r1

; 223  :         // Non Zero Endpoint: No zero length padding needed.
; 224  :         pPdd->ep[endPoint].zeroLength = FALSE;

  0030c	1589e02c	 strne       lr, [r9, #0x2C]
  00310	1a000008	 bne         |$LN6@IssueTxTra|

; 225  :     } else {
; 226  :         // Zero endpoint: Zero length padding needed if last
; 227  :         // packet is maxPacketSize.
; 228  :         pPdd->ep[endPoint].zeroLength = (
; 229  :             space == pPdd->ep[endPoint].maxPacketSize && 
; 230  :             pPdd->setupCount > pTransfer->cbBuffer
; 231  :         );

  00314	e1d832b4	 ldrh        r3, [r8, #0x24]
  00318	e1500003	 cmp         r0, r3
  0031c	1a000003	 bne         |$LN21@IssueTxTra|
  00320	e1d831bc	 ldrh        r3, [r8, #0x1C]
  00324	e1530002	 cmp         r3, r2
  00328	83a03001	 movhi       r3, #1
  0032c	8a000000	 bhi         |$LN22@IssueTxTra|
  00330		 |$LN21@IssueTxTra|
  00330	e3a03000	 mov         r3, #0
  00334		 |$LN22@IssueTxTra|
  00334	e588302c	 str         r3, [r8, #0x2C]
  00338		 |$LN6@IssueTxTra|

; 232  :     }        
; 233  : 
; 234  :     // How many bytes we can send just now?
; 235  :     count = pPdd->ep[endPoint].maxPacketSize;

  00338	e1d912b4	 ldrh        r1, [r9, #0x24]

; 236  :     if (count > space) count = space;

  0033c	e1510000	 cmp         r1, r0
  00340	81a01000	 movhi       r1, r0

; 237  : 
; 238  :     // Write data to FIFO
; 239  :     remain = count;
; 240  :     while (remain > 1) {

  00344	e3510001	 cmp         r1, #1
  00348	9a00000b	 bls         |$LN3@IssueTxTra|
  0034c	e2413002	 sub         r3, r1, #2
  00350	e1a030a3	 mov         r3, r3, lsr #1
  00354	e283e001	 add         lr, r3, #1
  00358		 |$LL4@IssueTxTra|

; 241  :         data = (pBuffer[1] << 8) | pBuffer[0];
; 242  :         OUTREG16((UINT16*)&pUSBDRegs->DATA, data);

  00358	e5d52001	 ldrb        r2, [r5, #1]
  0035c	e4d53002	 ldrb        r3, [r5], #2

; 243  :         pBuffer += 2;
; 244  :         space -= 2;

  00360	e2400002	 sub         r0, r0, #2

; 245  :         remain -= 2;

  00364	e2411002	 sub         r1, r1, #2
  00368	e25ee001	 subs        lr, lr, #1
  0036c	e1833402	 orr         r3, r3, r2, lsl #8
  00370	e1c730b8	 strh        r3, [r7, #8]
  00374	1afffff7	 bne         |$LL4@IssueTxTra|
  00378	e3a0e000	 mov         lr, #0
  0037c		 |$LN3@IssueTxTra|

; 246  :     }
; 247  :     if (remain > 0) {

  0037c	e3510000	 cmp         r1, #0
  00380	0a000002	 beq         |$LN2@IssueTxTra|

; 248  :         OUTREG8((UINT8*)&pUSBDRegs->DATA, *pBuffer);

  00384	e5d53000	 ldrb        r3, [r5]

; 249  :         pBuffer += 1;
; 250  :         space -= 1;

  00388	e2400001	 sub         r0, r0, #1
  0038c	e5c73008	 strb        r3, [r7, #8]
  00390		 |$LN2@IssueTxTra|

; 251  :         remain -= 1;
; 252  :     }
; 253  : 
; 254  :     // Enable FIFO
; 255  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00390	e3a03004	 mov         r3, #4
  00394	e587300c	 str         r3, [r7, #0xC]

; 256  : 
; 257  :     // We transfered some data
; 258  :     pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  00398	e594300c	 ldr         r3, [r4, #0xC]
  0039c	e0433000	 sub         r3, r3, r0
  003a0	e5843010	 str         r3, [r4, #0x10]
  003a4		 |$clean$45039|

; 259  : 
; 260  : clean:
; 261  : 
; 262  :     // Deselect EP
; 263  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  003a4	e587b004	 str         r11, [r7, #4]

; 264  : 
; 265  :     // If transaction is complete we should tell MDD
; 266  :     if (complete) {

  003a8	e35a0000	 cmp         r10, #0
  003ac	0a000006	 beq         |$LN1@IssueTxTra|

; 267  :         pPdd->ep[endPoint].pTransfer = NULL;

  003b0	e589e030	 str         lr, [r9, #0x30]

; 268  :         pPdd->pfnNotify(
; 269  :             pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 270  :         );

  003b4	e5980000	 ldr         r0, [r8]
  003b8	e5983004	 ldr         r3, [r8, #4]
  003bc	e1a02004	 mov         r2, r4
  003c0	e3a01064	 mov         r1, #0x64
  003c4	e1a0e00f	 mov         lr, pc
  003c8	e12fff13	 bx          r3
  003cc		 |$LN1@IssueTxTra|

; 271  :     }
; 272  : }

  003cc	e28dd008	 add         sp, sp, #8
  003d0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003d4	e12fff1e	 bx          lr
  003d8		 |$LN28@IssueTxTra|
  003d8		 |$LN29@IssueTxTra|
  003d8	00000000	 DCD         |??_C@_1HM@LNNMMNAI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAT?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@|
  003dc		 |$LN30@IssueTxTra|
  003dc	00000000	 DCD         |dpCurSettings|
  003e0		 |$M45720|

			 ENDP  ; |IssueTxTransfer|

	EXPORT	|??_C@_1HM@BCFIOLEH@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| [ DATA ] ; `string'

  00018			 AREA	 |.pdata|, PDATA
|$T45755| DCD	|$LN30@IssueRxTra|
	DCD	0x40007002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@BCFIOLEH@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "I", 0x0, "s", 0x0, "s", 0x0, "u"
	DCB	0x0, "e", 0x0, "R", 0x0, "x", 0x0, "T", 0x0, "r", 0x0, "a"
	DCB	0x0, "n", 0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "E", 0x0, "P", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, " ", 0x0, "p", 0x0, "T", 0x0, "r", 0x0, "a", 0x0, "n"
	DCB	0x0, "s", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, " ", 0x0, "(", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ","
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  003e0			 AREA	 |.text|, CODE, ARM

  003e0		 |IssueRxTransfer| PROC

; 282  : {

  003e0		 |$LN30@IssueRxTra|
  003e0	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  003e4	e24dd00c	 sub         sp, sp, #0xC
  003e8		 |$M45752|
  003e8	e1a06001	 mov         r6, r1
  003ec	e1a08000	 mov         r8, r0

; 283  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 284  :     STransfer *pTransfer;
; 285  :     BOOL complete = FALSE;
; 286  :     DWORD epNum, stat, space, count, remain, maxSize;
; 287  :     UCHAR *pBuffer;
; 288  :     WORD data;
; 289  : 
; 290  :     // Get active transfer
; 291  :     pTransfer = pPdd->ep[endPoint].pTransfer;
; 292  : 
; 293  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 294  :         L"UsbFnPdd!IssueRxTransfer: EP %d pTransfer 0x%x (%d, %d, %d)\r\n",
; 295  :         endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 296  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 297  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 298  :     ));

  003f0	e59f31a4	 ldr         r3, [pc, #0x1A4]
  003f4	e088e206	 add         lr, r8, r6, lsl #4
  003f8	e5987008	 ldr         r7, [r8, #8]
  003fc	e5933440	 ldr         r3, [r3, #0x440]
  00400	e59e4030	 ldr         r4, [lr, #0x30]
  00404	e58de008	 str         lr, [sp, #8]
  00408	e3130a02	 tst         r3, #2, 20
  0040c	e3a0a000	 mov         r10, #0
  00410	0a000011	 beq         |$LN18@IssueRxTra|
  00414	e3130004	 tst         r3, #4
  00418	0a00000f	 beq         |$LN18@IssueRxTra|
  0041c	e3540000	 cmp         r4, #0
  00420	0a000003	 beq         |$LN19@IssueRxTra|
  00424	e594e014	 ldr         lr, [r4, #0x14]
  00428	e5945010	 ldr         r5, [r4, #0x10]
  0042c	e594300c	 ldr         r3, [r4, #0xC]
  00430	ea000002	 b           |$LN24@IssueRxTra|
  00434		 |$LN19@IssueRxTra|
  00434	e3e0e000	 mvn         lr, #0
  00438	e3a05000	 mov         r5, #0
  0043c	e3a03000	 mov         r3, #0
  00440		 |$LN24@IssueRxTra|
  00440	e59f0150	 ldr         r0, [pc, #0x150]
  00444	e1a02004	 mov         r2, r4
  00448	e1a01006	 mov         r1, r6
  0044c	e58de004	 str         lr, [sp, #4]
  00450	e58d5000	 str         r5, [sp]
  00454	eb000000	 bl          NKDbgPrintfW
  00458	e088e206	 add         lr, r8, r6, lsl #4
  0045c		 |$LN18@IssueRxTra|

; 299  : 
; 300  :     // Select EP
; 301  :     epNum = USBD_EP_NUM & endPoint;

  0045c	e206b00f	 and         r11, r6, #0xF

; 302  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00460	e38b3020	 orr         r3, r11, #0x20
  00464	e5873004	 str         r3, [r7, #4]

; 303  : 
; 304  :     // Get EP status
; 305  :     stat = INREG32(&pUSBDRegs->STAT_FLG);

  00468	e5973010	 ldr         r3, [r7, #0x10]

; 306  : 
; 307  :     // Depending on EP status
; 308  :     if ((stat & USBD_STAT_STALL) != 0) {

  0046c	e3a02000	 mov         r2, #0
  00470	e3130020	 tst         r3, #0x20
  00474	0a000002	 beq         |$LN15@IssueRxTra|

; 309  :         // We issued stall, remove it...
; 310  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_HALT);

  00478	e3a03080	 mov         r3, #0x80
  0047c	e587300c	 str         r3, [r7, #0xC]

; 311  :         // We are done
; 312  :         goto clean;

  00480	ea000037	 b           |$clean$45092|
  00484		 |$LN15@IssueRxTra|

; 313  :     }
; 314  : 
; 315  :     // When transfer is NULL it is handshake ACK
; 316  :     if (pTransfer == NULL) goto clean;

  00484	e3540000	 cmp         r4, #0
  00488	0a000035	 beq         |$clean$45092|

; 317  : 
; 318  :     // Get maxPacketSize
; 319  :     maxSize = pPdd->ep[endPoint].maxPacketSize;
; 320  : 
; 321  :         pBuffer = (UCHAR*)pTransfer->pvBuffer + pTransfer->cbTransferred;
; 322  :         space = pTransfer->cbBuffer - pTransfer->cbTransferred;
; 323  : 
; 324  :         // Get EP status flag
; 325  :         stat = INREG32(&pUSBDRegs->STAT_FLG);

  0048c	e5970010	 ldr         r0, [r7, #0x10]
  00490	e5941010	 ldr         r1, [r4, #0x10]
  00494	e5943004	 ldr         r3, [r4, #4]
  00498	e594200c	 ldr         r2, [r4, #0xC]

; 326  : 
; 327  :         // Get number of bytes in FIFO
; 328  :         if ((stat & USBD_STAT_FIFO_EMPTY) != 0) {

  0049c	e3100002	 tst         r0, #2
  004a0	e1de92b4	 ldrh        r9, [lr, #0x24]
  004a4	e0836001	 add         r6, r3, r1

; 329  :             count = 0;

  004a8	13a05000	 movne       r5, #0
  004ac	e0421001	 sub         r1, r2, r1
  004b0	1a000006	 bne         |$LN10@IssueRxTra|

; 330  :         } else if ((stat & USBD_STAT_FIFO_FULL) != 0) {

  004b4	e3100001	 tst         r0, #1

; 331  :             count = maxSize;

  004b8	11a05009	 movne       r5, r9
  004bc	1a000003	 bne         |$LN10@IssueRxTra|

; 332  :         } else {
; 333  :             count = INREG32(&pUSBDRegs->RXFSTAT) & USBD_RFXSTAT_COUNT;

  004c0	e5972014	 ldr         r2, [r7, #0x14]
  004c4	e3a03c03	 mov         r3, #3, 24
  004c8	e38330ff	 orr         r3, r3, #0xFF
  004cc	e0025003	 and         r5, r2, r3
  004d0		 |$LN10@IssueRxTra|

; 334  :         }
; 335  : 
; 336  :         // Read data
; 337  :         remain = count;

  004d0	e1a00005	 mov         r0, r5

; 338  :         while (remain > 1) {

  004d4	e3550001	 cmp         r5, #1
  004d8	9a00000e	 bls         |$LN8@IssueRxTra|
  004dc	e2453002	 sub         r3, r5, #2
  004e0	e1a030a3	 mov         r3, r3, lsr #1
  004e4	e283e001	 add         lr, r3, #1
  004e8		 |$LL9@IssueRxTra|

; 339  :             data = (WORD)INREG32(&pUSBDRegs->DATA);

  004e8	e5972008	 ldr         r2, [r7, #8]

; 340  :             if (space > 1) {

  004ec	e3510001	 cmp         r1, #1
  004f0	9a000004	 bls         |$LN7@IssueRxTra|

; 341  :                 pBuffer[0] = (UCHAR)data;
; 342  :                 pBuffer[1] = (UCHAR)(data >> 8);

  004f4	e1a03422	 mov         r3, r2, lsr #8
  004f8	e5c63001	 strb        r3, [r6, #1]
  004fc	e5c62000	 strb        r2, [r6]

; 343  :                 pBuffer += 2;

  00500	e2866002	 add         r6, r6, #2

; 344  :                 space -= 2;

  00504	e2411002	 sub         r1, r1, #2
  00508		 |$LN7@IssueRxTra|

; 345  :             }
; 346  :             remain -= 2;

  00508	e2400002	 sub         r0, r0, #2
  0050c	e25ee001	 subs        lr, lr, #1
  00510	1afffff4	 bne         |$LL9@IssueRxTra|

; 283  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 284  :     STransfer *pTransfer;
; 285  :     BOOL complete = FALSE;
; 286  :     DWORD epNum, stat, space, count, remain, maxSize;
; 287  :     UCHAR *pBuffer;
; 288  :     WORD data;
; 289  : 
; 290  :     // Get active transfer
; 291  :     pTransfer = pPdd->ep[endPoint].pTransfer;
; 292  : 
; 293  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 294  :         L"UsbFnPdd!IssueRxTransfer: EP %d pTransfer 0x%x (%d, %d, %d)\r\n",
; 295  :         endPoint, pTransfer, pTransfer != NULL ? pTransfer->cbBuffer : 0,
; 296  :         pTransfer != NULL ? pTransfer->cbTransferred : 0,
; 297  :         pTransfer != NULL ? pTransfer->dwUsbError : -1
; 298  :     ));

  00514	e59de008	 ldr         lr, [sp, #8]
  00518		 |$LN8@IssueRxTra|

; 347  :         }
; 348  :         if (remain > 0) {

  00518	e3500000	 cmp         r0, #0

; 349  :             data = (WORD)INREG32(&pUSBDRegs->DATA);

  0051c	15973008	 ldrne       r3, [r7, #8]

; 350  :             if (space > 0) {

  00520	13510000	 cmpne       r1, #0

; 351  :                 *pBuffer = (UCHAR)data;
; 352  :                 pBuffer += 1;
; 353  :                 space -= 1;

  00524	12411001	 subne       r1, r1, #1
  00528	15c63000	 strneb      r3, [r6]

; 354  :             }
; 355  :             remain -= 1;
; 356  :         }
; 357  : 
; 358  :         // We transfered some data
; 359  :         pTransfer->cbTransferred = pTransfer->cbBuffer - space;

  0052c	e594200c	 ldr         r2, [r4, #0xC]
  00530	e0423001	 sub         r3, r2, r1
  00534	e5843010	 str         r3, [r4, #0x10]

; 360  : 
; 361  :         // Is this end of transfer?
; 362  :         if (
; 363  :             pTransfer->cbTransferred == pTransfer->cbBuffer || count < maxSize
; 364  :         ) {

  00538	e1530002	 cmp         r3, r2
  0053c	0a000005	 beq         |$LN3@IssueRxTra|
  00540	e1550009	 cmp         r5, r9
  00544	3a000003	 bcc         |$LN3@IssueRxTra|

; 369  :         } else {
; 370  :             // No, enable FIFO for next packet
; 371  :             OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00548	e3a03004	 mov         r3, #4
  0054c	e587300c	 str         r3, [r7, #0xC]
  00550	e3a02000	 mov         r2, #0
  00554	ea000002	 b           |$clean$45092|
  00558		 |$LN3@IssueRxTra|

; 365  :             // Yes, set return code
; 366  :             pTransfer->dwUsbError = UFN_NO_ERROR;

  00558	e3a02000	 mov         r2, #0
  0055c	e5842014	 str         r2, [r4, #0x14]

; 367  :             // And complete flag
; 368  :             complete = TRUE;

  00560	e3a0a001	 mov         r10, #1
  00564		 |$clean$45092|

; 372  :         }
; 373  : 
; 374  : clean:
; 375  : 
; 376  :     // Deselect EP
; 377  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00564	e587b004	 str         r11, [r7, #4]

; 378  : 
; 379  :     // If transaction is complete we should tell MDD
; 380  :     if (complete) {

  00568	e35a0000	 cmp         r10, #0
  0056c	0a000006	 beq         |$LN1@IssueRxTra|

; 381  :         pPdd->ep[endPoint].pTransfer = NULL;

  00570	e58e2030	 str         r2, [lr, #0x30]

; 382  :         pPdd->pfnNotify(
; 383  :             pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 384  :         );

  00574	e5980000	 ldr         r0, [r8]
  00578	e5983004	 ldr         r3, [r8, #4]
  0057c	e1a02004	 mov         r2, r4
  00580	e3a01064	 mov         r1, #0x64
  00584	e1a0e00f	 mov         lr, pc
  00588	e12fff13	 bx          r3
  0058c		 |$LN1@IssueRxTra|

; 385  :     }
; 386  : }

  0058c	e28dd00c	 add         sp, sp, #0xC
  00590	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00594	e12fff1e	 bx          lr
  00598		 |$LN31@IssueRxTra|
  00598		 |$LN32@IssueRxTra|
  00598	00000000	 DCD         |??_C@_1HM@BCFIOLEH@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAI?$AAs?$AAs?$AAu?$AAe?$AAR?$AAx?$AAT?$AAr?$AAa?$AAn?$AAs?$AAf?$AAe?$AAr?$AA?3?$AA?5?$AAE?$AAP?$AA?5?$AA?$CF?$AAd?$AA?5@|
  0059c		 |$LN33@IssueRxTra|
  0059c	00000000	 DCD         |dpCurSettings|
  005a0		 |$M45753|

			 ENDP  ; |IssueRxTransfer|

	EXPORT	|??_C@_1GI@OPBGFKOJ@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAD?$AAe?$AAv?$AAS?$AAt?$AAa?$AAt?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?3?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAs?$AAt@| [ DATA ] ; `string'

  00020			 AREA	 |.pdata|, PDATA
|$T45770| DCD	|$LN19@DevStatEve|
	DCD	0x40007601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@OPBGFKOJ@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAD?$AAe?$AAv?$AAS?$AAt?$AAa?$AAt?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?3?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAs?$AAt@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "!", 0x0, "D", 0x0, "e", 0x0, "v", 0x0, "S"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "E", 0x0, "v", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "D", 0x0, "e"
	DCB	0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "%"
	DCB	0x0, "x", 0x0, ",", 0x0, " ", 0x0, "c", 0x0, "h", 0x0, "a"
	DCB	0x0, "n", 0x0, "g", 0x0, "e", 0x0, " ", 0x0, "%", 0x0, "x"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  005a0			 AREA	 |.text|, CODE, ARM

  005a0		 |DevStatEvent| PROC

; 395  : {

  005a0		 |$LN19@DevStatEve|
  005a0	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  005a4		 |$M45767|
  005a4	e1a04000	 mov         r4, r0

; 396  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  005a8	e5947008	 ldr         r7, [r4, #8]

; 397  :     DWORD state, change;
; 398  : 
; 399  :     // Get device state & change
; 400  :     state = INREG32(&pUSBDRegs->DEVSTAT);
; 401  :     change = state ^ pPdd->devState;
; 402  : 
; 403  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 404  :         L"UsbFnPdd!DevStatEvent: Device state %x, change %x\r\n",
; 405  :         state, change
; 406  :     ));

  005ac	e59f31c0	 ldr         r3, [pc, #0x1C0]
  005b0	e5942010	 ldr         r2, [r4, #0x10]
  005b4	e5975020	 ldr         r5, [r7, #0x20]
  005b8	e5933440	 ldr         r3, [r3, #0x440]
  005bc	e0226005	 eor         r6, r2, r5
  005c0	e3130a02	 tst         r3, #2, 20
  005c4	0a000005	 beq         |$LN14@DevStatEve|
  005c8	e3130004	 tst         r3, #4
  005cc	0a000003	 beq         |$LN14@DevStatEve|
  005d0	e59f0198	 ldr         r0, [pc, #0x198]
  005d4	e1a02006	 mov         r2, r6
  005d8	e1a01005	 mov         r1, r5
  005dc	eb000000	 bl          NKDbgPrintfW
  005e0		 |$LN14@DevStatEve|

; 407  : 
; 408  :     // Attach/deattach
; 409  :     if ((change & USBD_DEVSTAT_ATT) != 0) {

  005e0	e3160001	 tst         r6, #1
  005e4	0a00000d	 beq         |$LN9@DevStatEve|

; 410  :         if ((state & USBD_DEVSTAT_ATT) != 0) {

  005e8	e3150001	 tst         r5, #1

; 411  :             // TODO: Call bus driver (OTG?) to move HW from deep sleep
; 412  :             // Let MDD process change
; 413  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);

  005ec	e3a01001	 mov         r1, #1
  005f0	0a00002b	 beq         |$LN10@DevStatEve|
  005f4	e5940000	 ldr         r0, [r4]
  005f8	e5943004	 ldr         r3, [r4, #4]
  005fc	e3a02001	 mov         r2, #1
  00600	e1a0e00f	 mov         lr, pc
  00604	e12fff13	 bx          r3

; 414  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED, BS_FULL_SPEED);

  00608	e5940000	 ldr         r0, [r4]
  0060c	e5943004	 ldr         r3, [r4, #4]
  00610	e3a02001	 mov         r2, #1
  00614	e3a01003	 mov         r1, #3
  00618	e1a0e00f	 mov         lr, pc
  0061c	e12fff13	 bx          r3
  00620		 |$LN9@DevStatEve|

; 422  :             // Don't process other changes (we are disconnected)
; 423  :             goto clean;
; 424  :         }
; 425  :     }
; 426  : 
; 427  :     // Reset
; 428  :     if ((change & (USBD_DEVSTAT_USB_RESET|USBD_DEVSTAT_DEF)) != 0) {

  00620	e3160022	 tst         r6, #0x22
  00624	0a000028	 beq         |$LN8@DevStatEve|

; 429  :         if ((state & USBD_DEVSTAT_USB_RESET) == 0) {

  00628	e3150020	 tst         r5, #0x20
  0062c	1a000017	 bne         |$LN7@DevStatEve|

; 430  :             // OTG may not detect attach/detach events correctly on some platforms
; 431  :             // Simulate a attach/detach event to clear any previous state on reset
; 432  :             // Let MDD process change
; 433  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  00630	e5940000	 ldr         r0, [r4]
  00634	e5943004	 ldr         r3, [r4, #4]
  00638	e3a02000	 mov         r2, #0
  0063c	e3a01001	 mov         r1, #1
  00640	e1a0e00f	 mov         lr, pc
  00644	e12fff13	 bx          r3

; 434  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_ATTACH);

  00648	e5940000	 ldr         r0, [r4]
  0064c	e5943004	 ldr         r3, [r4, #4]
  00650	e3a02001	 mov         r2, #1
  00654	e3a01001	 mov         r1, #1
  00658	e1a0e00f	 mov         lr, pc
  0065c	e12fff13	 bx          r3

; 435  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_SPEED, BS_FULL_SPEED);

  00660	e5940000	 ldr         r0, [r4]
  00664	e5943004	 ldr         r3, [r4, #4]
  00668	e3a02001	 mov         r2, #1
  0066c	e3a01003	 mov         r1, #3
  00670	e1a0e00f	 mov         lr, pc
  00674	e12fff13	 bx          r3

; 436  :             // Tell MDD about reset...
; 437  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESET);

  00678	e5940000	 ldr         r0, [r4]
  0067c	e5943004	 ldr         r3, [r4, #4]
  00680	e3a02002	 mov         r2, #2
  00684	e3a01001	 mov         r1, #1
  00688	e1a0e00f	 mov         lr, pc
  0068c	e12fff13	 bx          r3
  00690		 |$LN7@DevStatEve|

; 438  :         }
; 439  :         // Enable interrupts
; 440  :         OUTREG32(&pUSBDRegs->IRQ_EN, USBD_IRQ_MASK);

  00690	e3a03039	 mov         r3, #0x39
  00694	e5873028	 str         r3, [r7, #0x28]

; 468  :         }
; 469  :     }
; 470  : 
; 471  : clean:
; 472  :     // Save device state for next interrupt
; 473  :     pPdd->devState = state;

  00698	e5845010	 str         r5, [r4, #0x10]
  0069c		 |$clean$45140|

; 474  : }

  0069c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  006a0	e12fff1e	 bx          lr
  006a4		 |$LN10@DevStatEve|

; 415  :         } else {
; 416  :             // Clear source bit
; 417  :             // We are not configured anymore
; 418  :             OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_CLR_CFG);

  006a4	e3a03004	 mov         r3, #4
  006a8	e587301c	 str         r3, [r7, #0x1C]

; 419  :             // TODO: Call bus driver (OTG?) to move HW to deep sleep
; 420  :             // Let MDD process change
; 421  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_DETACH);

  006ac	e5940000	 ldr         r0, [r4]
  006b0	e5943004	 ldr         r3, [r4, #4]
  006b4	e3a02000	 mov         r2, #0
  006b8	e1a0e00f	 mov         lr, pc
  006bc	e12fff13	 bx          r3

; 468  :         }
; 469  :     }
; 470  : 
; 471  : clean:
; 472  :     // Save device state for next interrupt
; 473  :     pPdd->devState = state;

  006c0	e5845010	 str         r5, [r4, #0x10]
  006c4		 |$clean_1$45140|

; 474  : }

  006c4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  006c8	e12fff1e	 bx          lr
  006cc		 |$LN8@DevStatEve|

; 441  :         // In the middle of a reset don't process other changes
; 442  :         goto clean;
; 443  :     }
; 444  : 
; 445  :     // Suspend/resume
; 446  :     if ((change & USBD_DEVSTAT_SUS) != 0) {

  006cc	e3160010	 tst         r6, #0x10
  006d0	0a00000c	 beq         |$LN4@DevStatEve|

; 447  :         if ((state & USBD_DEVSTAT_SUS) != 0) {
; 448  :             // Let MDD process change
; 449  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_SUSPEND);

  006d4	e5940000	 ldr         r0, [r4]
  006d8	e5943004	 ldr         r3, [r4, #4]
  006dc	e3150010	 tst         r5, #0x10
  006e0	e3a01001	 mov         r1, #1
  006e4	0a000004	 beq         |$LN5@DevStatEve|
  006e8	e3a02003	 mov         r2, #3
  006ec	e1a0e00f	 mov         lr, pc
  006f0	e12fff13	 bx          r3

; 450  :             // Read device status
; 451  :             INREG32(&pUSBDRegs->DEVSTAT);

  006f4	e5973020	 ldr         r3, [r7, #0x20]

; 452  :         } else {

  006f8	ea000002	 b           |$LN4@DevStatEve|
  006fc		 |$LN5@DevStatEve|

; 453  :             // Let MDD process change
; 454  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_BUS_EVENTS, UFN_RESUME);

  006fc	e3a02004	 mov         r2, #4
  00700	e1a0e00f	 mov         lr, pc
  00704	e12fff13	 bx          r3
  00708		 |$LN4@DevStatEve|

; 455  :         }
; 456  :     }
; 457  : 
; 458  : 
; 459  :     // Addressed
; 460  :     if ((change & USBD_DEVSTAT_ADD) != 0) {

  00708	e3160004	 tst         r6, #4
  0070c	0a000014	 beq         |$LN16@DevStatEve|

; 461  :         if ((state & USBD_DEVSTAT_ADD) != 0) {
; 462  :             // Let MDD process change
; 463  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SET_ADDRESS, 1);

  00710	e5940000	 ldr         r0, [r4]
  00714	e5943004	 ldr         r3, [r4, #4]
  00718	e3150004	 tst         r5, #4
  0071c	0a000006	 beq         |$LN2@DevStatEve|
  00720	e3a02001	 mov         r2, #1
  00724	e3a01006	 mov         r1, #6
  00728	e1a0e00f	 mov         lr, pc
  0072c	e12fff13	 bx          r3

; 468  :         }
; 469  :     }
; 470  : 
; 471  : clean:
; 472  :     // Save device state for next interrupt
; 473  :     pPdd->devState = state;

  00730	e5845010	 str         r5, [r4, #0x10]
  00734		 |$clean_2$45140|

; 474  : }

  00734	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00738	e12fff1e	 bx          lr
  0073c		 |$LN2@DevStatEve|

; 464  :         } else {
; 465  :             // Let MDD process change
; 466  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_CONFIGURED, 0 );

  0073c	e3a02000	 mov         r2, #0
  00740	e3a01002	 mov         r1, #2
  00744	e1a0e00f	 mov         lr, pc
  00748	e12fff13	 bx          r3

; 467  :             pPdd->pfnNotify(pPdd->pMddContext, UFN_MSG_SET_ADDRESS,0 );

  0074c	e5940000	 ldr         r0, [r4]
  00750	e5943004	 ldr         r3, [r4, #4]
  00754	e3a02000	 mov         r2, #0
  00758	e3a01006	 mov         r1, #6
  0075c	e1a0e00f	 mov         lr, pc
  00760	e12fff13	 bx          r3
  00764		 |$LN16@DevStatEve|

; 468  :         }
; 469  :     }
; 470  : 
; 471  : clean:
; 472  :     // Save device state for next interrupt
; 473  :     pPdd->devState = state;

  00764	e5845010	 str         r5, [r4, #0x10]
  00768		 |$clean_3$45140|

; 474  : }

  00768	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0076c	e12fff1e	 bx          lr
  00770		 |$LN20@DevStatEve|
  00770		 |$LN21@DevStatEve|
  00770	00000000	 DCD         |??_C@_1GI@OPBGFKOJ@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA?$CB?$AAD?$AAe?$AAv?$AAS?$AAt?$AAa?$AAt?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?3?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAs?$AAt@|
  00774		 |$LN22@DevStatEve|
  00774	00000000	 DCD         |dpCurSettings|
  00778		 |$M45768|

			 ENDP  ; |DevStatEvent|

	EXPORT	|UfnPdd_IssueTransfer|

  00028			 AREA	 |.pdata|, PDATA
|$T45789| DCD	|$LN11@UfnPdd_Iss|
	DCD	0x40002401
; Function compile flags: /Ogtp

  00778			 AREA	 |.text|, CODE, ARM

  00778		 |UfnPdd_IssueTransfer| PROC

; 571  : ) {

  00778		 |$LN11@UfnPdd_Iss|
  00778	e92d4030	 stmdb       sp!, {r4, r5, lr}
  0077c		 |$M45786|

; 572  :     USBFN_PDD *pPdd = pPddContext;
; 573  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 574  :     DWORD epNum;
; 575  : 
; 576  :     // Save transfer for interrupt thread
; 577  :     pPdd->ep[endPoint].pTransfer = pTransfer;

  0077c	e5904008	 ldr         r4, [r0, #8]
  00780	e080e201	 add         lr, r0, r1, lsl #4
  00784	e58e2030	 str         r2, [lr, #0x30]

; 578  :     // Sync Length with buffer
; 579  :      if (pTransfer->pvBuffer == NULL) pTransfer->cbBuffer = 0;

  00788	e5923004	 ldr         r3, [r2, #4]
  0078c	e3a05000	 mov         r5, #0
  00790	e3530000	 cmp         r3, #0

; 580  : 
; 581  :     // Depending on direction
; 582  :     if (TRANSFER_IS_IN(pTransfer)) {

  00794	e5923000	 ldr         r3, [r2]
  00798	0582500c	 streq       r5, [r2, #0xC]
  0079c	e3130080	 tst         r3, #0x80
  007a0	0a00000e	 beq         |$LN2@UfnPdd_Iss|

; 583  :         pPdd->ep[endPoint].zeroLength = (pTransfer->cbBuffer == 0);

  007a4	e592300c	 ldr         r3, [r2, #0xC]
  007a8	e3530000	 cmp         r3, #0
  007ac	1a000005	 bne         |$LN6@UfnPdd_Iss|
  007b0	e3a03001	 mov         r3, #1

; 584  :         IssueTxTransfer(pPdd, endPoint);

  007b4	e58e302c	 str         r3, [lr, #0x2C]
  007b8	eb000000	 bl          IssueTxTransfer

; 594  :     }
; 595  : 
; 596  :     return ERROR_SUCCESS;

  007bc	e3a00000	 mov         r0, #0

; 597  : }

  007c0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  007c4	e12fff1e	 bx          lr
  007c8		 |$LN6@UfnPdd_Iss|

; 583  :         pPdd->ep[endPoint].zeroLength = (pTransfer->cbBuffer == 0);

  007c8	e3a03000	 mov         r3, #0

; 584  :         IssueTxTransfer(pPdd, endPoint);

  007cc	e58e302c	 str         r3, [lr, #0x2C]
  007d0	eb000000	 bl          IssueTxTransfer

; 594  :     }
; 595  : 
; 596  :     return ERROR_SUCCESS;

  007d4	e3a00000	 mov         r0, #0

; 597  : }

  007d8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  007dc	e12fff1e	 bx          lr
  007e0		 |$LN2@UfnPdd_Iss|

; 585  :     } else {
; 586  :         pPdd->ep[endPoint].zeroLength = FALSE;
; 587  :         // Select EP
; 588  :         epNum = USBD_EP_NUM & endPoint;

  007e0	e201200f	 and         r2, r1, #0xF

; 589  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  007e4	e3823020	 orr         r3, r2, #0x20
  007e8	e58e502c	 str         r5, [lr, #0x2C]
  007ec	e5843004	 str         r3, [r4, #4]

; 590  :         // Enable EP FIFO
; 591  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  007f0	e3a03004	 mov         r3, #4
  007f4	e584300c	 str         r3, [r4, #0xC]

; 592  :         // Deselect EP
; 593  :         OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  007f8	e5842004	 str         r2, [r4, #4]

; 594  :     }
; 595  : 
; 596  :     return ERROR_SUCCESS;

  007fc	e3a00000	 mov         r0, #0

; 597  : }

  00800	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00804	e12fff1e	 bx          lr
  00808		 |$M45787|

			 ENDP  ; |UfnPdd_IssueTransfer|

	EXPORT	|UfnPdd_AbortTransfer|

  00030			 AREA	 |.pdata|, PDATA
|$T45801| DCD	|$LN6@UfnPdd_Abo|
	DCD	0x40001a01
; Function compile flags: /Ogtp

  00808			 AREA	 |.text|, CODE, ARM

  00808		 |UfnPdd_AbortTransfer| PROC

; 603  : ) {

  00808		 |$LN6@UfnPdd_Abo|
  00808	e92d4030	 stmdb       sp!, {r4, r5, lr}
  0080c		 |$M45798|
  0080c	e1a04000	 mov         r4, r0

; 604  :     USBFN_PDD *pPdd = pPddContext;
; 605  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 606  :     DWORD epNum;
; 607  : 
; 608  :     // Select EP
; 609  :     epNum = USBD_EP_NUM & endPoint;
; 610  :     if (TRANSFER_IS_IN(pTransfer)) epNum |= USBD_EP_NUM_DIRIN;

  00810	e5923000	 ldr         r3, [r2]
  00814	e5940008	 ldr         r0, [r4, #8]
  00818	e201e00f	 and         lr, r1, #0xF
  0081c	e3130080	 tst         r3, #0x80
  00820	138ee010	 orrne       lr, lr, #0x10

; 611  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00824	e38e3020	 orr         r3, lr, #0x20
  00828	e5803004	 str         r3, [r0, #4]

; 612  : 
; 613  :     // Clear EP
; 614  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);

  0082c	e3a03002	 mov         r3, #2
  00830	e580300c	 str         r3, [r0, #0xC]

; 615  : 
; 616  :     // Deselect EP
; 617  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 618  : 
; 619  :     // Finish transfer
; 620  :     pPdd->ep[endPoint].pTransfer = NULL;

  00834	e0843201	 add         r3, r4, r1, lsl #4
  00838	e3a01000	 mov         r1, #0
  0083c	e3a05c01	 mov         r5, #1, 24
  00840	e580e004	 str         lr, [r0, #4]
  00844	e5831030	 str         r1, [r3, #0x30]

; 621  :     pTransfer->dwUsbError = UFN_CANCELED_ERROR;

  00848	e3853001	 orr         r3, r5, #1
  0084c	e5823014	 str         r3, [r2, #0x14]

; 622  :     pPdd->pfnNotify(
; 623  :         pPdd->pMddContext, UFN_MSG_TRANSFER_COMPLETE, (DWORD)pTransfer
; 624  :     );

  00850	e5940000	 ldr         r0, [r4]
  00854	e5943004	 ldr         r3, [r4, #4]
  00858	e3a01064	 mov         r1, #0x64
  0085c	e1a0e00f	 mov         lr, pc
  00860	e12fff13	 bx          r3

; 625  : 
; 626  :     // Done
; 627  :     return ERROR_SUCCESS;

  00864	e3a00000	 mov         r0, #0

; 628  : }

  00868	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0086c	e12fff1e	 bx          lr
  00870		 |$M45799|

			 ENDP  ; |UfnPdd_AbortTransfer|

	EXPORT	|UfnPdd_StallEndpoint|
	EXPORT	|??_C@_1DI@FFFNHHBF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAa?$AAl?$AAl?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00038			 AREA	 |.pdata|, PDATA
|$T45816| DCD	|$LN11@UfnPdd_Sta|
	DCD	0x40002001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@FFFNHHBF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAa?$AAl?$AAl?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "l"
	DCB	0x0, "l", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o"
	DCB	0x0, "i", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  00870			 AREA	 |.text|, CODE, ARM

  00870		 |UfnPdd_StallEndpoint| PROC

; 637  : {

  00870		 |$LN11@UfnPdd_Sta|
  00870	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00874		 |$M45813|
  00874	e1a04001	 mov         r4, r1
  00878	e1a06000	 mov         r6, r0

; 638  :     USBFN_PDD *pPdd = pPddContext;
; 639  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 640  :     DWORD epNum;
; 641  : 
; 642  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 643  :         L"UsbFnPdd_StallEndpoint %d\r\n", endPoint
; 644  :     ));

  0087c	e59f3068	 ldr         r3, [pc, #0x68]
  00880	e5965008	 ldr         r5, [r6, #8]
  00884	e5933440	 ldr         r3, [r3, #0x440]
  00888	e3130a02	 tst         r3, #2, 20
  0088c	13130004	 tstne       r3, #4
  00890	159f0050	 ldrne       r0, [pc, #0x50]
  00894	1b000000	 blne        NKDbgPrintfW

; 645  : 
; 646  :     if (endPoint == 0) {

  00898	e3540000	 cmp         r4, #0
  0089c	1a000004	 bne         |$LN3@UfnPdd_Sta|

; 647  : 
; 648  :         // Stall next EP0 transaction
; 649  :         OUTREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_STALL_CMD);

  008a0	e3a03020	 mov         r3, #0x20
  008a4	e585301c	 str         r3, [r5, #0x1C]

; 656  :         
; 657  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 658  : 
; 659  :         // Halt EP
; 660  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_SET_HALT);
; 661  : 
; 662  :         // Deselect EP
; 663  :         OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 664  :     }
; 665  : 
; 666  :     // Done
; 667  :     return ERROR_SUCCESS;

  008a8	e3a00000	 mov         r0, #0

; 668  : }

  008ac	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  008b0	e12fff1e	 bx          lr
  008b4		 |$LN3@UfnPdd_Sta|

; 650  : 
; 651  :     } else {
; 652  : 
; 653  :         // Select EP
; 654  :         epNum = USBD_EP_NUM & endPoint;
; 655  :         if (!pPdd->ep[endPoint].dirRx) epNum |= USBD_EP_NUM_DIRIN;

  008b4	e0863204	 add         r3, r6, r4, lsl #4
  008b8	e5933028	 ldr         r3, [r3, #0x28]
  008bc	e204200f	 and         r2, r4, #0xF

; 656  :         
; 657  :         OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 658  : 
; 659  :         // Halt EP
; 660  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_SET_HALT);
; 661  : 
; 662  :         // Deselect EP
; 663  :         OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 664  :     }
; 665  : 
; 666  :     // Done
; 667  :     return ERROR_SUCCESS;

  008c0	e3a00000	 mov         r0, #0
  008c4	e3530000	 cmp         r3, #0
  008c8	03822010	 orreq       r2, r2, #0x10
  008cc	e3823020	 orr         r3, r2, #0x20
  008d0	e5853004	 str         r3, [r5, #4]
  008d4	e3a03040	 mov         r3, #0x40
  008d8	e585300c	 str         r3, [r5, #0xC]
  008dc	e5852004	 str         r2, [r5, #4]

; 668  : }

  008e0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  008e4	e12fff1e	 bx          lr
  008e8		 |$LN12@UfnPdd_Sta|
  008e8		 |$LN13@UfnPdd_Sta|
  008e8	00000000	 DCD         |??_C@_1DI@FFFNHHBF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAa?$AAl?$AAl?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  008ec		 |$LN14@UfnPdd_Sta|
  008ec	00000000	 DCD         |dpCurSettings|
  008f0		 |$M45814|

			 ENDP  ; |UfnPdd_StallEndpoint|

	EXPORT	|UfnPdd_ClearEndpointStall|
	EXPORT	|??_C@_1DI@EBJLFADF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00040			 AREA	 |.pdata|, PDATA
|$T45836| DCD	|$LN10@UfnPdd_Cle|
	DCD	0x40001e01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@EBJLFADF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "C", 0x0, "l", 0x0, "e", 0x0, "a"
	DCB	0x0, "r", 0x0, "E", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o"
	DCB	0x0, "i", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  008f0			 AREA	 |.text|, CODE, ARM

  008f0		 |UfnPdd_ClearEndpointStall| PROC

; 677  : {

  008f0		 |$LN10@UfnPdd_Cle|
  008f0	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  008f4		 |$M45833|
  008f4	e1a04001	 mov         r4, r1
  008f8	e1a06000	 mov         r6, r0

; 678  :     DWORD rc = ERROR_INVALID_FUNCTION;
; 679  :     USBFN_PDD *pPdd = pPddContext;
; 680  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 681  :     DWORD epNum;
; 682  : 
; 683  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 684  :         L"UsbFnPdd_ClearEndpoint %d\r\n", endPoint
; 685  :     ));

  008fc	e59f3060	 ldr         r3, [pc, #0x60]
  00900	e5965008	 ldr         r5, [r6, #8]
  00904	e5933440	 ldr         r3, [r3, #0x440]
  00908	e3130a02	 tst         r3, #2, 20
  0090c	13130004	 tstne       r3, #4
  00910	159f0048	 ldrne       r0, [pc, #0x48]
  00914	1b000000	 blne        NKDbgPrintfW

; 686  : 
; 687  :     // Endpoint can't be zero
; 688  :     if (endPoint == 0) goto clean;

  00918	e3540000	 cmp         r4, #0
  0091c	0a00000c	 beq         |$LN7@UfnPdd_Cle|

; 689  :     
; 690  :     // Select EP
; 691  :     epNum = USBD_EP_NUM & endPoint;
; 692  :     if (!pPdd->ep[endPoint].dirRx) epNum |= USBD_EP_NUM_DIRIN;

  00920	e0863204	 add         r3, r6, r4, lsl #4
  00924	e5933028	 ldr         r3, [r3, #0x28]
  00928	e204200f	 and         r2, r4, #0xF

; 693  : 
; 694  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 695  : 
; 696  :     // Reset endpoint - clear halt isn't sufficient
; 697  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_RESET_EP);
; 698  : 
; 699  :     // Deselect EP
; 700  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);
; 701  : 
; 702  :     // Done
; 703  :     rc = ERROR_SUCCESS;

  0092c	e3a00000	 mov         r0, #0
  00930	e3530000	 cmp         r3, #0
  00934	03822010	 orreq       r2, r2, #0x10
  00938	e3823020	 orr         r3, r2, #0x20
  0093c	e5853004	 str         r3, [r5, #4]
  00940	e3a03001	 mov         r3, #1
  00944	e585300c	 str         r3, [r5, #0xC]
  00948	e5852004	 str         r2, [r5, #4]

; 704  : 
; 705  : clean:
; 706  :     return rc;
; 707  : }

  0094c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00950	e12fff1e	 bx          lr
  00954		 |$LN7@UfnPdd_Cle|
  00954	e3a00001	 mov         r0, #1
  00958		 |$clean$45264|
  00958	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0095c	e12fff1e	 bx          lr
  00960		 |$LN11@UfnPdd_Cle|
  00960		 |$LN12@UfnPdd_Cle|
  00960	00000000	 DCD         |??_C@_1DI@EBJLFADF@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAC?$AAl?$AAe?$AAa?$AAr?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00964		 |$LN13@UfnPdd_Cle|
  00964	00000000	 DCD         |dpCurSettings|
  00968		 |$M45834|

			 ENDP  ; |UfnPdd_ClearEndpointStall|

	EXPORT	|UfnPdd_IsEndpointHalted|
	EXPORT	|??_C@_1DO@MLIBPKBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAH?$AAa?$AAl?$AAt?$AAe?$AAd?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00048			 AREA	 |.pdata|, PDATA
|$T45859| DCD	|$LN12@UfnPdd_IsE|
	DCD	0x40002801

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@MLIBPKBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAH?$AAa?$AAl?$AAt?$AAe?$AAd?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "I", 0x0, "s", 0x0, "E", 0x0, "n"
	DCB	0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t"
	DCB	0x0, "H", 0x0, "a", 0x0, "l", 0x0, "t", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogtp

  00968			 AREA	 |.text|, CODE, ARM

  00968		 |UfnPdd_IsEndpointHalted| PROC

; 715  : ) {

  00968		 |$LN12@UfnPdd_IsE|
  00968	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  0096c		 |$M45856|
  0096c	e1a07002	 mov         r7, r2
  00970	e1a04001	 mov         r4, r1
  00974	e1a06000	 mov         r6, r0

; 716  :     DWORD rc = ERROR_INVALID_FUNCTION;
; 717  :     USBFN_PDD *pPdd = pPddContext;
; 718  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 719  :     DWORD epNum;
; 720  : 
; 721  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 722  :         L"UsbFnPdd_IsEndpointHalted %d\r\n", endPoint
; 723  :     ));

  00978	e59f3084	 ldr         r3, [pc, #0x84]
  0097c	e5965008	 ldr         r5, [r6, #8]
  00980	e5933440	 ldr         r3, [r3, #0x440]
  00984	e3130a02	 tst         r3, #2, 20
  00988	13130004	 tstne       r3, #4
  0098c	159f006c	 ldrne       r0, [pc, #0x6C]
  00990	1b000000	 blne        NKDbgPrintfW

; 724  : 
; 725  :     // Endpoint can't be zero
; 726  :     if (endPoint == 0) goto clean;

  00994	e3540000	 cmp         r4, #0
  00998	0a000015	 beq         |$LN9@UfnPdd_IsE|

; 727  :     
; 728  : 
; 729  :     // Select EP
; 730  :     epNum = USBD_EP_NUM & endPoint;
; 731  :     if (!pPdd->ep[endPoint].dirRx) epNum |= USBD_EP_NUM_DIRIN;

  0099c	e0863204	 add         r3, r6, r4, lsl #4
  009a0	e5933028	 ldr         r3, [r3, #0x28]
  009a4	e204200f	 and         r2, r4, #0xF
  009a8	e3530000	 cmp         r3, #0
  009ac	03822010	 orreq       r2, r2, #0x10

; 732  : 
; 733  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  009b0	e3823020	 orr         r3, r2, #0x20
  009b4	e5853004	 str         r3, [r5, #4]

; 734  : 
; 735  :     // Is EP halted?
; 736  :     *pHalted = (INREG32(&pUSBDRegs->STAT_FLG) & USBD_STAT_HALTED) != 0;

  009b8	e5953010	 ldr         r3, [r5, #0x10]
  009bc	e3130040	 tst         r3, #0x40
  009c0	0a000005	 beq         |$LN7@UfnPdd_IsE|
  009c4	e3a03001	 mov         r3, #1
  009c8	e5873000	 str         r3, [r7]

; 737  : 
; 738  :     // Deselect EP
; 739  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  009cc	e5852004	 str         r2, [r5, #4]

; 740  : 
; 741  :     // Done
; 742  :     rc = ERROR_SUCCESS;

  009d0	e3a00000	 mov         r0, #0

; 743  :     
; 744  : clean:
; 745  :     return rc;
; 746  : }

  009d4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  009d8	e12fff1e	 bx          lr
  009dc		 |$LN7@UfnPdd_IsE|

; 734  : 
; 735  :     // Is EP halted?
; 736  :     *pHalted = (INREG32(&pUSBDRegs->STAT_FLG) & USBD_STAT_HALTED) != 0;

  009dc	e3a03000	 mov         r3, #0
  009e0	e5873000	 str         r3, [r7]

; 737  : 
; 738  :     // Deselect EP
; 739  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  009e4	e5852004	 str         r2, [r5, #4]

; 740  : 
; 741  :     // Done
; 742  :     rc = ERROR_SUCCESS;

  009e8	e3a00000	 mov         r0, #0

; 743  :     
; 744  : clean:
; 745  :     return rc;
; 746  : }

  009ec	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  009f0	e12fff1e	 bx          lr
  009f4		 |$LN9@UfnPdd_IsE|
  009f4	e3a00001	 mov         r0, #1
  009f8		 |$clean$45287|
  009f8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  009fc	e12fff1e	 bx          lr
  00a00		 |$LN13@UfnPdd_IsE|
  00a00		 |$LN14@UfnPdd_IsE|
  00a00	00000000	 DCD         |??_C@_1DO@MLIBPKBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAs?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AAH?$AAa?$AAl?$AAt?$AAe?$AAd?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00a04		 |$LN15@UfnPdd_IsE|
  00a04	00000000	 DCD         |dpCurSettings|
  00a08		 |$M45857|

			 ENDP  ; |UfnPdd_IsEndpointHalted|

	EXPORT	|UfnPdd_SendControlStatusHandshake|
	EXPORT	|??_C@_1GM@CFMOOMGC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAn?$AAd?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAH?$AAa?$AAn?$AAd?$AAh?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@| [ DATA ] ; `string'

  00050			 AREA	 |.pdata|, PDATA
|$T45878| DCD	|$LN11@UfnPdd_Sen|
	DCD	0x40002401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@CFMOOMGC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAn?$AAd?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAH?$AAa?$AAn?$AAd?$AAh?$AAa@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "S", 0x0, "e", 0x0, "n", 0x0, "d"
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o"
	DCB	0x0, "l", 0x0, "S", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "u"
	DCB	0x0, "s", 0x0, "H", 0x0, "a", 0x0, "n", 0x0, "d", 0x0, "h"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " ", 0x0, "("
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, " ", 0x0, "%"
	DCB	0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@| DCB "O", 0x0, "U", 0x0, "T", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@| DCB "I", 0x0, "N", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogtp

  00a08			 AREA	 |.text|, CODE, ARM

  00a08		 |UfnPdd_SendControlStatusHandshake| PROC

; 756  : ) {

  00a08		 |$LN11@UfnPdd_Sen|
  00a08	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00a0c		 |$M45875|

; 757  :     USBFN_PDD *pPdd = pPddContext;
; 758  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 759  :     DWORD epNum, stat;
; 760  : 
; 761  :     // Select EP
; 762  :     epNum = USBD_EP_NUM & endPoint;
; 763  :     if (pPdd->setupDirRx) epNum |= USBD_EP_NUM_DIRIN;

  00a0c	e5903018	 ldr         r3, [r0, #0x18]
  00a10	e5905008	 ldr         r5, [r0, #8]
  00a14	e201400f	 and         r4, r1, #0xF
  00a18	e3530000	 cmp         r3, #0

; 764  : 
; 765  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);
; 766  : 
; 767  :     // Get actual status
; 768  :     stat = INREG32(&pUSBDRegs->STAT_FLG);
; 769  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 770  :         L"UsbFnPdd_SendControlStatusHandhake: %d %s (stat %x)\r\n",
; 771  :         endPoint, pPdd->setupDirRx ? L"IN" : L"OUT", stat
; 772  :     ));

  00a1c	e59f2070	 ldr         r2, [pc, #0x70]
  00a20	13844010	 orrne       r4, r4, #0x10
  00a24	e3843020	 orr         r3, r4, #0x20
  00a28	e5853004	 str         r3, [r5, #4]
  00a2c	e5923440	 ldr         r3, [r2, #0x440]
  00a30	e5956010	 ldr         r6, [r5, #0x10]
  00a34	e3130a02	 tst         r3, #2, 20
  00a38	0a000008	 beq         |$LN5@UfnPdd_Sen|
  00a3c	e3130004	 tst         r3, #4
  00a40	0a000006	 beq         |$LN5@UfnPdd_Sen|
  00a44	e5903018	 ldr         r3, [r0, #0x18]
  00a48	e59f0040	 ldr         r0, [pc, #0x40]
  00a4c	e3530000	 cmp         r3, #0
  00a50	159f2034	 ldrne       r2, [pc, #0x34]
  00a54	059f202c	 ldreq       r2, [pc, #0x2C]
  00a58	e1a03006	 mov         r3, r6
  00a5c	eb000000	 bl          NKDbgPrintfW
  00a60		 |$LN5@UfnPdd_Sen|

; 773  : 
; 774  :     // Don't send handshake when EP is stall
; 775  :     if ((stat & USBD_STAT_STALL) == 0) {

  00a60	e3160020	 tst         r6, #0x20
  00a64	1a000003	 bne         |$LN1@UfnPdd_Sen|

; 776  :         // Clear & enable FIFO
; 777  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);

  00a68	e3a03002	 mov         r3, #2
  00a6c	e585300c	 str         r3, [r5, #0xC]

; 778  :         OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_FIFO_EN);

  00a70	e3a03004	 mov         r3, #4
  00a74	e585300c	 str         r3, [r5, #0xC]
  00a78		 |$LN1@UfnPdd_Sen|

; 779  :     }
; 780  : 
; 781  :     // Deselect EP
; 782  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00a78	e5854004	 str         r4, [r5, #4]

; 783  : 
; 784  :     return ERROR_SUCCESS;

  00a7c	e3a00000	 mov         r0, #0

; 785  : }

  00a80	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00a84	e12fff1e	 bx          lr
  00a88		 |$LN12@UfnPdd_Sen|
  00a88		 |$LN13@UfnPdd_Sen|
  00a88	00000000	 DCD         |??_C@_17HCEMPBGG@?$AAO?$AAU?$AAT?$AA?$AA@|
  00a8c		 |$LN14@UfnPdd_Sen|
  00a8c	00000000	 DCD         |??_C@_15BNKBCKPG@?$AAI?$AAN?$AA?$AA@|
  00a90		 |$LN15@UfnPdd_Sen|
  00a90	00000000	 DCD         |??_C@_1GM@CFMOOMGC@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAn?$AAd?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAH?$AAa?$AAn?$AAd?$AAh?$AAa@|
  00a94		 |$LN16@UfnPdd_Sen|
  00a94	00000000	 DCD         |dpCurSettings|
  00a98		 |$M45876|

			 ENDP  ; |UfnPdd_SendControlStatusHandshake|

	EXPORT	|UfnPdd_InitiateRemoteWakeup|
	EXPORT	|??_C@_1EA@KNMJPPBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAt?$AAe?$AAR?$AAe?$AAm?$AAo?$AAt?$AAe?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00058			 AREA	 |.pdata|, PDATA
|$T45894| DCD	|$LN7@UfnPdd_Ini|
	DCD	0x40001001

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@KNMJPPBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAt?$AAe?$AAR?$AAe?$AAm?$AAo?$AAt?$AAe?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "s", 0x0, "b", 0x0, "F", 0x0, "n", 0x0, "P", 0x0, "d"
	DCB	0x0, "d", 0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "i", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, "R", 0x0, "e"
	DCB	0x0, "m", 0x0, "o", 0x0, "t", 0x0, "e", 0x0, "W", 0x0, "a"
	DCB	0x0, "k", 0x0, "e", 0x0, "u", 0x0, "p", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00a98			 AREA	 |.text|, CODE, ARM

  00a98		 |UfnPdd_InitiateRemoteWakeup| PROC

; 792  : {

  00a98		 |$LN7@UfnPdd_Ini|
  00a98	e92d4010	 stmdb       sp!, {r4, lr}
  00a9c		 |$M45891|

; 793  :     USBFN_PDD *pPdd = pPddContext;
; 794  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 795  : 
; 796  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"UsbFnPdd_InitiateRemoteWakeup\r\n"));

  00a9c	e59f3030	 ldr         r3, [pc, #0x30]
  00aa0	e5904008	 ldr         r4, [r0, #8]
  00aa4	e5933440	 ldr         r3, [r3, #0x440]
  00aa8	e3130a02	 tst         r3, #2, 20
  00aac	13130004	 tstne       r3, #4
  00ab0	159f0018	 ldrne       r0, [pc, #0x18]
  00ab4	1b000000	 blne        NKDbgPrintfW

; 797  :     SETREG32(&pUSBDRegs->SYSCON2, USBD_SYSCON2_RMT_WKP);

  00ab8	e594301c	 ldr         r3, [r4, #0x1C]

; 798  :     return ERROR_SUCCESS;

  00abc	e3a00000	 mov         r0, #0
  00ac0	e3833040	 orr         r3, r3, #0x40
  00ac4	e584301c	 str         r3, [r4, #0x1C]

; 799  : }

  00ac8	e8bd4010	 ldmia       sp!, {r4, lr}
  00acc	e12fff1e	 bx          lr
  00ad0		 |$LN8@UfnPdd_Ini|
  00ad0		 |$LN9@UfnPdd_Ini|
  00ad0	00000000	 DCD         |??_C@_1EA@KNMJPPBI@?$AAU?$AAs?$AAb?$AAF?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAt?$AAe?$AAR?$AAe?$AAm?$AAo?$AAt?$AAe?$AAW?$AAa?$AAk?$AAe?$AAu?$AAp?$AA?$AN?$AA?6?$AA?$AA@|
  00ad4		 |$LN10@UfnPdd_Ini|
  00ad4	00000000	 DCD         |dpCurSettings|
  00ad8		 |$M45892|

			 ENDP  ; |UfnPdd_InitiateRemoteWakeup|

	EXPORT	|UfnPdd_PowerDown|

  00060			 AREA	 |.pdata|, PDATA
|$T45902| DCD	|$LN5@UfnPdd_Pow|
	DCD	0x40000100
; Function compile flags: /Ogtp

  00ad8			 AREA	 |.text|, CODE, ARM

  00ad8		 |UfnPdd_PowerDown| PROC

; 806  : {

  00ad8		 |$LN5@UfnPdd_Pow|
  00ad8		 |$M45899|

; 807  : }

  00ad8	e12fff1e	 bx          lr
  00adc		 |$M45900|

			 ENDP  ; |UfnPdd_PowerDown|

	EXPORT	|UfnPdd_PowerUp|

  00068			 AREA	 |.pdata|, PDATA
|$T45907| DCD	|$LN5@UfnPdd_Pow@2|
	DCD	0x40000100
; Function compile flags: /Ogtp

  00adc			 AREA	 |.text|, CODE, ARM

  00adc		 |UfnPdd_PowerUp| PROC

; 814  : {

  00adc		 |$LN5@UfnPdd_Pow@2|
  00adc		 |$M45904|

; 815  : }

  00adc	e12fff1e	 bx          lr
  00ae0		 |$M45905|

			 ENDP  ; |UfnPdd_PowerUp|

	EXPORT	|UfnPdd_IOControl|

  00070			 AREA	 |.pdata|, PDATA
|$T45918| DCD	|$LN13@UfnPdd_IOC|
	DCD	0x40001400
; Function compile flags: /Ogtp

  00ae0			 AREA	 |.text|, CODE, ARM

  00ae0		 |UfnPdd_IOControl| PROC

; 824  : ) {

  00ae0		 |$LN13@UfnPdd_IOC|
  00ae0		 |$M45915|
  00ae0	e3a03822	 mov         r3, #0x22, 16

; 825  :     DWORD rc = ERROR_INVALID_PARAMETER;
; 826  :     USBFN_PDD *pPdd = pPddContext;
; 827  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 828  :     UFN_PDD_INFO *pInfo;
; 829  : 
; 830  :     switch (code) {

  00ae4	e3833f65	 orr         r3, r3, #0x65, 30
  00ae8	e1520003	 cmp         r2, r3
  00aec	e3a00057	 mov         r0, #0x57
  00af0	1a00000d	 bne         |$LN3@UfnPdd_IOC|

; 831  :     case IOCTL_UFN_GET_PDD_INFO:
; 832  :         if (source != BUS_IOCTL) break;

  00af4	e3510000	 cmp         r1, #0
  00af8	1a00000b	 bne         |$LN3@UfnPdd_IOC|

; 833  :         if (pOutBuffer == NULL || outSize < sizeof(UFN_PDD_INFO)) break;

  00afc	e59d2004	 ldr         r2, [sp, #4]
  00b00	e3520000	 cmp         r2, #0
  00b04	0a000008	 beq         |$LN3@UfnPdd_IOC|
  00b08	e59d3008	 ldr         r3, [sp, #8]
  00b0c	e353000c	 cmp         r3, #0xC
  00b10	3a000005	 bcc         |$LN3@UfnPdd_IOC|

; 834  :         pInfo = (UFN_PDD_INFO*)pOutBuffer;
; 835  :         pInfo->InterfaceType = Internal;
; 836  :         pInfo->BusNumber = 0;
; 837  :         pInfo->dwAlignment = sizeof(DWORD);

  00b14	e3a03004	 mov         r3, #4
  00b18	e3a01000	 mov         r1, #0
  00b1c	e5823008	 str         r3, [r2, #8]
  00b20	e5821000	 str         r1, [r2]
  00b24	e5821004	 str         r1, [r2, #4]

; 838  :         rc = ERROR_SUCCESS;

  00b28	e3a00000	 mov         r0, #0
  00b2c		 |$LN3@UfnPdd_IOC|

; 839  :         break;
; 840  :     case IOCTL_BUS_GET_POWER_STATE:
; 841  :         break;
; 842  : 
; 843  :     case IOCTL_BUS_SET_POWER_STATE:
; 844  :         break;
; 845  :     }
; 846  :     
; 847  :     return rc;
; 848  : }

  00b2c	e12fff1e	 bx          lr
  00b30		 |$M45916|

			 ENDP  ; |UfnPdd_IOControl|

	EXPORT	|UfnPdd_Deinit|

  00078			 AREA	 |.pdata|, PDATA
|$T45928| DCD	|$LN7@UfnPdd_Dei|
	DCD	0x40000600
; Function compile flags: /Ogtp

  00b30			 AREA	 |.text|, CODE, ARM

  00b30		 |UfnPdd_Deinit| PROC

; 855  : {

  00b30		 |$LN7@UfnPdd_Dei|
  00b30		 |$M45925|

; 856  :     USBFN_PDD *pPdd = pPddContext;
; 857  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 858  : 
; 859  :     // Unmap USBD controller registers
; 860  :     if (pPdd->pUSBDRegs != NULL) {

  00b30	e5903008	 ldr         r3, [r0, #8]
  00b34	e3530000	 cmp         r3, #0

; 861  :         pPdd->pUSBDRegs = NULL;

  00b38	13a03000	 movne       r3, #0
  00b3c	15803008	 strne       r3, [r0, #8]

; 862  :     }
; 863  : 
; 864  :     // Done
; 865  :     return ERROR_SUCCESS;

  00b40	e3a00000	 mov         r0, #0

; 866  : }

  00b44	e12fff1e	 bx          lr
  00b48		 |$M45926|

			 ENDP  ; |UfnPdd_Deinit|

	EXPORT	|UfnPdd_DeregisterDevice|

  00080			 AREA	 |.pdata|, PDATA
|$T45939| DCD	|$LN10@UfnPdd_Der|
	DCD	0x40000c00
; Function compile flags: /Ogtp

  00b48			 AREA	 |.text|, CODE, ARM

  00b48		 |UfnPdd_DeregisterDevice| PROC

; 876  : {

  00b48		 |$LN10@UfnPdd_Der|
  00b48		 |$M45936|

; 877  :     USBFN_PDD *pPdd = pPddContext;
; 878  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00b48	e5903008	 ldr         r3, [r0, #8]

; 879  :     DWORD ep;
; 880  : 
; 881  :     // Disable all RX, TX EPs
; 882  :     OUTREG32(&pUSBDRegs->EP0, 0);

  00b4c	e3a01000	 mov         r1, #0
  00b50	e3a0200f	 mov         r2, #0xF
  00b54	e5831080	 str         r1, [r3, #0x80]
  00b58	e2833088	 add         r3, r3, #0x88
  00b5c		 |$LL3@UfnPdd_Der|

; 883  :     for (ep = 1; ep < USBD_EP_COUNT; ep++) {
; 884  :         OUTREG32(&pUSBDRegs->EP_RX[ep], 0);

  00b5c	e5831000	 str         r1, [r3]

; 885  :         OUTREG32(&pUSBDRegs->EP_TX[ep], 0);

  00b60	e5831040	 str         r1, [r3, #0x40]
  00b64	e2833004	 add         r3, r3, #4
  00b68	e2522001	 subs        r2, r2, #1
  00b6c	1afffffa	 bne         |$LL3@UfnPdd_Der|

; 886  :     }
; 887  : 
; 888  :     return ERROR_SUCCESS;

  00b70	e3a00000	 mov         r0, #0

; 889  : }

  00b74	e12fff1e	 bx          lr
  00b78		 |$M45937|

			 ENDP  ; |UfnPdd_DeregisterDevice|

	EXPORT	|UfnPdd_Stop|
	EXPORT	|??_C@_1BM@ELBPNMDN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAo?$AAp?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|DisconnectHardware|

  00088			 AREA	 |.pdata|, PDATA
|$T45950| DCD	|$LN7@UfnPdd_Sto|
	DCD	0x40001101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@ELBPNMDN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAo?$AAp?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "S", 0x0, "t", 0x0, "o", 0x0, "p", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00b78			 AREA	 |.text|, CODE, ARM

  00b78		 |UfnPdd_Stop| PROC

; 900  : {

  00b78		 |$LN7@UfnPdd_Sto|
  00b78	e92d4010	 stmdb       sp!, {r4, lr}
  00b7c		 |$M45947|

; 901  :     USBFN_PDD *pPdd = pPddContext;
; 902  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 903  : 
; 904  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"UfnPdd_Stop\r\n"));

  00b7c	e59f3034	 ldr         r3, [pc, #0x34]
  00b80	e5904008	 ldr         r4, [r0, #8]
  00b84	e5933440	 ldr         r3, [r3, #0x440]
  00b88	e3130a02	 tst         r3, #2, 20
  00b8c	13130004	 tstne       r3, #4
  00b90	159f001c	 ldrne       r0, [pc, #0x1C]
  00b94	1b000000	 blne        NKDbgPrintfW

; 905  : 
; 906  :     // Deattach device
; 907  :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  00b98	e5943018	 ldr         r3, [r4, #0x18]
  00b9c	e3c33001	 bic         r3, r3, #1
  00ba0	e5843018	 str         r3, [r4, #0x18]

; 908  :     DisconnectHardware();

  00ba4	eb000000	 bl          DisconnectHardware

; 909  : 
; 910  :     // Disable USB device PLL clock
; 911  :     // ClkRelease(pPdd->hClk, 1); @todo
; 912  : 
; 913  :     // Done
; 914  :     return ERROR_SUCCESS;

  00ba8	e3a00000	 mov         r0, #0

; 915  : }

  00bac	e8bd4010	 ldmia       sp!, {r4, lr}
  00bb0	e12fff1e	 bx          lr
  00bb4		 |$LN8@UfnPdd_Sto|
  00bb4		 |$LN9@UfnPdd_Sto|
  00bb4	00000000	 DCD         |??_C@_1BM@ELBPNMDN@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAt?$AAo?$AAp?$AA?$AN?$AA?6?$AA?$AA@|
  00bb8		 |$LN10@UfnPdd_Sto|
  00bb8	00000000	 DCD         |dpCurSettings|
  00bbc		 |$M45948|

			 ENDP  ; |UfnPdd_Stop|

	EXPORT	|UfnPdd_DeinitEndpoint|
	EXPORT	|??_C@_1DI@DNFBFJFI@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00090			 AREA	 |.pdata|, PDATA
|$T45966| DCD	|$LN7@UfnPdd_Dei@2|
	DCD	0x40001401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@DNFBFJFI@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "E", 0x0, "n", 0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i"
	DCB	0x0, "n", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  00bbc			 AREA	 |.text|, CODE, ARM

  00bbc		 |UfnPdd_DeinitEndpoint| PROC

; 925  : {

  00bbc		 |$LN7@UfnPdd_Dei@2|
  00bbc	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00bc0		 |$M45963|
  00bc0	e1a04001	 mov         r4, r1

; 926  :     USBFN_PDD *pPdd = pPddContext;
; 927  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 928  :     DWORD epNum;
; 929  : 
; 930  :     OALMSG(OAL_ETHER&&OAL_FUNC, (L"UfnPdd_DeinitEndpoint: %d\r\n", endPoint));

  00bc4	e59f303c	 ldr         r3, [pc, #0x3C]
  00bc8	e5905008	 ldr         r5, [r0, #8]
  00bcc	e5933440	 ldr         r3, [r3, #0x440]
  00bd0	e3130a02	 tst         r3, #2, 20
  00bd4	13130004	 tstne       r3, #4
  00bd8	159f0024	 ldrne       r0, [pc, #0x24]
  00bdc	1b000000	 blne        NKDbgPrintfW

; 931  : 
; 932  :     // Select EP
; 933  :     epNum = USBD_EP_NUM & endPoint;

  00be0	e204200f	 and         r2, r4, #0xF

; 934  :     OUTREG32(&pUSBDRegs->EP_NUM, USBD_EP_NUM_SEL | epNum);

  00be4	e3823020	 orr         r3, r2, #0x20
  00be8	e5853004	 str         r3, [r5, #4]

; 935  : 
; 936  :     // Clear EP
; 937  :     OUTREG32(&pUSBDRegs->CTRL, USBD_CTRL_CLR_EP);

  00bec	e3a03002	 mov         r3, #2
  00bf0	e585300c	 str         r3, [r5, #0xC]

; 938  : 
; 939  :     // Deselect EP
; 940  :     OUTREG32(&pUSBDRegs->EP_NUM, epNum);

  00bf4	e5852004	 str         r2, [r5, #4]

; 941  : 
; 942  :     // Done
; 943  :     return ERROR_SUCCESS;

  00bf8	e3a00000	 mov         r0, #0

; 944  : }

  00bfc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00c00	e12fff1e	 bx          lr
  00c04		 |$LN8@UfnPdd_Dei@2|
  00c04		 |$LN9@UfnPdd_Dei@2|
  00c04	00000000	 DCD         |??_C@_1DI@DNFBFJFI@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00c08		 |$LN10@UfnPdd_Dei@2|
  00c08	00000000	 DCD         |dpCurSettings|
  00c0c		 |$M45964|

			 ENDP  ; |UfnPdd_DeinitEndpoint|

	EXPORT	|UfnPdd_InitEndpoint|
	EXPORT	|??_C@_1DE@CLEBGKIE@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  00098			 AREA	 |.pdata|, PDATA
|$T45983| DCD	|$LN9@UfnPdd_Ini@2|
	DCD	0x40000c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@CLEBGKIE@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "E", 0x0, "n"
	DCB	0x0, "d", 0x0, "p", 0x0, "o", 0x0, "i", 0x0, "n", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogtp

  00c0c			 AREA	 |.text|, CODE, ARM

  00c0c		 |UfnPdd_InitEndpoint| PROC

; 958  : ) {

  00c0c		 |$LN9@UfnPdd_Ini@2|
  00c0c	e52de004	 str         lr, [sp, #-4]!
  00c10		 |$M45980|

; 959  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 960  :         L"UfnPdd_InitEndpoint: %d\r\n", endPoint
; 961  :     ));

  00c10	e59f3020	 ldr         r3, [pc, #0x20]
  00c14	e5933440	 ldr         r3, [r3, #0x440]
  00c18	e3130a02	 tst         r3, #2, 20
  00c1c	13130004	 tstne       r3, #4
  00c20	159f000c	 ldrne       r0, [pc, #0xC]
  00c24	1b000000	 blne        NKDbgPrintfW

; 962  :     return ERROR_SUCCESS;

  00c28	e3a00000	 mov         r0, #0

; 963  : }

  00c2c	e49de004	 ldr         lr, [sp], #4
  00c30	e12fff1e	 bx          lr
  00c34		 |$LN10@UfnPdd_Ini@2|
  00c34		 |$LN11@UfnPdd_Ini@2|
  00c34	00000000	 DCD         |??_C@_1DE@CLEBGKIE@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AAE?$AAn?$AAd?$AAp?$AAo?$AAi?$AAn?$AAt?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00c38		 |$LN12@UfnPdd_Ini@2|
  00c38	00000000	 DCD         |dpCurSettings|
  00c3c		 |$M45981|

			 ENDP  ; |UfnPdd_InitEndpoint|

	EXPORT	|UfnPdd_SetAddress|
	EXPORT	|??_C@_1DA@IMJLDCBL@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAt?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'

  000a0			 AREA	 |.pdata|, PDATA
|$T46000| DCD	|$LN9@UfnPdd_Set|
	DCD	0x40000c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DA@IMJLDCBL@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAt?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d", 0x0, "_"
	DCB	0x0, "S", 0x0, "e", 0x0, "t", 0x0, "A", 0x0, "d", 0x0, "d"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogtp

  00c3c			 AREA	 |.text|, CODE, ARM

  00c3c		 |UfnPdd_SetAddress| PROC

; 973  : {

  00c3c		 |$LN9@UfnPdd_Set|
  00c3c	e52de004	 str         lr, [sp, #-4]!
  00c40		 |$M45997|

; 974  :     OALMSG(OAL_ETHER&&OAL_FUNC, (
; 975  :         L"UfnPdd_SetAddress: %d\r\n", address
; 976  :     ));

  00c40	e59f3020	 ldr         r3, [pc, #0x20]
  00c44	e5933440	 ldr         r3, [r3, #0x440]
  00c48	e3130a02	 tst         r3, #2, 20
  00c4c	13130004	 tstne       r3, #4
  00c50	159f000c	 ldrne       r0, [pc, #0xC]
  00c54	1b000000	 blne        NKDbgPrintfW

; 977  :     return ERROR_SUCCESS;

  00c58	e3a00000	 mov         r0, #0

; 978  : }

  00c5c	e49de004	 ldr         lr, [sp], #4
  00c60	e12fff1e	 bx          lr
  00c64		 |$LN10@UfnPdd_Set|
  00c64		 |$LN11@UfnPdd_Set|
  00c64	00000000	 DCD         |??_C@_1DA@IMJLDCBL@?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAS?$AAe?$AAt?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?3?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  00c68		 |$LN12@UfnPdd_Set|
  00c68	00000000	 DCD         |dpCurSettings|
  00c6c		 |$M45998|

			 ENDP  ; |UfnPdd_SetAddress|

	EXPORT	|UfnPdd_Start|
	IMPORT	|ConnectHardware|
	IMPORT	|OALStall|

  000a8			 AREA	 |.pdata|, PDATA
|$T46012| DCD	|$LN5@UfnPdd_Sta@2|
	DCD	0x40001501
; Function compile flags: /Ogtp

  00c6c			 AREA	 |.text|, CODE, ARM

  00c6c		 |UfnPdd_Start| PROC

; 988  : {

  00c6c		 |$LN5@UfnPdd_Sta@2|
  00c6c	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00c70		 |$M46009|
  00c70	e1a05000	 mov         r5, r0

; 989  :     USBFN_PDD *pPdd = pPddContext;
; 990  :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;

  00c74	e5954008	 ldr         r4, [r5, #8]

; 991  : 
; 992  :     // Disconnect hardware
; 993  :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  00c78	e5943018	 ldr         r3, [r4, #0x18]
  00c7c	e3c33001	 bic         r3, r3, #1
  00c80	e5843018	 str         r3, [r4, #0x18]

; 994  :     DisconnectHardware();

  00c84	eb000000	 bl          DisconnectHardware
  00c88	e3a03c27	 mov         r3, #0x27, 24

; 995  : 
; 996  :     // Wait for while
; 997  :     OALStall(10000);

  00c8c	e3830010	 orr         r0, r3, #0x10
  00c90	eb000000	 bl          OALStall

; 998  : 
; 999  :     // Enable interrupts
; 1000 :     OUTREG32(&pUSBDRegs->IRQ_EN, USBD_IRQ_MASK);

  00c94	e3a03039	 mov         r3, #0x39
  00c98	e5843028	 str         r3, [r4, #0x28]

; 1001 : 
; 1002 :     // Attach device to bus (it has no effect when OTG controller is used)
; 1003 :     SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_PULLUP_EN);

  00c9c	e5943018	 ldr         r3, [r4, #0x18]
  00ca0	e3833001	 orr         r3, r3, #1
  00ca4	e5843018	 str         r3, [r4, #0x18]

; 1004 :     ConnectHardware();

  00ca8	eb000000	 bl          ConnectHardware

; 1005 : 
; 1006 :     // Set fake device change flag which on first interrupt force
; 1007 :     // device state change handler even if it isn't indicated by hardware
; 1008 :     pPdd->fakeDsChange = TRUE;

  00cac	e3a03001	 mov         r3, #1
  00cb0	e5853124	 str         r3, [r5, #0x124]

; 1009 : 
; 1010 :     // Done
; 1011 :     return ERROR_SUCCESS;

  00cb4	e3a00000	 mov         r0, #0

; 1012 : }

  00cb8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00cbc	e12fff1e	 bx          lr
  00cc0		 |$M46010|

			 ENDP  ; |UfnPdd_Start|

	EXPORT	|UfnPdd_RegisterDevice|

  000b0			 AREA	 |.pdata|, PDATA
|$T46046| DCD	|$LN31@UfnPdd_Reg|
	DCD	0x40009e02
; Function compile flags: /Ogtp

  00cc0			 AREA	 |.text|, CODE, ARM

  00cc0		 |UfnPdd_RegisterDevice| PROC

; 1033 : ) {

  00cc0		 |$LN31@UfnPdd_Reg|
  00cc0	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00cc4	e24dd00c	 sub         sp, sp, #0xC
  00cc8		 |$M46043|
  00cc8	e1a06000	 mov         r6, r0
  00ccc	e58d6008	 str         r6, [sp, #8]

; 1034 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1035 :     USBFN_PDD *pPdd = pPddContext;
; 1036 :     OMAP5912_USBD_REGS *pUSBDRegs = pPdd->pUSBDRegs;
; 1037 :     UFN_INTERFACE *pIFC;
; 1038 :     UFN_ENDPOINT *pEP;
; 1039 :     DWORD offset, ep, cfg;
; 1040 :     DWORD ifc, epx;
; 1041 : 
; 1042 : 
; 1043 :     // Remember self powered flag
; 1044 :     pPdd->selfPowered = (pFullSpeedConfig->Descriptor.bmAttributes & 0x20) != 0;

  00cd0	e59d5034	 ldr         r5, [sp, #0x34]
  00cd4	e596a008	 ldr         r10, [r6, #8]

; 1045 : 
; 1046 :     // Unlock configuration
; 1047 :     CLRREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_CFG_LOCK);
; 1048 : 
; 1049 :     // Configure EP0
; 1050 :     offset = 8;
; 1051 :     cfg  = Log2(pFullSpeedDeviceDesc->bMaxPacketSize0 >> 3) << 12;

  00cd8	e59d4030	 ldr         r4, [sp, #0x30]
  00cdc	e5d5300b	 ldrb        r3, [r5, #0xB]
  00ce0	e3130020	 tst         r3, #0x20
  00ce4	13a03001	 movne       r3, #1
  00ce8	03a03000	 moveq       r3, #0
  00cec	e5863014	 str         r3, [r6, #0x14]
  00cf0	e59a3018	 ldr         r3, [r10, #0x18]
  00cf4	e3c33c01	 bic         r3, r3, #1, 24
  00cf8	e58a3018	 str         r3, [r10, #0x18]
  00cfc	e5d43007	 ldrb        r3, [r4, #7]
  00d00	e1a001a3	 mov         r0, r3, lsr #3
  00d04	eb000000	 bl          Log2
  00d08	e1a03600	 mov         r3, r0, lsl #12

; 1052 :     cfg |= offset >> 3;

  00d0c	e3833001	 orr         r3, r3, #1

; 1053 :     OUTREG32(&pUSBDRegs->EP0, cfg);

  00d10	e58a3080	 str         r3, [r10, #0x80]

; 1054 :     pPdd->ep[0].maxPacketSize = pFullSpeedDeviceDesc->bMaxPacketSize0;

  00d14	e5d43007	 ldrb        r3, [r4, #7]

; 1055 :     offset += pFullSpeedDeviceDesc->bMaxPacketSize0;
; 1056 : 
; 1057 :     // Configure Rx EPs
; 1058 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++) {

  00d18	e3a01000	 mov         r1, #0
  00d1c	e58d1000	 str         r1, [sp]
  00d20	e1c632b4	 strh        r3, [r6, #0x24]
  00d24	e5d43007	 ldrb        r3, [r4, #7]
  00d28	e5d52008	 ldrb        r2, [r5, #8]
  00d2c	e2837008	 add         r7, r3, #8
  00d30	e3520000	 cmp         r2, #0
  00d34	0a000039	 beq         |$LN14@UfnPdd_Reg|
  00d38	e3a0b000	 mov         r11, #0
  00d3c	e58db004	 str         r11, [sp, #4]
  00d40	e3a00001	 mov         r0, #1
  00d44		 |$LL16@UfnPdd_Reg|

; 1059 :         // For each endpoint in interface
; 1060 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00d44	e5953018	 ldr         r3, [r5, #0x18]

; 1061 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++) {

  00d48	e3a06000	 mov         r6, #0
  00d4c	e08b8003	 add         r8, r11, r3
  00d50	e5d83008	 ldrb        r3, [r8, #8]
  00d54	e3530000	 cmp         r3, #0
  00d58	0a000029	 beq         |$LN15@UfnPdd_Reg|
  00d5c	e59db008	 ldr         r11, [sp, #8]
  00d60	e3a05000	 mov         r5, #0
  00d64		 |$LL13@UfnPdd_Reg|

; 1062 :             pEP = &pIFC->pEndpoints[epx];

  00d64	e5983018	 ldr         r3, [r8, #0x18]
  00d68	e0854003	 add         r4, r5, r3

; 1063 :             // If it is Tx EP skip it
; 1064 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) != 0) continue;

  00d6c	e5d42006	 ldrb        r2, [r4, #6]
  00d70	e3120080	 tst         r2, #0x80
  00d74	1a00001a	 bne         |$LN12@UfnPdd_Reg|

; 1065 :             // Get EP address
; 1066 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 1067 :             // Save max packet size & direction
; 1068 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  00d78	e5d41008	 ldrb        r1, [r4, #8]
  00d7c	e5d43009	 ldrb        r3, [r4, #9]
  00d80	e202900f	 and         r9, r2, #0xF
  00d84	e08b2209	 add         r2, r11, r9, lsl #4
  00d88	e1813403	 orr         r3, r1, r3, lsl #8
  00d8c	e1c232b4	 strh        r3, [r2, #0x24]

; 1069 :             pPdd->ep[ep].dirRx = TRUE;

  00d90	e5820028	 str         r0, [r2, #0x28]

; 1070 :             // Create EP config
; 1071 :             cfg  = USBD_EP_VALID;
; 1072 :             cfg |= Log2(pEP->Descriptor.wMaxPacketSize >> 3) << 12;

  00d94	e5d42008	 ldrb        r2, [r4, #8]
  00d98	e5d43009	 ldrb        r3, [r4, #9]
  00d9c	e1823403	 orr         r3, r2, r3, lsl #8
  00da0	e1a001a3	 mov         r0, r3, lsr #3
  00da4	eb000000	 bl          Log2

; 1073 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01) {

  00da8	e5d43007	 ldrb        r3, [r4, #7]
  00dac	e3802008	 orr         r2, r0, #8
  00db0	e1a01602	 mov         r1, r2, lsl #12
  00db4	e2033003	 and         r3, r3, #3
  00db8	e3530001	 cmp         r3, #1

; 1074 :                 cfg |= USBD_EP_ISO;
; 1075 :             }
; 1076 :             cfg |= offset >> 3;
; 1077 :             OUTREG32(&pUSBDRegs->EP_RX[ep - 1], cfg);

  00dbc	e2893020	 add         r3, r9, #0x20
  00dc0	03811b02	 orreq       r1, r1, #2, 22
  00dc4	e08a2103	 add         r2, r10, r3, lsl #2
  00dc8	e18131a7	 orr         r3, r1, r7, lsr #3
  00dcc	e5823000	 str         r3, [r2]

; 1078 :             // Update offset
; 1079 :             offset += pEP->Descriptor.wMaxPacketSize;

  00dd0	e5d42008	 ldrb        r2, [r4, #8]
  00dd4	e5d43009	 ldrb        r3, [r4, #9]
  00dd8	e3a00001	 mov         r0, #1
  00ddc	e1823403	 orr         r3, r2, r3, lsl #8
  00de0	e0877003	 add         r7, r7, r3
  00de4		 |$LN12@UfnPdd_Reg|
  00de4	e5d83008	 ldrb        r3, [r8, #8]
  00de8	e2866001	 add         r6, r6, #1
  00dec	e2855014	 add         r5, r5, #0x14
  00df0	e1560003	 cmp         r6, r3
  00df4	3affffda	 bcc         |$LL13@UfnPdd_Reg|
  00df8	e59db004	 ldr         r11, [sp, #4]
  00dfc	e59d1000	 ldr         r1, [sp]
  00e00	e59d5034	 ldr         r5, [sp, #0x34]
  00e04		 |$LN15@UfnPdd_Reg|
  00e04	e5d53008	 ldrb        r3, [r5, #8]
  00e08	e2811001	 add         r1, r1, #1
  00e0c	e28bb01c	 add         r11, r11, #0x1C
  00e10	e1510003	 cmp         r1, r3
  00e14	e58d1000	 str         r1, [sp]
  00e18	e58db004	 str         r11, [sp, #4]
  00e1c	3affffc8	 bcc         |$LL16@UfnPdd_Reg|
  00e20		 |$LN14@UfnPdd_Reg|

; 1080 :         }
; 1081 :     }
; 1082 : 
; 1083 :     // Configure Tx EPs
; 1084 :     for (ifc = 0; ifc < pFullSpeedConfig->Descriptor.bNumInterfaces; ifc++) {

  00e20	e5d53008	 ldrb        r3, [r5, #8]
  00e24	e3a0b000	 mov         r11, #0
  00e28	e58db004	 str         r11, [sp, #4]
  00e2c	e3530000	 cmp         r3, #0
  00e30	0a000039	 beq         |$LN6@UfnPdd_Reg|
  00e34	e3a02000	 mov         r2, #0
  00e38	e58d2000	 str         r2, [sp]
  00e3c	e3a00000	 mov         r0, #0
  00e40		 |$LL8@UfnPdd_Reg|

; 1085 :         // For each endpoint in interface
; 1086 :         pIFC = &pFullSpeedConfig->pInterfaces[ifc];

  00e40	e5953018	 ldr         r3, [r5, #0x18]

; 1087 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++) {

  00e44	e3a06000	 mov         r6, #0
  00e48	e0828003	 add         r8, r2, r3
  00e4c	e5d83008	 ldrb        r3, [r8, #8]
  00e50	e3530000	 cmp         r3, #0
  00e54	0a000029	 beq         |$LN7@UfnPdd_Reg|
  00e58	e59db008	 ldr         r11, [sp, #8]
  00e5c	e3a05000	 mov         r5, #0
  00e60		 |$LL5@UfnPdd_Reg|

; 1088 :             pEP = &pIFC->pEndpoints[epx];

  00e60	e5983018	 ldr         r3, [r8, #0x18]
  00e64	e0854003	 add         r4, r5, r3

; 1089 :             // If it is Rx EP skip it
; 1090 :             if ((pEP->Descriptor.bEndpointAddress & 0x80) == 0) continue;

  00e68	e5d42006	 ldrb        r2, [r4, #6]
  00e6c	e3120080	 tst         r2, #0x80
  00e70	0a00001a	 beq         |$LN4@UfnPdd_Reg|

; 1091 :             // Get EP address
; 1092 :             ep = pEP->Descriptor.bEndpointAddress & 0x0F;
; 1093 :             // Save max packet size & direction
; 1094 :             pPdd->ep[ep].maxPacketSize = pEP->Descriptor.wMaxPacketSize;

  00e74	e5d41008	 ldrb        r1, [r4, #8]
  00e78	e5d43009	 ldrb        r3, [r4, #9]
  00e7c	e202900f	 and         r9, r2, #0xF
  00e80	e08b2209	 add         r2, r11, r9, lsl #4
  00e84	e1813403	 orr         r3, r1, r3, lsl #8
  00e88	e1c232b4	 strh        r3, [r2, #0x24]

; 1095 :             pPdd->ep[ep].dirRx = FALSE;

  00e8c	e5820028	 str         r0, [r2, #0x28]

; 1096 :             // Create EP config
; 1097 :             cfg  = USBD_EP_VALID;
; 1098 :             cfg |= Log2(pEP->Descriptor.wMaxPacketSize >> 3) << 12;

  00e90	e5d42008	 ldrb        r2, [r4, #8]
  00e94	e5d43009	 ldrb        r3, [r4, #9]
  00e98	e1823403	 orr         r3, r2, r3, lsl #8
  00e9c	e1a001a3	 mov         r0, r3, lsr #3
  00ea0	eb000000	 bl          Log2

; 1099 :             if ((pEP->Descriptor.bmAttributes & 0x03) == 0x01) {

  00ea4	e5d43007	 ldrb        r3, [r4, #7]
  00ea8	e3802008	 orr         r2, r0, #8
  00eac	e1a01602	 mov         r1, r2, lsl #12
  00eb0	e2033003	 and         r3, r3, #3
  00eb4	e3530001	 cmp         r3, #1

; 1100 :                 cfg |= USBD_EP_ISO;
; 1101 :             }
; 1102 :             cfg |= offset >> 3;
; 1103 :             OUTREG32(&pUSBDRegs->EP_TX[ep - 1], cfg);

  00eb8	e2893030	 add         r3, r9, #0x30
  00ebc	03811b02	 orreq       r1, r1, #2, 22
  00ec0	e08a2103	 add         r2, r10, r3, lsl #2
  00ec4	e18131a7	 orr         r3, r1, r7, lsr #3
  00ec8	e5823000	 str         r3, [r2]

; 1104 :             // Update offset
; 1105 :             offset += pEP->Descriptor.wMaxPacketSize;

  00ecc	e5d42008	 ldrb        r2, [r4, #8]
  00ed0	e5d43009	 ldrb        r3, [r4, #9]
  00ed4	e3a00000	 mov         r0, #0
  00ed8	e1823403	 orr         r3, r2, r3, lsl #8
  00edc	e0877003	 add         r7, r7, r3
  00ee0		 |$LN4@UfnPdd_Reg|
  00ee0	e5d83008	 ldrb        r3, [r8, #8]
  00ee4	e2866001	 add         r6, r6, #1
  00ee8	e2855014	 add         r5, r5, #0x14
  00eec	e1560003	 cmp         r6, r3
  00ef0	3affffda	 bcc         |$LL5@UfnPdd_Reg|
  00ef4	e59db004	 ldr         r11, [sp, #4]
  00ef8	e59d2000	 ldr         r2, [sp]
  00efc	e59d5034	 ldr         r5, [sp, #0x34]
  00f00		 |$LN7@UfnPdd_Reg|
  00f00	e5d53008	 ldrb        r3, [r5, #8]
  00f04	e28bb001	 add         r11, r11, #1
  00f08	e282201c	 add         r2, r2, #0x1C
  00f0c	e15b0003	 cmp         r11, r3
  00f10	e58db004	 str         r11, [sp, #4]
  00f14	e58d2000	 str         r2, [sp]
  00f18	3affffc8	 bcc         |$LL8@UfnPdd_Reg|
  00f1c		 |$LN6@UfnPdd_Reg|

; 1106 :         }
; 1107 :     }
; 1108 : 
; 1109 :     // Lock configuration
; 1110 :     SETREG32(&pUSBDRegs->SYSCON1, USBD_SYSCON1_CFG_LOCK);

  00f1c	e59a3018	 ldr         r3, [r10, #0x18]

; 1111 : 
; 1112 :     // Done
; 1113 :     return ERROR_SUCCESS;

  00f20	e3a00000	 mov         r0, #0
  00f24	e3833c01	 orr         r3, r3, #1, 24
  00f28	e58a3018	 str         r3, [r10, #0x18]

; 1114 : }

  00f2c	e28dd00c	 add         sp, sp, #0xC
  00f30	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00f34	e12fff1e	 bx          lr
  00f38		 |$M46044|

			 ENDP  ; |UfnPdd_RegisterDevice|


  000b8			 AREA	 |.pdata|, PDATA
|$T46062| DCD	|$LN12@Log2|
	DCD	0x40000900
; Function compile flags: /Ogtp

  00f38			 AREA	 |.text|, CODE, ARM

  00f38		 |Log2|	 PROC

; 99   : {

  00f38		 |$LN12@Log2|
  00f38		 |$M46059|
  00f38	e1b03000	 movs        r3, r0

; 100  :     DWORD rc = 0;

  00f3c	e3a00000	 mov         r0, #0

; 101  :     while (value != 0) {

  00f40	0a000004	 beq         |$LN1@Log2|
  00f44		 |$LL3@Log2|

; 102  :         value >>= 1;

  00f44	e1b030a3	 movs        r3, r3, lsr #1

; 103  :         rc++;

  00f48	e2800001	 add         r0, r0, #1
  00f4c	1afffffc	 bne         |$LL3@Log2|

; 104  :     }
; 105  :     if (rc > 0) rc--;

  00f50	e3500000	 cmp         r0, #0
  00f54	12400001	 subne       r0, r0, #1
  00f58		 |$LN1@Log2|

; 106  :     return rc;
; 107  : }

  00f58	e12fff1e	 bx          lr
  00f5c		 |$M46060|

			 ENDP  ; |Log2|

	EXPORT	|UfnPdd_IsEndpointSupportable|
	EXPORT	|??_C@_1JI@CDHGGCAD@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@| [ DATA ] ; `string'

  000c0			 AREA	 |.pdata|, PDATA
|$T46077| DCD	|$LN11@UfnPdd_IsE@2|
	DCD	0x40002301

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JI@CDHGGCAD@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "O"
	DCB	0x0, "M", 0x0, "A", 0x0, "P", 0x0, "5", 0x0, "9", 0x0, "1"
	DCB	0x0, "2", 0x0, "_", 0x0, "M", 0x0, "S", 0x0, "_", 0x0, "V"
	DCB	0x0, "1", 0x0, "\\", 0x0, "O", 0x0, "A", 0x0, "L", 0x0, "\\"
	DCB	0x0, "E", 0x0, "T", 0x0, "H", 0x0, "D", 0x0, "R", 0x0, "V"
	DCB	0x0, "\\", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "F", 0x0, "N"
	DCB	0x0, "\\", 0x0, ".", 0x0, "\\", 0x0, "p", 0x0, "d", 0x0, "d"
	DCB	0x0, ".", 0x0, "c", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@| DCB "%"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "D", 0x0, "E", 0x0, "B"
	DCB	0x0, "U", 0x0, "G", 0x0, "C", 0x0, "H", 0x0, "K", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "i", 0x0, "n", 0x0, " ", 0x0, "f", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " "
	DCB	0x0, "a", 0x0, "t", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogtp

  00f5c			 AREA	 |.text|, CODE, ARM

  00f5c		 |UfnPdd_IsEndpointSupportable| PROC

; 1130 : ) {

  00f5c		 |$LN11@UfnPdd_IsE@2|
  00f5c	e92d4010	 stmdb       sp!, {r4, lr}
  00f60		 |$M46074|
  00f60	e1a04003	 mov         r4, r3
  00f64	e3510000	 cmp         r1, #0

; 1131 :     USBFN_PDD *pPdd = pPddContext;
; 1132 : 
; 1133 :     // Update maximal packet size for EP0
; 1134 :     if (endPoint == 0) {

  00f68	1a000018	 bne         |$LN8@UfnPdd_IsE@2|

; 1135 :         DEBUGCHK(pEPDesc->wMaxPacketSize <= 64);

  00f6c	e5d4e004	 ldrb        lr, [r4, #4]
  00f70	e5d42005	 ldrb        r2, [r4, #5]
  00f74	e18e2402	 orr         r2, lr, r2, lsl #8
  00f78	e3520040	 cmp         r2, #0x40
  00f7c	9a000006	 bls         |$LN5@UfnPdd_IsE@2|
  00f80	e59f205c	 ldr         r2, [pc, #0x5C]
  00f84	e59f1054	 ldr         r1, [pc, #0x54]
  00f88	e59f004c	 ldr         r0, [pc, #0x4C]
  00f8c	e3a03b01	 mov         r3, #1, 22
  00f90	e383306f	 orr         r3, r3, #0x6F
  00f94	eb000000	 bl          NKDbgPrintfW
  00f98	e6000010	 __debugbreak_ce
  00f9c		 |$LN5@UfnPdd_IsE@2|

; 1136 :         DEBUGCHK(pEPDesc->bmAttributes == USB_ENDPOINT_TYPE_CONTROL);

  00f9c	e5d4e003	 ldrb        lr, [r4, #3]
  00fa0	e35e0000	 cmp         lr, #0
  00fa4	0a000005	 beq         |$LN7@UfnPdd_IsE@2|
  00fa8	e59f2034	 ldr         r2, [pc, #0x34]
  00fac	e59f102c	 ldr         r1, [pc, #0x2C]
  00fb0	e59f0024	 ldr         r0, [pc, #0x24]
  00fb4	e3a03e47	 mov         r3, #0x47, 28
  00fb8	eb000000	 bl          NKDbgPrintfW
  00fbc	e6000010	 __debugbreak_ce
  00fc0		 |$LN7@UfnPdd_IsE@2|

; 1137 :         pEPDesc->wMaxPacketSize = 64;

  00fc0	e3a03040	 mov         r3, #0x40
  00fc4	e3a02000	 mov         r2, #0
  00fc8	e5c43004	 strb        r3, [r4, #4]
  00fcc	e5c42005	 strb        r2, [r4, #5]
  00fd0		 |$LN8@UfnPdd_IsE@2|

; 1138 : 
; 1139 :     }
; 1140 : 
; 1141 :     // Done
; 1142 :     return ERROR_SUCCESS;

  00fd0	e3a00000	 mov         r0, #0

; 1143 : }

  00fd4	e8bd4010	 ldmia       sp!, {r4, lr}
  00fd8	e12fff1e	 bx          lr
  00fdc		 |$LN12@UfnPdd_IsE@2|
  00fdc		 |$LN13@UfnPdd_IsE@2|
  00fdc	00000000	 DCD         |??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@|
  00fe0		 |$LN14@UfnPdd_IsE@2|
  00fe0	00000000	 DCD         |dpCurSettings|
  00fe4		 |$LN15@UfnPdd_IsE@2|
  00fe4	00000000	 DCD         |??_C@_1JI@CDHGGCAD@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00fe8		 |$M46075|

			 ENDP  ; |UfnPdd_IsEndpointSupportable|

	EXPORT	|UfnPdd_IsConfigurationSupportable|

  000c8			 AREA	 |.pdata|, PDATA
|$T46107| DCD	|$LN22@UfnPdd_IsC|
	DCD	0x40004901
; Function compile flags: /Ogtp

  00fe8			 AREA	 |.text|, CODE, ARM

  00fe8		 |UfnPdd_IsConfigurationSupportable| PROC

; 1159 : ) {

  00fe8		 |$LN22@UfnPdd_IsC|
  00fe8	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00fec		 |$M46104|
  00fec	e1a08002	 mov         r8, r2

; 1160 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1161 :     USBFN_PDD *pPdd = pPddContext;
; 1162 :     UFN_INTERFACE *pIFC;
; 1163 :     UFN_ENDPOINT *pEP;
; 1164 :     WORD ifc, epx, count;
; 1165 :     WORD offset, size;
; 1166 : 
; 1167 : 
; 1168 :     // TODO: Update self power bit & maxPower
; 1169 : 
; 1170 :     // We must start with offset 8 + 64 (config plus EP0 size)
; 1171 :     offset = 8 + 64;
; 1172 :     // Clear number of end points
; 1173 :     count = 0;
; 1174 : 
; 1175 :     // For each interface in configuration
; 1176 :     for (ifc = 0; ifc < pConfig->Descriptor.bNumInterfaces; ifc++) {

  00ff0	e5d83008	 ldrb        r3, [r8, #8]
  00ff4	e3a07048	 mov         r7, #0x48
  00ff8	e3a09000	 mov         r9, #0
  00ffc	e3530000	 cmp         r3, #0
  01000	e3a0e000	 mov         lr, #0
  01004	0a000036	 beq         |$LN9@UfnPdd_IsC|
  01008	e3a0a000	 mov         r10, #0
  0100c	e3a0201c	 mov         r2, #0x1C
  01010	e3a0b001	 mov         r11, #1
  01014		 |$LL11@UfnPdd_IsC|

; 1177 :         // For each endpoint in interface
; 1178 :         pIFC = &pConfig->pInterfaces[ifc];

  01014	e5983018	 ldr         r3, [r8, #0x18]

; 1179 :         for (epx = 0; epx < pIFC->Descriptor.bNumEndpoints; epx++) {

  01018	e3a00000	 mov         r0, #0
  0101c	e025329e	 mla         r5, lr, r2, r3
  01020	e5d53008	 ldrb        r3, [r5, #8]
  01024	e3530000	 cmp         r3, #0
  01028	0a000021	 beq         |$LN6@UfnPdd_IsC|
  0102c	e3a06000	 mov         r6, #0
  01030		 |$LL8@UfnPdd_IsC|

; 1180 :             pEP = &pIFC->pEndpoints[epx];

  01030	e5952018	 ldr         r2, [r5, #0x18]
  01034	e0803100	 add         r3, r0, r0, lsl #2
  01038	e0824103	 add         r4, r2, r3, lsl #2

; 1181 :             // We support maximal sizes 8, 16, 32 and 64 bytes for non-ISO
; 1182 :             size = pEP->Descriptor.wMaxPacketSize;

  0103c	e5d42008	 ldrb        r2, [r4, #8]
  01040	e5d43009	 ldrb        r3, [r4, #9]
  01044	e1820403	 orr         r0, r2, r3, lsl #8

; 1183 :             // First round size to supported sizes
; 1184 :             size = 1 << Log2(size);

  01048	eb000000	 bl          Log2

; 1185 :             // Is it ISO end point?
; 1186 :             if ((pEP->Descriptor.bmAttributes & 0x03) != 0x01) {

  0104c	e5d42007	 ldrb        r2, [r4, #7]
  01050	e1a0301b	 mov         r3, r11, lsl r0
  01054	e2022003	 and         r2, r2, #3
  01058	e1a00803	 mov         r0, r3, lsl #16
  0105c	e1a00820	 mov         r0, r0, lsr #16
  01060	e3520001	 cmp         r2, #1
  01064	0a000003	 beq         |$LN5@UfnPdd_IsC|

; 1187 :                 // Non-ISO, max size is 64 bytes
; 1188 :                 if (size > 64) size = 64;

  01068	e3500040	 cmp         r0, #0x40
  0106c	9a000003	 bls         |$LN2@UfnPdd_IsC|
  01070	e3a00040	 mov         r0, #0x40

; 1189 :             } else {

  01074	ea000001	 b           |$LN2@UfnPdd_IsC|
  01078		 |$LN5@UfnPdd_IsC|

; 1190 :                 // ISO edpoint, maximal size is 512 bytes
; 1191 :                 if (size > 512) size = 512;

  01078	e3500c02	 cmp         r0, #2, 24
  0107c	83a00c02	 movhi       r0, #2, 24
  01080		 |$LN2@UfnPdd_IsC|

; 1192 :             }
; 1193 :             // Update EP size
; 1194 :             pEP->Descriptor.wMaxPacketSize = size;

  01080	e1a03420	 mov         r3, r0, lsr #8
  01084	e5c43009	 strb        r3, [r4, #9]
  01088	e2863001	 add         r3, r6, #1
  0108c	e5c40008	 strb        r0, [r4, #8]
  01090	e5d51008	 ldrb        r1, [r5, #8]

; 1195 :             // Calculate total buffer size
; 1196 :             offset += size;

  01094	e0802007	 add         r2, r0, r7
  01098	e1a00803	 mov         r0, r3, lsl #16
  0109c	e1a00820	 mov         r0, r0, lsr #16
  010a0	e1a07802	 mov         r7, r2, lsl #16
  010a4	e1500001	 cmp         r0, r1
  010a8	e1a06000	 mov         r6, r0
  010ac	e1a07827	 mov         r7, r7, lsr #16
  010b0	3affffde	 bcc         |$LL8@UfnPdd_IsC|
  010b4		 |$LN6@UfnPdd_IsC|

; 1197 :         }
; 1198 :         // Add number of end points to total count
; 1199 :         count += pIFC->Descriptor.bNumEndpoints;

  010b4	e5d52008	 ldrb        r2, [r5, #8]
  010b8	e5d81008	 ldrb        r1, [r8, #8]
  010bc	e28a3001	 add         r3, r10, #1
  010c0	e0822009	 add         r2, r2, r9
  010c4	e1a0e803	 mov         lr, r3, lsl #16
  010c8	e1a09802	 mov         r9, r2, lsl #16
  010cc	e1a0e82e	 mov         lr, lr, lsr #16
  010d0	e1a09829	 mov         r9, r9, lsr #16
  010d4	e1a0a00e	 mov         r10, lr
  010d8	e15e0001	 cmp         lr, r1
  010dc	e3a0201c	 mov         r2, #0x1C
  010e0	3affffcb	 bcc         |$LL11@UfnPdd_IsC|
  010e4		 |$LN9@UfnPdd_IsC|

; 1200 :     }
; 1201 : 
; 1202 :     // Can we support this configuration?
; 1203 :     if (count < USBD_EP_COUNT && offset <= 2048) rc = ERROR_SUCCESS;

  010e4	e3590010	 cmp         r9, #0x10
  010e8	2a000004	 bcs         |$LN18@UfnPdd_IsC|
  010ec	e3570b02	 cmp         r7, #2, 22
  010f0	8a000002	 bhi         |$LN18@UfnPdd_IsC|
  010f4	e3a00000	 mov         r0, #0

; 1204 : 
; 1205 :     // Done
; 1206 :     return rc;
; 1207 : }

  010f8	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  010fc	e12fff1e	 bx          lr
  01100		 |$LN18@UfnPdd_IsC|
  01100	e3a00057	 mov         r0, #0x57
  01104	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  01108	e12fff1e	 bx          lr
  0110c		 |$M46105|

			 ENDP  ; |UfnPdd_IsConfigurationSupportable|

	EXPORT	|UfnPdd_Init|
	EXPORT	|??_C@_1HE@JFIJHLAK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr@| [ DATA ] ; `string'
	IMPORT	|OALPAtoVA|
	IMPORT	|memset|

  000d0			 AREA	 |.pdata|, PDATA
|$T46127| DCD	|$LN15@UfnPdd_Ini@3|
	DCD	0x40007402

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@JFIJHLAK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "U", 0x0, "f", 0x0, "n", 0x0, "P", 0x0, "d", 0x0, "d"
	DCB	0x0, "_", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, ":"
	DCB	0x0, " ", 0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r"
	DCB	0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, " ", 0x0, "m", 0x0, "a"
	DCB	0x0, "p", 0x0, "p", 0x0, "i", 0x0, "n", 0x0, "g", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogtp

  0110c			 AREA	 |.text|, CODE, ARM

  0110c		 |UfnPdd_Init| PROC

; 1220 : ) {

  0110c		 |$LN15@UfnPdd_Ini@3|
  0110c	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  01110	e24dd00c	 sub         sp, sp, #0xC
  01114		 |$M46124|
  01114	e58d3000	 str         r3, [sp]
  01118	e58d2008	 str         r2, [sp, #8]
  0111c	e58d1004	 str         r1, [sp, #4]

; 1221 :     DWORD rc = ERROR_INVALID_PARAMETER;
; 1222 :     USBFN_PDD *pPdd;
; 1223 :     OMAP5912_USBD_REGS *pUSBDRegs;
; 1224 :     DWORD ep;
; 1225 : 
; 1226 :     // Allocate and initialize the OHCD object.
; 1227 :     pPdd = &g_usbfnpdd;
; 1228 :     if (pPdd == NULL) goto clean;
; 1229 : 
; 1230 :     // Clear the allocated object.
; 1231 :     memset(pPdd, 0, sizeof(USBFN_PDD));

  01120	e59f4158	 ldr         r4, [pc, #0x158]
  01124	e3a02f4a	 mov         r2, #0x4A, 30
  01128	e3a01000	 mov         r1, #0
  0112c	e1a00004	 mov         r0, r4
  01130	eb000000	 bl          memset

; 1232 : 
; 1233 :     // Map the USB OHCI registers
; 1234 :     pUSBDRegs = (OMAP5912_USBD_REGS*)OALPAtoUA( OMAP5912_USBD_REGS_PA );

  01134	e3a01000	 mov         r1, #0
  01138	e2410913	 sub         r0, r1, #0x13, 18
  0113c	eb000000	 bl          OALPAtoVA
  01140	e3500000	 cmp         r0, #0

; 1235 : 
; 1236 :     if (pUSBDRegs == NULL) {

  01144	1a000008	 bne         |$LN4@UfnPdd_Ini@3|

; 1237 :         OALMSG(OAL_ERROR, (
; 1238 :             L"ERROR: UfnPdd_Init: Controller registers mapping failed\r\n"
; 1239 :         ));

  01148	e59f3188	 ldr         r3, [pc, #0x188]
  0114c	e5933440	 ldr         r3, [r3, #0x440]
  01150	e3130001	 tst         r3, #1
  01154	159f0178	 ldrne       r0, [pc, #0x178]
  01158	1b000000	 blne        NKDbgPrintfW

; 1290 : 
; 1291 : clean:
; 1292 :     return rc;
; 1293 : }

  0115c	e3a00057	 mov         r0, #0x57
  01160	e28dd00c	 add         sp, sp, #0xC
  01164	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  01168	e12fff1e	 bx          lr
  0116c		 |$LN4@UfnPdd_Ini@3|

; 1240 :         goto clean;
; 1241 :     }
; 1242 :     pPdd->pUSBDRegs = pUSBDRegs;
; 1243 : 
; 1244 :     // Clear USB Interrupt enable registers
; 1245 :     OUTREG32(&pUSBDRegs->IRQ_EN, 0);

  0116c	e3a01000	 mov         r1, #0
  01170	e5840008	 str         r0, [r4, #8]
  01174	e5801028	 str         r1, [r0, #0x28]

; 1246 :     OUTREG32(&pUSBDRegs->DMA_IRQ_EN, 0);
; 1247 : 
; 1248 :     // Reset all interrupts
; 1249 :     OUTREG32(&pUSBDRegs->IRQ_SRC, 0xFFFFFFFF);

  01178	e3e03000	 mvn         r3, #0
  0117c	e580102c	 str         r1, [r0, #0x2C]
  01180	e5803030	 str         r3, [r0, #0x30]

; 1250 : 
; 1251 :     // Disable all RX, TX EPs
; 1252 :     OUTREG32(&pUSBDRegs->EP0, 0);

  01184	e5801080	 str         r1, [r0, #0x80]
  01188	e2803088	 add         r3, r0, #0x88
  0118c	e3a0200f	 mov         r2, #0xF
  01190		 |$LL3@UfnPdd_Ini@3|

; 1253 :     for (ep = 1; ep < USBD_EP_COUNT; ep++) {
; 1254 :         OUTREG32(&pUSBDRegs->EP_RX[ep], 0);

  01190	e5831000	 str         r1, [r3]

; 1255 :         OUTREG32(&pUSBDRegs->EP_TX[ep], 0);

  01194	e5831040	 str         r1, [r3, #0x40]
  01198	e2833004	 add         r3, r3, #4
  0119c	e2522001	 subs        r2, r2, #1
  011a0	1afffffa	 bne         |$LL3@UfnPdd_Ini@3|

; 1256 :     }
; 1257 : 
; 1258 :     // Set PDD interface
; 1259 :     pPddIfc->dwVersion = UFN_PDD_INTERFACE_VERSION;
; 1260 :     pPddIfc->dwCapabilities = UFN_PDD_CAPS_SUPPORTS_FULL_SPEED;
; 1261 :     pPddIfc->dwEndpointCount = USBD_EP_COUNT;
; 1262 :     pPddIfc->pvPddContext = pPdd;
; 1263 :     pPddIfc->pfnDeinit = UfnPdd_Deinit;
; 1264 :     pPddIfc->pfnIsConfigurationSupportable = UfnPdd_IsConfigurationSupportable;
; 1265 :     pPddIfc->pfnIsEndpointSupportable = UfnPdd_IsEndpointSupportable;
; 1266 :     pPddIfc->pfnInitEndpoint = UfnPdd_InitEndpoint;
; 1267 :     pPddIfc->pfnRegisterDevice = UfnPdd_RegisterDevice;
; 1268 :     pPddIfc->pfnDeregisterDevice = UfnPdd_DeregisterDevice;
; 1269 :     pPddIfc->pfnStart = UfnPdd_Start;
; 1270 :     pPddIfc->pfnStop = UfnPdd_Stop;
; 1271 :     pPddIfc->pfnIssueTransfer = UfnPdd_IssueTransfer;
; 1272 :     pPddIfc->pfnAbortTransfer = UfnPdd_AbortTransfer;
; 1273 :     pPddIfc->pfnDeinitEndpoint = UfnPdd_DeinitEndpoint;
; 1274 :     pPddIfc->pfnStallEndpoint = UfnPdd_StallEndpoint;
; 1275 :     pPddIfc->pfnClearEndpointStall = UfnPdd_ClearEndpointStall;
; 1276 :     pPddIfc->pfnSendControlStatusHandshake = UfnPdd_SendControlStatusHandshake;
; 1277 :     pPddIfc->pfnSetAddress = UfnPdd_SetAddress;
; 1278 :     pPddIfc->pfnIsEndpointHalted = UfnPdd_IsEndpointHalted;
; 1279 :     pPddIfc->pfnInitiateRemoteWakeup = UfnPdd_InitiateRemoteWakeup;
; 1280 :     pPddIfc->pfnPowerDown = UfnPdd_PowerDown;
; 1281 :     pPddIfc->pfnPowerUp = UfnPdd_PowerUp;
; 1282 :     pPddIfc->pfnIOControl = UfnPdd_IOControl;

  011a4	e59f3124	 ldr         r3, [pc, #0x124]
  011a8	e59d2000	 ldr         r2, [sp]
  011ac	e59f1118	 ldr         r1, [pc, #0x118]
  011b0	e59f0110	 ldr         r0, [pc, #0x110]
  011b4	e5823010	 str         r3, [r2, #0x10]
  011b8	e59f2104	 ldr         r2, [pc, #0x104]
  011bc	e59d3000	 ldr         r3, [sp]
  011c0	e59fe0f8	 ldr         lr, [pc, #0xF8]
  011c4	e59f40f0	 ldr         r4, [pc, #0xF0]
  011c8	e5832014	 str         r2, [r3, #0x14]
  011cc	e1a02003	 mov         r2, r3
  011d0	e59f30e0	 ldr         r3, [pc, #0xE0]
  011d4	e59f50d8	 ldr         r5, [pc, #0xD8]
  011d8	e59f60d0	 ldr         r6, [pc, #0xD0]
  011dc	e5823044	 str         r3, [r2, #0x44]
  011e0	e59f30c4	 ldr         r3, [pc, #0xC4]
  011e4	e59f70bc	 ldr         r7, [pc, #0xBC]
  011e8	e59f80b4	 ldr         r8, [pc, #0xB4]
  011ec	e5823048	 str         r3, [r2, #0x48]
  011f0	e59f30a8	 ldr         r3, [pc, #0xA8]
  011f4	e59f90a0	 ldr         r9, [pc, #0xA0]
  011f8	e59fa098	 ldr         r10, [pc, #0x98]
  011fc	e582304c	 str         r3, [r2, #0x4C]
  01200	e59f308c	 ldr         r3, [pc, #0x8C]
  01204	e59fb084	 ldr         r11, [pc, #0x84]
  01208	e5821018	 str         r1, [r2, #0x18]
  0120c	e5823050	 str         r3, [r2, #0x50]
  01210	e59f3074	 ldr         r3, [pc, #0x74]
  01214	e282c01c	 add         r12, r2, #0x1C
  01218	e88c4001	 stmia       r12, {r0, lr}

; 1283 : 
; 1284 :     // Save MDD context & notify function
; 1285 :     pPdd->pMddContext = pMddContext;
; 1286 :     pPdd->pfnNotify = pMddIfc->pfnNotify;
; 1287 : 
; 1288 :     // Done
; 1289 :     rc = ERROR_SUCCESS;

  0121c	e3a00000	 mov         r0, #0
  01220	e5823054	 str         r3, [r2, #0x54]
  01224	e59f305c	 ldr         r3, [pc, #0x5C]
  01228	e282c024	 add         r12, r2, #0x24
  0122c	e88c0ff0	 stmia       r12, {r4 - r11}
  01230	e5823058	 str         r3, [r2, #0x58]
  01234	e59f3048	 ldr         r3, [pc, #0x48]
  01238	e582305c	 str         r3, [r2, #0x5C]
  0123c	e3a03806	 mov         r3, #6, 16
  01240	e5823000	 str         r3, [r2]
  01244	e3a03001	 mov         r3, #1
  01248	e5823004	 str         r3, [r2, #4]
  0124c	e3a03010	 mov         r3, #0x10
  01250	e5823008	 str         r3, [r2, #8]
  01254	e59f2024	 ldr         r2, [pc, #0x24]
  01258	e59d3000	 ldr         r3, [sp]
  0125c	e583200c	 str         r2, [r3, #0xC]
  01260	e59d3004	 ldr         r3, [sp, #4]
  01264	e5823000	 str         r3, [r2]
  01268	e59d3008	 ldr         r3, [sp, #8]
  0126c	e5933004	 ldr         r3, [r3, #4]
  01270	e5823004	 str         r3, [r2, #4]
  01274		 |$clean$45594|

; 1290 : 
; 1291 : clean:
; 1292 :     return rc;
; 1293 : }

  01274	e28dd00c	 add         sp, sp, #0xC
  01278	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0127c	e12fff1e	 bx          lr
  01280		 |$LN16@UfnPdd_Ini@3|
  01280		 |$LN17@UfnPdd_Ini@3|
  01280	00000000	 DCD         |g_usbfnpdd|
  01284		 |$LN18@UfnPdd_Ini@3|
  01284	00000000	 DCD         |UfnPdd_IOControl|
  01288		 |$LN19@UfnPdd_Ini@3|
  01288	00000000	 DCD         |UfnPdd_PowerUp|
  0128c		 |$LN20@UfnPdd_Ini@3|
  0128c	00000000	 DCD         |UfnPdd_PowerDown|
  01290		 |$LN21@UfnPdd_Ini@3|
  01290	00000000	 DCD         |UfnPdd_ClearEndpointStall|
  01294		 |$LN22@UfnPdd_Ini@3|
  01294	00000000	 DCD         |UfnPdd_InitiateRemoteWakeup|
  01298		 |$LN23@UfnPdd_Ini@3|
  01298	00000000	 DCD         |UfnPdd_StallEndpoint|
  0129c		 |$LN24@UfnPdd_Ini@3|
  0129c	00000000	 DCD         |UfnPdd_DeinitEndpoint|
  012a0		 |$LN25@UfnPdd_Ini@3|
  012a0	00000000	 DCD         |UfnPdd_IsEndpointHalted|
  012a4		 |$LN26@UfnPdd_Ini@3|
  012a4	00000000	 DCD         |UfnPdd_AbortTransfer|
  012a8		 |$LN27@UfnPdd_Ini@3|
  012a8	00000000	 DCD         |UfnPdd_IssueTransfer|
  012ac		 |$LN28@UfnPdd_Ini@3|
  012ac	00000000	 DCD         |UfnPdd_SetAddress|
  012b0		 |$LN29@UfnPdd_Ini@3|
  012b0	00000000	 DCD         |UfnPdd_Stop|
  012b4		 |$LN30@UfnPdd_Ini@3|
  012b4	00000000	 DCD         |UfnPdd_Start|
  012b8		 |$LN31@UfnPdd_Ini@3|
  012b8	00000000	 DCD         |UfnPdd_SendControlStatusHandshake|
  012bc		 |$LN32@UfnPdd_Ini@3|
  012bc	00000000	 DCD         |UfnPdd_DeregisterDevice|
  012c0		 |$LN33@UfnPdd_Ini@3|
  012c0	00000000	 DCD         |UfnPdd_RegisterDevice|
  012c4		 |$LN34@UfnPdd_Ini@3|
  012c4	00000000	 DCD         |UfnPdd_IsConfigurationSupportable|
  012c8		 |$LN35@UfnPdd_Ini@3|
  012c8	00000000	 DCD         |UfnPdd_InitEndpoint|
  012cc		 |$LN36@UfnPdd_Ini@3|
  012cc	00000000	 DCD         |UfnPdd_IsEndpointSupportable|
  012d0		 |$LN37@UfnPdd_Ini@3|
  012d0	00000000	 DCD         |UfnPdd_Deinit|
  012d4		 |$LN38@UfnPdd_Ini@3|
  012d4	00000000	 DCD         |??_C@_1HE@JFIJHLAK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAU?$AAf?$AAn?$AAP?$AAd?$AAd?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?5?$AAr@|
  012d8		 |$LN39@UfnPdd_Ini@3|
  012d8	00000000	 DCD         |dpCurSettings|
  012dc		 |$M46125|

			 ENDP  ; |UfnPdd_Init|

	EXPORT	|UfnPdd_DllEntry|

  000d8			 AREA	 |.pdata|, PDATA
|$T46158| DCD	|$LN5@UfnPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogtp

  012dc			 AREA	 |.text|, CODE, ARM

  012dc		 |UfnPdd_DllEntry| PROC

; 1299 : ) {

  012dc		 |$LN5@UfnPdd_Dll|
  012dc		 |$M46155|

; 1300 :     return TRUE;

  012dc	e3a00001	 mov         r0, #1

; 1301 : }

  012e0	e12fff1e	 bx          lr
  012e4		 |$M46156|

			 ENDP  ; |UfnPdd_DllEntry|

	END
