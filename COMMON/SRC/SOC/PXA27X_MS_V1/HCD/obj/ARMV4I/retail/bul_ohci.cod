; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\HCD\bul_ohci.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?ThreadStart@CMiniThread@@QAAHXZ|	; CMiniThread::ThreadStart
	IMPORT	|ResumeThread|
; File c:\wince600\public\common\oak\inc\cmthread.h

  00000			 AREA	 |.pdata|, PDATA
|$T38667| DCD	|$LN7@ThreadStar|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadStart@CMiniThread@@QAAHXZ| PROC ; CMiniThread::ThreadStart

; 49   :     {

  00000		 |$LN7@ThreadStar|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38664|
  00004	e1a04000	 mov         r4, r0

; 50   :         if( m_bSuspendFlag )

  00008	e5943010	 ldr         r3, [r4, #0x10]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000007	 beq         |$LN2@ThreadStar|

; 51   :         {
; 52   :             if( ResumeThread( m_hThreadHandle ) == ( DWORD ) ( -1 ) )

  00014	e5940008	 ldr         r0, [r4, #8]
  00018	eb000000	 bl          ResumeThread
  0001c	e3700001	 cmn         r0, #1

; 53   :             {
; 54   :                 // failure for resume somehow
; 55   :                 return FALSE;

  00020	03a00000	 moveq       r0, #0

; 60   :     }

  00024	08bd4010	 ldmeqia     sp!, {r4, lr}
  00028	012fff1e	 bxeq        lr

; 56   :             };
; 57   :             m_bSuspendFlag = FALSE;

  0002c	e3a03000	 mov         r3, #0
  00030	e5843010	 str         r3, [r4, #0x10]
  00034		 |$LN2@ThreadStar|

; 58   :         }
; 59   :         return TRUE;

  00034	e3a00001	 mov         r0, #1

; 60   :     }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M38665|

			 ENDP  ; |?ThreadStart@CMiniThread@@QAAHXZ|, CMiniThread::ThreadStart

	EXPORT	|?WaitThreadComplete@CMiniThread@@QAAHK@Z| ; CMiniThread::WaitThreadComplete
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T38678| DCD	|$LN8@WaitThread|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitThreadComplete@CMiniThread@@QAAHK@Z| PROC ; CMiniThread::WaitThreadComplete

; 92   :     {

  00000		 |$LN8@WaitThread|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M38675|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 93   :         if( !m_hThreadHandle )

  0000c	e5943008	 ldr         r3, [r4, #8]
  00010	e3530000	 cmp         r3, #0

; 94   :         {
; 95   :             return FALSE;

  00014	0a00000e	 beq         |$LN1@WaitThread|

; 96   :         };
; 97   : 
; 98   :         if( ThreadStart() )

  00018	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|
  0001c	e3500000	 cmp         r0, #0
  00020	0a00000b	 beq         |$LN1@WaitThread|

; 99   :         {
; 100  :             if( ::WaitForSingleObject( m_hThreadHandle, dwMilliSeconds ) ==
; 101  :                 WAIT_OBJECT_0 )

  00024	e5940008	 ldr         r0, [r4, #8]
  00028	e1a01005	 mov         r1, r5
  0002c	eb000000	 bl          WaitForSingleObject
  00030	e3500000	 cmp         r0, #0
  00034	1a000006	 bne         |$LN1@WaitThread|

; 102  :             {
; 103  :                 // thread dead
; 104  :                 ::CloseHandle( m_hThreadHandle );

  00038	e5940008	 ldr         r0, [r4, #8]
  0003c	eb000000	 bl          CloseHandle

; 105  :                 m_hThreadHandle = NULL;

  00040	e3a03000	 mov         r3, #0
  00044	e5843008	 str         r3, [r4, #8]

; 106  :                 return TRUE;

  00048	e3a00001	 mov         r0, #1

; 110  :     }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN1@WaitThread|

; 107  :             }
; 108  :         }
; 109  :         return FALSE;

  00054	e3a00000	 mov         r0, #0

; 110  :     }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M38676|

			 ENDP  ; |?WaitThreadComplete@CMiniThread@@QAAHK@Z|, CMiniThread::WaitThreadComplete

	EXPORT	|?ForceTerminated@CMiniThread@@QAAHXZ|	; CMiniThread::ForceTerminated
	IMPORT	|TerminateThread|

  00000			 AREA	 |.pdata|, PDATA
|$T38689| DCD	|$LN6@ForceTermi|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ForceTerminated@CMiniThread@@QAAHXZ| PROC ; CMiniThread::ForceTerminated

; 113  :     {

  00000		 |$LN6@ForceTermi|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M38686|
  00004	e1a05000	 mov         r5, r0

; 114  :         if( m_hThreadHandle )

  00008	e5953008	 ldr         r3, [r5, #8]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000a	 beq         |$LN1@ForceTermi|

; 115  :         {
; 116  : //#pragma prefast(suppress: 258, "Try to recover from a pathological failure")
; 117  :             BOOL bReturn = ::TerminateThread( m_hThreadHandle, ( DWORD ) - 1 ); // terminate abnormal

  00014	e3e06000	 mvn         r6, #0
  00018	e1a01006	 mov         r1, r6
  0001c	e1a00003	 mov         r0, r3
  00020	eb000000	 bl          TerminateThread
  00024	e1a04000	 mov         r4, r0

; 118  :             m_dwExitCode = -1;
; 119  :             ::CloseHandle( m_hThreadHandle );

  00028	e5950008	 ldr         r0, [r5, #8]
  0002c	e5856014	 str         r6, [r5, #0x14]
  00030	eb000000	 bl          CloseHandle

; 120  :             m_hThreadHandle = NULL;

  00034	e3a03000	 mov         r3, #0
  00038	e5853008	 str         r3, [r5, #8]

; 121  :             return bReturn;

  0003c	ea000000	 b           |$LN2@ForceTermi|
  00040		 |$LN1@ForceTermi|

; 122  :         };
; 123  :         return TRUE;

  00040	e3a04001	 mov         r4, #1
  00044		 |$LN2@ForceTermi|

; 124  :     }

  00044	e1a00004	 mov         r0, r4
  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M38687|

			 ENDP  ; |?ForceTerminated@CMiniThread@@QAAHXZ|, CMiniThread::ForceTerminated

	EXPORT	|?ThreadProc@CMiniThread@@CAKPAX@Z|	; CMiniThread::ThreadProc
	IMPORT	|ExitThread|

  00000			 AREA	 |.pdata|, PDATA
|$T38699| DCD	|$LN5@ThreadProc|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadProc@CMiniThread@@CAKPAX@Z| PROC ; CMiniThread::ThreadProc

; 154  :     {

  00000		 |$LN5@ThreadProc|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38696|
  00004	e1a04000	 mov         r4, r0

; 155  :         CMiniThread* pThreadPtr = ( CMiniThread* ) dParam;
; 156  :         pThreadPtr->m_dwExitCode = pThreadPtr->ThreadRun();

  00008	e5943000	 ldr         r3, [r4]
  0000c	e5933000	 ldr         r3, [r3]
  00010	e1a0e00f	 mov         lr, pc
  00014	e12fff13	 bx          r3
  00018	e1a03000	 mov         r3, r0

; 157  :         ::ExitThread( pThreadPtr->m_dwExitCode );

  0001c	e5843014	 str         r3, [r4, #0x14]
  00020	eb000000	 bl          ExitThread

; 158  :         return pThreadPtr->m_dwExitCode;

  00024	e5940014	 ldr         r0, [r4, #0x14]

; 159  :     };

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M38697|

			 ENDP  ; |?ThreadProc@CMiniThread@@CAKPAX@Z|, CMiniThread::ThreadProc

	EXPORT	|??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z| ; CRegistryEdit::CRegistryEdit
	IMPORT	|RegOpenKeyExW|
; File c:\wince600\public\common\oak\inc\cregedit.h

  00000			 AREA	 |.pdata|, PDATA
|$T38711| DCD	|$LN7@CRegistryE|
	DCD	0x40001402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z| PROC ; CRegistryEdit::CRegistryEdit

; 45   :     CRegistryEdit( HKEY hKey, LPCTSTR pszRegPath )

  00000		 |$LN7@CRegistryE|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M38708|
  00008	e1b0e002	 movs        lr, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a04000	 mov         r4, r0

; 46   :     {
; 47   :         m_hDevKey = NULL;

  00014	e3a06000	 mov         r6, #0
  00018	e5846000	 str         r6, [r4]

; 48   :         if( pszRegPath )

  0001c	0a000007	 beq         |$LN1@CRegistryE|

; 49   :         {
; 50   :             if( RegOpenKeyEx( hKey, pszRegPath, 0, 0, &m_hDevKey ) != ERROR_SUCCESS )

  00020	e3a03000	 mov         r3, #0
  00024	e3a02000	 mov         r2, #0
  00028	e1a0100e	 mov         r1, lr
  0002c	e1a00005	 mov         r0, r5
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          RegOpenKeyExW
  00038	e3500000	 cmp         r0, #0

; 51   :             {
; 52   :                 m_hDevKey = NULL;

  0003c	15846000	 strne       r6, [r4]
  00040		 |$LN1@CRegistryE|

; 53   :             }
; 54   :         }
; 55   :     }

  00040	e1a00004	 mov         r0, r4
  00044	e28dd004	 add         sp, sp, #4
  00048	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M38709|

			 ENDP  ; |??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z|, CRegistryEdit::CRegistryEdit

	EXPORT	|??1CRegistryEdit@@QAA@XZ|		; CRegistryEdit::~CRegistryEdit
	IMPORT	|RegCloseKey|

  00000			 AREA	 |.pdata|, PDATA
|$T38719| DCD	|$LN6@CRegistryE@2|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CRegistryEdit@@QAA@XZ| PROC	; CRegistryEdit::~CRegistryEdit

; 80   :     {

  00000		 |$LN6@CRegistryE@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38716|

; 81   :         if( m_hDevKey )

  00004	e5903000	 ldr         r3, [r0]
  00008	e3530000	 cmp         r3, #0

; 82   :         {
; 83   :             RegCloseKey( m_hDevKey );

  0000c	11a00003	 movne       r0, r3
  00010	1b000000	 blne        RegCloseKey

; 84   :         }
; 85   :     }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M38717|

			 ENDP  ; |??1CRegistryEdit@@QAA@XZ|, CRegistryEdit::~CRegistryEdit

	EXPORT	|?GetIsrInfo@CRegistryEdit@@QAAKPAU_DDKISRINFO_tag@@@Z| ; CRegistryEdit::GetIsrInfo
	IMPORT	|DDKReg_GetIsrInfo|

  00000			 AREA	 |.pdata|, PDATA
|$T38730| DCD	|$LN7@GetIsrInfo|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetIsrInfo@CRegistryEdit@@QAAKPAU_DDKISRINFO_tag@@@Z| PROC ; CRegistryEdit::GetIsrInfo

; 102  :     {

  00000		 |$LN7@GetIsrInfo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38727|
  00004	e3510000	 cmp         r1, #0

; 103  :         if( pddi && m_hDevKey )

  00008	0a000008	 beq         |$LN2@GetIsrInfo|
  0000c	e5903000	 ldr         r3, [r0]
  00010	e3530000	 cmp         r3, #0
  00014	0a000005	 beq         |$LN2@GetIsrInfo|

; 104  :         {
; 105  :             pddi->cbSize = sizeof( DDKISRINFO );

  00018	e3a03f43	 mov         r3, #0x43, 30
  0001c	e5813000	 str         r3, [r1]

; 106  :             DWORD status = DDKReg_GetIsrInfo( m_hDevKey, pddi );

  00020	e5900000	 ldr         r0, [r0]
  00024	eb000000	 bl          DDKReg_GetIsrInfo

; 112  :         }
; 113  :     }

  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$LN2@GetIsrInfo|

; 107  :             return status;
; 108  :         }
; 109  :         else
; 110  :         {
; 111  :             return ERROR_INVALID_FUNCTION;

  00030	e3a00001	 mov         r0, #1

; 112  :         }
; 113  :     }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M38728|

			 ENDP  ; |?GetIsrInfo@CRegistryEdit@@QAAKPAU_DDKISRINFO_tag@@@Z|, CRegistryEdit::GetIsrInfo

	EXPORT	|?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z| ; CRegistryEdit::GetRegValue
	IMPORT	|RegQueryValueExW|

  00000			 AREA	 |.pdata|, PDATA
|$T38744| DCD	|$LN7@GetRegValu|
	DCD	0x40001404
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z| PROC ; CRegistryEdit::GetRegValue

; 130  :     {

  00000		 |$LN7@GetRegValu|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5030	 stmdb       sp!, {r4, r5, r12, lr}
  0000c	e24dd00c	 sub         sp, sp, #0xC
  00010		 |$M38741|
  00010	e1a04002	 mov         r4, r2

; 131  :         DWORD dwType = 0;
; 132  :         LONG status = ::RegQueryValueEx( m_hDevKey,
; 133  :                                            lpcName,
; 134  :                                            NULL,
; 135  :                                            &dwType,
; 136  :                                            lpData,
; 137  :                                            &dwDataLen );

  00014	e5900000	 ldr         r0, [r0]
  00018	e3a05000	 mov         r5, #0
  0001c	e28de028	 add         lr, sp, #0x28
  00020	e28d3008	 add         r3, sp, #8
  00024	e3a02000	 mov         r2, #0
  00028	e58d5008	 str         r5, [sp, #8]
  0002c	e58de004	 str         lr, [sp, #4]
  00030	e58d4000	 str         r4, [sp]
  00034	eb000000	 bl          RegQueryValueExW
  00038	e3500000	 cmp         r0, #0

; 138  :         return ( status == ERROR_SUCCESS );

  0003c	03a00001	 moveq       r0, #1
  00040	13a00000	 movne       r0, #0

; 139  :     }

  00044	e28dd00c	 add         sp, sp, #0xC
  00048	e89d6030	 ldmia       sp, {r4, r5, sp, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M38742|

			 ENDP  ; |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z|, CRegistryEdit::GetRegValue

	EXPORT	|?IsKeyOpened@CRegistryEdit@@QAAHXZ|	; CRegistryEdit::IsKeyOpened

  00000			 AREA	 |.pdata|, PDATA
|$T38756| DCD	|$LN7@IsKeyOpene|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsKeyOpened@CRegistryEdit@@QAAHXZ| PROC ; CRegistryEdit::IsKeyOpened

; 171  :     {

  00000		 |$LN7@IsKeyOpene|
  00000		 |$M38753|

; 172  :         return ( m_hDevKey != NULL );

  00000	e5903000	 ldr         r3, [r0]
  00004	e3530000	 cmp         r3, #0
  00008	13a00001	 movne       r0, #1
  0000c	03a00000	 moveq       r0, #0

; 173  :     }

  00010	e12fff1e	 bx          lr
  00014		 |$M38754|

			 ENDP  ; |?IsKeyOpened@CRegistryEdit@@QAAHXZ|, CRegistryEdit::IsKeyOpened

	EXPORT	|?DisablePddInterrupts@SOhcdPdd@@MAAXXZ| ; SOhcdPdd::DisablePddInterrupts
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\inc\bulverde_usbohci.h

  00000			 AREA	 |.pdata|, PDATA
|$T38764| DCD	|$LN5@DisablePdd|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePddInterrupts@SOhcdPdd@@MAAXXZ| PROC ; SOhcdPdd::DisablePddInterrupts

; 63   :     virtual void DisablePddInterrupts() { 

  00000		 |$LN5@DisablePdd|
  00000		 |$M38761|

; 64   :         m_pDCUSBOHCIReg->uhchie = 0 ; // Mask All PDD interrupt.

  00000	e5903020	 ldr         r3, [r0, #0x20]
  00004	e3a02000	 mov         r2, #0
  00008	e5832068	 str         r2, [r3, #0x68]

; 65   :     };

  0000c	e12fff1e	 bx          lr
  00010		 |$M38762|

			 ENDP  ; |?DisablePddInterrupts@SOhcdPdd@@MAAXXZ|, SOhcdPdd::DisablePddInterrupts

	EXPORT	|?InitPddInterrupts@SOhcdPdd@@MAAHXZ|	; SOhcdPdd::InitPddInterrupts
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\hcd\bul_ohci.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T38774| DCD	|$LN5@InitPddInt|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitPddInterrupts@SOhcdPdd@@MAAHXZ| PROC ; SOhcdPdd::InitPddInterrupts

; 253  : {

  00000		 |$LN5@InitPddInt|
  00000		 |$M38771|

; 254  :     DEBUGMSG(ZONE_INIT, (TEXT("SOhcdPdd::InitPddInterrupts() - Initial UHCHIE = 0x%x\r\n"),m_pDCUSBOHCIReg->uhchie));
; 255  :     m_pDCUSBOHCIReg->uhchie = 0 ; // Mask All PDD interrupt.

  00000	e5903020	 ldr         r3, [r0, #0x20]
  00004	e3a02000	 mov         r2, #0

; 256  :     return TRUE;

  00008	e3a00001	 mov         r0, #1
  0000c	e5832068	 str         r2, [r3, #0x68]

; 257  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M38772|

			 ENDP  ; |?InitPddInterrupts@SOhcdPdd@@MAAHXZ|, SOhcdPdd::InitPddInterrupts

	EXPORT	|?OHCI_Reset@SOhcdPdd@@MAAHXZ|		; SOhcdPdd::OHCI_Reset
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T38785| DCD	|$LN8@OHCI_Reset|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OHCI_Reset@SOhcdPdd@@MAAHXZ| PROC	; SOhcdPdd::OHCI_Reset

; 260  : {

  00000		 |$LN8@OHCI_Reset|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38782|
  00004	e1a04000	 mov         r4, r0

; 261  :    DEBUGMSG(ZONE_INIT,(TEXT("OHCI_Reset: Resetting Bulverde OHCI.\r\n")));
; 262  : 
; 263  :    // Do the reset for the Bulverde part.
; 264  :    // Two levels of reset need to be initiated:
; 265  :    //	The OHCI core needs to be reset via the FHR bit,
; 266  :    //	then the OHCI system bus interface needs to be reset via the FSBIR bit.
; 267  : 
; 268  :     // reset the OHC core and all OHC blocks driven by the 12 MHz clock, eg. write fifo, etc.
; 269  :     m_pDCUSBOHCIReg->uhchr |=  XLLP_USBOHCI_UHCHR_FHR;

  00008	e5942020	 ldr         r2, [r4, #0x20]

; 270  :     Sleep(1);

  0000c	e3a00001	 mov         r0, #1
  00010	e5923064	 ldr         r3, [r2, #0x64]
  00014	e3833002	 orr         r3, r3, #2
  00018	e5823064	 str         r3, [r2, #0x64]
  0001c	eb000000	 bl          Sleep

; 271  :     m_pDCUSBOHCIReg->uhchr &= ~XLLP_USBOHCI_UHCHR_FHR;

  00020	e5942020	 ldr         r2, [r4, #0x20]
  00024	e5923064	 ldr         r3, [r2, #0x64]
  00028	e3c33002	 bic         r3, r3, #2
  0002c	e5823064	 str         r3, [r2, #0x64]

; 272  : 
; 273  :     // reset the OHC system bus interface, eg. SBI, DMA blocks, fifos, etc.
; 274  :     m_pDCUSBOHCIReg->uhchr |=  XLLP_USBOHCI_UHCHR_FSBIR;

  00030	e5942020	 ldr         r2, [r4, #0x20]
  00034	e5923064	 ldr         r3, [r2, #0x64]
  00038	e3833001	 orr         r3, r3, #1
  0003c	e5823064	 str         r3, [r2, #0x64]
  00040		 |$LL2@OHCI_Reset|

; 275  :     while( m_pDCUSBOHCIReg->uhchr & XLLP_USBOHCI_UHCHR_FSBIR );	// auto clears in 3 system bus clocks

  00040	e5943020	 ldr         r3, [r4, #0x20]
  00044	e5933064	 ldr         r3, [r3, #0x64]
  00048	e3130001	 tst         r3, #1
  0004c	1afffffb	 bne         |$LL2@OHCI_Reset|

; 276  : 
; 277  :     DEBUGMSG(m_pDCUSBOHCIReg,(TEXT("OHCI_Reset: done.\r\n")));
; 278  :     return TRUE;

  00050	e3a00001	 mov         r0, #1

; 279  : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M38783|

			 ENDP  ; |?OHCI_Reset@SOhcdPdd@@MAAHXZ|, SOhcdPdd::OHCI_Reset

	EXPORT	|?TurnOnUSBHostClocks@SOhcdPdd@@QAAXXZ|	; SOhcdPdd::TurnOnUSBHostClocks

  00000			 AREA	 |.pdata|, PDATA
|$T38793| DCD	|$LN5@TurnOnUSBH|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TurnOnUSBHostClocks@SOhcdPdd@@QAAXXZ| PROC ; SOhcdPdd::TurnOnUSBHostClocks

; 288  : {

  00000		 |$LN5@TurnOnUSBH|
  00000		 |$M38790|

; 289  :     // The clock enable bit for the USB Host OHCI block in Bulverde
; 290  :     // is bit number 20.
; 291  :     DEBUGMSG(ZONE_INIT,(TEXT("TurnOnUSBHostClocks: Initial Values: cccr: %08x cken: %08x oscc: %08x ccsr: %08x\n\r"), m_pDCCLKReg->cccr, m_pDCCLKReg->cken, m_pDCCLKReg->oscc, m_pDCCLKReg->ccsr));
; 292  :     m_pDCCLKReg->cken |= XLLP_CLKEN_USBHOST;

  00000	e590201c	 ldr         r2, [r0, #0x1C]
  00004	e5923004	 ldr         r3, [r2, #4]
  00008	e3833b01	 orr         r3, r3, #1, 22
  0000c	e5823004	 str         r3, [r2, #4]

; 293  :     DEBUGMSG(ZONE_INIT,(TEXT("TurnOnUSBHostClocks: Final   Values: cccr: %08x cken: %08x oscc: %08x ccsr: %08x\n\r"), m_pDCCLKReg->cccr, m_pDCCLKReg->cken, m_pDCCLKReg->oscc, m_pDCCLKReg->ccsr));
; 294  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M38791|

			 ENDP  ; |?TurnOnUSBHostClocks@SOhcdPdd@@QAAXXZ|, SOhcdPdd::TurnOnUSBHostClocks

	EXPORT	|?TurnOffUSBHostClocks@SOhcdPdd@@QAAXXZ| ; SOhcdPdd::TurnOffUSBHostClocks

  00000			 AREA	 |.pdata|, PDATA
|$T38801| DCD	|$LN5@TurnOffUSB|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?TurnOffUSBHostClocks@SOhcdPdd@@QAAXXZ| PROC ; SOhcdPdd::TurnOffUSBHostClocks

; 303  : {

  00000		 |$LN5@TurnOffUSB|
  00000		 |$M38798|

; 304  :     // The clock enable bit for the USB Host OHCI block in Bulverde
; 305  :     // is bit number 20.
; 306  :     DEBUGMSG(ZONE_INIT,(TEXT("TurnOfUSBHostClocks: Initial Values: cccr: %08x cken: %08x oscc: %08x ccsr: %08x\n\r"), m_pDCCLKReg->cccr, m_pDCCLKReg->cken, m_pDCCLKReg->oscc, m_pDCCLKReg->ccsr));
; 307  :     m_pDCCLKReg->cken &= ~XLLP_CLKEN_USBHOST;

  00000	e590201c	 ldr         r2, [r0, #0x1C]
  00004	e5923004	 ldr         r3, [r2, #4]
  00008	e3c33b01	 bic         r3, r3, #1, 22
  0000c	e5823004	 str         r3, [r2, #4]

; 308  :     DEBUGMSG(ZONE_INIT,(TEXT("TurnOfUSBHostClocks: Final   Values: cccr: %08x cken: %08x oscc: %08x ccsr: %08x\n\r"), m_pDCCLKReg->cccr, m_pDCCLKReg->cken, m_pDCCLKReg->oscc, m_pDCCLKReg->ccsr));
; 309  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M38799|

			 ENDP  ; |?TurnOffUSBHostClocks@SOhcdPdd@@QAAXXZ|, SOhcdPdd::TurnOffUSBHostClocks

	EXPORT	|?SelectUSBHOSTPowerManagementMode@SOhcdPdd@@QAAXHHPAH@Z| ; SOhcdPdd::SelectUSBHOSTPowerManagementMode

  00000			 AREA	 |.pdata|, PDATA
|$T38819| DCD	|$LN24@SelectUSBH|
	DCD	0x40004a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SelectUSBHOSTPowerManagementMode@SOhcdPdd@@QAAXHHPAH@Z| PROC ; SOhcdPdd::SelectUSBHOSTPowerManagementMode

; 318  : {

  00000		 |$LN24@SelectUSBH|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M38816|
  00004	e1a05003	 mov         r5, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e3510000	 cmp         r1, #0

; 319  :     switch(Mode) {

  00010	0a00003e	 beq         |$LN12@SelectUSBH|
  00014	e3510001	 cmp         r1, #1
  00018	0a000034	 beq         |$LN11@SelectUSBH|
  0001c	e3510002	 cmp         r1, #2
  00020	0a00001c	 beq         |$LN10@SelectUSBH|
  00024	e3510003	 cmp         r1, #3
  00028	1a00003c	 bne         |$LN13@SelectUSBH|

; 345  :             }
; 346  :         }
; 347  : 
; 348  :         break;
; 349  : 
; 350  :       case XLLP_USBOHCI_PPM_MIXED:
; 351  :         // make sure the NO Power Switching mode bit is OFF so Power Switching can occur
; 352  :         // make sure the PSM bit is SET, which allows all ports to be controlled with 
; 353  :         // the PER PORT set and clear power commands
; 354  :         m_pDCUSBOHCIReg->uhcrhda &= ~XLLP_USBOHCI_UHCRHDA_NPS;

  0002c	e590e020	 ldr         lr, [r0, #0x20]

; 355  :         m_pDCUSBOHCIReg->uhcrhda |=  XLLP_USBOHCI_UHCRHDA_PSM_PERPORT;
; 356  : 
; 357  :         // set the power management mode for each individual port to Per Port.
; 358  :         // if the value in the PortMode array is non-zero, set Per Port mode for the port.
; 359  :         // if the value in the PortMode array is zero, set Global mode for the port
; 360  :         {
; 361  :         int		p;
; 362  : 
; 363  :         for( p = 0; p < NumPorts; p++ ) {

  00030	e3a04000	 mov         r4, #0
  00034	e3560000	 cmp         r6, #0
  00038	e59e1048	 ldr         r1, [lr, #0x48]
  0003c	e3c11c02	 bic         r1, r1, #2, 24
  00040	e58e1048	 str         r1, [lr, #0x48]
  00044	e5901020	 ldr         r1, [r0, #0x20]
  00048	e5913048	 ldr         r3, [r1, #0x48]
  0004c	e3833001	 orr         r3, r3, #1
  00050	e5813048	 str         r3, [r1, #0x48]
  00054	da000031	 ble         |$LN13@SelectUSBH|
  00058	e3a0e001	 mov         lr, #1
  0005c	e3a07001	 mov         r7, #1
  00060		 |$LL5@SelectUSBH|

; 364  :             if( PortMode[p] ) {

  00060	e5953000	 ldr         r3, [r5]

; 365  :                 m_pDCUSBOHCIReg->uhcrhdb |= (unsigned int)( 1u << (p+17) );	// port 1 begins at bit 17

  00064	e5901020	 ldr         r1, [r0, #0x20]
  00068	e2842011	 add         r2, r4, #0x11
  0006c	e3530000	 cmp         r3, #0
  00070	e591304c	 ldr         r3, [r1, #0x4C]

; 366  :             }
; 367  :             else   {
; 368  :                 m_pDCUSBOHCIReg->uhcrhdb &= ~(unsigned int)( 1u << (p+17) );	// port 1 begins at bit 17

  00074	e2844001	 add         r4, r4, #1
  00078	e2855004	 add         r5, r5, #4
  0007c	1183321e	 orrne       r3, r3, lr, lsl r2
  00080	01c33217	 biceq       r3, r3, r7, lsl r2
  00084	e1540006	 cmp         r4, r6
  00088	e581304c	 str         r3, [r1, #0x4C]
  0008c	bafffff3	 blt         |$LL5@SelectUSBH|

; 369  :             }
; 370  : 
; 371  :             }
; 372  :         }
; 373  : 
; 374  :         break;
; 375  :     }
; 376  : }

  00090	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$LN10@SelectUSBH|

; 330  :         break;
; 331  : 
; 332  :       case XLLP_USBOHCI_PPM_PERPORT:
; 333  :         // make sure the NO Power Switching mode bit is OFF so Power Switching can occur
; 334  :         // make sure the PSM bit is SET, which allows all ports to be controlled with 
; 335  :         // the PER PORT set and clear power commands
; 336  :         m_pDCUSBOHCIReg->uhcrhda &= ~XLLP_USBOHCI_UHCRHDA_NPS;

  00098	e5902020	 ldr         r2, [r0, #0x20]

; 337  :         m_pDCUSBOHCIReg->uhcrhda |=  XLLP_USBOHCI_UHCRHDA_PSM_PERPORT;
; 338  : 
; 339  :         // set the power management mode for each individual port to Per Port.
; 340  :         {
; 341  :             int p;
; 342  : 
; 343  :             for( p = 0; p < NumPorts; p++ ) {

  0009c	e3a0e000	 mov         lr, #0
  000a0	e3560000	 cmp         r6, #0
  000a4	e5923048	 ldr         r3, [r2, #0x48]
  000a8	e3c33c02	 bic         r3, r3, #2, 24
  000ac	e5823048	 str         r3, [r2, #0x48]
  000b0	e5902020	 ldr         r2, [r0, #0x20]
  000b4	e5923048	 ldr         r3, [r2, #0x48]
  000b8	e3833001	 orr         r3, r3, #1
  000bc	e5823048	 str         r3, [r2, #0x48]
  000c0	da000016	 ble         |$LN13@SelectUSBH|
  000c4	e3a04001	 mov         r4, #1
  000c8		 |$LL9@SelectUSBH|

; 344  :                 m_pDCUSBOHCIReg->uhcrhdb |= (unsigned int)( 1u << (p+17) );	// port 1 begins at bit 17

  000c8	e5901020	 ldr         r1, [r0, #0x20]
  000cc	e28e2011	 add         r2, lr, #0x11
  000d0	e28ee001	 add         lr, lr, #1
  000d4	e591304c	 ldr         r3, [r1, #0x4C]
  000d8	e15e0006	 cmp         lr, r6
  000dc	e1833214	 orr         r3, r3, r4, lsl r2
  000e0	e581304c	 str         r3, [r1, #0x4C]
  000e4	bafffff7	 blt         |$LL9@SelectUSBH|

; 369  :             }
; 370  : 
; 371  :             }
; 372  :         }
; 373  : 
; 374  :         break;
; 375  :     }
; 376  : }

  000e8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN11@SelectUSBH|

; 323  :         break;
; 324  : 
; 325  :       case XLLP_USBOHCI_PPM_GLOBAL:
; 326  :         // make sure the NO Power Switching mode bit is OFF so Power Switching can occur
; 327  :         // make sure the PSM bit is CLEAR, which allows all ports to be controlled with 
; 328  :         // the GLOBAL set and clear power commands
; 329  :         m_pDCUSBOHCIReg->uhcrhda &= ~(XLLP_USBOHCI_UHCRHDA_NPS|XLLP_USBOHCI_UHCRHDA_PSM_PERPORT);

  000f0	e5901020	 ldr         r1, [r0, #0x20]
  000f4	e3e03c02	 mvn         r3, #2, 24
  000f8	e2232001	 eor         r2, r3, #1
  000fc	e5913048	 ldr         r3, [r1, #0x48]
  00100	e0033002	 and         r3, r3, r2
  00104	e5813048	 str         r3, [r1, #0x48]

; 369  :             }
; 370  : 
; 371  :             }
; 372  :         }
; 373  : 
; 374  :         break;
; 375  :     }
; 376  : }

  00108	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN12@SelectUSBH|

; 320  :       case XLLP_USBOHCI_PPM_NPS:
; 321  :         // set NO Power Switching mode
; 322  :         m_pDCUSBOHCIReg->uhcrhda |= XLLP_USBOHCI_UHCRHDA_NPS;			

  00110	e5902020	 ldr         r2, [r0, #0x20]
  00114	e5923048	 ldr         r3, [r2, #0x48]
  00118	e3833c02	 orr         r3, r3, #2, 24
  0011c	e5823048	 str         r3, [r2, #0x48]
  00120		 |$LN13@SelectUSBH|

; 369  :             }
; 370  : 
; 371  :             }
; 372  :         }
; 373  : 
; 374  :         break;
; 375  :     }
; 376  : }

  00120	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$M38817|

			 ENDP  ; |?SelectUSBHOSTPowerManagementMode@SOhcdPdd@@QAAXHHPAH@Z|, SOhcdPdd::SelectUSBHOSTPowerManagementMode

	EXPORT	|?InitiatePowerUp@SOhcdPdd@@UAAKXZ|	; SOhcdPdd::InitiatePowerUp

  00000			 AREA	 |.pdata|, PDATA
|$T38855| DCD	|$LN27@InitiatePo|
	DCD	0x40002901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitiatePowerUp@SOhcdPdd@@UAAKXZ| PROC ; SOhcdPdd::InitiatePowerUp

; 384  : {

  00000		 |$LN27@InitiatePo|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38852|
  00004	e1a04000	 mov         r4, r0

; 385  :     DEBUGMSG(ZONE_INIT,(TEXT("SOhcdPdd::InitiatePowerUp: m_pDCUSBOHCIReg: %08x.\r\n"), m_pDCUSBOHCIReg));
; 386  : 
; 387  : 
; 388  :     TurnOnUSBHostClocks();	// make sure the ohci block is running (eg. getting clocked)

  00008	e594201c	 ldr         r2, [r4, #0x1C]

; 389  :     // Port 1
; 390  :     SetupUSBHostPWR(1);		// this sets up Pwr 1 notification using gpio 88 as input in alternate function 1 mode

  0000c	e3a01001	 mov         r1, #1
  00010	e5923004	 ldr         r3, [r2, #4]
  00014	e3833b01	 orr         r3, r3, #1, 22
  00018	e5823004	 str         r3, [r2, #4]
  0001c	e5943000	 ldr         r3, [r4]
  00020	e593300c	 ldr         r3, [r3, #0xC]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff13	 bx          r3

; 391  :     SetupUSBHostPEN(1);		// this sets up Pwr 1 enable using gpio 89 as output in alternate function 2 mode

  0002c	e5943000	 ldr         r3, [r4]
  00030	e3a01001	 mov         r1, #1
  00034	e1a00004	 mov         r0, r4
  00038	e5933010	 ldr         r3, [r3, #0x10]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3

; 392  :     // Port 2
; 393  :     SetupUSBHostPWR(2);		// this sets up Pwr 2 notification using gpio 88 as input in alternate function 1 mode

  00044	e5943000	 ldr         r3, [r4]
  00048	e3a01002	 mov         r1, #2
  0004c	e1a00004	 mov         r0, r4
  00050	e593300c	 ldr         r3, [r3, #0xC]
  00054	e1a0e00f	 mov         lr, pc
  00058	e12fff13	 bx          r3

; 394  :     SetupUSBHostPEN(2);		// this sets up Pwr 2 enable using gpio 89 as output in alternate function 2 mode

  0005c	e5943000	 ldr         r3, [r4]
  00060	e3a01002	 mov         r1, #2
  00064	e1a00004	 mov         r0, r4
  00068	e5933010	 ldr         r3, [r3, #0x10]
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3

; 395  :     
; 396  :     //TurnOnUSBHostPorts();	// probably only do this after the rest of the ohci is set up.
; 397  :     //TestUSBHostPEN(0);
; 398  :     SelectUSBHOSTPowerManagementMode( XLLP_USBOHCI_PPM_NPS, 0, 0 );

  00074	e5942020	 ldr         r2, [r4, #0x20]

; 399  :     
; 400  :     OHCI_Reset();

  00078	e1a00004	 mov         r0, r4
  0007c	e5923048	 ldr         r3, [r2, #0x48]
  00080	e3833c02	 orr         r3, r3, #2, 24
  00084	e5823048	 str         r3, [r2, #0x48]
  00088	e5943000	 ldr         r3, [r4]
  0008c	e5933018	 ldr         r3, [r3, #0x18]
  00090	e1a0e00f	 mov         lr, pc
  00094	e12fff13	 bx          r3

; 401  :     return 0;

  00098	e3a00000	 mov         r0, #0

; 402  : }

  0009c	e8bd4010	 ldmia       sp!, {r4, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M38853|

			 ENDP  ; |?InitiatePowerUp@SOhcdPdd@@UAAKXZ|, SOhcdPdd::InitiatePowerUp

	EXPORT	|?PowerUp@SOhcdPdd@@UAAXXZ|		; SOhcdPdd::PowerUp
	IMPORT	|HcdMdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T38863| DCD	|$LN5@PowerUp|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerUp@SOhcdPdd@@UAAXXZ| PROC	; SOhcdPdd::PowerUp

; 404  : {

  00000		 |$LN5@PowerUp|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38860|

; 405  :     HcdMdd_PowerUp(m_pobOhcd);

  00004	e5900054	 ldr         r0, [r0, #0x54]
  00008	eb000000	 bl          HcdMdd_PowerUp

; 406  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M38861|

			 ENDP  ; |?PowerUp@SOhcdPdd@@UAAXXZ|, SOhcdPdd::PowerUp

	EXPORT	|?PowerDown@SOhcdPdd@@UAAXXZ|		; SOhcdPdd::PowerDown
	IMPORT	|HcdMdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T38871| DCD	|$LN5@PowerDown|
	DCD	0x40000e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PowerDown@SOhcdPdd@@UAAXXZ| PROC	; SOhcdPdd::PowerDown

; 409  : {

  00000		 |$LN5@PowerDown|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38868|
  00004	e1a04000	 mov         r4, r0

; 410  : 
; 411  :     // let the MDD do its processing (including putting the HC into reset)
; 412  :     HcdMdd_PowerDown(m_pobOhcd);

  00008	e5940054	 ldr         r0, [r4, #0x54]
  0000c	eb000000	 bl          HcdMdd_PowerDown

; 413  : 
; 414  :     // disable the USB port as described in section 6.1.4.4 of the SA-1111 companion
; 415  :     // chip documentation:
; 416  :     // (1) Reset HC (done by MDD)
; 417  :     // (2) wait 10 us
; 418  :     // (3) clear global power enable bit
; 419  :     // (4) set the standby enable bit
; 420  :     // (5) stop the usb clock
; 421  :     //usWait(10);                     // must not block or do operations illegal in interrupt context
; 422  :     m_pDCUSBOHCIReg->uhcrhda &= ~ ((1 << 8) | (1 << 9));     // set global power switch mode

  00010	e5942020	 ldr         r2, [r4, #0x20]
  00014	e5923048	 ldr         r3, [r2, #0x48]
  00018	e3c33c03	 bic         r3, r3, #3, 24
  0001c	e5823048	 str         r3, [r2, #0x48]

; 423  :     m_pDCUSBOHCIReg->uhcrhs |= 0x0001;                   // clear global power

  00020	e5942020	 ldr         r2, [r4, #0x20]
  00024	e5923050	 ldr         r3, [r2, #0x50]
  00028	e3833001	 orr         r3, r3, #1
  0002c	e5823050	 str         r3, [r2, #0x50]

; 424  : };

  00030	e8bd4010	 ldmia       sp!, {r4, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M38869|

			 ENDP  ; |?PowerDown@SOhcdPdd@@UAAXXZ|, SOhcdPdd::PowerDown

	EXPORT	|HcdPdd_DllMain|

  00000			 AREA	 |.pdata|, PDATA
|$T38880| DCD	|$LN5@HcdPdd_Dll|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_DllMain| PROC

; 434  : {

  00000		 |$LN5@HcdPdd_Dll|
  00000		 |$M38877|

; 435  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 436  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38878|

			 ENDP  ; |HcdPdd_DllMain|

	EXPORT	|HcdPdd_InitiatePowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T38888| DCD	|$LN6@HcdPdd_Ini|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_InitiatePowerUp| PROC

; 439  : {

  00000		 |$LN6@HcdPdd_Ini|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38885|
  00004	e3500000	 cmp         r0, #0

; 440  :     SOhcdPdd * pPddObject = (SOhcdPdd *)hDeviceContext;
; 441  :     if (pPddObject)
; 442  :         pPddObject->InitiatePowerUp();

  00008	15903000	 ldrne       r3, [r0]
  0000c	1593302c	 ldrne       r3, [r3, #0x2C]
  00010	11a0e00f	 movne       lr, pc
  00014	112fff13	 bxne        r3

; 443  :     
; 444  :     return;
; 445  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M38886|

			 ENDP  ; |HcdPdd_InitiatePowerUp|

	EXPORT	|HcdPdd_Init|
	IMPORT	|?CreateBulverdeOhci@@YAPAVSOhcdPdd@@PBG@Z| ; CreateBulverdeOhci

  00000			 AREA	 |.pdata|, PDATA
|$T38903| DCD	|$LN9@HcdPdd_Ini@2|
	DCD	0x40001501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Init| PROC

; 459  : {

  00000		 |$LN9@HcdPdd_Ini@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M38900|

; 460  :     SOhcdPdd *  pPddObject = CreateBulverdeOhci((LPCTSTR)dwContext);

  00004	eb000000	 bl          |?CreateBulverdeOhci@@YAPAVSOhcdPdd@@PBG@Z|
  00008	e1b04000	 movs        r4, r0

; 461  : 
; 462  :     if (pPddObject && pPddObject->Init()) {

  0000c	0a00000c	 beq         |$LN5@HcdPdd_Ini@2|
  00010	e5943000	 ldr         r3, [r4]
  00014	e1a00004	 mov         r0, r4
  00018	e5933008	 ldr         r3, [r3, #8]
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3
  00024	e3500000	 cmp         r0, #0

; 463  :         DEBUGMSG(ZONE_INIT, (TEXT("HcdPdd_Init: Checking SW18 - controls OHCI loading.\r\n")));
; 464  :         return (DWORD) pPddObject ;

  00028	1a000006	 bne         |$LN3@HcdPdd_Ini@2|

; 465  :     }
; 466  :     if (pPddObject)
; 467  :         delete pPddObject;

  0002c	e5943000	 ldr         r3, [r4]
  00030	e3a01001	 mov         r1, #1
  00034	e1a00004	 mov         r0, r4
  00038	e5933004	 ldr         r3, [r3, #4]
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3
  00044		 |$LN5@HcdPdd_Ini@2|

; 468  :     return (DWORD)NULL;

  00044	e3a04000	 mov         r4, #0
  00048		 |$LN3@HcdPdd_Ini@2|

; 469  : }

  00048	e1a00004	 mov         r0, r4
  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$M38901|

			 ENDP  ; |HcdPdd_Init|

	EXPORT	|HcdPdd_CheckConfigPower|

  00000			 AREA	 |.pdata|, PDATA
|$T38916| DCD	|$LN7@HcdPdd_Che|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_CheckConfigPower| PROC

; 485  : {

  00000		 |$LN7@HcdPdd_Che|
  00000		 |$M38913|

; 486  :     return ((dwCfgPower + dwTotalPower) > 500) ? FALSE : TRUE;

  00000	e0813002	 add         r3, r1, r2
  00004	e3530f7d	 cmp         r3, #0x7D, 30
  00008	83a00000	 movhi       r0, #0
  0000c	93a00001	 movls       r0, #1

; 487  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M38914|

			 ENDP  ; |HcdPdd_CheckConfigPower|

	EXPORT	|HcdPdd_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T38924| DCD	|$LN6@HcdPdd_Pow|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PowerUp| PROC

; 490  : {

  00000		 |$LN6@HcdPdd_Pow|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38921|
  00004	e3500000	 cmp         r0, #0

; 491  :     SOhcdPdd * pPddObject = (SOhcdPdd *)hDeviceContext;
; 492  :     DEBUGMSG(ZONE_INIT, (TEXT("HcdPdd_PowerUp: enter.\n\r")));
; 493  :     if (pPddObject)
; 494  :         pPddObject->PowerUp();

  00008	15903000	 ldrne       r3, [r0]
  0000c	15933024	 ldrne       r3, [r3, #0x24]
  00010	11a0e00f	 movne       lr, pc
  00014	112fff13	 bxne        r3

; 495  :     DEBUGMSG(ZONE_INIT, (TEXT("HcdPdd_PowerUp: Need to add Bulverde support.\n\r")));
; 496  :     return;
; 497  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M38922|

			 ENDP  ; |HcdPdd_PowerUp|

	EXPORT	|HcdPdd_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T38932| DCD	|$LN6@HcdPdd_Pow@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_PowerDown| PROC

; 500  : {

  00000		 |$LN6@HcdPdd_Pow@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38929|
  00004	e3500000	 cmp         r0, #0

; 501  :     SOhcdPdd * pPddObject = (SOhcdPdd *)hDeviceContext;
; 502  :     DEBUGMSG(ZONE_INIT, (TEXT("HcdPdd_PowerDown: enter.\n\r")));
; 503  :     if (pPddObject)
; 504  :         pPddObject->PowerDown();

  00008	15903000	 ldrne       r3, [r0]
  0000c	15933028	 ldrne       r3, [r3, #0x28]
  00010	11a0e00f	 movne       lr, pc
  00014	112fff13	 bxne        r3

; 505  : 
; 506  :     DEBUGMSG(ZONE_INIT, (TEXT("HcdPdd_PowerDown: Need to add Bulverde support.\n\r")));
; 507  :     return;
; 508  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M38930|

			 ENDP  ; |HcdPdd_PowerDown|

	EXPORT	|HcdPdd_Deinit|

  00000			 AREA	 |.pdata|, PDATA
|$T38946| DCD	|$LN8@HcdPdd_Dei|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Deinit| PROC

; 512  : {

  00000		 |$LN8@HcdPdd_Dei|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M38943|
  00004	e3500000	 cmp         r0, #0

; 513  :     SOhcdPdd * pPddObject = (SOhcdPdd *)hDeviceContext;
; 514  :     if (pPddObject)
; 515  :         delete pPddObject;

  00008	15903000	 ldrne       r3, [r0]
  0000c	13a01001	 movne       r1, #1
  00010	15933004	 ldrne       r3, [r3, #4]
  00014	11a0e00f	 movne       lr, pc
  00018	112fff13	 bxne        r3

; 516  :     return TRUE;

  0001c	e3a00001	 mov         r0, #1

; 517  : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M38944|

			 ENDP  ; |HcdPdd_Deinit|

	EXPORT	|HcdPdd_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T38955| DCD	|$LN5@HcdPdd_Ope|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Open| PROC

; 522  : {

  00000		 |$LN5@HcdPdd_Ope|
  00000		 |$M38952|

; 523  : 
; 524  :     return 1; // we can be opened, but only once!

  00000	e3a00001	 mov         r0, #1

; 525  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38953|

			 ENDP  ; |HcdPdd_Open|

	EXPORT	|HcdPdd_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T38964| DCD	|$LN5@HcdPdd_Clo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Close| PROC

; 529  : {

  00000		 |$LN5@HcdPdd_Clo|
  00000		 |$M38961|

; 530  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 531  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38962|

			 ENDP  ; |HcdPdd_Close|

	EXPORT	|HcdPdd_Read|

  00000			 AREA	 |.pdata|, PDATA
|$T38973| DCD	|$LN5@HcdPdd_Rea|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Read| PROC

; 535  : {

  00000		 |$LN5@HcdPdd_Rea|
  00000		 |$M38970|

; 536  :     return (DWORD)-1; // an error occured

  00000	e3e00000	 mvn         r0, #0

; 537  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38971|

			 ENDP  ; |HcdPdd_Read|

	EXPORT	|HcdPdd_Write|

  00000			 AREA	 |.pdata|, PDATA
|$T38982| DCD	|$LN5@HcdPdd_Wri|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Write| PROC

; 542  : {

  00000		 |$LN5@HcdPdd_Wri|
  00000		 |$M38979|

; 543  :     return (DWORD)-1;

  00000	e3e00000	 mvn         r0, #0

; 544  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38980|

			 ENDP  ; |HcdPdd_Write|

	EXPORT	|HcdPdd_Seek|

  00000			 AREA	 |.pdata|, PDATA
|$T38991| DCD	|$LN5@HcdPdd_See|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_Seek| PROC

; 548  : {

  00000		 |$LN5@HcdPdd_See|
  00000		 |$M38988|

; 549  :     return (DWORD)-1;

  00000	e3e00000	 mvn         r0, #0

; 550  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38989|

			 ENDP  ; |HcdPdd_Seek|

	EXPORT	|HcdPdd_IOControl|

  00000			 AREA	 |.pdata|, PDATA
|$T39000| DCD	|$LN5@HcdPdd_IOC|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HcdPdd_IOControl| PROC

; 555  : {

  00000		 |$LN5@HcdPdd_IOC|
  00000		 |$M38997|

; 556  :     return FALSE;

  00000	e3a00000	 mov         r0, #0

; 557  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M38998|

			 ENDP  ; |HcdPdd_IOControl|

	EXPORT	|??0CBulverdeOhcd@@QAA@PAXPAVCPhysMem@@PBGRAEK@Z| ; CBulverdeOhcd::CBulverdeOhcd
	EXPORT	|??_7CBulverdeOhcd@@6B@| [ DATA ]	; CBulverdeOhcd::`vftable'
	EXPORT	|?GetCapability@CHW@@UAAKXZ|		; CHW::GetCapability
	EXPORT	|?ResumeNotification@CHcd@@MAAHXZ|	; CHcd::ResumeNotification
	EXPORT	|?SignalCheckForDoneTransfers@COhcd@@UAAXK@Z| ; COhcd::SignalCheckForDoneTransfers
	EXPORT	|?GetNumberOfDownStreamPort@CBulverdeOhcd@@UAAEXZ| ; CBulverdeOhcd::GetNumberOfDownStreamPort
	EXPORT	|?LoadHcdCapability@CBulverdeOhcd@@UAAXPBG@Z| ; CBulverdeOhcd::LoadHcdCapability
	IMPORT	|??0COhcd@@QAA@PAXPAVCPhysMem@@PBGRAEK@Z| ; COhcd::COhcd
	IMPORT	|??_ECBulverdeOhcd@@UAAPAXI@Z|, WEAK |??_GCBulverdeOhcd@@UAAPAXI@Z| ; CBulverdeOhcd::`vector deleting destructor', CBulverdeOhcd::`scalar deleting destructor'
	IMPORT	|?DeviceInitialize@COhcd@@UAAHXZ|	; COhcd::DeviceInitialize
	IMPORT	|?DeviceDeInitialize@COhcd@@UAAXXZ|	; COhcd::DeviceDeInitialize
	IMPORT	|?GetFrameNumber@CHW@@UAAHPAK@Z|	; CHW::GetFrameNumber
	IMPORT	|?GetFrameLength@CHW@@UAAHPAG@Z|	; CHW::GetFrameLength
	IMPORT	|?SetFrameLength@CHW@@UAAHPAXG@Z|	; CHW::SetFrameLength
	IMPORT	|?StopAdjustingFrame@CHW@@UAAHXZ|	; CHW::StopAdjustingFrame
	IMPORT	|?PowerMgmtCallback@CHW@@UAAXH@Z|	; CHW::PowerMgmtCallback
	IMPORT	|?DisableDevice@CHcd@@UAAHIH@Z|		; CHcd::DisableDevice
	IMPORT	|?SuspendResume@CHcd@@UAAHIH@Z|		; CHcd::SuspendResume
	IMPORT	|?DidPortStatusChange@CHW@@UAAHE@Z|	; CHW::DidPortStatusChange
	IMPORT	|?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z| ; CHW::GetPortStatus
	IMPORT	|?RootHubFeature@CHW@@UAAHEEG@Z|	; CHW::RootHubFeature
	IMPORT	|?ResetAndEnablePort@CHW@@UAAHE@Z|	; CHW::ResetAndEnablePort
	IMPORT	|?DisablePort@CHW@@UAAXE@Z|		; CHW::DisablePort
	IMPORT	|?WaitForPortStatusChange@CHW@@UAAHPAX@Z| ; CHW::WaitForPortStatusChange
	IMPORT	|?SetCapability@CHW@@UAAKK@Z|		; CHW::SetCapability
	IMPORT	|?SuspendHC@CHW@@UAAHXZ|		; CHW::SuspendHC
	IMPORT	|?Initialize@CHW@@UAAHXZ|		; CHW::Initialize
	IMPORT	|?DeInitialize@CHW@@UAAXXZ|		; CHW::DeInitialize

  00000			 AREA	 |.pdata|, PDATA
|$T39013| DCD	|$LN5@CBulverdeO|
	DCD	0x40000f02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CBulverdeOhcd@@6B@| DCD |??_ECBulverdeOhcd@@UAAPAXI@Z| ; CBulverdeOhcd::`vftable'
	DCD	|?DeviceInitialize@COhcd@@UAAHXZ|
	DCD	|?DeviceDeInitialize@COhcd@@UAAXXZ|
	DCD	|?GetFrameNumber@CHW@@UAAHPAK@Z|
	DCD	|?GetFrameLength@CHW@@UAAHPAG@Z|
	DCD	|?SetFrameLength@CHW@@UAAHPAXG@Z|
	DCD	|?StopAdjustingFrame@CHW@@UAAHXZ|
	DCD	|?PowerMgmtCallback@CHW@@UAAXH@Z|
	DCD	|?DisableDevice@CHcd@@UAAHIH@Z|
	DCD	|?SuspendResume@CHcd@@UAAHIH@Z|
	DCD	|?DidPortStatusChange@CHW@@UAAHE@Z|
	DCD	|?GetPortStatus@CHW@@UAAHEAAU_USB_HUB_AND_PORT_STATUS@@@Z|
	DCD	|?RootHubFeature@CHW@@UAAHEEG@Z|
	DCD	|?ResetAndEnablePort@CHW@@UAAHE@Z|
	DCD	|?DisablePort@CHW@@UAAXE@Z|
	DCD	|?WaitForPortStatusChange@CHW@@UAAHPAX@Z|
	DCD	|?SetCapability@CHW@@UAAKK@Z|
	DCD	|?GetCapability@CHW@@UAAKXZ|
	DCD	|?SuspendHC@CHW@@UAAHXZ|
	DCD	|?ResumeNotification@CHcd@@MAAHXZ|
	DCD	|?Initialize@CHW@@UAAHXZ|
	DCD	|?DeInitialize@CHW@@UAAXXZ|
	DCD	|?SignalCheckForDoneTransfers@COhcd@@UAAXK@Z|
	DCD	|?GetNumberOfDownStreamPort@CBulverdeOhcd@@UAAEXZ|
	DCD	|?LoadHcdCapability@CBulverdeOhcd@@UAAXPBG@Z|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CBulverdeOhcd@@QAA@PAXPAVCPhysMem@@PBGRAEK@Z| PROC ; CBulverdeOhcd::CBulverdeOhcd

; 569  :     { ; }

  00000		 |$LN5@CBulverdeO|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M39010|
  00008	e1a05000	 mov         r5, r0
  0000c	e59de018	 ldr         lr, [sp, #0x18]
  00010	e59d4014	 ldr         r4, [sp, #0x14]
  00014	e58de004	 str         lr, [sp, #4]
  00018	e58d4000	 str         r4, [sp]
  0001c	eb000000	 bl          |??0COhcd@@QAA@PAXPAVCPhysMem@@PBGRAEK@Z|
  00020	e59f3010	 ldr         r3, [pc, #0x10]
  00024	e1a00005	 mov         r0, r5
  00028	e5853000	 str         r3, [r5]
  0002c	e28dd008	 add         sp, sp, #8
  00030	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$LN6@CBulverdeO|
  00038		 |$LN7@CBulverdeO|
  00038	00000000	 DCD         |??_7CBulverdeOhcd@@6B@|
  0003c		 |$M39011|

			 ENDP  ; |??0CBulverdeOhcd@@QAA@PAXPAVCPhysMem@@PBGRAEK@Z|, CBulverdeOhcd::CBulverdeOhcd

	EXPORT	|?Lock@LockObject@@QAAXXZ|		; LockObject::Lock
	IMPORT	|EnterCriticalSection|
; File c:\wince600\public\common\oak\drivers\usb\hcd\common\sync.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39023| DCD	|$LN5@Lock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Lock@LockObject@@QAAXXZ| PROC	; LockObject::Lock

; 74   :     void Lock(void) { EnterCriticalSection(&m_CSection); };

  00000		 |$LN5@Lock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39020|
  00004	eb000000	 bl          EnterCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M39021|

			 ENDP  ; |?Lock@LockObject@@QAAXXZ|, LockObject::Lock

	EXPORT	|?Unlock@LockObject@@QAAXXZ|		; LockObject::Unlock
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T39031| DCD	|$LN5@Unlock|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Unlock@LockObject@@QAAXXZ| PROC	; LockObject::Unlock

; 75   :     void Unlock(void) {LeaveCriticalSection( &m_CSection); };

  00000		 |$LN5@Unlock|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39028|
  00004	eb000000	 bl          LeaveCriticalSection
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M39029|

			 ENDP  ; |?Unlock@LockObject@@QAAXXZ|, LockObject::Unlock


  00000			 AREA	 |.pdata|, PDATA
|$T39048| DCD	|$LN10@ResumeNoti|
	DCD	0x40002001
; Function compile flags: /Ogspy
; File c:\wince600\public\common\oak\drivers\usb\hcd\common\hcd.hpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResumeNotification@CHcd@@MAAHXZ| PROC ; CHcd::ResumeNotification

; 130  :     virtual BOOL ResumeNotification ()  {

  00000		 |$LN10@ResumeNoti|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39045|
  00004	e1a04000	 mov         r4, r0

; 131  :         Lock();

  00008	e2840004	 add         r0, r4, #4
  0000c	eb000000	 bl          EnterCriticalSection

; 132  :         BOOL fReturn = FALSE;
; 133  :         if (m_pCRootHub) {

  00010	e59430a8	 ldr         r3, [r4, #0xA8]
  00014	e3a05000	 mov         r5, #0
  00018	e3530000	 cmp         r3, #0
  0001c	0a000012	 beq         |$LN1@ResumeNoti|

; 134  :             fReturn = m_pCRootHub->ResumeNotification();

  00020	e1a00003	 mov         r0, r3
  00024	e5903000	 ldr         r3, [r0]
  00028	e593302c	 ldr         r3, [r3, #0x2C]
  0002c	e1a0e00f	 mov         lr, pc
  00030	e12fff13	 bx          r3

; 135  :             m_pCRootHub->NotifyOnSuspendedResumed(FALSE);

  00034	e59420a8	 ldr         r2, [r4, #0xA8]
  00038	e1a05000	 mov         r5, r0
  0003c	e3a01000	 mov         r1, #0
  00040	e5923000	 ldr         r3, [r2]
  00044	e1a00002	 mov         r0, r2
  00048	e5933030	 ldr         r3, [r3, #0x30]
  0004c	e1a0e00f	 mov         lr, pc
  00050	e12fff13	 bx          r3

; 136  :             m_pCRootHub->NotifyOnSuspendedResumed(TRUE);

  00054	e59400a8	 ldr         r0, [r4, #0xA8]
  00058	e3a01001	 mov         r1, #1
  0005c	e5903000	 ldr         r3, [r0]
  00060	e5933030	 ldr         r3, [r3, #0x30]
  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff13	 bx          r3
  0006c		 |$LN1@ResumeNoti|

; 137  :             
; 138  :         }
; 139  :         Unlock();

  0006c	e2840004	 add         r0, r4, #4
  00070	eb000000	 bl          LeaveCriticalSection

; 140  :         return fReturn;
; 141  :     }

  00074	e1a00005	 mov         r0, r5
  00078	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$M39046|

			 ENDP  ; |?ResumeNotification@CHcd@@MAAHXZ|, CHcd::ResumeNotification

	EXPORT	|?GetNumberOfDownStreamPort@CHW@@UAAEXZ| ; CHW::GetNumberOfDownStreamPort
; File c:\wince600\public\common\oak\drivers\usb\hcd\ohcd2\chw.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39058| DCD	|$LN5@GetNumberO|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetNumberOfDownStreamPort@CHW@@UAAEXZ| PROC ; CHW::GetNumberOfDownStreamPort

; 228  :     virtual UCHAR GetNumberOfDownStreamPort()  {

  00000		 |$LN5@GetNumberO|
  00000		 |$M39055|

; 229  :         return m_portBase->HcRhDescriptorA.NDP ;

  00000	e59030bc	 ldr         r3, [r0, #0xBC]
  00004	e5933048	 ldr         r3, [r3, #0x48]
  00008	e20300ff	 and         r0, r3, #0xFF

; 230  :     }

  0000c	e12fff1e	 bx          lr
  00010		 |$M39056|

			 ENDP  ; |?GetNumberOfDownStreamPort@CHW@@UAAEXZ|, CHW::GetNumberOfDownStreamPort


  00000			 AREA	 |.pdata|, PDATA
|$T39068| DCD	|$LN5@GetCapabil|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetCapability@CHW@@UAAKXZ| PROC	; CHW::GetCapability

; 314  :     DWORD   GetCapability() { return m_dwCapability; };

  00000		 |$LN5@GetCapabil|
  00000		 |$M39065|
  00000	e5900108	 ldr         r0, [r0, #0x108]
  00004	e12fff1e	 bx          lr
  00008		 |$M39066|

			 ENDP  ; |?GetCapability@CHW@@UAAKXZ|, CHW::GetCapability

	IMPORT	|?SignalCheckForDoneTransfers@CHCCAera@@QAAXK@Z| ; CHCCAera::SignalCheckForDoneTransfers
; File c:\wince600\public\common\oak\drivers\usb\hcd\ohcd2\cohcd.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39077| DCD	|$LN5@SignalChec|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SignalCheckForDoneTransfers@COhcd@@UAAXK@Z| PROC ; COhcd::SignalCheckForDoneTransfers

; 62   :     virtual void SignalCheckForDoneTransfers( DWORD paDoneHead ) { CHCCAera::SignalCheckForDoneTransfers(paDoneHead); };

  00000		 |$LN5@SignalChec|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39074|
  00004	e2800f46	 add         r0, r0, #0x46, 30
  00008	eb000000	 bl          |?SignalCheckForDoneTransfers@CHCCAera@@QAAXK@Z|
  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M39075|

			 ENDP  ; |?SignalCheckForDoneTransfers@COhcd@@UAAXK@Z|, COhcd::SignalCheckForDoneTransfers

; File c:\wince600\public\common\oak\drivers\usb\hcd\ohcd2\chw.hpp

  00000			 AREA	 |.pdata|, PDATA
|$T39090| DCD	|$LN7@GetNumberO@2|
	DCD	0x40000500
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\hcd\bul_ohci.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetNumberOfDownStreamPort@CBulverdeOhcd@@UAAEXZ| PROC ; CBulverdeOhcd::GetNumberOfDownStreamPort

; 574  :     virtual UCHAR GetNumberOfDownStreamPort()  {

  00000		 |$LN7@GetNumberO@2|
  00000		 |$M39087|

; 575  :         return (COhcd::GetNumberOfDownStreamPort()+1) ;

  00000	e59030bc	 ldr         r3, [r0, #0xBC]
  00004	e5933048	 ldr         r3, [r3, #0x48]
  00008	e2833001	 add         r3, r3, #1
  0000c	e20300ff	 and         r0, r3, #0xFF

; 576  :     }

  00010	e12fff1e	 bx          lr
  00014		 |$M39088|

			 ENDP  ; |?GetNumberOfDownStreamPort@CBulverdeOhcd@@UAAEXZ|, CBulverdeOhcd::GetNumberOfDownStreamPort

	EXPORT	|??_C@_1BM@KKKMKIHE@?$AAH?$AAc?$AAd?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T39102| DCD	|$LN11@LoadHcdCap|
	DCD	0x40002b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@KKKMKIHE@?$AAH?$AAc?$AAd?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?$AA@| DCB "H"
	DCB	0x0, "c", 0x0, "d", 0x0, "C", 0x0, "a", 0x0, "p", 0x0, "a"
	DCB	0x0, "b", 0x0, "i", 0x0, "l", 0x0, "i", 0x0, "t", 0x0, "y"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?LoadHcdCapability@CBulverdeOhcd@@UAAXPBG@Z| PROC ; CBulverdeOhcd::LoadHcdCapability

; 581  :     virtual void LoadHcdCapability( IN LPCWSTR szDriverRegistryKey) {

  00000		 |$LN11@LoadHcdCap|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M39099|
  00008	e1a05000	 mov         r5, r0
  0000c	e3a0380f	 mov         r3, #0xF, 16

; 582  :         LONG  regError;
; 583  :         DWORD dwDataSize;
; 584  :         HKEY  hKey = NULL;

  00010	e3a04000	 mov         r4, #0

; 585  :         DWORD dwHcdCapability=0;

  00014	e3a06000	 mov         r6, #0

; 586  : 
; 587  :         // Open the driver registry key
; 588  :         regError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szDriverRegistryKey,0,KEY_ALL_ACCESS,&hKey);

  00018	e28de008	 add         lr, sp, #8
  0001c	e383303f	 orr         r3, r3, #0x3F
  00020	e3a02000	 mov         r2, #0
  00024	e3a0010a	 mov         r0, #0xA, 2
  00028	e58d4008	 str         r4, [sp, #8]
  0002c	e58d600c	 str         r6, [sp, #0xC]
  00030	e58de000	 str         lr, [sp]
  00034	eb000000	 bl          RegOpenKeyExW
  00038	e3500000	 cmp         r0, #0

; 589  :         if (regError != ERROR_SUCCESS)
; 590  :         {
; 591  :             DEBUGMSG(ZONE_INIT,(TEXT("CBulverdeOhcd:LoadHcdCapability:: Failed opening HKLM\\%s \r\n"), szDriverRegistryKey));
; 592  :             hKey = NULL;

  0003c	13a00000	 movne       r0, #0
  00040	158d0008	 strne       r0, [sp, #8]
  00044	059d0008	 ldreq       r0, [sp, #8]

; 593  :         }
; 594  :             
; 595  :         // Get "HcdCapability"
; 596  :         if (hKey)

  00048	e3500000	 cmp         r0, #0
  0004c	0a000011	 beq         |$LN2@LoadHcdCap|

; 597  :         {
; 598  :             dwDataSize = sizeof(dwHcdCapability);
; 599  :             regError = RegQueryValueEx(hKey,HCD_CAPABILITY_VALNAME,NULL,NULL,(LPBYTE)&dwHcdCapability,&dwDataSize);

  00050	e59f1050	 ldr         r1, [pc, #0x50]
  00054	e3a06004	 mov         r6, #4
  00058	e28de010	 add         lr, sp, #0x10
  0005c	e28d400c	 add         r4, sp, #0xC
  00060	e3a03000	 mov         r3, #0
  00064	e3a02000	 mov         r2, #0
  00068	e58d6010	 str         r6, [sp, #0x10]
  0006c	e58de004	 str         lr, [sp, #4]
  00070	e58d4000	 str         r4, [sp]
  00074	eb000000	 bl          RegQueryValueExW
  00078	e3500000	 cmp         r0, #0

; 600  :             if (regError == ERROR_SUCCESS)
; 601  :             {
; 602  :                 this->SetCapability(dwHcdCapability);

  0007c	05953000	 ldreq       r3, [r5]
  00080	059d100c	 ldreq       r1, [sp, #0xC]
  00084	01a00005	 moveq       r0, r5
  00088	05933040	 ldreq       r3, [r3, #0x40]
  0008c	01a0e00f	 moveq       lr, pc
  00090	012fff13	 bxeq        r3
  00094	e59d0008	 ldr         r0, [sp, #8]
  00098		 |$LN2@LoadHcdCap|

; 603  :             }
; 604  :             else
; 605  :             {
; 606  :                 DEBUGMSG(ZONE_INIT,(TEXT("CBulverdeOhcd:LoadHcdCapability:: Failed opening HKLM\\%s\\%s \r\n"), szDriverRegistryKey,HCD_CAPABILITY_VALNAME));
; 607  :             }
; 608  :         }
; 609  : 
; 610  :         RegCloseKey (hKey);

  00098	eb000000	 bl          RegCloseKey

; 611  :     }

  0009c	e28dd014	 add         sp, sp, #0x14
  000a0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN12@LoadHcdCap|
  000a8		 |$LN13@LoadHcdCap|
  000a8	00000000	 DCD         |??_C@_1BM@KKKMKIHE@?$AAH?$AAc?$AAd?$AAC?$AAa?$AAp?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?$AA@|
  000ac		 |$M39100|

			 ENDP  ; |?LoadHcdCapability@CBulverdeOhcd@@UAAXPBG@Z|, CBulverdeOhcd::LoadHcdCapability

	EXPORT	|??1CBulverdeOhcd@@UAA@XZ|		; CBulverdeOhcd::~CBulverdeOhcd
	IMPORT	|??1COhcd@@UAA@XZ|			; COhcd::~COhcd

  00000			 AREA	 |.pdata|, PDATA
|$T39112| DCD	|$LN5@CBulverdeO@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CBulverdeOhcd@@UAA@XZ| PROC	; CBulverdeOhcd::~CBulverdeOhcd
  00000		 |$LN5@CBulverdeO@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39109|
  00004	eb000000	 bl          |??1COhcd@@UAA@XZ|
  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M39110|

			 ENDP  ; |??1CBulverdeOhcd@@UAA@XZ|, CBulverdeOhcd::~CBulverdeOhcd

	EXPORT	|?CreateBulverdeHcdObject@@YAPAXPAX0PBGPAEK@Z| ; CreateBulverdeHcdObject
	IMPORT	|??2@YAPAXI@Z|				; operator new

  00000			 AREA	 |.pdata|, PDATA
|$T39138| DCD	|$LN13@CreateBulv|
	DCD	0x40003302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?CreateBulverdeHcdObject@@YAPAXPAX0PBGPAEK@Z| PROC ; CreateBulverdeHcdObject

; 617  : {

  00000		 |$LN13@CreateBulv|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M39135|
  00008	e1a04003	 mov         r4, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a08000	 mov         r8, r0

; 618  :     CHcd * pobHcd = new CBulverdeOhcd (lpvHcdPddObject, (CPhysMem *)lpvMemoryObject,szRegKey,ioPortBase,dwSysIntr) ;

  00018	e3a00f9a	 mov         r0, #0x9A, 30
  0001c	eb000000	 bl          |??2@YAPAXI@Z|
  00020	e1b05000	 movs        r5, r0
  00024	0a00000c	 beq         |$LN5@CreateBulv|
  00028	e58d4008	 str         r4, [sp, #8]
  0002c	e1a03006	 mov         r3, r6
  00030	e59d4024	 ldr         r4, [sp, #0x24]
  00034	e59de008	 ldr         lr, [sp, #8]
  00038	e1a02007	 mov         r2, r7
  0003c	e1a01008	 mov         r1, r8
  00040	e1a00005	 mov         r0, r5
  00044	e58de000	 str         lr, [sp]
  00048	e58d4004	 str         r4, [sp, #4]
  0004c	eb000000	 bl          |??0COhcd@@QAA@PAXPAVCPhysMem@@PBGRAEK@Z|
  00050	e59f3070	 ldr         r3, [pc, #0x70]
  00054	e5853000	 str         r3, [r5]
  00058	ea000000	 b           |$LN6@CreateBulv|
  0005c		 |$LN5@CreateBulv|
  0005c	e3a05000	 mov         r5, #0
  00060		 |$LN6@CreateBulv|

; 619  :     if ( pobHcd != NULL ) {

  00060	e3550000	 cmp         r5, #0
  00064	0a000013	 beq         |$LN1@CreateBulv|

; 620  : 
; 621  :         ((CBulverdeOhcd*)pobHcd)->LoadHcdCapability(szRegKey);

  00068	e5953000	 ldr         r3, [r5]
  0006c	e1a01006	 mov         r1, r6
  00070	e1a00005	 mov         r0, r5
  00074	e5933060	 ldr         r3, [r3, #0x60]
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3

; 622  : 
; 623  :         if ( !pobHcd->DeviceInitialize( )) {

  00080	e5953000	 ldr         r3, [r5]
  00084	e1a00005	 mov         r0, r5
  00088	e5933004	 ldr         r3, [r3, #4]
  0008c	e1a0e00f	 mov         lr, pc
  00090	e12fff13	 bx          r3
  00094	e3500000	 cmp         r0, #0
  00098	1a000006	 bne         |$LN1@CreateBulv|

; 624  :             delete pobHcd;

  0009c	e5953000	 ldr         r3, [r5]
  000a0	e3a01001	 mov         r1, #1
  000a4	e1a00005	 mov         r0, r5
  000a8	e5933000	 ldr         r3, [r3]
  000ac	e1a0e00f	 mov         lr, pc
  000b0	e12fff13	 bx          r3

; 625  :             pobHcd = NULL;

  000b4	e3a05000	 mov         r5, #0
  000b8		 |$LN1@CreateBulv|

; 626  :         }
; 627  :     }
; 628  : 
; 629  :     return pobHcd;
; 630  : }

  000b8	e1a00005	 mov         r0, r5
  000bc	e28dd00c	 add         sp, sp, #0xC
  000c0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$LN14@CreateBulv|
  000c8		 |$LN15@CreateBulv|
  000c8	00000000	 DCD         |??_7CBulverdeOhcd@@6B@|
  000cc		 |$M39136|

			 ENDP  ; |?CreateBulverdeHcdObject@@YAPAXPAX0PBGPAEK@Z|, CreateBulverdeHcdObject

	EXPORT	|??0CMiniThread@@QAA@KH@Z|		; CMiniThread::CMiniThread
	EXPORT	|??_7CMiniThread@@6B@| [ DATA ]		; CMiniThread::`vftable'
	IMPORT	|CreateThread|
	IMPORT	|_purecall|
; File c:\wince600\public\common\oak\inc\cmthread.h

  00000			 AREA	 |.pdata|, PDATA
|$T39154| DCD	|$LN7@CMiniThrea|
	DCD	0x40001b02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7CMiniThread@@6B@| DCD |_purecall|			; CMiniThread::`vftable'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0CMiniThread@@QAA@KH@Z| PROC	; CMiniThread::CMiniThread

; 29   :     CMiniThread( DWORD dwStackSize = 0, BOOL bSuspended = FALSE )

  00000		 |$LN7@CMiniThrea|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M39151|
  00008	e1b06002	 movs        r6, r2
  0000c	e1a05000	 mov         r5, r0
  00010	e59f3050	 ldr         r3, [pc, #0x50]

; 30   :     {
; 31   :         m_bTerminated = FALSE;

  00014	e3a02000	 mov         r2, #0

; 32   :         m_dwExitCode = ( DWORD ) - 1;

  00018	e5852004	 str         r2, [r5, #4]

; 33   :         m_hThreadHandle = ::CreateThread( NULL,
; 34   :                                           dwStackSize,
; 35   :                                           CMiniThread::ThreadProc,
; 36   :                                           ( LPVOID )this,
; 37   :                                           bSuspended ? CREATE_SUSPENDED : 0,
; 38   :                                           &m_dwThreadId );

  0001c	e59f2040	 ldr         r2, [pc, #0x40]
  00020	e3e00000	 mvn         r0, #0
  00024	13a04004	 movne       r4, #4
  00028	e5853000	 str         r3, [r5]
  0002c	e5850014	 str         r0, [r5, #0x14]
  00030	03a04000	 moveq       r4, #0
  00034	e285e00c	 add         lr, r5, #0xC
  00038	e1a03005	 mov         r3, r5
  0003c	e3a00000	 mov         r0, #0
  00040	e58de004	 str         lr, [sp, #4]
  00044	e58d4000	 str         r4, [sp]
  00048	eb000000	 bl          CreateThread
  0004c	e5850008	 str         r0, [r5, #8]

; 39   :         m_bSuspendFlag = bSuspended;
; 40   :     };

  00050	e1a00005	 mov         r0, r5
  00054	e5856010	 str         r6, [r5, #0x10]
  00058	e28dd008	 add         sp, sp, #8
  0005c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN8@CMiniThrea|
  00064		 |$LN9@CMiniThrea|
  00064	00000000	 DCD         |?ThreadProc@CMiniThread@@CAKPAX@Z|
  00068		 |$LN10@CMiniThrea|
  00068	00000000	 DCD         |??_7CMiniThread@@6B@|
  0006c		 |$M39152|

			 ENDP  ; |??0CMiniThread@@QAA@KH@Z|, CMiniThread::CMiniThread

	EXPORT	|??1CMiniThread@@QAA@XZ|		; CMiniThread::~CMiniThread

  00000			 AREA	 |.pdata|, PDATA
|$T39165| DCD	|$LN5@CMiniThrea@2|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1CMiniThread@@QAA@XZ| PROC		; CMiniThread::~CMiniThread

; 44   :     {

  00000		 |$LN5@CMiniThrea@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39162|
  00004	e1a02000	 mov         r2, r0
  00008	e59f300c	 ldr         r3, [pc, #0xC]

; 45   :         ForceTerminated();

  0000c	e5823000	 str         r3, [r2]
  00010	eb000000	 bl          |?ForceTerminated@CMiniThread@@QAAHXZ|

; 46   :     }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@CMiniThrea@2|
  0001c		 |$LN7@CMiniThrea@2|
  0001c	00000000	 DCD         |??_7CMiniThread@@6B@|
  00020		 |$M39163|

			 ENDP  ; |??1CMiniThread@@QAA@XZ|, CMiniThread::~CMiniThread

	EXPORT	|?ThreadTerminated@CMiniThread@@QAAHK@Z| ; CMiniThread::ThreadTerminated

  00000			 AREA	 |.pdata|, PDATA
|$T39178| DCD	|$LN5@ThreadTerm|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadTerminated@CMiniThread@@QAAHK@Z| PROC ; CMiniThread::ThreadTerminated

; 86   :     {

  00000		 |$LN5@ThreadTerm|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M39175|

; 87   :         m_bTerminated = TRUE;

  00004	e3a03001	 mov         r3, #1
  00008	e5803004	 str         r3, [r0, #4]

; 88   :         return WaitThreadComplete( dwMilliSeconds  );

  0000c	eb000000	 bl          |?WaitThreadComplete@CMiniThread@@QAAHK@Z|

; 89   :     }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M39176|

			 ENDP  ; |?ThreadTerminated@CMiniThread@@QAAHK@Z|, CMiniThread::ThreadTerminated

	EXPORT	|??0SOhcdPdd@@QAA@PBG@Z|		; SOhcdPdd::SOhcdPdd
	EXPORT	|??_7SOhcdPdd@@6B@| [ DATA ]		; SOhcdPdd::`vftable'
	EXPORT	|?ThreadRun@SOhcdPdd@@EAAKXZ|		; SOhcdPdd::ThreadRun
	EXPORT	|?Init@SOhcdPdd@@UAAHXZ|		; SOhcdPdd::Init
	EXPORT	|?InitializeOHCI@SOhcdPdd@@UAAHXZ|	; SOhcdPdd::InitializeOHCI
	IMPORT	|CreateBusAccessHandle|
	IMPORT	|g_dwContext|
	IMPORT	|wcscpy|
	IMPORT	|wcslen|
	IMPORT	|??_ESOhcdPdd@@UAAPAXI@Z|, WEAK |??_GSOhcdPdd@@UAAPAXI@Z| ; SOhcdPdd::`vector deleting destructor', SOhcdPdd::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\hcd\bul_ohci.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T39195| DCD	|$LN9@SOhcdPdd|
	DCD	0x40003601

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7SOhcdPdd@@6B@| DCD |?ThreadRun@SOhcdPdd@@EAAKXZ|	; SOhcdPdd::`vftable'
	DCD	|??_ESOhcdPdd@@UAAPAXI@Z|
	DCD	|?Init@SOhcdPdd@@UAAHXZ|
	DCD	|_purecall|
	DCD	|_purecall|
	DCD	|?InitializeOHCI@SOhcdPdd@@UAAHXZ|
	DCD	|?OHCI_Reset@SOhcdPdd@@MAAHXZ|
	DCD	|?InitPddInterrupts@SOhcdPdd@@MAAHXZ|
	DCD	|?DisablePddInterrupts@SOhcdPdd@@MAAXXZ|
	DCD	|?PowerUp@SOhcdPdd@@UAAXXZ|
	DCD	|?PowerDown@SOhcdPdd@@UAAXXZ|
	DCD	|?InitiatePowerUp@SOhcdPdd@@UAAKXZ|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0SOhcdPdd@@QAA@PBG@Z| PROC		; SOhcdPdd::SOhcdPdd

; 43   : {

  00000		 |$LN9@SOhcdPdd|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M39192|
  00004	e1a07001	 mov         r7, r1
  00008	e1a04000	 mov         r4, r0
  0000c	e1a02007	 mov         r2, r7
  00010	e3a0110a	 mov         r1, #0xA, 2
  00014	e2840018	 add         r0, r4, #0x18
  00018	eb000000	 bl          |??0CRegistryEdit@@QAA@PAUHKEY__@@PBG@Z|
  0001c	e3a02001	 mov         r2, #1
  00020	e3a01000	 mov         r1, #0
  00024	e1a00004	 mov         r0, r4
  00028	eb000000	 bl          |??0CMiniThread@@QAA@KH@Z|
  0002c	e59f30a0	 ldr         r3, [pc, #0xA0]

; 44   :     m_pDCCLKReg = NULL;
; 45   :     m_pDCUSBOHCIReg = NULL;
; 46   :     m_lpvMemoryObject = NULL;
; 47   :     m_pvDmaVirtualAddress = NULL;             // DMA buffers as seen by the CPU
; 48   :     m_dwDamBufferSize = 0;
; 49   :     m_dwSysIntr = MAXDWORD;
; 50   :     m_IsrHandle = NULL;
; 51   :     m_bIsBuiltInDma = TRUE;
; 52   :     m_pobMem = NULL;
; 53   :     m_pobOhcd = NULL;
; 54   :     m_hParentBusHandle =  CreateBusAccessHandle((LPCWSTR)g_dwContext);

  00030	e59f2098	 ldr         r2, [pc, #0x98]
  00034	e3a08000	 mov         r8, #0
  00038	e3a01001	 mov         r1, #1
  0003c	e3e06000	 mvn         r6, #0
  00040	e584801c	 str         r8, [r4, #0x1C]
  00044	e5843000	 str         r3, [r4]
  00048	e5848020	 str         r8, [r4, #0x20]
  0004c	e5848024	 str         r8, [r4, #0x24]
  00050	e5848040	 str         r8, [r4, #0x40]
  00054	e5848044	 str         r8, [r4, #0x44]
  00058	e584604c	 str         r6, [r4, #0x4C]
  0005c	e5848050	 str         r8, [r4, #0x50]
  00060	e5841034	 str         r1, [r4, #0x34]
  00064	e5848048	 str         r8, [r4, #0x48]
  00068	e5848054	 str         r8, [r4, #0x54]
  0006c	e5920000	 ldr         r0, [r2]
  00070	eb000000	 bl          CreateBusAccessHandle
  00074	e584005c	 str         r0, [r4, #0x5C]

; 55   :     m_lpDriverReg = NULL;

  00078	e5848058	 str         r8, [r4, #0x58]

; 56   :     if (lpActiveRegistry) {

  0007c	e3570000	 cmp         r7, #0
  00080	0a00000f	 beq         |$LN1@SOhcdPdd|

; 57   :         DWORD dwLen = _tcslen(lpActiveRegistry);

  00084	e1a00007	 mov         r0, r7
  00088	eb000000	 bl          wcslen
  0008c	e1a05000	 mov         r5, r0

; 58   :         m_lpDriverReg = new TCHAR [ dwLen +1 ];

  00090	e2853001	 add         r3, r5, #1
  00094	e3730106	 cmn         r3, #6, 2
  00098	91a06083	 movls       r6, r3, lsl #1
  0009c	e1a00006	 mov         r0, r6
  000a0	eb000000	 bl          |??2@YAPAXI@Z|
  000a4	e3500000	 cmp         r0, #0
  000a8	e5840058	 str         r0, [r4, #0x58]

; 59   :         if (m_lpDriverReg) {

  000ac	0a000004	 beq         |$LN1@SOhcdPdd|

; 60   :             _tcscpy(m_lpDriverReg,lpActiveRegistry);

  000b0	e1a01007	 mov         r1, r7
  000b4	eb000000	 bl          wcscpy

; 61   :             m_lpDriverReg [ dwLen ] =0;

  000b8	e5943058	 ldr         r3, [r4, #0x58]
  000bc	e0833085	 add         r3, r3, r5, lsl #1
  000c0	e1c380b0	 strh        r8, [r3]
  000c4		 |$LN1@SOhcdPdd|

; 62   :         }
; 63   :     }
; 64   : }

  000c4	e1a00004	 mov         r0, r4
  000c8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN10@SOhcdPdd|
  000d0		 |$LN11@SOhcdPdd|
  000d0	00000000	 DCD         |g_dwContext|
  000d4		 |$LN12@SOhcdPdd|
  000d4	00000000	 DCD         |??_7SOhcdPdd@@6B@|
  000d8		 |$M39193|

			 ENDP  ; |??0SOhcdPdd@@QAA@PBG@Z|, SOhcdPdd::SOhcdPdd

; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\inc\bulverde_usbohci.h

  00000			 AREA	 |.pdata|, PDATA
|$T39207| DCD	|$LN5@ThreadRun|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ThreadRun@SOhcdPdd@@EAAKXZ| PROC	; SOhcdPdd::ThreadRun

; 68   :     virtual DWORD ThreadRun() { return 1; }   // PDD IST

  00000		 |$LN5@ThreadRun|
  00000		 |$M39204|
  00000	e3a00001	 mov         r0, #1
  00004	e12fff1e	 bx          lr
  00008		 |$M39205|

			 ENDP  ; |?ThreadRun@SOhcdPdd@@EAAKXZ|, SOhcdPdd::ThreadRun

	EXPORT	|??1SOhcdPdd@@UAA@XZ|			; SOhcdPdd::~SOhcdPdd
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|??3@YAXPAX@Z|				; operator delete
	IMPORT	|HalFreeCommonBuffer|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|HcdMdd_DestroyMemoryObject|
	IMPORT	|HcdMdd_DestroyHcdObject|
	IMPORT	|FreeIntChainHandler|
; File c:\wince600\public\common\oak\inc\cregedit.h

  00000			 AREA	 |.pdata|, PDATA
|$T39233| DCD	|$LN27@SOhcdPdd@2|
	DCD	0x40005102
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\hcd\bul_ohci.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1SOhcdPdd@@UAA@XZ| PROC		; SOhcdPdd::~SOhcdPdd

; 66   : {

  00000		 |$LN27@SOhcdPdd@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M39230|
  00008	e1a04000	 mov         r4, r0
  0000c	e59f312c	 ldr         r3, [pc, #0x12C]

; 67   :     m_bTerminated=TRUE;

  00010	e3a05001	 mov         r5, #1

; 68   :     ThreadStart();

  00014	e8840028	 stmia       r4, {r3, r5}
  00018	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|

; 69   :     // Signal IST.
; 70   :     ThreadStart();

  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          |?ThreadStart@CMiniThread@@QAAHXZ|

; 71   :     DisablePddInterrupts();

  00024	e5943020	 ldr         r3, [r4, #0x20]
  00028	e3a06000	 mov         r6, #0

; 72   :     ThreadTerminated(1000);

  0002c	e3a01ffa	 mov         r1, #0xFA, 30
  00030	e1a00004	 mov         r0, r4
  00034	e5836068	 str         r6, [r3, #0x68]
  00038	e5845004	 str         r5, [r4, #4]
  0003c	eb000000	 bl          |?WaitThreadComplete@CMiniThread@@QAAHK@Z|

; 73   :     //
; 74   :     if (m_IsrHandle) {

  00040	e5943050	 ldr         r3, [r4, #0x50]
  00044	e3530000	 cmp         r3, #0

; 75   :         FreeIntChainHandler(m_IsrHandle);

  00048	11a00003	 movne       r0, r3
  0004c	1b000000	 blne        FreeIntChainHandler

; 76   :     }
; 77   :     
; 78   :     if ( m_pobOhcd )

  00050	e5943054	 ldr         r3, [r4, #0x54]
  00054	e3530000	 cmp         r3, #0

; 79   :         HcdMdd_DestroyHcdObject( m_pobOhcd );

  00058	11a00003	 movne       r0, r3
  0005c	1b000000	 blne        HcdMdd_DestroyHcdObject

; 80   :     if (m_pobMem)

  00060	e5943048	 ldr         r3, [r4, #0x48]
  00064	e3530000	 cmp         r3, #0

; 81   :         HcdMdd_DestroyMemoryObject(m_pobMem);

  00068	11a00003	 movne       r0, r3
  0006c	1b000000	 blne        HcdMdd_DestroyMemoryObject

; 82   :     
; 83   :     if (m_pvDmaVirtualAddress) {        

  00070	e5943040	 ldr         r3, [r4, #0x40]
  00074	e1b0e003	 movs        lr, r3
  00078	0a00000d	 beq         |$LN6@SOhcdPdd@2|

; 84   :         if (m_bIsBuiltInDma) {

  0007c	e5943034	 ldr         r3, [r4, #0x34]
  00080	e3530000	 cmp         r3, #0
  00084	0a000003	 beq         |$LN7@SOhcdPdd@2|

; 85   :             MmUnmapIoSpace(m_pvDmaVirtualAddress,0);

  00088	e3a01000	 mov         r1, #0
  0008c	e1a0000e	 mov         r0, lr
  00090	eb000000	 bl          MmUnmapIoSpace

; 86   :         }
; 87   :         else {

  00094	ea000006	 b           |$LN6@SOhcdPdd@2|
  00098		 |$LN7@SOhcdPdd@2|

; 88   :             HalFreeCommonBuffer(&m_AdapterObject, m_dwDamBufferSize, m_DmaPhysicalAddr, m_pvDmaVirtualAddress, FALSE);

  00098	e5942038	 ldr         r2, [r4, #0x38]
  0009c	e594303c	 ldr         r3, [r4, #0x3C]
  000a0	e5941044	 ldr         r1, [r4, #0x44]
  000a4	e2840028	 add         r0, r4, #0x28
  000a8	e58d6004	 str         r6, [sp, #4]
  000ac	e58de000	 str         lr, [sp]
  000b0	eb000000	 bl          HalFreeCommonBuffer
  000b4		 |$LN6@SOhcdPdd@2|

; 89   :         }
; 90   :     }
; 91   :     if (m_lpDriverReg)

  000b4	e5943058	 ldr         r3, [r4, #0x58]
  000b8	e3530000	 cmp         r3, #0

; 92   :         delete m_lpDriverReg;

  000bc	11a00003	 movne       r0, r3
  000c0	1b000000	 blne        |??3@YAXPAX@Z|

; 93   :     if (m_pDCCLKReg)

  000c4	e594301c	 ldr         r3, [r4, #0x1C]
  000c8	e3530000	 cmp         r3, #0

; 94   :         MmUnmapIoSpace((PVOID)m_pDCCLKReg,0);

  000cc	1594001c	 ldrne       r0, [r4, #0x1C]
  000d0	13a01000	 movne       r1, #0
  000d4	1b000000	 blne        MmUnmapIoSpace

; 95   :     if (m_pDCUSBOHCIReg)

  000d8	e5943020	 ldr         r3, [r4, #0x20]
  000dc	e3530000	 cmp         r3, #0

; 96   :         MmUnmapIoSpace((PVOID)m_pDCUSBOHCIReg,0);

  000e0	15940020	 ldrne       r0, [r4, #0x20]
  000e4	13a01000	 movne       r1, #0
  000e8	1b000000	 blne        MmUnmapIoSpace

; 97   :     if (m_pvDmaVirtualAddress)

  000ec	e5943040	 ldr         r3, [r4, #0x40]
  000f0	e3530000	 cmp         r3, #0

; 98   :         MmUnmapIoSpace(m_pvDmaVirtualAddress,0);

  000f4	13a01000	 movne       r1, #0
  000f8	11a00003	 movne       r0, r3
  000fc	1b000000	 blne        MmUnmapIoSpace

; 99   :     if (m_hParentBusHandle)

  00100	e594305c	 ldr         r3, [r4, #0x5C]
  00104	e3530000	 cmp         r3, #0

; 100  :         CloseBusAccessHandle(m_hParentBusHandle);

  00108	11a00003	 movne       r0, r3
  0010c	1b000000	 blne        CloseBusAccessHandle

; 101  : 
; 102  : }

  00110	e59f3024	 ldr         r3, [pc, #0x24]
  00114	e1a00004	 mov         r0, r4
  00118	e5843000	 str         r3, [r4]
  0011c	eb000000	 bl          |?ForceTerminated@CMiniThread@@QAAHXZ|
  00120	e5b43018	 ldr         r3, [r4, #0x18]!
  00124	e3530000	 cmp         r3, #0
  00128	11a00003	 movne       r0, r3
  0012c	1b000000	 blne        RegCloseKey
  00130	e28dd008	 add         sp, sp, #8
  00134	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$LN28@SOhcdPdd@2|
  0013c		 |$LN29@SOhcdPdd@2|
  0013c	00000000	 DCD         |??_7CMiniThread@@6B@|
  00140		 |$LN30@SOhcdPdd@2|
  00140	00000000	 DCD         |??_7SOhcdPdd@@6B@|
  00144		 |$M39231|

			 ENDP  ; |??1SOhcdPdd@@UAA@XZ|, SOhcdPdd::~SOhcdPdd

	IMPORT	|MmMapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T39263| DCD	|$LN15@Init|
	DCD	0x40004f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?Init@SOhcdPdd@@UAAHXZ| PROC		; SOhcdPdd::Init

; 104  : {

  00000		 |$LN15@Init|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M39260|
  00004	e1a04000	 mov         r4, r0
  00008	e3a03441	 mov         r3, #0x41, 8

; 105  :     {
; 106  :         PHYSICAL_ADDRESS ioPhysicalBase = { BULVERDE_BASE_REG_PA_CLKMGR, 0};

  0000c	e3830603	 orr         r0, r3, #3, 12

; 107  :         m_pDCCLKReg = (PBULVERDE_CLKMGR_REG)MmMapIoSpace(ioPhysicalBase, sizeof(BULVERDE_CLKMGR_REG),FALSE);

  00010	e3a03000	 mov         r3, #0
  00014	e3a01000	 mov         r1, #0
  00018	e3a02010	 mov         r2, #0x10
  0001c	eb000000	 bl          MmMapIoSpace
  00020	e1a03000	 mov         r3, r0

; 108  :     }
; 109  :     {
; 110  :         PHYSICAL_ADDRESS ioPhysicalBase = { BULVERDE_BASE_REG_PA_USBH, 0};

  00024	e584301c	 str         r3, [r4, #0x1C]

; 111  :         m_pDCUSBOHCIReg = (PBULVERDE_USBOHCI_REG)MmMapIoSpace(ioPhysicalBase, sizeof(BULVERDE_USBOHCI_REG),FALSE);

  00028	e3a03000	 mov         r3, #0
  0002c	e3a00313	 mov         r0, #0x13, 6
  00030	e3a01000	 mov         r1, #0
  00034	e3a02070	 mov         r2, #0x70
  00038	eb000000	 bl          MmMapIoSpace
  0003c	e5840020	 str         r0, [r4, #0x20]

; 112  :     }
; 113  :     if (m_pDCCLKReg && m_pDCUSBOHCIReg && IsKeyOpened()) {

  00040	e594301c	 ldr         r3, [r4, #0x1C]
  00044	e3530000	 cmp         r3, #0
  00048	0a000038	 beq         |$LN1@Init|
  0004c	e5943020	 ldr         r3, [r4, #0x20]
  00050	e3530000	 cmp         r3, #0
  00054	0a000035	 beq         |$LN1@Init|
  00058	e5943018	 ldr         r3, [r4, #0x18]
  0005c	e3530000	 cmp         r3, #0
  00060	0a000032	 beq         |$LN1@Init|

; 114  :         TurnOnUSBHostClocks();

  00064	e594201c	 ldr         r2, [r4, #0x1C]

; 115  :         // Port 1
; 116  :         SetupUSBHostPWR(1);

  00068	e3a01001	 mov         r1, #1
  0006c	e1a00004	 mov         r0, r4
  00070	e5923004	 ldr         r3, [r2, #4]
  00074	e3833b01	 orr         r3, r3, #1, 22
  00078	e5823004	 str         r3, [r2, #4]
  0007c	e5943000	 ldr         r3, [r4]
  00080	e593300c	 ldr         r3, [r3, #0xC]
  00084	e1a0e00f	 mov         lr, pc
  00088	e12fff13	 bx          r3

; 117  :         SetupUSBHostPEN(1);

  0008c	e5943000	 ldr         r3, [r4]
  00090	e3a01001	 mov         r1, #1
  00094	e1a00004	 mov         r0, r4
  00098	e5933010	 ldr         r3, [r3, #0x10]
  0009c	e1a0e00f	 mov         lr, pc
  000a0	e12fff13	 bx          r3

; 118  :         // Port 2
; 119  :         SetupUSBHostPWR(2);

  000a4	e5943000	 ldr         r3, [r4]
  000a8	e3a01002	 mov         r1, #2
  000ac	e1a00004	 mov         r0, r4
  000b0	e593300c	 ldr         r3, [r3, #0xC]
  000b4	e1a0e00f	 mov         lr, pc
  000b8	e12fff13	 bx          r3

; 120  :         SetupUSBHostPEN(2);

  000bc	e5943000	 ldr         r3, [r4]
  000c0	e3a01002	 mov         r1, #2
  000c4	e1a00004	 mov         r0, r4
  000c8	e5933010	 ldr         r3, [r3, #0x10]
  000cc	e1a0e00f	 mov         lr, pc
  000d0	e12fff13	 bx          r3

; 121  :         return (InitPddInterrupts() && OHCI_Reset() && InitializeOHCI());

  000d4	e5943000	 ldr         r3, [r4]
  000d8	e1a00004	 mov         r0, r4
  000dc	e593301c	 ldr         r3, [r3, #0x1C]
  000e0	e1a0e00f	 mov         lr, pc
  000e4	e12fff13	 bx          r3
  000e8	e3500000	 cmp         r0, #0
  000ec	0a00000f	 beq         |$LN1@Init|
  000f0	e5943000	 ldr         r3, [r4]
  000f4	e1a00004	 mov         r0, r4
  000f8	e5933018	 ldr         r3, [r3, #0x18]
  000fc	e1a0e00f	 mov         lr, pc
  00100	e12fff13	 bx          r3
  00104	e3500000	 cmp         r0, #0
  00108	0a000008	 beq         |$LN1@Init|
  0010c	e5943000	 ldr         r3, [r4]
  00110	e1a00004	 mov         r0, r4
  00114	e5933014	 ldr         r3, [r3, #0x14]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff13	 bx          r3
  00120	e3500000	 cmp         r0, #0
  00124	13a00001	 movne       r0, #1

; 124  : }

  00128	18bd4010	 ldmneia     sp!, {r4, lr}
  0012c	112fff1e	 bxne        lr
  00130		 |$LN1@Init|

; 122  :     }
; 123  :     return FALSE;

  00130	e3a00000	 mov         r0, #0

; 124  : }

  00134	e8bd4010	 ldmia       sp!, {r4, lr}
  00138	e12fff1e	 bx          lr
  0013c		 |$M39261|

			 ENDP  ; |?Init@SOhcdPdd@@UAAHXZ|, SOhcdPdd::Init

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@HMBIFFJK@?$AAD?$AAm?$AAa?$AAM?$AAe?$AAn?$AAL?$AAe?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@MOACEBDO@?$AAD?$AAm?$AAa?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|HcdMdd_CreateMemoryObject|
	IMPORT	|HalAllocateCommonBuffer|
	IMPORT	|KernelLibIoControl|
	IMPORT	|BusTransBusAddrToStatic|
	IMPORT	|LoadIntChainHandler|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|
; File c:\wince600\public\common\oak\inc\cregedit.h

  00000			 AREA	 |.pdata|, PDATA
|$T39300| DCD	|$LN30@Initialize|
	DCD	0xc000c402

  00000			 AREA	 |.xdata|, DATA
|$T39296| DCD	0xffffffe4

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@| DCB "P"
	DCB	0x0, "h", 0x0, "y", 0x0, "s", 0x0, "i", 0x0, "c", 0x0, "a"
	DCB	0x0, "l", 0x0, "P", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, "S"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@HMBIFFJK@?$AAD?$AAm?$AAa?$AAM?$AAe?$AAn?$AAL?$AAe?$AAn?$AA?$AA@| DCB "D"
	DCB	0x0, "m", 0x0, "a", 0x0, "M", 0x0, "e", 0x0, "n", 0x0, "L"
	DCB	0x0, "e", 0x0, "n", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@MOACEBDO@?$AAD?$AAm?$AAa?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@| DCB "D"
	DCB	0x0, "m", 0x0, "a", 0x0, "M", 0x0, "e", 0x0, "m", 0x0, "B"
	DCB	0x0, "a", 0x0, "s", 0x0, "e", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\hcd\bul_ohci.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T39296|

  00008		 |?InitializeOHCI@SOhcdPdd@@UAAHXZ| PROC ; SOhcdPdd::InitializeOHCI

; 126  : {

  00008		 |$LN30@Initialize|
  00008	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  0000c	e24ddf53	 sub         sp, sp, #0x53, 30
  00010		 |$M39297|
  00010	e1a05000	 mov         r5, r0
  00014	e59f32f8	 ldr         r3, [pc, #0x2F8]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3148	 str         r3, [sp, #0x148]

; 127  :     PUCHAR ioPortBase = NULL;
; 128  :     DWORD dwAddrLen;
; 129  :     DWORD dwIOSpace;
; 130  :     BOOL InstallIsr = FALSE;
; 131  :     BOOL fResult = FALSE;
; 132  :     LPVOID pobMem = NULL;
; 133  :     LPVOID pobOhcd = NULL;
; 134  :     DWORD PhysAddr;
; 135  :     HKEY hKey=NULL;
; 136  : 
; 137  :     DDKWINDOWINFO dwi;
; 138  :     DDKISRINFO dii;
; 139  : 
; 140  :     // Setup Memory Windows For OHCI MDD code.
; 141  :     dwi.cbSize=sizeof(dwi);
; 142  :     PhysAddr = dwi.memWindows[0].dwBase = BULVERDE_BASE_REG_PA_USBH;
; 143  :     dwAddrLen= dwi.memWindows[0].dwLen = 0x1000;
; 144  :     dwi.dwInterfaceType = Internal;
; 145  :     dwi.dwBusNumber = 0;
; 146  :     dwi.dwNumMemWindows =1;
; 147  :     dwIOSpace = 0;
; 148  :         
; 149  :     dii.cbSize=sizeof(dii);
; 150  :     if (GetIsrInfo(&dii)  != ERROR_SUCCESS) {

  00020	e5953018	 ldr         r3, [r5, #0x18]
  00024	e3a02313	 mov         r2, #0x13, 6
  00028	e3a01000	 mov         r1, #0
  0002c	e3a00f43	 mov         r0, #0x43, 30
  00030	e3530000	 cmp         r3, #0
  00034	e58d2010	 str         r2, [sp, #0x10]
  00038	e58d1018	 str         r1, [sp, #0x18]
  0003c	e58d003c	 str         r0, [sp, #0x3C]
  00040	0a000005	 beq         |$LN23@Initialize|
  00044	e3a02f43	 mov         r2, #0x43, 30
  00048	e28d103c	 add         r1, sp, #0x3C
  0004c	e1a00003	 mov         r0, r3
  00050	e58d203c	 str         r2, [sp, #0x3C]
  00054	eb000000	 bl          DDKReg_GetIsrInfo
  00058	ea000000	 b           |$LN22@Initialize|
  0005c		 |$LN23@Initialize|
  0005c	e3a00001	 mov         r0, #1
  00060		 |$LN22@Initialize|
  00060	e3500000	 cmp         r0, #0

; 151  :         DEBUGMSG(ZONE_ERROR,(TEXT("InitializeOHCI:DDKReg_GetWindowInfo or  DDKReg_GetWindowInfo failed\r\n")));
; 152  :         return FALSE;

  00064	1a0000a1	 bne         |$LN2@Initialize|

; 153  :     }
; 154  :     // Overwrite the item we know.
; 155  :     dii.dwIrq = IRQ_USBOHCI;
; 156  :     m_dwSysIntr = dii.dwSysintr;

  00068	e59d3044	 ldr         r3, [sp, #0x44]

; 157  :     DEBUGMSG(ZONE_INIT,(TEXT("OHCD: Read config from registry: Base Address: 0x%X, Length: 0x%X, I/O Port: %s, SysIntr: 0x%X, Interface Type: %u, Bus Number: %u\r\n"),
; 158  :                     PhysAddr, dwAddrLen, dwIOSpace ? L"YES" : L"NO", dii.dwSysintr, dwi.dwInterfaceType, dwi.dwBusNumber));
; 159  :     
; 160  :     ioPortBase = (PBYTE) PhysAddr;
; 161  :     
; 162  :     if (dii.szIsrDll[0] != 0 && dii.szIsrHandler[0]!=0 && dii.dwIrq<0xff && dii.dwIrq>0 ) {

  0006c	e1dd24b8	 ldrh        r2, [sp, #0x48]
  00070	e3a01003	 mov         r1, #3
  00074	e585304c	 str         r3, [r5, #0x4C]
  00078	e3520000	 cmp         r2, #0
  0007c	e58d1040	 str         r1, [sp, #0x40]
  00080	e3a08000	 mov         r8, #0
  00084	0a000032	 beq         |$LN12@Initialize|
  00088	e1dd3cb8	 ldrh        r3, [sp, #0xC8]
  0008c	e3530000	 cmp         r3, #0
  00090	0a00002f	 beq         |$LN12@Initialize|

; 163  :         // Install ISR handler
; 164  :         m_IsrHandle = LoadIntChainHandler(dii.szIsrDll, dii.szIsrHandler, (BYTE)dii.dwIrq);

  00094	e3a02003	 mov         r2, #3
  00098	e28d10c8	 add         r1, sp, #0xC8
  0009c	e28d0048	 add         r0, sp, #0x48
  000a0	eb000000	 bl          LoadIntChainHandler
  000a4	e3500000	 cmp         r0, #0
  000a8	e5850050	 str         r0, [r5, #0x50]

; 165  : 
; 166  :         if (!m_IsrHandle) {

  000ac	0a000028	 beq         |$LN12@Initialize|

; 167  :             DEBUGMSG(ZONE_ERROR, (L"OHCD: Couldn't install ISR handler\r\n"));
; 168  :         } else {
; 169  :             GIISR_INFO Info;
; 170  :             PHYSICAL_ADDRESS PortAddress = {PhysAddr, 0};

  000b0	e59d3010	 ldr         r3, [sp, #0x10]

; 171  :             
; 172  :             DEBUGMSG(ZONE_INIT, (L"OHCD: Installed ISR handler, Dll = '%s', Handler = '%s', Irq = %d\r\n",
; 173  :                 dii.szIsrDll, dii.szIsrHandler, dii.dwIrq));
; 174  :             
; 175  :             if (!BusTransBusAddrToStatic(m_hParentBusHandle,(INTERFACE_TYPE)dwi.dwInterfaceType, dwi.dwBusNumber, PortAddress, dwAddrLen, &dwIOSpace, (PVOID *)&PhysAddr)) {

  000b4	e595005c	 ldr         r0, [r5, #0x5C]
  000b8	e3a07000	 mov         r7, #0
  000bc	e28de010	 add         lr, sp, #0x10
  000c0	e28d4018	 add         r4, sp, #0x18
  000c4	e3a06a01	 mov         r6, #1, 20
  000c8	e3a02000	 mov         r2, #0
  000cc	e3a01000	 mov         r1, #0
  000d0	e58de00c	 str         lr, [sp, #0xC]
  000d4	e58d4008	 str         r4, [sp, #8]
  000d8	e58d6004	 str         r6, [sp, #4]
  000dc	e58d7000	 str         r7, [sp]
  000e0	eb000000	 bl          BusTransBusAddrToStatic
  000e4	e3500000	 cmp         r0, #0

; 176  :                 DEBUGMSG(ZONE_ERROR, (L"OHCD: Failed TransBusAddrToStatic\r\n"));
; 177  :                 return FALSE;

  000e8	0a000080	 beq         |$LN2@Initialize|

; 178  :             }
; 179  :         
; 180  :             // Set up ISR handler
; 181  :             Info.SysIntr = dii.dwSysintr;
; 182  :             Info.CheckPort = TRUE;
; 183  :             Info.PortIsIO = (dwIOSpace) ? TRUE : FALSE;

  000ec	e59d2018	 ldr         r2, [sp, #0x18]
  000f0	e59d3044	 ldr         r3, [sp, #0x44]

; 184  :             Info.UseMaskReg = TRUE;
; 185  :             Info.PortAddr = PhysAddr + 0x0C;
; 186  :             Info.PortSize = sizeof(DWORD);
; 187  :             Info.MaskAddr = PhysAddr + 0x10;
; 188  :             
; 189  :             if (!KernelLibIoControl(m_IsrHandle, IOCTL_GIISR_INFO, &Info, sizeof(Info), NULL, 0, NULL)) {

  000f4	e5950050	 ldr         r0, [r5, #0x50]
  000f8	e3520000	 cmp         r2, #0
  000fc	e58d301c	 str         r3, [sp, #0x1C]
  00100	13a03001	 movne       r3, #1
  00104	03a03000	 moveq       r3, #0
  00108	e58d3024	 str         r3, [sp, #0x24]
  0010c	e59d3010	 ldr         r3, [sp, #0x10]
  00110	e3a01001	 mov         r1, #1
  00114	e58d1020	 str         r1, [sp, #0x20]
  00118	e283200c	 add         r2, r3, #0xC
  0011c	e2833010	 add         r3, r3, #0x10
  00120	e58d3038	 str         r3, [sp, #0x38]
  00124	e3a0e001	 mov         lr, #1
  00128	e3a04004	 mov         r4, #4
  0012c	e58d202c	 str         r2, [sp, #0x2C]
  00130	e3a03020	 mov         r3, #0x20
  00134	e28d201c	 add         r2, sp, #0x1C
  00138	e3a01c01	 mov         r1, #1, 24
  0013c	e58de028	 str         lr, [sp, #0x28]
  00140	e58d4030	 str         r4, [sp, #0x30]
  00144	e58d8008	 str         r8, [sp, #8]
  00148	e58d8004	 str         r8, [sp, #4]
  0014c	e58d8000	 str         r8, [sp]
  00150	eb000000	 bl          KernelLibIoControl
  00154		 |$LN12@Initialize|

; 190  :                 DEBUGMSG(ZONE_ERROR, (L"OHCD: KernelLibIoControl call failed.\r\n"));
; 191  :             }
; 192  :         }
; 193  :     }
; 194  :     DWORD dwDmaBase = 0;
; 195  :     DWORD dwHPPhysicalMemSize = 0;
; 196  :     if (!GetRegValue(BULVERDE_REG_DMA_BUFFER_PH_ADDR_VAL_NAME, (PBYTE)&dwDmaBase,BULVERDE_REG_DMA_BUFFER_PH_ADDR_VAL_LEN)) {

  00154	e59f11b4	 ldr         r1, [pc, #0x1B4]
  00158	e3a0e000	 mov         lr, #0
  0015c	e3a03004	 mov         r3, #4
  00160	e28d2014	 add         r2, sp, #0x14
  00164	e2850018	 add         r0, r5, #0x18
  00168	e58de014	 str         lr, [sp, #0x14]
  0016c	e3a04000	 mov         r4, #0
  00170	eb000000	 bl          |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z|
  00174	e3500000	 cmp         r0, #0

; 197  :         DEBUGMSG(ZONE_INIT, (TEXT("SOhcdPdd::Init - Cann't get \"%s\" registry value.\r\n"),BULVERDE_REG_DMA_BUFFER_PH_ADDR_VAL_NAME));
; 198  :         dwDmaBase = 0;
; 199  :     }
; 200  :     if (!GetRegValue(BULVERDE_REG_DMA_BUFFER_LENGTH_VAL_NAME, (PBYTE)&m_dwDamBufferSize,BULVERDE_REG_DMA_BUFFER_LENGTH_VAL_LEN)) {

  00178	e59f118c	 ldr         r1, [pc, #0x18C]
  0017c	03a03000	 moveq       r3, #0
  00180	058d3014	 streq       r3, [sp, #0x14]
  00184	e3a03004	 mov         r3, #4
  00188	e2852044	 add         r2, r5, #0x44
  0018c	e2850018	 add         r0, r5, #0x18
  00190	eb000000	 bl          |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z|

; 201  :         DEBUGMSG(ZONE_INIT, (TEXT("SOhcdPdd::Init - Cann't get \"%s\" registry value.\r\n"),BULVERDE_REG_DMA_BUFFER_LENGTH_VAL_NAME));
; 202  :         m_dwDamBufferSize = 0;
; 203  :     }
; 204  :     if (dwDmaBase && m_dwDamBufferSize) {

  00194	e59d1014	 ldr         r1, [sp, #0x14]
  00198	e3500000	 cmp         r0, #0
  0019c	05858044	 streq       r8, [r5, #0x44]
  001a0	e3510000	 cmp         r1, #0
  001a4	0a00000e	 beq         |$LN9@Initialize|
  001a8	e5953044	 ldr         r3, [r5, #0x44]
  001ac	e1b02003	 movs        r2, r3
  001b0	0a00000b	 beq         |$LN9@Initialize|

; 205  :         m_DmaPhysicalAddr.LowPart = dwDmaBase;

  001b4	e5851038	 str         r1, [r5, #0x38]

; 206  :         m_DmaPhysicalAddr.HighPart = 0;
; 207  :         m_pvDmaVirtualAddress = MmMapIoSpace(m_DmaPhysicalAddr,m_dwDamBufferSize, FALSE);

  001b8	e1a00001	 mov         r0, r1
  001bc	e1a01008	 mov         r1, r8
  001c0	e3a03000	 mov         r3, #0
  001c4	e585803c	 str         r8, [r5, #0x3C]
  001c8	eb000000	 bl          MmMapIoSpace

; 208  :         dwHPPhysicalMemSize = m_dwDamBufferSize / 4  ; 

  001cc	e5953044	 ldr         r3, [r5, #0x44]

; 209  :         m_bIsBuiltInDma = TRUE;

  001d0	e3a02001	 mov         r2, #1
  001d4	e5850040	 str         r0, [r5, #0x40]
  001d8	e1a04123	 mov         r4, r3, lsr #2
  001dc	e5852034	 str         r2, [r5, #0x34]

; 210  :     }
; 211  :     else { // we locate DMA buffer from public pool

  001e0	ea00002a	 b           |$LN8@Initialize|
  001e4		 |$LN9@Initialize|

; 212  :         // The PDD can supply a buffer of contiguous physical memory here, or can let the 
; 213  :         // MDD try to allocate the memory from system RAM.  We will use the HalAllocateCommonBuffer()
; 214  :         // API to allocate the memory and bus controller physical addresses and pass this information
; 215  :         // into the MDD.
; 216  :         if (GetRegValue(REG_PHYSICAL_PAGE_SIZE, (PBYTE)&m_dwDamBufferSize, REG_PHYSICAL_PAGE_SIZE_LEN)) {

  001e4	e59f111c	 ldr         r1, [pc, #0x11C]
  001e8	e3a03004	 mov         r3, #4
  001ec	e2852044	 add         r2, r5, #0x44
  001f0	e2850018	 add         r0, r5, #0x18
  001f4	eb000000	 bl          |?GetRegValue@CRegistryEdit@@QAAHPBGPAEK@Z|
  001f8	e3500000	 cmp         r0, #0
  001fc	0a000010	 beq         |$LN7@Initialize|

; 217  :             dwHPPhysicalMemSize = m_dwDamBufferSize/4;
; 218  :             m_dwDamBufferSize = (m_dwDamBufferSize+ PAGE_SIZE -1) & ~(PAGE_SIZE -1);

  00200	e3e03b0d	 mvn         r3, #0xD, 22
  00204	e223e0fb	 eor         lr, r3, #0xFB
  00208	e59e2000	 ldr         r2, [lr]
  0020c	e5950044	 ldr         r0, [r5, #0x44]
  00210	e1a03002	 mov         r3, r2
  00214	e2431001	 sub         r1, r3, #1
  00218	e0803002	 add         r3, r0, r2
  0021c	e2433001	 sub         r3, r3, #1
  00220	e1c33001	 bic         r3, r3, r1
  00224	e5853044	 str         r3, [r5, #0x44]

; 219  :             // Align with page size.        
; 220  :             dwHPPhysicalMemSize = ((dwHPPhysicalMemSize +  PAGE_SIZE -1) & ~(PAGE_SIZE -1));

  00228	e59e3000	 ldr         r3, [lr]
  0022c	e1a02003	 mov         r2, r3
  00230	e0833120	 add         r3, r3, r0, lsr #2
  00234	e2433001	 sub         r3, r3, #1
  00238	e2422001	 sub         r2, r2, #1
  0023c	e1c34002	 bic         r4, r3, r2

; 221  :         }
; 222  :         else 

  00240	ea000000	 b           |$LN6@Initialize|
  00244		 |$LN7@Initialize|

; 223  :             m_dwDamBufferSize=0;

  00244	e5858044	 str         r8, [r5, #0x44]
  00248		 |$LN6@Initialize|

; 224  :         
; 225  :         if (m_dwDamBufferSize<gcTotalAvailablePhysicalMemory) { // Setup Minimun requirement.

  00248	e5953044	 ldr         r3, [r5, #0x44]

; 226  :             m_dwDamBufferSize = gcTotalAvailablePhysicalMemory;
; 227  :             dwHPPhysicalMemSize = gcHighPriorityPhysicalMemory;
; 228  :         }
; 229  : 
; 230  :         m_AdapterObject.ObjectSize = sizeof(DMA_ADAPTER_OBJECT);
; 231  :         m_AdapterObject.InterfaceType = Internal;
; 232  :         m_AdapterObject.BusNumber = 0 ;
; 233  :         if ((m_pvDmaVirtualAddress = HalAllocateCommonBuffer(&m_AdapterObject, m_dwDamBufferSize, &m_DmaPhysicalAddr, FALSE)) == NULL) {

  0024c	e3a0e00c	 mov         lr, #0xC
  00250	e2852038	 add         r2, r5, #0x38
  00254	e3530801	 cmp         r3, #1, 16
  00258	33a03801	 movcc       r3, #1, 16
  0025c	35853044	 strcc       r3, [r5, #0x44]
  00260	e5951044	 ldr         r1, [r5, #0x44]
  00264	e3a03000	 mov         r3, #0
  00268	e2850028	 add         r0, r5, #0x28
  0026c	33a04901	 movcc       r4, #1, 18
  00270	e1c5e2b8	 strh        lr, [r5, #0x28]
  00274	e585802c	 str         r8, [r5, #0x2C]
  00278	e5858030	 str         r8, [r5, #0x30]
  0027c	eb000000	 bl          HalAllocateCommonBuffer
  00280	e3500000	 cmp         r0, #0
  00284	e5850040	 str         r0, [r5, #0x40]

; 234  :             DEBUGMSG(ZONE_INIT, (TEXT("SOhcdPdd::InitializeOHCI() - HalAllocateCommonBuffer return FALSE!!!\r\n.\r\n")));
; 235  :             return FALSE;

  00288	0a000018	 beq         |$LN2@Initialize|

; 236  :         }
; 237  :         m_bIsBuiltInDma = FALSE;

  0028c	e5858034	 str         r8, [r5, #0x34]
  00290		 |$LN8@Initialize|

; 238  :     }
; 239  :     if (m_pvDmaVirtualAddress == NULL || 
; 240  :             !(m_pobMem = HcdMdd_CreateMemoryObject(m_dwDamBufferSize, dwHPPhysicalMemSize, (PUCHAR) m_pvDmaVirtualAddress, (PUCHAR) m_DmaPhysicalAddr.LowPart))) {

  00290	e5953040	 ldr         r3, [r5, #0x40]
  00294	e1b02003	 movs        r2, r3
  00298	0a000014	 beq         |$LN2@Initialize|
  0029c	e5953038	 ldr         r3, [r5, #0x38]
  002a0	e5950044	 ldr         r0, [r5, #0x44]
  002a4	e1a01004	 mov         r1, r4
  002a8	eb000000	 bl          HcdMdd_CreateMemoryObject
  002ac	e3500000	 cmp         r0, #0
  002b0	e5850048	 str         r0, [r5, #0x48]
  002b4	0a00000d	 beq         |$LN2@Initialize|

; 243  :     }
; 244  : 
; 245  :     if (!( m_pobOhcd  = CreateBulverdeHcdObject(this, m_pobMem, m_lpDriverReg, (PUCHAR)m_pDCUSBOHCIReg, m_dwSysIntr))) {

  002b8	e595e04c	 ldr         lr, [r5, #0x4C]
  002bc	e5953020	 ldr         r3, [r5, #0x20]
  002c0	e5952058	 ldr         r2, [r5, #0x58]
  002c4	e1a01000	 mov         r1, r0
  002c8	e1a00005	 mov         r0, r5
  002cc	e58de000	 str         lr, [sp]
  002d0	eb000000	 bl          |?CreateBulverdeHcdObject@@YAPAXPAX0PBGPAEK@Z|
  002d4	e3500000	 cmp         r0, #0
  002d8	e5850054	 str         r0, [r5, #0x54]

; 246  :         DEBUGMSG(ZONE_INIT, (TEXT("SOhcdPdd::InitializeOHCI() - Cann't CreateHcdObject!!!\r\n.\r\n")));
; 247  :         return FALSE;

  002dc	e59d0148	 ldr         r0, [sp, #0x148]
  002e0	0a000003	 beq         |$LN27@Initialize|

; 248  :     }
; 249  : 
; 250  :     return TRUE;

  002e4	eb000000	 bl          __security_check_cookie
  002e8	e3a00001	 mov         r0, #1
  002ec	ea000002	 b           |$LN18@Initialize|
  002f0		 |$LN2@Initialize|

; 241  :         DEBUGMSG(ZONE_INIT, (TEXT("SOhcdPdd::InitializeOHCI() - Cann't CreateMemoryObject!!!\r\n.\r\n")));
; 242  :         return FALSE;

  002f0	e59d0148	 ldr         r0, [sp, #0x148]
  002f4		 |$LN27@Initialize|
  002f4	eb000000	 bl          __security_check_cookie
  002f8	e3a00000	 mov         r0, #0
  002fc		 |$LN18@Initialize|

; 251  : }

  002fc	e28ddf53	 add         sp, sp, #0x53, 30
  00300	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00304	e12fff1e	 bx          lr
  00308		 |$LN31@Initialize|
  00308		 |$LN32@Initialize|
  00308	00000000	 DCD         |??_C@_1CC@NPEFILDH@?$AAP?$AAh?$AAy?$AAs?$AAi?$AAc?$AAa?$AAl?$AAP?$AAa?$AAg?$AAe?$AAS?$AAi?$AAz?$AAe?$AA?$AA@|
  0030c		 |$LN33@Initialize|
  0030c	00000000	 DCD         |??_C@_1BE@HMBIFFJK@?$AAD?$AAm?$AAa?$AAM?$AAe?$AAn?$AAL?$AAe?$AAn?$AA?$AA@|
  00310		 |$LN34@Initialize|
  00310	00000000	 DCD         |??_C@_1BG@MOACEBDO@?$AAD?$AAm?$AAa?$AAM?$AAe?$AAm?$AAB?$AAa?$AAs?$AAe?$AA?$AA@|
  00314		 |$LN35@Initialize|
  00314	00000000	 DCD         |__security_cookie|
  00318		 |$M39298|

			 ENDP  ; |?InitializeOHCI@SOhcdPdd@@UAAHXZ|, SOhcdPdd::InitializeOHCI


  00000			 AREA	 |.pdata|, PDATA
|$T39320| DCD	|$LN8@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GCBulverdeOhcd@@UAAPAXI@Z| PROC	; CBulverdeOhcd::`scalar deleting destructor'
  00000		 |$LN8@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39317|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1COhcd@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M39318|

			 ENDP  ; |??_GCBulverdeOhcd@@UAAPAXI@Z|, CBulverdeOhcd::`scalar deleting destructor'


  00000			 AREA	 |.pdata|, PDATA
|$T39331| DCD	|$LN6@scalar@2|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GSOhcdPdd@@UAAPAXI@Z| PROC		; SOhcdPdd::`scalar deleting destructor'
  00000		 |$LN6@scalar@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M39328|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1SOhcdPdd@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M39329|

			 ENDP  ; |??_GSOhcdPdd@@UAAPAXI@Z|, SOhcdPdd::`scalar deleting destructor'

	END
