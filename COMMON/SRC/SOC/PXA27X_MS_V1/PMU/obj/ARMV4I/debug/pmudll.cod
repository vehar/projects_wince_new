; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\PMU\pmudll.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?PVTuneInterrupt@@3PAXA| [ DATA ]	; PVTuneInterrupt
	EXPORT	|?PVTuneReleasePMU@@3PAXA| [ DATA ]	; PVTuneReleasePMU
	EXPORT	|?PVTuneReleaseCCF@@3PAXA| [ DATA ]	; PVTuneReleaseCCF

  00000			 AREA	 |.bss|, NOINIT
|trySemaphore| % 0x4
|semHandle| %	0x4
|?PVTuneInterrupt@@3PAXA| % 0x4				; PVTuneInterrupt
|?PVTuneReleasePMU@@3PAXA| % 0x4			; PVTuneReleasePMU
|?PVTuneReleaseCCF@@3PAXA| % 0x4			; PVTuneReleaseCCF
	EXPORT	|??_C@_1BM@CAGEFPEO@?$AAX?$AAS?$AAC?$AA_?$AAP?$AAM?$AAU?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|AllocatePMU|
	IMPORT	|malloc|
	IMPORT	|KernelIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|GetLastError|
	IMPORT	|CreateSemaphoreW|

  00000			 AREA	 |.pdata|, PDATA
|$T33346| DCD	|$LN8@AllocatePM|
	DCD	0x40005804
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\pmu\pmudll.cpp

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@CAGEFPEO@?$AAX?$AAS?$AAC?$AA_?$AAP?$AAM?$AAU?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$AA@| DCB "X"
	DCB	0x0, "S", 0x0, "C", 0x0, "_", 0x0, "P", 0x0, "M", 0x0, "U"
	DCB	0x0, "_", 0x0, "A", 0x0, "L", 0x0, "L", 0x0, "O", 0x0, "C"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |AllocatePMU| PROC

; 71   : {

  00000		 |$LN8@AllocatePM|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd048	 sub         sp, sp, #0x48
  00010		 |$M33343|

; 72   : 
; 73   :     PMUHandle   handle = 0;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3028	 str         r3, [sp, #0x28]

; 74   :     PMURegInfo  PMURegBuffer;
; 75   :     BOOL        rtnvalue = FALSE;

  00018	e3a03000	 mov         r3, #0
  0001c	e58d3008	 str         r3, [sp, #8]

; 76   :     LPCTSTR     semName = TEXT("XSC_PMU_ALLOC");

  00020	e59f3134	 ldr         r3, [pc, #0x134]
  00024	e58d3024	 str         r3, [sp, #0x24]

; 77   : 
; 78   :     // Allocate a system resource, initialize to unsignalled state.
; 79   :     // If it's already allocated, return NULL handle.
; 80   :     //
; 81   :     trySemaphore = CreateSemaphore (NULL, 1, 1, semName);

  00028	e59d3024	 ldr         r3, [sp, #0x24]
  0002c	e3a02001	 mov         r2, #1
  00030	e3a01001	 mov         r1, #1
  00034	e3a00000	 mov         r0, #0
  00038	eb000000	 bl          CreateSemaphoreW
  0003c	e58d0038	 str         r0, [sp, #0x38]
  00040	e59d2038	 ldr         r2, [sp, #0x38]
  00044	e59f310c	 ldr         r3, [pc, #0x10C]
  00048	e5832000	 str         r2, [r3]

; 82   :     if (trySemaphore == NULL) 

  0004c	e59f3104	 ldr         r3, [pc, #0x104]
  00050	e5933000	 ldr         r3, [r3]
  00054	e3530000	 cmp         r3, #0
  00058	1a000002	 bne         |$LN3@AllocatePM|

; 83   :     {
; 84   :         return 0;

  0005c	e3a03000	 mov         r3, #0
  00060	e58d302c	 str         r3, [sp, #0x2C]
  00064	ea000032	 b           |$LN4@AllocatePM|
  00068		 |$LN3@AllocatePM|

; 85   :     }
; 86   : 
; 87   :     if (GetLastError() == ERROR_ALREADY_EXISTS)

  00068	eb000000	 bl          GetLastError
  0006c	e58d003c	 str         r0, [sp, #0x3C]
  00070	e59d303c	 ldr         r3, [sp, #0x3C]
  00074	e35300b7	 cmp         r3, #0xB7
  00078	1a000005	 bne         |$LN2@AllocatePM|

; 88   :     {
; 89   :         //
; 90   :         // Invalidate this handle
; 91   :         //
; 92   :         CloseHandle(trySemaphore);

  0007c	e59f30d4	 ldr         r3, [pc, #0xD4]
  00080	e5930000	 ldr         r0, [r3]
  00084	eb000000	 bl          CloseHandle

; 93   :         return 0;

  00088	e3a03000	 mov         r3, #0
  0008c	e58d302c	 str         r3, [sp, #0x2C]
  00090	ea000027	 b           |$LN4@AllocatePM|
  00094		 |$LN2@AllocatePM|

; 94   :     }
; 95   : 
; 96   :         semHandle = trySemaphore;

  00094	e59f30bc	 ldr         r3, [pc, #0xBC]
  00098	e5932000	 ldr         r2, [r3]
  0009c	e59f30b0	 ldr         r3, [pc, #0xB0]
  000a0	e5832000	 str         r2, [r3]

; 97   : 
; 98   :         // Register callback with kernel
; 99   :         // NOTE: Intel no longer uses the pCallBack parameter that was stored in 
; 100  :         // the PVTuneReleasePMU variable, it is understood to be NULL.
; 101  :         PMURegBuffer.subcode = PMU_ALLOCATE;

  000a4	e3a03007	 mov         r3, #7
  000a8	e58d300c	 str         r3, [sp, #0xC]

; 102  :         PMURegBuffer.pCallback = PVTuneReleasePMU;

  000ac	e59f309c	 ldr         r3, [pc, #0x9C]
  000b0	e5933000	 ldr         r3, [r3]
  000b4	e58d3018	 str         r3, [sp, #0x18]

; 103  : 
; 104  :         rtnvalue = 
; 105  :                 KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 106  :                                  (LPVOID)NULL, 0, (LPDWORD)NULL);

  000b8	e3a03000	 mov         r3, #0
  000bc	e58d3004	 str         r3, [sp, #4]
  000c0	e3a03000	 mov         r3, #0
  000c4	e58d3000	 str         r3, [sp]
  000c8	e3a03000	 mov         r3, #0
  000cc	e3a02018	 mov         r2, #0x18
  000d0	e28d100c	 add         r1, sp, #0xC
  000d4	e59f0070	 ldr         r0, [pc, #0x70]
  000d8	eb000000	 bl          KernelIoControl
  000dc	e58d0040	 str         r0, [sp, #0x40]
  000e0	e59d3040	 ldr         r3, [sp, #0x40]
  000e4	e58d3008	 str         r3, [sp, #8]

; 107  :         if (rtnvalue == FALSE)

  000e8	e59d3008	 ldr         r3, [sp, #8]
  000ec	e3530000	 cmp         r3, #0
  000f0	1a000002	 bne         |$LN1@AllocatePM|

; 108  :         {
; 109  :             return 0;

  000f4	e3a03000	 mov         r3, #0
  000f8	e58d302c	 str         r3, [sp, #0x2C]
  000fc	ea00000c	 b           |$LN4@AllocatePM|
  00100		 |$LN1@AllocatePM|

; 110  :         }
; 111  : 
; 112  :         // Null other callbacks
; 113  :         //
; 114  :         PVTuneInterrupt = NULL;

  00100	e59f2040	 ldr         r2, [pc, #0x40]
  00104	e3a03000	 mov         r3, #0
  00108	e5823000	 str         r3, [r2]

; 115  :         PVTuneReleaseCCF = NULL;

  0010c	e59f2030	 ldr         r2, [pc, #0x30]
  00110	e3a03000	 mov         r3, #0
  00114	e5823000	 str         r3, [r2]

; 116  : 
; 117  :         // Allocate a PMUHandle
; 118  :         //
; 119  :         handle = (PMUHandle) malloc (sizeof (PMUHResource));

  00118	e3a00004	 mov         r0, #4
  0011c	eb000000	 bl          malloc
  00120	e58d0044	 str         r0, [sp, #0x44]
  00124	e59d3044	 ldr         r3, [sp, #0x44]
  00128	e58d3028	 str         r3, [sp, #0x28]

; 120  : 
; 121  :     return handle;

  0012c	e59d3028	 ldr         r3, [sp, #0x28]
  00130	e58d302c	 str         r3, [sp, #0x2C]
  00134		 |$LN4@AllocatePM|

; 122  : 
; 123  : }

  00134	e59d002c	 ldr         r0, [sp, #0x2C]
  00138	e28dd048	 add         sp, sp, #0x48
  0013c	e89d6000	 ldmia       sp, {sp, lr}
  00140	e12fff1e	 bx          lr
  00144		 |$LN9@AllocatePM|
  00144		 |$LN10@AllocatePM|
  00144	00000000	 DCD         |?PVTuneReleaseCCF@@3PAXA|
  00148		 |$LN11@AllocatePM|
  00148	00000000	 DCD         |?PVTuneInterrupt@@3PAXA|
  0014c		 |$LN12@AllocatePM|
  0014c	01013e80	 DCD         0x1013e80
  00150		 |$LN13@AllocatePM|
  00150	00000000	 DCD         |?PVTuneReleasePMU@@3PAXA|
  00154		 |$LN14@AllocatePM|
  00154	00000000	 DCD         |semHandle|
  00158		 |$LN15@AllocatePM|
  00158	00000000	 DCD         |trySemaphore|
  0015c		 |$LN16@AllocatePM|
  0015c	00000000	 DCD         |??_C@_1BM@CAGEFPEO@?$AAX?$AAS?$AAC?$AA_?$AAP?$AAM?$AAU?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$AA@|
  00160		 |$M33344|

			 ENDP  ; |AllocatePMU|

	EXPORT	|UnlockAndRestoreCoreClockFrequency|
	EXPORT	|RemovePMUInterruptCallback|
	EXPORT	|ReleasePMUResources|
	IMPORT	|free|
	IMPORT	|ReleaseSemaphore|

  00008			 AREA	 |.pdata|, PDATA
|$T33362| DCD	|$LN6@ReleasePMU|
	DCD	0x40003604
; Function compile flags: /Odtp

  00160			 AREA	 |.text|, CODE, ARM

  00160		 |ReleasePMUResources| PROC

; 134  : {   

  00160		 |$LN6@ReleasePMU|
  00160	e1a0c00d	 mov         r12, sp
  00164	e92d0001	 stmdb       sp!, {r0}
  00168	e92d5000	 stmdb       sp!, {r12, lr}
  0016c	e24dd034	 sub         sp, sp, #0x34
  00170		 |$M33359|

; 135  :     PMURegInfo  PMURegBuffer;
; 136  :     BOOL        rtnvalue = FALSE;

  00170	e3a03000	 mov         r3, #0
  00174	e58d3008	 str         r3, [sp, #8]

; 137  : 
; 138  :     if (handle == 0)

  00178	e59d303c	 ldr         r3, [sp, #0x3C]
  0017c	e3530000	 cmp         r3, #0
  00180	1a000002	 bne         |$LN1@ReleasePMU|

; 139  :     {
; 140  :         return FALSE;

  00184	e3a03000	 mov         r3, #0
  00188	e58d3024	 str         r3, [sp, #0x24]
  0018c	ea000022	 b           |$LN2@ReleasePMU|
  00190		 |$LN1@ReleasePMU|

; 141  :     }
; 142  : 
; 143  :     //
; 144  :     // Remove Interrupt callback
; 145  :     //
; 146  :     RemovePMUInterruptCallback(handle);

  00190	e59d003c	 ldr         r0, [sp, #0x3C]
  00194	eb000000	 bl          RemovePMUInterruptCallback

; 147  : 
; 148  :     //
; 149  :     // Remove lock, if any, and release CCF callback
; 150  :     //
; 151  :     UnlockAndRestoreCoreClockFrequency(handle);

  00198	e59d003c	 ldr         r0, [sp, #0x3C]
  0019c	eb000000	 bl          UnlockAndRestoreCoreClockFrequency

; 152  : 
; 153  :     //
; 154  :     // Null local copy
; 155  :     //
; 156  :     PVTuneReleasePMU = NULL;

  001a0	e59f208c	 ldr         r2, [pc, #0x8C]
  001a4	e3a03000	 mov         r3, #0
  001a8	e5823000	 str         r3, [r2]

; 157  : 
; 158  :     //
; 159  :     // Unregister ReleasePMU callback in kernel
; 160  :     //
; 161  :     PMURegBuffer.subcode = PMU_RELEASE;

  001ac	e3a03008	 mov         r3, #8
  001b0	e58d300c	 str         r3, [sp, #0xC]

; 162  :     rtnvalue = 
; 163  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 164  :                              (LPVOID)NULL, 0, (LPDWORD)NULL);

  001b4	e3a03000	 mov         r3, #0
  001b8	e58d3004	 str         r3, [sp, #4]
  001bc	e3a03000	 mov         r3, #0
  001c0	e58d3000	 str         r3, [sp]
  001c4	e3a03000	 mov         r3, #0
  001c8	e3a02018	 mov         r2, #0x18
  001cc	e28d100c	 add         r1, sp, #0xC
  001d0	e59f0058	 ldr         r0, [pc, #0x58]
  001d4	eb000000	 bl          KernelIoControl
  001d8	e58d0030	 str         r0, [sp, #0x30]
  001dc	e59d3030	 ldr         r3, [sp, #0x30]
  001e0	e58d3008	 str         r3, [sp, #8]

; 165  : 
; 166  :     //
; 167  :     // Release resource, NULL handle
; 168  :     //
; 169  :     ReleaseSemaphore(semHandle, 1, NULL);

  001e4	e3a02000	 mov         r2, #0
  001e8	e3a01001	 mov         r1, #1
  001ec	e59f3038	 ldr         r3, [pc, #0x38]
  001f0	e5930000	 ldr         r0, [r3]
  001f4	eb000000	 bl          ReleaseSemaphore

; 170  :     CloseHandle(semHandle);

  001f8	e59f302c	 ldr         r3, [pc, #0x2C]
  001fc	e5930000	 ldr         r0, [r3]
  00200	eb000000	 bl          CloseHandle

; 171  :     free ((PMUHResource*) handle);

  00204	e59d003c	 ldr         r0, [sp, #0x3C]
  00208	eb000000	 bl          free

; 172  :     handle = 0;

  0020c	e3a03000	 mov         r3, #0
  00210	e58d303c	 str         r3, [sp, #0x3C]

; 173  : 
; 174  :     return rtnvalue;

  00214	e59d3008	 ldr         r3, [sp, #8]
  00218	e58d3024	 str         r3, [sp, #0x24]
  0021c		 |$LN2@ReleasePMU|

; 175  : }

  0021c	e59d0024	 ldr         r0, [sp, #0x24]
  00220	e28dd034	 add         sp, sp, #0x34
  00224	e89d6000	 ldmia       sp, {sp, lr}
  00228	e12fff1e	 bx          lr
  0022c		 |$LN7@ReleasePMU|
  0022c		 |$LN8@ReleasePMU|
  0022c	00000000	 DCD         |semHandle|
  00230		 |$LN9@ReleasePMU|
  00230	01013e80	 DCD         0x1013e80
  00234		 |$LN10@ReleasePMU|
  00234	00000000	 DCD         |?PVTuneReleasePMU@@3PAXA|
  00238		 |$M33360|

			 ENDP  ; |ReleasePMUResources|


  00010			 AREA	 |.pdata|, PDATA
|$T33374| DCD	|$LN8@RemovePMUI|
	DCD	0x40003204
; Function compile flags: /Odtp

  00238			 AREA	 |.text|, CODE, ARM

  00238		 |RemovePMUInterruptCallback| PROC

; 186  : {

  00238		 |$LN8@RemovePMUI|
  00238	e1a0c00d	 mov         r12, sp
  0023c	e92d0001	 stmdb       sp!, {r0}
  00240	e92d5000	 stmdb       sp!, {r12, lr}
  00244	e24dd034	 sub         sp, sp, #0x34
  00248		 |$M33371|

; 187  :     PMURegInfo      PMURegBuffer;
; 188  :     BOOL            rtnvalue = FALSE;

  00248	e3a03000	 mov         r3, #0
  0024c	e58d3008	 str         r3, [sp, #8]

; 189  : 
; 190  :     if (handle == 0)

  00250	e59d303c	 ldr         r3, [sp, #0x3C]
  00254	e3530000	 cmp         r3, #0
  00258	1a000002	 bne         |$LN3@RemovePMUI|

; 191  :     {
; 192  :         return INVALIDHANDLE_PMU;

  0025c	e3a03001	 mov         r3, #1
  00260	e58d3024	 str         r3, [sp, #0x24]
  00264	ea00001f	 b           |$LN4@RemovePMUI|
  00268		 |$LN3@RemovePMUI|

; 193  :     }
; 194  : 
; 195  :     //
; 196  :     // Remove the interrupt callback
; 197  :     //
; 198  :     if (PVTuneInterrupt == NULL)

  00268	e59f308c	 ldr         r3, [pc, #0x8C]
  0026c	e5933000	 ldr         r3, [r3]
  00270	e3530000	 cmp         r3, #0
  00274	1a000002	 bne         |$LN2@RemovePMUI|

; 199  :     {
; 200  :         return NOCALLBACK_PMU;

  00278	e3a03003	 mov         r3, #3
  0027c	e58d3024	 str         r3, [sp, #0x24]
  00280	ea000018	 b           |$LN4@RemovePMUI|
  00284		 |$LN2@RemovePMUI|

; 201  :     }
; 202  : 
; 203  :     PVTuneInterrupt = NULL;

  00284	e59f2070	 ldr         r2, [pc, #0x70]
  00288	e3a03000	 mov         r3, #0
  0028c	e5823000	 str         r3, [r2]

; 204  : 
; 205  :     //
; 206  :     // Disable the interrupt (IRQ for now...) and 
; 207  :     // unregister the callback in the kernel
; 208  :     //
; 209  :     PMURegBuffer.subcode = PMU_DISABLE_IRQ;

  00290	e3a03003	 mov         r3, #3
  00294	e58d300c	 str         r3, [sp, #0xC]

; 210  :     rtnvalue = 
; 211  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 212  :                              (LPVOID)NULL, 0, (LPDWORD)NULL);

  00298	e3a03000	 mov         r3, #0
  0029c	e58d3004	 str         r3, [sp, #4]
  002a0	e3a03000	 mov         r3, #0
  002a4	e58d3000	 str         r3, [sp]
  002a8	e3a03000	 mov         r3, #0
  002ac	e3a02018	 mov         r2, #0x18
  002b0	e28d100c	 add         r1, sp, #0xC
  002b4	e59f003c	 ldr         r0, [pc, #0x3C]
  002b8	eb000000	 bl          KernelIoControl
  002bc	e58d0030	 str         r0, [sp, #0x30]
  002c0	e59d3030	 ldr         r3, [sp, #0x30]
  002c4	e58d3008	 str         r3, [sp, #8]

; 213  : 
; 214  :     if (rtnvalue == FALSE)

  002c8	e59d3008	 ldr         r3, [sp, #8]
  002cc	e3530000	 cmp         r3, #0
  002d0	1a000002	 bne         |$LN1@RemovePMUI|

; 215  :     {
; 216  :         return KERNELIOFAILED_PMU;

  002d4	e3a03004	 mov         r3, #4
  002d8	e58d3024	 str         r3, [sp, #0x24]
  002dc	ea000001	 b           |$LN4@RemovePMUI|
  002e0		 |$LN1@RemovePMUI|

; 217  :     }
; 218  : 
; 219  :     return SUCCESS_PMU;

  002e0	e3a03000	 mov         r3, #0
  002e4	e58d3024	 str         r3, [sp, #0x24]
  002e8		 |$LN4@RemovePMUI|

; 220  : 
; 221  : }

  002e8	e59d0024	 ldr         r0, [sp, #0x24]
  002ec	e28dd034	 add         sp, sp, #0x34
  002f0	e89d6000	 ldmia       sp, {sp, lr}
  002f4	e12fff1e	 bx          lr
  002f8		 |$LN9@RemovePMUI|
  002f8		 |$LN10@RemovePMUI|
  002f8	01013e80	 DCD         0x1013e80
  002fc		 |$LN11@RemovePMUI|
  002fc	00000000	 DCD         |?PVTuneInterrupt@@3PAXA|
  00300		 |$M33372|

			 ENDP  ; |RemovePMUInterruptCallback|

	EXPORT	|GetNumberOfPossibleCoreClockFrequencies|

  00018			 AREA	 |.pdata|, PDATA
|$T33383| DCD	|$LN5@GetNumberO|
	DCD	0x40000601
; Function compile flags: /Odtp

  00300			 AREA	 |.text|, CODE, ARM

  00300		 |GetNumberOfPossibleCoreClockFrequencies| PROC

; 232  : {

  00300		 |$LN5@GetNumberO|
  00300	e24dd004	 sub         sp, sp, #4
  00304		 |$M33380|

; 233  :     return MAXFREQS;

  00304	e3a03008	 mov         r3, #8
  00308	e58d3000	 str         r3, [sp]

; 234  : }

  0030c	e59d0000	 ldr         r0, [sp]
  00310	e28dd004	 add         sp, sp, #4
  00314	e12fff1e	 bx          lr
  00318		 |$M33381|

			 ENDP  ; |GetNumberOfPossibleCoreClockFrequencies|

	EXPORT	|GetPossibleCoreClockFrequencies|

  00020			 AREA	 |.pdata|, PDATA
|$T33389| DCD	|$LN9@GetPossibl|
	DCD	0x40002804

  00000			 AREA	 |.data|, DATA
|?FreqArray@?1??GetPossibleCoreClockFrequencies@@9@4PAKA| DCD 0x19640 ; `GetPossibleCoreClockFrequencies'::`2'::FreqArray
	DCD	0x1c908
	DCD	0x1fbd0
	DCD	0x22e98
	DCD	0x26160
	DCD	0x29428
	DCD	0x2c6f0
	DCD	0x2f9b8
; Function compile flags: /Odtp

  00318			 AREA	 |.text|, CODE, ARM

  00318		 |GetPossibleCoreClockFrequencies| PROC

; 249  : {

  00318		 |$LN9@GetPossibl|
  00318	e1a0c00d	 mov         r12, sp
  0031c	e92d0003	 stmdb       sp!, {r0, r1}
  00320	e92d5000	 stmdb       sp!, {r12, lr}
  00324	e24dd008	 sub         sp, sp, #8
  00328		 |$M33386|

; 250  : 
; 251  : /*
; 252  :  * Restrict frequencies between the same LCD Frequency
; 253  :  * (K) range until LCD controller can be disabled
; 254  :  *
; 255  :  *    static unsigned long FreqArray[MAXFREQS] =
; 256  :  *      {26000, 39000, 52000, 65000, 78000,
; 257  :  *         91000, 104000, 117000, 130000, 143000,
; 258  :  *         156000, 169000, 182000, 195000,
; 259  :  *         208000, 377000, 390000, 403000};
; 260  :  */
; 261  : 
; 262  :     static unsigned long FreqArray[MAXFREQS] =
; 263  :     {104000, 117000, 130000, 143000,
; 264  :         156000, 169000, 182000, 195000};
; 265  : 
; 266  : 
; 267  :     unsigned int    i;
; 268  : 
; 269  :     if (numberfreqs > MAXFREQS)

  00328	e59d3010	 ldr         r3, [sp, #0x10]
  0032c	e3530008	 cmp         r3, #8
  00330	9a000002	 bls         |$LN4@GetPossibl|

; 270  :     {
; 271  :         return FAILURE_PMU;

  00334	e3a03005	 mov         r3, #5
  00338	e58d3004	 str         r3, [sp, #4]
  0033c	ea000018	 b           |$LN5@GetPossibl|
  00340		 |$LN4@GetPossibl|

; 272  :     }
; 273  : 
; 274  :     //
; 275  :     // Calculate possible frequencies
; 276  :     //
; 277  :     for (i=0; i < numberfreqs; i++)

  00340	e3a03000	 mov         r3, #0
  00344	e58d3000	 str         r3, [sp]
  00348	ea000002	 b           |$LN3@GetPossibl|
  0034c		 |$LN2@GetPossibl|
  0034c	e59d3000	 ldr         r3, [sp]
  00350	e2833001	 add         r3, r3, #1
  00354	e58d3000	 str         r3, [sp]
  00358		 |$LN3@GetPossibl|
  00358	e59d2000	 ldr         r2, [sp]
  0035c	e59d3010	 ldr         r3, [sp, #0x10]
  00360	e1520003	 cmp         r2, r3
  00364	2a00000c	 bcs         |$LN1@GetPossibl|

; 278  :     {
; 279  :         FrequencyArray[i] = FreqArray[i];

  00368	e59d1000	 ldr         r1, [sp]
  0036c	e3a03004	 mov         r3, #4
  00370	e0020391	 mul         r2, r1, r3
  00374	e59f3038	 ldr         r3, [pc, #0x38]
  00378	e0830002	 add         r0, r3, r2
  0037c	e59d1000	 ldr         r1, [sp]
  00380	e3a03004	 mov         r3, #4
  00384	e0020391	 mul         r2, r1, r3
  00388	e59d3014	 ldr         r3, [sp, #0x14]
  0038c	e0832002	 add         r2, r3, r2
  00390	e5903000	 ldr         r3, [r0]
  00394	e5823000	 str         r3, [r2]

; 280  :     }

  00398	eaffffeb	 b           |$LN2@GetPossibl|
  0039c		 |$LN1@GetPossibl|

; 281  : 
; 282  :     return SUCCESS_PMU;

  0039c	e3a03000	 mov         r3, #0
  003a0	e58d3004	 str         r3, [sp, #4]
  003a4		 |$LN5@GetPossibl|

; 283  : }

  003a4	e59d0004	 ldr         r0, [sp, #4]
  003a8	e28dd008	 add         sp, sp, #8
  003ac	e89d6000	 ldmia       sp, {sp, lr}
  003b0	e12fff1e	 bx          lr
  003b4		 |$LN10@GetPossibl|
  003b4		 |$LN11@GetPossibl|
  003b4	00000000	 DCD         |?FreqArray@?1??GetPossibleCoreClockFrequencies@@9@4PAKA|
  003b8		 |$M33387|

			 ENDP  ; |GetPossibleCoreClockFrequencies|

	EXPORT	|GetNominalCoreClockFrequency|

  00028			 AREA	 |.pdata|, PDATA
|$T33397| DCD	|$LN5@GetNominal|
	DCD	0x40000701
; Function compile flags: /Odtp

  003b8			 AREA	 |.text|, CODE, ARM

  003b8		 |GetNominalCoreClockFrequency| PROC

; 292  : {

  003b8		 |$LN5@GetNominal|
  003b8	e24dd004	 sub         sp, sp, #4
  003bc		 |$M33394|

; 293  :     return 208000;

  003bc	e3a03bcb	 mov         r3, #0xCB, 22
  003c0	e3833080	 orr         r3, r3, #0x80
  003c4	e58d3000	 str         r3, [sp]

; 294  : }

  003c8	e59d0000	 ldr         r0, [sp]
  003cc	e28dd004	 add         sp, sp, #4
  003d0	e12fff1e	 bx          lr
  003d4		 |$M33395|

			 ENDP  ; |GetNominalCoreClockFrequency|

	EXPORT	|GetCurrentCoreClockFrequency|

  00030			 AREA	 |.pdata|, PDATA
|$T33405| DCD	|$LN7@GetCurrent|
	DCD	0x40002302
; Function compile flags: /Odtp

  003d4			 AREA	 |.text|, CODE, ARM

  003d4		 |GetCurrentCoreClockFrequency| PROC

; 304  : {

  003d4		 |$LN7@GetCurrent|
  003d4	e52de004	 str         lr, [sp, #-4]!
  003d8	e24dd034	 sub         sp, sp, #0x34
  003dc		 |$M33402|

; 305  : 
; 306  :     PMUCCFInfo      PMUCCFBuffer;
; 307  :     unsigned long   CurFrequency,
; 308  :                     nOutBytes;
; 309  :     BOOL            rtnvalue = FALSE;

  003dc	e3a03000	 mov         r3, #0
  003e0	e58d300c	 str         r3, [sp, #0xC]

; 310  : 
; 311  :     //
; 312  :     // This API calls KernelIoControl to access to get
; 313  :     // the current core clock frequency.
; 314  :     // This in turn calls the OEMIoControl routine.  
; 315  :     // Note, the system is fully preemptible when this
; 316  :     // routine is called.
; 317  :     //
; 318  : 
; 319  :     //
; 320  :     // Set the subcode for get ccf
; 321  :     //
; 322  :     PMUCCFBuffer.subcode = PMU_CCF_GETCURRENT;

  003e4	e3a03001	 mov         r3, #1
  003e8	e58d3010	 str         r3, [sp, #0x10]

; 323  :     rtnvalue = 
; 324  :         KernelIoControl (IOCTL_PMU_CCF, (void *)&PMUCCFBuffer, sizeof(PMUCCFInfo), 
; 325  :                          &CurFrequency, sizeof(CurFrequency), &nOutBytes);

  003ec	e28d3008	 add         r3, sp, #8
  003f0	e58d3004	 str         r3, [sp, #4]
  003f4	e3a03004	 mov         r3, #4
  003f8	e58d3000	 str         r3, [sp]
  003fc	e28d3020	 add         r3, sp, #0x20
  00400	e3a02010	 mov         r2, #0x10
  00404	e28d1010	 add         r1, sp, #0x10
  00408	e59f004c	 ldr         r0, [pc, #0x4C]
  0040c	eb000000	 bl          KernelIoControl
  00410	e58d0030	 str         r0, [sp, #0x30]
  00414	e59d3030	 ldr         r3, [sp, #0x30]
  00418	e58d300c	 str         r3, [sp, #0xC]

; 326  : 
; 327  :     if (rtnvalue && (nOutBytes == sizeof(unsigned long)))

  0041c	e59d300c	 ldr         r3, [sp, #0xC]
  00420	e3530000	 cmp         r3, #0
  00424	0a000006	 beq         |$LN2@GetCurrent|
  00428	e59d3008	 ldr         r3, [sp, #8]
  0042c	e3530004	 cmp         r3, #4
  00430	1a000003	 bne         |$LN2@GetCurrent|

; 328  :     {
; 329  :         return CurFrequency;

  00434	e59d3020	 ldr         r3, [sp, #0x20]
  00438	e58d302c	 str         r3, [sp, #0x2C]
  0043c	ea000002	 b           |$LN3@GetCurrent|

; 330  :     }
; 331  :     else

  00440	ea000001	 b           |$LN1@GetCurrent|
  00444		 |$LN2@GetCurrent|

; 332  :     {
; 333  :         return 0;

  00444	e3a03000	 mov         r3, #0
  00448	e58d302c	 str         r3, [sp, #0x2C]
  0044c		 |$LN1@GetCurrent|
  0044c		 |$LN3@GetCurrent|

; 334  :     }
; 335  : }

  0044c	e59d002c	 ldr         r0, [sp, #0x2C]
  00450	e28dd034	 add         sp, sp, #0x34
  00454	e49de004	 ldr         lr, [sp], #4
  00458	e12fff1e	 bx          lr
  0045c		 |$LN8@GetCurrent|
  0045c		 |$LN9@GetCurrent|
  0045c	01013e88	 DCD         0x1013e88
  00460		 |$M33403|

			 ENDP  ; |GetCurrentCoreClockFrequency|


  00038			 AREA	 |.pdata|, PDATA
|$T33415| DCD	|$LN8@UnlockAndR|
	DCD	0x40002e04
; Function compile flags: /Odtp

  00460			 AREA	 |.text|, CODE, ARM

  00460		 |UnlockAndRestoreCoreClockFrequency| PROC

; 349  : {

  00460		 |$LN8@UnlockAndR|
  00460	e1a0c00d	 mov         r12, sp
  00464	e92d0001	 stmdb       sp!, {r0}
  00468	e92d5000	 stmdb       sp!, {r12, lr}
  0046c	e24dd030	 sub         sp, sp, #0x30
  00470		 |$M33412|

; 350  :     PMUCCFInfo      PMUCCFBuffer;
; 351  :     BOOL            rtnvalue = FALSE;

  00470	e3a03000	 mov         r3, #0
  00474	e58d3008	 str         r3, [sp, #8]

; 352  : 
; 353  :     if (handle == 0)

  00478	e59d3038	 ldr         r3, [sp, #0x38]
  0047c	e3530000	 cmp         r3, #0
  00480	1a000002	 bne         |$LN3@UnlockAndR|

; 354  :     {
; 355  :         return 0;

  00484	e3a03000	 mov         r3, #0
  00488	e58d301c	 str         r3, [sp, #0x1C]
  0048c	ea00001b	 b           |$LN4@UnlockAndR|
  00490		 |$LN3@UnlockAndR|

; 356  :     }
; 357  : 
; 358  :     PVTuneReleaseCCF = NULL;

  00490	e59f207c	 ldr         r2, [pc, #0x7C]
  00494	e3a03000	 mov         r3, #0
  00498	e5823000	 str         r3, [r2]

; 359  : 
; 360  :     //
; 361  :     // This API calls KernelIoControl to unlock and
; 362  :     // restore the previous core clock frequency.
; 363  :     //
; 364  :     // Note, the system is fully preemptible when this
; 365  :     // routine is called.
; 366  :     //
; 367  : 
; 368  :     //
; 369  :     // Set the subcode for unlock CCF
; 370  :     //
; 371  :     PMUCCFBuffer.subcode = PMU_CCF_UNLOCK;

  0049c	e3a03003	 mov         r3, #3
  004a0	e58d300c	 str         r3, [sp, #0xC]

; 372  : 
; 373  :     rtnvalue = 
; 374  :         KernelIoControl (IOCTL_PMU_CCF, (void *)&PMUCCFBuffer, sizeof(PMUCCFInfo), 
; 375  :                          (LPVOID)NULL, 0, (LPDWORD)NULL);

  004a4	e3a03000	 mov         r3, #0
  004a8	e58d3004	 str         r3, [sp, #4]
  004ac	e3a03000	 mov         r3, #0
  004b0	e58d3000	 str         r3, [sp]
  004b4	e3a03000	 mov         r3, #0
  004b8	e3a02010	 mov         r2, #0x10
  004bc	e28d100c	 add         r1, sp, #0xC
  004c0	e59f0048	 ldr         r0, [pc, #0x48]
  004c4	eb000000	 bl          KernelIoControl
  004c8	e58d0028	 str         r0, [sp, #0x28]
  004cc	e59d3028	 ldr         r3, [sp, #0x28]
  004d0	e58d3008	 str         r3, [sp, #8]

; 376  : 
; 377  :     if (rtnvalue)

  004d4	e59d3008	 ldr         r3, [sp, #8]
  004d8	e3530000	 cmp         r3, #0
  004dc	0a000005	 beq         |$LN2@UnlockAndR|

; 378  :     {
; 379  :         // Returns the restored core clock frequency (in KHz).
; 380  :         //
; 381  :         return GetCurrentCoreClockFrequency();

  004e0	eb000000	 bl          GetCurrentCoreClockFrequency
  004e4	e58d002c	 str         r0, [sp, #0x2C]
  004e8	e59d302c	 ldr         r3, [sp, #0x2C]
  004ec	e58d301c	 str         r3, [sp, #0x1C]
  004f0	ea000002	 b           |$LN4@UnlockAndR|

; 382  :     }
; 383  :     else

  004f4	ea000001	 b           |$LN1@UnlockAndR|
  004f8		 |$LN2@UnlockAndR|

; 384  :     {
; 385  :         return 0;

  004f8	e3a03000	 mov         r3, #0
  004fc	e58d301c	 str         r3, [sp, #0x1C]
  00500		 |$LN1@UnlockAndR|
  00500		 |$LN4@UnlockAndR|

; 386  :     }
; 387  : 
; 388  : 
; 389  : }

  00500	e59d001c	 ldr         r0, [sp, #0x1C]
  00504	e28dd030	 add         sp, sp, #0x30
  00508	e89d6000	 ldmia       sp, {sp, lr}
  0050c	e12fff1e	 bx          lr
  00510		 |$LN9@UnlockAndR|
  00510		 |$LN10@UnlockAndR|
  00510	01013e88	 DCD         0x1013e88
  00514		 |$LN11@UnlockAndR|
  00514	00000000	 DCD         |?PVTuneReleaseCCF@@3PAXA|
  00518		 |$M33413|

			 ENDP  ; |UnlockAndRestoreCoreClockFrequency|

	EXPORT	|AccessPMUReg|

  00040			 AREA	 |.pdata|, PDATA
|$T33428| DCD	|$LN13@AccessPMUR|
	DCD	0x40004e04
; Function compile flags: /Odtp

  00518			 AREA	 |.text|, CODE, ARM

  00518		 |AccessPMUReg| PROC

; 405  : {

  00518		 |$LN13@AccessPMUR|
  00518	e1a0c00d	 mov         r12, sp
  0051c	e92d000f	 stmdb       sp!, {r0 - r3}
  00520	e92d5000	 stmdb       sp!, {r12, lr}
  00524	e24dd04c	 sub         sp, sp, #0x4C
  00528		 |$M33425|

; 406  :     PMURegInfo      PMURegBuffer;
; 407  :     unsigned long   PMURegResults,
; 408  :                     nOutBytes;
; 409  :     BOOL            rtnvalue = FALSE;

  00528	e3a03000	 mov         r3, #0
  0052c	e58d300c	 str         r3, [sp, #0xC]

; 410  :         
; 411  :     if (handle == 0)

  00530	e59d3054	 ldr         r3, [sp, #0x54]
  00534	e3530000	 cmp         r3, #0
  00538	1a000002	 bne         |$LN8@AccessPMUR|

; 412  :     {
; 413  :         return FALSE;

  0053c	e3a03000	 mov         r3, #0
  00540	e58d302c	 str         r3, [sp, #0x2C]
  00544	ea00003c	 b           |$LN9@AccessPMUR|
  00548		 |$LN8@AccessPMUR|

; 414  :     }
; 415  : 
; 416  :     PMURegBuffer.PMUReg = RegisterNumber;

  00548	e59d305c	 ldr         r3, [sp, #0x5C]
  0054c	e58d3014	 str         r3, [sp, #0x14]

; 417  : 
; 418  :     switch (Access)

  00550	e59d3058	 ldr         r3, [sp, #0x58]
  00554	e58d3040	 str         r3, [sp, #0x40]
  00558	e59d3040	 ldr         r3, [sp, #0x40]
  0055c	e3530000	 cmp         r3, #0
  00560	0a000003	 beq         |$LN5@AccessPMUR|
  00564	e59d3040	 ldr         r3, [sp, #0x40]
  00568	e3530001	 cmp         r3, #1
  0056c	0a00001b	 beq         |$LN2@AccessPMUR|
  00570	ea00002c	 b           |$LN1@AccessPMUR|
  00574		 |$LN5@AccessPMUR|

; 419  :     {
; 420  :     case READ:
; 421  :         PMURegBuffer.subcode = PMU_READ_REG;

  00574	e3a03005	 mov         r3, #5
  00578	e58d3010	 str         r3, [sp, #0x10]

; 422  :         rtnvalue = 
; 423  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 424  :                              &PMURegResults, sizeof(PMURegResults), &nOutBytes);

  0057c	e28d3008	 add         r3, sp, #8
  00580	e58d3004	 str         r3, [sp, #4]
  00584	e3a03004	 mov         r3, #4
  00588	e58d3000	 str         r3, [sp]
  0058c	e28d3028	 add         r3, sp, #0x28
  00590	e3a02018	 mov         r2, #0x18
  00594	e28d1010	 add         r1, sp, #0x10
  00598	e59f00ac	 ldr         r0, [pc, #0xAC]
  0059c	eb000000	 bl          KernelIoControl
  005a0	e58d0044	 str         r0, [sp, #0x44]
  005a4	e59d3044	 ldr         r3, [sp, #0x44]
  005a8	e58d300c	 str         r3, [sp, #0xC]

; 425  :         if (rtnvalue && (nOutBytes == sizeof(unsigned long)))

  005ac	e59d300c	 ldr         r3, [sp, #0xC]
  005b0	e3530000	 cmp         r3, #0
  005b4	0a000006	 beq         |$LN4@AccessPMUR|
  005b8	e59d3008	 ldr         r3, [sp, #8]
  005bc	e3530004	 cmp         r3, #4
  005c0	1a000003	 bne         |$LN4@AccessPMUR|

; 426  :         {
; 427  :             *pValue = PMURegResults;

  005c4	e59d2028	 ldr         r2, [sp, #0x28]
  005c8	e59d3060	 ldr         r3, [sp, #0x60]
  005cc	e5832000	 str         r2, [r3]

; 428  :         }
; 429  :         else

  005d0	ea000001	 b           |$LN3@AccessPMUR|
  005d4		 |$LN4@AccessPMUR|

; 430  :         {
; 431  :             rtnvalue = FALSE;

  005d4	e3a03000	 mov         r3, #0
  005d8	e58d300c	 str         r3, [sp, #0xC]
  005dc		 |$LN3@AccessPMUR|

; 432  :         }
; 433  : 
; 434  :         break;

  005dc	ea000014	 b           |$LN6@AccessPMUR|
  005e0		 |$LN2@AccessPMUR|

; 435  :     case WRITE:
; 436  :         PMURegBuffer.subcode = PMU_WRITE_REG;

  005e0	e3a03006	 mov         r3, #6
  005e4	e58d3010	 str         r3, [sp, #0x10]

; 437  :         PMURegBuffer.PMUValue = *pValue;

  005e8	e59d3060	 ldr         r3, [sp, #0x60]
  005ec	e5933000	 ldr         r3, [r3]
  005f0	e58d3018	 str         r3, [sp, #0x18]

; 438  : 
; 439  :         rtnvalue = 
; 440  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 441  :                              &PMURegResults, sizeof(PMURegResults), &nOutBytes);

  005f4	e28d3008	 add         r3, sp, #8
  005f8	e58d3004	 str         r3, [sp, #4]
  005fc	e3a03004	 mov         r3, #4
  00600	e58d3000	 str         r3, [sp]
  00604	e28d3028	 add         r3, sp, #0x28
  00608	e3a02018	 mov         r2, #0x18
  0060c	e28d1010	 add         r1, sp, #0x10
  00610	e59f0034	 ldr         r0, [pc, #0x34]
  00614	eb000000	 bl          KernelIoControl
  00618	e58d0048	 str         r0, [sp, #0x48]
  0061c	e59d3048	 ldr         r3, [sp, #0x48]
  00620	e58d300c	 str         r3, [sp, #0xC]

; 442  :         break;

  00624	ea000002	 b           |$LN6@AccessPMUR|
  00628		 |$LN1@AccessPMUR|

; 443  :     default:
; 444  :         return FALSE;

  00628	e3a03000	 mov         r3, #0
  0062c	e58d302c	 str         r3, [sp, #0x2C]
  00630	ea000001	 b           |$LN9@AccessPMUR|
  00634		 |$LN6@AccessPMUR|

; 445  :         break;
; 446  : 
; 447  :     }
; 448  : 
; 449  :     return rtnvalue;

  00634	e59d300c	 ldr         r3, [sp, #0xC]
  00638	e58d302c	 str         r3, [sp, #0x2C]
  0063c		 |$LN9@AccessPMUR|

; 450  : }

  0063c	e59d002c	 ldr         r0, [sp, #0x2C]
  00640	e28dd04c	 add         sp, sp, #0x4C
  00644	e89d6000	 ldmia       sp, {sp, lr}
  00648	e12fff1e	 bx          lr
  0064c		 |$LN14@AccessPMUR|
  0064c		 |$LN15@AccessPMUR|
  0064c	01013e80	 DCD         0x1013e80
  00650		 |$M33426|

			 ENDP  ; |AccessPMUReg|

	EXPORT	|GetCPUId|

  00048			 AREA	 |.pdata|, PDATA
|$T33438| DCD	|$LN7@GetCPUId|
	DCD	0x40002504
; Function compile flags: /Odtp

  00650			 AREA	 |.text|, CODE, ARM

  00650		 |GetCPUId| PROC

; 463  : {

  00650		 |$LN7@GetCPUId|
  00650	e1a0c00d	 mov         r12, sp
  00654	e92d0001	 stmdb       sp!, {r0}
  00658	e92d5000	 stmdb       sp!, {r12, lr}
  0065c	e24dd028	 sub         sp, sp, #0x28
  00660		 |$M33435|

; 464  :     CPUIdInfo       CPUIdBuffer;
; 465  :     unsigned long   CPUIdResults,
; 466  :                     nOutBytes;
; 467  :     BOOL            rtnvalue = FALSE;

  00660	e3a03000	 mov         r3, #0
  00664	e58d3010	 str         r3, [sp, #0x10]

; 468  : 
; 469  :     rtnvalue = 
; 470  :         KernelIoControl (IOCTL_GET_CPU_ID, (void *)&CPUIdBuffer, sizeof(CPUIdInfo), 
; 471  :                          &CPUIdResults, sizeof(CPUIdResults), &nOutBytes);

  00668	e28d3008	 add         r3, sp, #8
  0066c	e58d3004	 str         r3, [sp, #4]
  00670	e3a03004	 mov         r3, #4
  00674	e58d3000	 str         r3, [sp]
  00678	e28d300c	 add         r3, sp, #0xC
  0067c	e3a02004	 mov         r2, #4
  00680	e28d1014	 add         r1, sp, #0x14
  00684	e59f0054	 ldr         r0, [pc, #0x54]
  00688	eb000000	 bl          KernelIoControl
  0068c	e58d0024	 str         r0, [sp, #0x24]
  00690	e59d3024	 ldr         r3, [sp, #0x24]
  00694	e58d3010	 str         r3, [sp, #0x10]

; 472  :     if (rtnvalue && (nOutBytes == sizeof(unsigned long)))

  00698	e59d3010	 ldr         r3, [sp, #0x10]
  0069c	e3530000	 cmp         r3, #0
  006a0	0a000006	 beq         |$LN2@GetCPUId|
  006a4	e59d3008	 ldr         r3, [sp, #8]
  006a8	e3530004	 cmp         r3, #4
  006ac	1a000003	 bne         |$LN2@GetCPUId|

; 473  :     {
; 474  :         *CPUId = CPUIdResults;

  006b0	e59d200c	 ldr         r2, [sp, #0xC]
  006b4	e59d3030	 ldr         r3, [sp, #0x30]
  006b8	e5832000	 str         r2, [r3]

; 475  :     }
; 476  :     else

  006bc	ea000001	 b           |$LN1@GetCPUId|
  006c0		 |$LN2@GetCPUId|

; 477  :     {
; 478  :         rtnvalue = FALSE;

  006c0	e3a03000	 mov         r3, #0
  006c4	e58d3010	 str         r3, [sp, #0x10]
  006c8		 |$LN1@GetCPUId|

; 479  :     }
; 480  : 
; 481  :     return rtnvalue;

  006c8	e59d3010	 ldr         r3, [sp, #0x10]
  006cc	e58d3020	 str         r3, [sp, #0x20]

; 482  : 
; 483  : }

  006d0	e59d0020	 ldr         r0, [sp, #0x20]
  006d4	e28dd028	 add         sp, sp, #0x28
  006d8	e89d6000	 ldmia       sp, {sp, lr}
  006dc	e12fff1e	 bx          lr
  006e0		 |$LN8@GetCPUId|
  006e0		 |$LN9@GetCPUId|
  006e0	01013e84	 DCD         0x1013e84
  006e4		 |$M33436|

			 ENDP  ; |GetCPUId|

	EXPORT	|GetOEMConfigData|

  00050			 AREA	 |.pdata|, PDATA
|$T33448| DCD	|$LN8@GetOEMConf|
	DCD	0x40003704
; Function compile flags: /Odtp

  006e4			 AREA	 |.text|, CODE, ARM

  006e4		 |GetOEMConfigData| PROC

; 502  : {

  006e4		 |$LN8@GetOEMConf|
  006e4	e1a0c00d	 mov         r12, sp
  006e8	e92d0007	 stmdb       sp!, {r0 - r2}
  006ec	e92d5000	 stmdb       sp!, {r12, lr}
  006f0	e24dd040	 sub         sp, sp, #0x40
  006f4		 |$M33445|

; 503  :     OEMInfo         OEMBuffer;
; 504  :     PMURegInfo      PMURegBuffer;
; 505  :     unsigned long   nOutBytes;
; 506  :     BOOL            rtnvalue = FALSE;

  006f4	e3a03000	 mov         r3, #0
  006f8	e58d300c	 str         r3, [sp, #0xC]

; 507  : 
; 508  :     PMURegBuffer.subcode = PMU_OEM_INFO;

  006fc	e3a03009	 mov         r3, #9
  00700	e58d3018	 str         r3, [sp, #0x18]

; 509  :     rtnvalue = 
; 510  :         KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 511  :                      &OEMBuffer, sizeof(OEMInfo), &nOutBytes);

  00704	e28d3008	 add         r3, sp, #8
  00708	e58d3004	 str         r3, [sp, #4]
  0070c	e3a03008	 mov         r3, #8
  00710	e58d3000	 str         r3, [sp]
  00714	e28d3010	 add         r3, sp, #0x10
  00718	e3a02018	 mov         r2, #0x18
  0071c	e28d1018	 add         r1, sp, #0x18
  00720	e59f0094	 ldr         r0, [pc, #0x94]
  00724	eb000000	 bl          KernelIoControl
  00728	e58d003c	 str         r0, [sp, #0x3C]
  0072c	e59d303c	 ldr         r3, [sp, #0x3C]
  00730	e58d300c	 str         r3, [sp, #0xC]

; 512  : 
; 513  :     if (rtnvalue && ((nOutBytes != sizeof(OEMInfo) || 
; 514  :         (nOutBytes > (maxItems*sizeof(unsigned long))))))

  00734	e59d300c	 ldr         r3, [sp, #0xC]
  00738	e3530000	 cmp         r3, #0
  0073c	0a00000e	 beq         |$LN3@GetOEMConf|
  00740	e59d3008	 ldr         r3, [sp, #8]
  00744	e3530008	 cmp         r3, #8
  00748	1a000005	 bne         |$LN2@GetOEMConf|
  0074c	e59d104c	 ldr         r1, [sp, #0x4C]
  00750	e3a03004	 mov         r3, #4
  00754	e0020391	 mul         r2, r1, r3
  00758	e59d3008	 ldr         r3, [sp, #8]
  0075c	e1530002	 cmp         r3, r2
  00760	9a000005	 bls         |$LN3@GetOEMConf|
  00764		 |$LN2@GetOEMConf|

; 515  :     {
; 516  :         rtnvalue = FALSE;

  00764	e3a03000	 mov         r3, #0
  00768	e58d300c	 str         r3, [sp, #0xC]

; 517  :         *nOutItems = 0;

  0076c	e59d2050	 ldr         r2, [sp, #0x50]
  00770	e3a03000	 mov         r3, #0
  00774	e5823000	 str         r3, [r2]

; 518  :     }
; 519  :     else

  00778	ea000009	 b           |$LN1@GetOEMConf|
  0077c		 |$LN3@GetOEMConf|

; 520  :     {
; 521  :         configArray[0] = OEMBuffer.sysintrID;

  0077c	e59d2010	 ldr         r2, [sp, #0x10]
  00780	e59d3048	 ldr         r3, [sp, #0x48]
  00784	e5832000	 str         r2, [r3]

; 522  :         configArray[1] = OEMBuffer.PMUglobals;

  00788	e59d3048	 ldr         r3, [sp, #0x48]
  0078c	e2832004	 add         r2, r3, #4
  00790	e59d3014	 ldr         r3, [sp, #0x14]
  00794	e5823000	 str         r3, [r2]

; 523  :         *nOutItems = 2;

  00798	e59d2050	 ldr         r2, [sp, #0x50]
  0079c	e3a03002	 mov         r3, #2
  007a0	e5823000	 str         r3, [r2]
  007a4		 |$LN1@GetOEMConf|

; 524  :    }
; 525  : 
; 526  :     return rtnvalue;

  007a4	e59d300c	 ldr         r3, [sp, #0xC]
  007a8	e58d3038	 str         r3, [sp, #0x38]

; 527  : 
; 528  : }

  007ac	e59d0038	 ldr         r0, [sp, #0x38]
  007b0	e28dd040	 add         sp, sp, #0x40
  007b4	e89d6000	 ldmia       sp, {sp, lr}
  007b8	e12fff1e	 bx          lr
  007bc		 |$LN9@GetOEMConf|
  007bc		 |$LN10@GetOEMConf|
  007bc	01013e80	 DCD         0x1013e80
  007c0		 |$M33446|

			 ENDP  ; |GetOEMConfigData|

	END
