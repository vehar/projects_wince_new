; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\PMU\pmudll.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?PVTuneInterrupt@@3PAXA| [ DATA ]	; PVTuneInterrupt
	EXPORT	|?PVTuneReleasePMU@@3PAXA| [ DATA ]	; PVTuneReleasePMU
	EXPORT	|?PVTuneReleaseCCF@@3PAXA| [ DATA ]	; PVTuneReleaseCCF

  00000			 AREA	 |.bss|, NOINIT
|trySemaphore| % 0x4
|semHandle| %	0x4
|?PVTuneInterrupt@@3PAXA| % 0x4				; PVTuneInterrupt
|?PVTuneReleasePMU@@3PAXA| % 0x4			; PVTuneReleasePMU
|?PVTuneReleaseCCF@@3PAXA| % 0x4			; PVTuneReleaseCCF
	EXPORT	|AllocatePMU|
	EXPORT	|??_C@_1BM@CAGEFPEO@?$AAX?$AAS?$AAC?$AA_?$AAP?$AAM?$AAU?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|malloc|
	IMPORT	|KernelIoControl|
	IMPORT	|CloseHandle|
	IMPORT	|GetLastError|
	IMPORT	|CreateSemaphoreW|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\pmu\pmudll.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T33381| DCD	|$LN9@AllocatePM|
	DCD	0x40003002

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BM@CAGEFPEO@?$AAX?$AAS?$AAC?$AA_?$AAP?$AAM?$AAU?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$AA@| DCB "X"
	DCB	0x0, "S", 0x0, "C", 0x0, "_", 0x0, "P", 0x0, "M", 0x0, "U"
	DCB	0x0, "_", 0x0, "A", 0x0, "L", 0x0, "L", 0x0, "O", 0x0, "C"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |AllocatePMU| PROC

; 71   : {

  00000		 |$LN9@AllocatePM|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M33378|

; 72   : 
; 73   :     PMUHandle   handle = 0;
; 74   :     PMURegInfo  PMURegBuffer;
; 75   :     BOOL        rtnvalue = FALSE;
; 76   :     LPCTSTR     semName = TEXT("XSC_PMU_ALLOC");
; 77   : 
; 78   :     // Allocate a system resource, initialize to unsignalled state.
; 79   :     // If it's already allocated, return NULL handle.
; 80   :     //
; 81   :     trySemaphore = CreateSemaphore (NULL, 1, 1, semName);

  00008	e59f30ac	 ldr         r3, [pc, #0xAC]
  0000c	e3a02001	 mov         r2, #1
  00010	e3a01001	 mov         r1, #1
  00014	e3a00000	 mov         r0, #0
  00018	eb000000	 bl          CreateSemaphoreW
  0001c	e59f4094	 ldr         r4, [pc, #0x94]
  00020	e3500000	 cmp         r0, #0
  00024	e5840000	 str         r0, [r4]

; 82   :     if (trySemaphore == NULL) 

  00028	1a000001	 bne         |$LN3@AllocatePM|
  0002c		 |$LN6@AllocatePM|

; 83   :     {
; 84   :         return 0;

  0002c	e3a00000	 mov         r0, #0
  00030	ea00001c	 b           |$LN4@AllocatePM|
  00034		 |$LN3@AllocatePM|

; 85   :     }
; 86   : 
; 87   :     if (GetLastError() == ERROR_ALREADY_EXISTS)

  00034	eb000000	 bl          GetLastError
  00038	e35000b7	 cmp         r0, #0xB7
  0003c	1a000003	 bne         |$LN2@AllocatePM|

; 88   :     {
; 89   :         //
; 90   :         // Invalidate this handle
; 91   :         //
; 92   :         CloseHandle(trySemaphore);

  00040	e5940000	 ldr         r0, [r4]
  00044	eb000000	 bl          CloseHandle
  00048	e3a00000	 mov         r0, #0
  0004c	ea000015	 b           |$LN4@AllocatePM|
  00050		 |$LN2@AllocatePM|

; 93   :         return 0;
; 94   :     }
; 95   : 
; 96   :         semHandle = trySemaphore;

  00050	e5943000	 ldr         r3, [r4]

; 97   : 
; 98   :         // Register callback with kernel
; 99   :         // NOTE: Intel no longer uses the pCallBack parameter that was stored in 
; 100  :         // the PVTuneReleasePMU variable, it is understood to be NULL.
; 101  :         PMURegBuffer.subcode = PMU_ALLOCATE;
; 102  :         PMURegBuffer.pCallback = PVTuneReleasePMU;

  00054	e594200c	 ldr         r2, [r4, #0xC]

; 103  : 
; 104  :         rtnvalue = 
; 105  :                 KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 106  :                                  (LPVOID)NULL, 0, (LPDWORD)NULL);

  00058	e59f0054	 ldr         r0, [pc, #0x54]
  0005c	e5843004	 str         r3, [r4, #4]
  00060	e58d2014	 str         r2, [sp, #0x14]
  00064	e3a05007	 mov         r5, #7
  00068	e3a0e000	 mov         lr, #0
  0006c	e3a03000	 mov         r3, #0
  00070	e3a02018	 mov         r2, #0x18
  00074	e28d1008	 add         r1, sp, #8
  00078	e58d5008	 str         r5, [sp, #8]
  0007c	e58de004	 str         lr, [sp, #4]
  00080	e58de000	 str         lr, [sp]
  00084	eb000000	 bl          KernelIoControl
  00088	e3500000	 cmp         r0, #0

; 107  :         if (rtnvalue == FALSE)
; 108  :         {
; 109  :             return 0;

  0008c	0affffe6	 beq         |$LN6@AllocatePM|

; 110  :         }
; 111  : 
; 112  :         // Null other callbacks
; 113  :         //
; 114  :         PVTuneInterrupt = NULL;

  00090	e3a03000	 mov         r3, #0

; 115  :         PVTuneReleaseCCF = NULL;

  00094	e3a02000	 mov         r2, #0

; 116  : 
; 117  :         // Allocate a PMUHandle
; 118  :         //
; 119  :         handle = (PMUHandle) malloc (sizeof (PMUHResource));

  00098	e3a00004	 mov         r0, #4
  0009c	e5843008	 str         r3, [r4, #8]
  000a0	e5842010	 str         r2, [r4, #0x10]
  000a4	eb000000	 bl          malloc
  000a8		 |$LN4@AllocatePM|

; 120  : 
; 121  :     return handle;
; 122  : 
; 123  : }

  000a8	e28dd020	 add         sp, sp, #0x20
  000ac	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$LN10@AllocatePM|
  000b4		 |$LN11@AllocatePM|
  000b4	01013e80	 DCD         0x1013e80
  000b8		 |$LN12@AllocatePM|
  000b8	00000000	 DCD         |trySemaphore|
  000bc		 |$LN13@AllocatePM|
  000bc	00000000	 DCD         |??_C@_1BM@CAGEFPEO@?$AAX?$AAS?$AAC?$AA_?$AAP?$AAM?$AAU?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AA?$AA@|
  000c0		 |$M33379|

			 ENDP  ; |AllocatePMU|

	EXPORT	|RemovePMUInterruptCallback|

  00000			 AREA	 |.pdata|, PDATA
|$T33395| DCD	|$LN8@RemovePMUI|
	DCD	0x40001e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |RemovePMUInterruptCallback| PROC

; 186  : {

  00000		 |$LN8@RemovePMUI|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M33392|
  00008	e3500000	 cmp         r0, #0

; 187  :     PMURegInfo      PMURegBuffer;
; 188  :     BOOL            rtnvalue = FALSE;
; 189  : 
; 190  :     if (handle == 0)
; 191  :     {
; 192  :         return INVALIDHANDLE_PMU;

  0000c	03a00001	 moveq       r0, #1
  00010	0a000013	 beq         |$LN4@RemovePMUI|

; 193  :     }
; 194  : 
; 195  :     //
; 196  :     // Remove the interrupt callback
; 197  :     //
; 198  :     if (PVTuneInterrupt == NULL)

  00014	e59fe058	 ldr         lr, [pc, #0x58]
  00018	e59e3000	 ldr         r3, [lr]
  0001c	e3530000	 cmp         r3, #0

; 199  :     {
; 200  :         return NOCALLBACK_PMU;

  00020	03a00003	 moveq       r0, #3
  00024	0a00000e	 beq         |$LN4@RemovePMUI|

; 201  :     }
; 202  : 
; 203  :     PVTuneInterrupt = NULL;
; 204  : 
; 205  :     //
; 206  :     // Disable the interrupt (IRQ for now...) and 
; 207  :     // unregister the callback in the kernel
; 208  :     //
; 209  :     PMURegBuffer.subcode = PMU_DISABLE_IRQ;
; 210  :     rtnvalue = 
; 211  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 212  :                              (LPVOID)NULL, 0, (LPDWORD)NULL);

  00028	e59f0040	 ldr         r0, [pc, #0x40]
  0002c	e3a04000	 mov         r4, #0
  00030	e3a05003	 mov         r5, #3
  00034	e3a06000	 mov         r6, #0
  00038	e3a03000	 mov         r3, #0
  0003c	e3a02018	 mov         r2, #0x18
  00040	e28d1008	 add         r1, sp, #8
  00044	e58e4000	 str         r4, [lr]
  00048	e58d5008	 str         r5, [sp, #8]
  0004c	e58d6004	 str         r6, [sp, #4]
  00050	e58d6000	 str         r6, [sp]
  00054	eb000000	 bl          KernelIoControl
  00058	e3500000	 cmp         r0, #0

; 213  : 
; 214  :     if (rtnvalue == FALSE)
; 215  :     {
; 216  :         return KERNELIOFAILED_PMU;

  0005c	03a00004	 moveq       r0, #4

; 217  :     }
; 218  : 
; 219  :     return SUCCESS_PMU;

  00060	13a00000	 movne       r0, #0
  00064		 |$LN4@RemovePMUI|

; 220  : 
; 221  : }

  00064	e28dd020	 add         sp, sp, #0x20
  00068	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN9@RemovePMUI|
  00070		 |$LN10@RemovePMUI|
  00070	01013e80	 DCD         0x1013e80
  00074		 |$LN11@RemovePMUI|
  00074	00000000	 DCD         |?PVTuneInterrupt@@3PAXA|
  00078		 |$M33393|

			 ENDP  ; |RemovePMUInterruptCallback|

	EXPORT	|GetNumberOfPossibleCoreClockFrequencies|

  00000			 AREA	 |.pdata|, PDATA
|$T33407| DCD	|$LN5@GetNumberO|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetNumberOfPossibleCoreClockFrequencies| PROC

; 232  : {

  00000		 |$LN5@GetNumberO|
  00000		 |$M33404|

; 233  :     return MAXFREQS;

  00000	e3a00008	 mov         r0, #8

; 234  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M33405|

			 ENDP  ; |GetNumberOfPossibleCoreClockFrequencies|

	EXPORT	|GetPossibleCoreClockFrequencies|

  00000			 AREA	 |.pdata|, PDATA
|$T33420| DCD	|$LN11@GetPossibl|
	DCD	0x40000e00

  00000			 AREA	 |.data|, DATA
|?FreqArray@?1??GetPossibleCoreClockFrequencies@@9@4PAKA| DCD 0x19640 ; `GetPossibleCoreClockFrequencies'::`2'::FreqArray
	DCD	0x1c908
	DCD	0x1fbd0
	DCD	0x22e98
	DCD	0x26160
	DCD	0x29428
	DCD	0x2c6f0
	DCD	0x2f9b8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetPossibleCoreClockFrequencies| PROC

; 249  : {

  00000		 |$LN11@GetPossibl|
  00000		 |$M33417|

; 250  : 
; 251  : /*
; 252  :  * Restrict frequencies between the same LCD Frequency
; 253  :  * (K) range until LCD controller can be disabled
; 254  :  *
; 255  :  *    static unsigned long FreqArray[MAXFREQS] =
; 256  :  *      {26000, 39000, 52000, 65000, 78000,
; 257  :  *         91000, 104000, 117000, 130000, 143000,
; 258  :  *         156000, 169000, 182000, 195000,
; 259  :  *         208000, 377000, 390000, 403000};
; 260  :  */
; 261  : 
; 262  :     static unsigned long FreqArray[MAXFREQS] =
; 263  :     {104000, 117000, 130000, 143000,
; 264  :         156000, 169000, 182000, 195000};
; 265  : 
; 266  : 
; 267  :     unsigned int    i;
; 268  : 
; 269  :     if (numberfreqs > MAXFREQS)

  00000	e3500008	 cmp         r0, #8

; 270  :     {
; 271  :         return FAILURE_PMU;

  00004	83a00005	 movhi       r0, #5

; 283  : }

  00008	812fff1e	 bxhi        lr

; 272  :     }
; 273  : 
; 274  :     //
; 275  :     // Calculate possible frequencies
; 276  :     //
; 277  :     for (i=0; i < numberfreqs; i++)

  0000c	e3500000	 cmp         r0, #0
  00010	0a000005	 beq         |$LN1@GetPossibl|
  00014	e59f3018	 ldr         r3, [pc, #0x18]
  00018	e0432001	 sub         r2, r3, r1
  0001c		 |$LL3@GetPossibl|

; 278  :     {
; 279  :         FrequencyArray[i] = FreqArray[i];

  0001c	e7923001	 ldr         r3, [r2, +r1]
  00020	e2500001	 subs        r0, r0, #1
  00024	e4813004	 str         r3, [r1], #4
  00028	1afffffb	 bne         |$LL3@GetPossibl|
  0002c		 |$LN1@GetPossibl|

; 280  :     }
; 281  : 
; 282  :     return SUCCESS_PMU;

  0002c	e3a00000	 mov         r0, #0

; 283  : }

  00030	e12fff1e	 bx          lr
  00034		 |$LN12@GetPossibl|
  00034		 |$LN13@GetPossibl|
  00034	00000000	 DCD         |?FreqArray@?1??GetPossibleCoreClockFrequencies@@9@4PAKA|
  00038		 |$M33418|

			 ENDP  ; |GetPossibleCoreClockFrequencies|

	EXPORT	|GetNominalCoreClockFrequency|

  00000			 AREA	 |.pdata|, PDATA
|$T33431| DCD	|$LN5@GetNominal|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetNominalCoreClockFrequency| PROC

; 292  : {

  00000		 |$LN5@GetNominal|
  00000		 |$M33428|
  00000	e3a03bcb	 mov         r3, #0xCB, 22

; 293  :     return 208000;

  00004	e3830080	 orr         r0, r3, #0x80

; 294  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M33429|

			 ENDP  ; |GetNominalCoreClockFrequency|

	EXPORT	|GetCurrentCoreClockFrequency|

  00000			 AREA	 |.pdata|, PDATA
|$T33440| DCD	|$LN7@GetCurrent|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentCoreClockFrequency| PROC

; 304  : {

  00000		 |$LN7@GetCurrent|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M33437|

; 305  : 
; 306  :     PMUCCFInfo      PMUCCFBuffer;
; 307  :     unsigned long   CurFrequency,
; 308  :                     nOutBytes;
; 309  :     BOOL            rtnvalue = FALSE;
; 310  : 
; 311  :     //
; 312  :     // This API calls KernelIoControl to access to get
; 313  :     // the current core clock frequency.
; 314  :     // This in turn calls the OEMIoControl routine.  
; 315  :     // Note, the system is fully preemptible when this
; 316  :     // routine is called.
; 317  :     //
; 318  : 
; 319  :     //
; 320  :     // Set the subcode for get ccf
; 321  :     //
; 322  :     PMUCCFBuffer.subcode = PMU_CCF_GETCURRENT;
; 323  :     rtnvalue = 
; 324  :         KernelIoControl (IOCTL_PMU_CCF, (void *)&PMUCCFBuffer, sizeof(PMUCCFInfo), 
; 325  :                          &CurFrequency, sizeof(CurFrequency), &nOutBytes);

  00008	e59f004c	 ldr         r0, [pc, #0x4C]
  0000c	e3a04001	 mov         r4, #1
  00010	e28de008	 add         lr, sp, #8
  00014	e3a05004	 mov         r5, #4
  00018	e28d300c	 add         r3, sp, #0xC
  0001c	e3a02010	 mov         r2, #0x10
  00020	e28d1010	 add         r1, sp, #0x10
  00024	e58d4010	 str         r4, [sp, #0x10]
  00028	e58de004	 str         lr, [sp, #4]
  0002c	e58d5000	 str         r5, [sp]
  00030	eb000000	 bl          KernelIoControl
  00034	e3500000	 cmp         r0, #0

; 326  : 
; 327  :     if (rtnvalue && (nOutBytes == sizeof(unsigned long)))

  00038	0a000003	 beq         |$LN2@GetCurrent|
  0003c	e59d3008	 ldr         r3, [sp, #8]
  00040	e3530004	 cmp         r3, #4

; 328  :     {
; 329  :         return CurFrequency;

  00044	059d000c	 ldreq       r0, [sp, #0xC]
  00048	0a000000	 beq         |$LN1@GetCurrent|
  0004c		 |$LN2@GetCurrent|

; 330  :     }
; 331  :     else
; 332  :     {
; 333  :         return 0;

  0004c	e3a00000	 mov         r0, #0
  00050		 |$LN1@GetCurrent|

; 334  :     }
; 335  : }

  00050	e28dd020	 add         sp, sp, #0x20
  00054	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN8@GetCurrent|
  0005c		 |$LN9@GetCurrent|
  0005c	01013e88	 DCD         0x1013e88
  00060		 |$M33438|

			 ENDP  ; |GetCurrentCoreClockFrequency|

	EXPORT	|UnlockAndRestoreCoreClockFrequency|

  00000			 AREA	 |.pdata|, PDATA
|$T33452| DCD	|$LN8@UnlockAndR|
	DCD	0x40001b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |UnlockAndRestoreCoreClockFrequency| PROC

; 349  : {

  00000		 |$LN8@UnlockAndR|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M33449|
  00008	e3500000	 cmp         r0, #0

; 350  :     PMUCCFInfo      PMUCCFBuffer;
; 351  :     BOOL            rtnvalue = FALSE;
; 352  : 
; 353  :     if (handle == 0)
; 354  :     {
; 355  :         return 0;

  0000c	0a000010	 beq         |$LN2@UnlockAndR|

; 356  :     }
; 357  : 
; 358  :     PVTuneReleaseCCF = NULL;

  00010	e59f3050	 ldr         r3, [pc, #0x50]

; 359  : 
; 360  :     //
; 361  :     // This API calls KernelIoControl to unlock and
; 362  :     // restore the previous core clock frequency.
; 363  :     //
; 364  :     // Note, the system is fully preemptible when this
; 365  :     // routine is called.
; 366  :     //
; 367  : 
; 368  :     //
; 369  :     // Set the subcode for unlock CCF
; 370  :     //
; 371  :     PMUCCFBuffer.subcode = PMU_CCF_UNLOCK;
; 372  : 
; 373  :     rtnvalue = 
; 374  :         KernelIoControl (IOCTL_PMU_CCF, (void *)&PMUCCFBuffer, sizeof(PMUCCFInfo), 
; 375  :                          (LPVOID)NULL, 0, (LPDWORD)NULL);

  00014	e59f0048	 ldr         r0, [pc, #0x48]
  00018	e3a02000	 mov         r2, #0
  0001c	e5832000	 str         r2, [r3]
  00020	e3a0e003	 mov         lr, #3
  00024	e3a04000	 mov         r4, #0
  00028	e3a03000	 mov         r3, #0
  0002c	e3a02010	 mov         r2, #0x10
  00030	e28d1008	 add         r1, sp, #8
  00034	e58de008	 str         lr, [sp, #8]
  00038	e58d4004	 str         r4, [sp, #4]
  0003c	e58d4000	 str         r4, [sp]
  00040	eb000000	 bl          KernelIoControl
  00044	e3500000	 cmp         r0, #0

; 376  : 
; 377  :     if (rtnvalue)

  00048	0a000001	 beq         |$LN2@UnlockAndR|

; 378  :     {
; 379  :         // Returns the restored core clock frequency (in KHz).
; 380  :         //
; 381  :         return GetCurrentCoreClockFrequency();

  0004c	eb000000	 bl          GetCurrentCoreClockFrequency
  00050	ea000000	 b           |$LN1@UnlockAndR|
  00054		 |$LN2@UnlockAndR|

; 382  :     }
; 383  :     else
; 384  :     {
; 385  :         return 0;

  00054	e3a00000	 mov         r0, #0
  00058		 |$LN1@UnlockAndR|

; 386  :     }
; 387  : 
; 388  : 
; 389  : }

  00058	e28dd018	 add         sp, sp, #0x18
  0005c	e8bd4010	 ldmia       sp!, {r4, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN9@UnlockAndR|
  00064		 |$LN10@UnlockAndR|
  00064	01013e88	 DCD         0x1013e88
  00068		 |$LN11@UnlockAndR|
  00068	00000000	 DCD         |?PVTuneReleaseCCF@@3PAXA|
  0006c		 |$M33450|

			 ENDP  ; |UnlockAndRestoreCoreClockFrequency|

	EXPORT	|AccessPMUReg|

  00000			 AREA	 |.pdata|, PDATA
|$T33469| DCD	|$LN13@AccessPMUR|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |AccessPMUReg| PROC

; 405  : {

  00000		 |$LN13@AccessPMUR|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd028	 sub         sp, sp, #0x28
  00008		 |$M33466|
  00008	e1a04003	 mov         r4, r3
  0000c	e3500000	 cmp         r0, #0

; 406  :     PMURegInfo      PMURegBuffer;
; 407  :     unsigned long   PMURegResults,
; 408  :                     nOutBytes;
; 409  :     BOOL            rtnvalue = FALSE;
; 410  :         
; 411  :     if (handle == 0)
; 412  :     {
; 413  :         return FALSE;

  00010	0a000024	 beq         |$LN4@AccessPMUR|

; 414  :     }
; 415  : 
; 416  :     PMURegBuffer.PMUReg = RegisterNumber;

  00014	e58d2014	 str         r2, [sp, #0x14]

; 417  : 
; 418  :     switch (Access)

  00018	e3510000	 cmp         r1, #0
  0001c	0a00000f	 beq         |$LN5@AccessPMUR|
  00020	e3510001	 cmp         r1, #1

; 432  :         }
; 433  : 
; 434  :         break;
; 435  :     case WRITE:
; 436  :         PMURegBuffer.subcode = PMU_WRITE_REG;
; 437  :         PMURegBuffer.PMUValue = *pValue;
; 438  : 
; 439  :         rtnvalue = 
; 440  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 441  :                              &PMURegResults, sizeof(PMURegResults), &nOutBytes);
; 442  :         break;
; 443  :     default:
; 444  :         return FALSE;

  00024	1a00001f	 bne         |$LN4@AccessPMUR|
  00028	e5943000	 ldr         r3, [r4]
  0002c	e59f0084	 ldr         r0, [pc, #0x84]
  00030	e3a04006	 mov         r4, #6
  00034	e58d3018	 str         r3, [sp, #0x18]
  00038	e28de008	 add         lr, sp, #8
  0003c	e3a05004	 mov         r5, #4
  00040	e28d300c	 add         r3, sp, #0xC
  00044	e3a02018	 mov         r2, #0x18
  00048	e28d1010	 add         r1, sp, #0x10
  0004c	e58d4010	 str         r4, [sp, #0x10]
  00050	e58de004	 str         lr, [sp, #4]
  00054	e58d5000	 str         r5, [sp]
  00058	eb000000	 bl          KernelIoControl
  0005c	ea000012	 b           |$LN3@AccessPMUR|
  00060		 |$LN5@AccessPMUR|

; 419  :     {
; 420  :     case READ:
; 421  :         PMURegBuffer.subcode = PMU_READ_REG;
; 422  :         rtnvalue = 
; 423  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 424  :                              &PMURegResults, sizeof(PMURegResults), &nOutBytes);

  00060	e59f0050	 ldr         r0, [pc, #0x50]
  00064	e3a05005	 mov         r5, #5
  00068	e28de008	 add         lr, sp, #8
  0006c	e3a06004	 mov         r6, #4
  00070	e28d300c	 add         r3, sp, #0xC
  00074	e3a02018	 mov         r2, #0x18
  00078	e28d1010	 add         r1, sp, #0x10
  0007c	e58d5010	 str         r5, [sp, #0x10]
  00080	e58de004	 str         lr, [sp, #4]
  00084	e58d6000	 str         r6, [sp]
  00088	eb000000	 bl          KernelIoControl
  0008c	e3500000	 cmp         r0, #0

; 425  :         if (rtnvalue && (nOutBytes == sizeof(unsigned long)))

  00090	0a000004	 beq         |$LN4@AccessPMUR|
  00094	e59d3008	 ldr         r3, [sp, #8]
  00098	e3530004	 cmp         r3, #4

; 426  :         {
; 427  :             *pValue = PMURegResults;

  0009c	059d300c	 ldreq       r3, [sp, #0xC]
  000a0	05843000	 streq       r3, [r4]
  000a4	0a000000	 beq         |$LN3@AccessPMUR|
  000a8		 |$LN4@AccessPMUR|

; 428  :         }
; 429  :         else
; 430  :         {
; 431  :             rtnvalue = FALSE;

  000a8	e3a00000	 mov         r0, #0
  000ac		 |$LN3@AccessPMUR|

; 445  :         break;
; 446  : 
; 447  :     }
; 448  : 
; 449  :     return rtnvalue;
; 450  : }

  000ac	e28dd028	 add         sp, sp, #0x28
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN14@AccessPMUR|
  000b8		 |$LN15@AccessPMUR|
  000b8	01013e80	 DCD         0x1013e80
  000bc		 |$M33467|

			 ENDP  ; |AccessPMUReg|

	EXPORT	|GetCPUId|

  00000			 AREA	 |.pdata|, PDATA
|$T33482| DCD	|$LN7@GetCPUId|
	DCD	0x40001802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCPUId| PROC

; 463  : {

  00000		 |$LN7@GetCPUId|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M33479|
  00008	e1a04000	 mov         r4, r0

; 464  :     CPUIdInfo       CPUIdBuffer;
; 465  :     unsigned long   CPUIdResults,
; 466  :                     nOutBytes;
; 467  :     BOOL            rtnvalue = FALSE;
; 468  : 
; 469  :     rtnvalue = 
; 470  :         KernelIoControl (IOCTL_GET_CPU_ID, (void *)&CPUIdBuffer, sizeof(CPUIdInfo), 
; 471  :                          &CPUIdResults, sizeof(CPUIdResults), &nOutBytes);

  0000c	e59f0048	 ldr         r0, [pc, #0x48]
  00010	e28de008	 add         lr, sp, #8
  00014	e3a05004	 mov         r5, #4
  00018	e28d300c	 add         r3, sp, #0xC
  0001c	e3a02004	 mov         r2, #4
  00020	e28d1010	 add         r1, sp, #0x10
  00024	e58de004	 str         lr, [sp, #4]
  00028	e58d5000	 str         r5, [sp]
  0002c	eb000000	 bl          KernelIoControl
  00030	e3500000	 cmp         r0, #0

; 472  :     if (rtnvalue && (nOutBytes == sizeof(unsigned long)))

  00034	0a000004	 beq         |$LN2@GetCPUId|
  00038	e59d3008	 ldr         r3, [sp, #8]
  0003c	e3530004	 cmp         r3, #4

; 473  :     {
; 474  :         *CPUId = CPUIdResults;

  00040	059d300c	 ldreq       r3, [sp, #0xC]
  00044	05843000	 streq       r3, [r4]
  00048	0a000000	 beq         |$LN1@GetCPUId|
  0004c		 |$LN2@GetCPUId|

; 475  :     }
; 476  :     else
; 477  :     {
; 478  :         rtnvalue = FALSE;

  0004c	e3a00000	 mov         r0, #0
  00050		 |$LN1@GetCPUId|

; 479  :     }
; 480  : 
; 481  :     return rtnvalue;
; 482  : 
; 483  : }

  00050	e28dd014	 add         sp, sp, #0x14
  00054	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN8@GetCPUId|
  0005c		 |$LN9@GetCPUId|
  0005c	01013e84	 DCD         0x1013e84
  00060		 |$M33480|

			 ENDP  ; |GetCPUId|

	EXPORT	|GetOEMConfigData|

  00000			 AREA	 |.pdata|, PDATA
|$T33497| DCD	|$LN8@GetOEMConf|
	DCD	0x40002602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetOEMConfigData| PROC

; 502  : {

  00000		 |$LN8@GetOEMConf|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd02c	 sub         sp, sp, #0x2C
  00008		 |$M33494|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a05000	 mov         r5, r0

; 503  :     OEMInfo         OEMBuffer;
; 504  :     PMURegInfo      PMURegBuffer;
; 505  :     unsigned long   nOutBytes;
; 506  :     BOOL            rtnvalue = FALSE;
; 507  : 
; 508  :     PMURegBuffer.subcode = PMU_OEM_INFO;
; 509  :     rtnvalue = 
; 510  :         KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 511  :                      &OEMBuffer, sizeof(OEMInfo), &nOutBytes);

  00014	e59f0078	 ldr         r0, [pc, #0x78]
  00018	e3a07009	 mov         r7, #9
  0001c	e28de008	 add         lr, sp, #8
  00020	e3a08008	 mov         r8, #8
  00024	e28d300c	 add         r3, sp, #0xC
  00028	e3a02018	 mov         r2, #0x18
  0002c	e28d1014	 add         r1, sp, #0x14
  00030	e58d7014	 str         r7, [sp, #0x14]
  00034	e58de004	 str         lr, [sp, #4]
  00038	e58d8000	 str         r8, [sp]
  0003c	eb000000	 bl          KernelIoControl
  00040	e3500000	 cmp         r0, #0

; 512  : 
; 513  :     if (rtnvalue && ((nOutBytes != sizeof(OEMInfo) || 
; 514  :         (nOutBytes > (maxItems*sizeof(unsigned long))))))

  00044	0a000009	 beq         |$LN3@GetOEMConf|
  00048	e59d3008	 ldr         r3, [sp, #8]
  0004c	e3530008	 cmp         r3, #8
  00050	1a000002	 bne         |$LN2@GetOEMConf|
  00054	e1a03106	 mov         r3, r6, lsl #2
  00058	e3530008	 cmp         r3, #8
  0005c	2a000003	 bcs         |$LN3@GetOEMConf|
  00060		 |$LN2@GetOEMConf|

; 515  :     {
; 516  :         rtnvalue = FALSE;
; 517  :         *nOutItems = 0;

  00060	e3a03000	 mov         r3, #0
  00064	e5843000	 str         r3, [r4]
  00068	e3a00000	 mov         r0, #0

; 518  :     }
; 519  :     else

  0006c	ea000005	 b           |$LN1@GetOEMConf|
  00070		 |$LN3@GetOEMConf|

; 520  :     {
; 521  :         configArray[0] = OEMBuffer.sysintrID;

  00070	e59d300c	 ldr         r3, [sp, #0xC]

; 522  :         configArray[1] = OEMBuffer.PMUglobals;

  00074	e59d2010	 ldr         r2, [sp, #0x10]

; 523  :         *nOutItems = 2;

  00078	e3a01002	 mov         r1, #2
  0007c	e5853000	 str         r3, [r5]
  00080	e5852004	 str         r2, [r5, #4]
  00084	e5841000	 str         r1, [r4]
  00088		 |$LN1@GetOEMConf|

; 524  :    }
; 525  : 
; 526  :     return rtnvalue;
; 527  : 
; 528  : }

  00088	e28dd02c	 add         sp, sp, #0x2C
  0008c	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN9@GetOEMConf|
  00094		 |$LN10@GetOEMConf|
  00094	01013e80	 DCD         0x1013e80
  00098		 |$M33495|

			 ENDP  ; |GetOEMConfigData|

	EXPORT	|ReleasePMUResources|
	IMPORT	|free|
	IMPORT	|ReleaseSemaphore|

  00000			 AREA	 |.pdata|, PDATA
|$T33510| DCD	|$LN6@ReleasePMU|
	DCD	0x40002502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReleasePMUResources| PROC

; 134  : {   

  00000		 |$LN6@ReleasePMU|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M33507|
  00008	e1b06000	 movs        r6, r0

; 135  :     PMURegInfo  PMURegBuffer;
; 136  :     BOOL        rtnvalue = FALSE;
; 137  : 
; 138  :     if (handle == 0)
; 139  :     {
; 140  :         return FALSE;

  0000c	03a05000	 moveq       r5, #0
  00010	0a000019	 beq         |$LN2@ReleasePMU|

; 141  :     }
; 142  : 
; 143  :     //
; 144  :     // Remove Interrupt callback
; 145  :     //
; 146  :     RemovePMUInterruptCallback(handle);

  00014	e1a00006	 mov         r0, r6
  00018	eb000000	 bl          RemovePMUInterruptCallback

; 147  : 
; 148  :     //
; 149  :     // Remove lock, if any, and release CCF callback
; 150  :     //
; 151  :     UnlockAndRestoreCoreClockFrequency(handle);

  0001c	e1a00006	 mov         r0, r6
  00020	eb000000	 bl          UnlockAndRestoreCoreClockFrequency

; 152  : 
; 153  :     //
; 154  :     // Null local copy
; 155  :     //
; 156  :     PVTuneReleasePMU = NULL;

  00024	e59f4064	 ldr         r4, [pc, #0x64]

; 157  : 
; 158  :     //
; 159  :     // Unregister ReleasePMU callback in kernel
; 160  :     //
; 161  :     PMURegBuffer.subcode = PMU_RELEASE;
; 162  :     rtnvalue = 
; 163  :             KernelIoControl (IOCTL_PMU_CONFIG, (void *)&PMURegBuffer, sizeof(PMURegInfo), 
; 164  :                              (LPVOID)NULL, 0, (LPDWORD)NULL);

  00028	e59f005c	 ldr         r0, [pc, #0x5C]
  0002c	e3a03000	 mov         r3, #0
  00030	e5843008	 str         r3, [r4, #8]
  00034	e3a0e008	 mov         lr, #8
  00038	e3a05000	 mov         r5, #0
  0003c	e3a03000	 mov         r3, #0
  00040	e3a02018	 mov         r2, #0x18
  00044	e28d1008	 add         r1, sp, #8
  00048	e58de008	 str         lr, [sp, #8]
  0004c	e58d5004	 str         r5, [sp, #4]
  00050	e58d5000	 str         r5, [sp]
  00054	eb000000	 bl          KernelIoControl
  00058	e1a05000	 mov         r5, r0

; 165  : 
; 166  :     //
; 167  :     // Release resource, NULL handle
; 168  :     //
; 169  :     ReleaseSemaphore(semHandle, 1, NULL);

  0005c	e5940000	 ldr         r0, [r4]
  00060	e3a02000	 mov         r2, #0
  00064	e3a01001	 mov         r1, #1
  00068	eb000000	 bl          ReleaseSemaphore

; 170  :     CloseHandle(semHandle);

  0006c	e5940000	 ldr         r0, [r4]
  00070	eb000000	 bl          CloseHandle

; 171  :     free ((PMUHResource*) handle);

  00074	e1a00006	 mov         r0, r6
  00078	eb000000	 bl          free
  0007c		 |$LN2@ReleasePMU|

; 172  :     handle = 0;
; 173  : 
; 174  :     return rtnvalue;
; 175  : }

  0007c	e1a00005	 mov         r0, r5
  00080	e28dd020	 add         sp, sp, #0x20
  00084	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN7@ReleasePMU|
  0008c		 |$LN8@ReleasePMU|
  0008c	01013e80	 DCD         0x1013e80
  00090		 |$LN9@ReleasePMU|
  00090	00000000	 DCD         |semHandle|
  00094		 |$M33508|

			 ENDP  ; |ReleasePMUResources|

	END
