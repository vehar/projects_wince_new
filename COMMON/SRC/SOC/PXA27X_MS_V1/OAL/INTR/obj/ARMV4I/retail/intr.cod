; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\OAL\INTR\intr.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|g_pProfilerISR| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|g_pProfilerISR| % 0x4
|g_pGpioRegs| %	0x4
|g_pICReg| %	0x4

  00000			 AREA	 |.data|, DATA
|g_IntPriorities| DCD 0x1a
	DCD	0xc
	DCD	0x1c
	DCD	0x1d
	DCD	0x9
	DCD	0x1f
	DCD	0x1
	DCD	0x19
	DCD	0x20
	DCD	0x21
	DCD	0xb
	DCD	0x3
	DCD	0x2
	DCD	0x7
	DCD	0x16
	DCD	0x14
	DCD	0x15
	DCD	0xe
	DCD	0x1b
	DCD	0x8
	DCD	0x17
	DCD	0x5
	DCD	0xf
	DCD	0xa
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
|g_IntPriorities2| DCD 0x0
	DCD	0x4
	EXPORT	|OALIntrInit|
	EXPORT	|??_C@_1DK@JEFKKIKI@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@LJHDCJDG@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OALIntrStaticTranslate|
	IMPORT	|BSPIntrInit|
	IMPORT	|OALPAtoVA|
	IMPORT	|OALIntrMapInit|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\oal\intr\intr.c

  00000			 AREA	 |.pdata|, PDATA
|$T43434| DCD	|$LN14@OALIntrIni|
	DCD	0x40003d01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@JEFKKIKI@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "(", 0x0, "r"
	DCB	0x0, "c", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@LJHDCJDG@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t"
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIntrInit| PROC

; 106  : {

  00000		 |$LN14@OALIntrIni|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M43431|

; 107  :     BOOL rc = FALSE;
; 108  :     UINT8 nIntPrio;
; 109  :     
; 110  :     OALMSG( OAL_FUNC&&OAL_INTR, (L"+OALInterruptInit\r\n") );

  00004	e59f50e4	 ldr         r5, [pc, #0xE4]
  00008	e5953440	 ldr         r3, [r5, #0x440]
  0000c	e3130004	 tst         r3, #4
  00010	13130901	 tstne       r3, #1, 18
  00014	159f00d0	 ldrne       r0, [pc, #0xD0]
  00018	1b000000	 blne        NKDbgPrintfW

; 111  : 
; 112  :     // Initialize interrupt mapping
; 113  :     OALIntrMapInit();

  0001c	eb000000	 bl          OALIntrMapInit
  00020	e3a06101	 mov         r6, #1, 2

; 114  : 
; 115  :     // Map a pointer to the GPIO regs
; 116  :     //
; 117  :     g_pGpioRegs  = (volatile BULVERDE_GPIO_REG *) OALPAtoUA(BULVERDE_BASE_REG_PA_GPIO);

  00024	e386060e	 orr         r0, r6, #0xE, 12
  00028	e3a01000	 mov         r1, #0
  0002c	eb000000	 bl          OALPAtoVA
  00030	e59f40b0	 ldr         r4, [pc, #0xB0]

; 118  : 
; 119  :     // Map a pointer to the interrupt controller.
; 120  :     //
; 121  :     g_pICReg = (volatile BULVERDE_INTR_REG *) OALPAtoVA(BULVERDE_BASE_REG_PA_INTC, FALSE);

  00034	e3a01000	 mov         r1, #0
  00038	e5840000	 str         r0, [r4]
  0003c	e386060d	 orr         r0, r6, #0xD, 12
  00040	eb000000	 bl          OALPAtoVA
  00044	e5840004	 str         r0, [r4, #4]

; 122  : 
; 123  :     // Configure interrupt priorities.
; 124  :     //
; 125  :     for (nIntPrio = 0 ; nIntPrio < NUM_INT_PRIOS ; nIntPrio++)

  00048	e59f4094	 ldr         r4, [pc, #0x94]
  0004c	e3a02000	 mov         r2, #0
  00050	e3a01000	 mov         r1, #0
  00054		 |$LL3@OALIntrIni|

; 126  :     {
; 127  :         g_pICReg->ipr[nIntPrio] = ((1 << 31) | g_IntPriorities[nIntPrio]);

  00054	e7943102	 ldr         r3, [r4, +r2, lsl #2]
  00058	e2822007	 add         r2, r2, #7
  0005c	e2811001	 add         r1, r1, #1
  00060	e383e102	 orr         lr, r3, #2, 2
  00064	e0803102	 add         r3, r0, r2, lsl #2
  00068	e20120ff	 and         r2, r1, #0xFF
  0006c	e1a01002	 mov         r1, r2
  00070	e3520020	 cmp         r2, #0x20
  00074	e583e000	 str         lr, [r3]
  00078	3afffff5	 bcc         |$LL3@OALIntrIni|

; 128  :     }
; 129  :     g_pICReg->ipr2[0] = ((1 << 31) | g_IntPriorities2[0]);

  0007c	e5943080	 ldr         r3, [r4, #0x80]

; 130  :     g_pICReg->ipr2[1] = ((1 << 31) | g_IntPriorities2[1]);
; 131  : 
; 132  :     //
; 133  :     // Set DIM, the only bit in the ICCR.  
; 134  :     // The effect is that only enabled and unmasked
; 135  :     // interrupts bring the processor out of IDLE mode.
; 136  :     //
; 137  :     g_pICReg->iccr = 0x1;

  00080	e3a02001	 mov         r2, #1
  00084	e3833102	 orr         r3, r3, #2, 2
  00088	e58030b0	 str         r3, [r0, #0xB0]
  0008c	e5943084	 ldr         r3, [r4, #0x84]
  00090	e3833102	 orr         r3, r3, #2, 2
  00094	e58030b4	 str         r3, [r0, #0xB4]
  00098	e5802014	 str         r2, [r0, #0x14]

; 138  : 
; 139  : #ifdef OAL_BSP_CALLBACKS
; 140  :     // Give BSP change to initialize subordinate controller
; 141  :     rc = BSPIntrInit();

  0009c	eb000000	 bl          BSPIntrInit
  000a0	e1a04000	 mov         r4, r0

; 142  : #else
; 143  :     rc = TRUE;
; 144  : #endif
; 145  : 
; 146  :     // Setup static interrupt mappings (first one isn't really needed)
; 147  :     OALIntrStaticTranslate(SYSINTR_RESCHED, IRQ_OSMR0);

  000a4	e3a00001	 mov         r0, #1
  000a8	e3a0101a	 mov         r1, #0x1A
  000ac	eb000000	 bl          OALIntrStaticTranslate

; 148  :     OALIntrStaticTranslate(SYSINTR_RTC_ALARM, IRQ_RTCALARM);

  000b0	e3a0101f	 mov         r1, #0x1F
  000b4	e3a0000d	 mov         r0, #0xD
  000b8	eb000000	 bl          OALIntrStaticTranslate

; 149  : 
; 150  :     OALMSG(OAL_INTR&&OAL_FUNC, (L"-OALInterruptInit(rc = %d)\r\n", rc));

  000bc	e5953440	 ldr         r3, [r5, #0x440]
  000c0	e3130901	 tst         r3, #1, 18
  000c4	13130004	 tstne       r3, #4
  000c8	159f0010	 ldrne       r0, [pc, #0x10]
  000cc	11a01004	 movne       r1, r4
  000d0	1b000000	 blne        NKDbgPrintfW

; 151  :     return rc;
; 152  : }

  000d4	e1a00004	 mov         r0, r4
  000d8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN15@OALIntrIni|
  000e0		 |$LN16@OALIntrIni|
  000e0	00000000	 DCD         |??_C@_1DK@JEFKKIKI@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000e4		 |$LN17@OALIntrIni|
  000e4	00000000	 DCD         |g_IntPriorities|
  000e8		 |$LN18@OALIntrIni|
  000e8	00000000	 DCD         |g_pGpioRegs|
  000ec		 |$LN19@OALIntrIni|
  000ec	00000000	 DCD         |??_C@_1CI@LJHDCJDG@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  000f0		 |$LN20@OALIntrIni|
  000f0	00000000	 DCD         |dpCurSettings|
  000f4		 |$M43432|

			 ENDP  ; |OALIntrInit|

	EXPORT	|OALIntrRequestIrqs|
	EXPORT	|??_C@_1DO@NDIEKHNP@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HO@EBPJKEJJ@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?1?$AA?$CF@| [ DATA ] ; `string'
	IMPORT	|BSPIntrRequestIrqs|

  00000			 AREA	 |.pdata|, PDATA
|$T43457| DCD	|$LN10@OALIntrReq|
	DCD	0x40002d02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@NDIEKHNP@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "R", 0x0, "e", 0x0, "q", 0x0, "u", 0x0, "e"
	DCB	0x0, "s", 0x0, "t", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, "s"
	DCB	0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HO@EBPJKEJJ@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?1?$AA?$CF@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "R", 0x0, "e", 0x0, "q", 0x0, "u", 0x0, "e"
	DCB	0x0, "s", 0x0, "t", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, "s"
	DCB	0x0, "(", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8"
	DCB	0x0, "x", 0x0, "-", 0x0, ">", 0x0, "%", 0x0, "d", 0x0, "/"
	DCB	0x0, "%", 0x0, "d", 0x0, "/", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "0", 0x0, "8", 0x0, "x", 0x0, "/", 0x0, "%", 0x0, "d"
	DCB	0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "x", 0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIntrRequestIrqs| PROC

; 164  : {

  00000		 |$LN10@OALIntrReq|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M43454|
  00008	e1a09002	 mov         r9, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a07000	 mov         r7, r0

; 165  :     BOOL rc = FALSE;
; 166  : 
; 167  :     OALMSG(OAL_INTR&&OAL_FUNC, (
; 168  :         L"+OALIntrRequestIrqs(0x%08x->%d/%d/0x%08x/%d, 0x%08x, 0x%08x)\r\n",
; 169  :         pDevLoc, pDevLoc->IfcType, pDevLoc->BusNumber, pDevLoc->LogicalLoc,
; 170  :         pDevLoc->Pin, pCount, pIrqs
; 171  :     ));

  00014	e59f8094	 ldr         r8, [pc, #0x94]
  00018	e3a05000	 mov         r5, #0
  0001c	e598e440	 ldr         lr, [r8, #0x440]
  00020	e31e0901	 tst         lr, #1, 18
  00024	0a00000d	 beq         |$LN4@OALIntrReq|
  00028	e31e0004	 tst         lr, #4
  0002c	0a00000b	 beq         |$LN4@OALIntrReq|
  00030	e597e010	 ldr         lr, [r7, #0x10]
  00034	e5974008	 ldr         r4, [r7, #8]
  00038	e5973004	 ldr         r3, [r7, #4]
  0003c	e5972000	 ldr         r2, [r7]
  00040	e59f0064	 ldr         r0, [pc, #0x64]
  00044	e1a01007	 mov         r1, r7
  00048	e58de004	 str         lr, [sp, #4]
  0004c	e58d4000	 str         r4, [sp]
  00050	e58d900c	 str         r9, [sp, #0xC]
  00054	e58d6008	 str         r6, [sp, #8]
  00058	eb000000	 bl          NKDbgPrintfW
  0005c	e598e440	 ldr         lr, [r8, #0x440]
  00060		 |$LN4@OALIntrReq|

; 172  : 
; 173  :     // This shouldn't happen
; 174  :     if (*pCount < 1) goto cleanUp;

  00060	e5963000	 ldr         r3, [r6]
  00064	e3530001	 cmp         r3, #1
  00068	3a000005	 bcc         |$cleanUp$43162|

; 175  : 
; 176  : #ifdef OAL_BSP_CALLBACKS
; 177  :     rc = BSPIntrRequestIrqs(pDevLoc, pCount, pIrqs);

  0006c	e1a02009	 mov         r2, r9
  00070	e1a01006	 mov         r1, r6
  00074	e1a00007	 mov         r0, r7
  00078	eb000000	 bl          BSPIntrRequestIrqs
  0007c	e598e440	 ldr         lr, [r8, #0x440]
  00080	e1a05000	 mov         r5, r0
  00084		 |$cleanUp$43162|

; 178  : #endif    
; 179  : 
; 180  : cleanUp:        
; 181  :     OALMSG(OAL_INTR&&OAL_FUNC, (L"-OALIntrRequestIrqs(rc = %d)\r\n", rc));

  00084	e31e0901	 tst         lr, #1, 18
  00088	131e0004	 tstne       lr, #4
  0008c	159f0014	 ldrne       r0, [pc, #0x14]
  00090	11a01005	 movne       r1, r5
  00094	1b000000	 blne        NKDbgPrintfW

; 182  :     return rc;
; 183  : }

  00098	e1a00005	 mov         r0, r5
  0009c	e28dd010	 add         sp, sp, #0x10
  000a0	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN11@OALIntrReq|
  000a8		 |$LN12@OALIntrReq|
  000a8	00000000	 DCD         |??_C@_1DO@NDIEKHNP@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000ac		 |$LN13@OALIntrReq|
  000ac	00000000	 DCD         |??_C@_1HO@EBPJKEJJ@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?9?$AA?$DO?$AA?$CF?$AAd?$AA?1?$AA?$CF@|
  000b0		 |$LN14@OALIntrReq|
  000b0	00000000	 DCD         |dpCurSettings|
  000b4		 |$M43455|

			 ENDP  ; |OALIntrRequestIrqs|

	EXPORT	|OALIntrEnableIrqs|
	EXPORT	|??_C@_1DM@INNHDHDJ@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EC@MDFPIGAB@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6@| [ DATA ] ; `string'
	IMPORT	|BSPIntrEnableIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T43481| DCD	|$LN22@OALIntrEna|
	DCD	0x40003d01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DM@INNHDHDJ@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "E", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l"
	DCB	0x0, "e", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, "s", 0x0, "("
	DCB	0x0, "r", 0x0, "c", 0x0, " ", 0x0, "=", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EC@MDFPIGAB@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "E", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l"
	DCB	0x0, "e", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, "s", 0x0, "("
	DCB	0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x"
	DCB	0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ")", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIntrEnableIrqs| PROC

; 191  : {

  00000		 |$LN22@OALIntrEna|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M43478|
  00004	e1a06001	 mov         r6, r1
  00008	e1a05000	 mov         r5, r0

; 192  :     BOOL rc = TRUE;
; 193  :     UINT32 irq, i;
; 194  : 
; 195  : 
; 196  :     OALMSG(OAL_INTR&&OAL_FUNC, (
; 197  :         L"+OALIntrEnableIrqs(%d, 0x%08x)\r\n", count, pIrqs
; 198  :     ));

  0000c	e59f70dc	 ldr         r7, [pc, #0xDC]
  00010	e3a04001	 mov         r4, #1
  00014	e5973440	 ldr         r3, [r7, #0x440]
  00018	e3130901	 tst         r3, #1, 18
  0001c	0a000006	 beq         |$LN13@OALIntrEna|
  00020	e3130004	 tst         r3, #4
  00024	0a000004	 beq         |$LN13@OALIntrEna|
  00028	e59f00bc	 ldr         r0, [pc, #0xBC]
  0002c	e1a02006	 mov         r2, r6
  00030	e1a01005	 mov         r1, r5
  00034	eb000000	 bl          NKDbgPrintfW
  00038	e5973440	 ldr         r3, [r7, #0x440]
  0003c		 |$LN13@OALIntrEna|

; 199  :     
; 200  :     for (i = 0; i < count; i++) {

  0003c	e3550000	 cmp         r5, #0
  00040	0a00001f	 beq         |$LN8@OALIntrEna|
  00044	e59f809c	 ldr         r8, [pc, #0x9C]
  00048	e3a09001	 mov         r9, #1
  0004c	e3a0a001	 mov         r10, #1
  00050		 |$LL10@OALIntrEna|

; 201  : #ifndef OAL_BSP_CALLBACKS
; 202  :         irq = pIrqs[i];
; 203  : #else
; 204  :         // Give BSP chance to enable irq on subordinate interrupt controller
; 205  :         irq = BSPIntrEnableIrq(pIrqs[i]);

  00050	e5960000	 ldr         r0, [r6]
  00054	eb000000	 bl          BSPIntrEnableIrq

; 206  :         if (irq == OAL_INTR_IRQ_UNDEFINED) continue;

  00058	e3700001	 cmn         r0, #1
  0005c	0a000014	 beq         |$LN9@OALIntrEna|

; 207  : #endif
; 208  :         if (irq <= IRQ_RTCALARM) {

  00060	e350001f	 cmp         r0, #0x1F

; 209  :             // Enable the primary IRQ
; 210  :             SETREG32(&g_pICReg->icmr, (1 << irq));

  00064	95982000	 ldrls       r2, [r8]
  00068	95923004	 ldrls       r3, [r2, #4]
  0006c	91833019	 orrls       r3, r3, r9, lsl r0

; 211  :         }
; 212  :         else if ((irq >= IRQ_WTM) && (irq <= IRQ_CAMQCKCAP))
; 213  :         {
; 214  :             SETREG32(&g_pICReg->icmr2, (1 << (irq - IRQ_WTM)));
; 215  :         }
; 216  :         else if (irq >= IRQ_GPIOXX_2_GPIOMIN && irq <= IRQ_GPIOXX_2_GPIOMAX) {
; 217  :             //Enable IRQ_GPIOXX_2
; 218  :             SETREG32(&g_pICReg->icmr, (1 << IRQ_GPIOXX_2));

  00070	95823004	 strls       r3, [r2, #4]
  00074	9a00000e	 bls         |$LN9@OALIntrEna|
  00078	e2403020	 sub         r3, r0, #0x20
  0007c	e3530001	 cmp         r3, #1
  00080	95981000	 ldrls       r1, [r8]
  00084	92402020	 subls       r2, r0, #0x20
  00088	959130a0	 ldrls       r3, [r1, #0xA0]
  0008c	9183321a	 orrls       r3, r3, r10, lsl r2
  00090	958130a0	 strls       r3, [r1, #0xA0]
  00094	9a000006	 bls         |$LN9@OALIntrEna|
  00098	e2403064	 sub         r3, r0, #0x64
  0009c	e3530076	 cmp         r3, #0x76
  000a0	95982000	 ldrls       r2, [r8]

; 219  :             //Note: To actually enable this GPIO irq generation make sure
; 220  :             //the corresponding GRERx/GFERx bits are also set
; 221  :         } else {
; 222  :             rc = FALSE;

  000a4	83a04000	 movhi       r4, #0
  000a8	95923004	 ldrls       r3, [r2, #4]
  000ac	93833b01	 orrls       r3, r3, #1, 22
  000b0	95823004	 strls       r3, [r2, #4]
  000b4		 |$LN9@OALIntrEna|
  000b4	e2866004	 add         r6, r6, #4
  000b8	e2555001	 subs        r5, r5, #1
  000bc	1affffe3	 bne         |$LL10@OALIntrEna|

; 199  :     
; 200  :     for (i = 0; i < count; i++) {

  000c0	e5973440	 ldr         r3, [r7, #0x440]
  000c4		 |$LN8@OALIntrEna|

; 223  :         }            
; 224  :     }
; 225  : 
; 226  :     OALMSG(OAL_INTR&&OAL_FUNC, (L"-OALIntrEnableIrqs(rc = %d)\r\n", rc));

  000c4	e3130901	 tst         r3, #1, 18
  000c8	13130004	 tstne       r3, #4
  000cc	159f0010	 ldrne       r0, [pc, #0x10]
  000d0	11a01004	 movne       r1, r4
  000d4	1b000000	 blne        NKDbgPrintfW

; 227  :     return rc;    
; 228  : }

  000d8	e1a00004	 mov         r0, r4
  000dc	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$LN23@OALIntrEna|
  000e4		 |$LN24@OALIntrEna|
  000e4	00000000	 DCD         |??_C@_1DM@INNHDHDJ@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000e8		 |$LN25@OALIntrEna|
  000e8	00000000	 DCD         |g_pICReg|
  000ec		 |$LN26@OALIntrEna|
  000ec	00000000	 DCD         |??_C@_1EC@MDFPIGAB@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6@|
  000f0		 |$LN27@OALIntrEna|
  000f0	00000000	 DCD         |dpCurSettings|
  000f4		 |$M43479|

			 ENDP  ; |OALIntrEnableIrqs|

	EXPORT	|OALIntrDoneIrqs|
	EXPORT	|??_C@_1CG@LBOJEJPE@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAo?$AAn?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DO@FCJPHKGC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAo?$AAn?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|BSPIntrDoneIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T43502| DCD	|$LN18@OALIntrDon|
	DCD	0x40003201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@LBOJEJPE@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAo?$AAn?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "D", 0x0, "o", 0x0, "n", 0x0, "e", 0x0, "I"
	DCB	0x0, "r", 0x0, "q", 0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@FCJPHKGC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAo?$AAn?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "D", 0x0, "o", 0x0, "n", 0x0, "e", 0x0, "I"
	DCB	0x0, "r", 0x0, "q", 0x0, "s", 0x0, "(", 0x0, "%", 0x0, "d"
	DCB	0x0, ",", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%", 0x0, "0"
	DCB	0x0, "8", 0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIntrDoneIrqs| PROC

; 275  : {

  00000		 |$LN18@OALIntrDon|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M43499|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 276  :     UINT32 irq, i;
; 277  : 
; 278  :     OALMSG(OAL_INTR&&OAL_VERBOSE, (
; 279  :         L"+OALIntrDoneIrqs(%d, 0x%08x)\r\n", count, pIrqs
; 280  :     ));

  0000c	e59f60b0	 ldr         r6, [pc, #0xB0]
  00010	e5963440	 ldr         r3, [r6, #0x440]
  00014	e3130901	 tst         r3, #1, 18
  00018	0a000006	 beq         |$LN10@OALIntrDon|
  0001c	e3130902	 tst         r3, #2, 18
  00020	0a000004	 beq         |$LN10@OALIntrDon|
  00024	e59f0094	 ldr         r0, [pc, #0x94]
  00028	e1a02005	 mov         r2, r5
  0002c	e1a01004	 mov         r1, r4
  00030	eb000000	 bl          NKDbgPrintfW
  00034	e5963440	 ldr         r3, [r6, #0x440]
  00038		 |$LN10@OALIntrDon|

; 281  : 
; 282  :     for (i = 0; i < count; i++) {

  00038	e3540000	 cmp         r4, #0
  0003c	0a000017	 beq         |$LN5@OALIntrDon|
  00040	e59f7074	 ldr         r7, [pc, #0x74]
  00044	e3a08001	 mov         r8, #1
  00048	e3a09001	 mov         r9, #1
  0004c		 |$LL7@OALIntrDon|

; 283  : #ifndef OAL_BSP_CALLBACKS
; 284  :         irq = pIrqs[i];
; 285  : #else
; 286  :         // Give BSP chance to finish irq on subordinate interrupt controller
; 287  :         irq = BSPIntrDoneIrq(pIrqs[i]);

  0004c	e5950000	 ldr         r0, [r5]
  00050	eb000000	 bl          BSPIntrDoneIrq

; 288  :         if (irq == OAL_INTR_IRQ_UNDEFINED) continue;

  00054	e3700001	 cmn         r0, #1
  00058	0a00000c	 beq         |$LN6@OALIntrDon|

; 289  : #endif
; 290  :         if (irq <= IRQ_RTCALARM) {

  0005c	e350001f	 cmp         r0, #0x1F

; 291  :             // Enable the primary IRQ
; 292  :             SETREG32(&g_pICReg->icmr, (1 << irq));

  00060	95972000	 ldrls       r2, [r7]
  00064	95923004	 ldrls       r3, [r2, #4]
  00068	91833018	 orrls       r3, r3, r8, lsl r0
  0006c	95823004	 strls       r3, [r2, #4]
  00070	9a000006	 bls         |$LN6@OALIntrDon|

; 293  :         }            
; 294  :         else if ((irq >= IRQ_WTM) && (irq <= IRQ_CAMQCKCAP))

  00074	e2403020	 sub         r3, r0, #0x20
  00078	e3530001	 cmp         r3, #1

; 295  :         {
; 296  :             SETREG32(&g_pICReg->icmr2, (1 << (irq - IRQ_WTM)));

  0007c	95971000	 ldrls       r1, [r7]
  00080	92402020	 subls       r2, r0, #0x20
  00084	959130a0	 ldrls       r3, [r1, #0xA0]
  00088	91833219	 orrls       r3, r3, r9, lsl r2
  0008c	958130a0	 strls       r3, [r1, #0xA0]
  00090		 |$LN6@OALIntrDon|
  00090	e2855004	 add         r5, r5, #4
  00094	e2544001	 subs        r4, r4, #1
  00098	1affffeb	 bne         |$LL7@OALIntrDon|

; 281  : 
; 282  :     for (i = 0; i < count; i++) {

  0009c	e5963440	 ldr         r3, [r6, #0x440]
  000a0		 |$LN5@OALIntrDon|

; 297  :         }
; 298  :     }
; 299  : 
; 300  :     OALMSG(OAL_INTR&&OAL_VERBOSE, (L"-OALIntrDoneIrqs\r\n"));

  000a0	e3130901	 tst         r3, #1, 18
  000a4	13130902	 tstne       r3, #2, 18
  000a8	159f0008	 ldrne       r0, [pc, #8]
  000ac	1b000000	 blne        NKDbgPrintfW

; 301  : }

  000b0	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$LN19@OALIntrDon|
  000b8		 |$LN20@OALIntrDon|
  000b8	00000000	 DCD         |??_C@_1CG@LBOJEJPE@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAo?$AAn?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$AN?$AA?6?$AA?$AA@|
  000bc		 |$LN21@OALIntrDon|
  000bc	00000000	 DCD         |g_pICReg|
  000c0		 |$LN22@OALIntrDon|
  000c0	00000000	 DCD         |??_C@_1DO@FCJPHKGC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAo?$AAn?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  000c4		 |$LN23@OALIntrDon|
  000c4	00000000	 DCD         |dpCurSettings|
  000c8		 |$M43500|

			 ENDP  ; |OALIntrDoneIrqs|

	EXPORT	|OEMInterruptHandlerFIQ|

  00000			 AREA	 |.pdata|, PDATA
|$T43514| DCD	|$LN5@OEMInterru|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMInterruptHandlerFIQ| PROC

; 462  : {

  00000		 |$LN5@OEMInterru|
  00000		 |$M43511|

; 463  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M43512|

			 ENDP  ; |OEMInterruptHandlerFIQ|

	EXPORT	|DisableGPIOIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T43522| DCD	|$LN12@DisableGPI|
	DCD	0x40003b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DisableGPIOIrq| PROC

; 470  : {

  00000		 |$LN12@DisableGPI|
  00000		 |$M43519|

; 471  :     if (IRQ_GPIOXX_2_GPIO2 <= irq && irq <= IRQ_GPIOXX_2_GPIO31) {

  00000	e2403064	 sub         r3, r0, #0x64
  00004	e353001d	 cmp         r3, #0x1D
  00008	8a00000a	 bhi         |$LN7@DisableGPI|

; 472  :         g_pGpioRegs->GFER0 &= ~(1 << (irq +2 - IRQ_GPIOXX_2_GPIO2));

  0000c	e59f30d4	 ldr         r3, [pc, #0xD4]
  00010	e2401062	 sub         r1, r0, #0x62
  00014	e3a00001	 mov         r0, #1
  00018	e5932000	 ldr         r2, [r3]
  0001c	e592303c	 ldr         r3, [r2, #0x3C]

; 473  :         g_pGpioRegs->GRER0 &= ~(1 << (irq +2 - IRQ_GPIOXX_2_GPIO2));

  00020	e1c33110	 bic         r3, r3, r0, lsl r1
  00024	e582303c	 str         r3, [r2, #0x3C]
  00028	e5923030	 ldr         r3, [r2, #0x30]
  0002c	e1c33110	 bic         r3, r3, r0, lsl r1
  00030	e5823030	 str         r3, [r2, #0x30]

; 486  :     }
; 487  : }

  00034	e12fff1e	 bx          lr
  00038		 |$LN7@DisableGPI|

; 474  :     }
; 475  :     else if (IRQ_GPIOXX_2_GPIO32 <= irq && irq <= IRQ_GPIOXX_2_GPIO63) {

  00038	e2403082	 sub         r3, r0, #0x82
  0003c	e353001f	 cmp         r3, #0x1F
  00040	8a00000a	 bhi         |$LN5@DisableGPI|

; 476  :         g_pGpioRegs->GFER1 &= ~(1 << (irq - IRQ_GPIOXX_2_GPIO32));

  00044	e59f309c	 ldr         r3, [pc, #0x9C]
  00048	e2401082	 sub         r1, r0, #0x82
  0004c	e3a00001	 mov         r0, #1
  00050	e5932000	 ldr         r2, [r3]
  00054	e5923040	 ldr         r3, [r2, #0x40]

; 477  :         g_pGpioRegs->GRER1 &= ~(1 << (irq - IRQ_GPIOXX_2_GPIO32));

  00058	e1c33110	 bic         r3, r3, r0, lsl r1
  0005c	e5823040	 str         r3, [r2, #0x40]
  00060	e5923034	 ldr         r3, [r2, #0x34]
  00064	e1c33110	 bic         r3, r3, r0, lsl r1
  00068	e5823034	 str         r3, [r2, #0x34]

; 486  :     }
; 487  : }

  0006c	e12fff1e	 bx          lr
  00070		 |$LN5@DisableGPI|

; 478  :     }
; 479  :     else if (IRQ_GPIOXX_2_GPIO64 <= irq && irq <= IRQ_GPIOXX_2_GPIO95)  {

  00070	e24030a2	 sub         r3, r0, #0xA2
  00074	e353001f	 cmp         r3, #0x1F
  00078	8a00000a	 bhi         |$LN3@DisableGPI|

; 480  :         g_pGpioRegs->GFER2 &= ~(1 << (irq - IRQ_GPIOXX_2_GPIO64));

  0007c	e59f3064	 ldr         r3, [pc, #0x64]
  00080	e24010a2	 sub         r1, r0, #0xA2
  00084	e3a00001	 mov         r0, #1
  00088	e5932000	 ldr         r2, [r3]
  0008c	e5923044	 ldr         r3, [r2, #0x44]

; 481  :         g_pGpioRegs->GRER2 &= ~(1 << (irq - IRQ_GPIOXX_2_GPIO64));

  00090	e1c33110	 bic         r3, r3, r0, lsl r1
  00094	e5823044	 str         r3, [r2, #0x44]
  00098	e5923038	 ldr         r3, [r2, #0x38]
  0009c	e1c33110	 bic         r3, r3, r0, lsl r1
  000a0	e5823038	 str         r3, [r2, #0x38]

; 486  :     }
; 487  : }

  000a4	e12fff1e	 bx          lr
  000a8		 |$LN3@DisableGPI|

; 482  :     }
; 483  :     else if (IRQ_GPIOXX_2_GPIO96 <= irq && irq <= IRQ_GPIOXX_2_GPIOMAX)  {

  000a8	e24030c2	 sub         r3, r0, #0xC2
  000ac	e3530018	 cmp         r3, #0x18
  000b0	8a00000b	 bhi         |$LN1@DisableGPI|

; 484  :         g_pGpioRegs->GFER3 &= ~(1 << (irq - IRQ_GPIOXX_2_GPIO96)) & GPIO_GFER3_VLD_MSK;

  000b4	e59f302c	 ldr         r3, [pc, #0x2C]
  000b8	e24020c2	 sub         r2, r0, #0xC2
  000bc	e3a00001	 mov         r0, #1
  000c0	e5931000	 ldr         r1, [r3]
  000c4	e591313c	 ldr         r3, [r1, #0x13C]

; 485  :         g_pGpioRegs->GRER3 &= ~(1 << (irq - IRQ_GPIOXX_2_GPIO96)) & GPIO_GRER3_VLD_MSK;

  000c8	e1c33210	 bic         r3, r3, r0, lsl r2
  000cc	e3c334fe	 bic         r3, r3, #0xFE, 8
  000d0	e581313c	 str         r3, [r1, #0x13C]
  000d4	e5913130	 ldr         r3, [r1, #0x130]
  000d8	e1c33210	 bic         r3, r3, r0, lsl r2
  000dc	e3c334fe	 bic         r3, r3, #0xFE, 8
  000e0	e5813130	 str         r3, [r1, #0x130]
  000e4		 |$LN1@DisableGPI|

; 486  :     }
; 487  : }

  000e4	e12fff1e	 bx          lr
  000e8		 |$LN13@DisableGPI|
  000e8		 |$LN14@DisableGPI|
  000e8	00000000	 DCD         |g_pGpioRegs|
  000ec		 |$M43520|

			 ENDP  ; |DisableGPIOIrq|

	EXPORT	|ClearGPIOIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T43532| DCD	|$LN12@ClearGPIOI|
	DCD	0x40002500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ClearGPIOIrq| PROC

; 494  : {

  00000		 |$LN12@ClearGPIOI|
  00000		 |$M43529|

; 495  : 
; 496  :     if (IRQ_GPIOXX_2_GPIO2 <= irq && irq <= IRQ_GPIOXX_2_GPIO31)

  00000	e2403064	 sub         r3, r0, #0x64
  00004	e353001d	 cmp         r3, #0x1D

; 497  :         g_pGpioRegs->GEDR0 = 1 << (irq +2 - IRQ_GPIOXX_2_GPIO2);

  00008	959f3080	 ldrls       r3, [pc, #0x80]
  0000c	92402062	 subls       r2, r0, #0x62
  00010	93a00001	 movls       r0, #1
  00014	95931000	 ldrls       r1, [r3]
  00018	91a03210	 movls       r3, r0, lsl r2
  0001c	95813048	 strls       r3, [r1, #0x48]

; 504  : }

  00020	912fff1e	 bxls        lr

; 498  :     else if (IRQ_GPIOXX_2_GPIO32 <= irq && irq <= IRQ_GPIOXX_2_GPIO63)

  00024	e2403082	 sub         r3, r0, #0x82
  00028	e353001f	 cmp         r3, #0x1F

; 499  :         g_pGpioRegs->GEDR1 = 1 << (irq - IRQ_GPIOXX_2_GPIO32);

  0002c	959f305c	 ldrls       r3, [pc, #0x5C]
  00030	92402082	 subls       r2, r0, #0x82
  00034	93a00001	 movls       r0, #1
  00038	95931000	 ldrls       r1, [r3]
  0003c	91a03210	 movls       r3, r0, lsl r2
  00040	9581304c	 strls       r3, [r1, #0x4C]

; 504  : }

  00044	912fff1e	 bxls        lr

; 500  :     else if (IRQ_GPIOXX_2_GPIO64 <= irq && irq <= IRQ_GPIOXX_2_GPIO95)

  00048	e24030a2	 sub         r3, r0, #0xA2
  0004c	e353001f	 cmp         r3, #0x1F

; 501  :         g_pGpioRegs->GEDR2 = 1 << (irq - IRQ_GPIOXX_2_GPIO64);

  00050	959f3038	 ldrls       r3, [pc, #0x38]
  00054	924020a2	 subls       r2, r0, #0xA2
  00058	93a00001	 movls       r0, #1
  0005c	95931000	 ldrls       r1, [r3]
  00060	91a03210	 movls       r3, r0, lsl r2
  00064	95813050	 strls       r3, [r1, #0x50]

; 504  : }

  00068	912fff1e	 bxls        lr

; 502  :     else if (IRQ_GPIOXX_2_GPIO96 <= irq && irq <= IRQ_GPIOXX_2_GPIOMAX)

  0006c	e24030c2	 sub         r3, r0, #0xC2
  00070	e3530018	 cmp         r3, #0x18

; 503  :         g_pGpioRegs->GEDR3 = (1 << (irq - IRQ_GPIOXX_2_GPIO96));

  00074	959f3014	 ldrls       r3, [pc, #0x14]
  00078	924020c2	 subls       r2, r0, #0xC2
  0007c	93a00001	 movls       r0, #1
  00080	95931000	 ldrls       r1, [r3]
  00084	91a03210	 movls       r3, r0, lsl r2
  00088	95813148	 strls       r3, [r1, #0x148]

; 504  : }

  0008c	e12fff1e	 bx          lr
  00090		 |$LN13@ClearGPIOI|
  00090		 |$LN14@ClearGPIOI|
  00090	00000000	 DCD         |g_pGpioRegs|
  00094		 |$M43530|

			 ENDP  ; |ClearGPIOIrq|

	EXPORT	|FirstSetBitPos|

  00000			 AREA	 |.pdata|, PDATA
|$T43548| DCD	|$LN21@FirstSetBi|
	DCD	0x40002800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FirstSetBitPos| PROC

; 514  : {

  00000		 |$LN21@FirstSetBi|
  00000		 |$M43545|
  00000	e1b02000	 movs        r2, r0

; 515  :     UINT32 pos = 0;

  00004	e3a00000	 mov         r0, #0

; 516  : 
; 517  :     if (!val) return -1;

  00008	03e00000	 mvneq       r0, #0

; 538  : }

  0000c	012fff1e	 bxeq        lr

; 518  :     
; 519  :     //zero out all high order bits that are 1 except the lowest one
; 520  :     val &= (INT32)(0-val);

  00010	e2623000	 rsb         r3, r2, #0
  00014	e0033002	 and         r3, r3, r2
  00018		 |$LL13@FirstSetBi|

; 521  :     for (;;)
; 522  :         {
; 523  :             switch (val)

  00018	e3530010	 cmp         r3, #0x10
  0001c	8a00000a	 bhi         |$LN17@FirstSetBi|
  00020	0a000016	 beq         |$LN5@FirstSetBi|
  00024	e3530001	 cmp         r3, #1
  00028	0a00001b	 beq         |$LN12@FirstSetBi|
  0002c	e3530002	 cmp         r3, #2
  00030	0a000010	 beq         |$LN8@FirstSetBi|
  00034	e3530004	 cmp         r3, #4
  00038	0a00000c	 beq         |$LN7@FirstSetBi|
  0003c	e3530008	 cmp         r3, #8
  00040	1a000007	 bne         |$LN1@FirstSetBi|

; 528  :                 case 8: return pos+3;

  00044	e2800003	 add         r0, r0, #3

; 538  : }

  00048	e12fff1e	 bx          lr
  0004c		 |$LN17@FirstSetBi|

; 521  :     for (;;)
; 522  :         {
; 523  :             switch (val)

  0004c	e3530020	 cmp         r3, #0x20
  00050	0a000010	 beq         |$LN4@FirstSetBi|
  00054	e3530040	 cmp         r3, #0x40
  00058	0a00000c	 beq         |$LN3@FirstSetBi|
  0005c	e3530080	 cmp         r3, #0x80
  00060	0a000008	 beq         |$LN2@FirstSetBi|
  00064		 |$LN1@FirstSetBi|

; 533  :                 default: 
; 534  :                     val >>= 8;

  00064	e1a03423	 mov         r3, r3, lsr #8

; 535  :                     pos += 8;

  00068	e2800008	 add         r0, r0, #8

; 536  :                 }
; 537  :         }

  0006c	eaffffe9	 b           |$LL13@FirstSetBi|
  00070		 |$LN7@FirstSetBi|

; 527  :                 case 4: return pos+2;

  00070	e2800002	 add         r0, r0, #2

; 538  : }

  00074	e12fff1e	 bx          lr
  00078		 |$LN8@FirstSetBi|

; 524  :                 {
; 525  :                 case 1: return pos;
; 526  :                 case 2: return pos+1;

  00078	e2800001	 add         r0, r0, #1

; 538  : }

  0007c	e12fff1e	 bx          lr
  00080		 |$LN5@FirstSetBi|

; 529  :                 case 16: return pos+4;

  00080	e2800004	 add         r0, r0, #4

; 538  : }

  00084	e12fff1e	 bx          lr
  00088		 |$LN2@FirstSetBi|

; 532  :                 case 128: return pos+7;

  00088	e2800007	 add         r0, r0, #7

; 538  : }

  0008c	e12fff1e	 bx          lr
  00090		 |$LN3@FirstSetBi|

; 531  :                 case 64: return pos+6;

  00090	e2800006	 add         r0, r0, #6

; 538  : }

  00094	e12fff1e	 bx          lr
  00098		 |$LN4@FirstSetBi|

; 530  :                 case 32: return pos+5;

  00098	e2800005	 add         r0, r0, #5
  0009c		 |$LN12@FirstSetBi|

; 538  : }

  0009c	e12fff1e	 bx          lr
  000a0		 |$M43546|

			 ENDP  ; |FirstSetBitPos|

	EXPORT	|FindIRQ_GPIOXX_2|

  00000			 AREA	 |.pdata|, PDATA
|$T43562| DCD	|$LN15@FindIRQ_GP|
	DCD	0x40002401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |FindIRQ_GPIOXX_2| PROC

; 549  : {

  00000		 |$LN15@FindIRQ_GP|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M43559|

; 550  :     //look up GEDR to find the GPIO Pin that caused interrupt
; 551  :     UINT32 retIrq = OAL_INTR_IRQ_UNDEFINED;
; 552  :     UINT32 regVal;
; 553  : 
; 554  :     if (regVal = (g_pGpioRegs->GEDR0 & ~0x03 & GPIO_GEDR0_VLD_MSK)) {     //~0x03 masks GPIO0 and GPIO1 bit positions

  00004	e59f3080	 ldr         r3, [pc, #0x80]
  00008	e5932000	 ldr         r2, [r3]
  0000c	e5923048	 ldr         r3, [r2, #0x48]
  00010	e3d33003	 bics        r3, r3, #3
  00014	0a000003	 beq         |$LN10@FindIRQ_GP|

; 555  :         retIrq = FirstSetBitPos(regVal >> 2) + IRQ_GPIOXX_2_GPIO2;

  00018	e1a00123	 mov         r0, r3, lsr #2
  0001c	eb000000	 bl          FirstSetBitPos
  00020	e2800064	 add         r0, r0, #0x64
  00024	ea000012	 b           |$LN3@FindIRQ_GP|
  00028		 |$LN10@FindIRQ_GP|

; 556  :     }
; 557  :     else if (regVal = (g_pGpioRegs->GEDR1 & GPIO_GEDR1_VLD_MSK)) {

  00028	e592304c	 ldr         r3, [r2, #0x4C]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000003	 beq         |$LN8@FindIRQ_GP|

; 558  :         retIrq = FirstSetBitPos(regVal) + IRQ_GPIOXX_2_GPIO32;

  00034	e1a00003	 mov         r0, r3
  00038	eb000000	 bl          FirstSetBitPos
  0003c	e2800082	 add         r0, r0, #0x82
  00040	ea00000b	 b           |$LN3@FindIRQ_GP|
  00044		 |$LN8@FindIRQ_GP|

; 559  :     }
; 560  :     else if (regVal = (g_pGpioRegs->GEDR2 & GPIO_GEDR2_VLD_MSK)) {

  00044	e5923050	 ldr         r3, [r2, #0x50]
  00048	e3530000	 cmp         r3, #0
  0004c	0a000003	 beq         |$LN6@FindIRQ_GP|

; 561  :         retIrq = FirstSetBitPos(regVal) + IRQ_GPIOXX_2_GPIO64;

  00050	e1a00003	 mov         r0, r3
  00054	eb000000	 bl          FirstSetBitPos
  00058	e28000a2	 add         r0, r0, #0xA2
  0005c	ea000004	 b           |$LN3@FindIRQ_GP|
  00060		 |$LN6@FindIRQ_GP|

; 562  :     }
; 563  :     else if (regVal = (g_pGpioRegs->GEDR3 & GPIO_GEDR3_VLD_MSK)) {

  00060	e5923148	 ldr         r3, [r2, #0x148]
  00064	e3d304fe	 bics        r0, r3, #0xFE, 8
  00068	0a000004	 beq         |$LN4@FindIRQ_GP|

; 564  :         retIrq = FirstSetBitPos(regVal) + IRQ_GPIOXX_2_GPIO96;

  0006c	eb000000	 bl          FirstSetBitPos
  00070	e28000c2	 add         r0, r0, #0xC2
  00074		 |$LN3@FindIRQ_GP|

; 568  :     }
; 569  :     
; 570  :     if (retIrq < IRQ_GPIOXX_2_GPIOMIN|| retIrq > IRQ_GPIOXX_2_GPIOMAX)

  00074	e2403064	 sub         r3, r0, #0x64
  00078	e3530076	 cmp         r3, #0x76

; 571  :         return OAL_INTR_IRQ_UNDEFINED;
; 572  : 
; 573  :     return retIrq;

  0007c	9a000000	 bls         |$LN11@FindIRQ_GP|
  00080		 |$LN4@FindIRQ_GP|

; 565  :     }
; 566  :     else { 
; 567  :         return OAL_INTR_IRQ_UNDEFINED;

  00080	e3e00000	 mvn         r0, #0
  00084		 |$LN11@FindIRQ_GP|

; 574  : }

  00084	e49de004	 ldr         lr, [sp], #4
  00088	e12fff1e	 bx          lr
  0008c		 |$LN16@FindIRQ_GP|
  0008c		 |$LN17@FindIRQ_GP|
  0008c	00000000	 DCD         |g_pGpioRegs|
  00090		 |$M43560|

			 ENDP  ; |FindIRQ_GPIOXX_2|

	EXPORT	|OALIntrDisableIrqs|
	EXPORT	|??_C@_1CM@GPENGBBP@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@NIPMEMC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN@| [ DATA ] ; `string'
	IMPORT	|BSPIntrDisableIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T43580| DCD	|$LN19@OALIntrDis|
	DCD	0x40003401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@GPENGBBP@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "D", 0x0, "i", 0x0, "s", 0x0, "a", 0x0, "b"
	DCB	0x0, "l", 0x0, "e", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, "s"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@NIPMEMC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "I", 0x0, "n", 0x0, "t"
	DCB	0x0, "r", 0x0, "D", 0x0, "i", 0x0, "s", 0x0, "a", 0x0, "b"
	DCB	0x0, "l", 0x0, "e", 0x0, "I", 0x0, "r", 0x0, "q", 0x0, "s"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ")"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIntrDisableIrqs| PROC

; 236  : {

  00000		 |$LN19@OALIntrDis|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M43577|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 237  :     UINT32 irq, i;
; 238  : 
; 239  :     OALMSG(OAL_INTR&&OAL_FUNC, (
; 240  :         L"+OALIntrDisableIrqs(%d, 0x%08x)\r\n", count, pIrqs
; 241  :     ));

  0000c	e59f60b8	 ldr         r6, [pc, #0xB8]
  00010	e5963440	 ldr         r3, [r6, #0x440]
  00014	e3130901	 tst         r3, #1, 18
  00018	0a000006	 beq         |$LN11@OALIntrDis|
  0001c	e3130004	 tst         r3, #4
  00020	0a000004	 beq         |$LN11@OALIntrDis|
  00024	e59f009c	 ldr         r0, [pc, #0x9C]
  00028	e1a02005	 mov         r2, r5
  0002c	e1a01004	 mov         r1, r4
  00030	eb000000	 bl          NKDbgPrintfW
  00034	e5963440	 ldr         r3, [r6, #0x440]
  00038		 |$LN11@OALIntrDis|

; 242  :     
; 243  :     for (i = 0; i < count; i++) {

  00038	e3540000	 cmp         r4, #0
  0003c	0a000019	 beq         |$LN6@OALIntrDis|
  00040	e59f707c	 ldr         r7, [pc, #0x7C]
  00044	e3a08001	 mov         r8, #1
  00048	e3a09001	 mov         r9, #1
  0004c		 |$LL8@OALIntrDis|

; 244  : #ifndef OAL_BSP_CALLBACKS
; 245  :         irq = pIrqs[i];
; 246  : #else
; 247  :         // Give BSP chance to disable irq on subordinate interrupt controller
; 248  :         irq = BSPIntrDisableIrq(pIrqs[i]);

  0004c	e5950000	 ldr         r0, [r5]
  00050	eb000000	 bl          BSPIntrDisableIrq

; 249  : #endif
; 250  :         if (irq <= IRQ_RTCALARM) {

  00054	e350001f	 cmp         r0, #0x1F

; 251  :             // Disable the primary IRQ
; 252  :             CLRREG32(&g_pICReg->icmr, (1 << irq));

  00058	95972000	 ldrls       r2, [r7]
  0005c	95923004	 ldrls       r3, [r2, #4]
  00060	91c33018	 bicls       r3, r3, r8, lsl r0
  00064	95823004	 strls       r3, [r2, #4]
  00068	9a00000a	 bls         |$LN7@OALIntrDis|

; 253  :         }
; 254  :         else if ((irq >= IRQ_WTM) && (irq <= IRQ_CAMQCKCAP)) {

  0006c	e2403020	 sub         r3, r0, #0x20
  00070	e3530001	 cmp         r3, #1

; 255  :             CLRREG32(&g_pICReg->icmr2, (1 << (irq - IRQ_WTM)));

  00074	95971000	 ldrls       r1, [r7]
  00078	92402020	 subls       r2, r0, #0x20
  0007c	959130a0	 ldrls       r3, [r1, #0xA0]
  00080	91c33219	 bicls       r3, r3, r9, lsl r2
  00084	958130a0	 strls       r3, [r1, #0xA0]
  00088	9a000002	 bls         |$LN7@OALIntrDis|

; 256  :         }
; 257  :         else if (irq >= IRQ_GPIOXX_2_GPIOMIN && irq <= IRQ_GPIOXX_2_GPIOMAX) {

  0008c	e2403064	 sub         r3, r0, #0x64
  00090	e3530076	 cmp         r3, #0x76

; 258  :             //Clear GRERx and GFERx bit disabling interrupt generation.
; 259  :             //Note: Since the next line clears the GRERx and GFERx bits,
; 260  :             //to reenable this GPIO irq generation calling OALIntrEnableIrqs
; 261  :             //is not enough - make sure corresponding GRERx/GFERx bits are also set.
; 262  :             DisableGPIOIrq(irq);

  00094	9b000000	 blls        DisableGPIOIrq
  00098		 |$LN7@OALIntrDis|
  00098	e2855004	 add         r5, r5, #4
  0009c	e2544001	 subs        r4, r4, #1
  000a0	1affffe9	 bne         |$LL8@OALIntrDis|

; 242  :     
; 243  :     for (i = 0; i < count; i++) {

  000a4	e5963440	 ldr         r3, [r6, #0x440]
  000a8		 |$LN6@OALIntrDis|

; 263  :         }
; 264  :     }
; 265  : 
; 266  :     OALMSG(OAL_INTR&&OAL_FUNC, (L"-OALIntrDisableIrqs\r\n"));

  000a8	e3130901	 tst         r3, #1, 18
  000ac	13130004	 tstne       r3, #4
  000b0	159f0008	 ldrne       r0, [pc, #8]
  000b4	1b000000	 blne        NKDbgPrintfW

; 267  : }

  000b8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN20@OALIntrDis|
  000c0		 |$LN21@OALIntrDis|
  000c0	00000000	 DCD         |??_C@_1CM@GPENGBBP@?$AA?9?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$AN?$AA?6?$AA?$AA@|
  000c4		 |$LN22@OALIntrDis|
  000c4	00000000	 DCD         |g_pICReg|
  000c8		 |$LN23@OALIntrDis|
  000c8	00000000	 DCD         |??_C@_1EE@NIPMEMC@?$AA?$CL?$AAO?$AAA?$AAL?$AAI?$AAn?$AAt?$AAr?$AAD?$AAi?$AAs?$AAa?$AAb?$AAl?$AAe?$AAI?$AAr?$AAq?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN@|
  000cc		 |$LN24@OALIntrDis|
  000cc	00000000	 DCD         |dpCurSettings|
  000d0		 |$M43578|

			 ENDP  ; |OALIntrDisableIrqs|

	EXPORT	|OEMInterruptHandler|
	IMPORT	|OALIntrTranslateIrq|
	IMPORT	|NKIsSysIntrValid|
	IMPORT	|NKCallIntChain|
	IMPORT	|BSPIntrActiveIrq|
	IMPORT	|OALTimerIntrHandler|

  00000			 AREA	 |.pdata|, PDATA
|$T43600| DCD	|$LN37@OEMInterru@2|
	DCD	0x40008b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMInterruptHandler| PROC

; 309  : {

  00000		 |$LN37@OEMInterru@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43597|

; 310  :     UINT32 irq = OAL_INTR_IRQ_UNDEFINED;
; 311  :     UINT32 sysIntr = SYSINTR_NOP;
; 312  : 
; 313  :     if (!g_pICReg) {

  00004	e59f721c	 ldr         r7, [pc, #0x21C]
  00008	e3a04000	 mov         r4, #0
  0000c	e5971008	 ldr         r1, [r7, #8]
  00010	e3510000	 cmp         r1, #0
  00014	1a000001	 bne         |$LN30@OEMInterru@2|
  00018		 |$LN34@OEMInterru@2|

; 314  :         return(SYSINTR_NOP);

  00018	e3a04000	 mov         r4, #0
  0001c	ea00007e	 b           |$LN1@OEMInterru@2|
  00020		 |$LN30@OEMInterru@2|

; 315  :     }
; 316  : 
; 317  :     // Determine the IRQ of the highest priority pending interrupt
; 318  :     irq = (UINT16)((g_pICReg->ichp >> 16) & 0x3F);

  00020	e5913018	 ldr         r3, [r1, #0x18]
  00024	e1a03503	 mov         r3, r3, lsl #10
  00028	e1b05d23	 movs        r5, r3, lsr #26

; 319  : 
; 320  :     if (irq == 0)
; 321  :     {
; 322  :         return(SYSINTR_NOP);

  0002c	0afffff9	 beq         |$LN34@OEMInterru@2|

; 323  :     }
; 324  : 
; 325  :     // System timer interrupt?
; 326  :     if (irq == IRQ_OSMR0)

  00030	e355001a	 cmp         r5, #0x1A
  00034	1a000002	 bne         |$LN28@OEMInterru@2|

; 327  :     {
; 328  :         // The rest is up to the timer interrupt handler.
; 329  :         //
; 330  :         sysIntr = OALTimerIntrHandler();

  00038	eb000000	 bl          OALTimerIntrHandler

; 343  :             sysIntr = g_pProfilerISR(ra);

  0003c	e1a04000	 mov         r4, r0

; 344  :         }
; 345  :     }
; 346  :     // Board-level interrupts
; 347  :     else

  00040	ea000075	 b           |$LN1@OEMInterru@2|
  00044		 |$LN28@OEMInterru@2|

; 331  : 
; 332  :     }
; 333  :     // Profiling timer interrupt?
; 334  :     else if (irq == IRQ_OSMR2)

  00044	e355001c	 cmp         r5, #0x1C
  00048	1a000009	 bne         |$LN26@OEMInterru@2|

; 335  :     {
; 336  :         // Mask the interrupt
; 337  :         CLRREG32(&g_pICReg->icmr, (1 << irq));

  0004c	e5913004	 ldr         r3, [r1, #4]
  00050	e3c33201	 bic         r3, r3, #1, 4
  00054	e5813004	 str         r3, [r1, #4]

; 338  : 
; 339  :         // The rest is up to the profiling interrupt handler (if profiling
; 340  :         // is enabled).
; 341  :         //
; 342  :         if (g_pProfilerISR) {

  00058	e5973000	 ldr         r3, [r7]
  0005c	e3530000	 cmp         r3, #0
  00060	0a00006d	 beq         |$LN1@OEMInterru@2|

; 343  :             sysIntr = g_pProfilerISR(ra);

  00064	e1a0e00f	 mov         lr, pc
  00068	e12fff13	 bx          r3
  0006c	e1a04000	 mov         r4, r0

; 344  :         }
; 345  :     }
; 346  :     // Board-level interrupts
; 347  :     else

  00070	ea000069	 b           |$LN1@OEMInterru@2|
  00074		 |$LN26@OEMInterru@2|

; 348  :     {
; 349  : #ifdef OAL_BSP_CALLBACKS
; 350  :         UINT32 origIrq = irq;  // save the original so we can tell if it's BSP specific irq

  00074	e1a06005	 mov         r6, r5

; 351  :         
; 352  :         if (irq == IRQ_GPIO0 || irq == IRQ_GPIO1 || irq == IRQ_GPIOXX_2)

  00078	e3550008	 cmp         r5, #8
  0007c	0a000010	 beq         |$LN22@OEMInterru@2|
  00080	e3550009	 cmp         r5, #9
  00084	0a00000e	 beq         |$LN22@OEMInterru@2|
  00088	e355000a	 cmp         r5, #0xA
  0008c	0a00000c	 beq         |$LN22@OEMInterru@2|

; 380  :             }
; 381  :         }
; 382  :         else
; 383  : #endif
; 384  :         {
; 385  :             // Mask the interrupt
; 386  :             if ((irq >= IRQ_WTM) && (irq <= IRQ_CAMQCKCAP))

  00090	e2453020	 sub         r3, r5, #0x20
  00094	e3530001	 cmp         r3, #1

; 387  :             {
; 388  :                 CLRREG32(&g_pICReg->icmr2, (1 << (irq - IRQ_WTM)));

  00098	959120a0	 ldrls       r2, [r1, #0xA0]
  0009c	92453020	 subls       r3, r5, #0x20
  000a0	93a00001	 movls       r0, #1
  000a4	91c23310	 bicls       r3, r2, r0, lsl r3
  000a8	958130a0	 strls       r3, [r1, #0xA0]
  000ac	9a00001d	 bls         |$LN18@OEMInterru@2|

; 389  :             }
; 390  :             else
; 391  :             {
; 392  :                 CLRREG32(&g_pICReg->icmr, (1 << irq));

  000b0	e5913004	 ldr         r3, [r1, #4]
  000b4	e3a02001	 mov         r2, #1
  000b8	e1c33512	 bic         r3, r3, r2, lsl r5
  000bc	e5813004	 str         r3, [r1, #4]
  000c0	ea000018	 b           |$LN18@OEMInterru@2|
  000c4		 |$LN22@OEMInterru@2|

; 353  :         {
; 354  :             // Give BSP chance to translate IRQ -- if there is subordinate
; 355  :             // interrupt controller in BSP it give chance to decode its status
; 356  :             // and change IRQ
; 357  :             irq = BSPIntrActiveIrq(irq);

  000c4	e1a00005	 mov         r0, r5
  000c8	eb000000	 bl          BSPIntrActiveIrq
  000cc	e1a05000	 mov         r5, r0

; 358  : 
; 359  :             // if irq equals IRQ_GPIOXX_2 demultiplex it to a particular emulated GPIO IRQ if it's not a BSP specific IRQ
; 360  :             if (irq == IRQ_GPIOXX_2 && origIrq== irq) {

  000d0	e355000a	 cmp         r5, #0xA
  000d4	1a00000e	 bne         |$LN21@OEMInterru@2|
  000d8	e356000a	 cmp         r6, #0xA
  000dc	1a000011	 bne         |$LN18@OEMInterru@2|

; 361  :                 
; 362  :                 // find the GPIO IRQ
; 363  :                 irq = FindIRQ_GPIOXX_2();

  000e0	eb000000	 bl          FindIRQ_GPIOXX_2
  000e4	e1a05000	 mov         r5, r0

; 364  : 
; 365  :                 if (irq != OAL_INTR_IRQ_UNDEFINED)

  000e8	e3750001	 cmn         r5, #1
  000ec	0a00000d	 beq         |$LN18@OEMInterru@2|

; 366  :                 {
; 367  :                     // Mask the interrupt
; 368  :                     CLRREG32(&g_pICReg->icmr, (1 << IRQ_GPIOXX_2));

  000f0	e5974008	 ldr         r4, [r7, #8]

; 369  :                     
; 370  :                     //clear the GEDRx bit otherwise this ISR will be called again
; 371  :                     ClearGPIOIrq(irq);

  000f4	e5943004	 ldr         r3, [r4, #4]
  000f8	e3c33b01	 bic         r3, r3, #1, 22
  000fc	e5843004	 str         r3, [r4, #4]
  00100	eb000000	 bl          ClearGPIOIrq

; 372  : 
; 373  :                     // Unmask the interrupt
; 374  :                     SETREG32(&g_pICReg->icmr, (1 << IRQ_GPIOXX_2));

  00104	e5943004	 ldr         r3, [r4, #4]
  00108	e3833b01	 orr         r3, r3, #1, 22
  0010c	e5843004	 str         r3, [r4, #4]

; 375  :                 }

  00110	ea000004	 b           |$LN18@OEMInterru@2|
  00114		 |$LN21@OEMInterru@2|

; 376  :             }
; 377  :             else if (irq == IRQ_GPIO1 && origIrq== irq) {

  00114	e3550009	 cmp         r5, #9
  00118	03560009	 cmpeq       r6, #9

; 378  :                 //clear the GEDRx bit otherwise this ISR will be called again
; 379  :                 g_pGpioRegs->GEDR0 = 1u << 1;

  0011c	05973004	 ldreq       r3, [r7, #4]
  00120	03a02002	 moveq       r2, #2
  00124	05832048	 streq       r2, [r3, #0x48]
  00128		 |$LN18@OEMInterru@2|

; 393  :             }
; 394  :         }
; 395  : 
; 396  : #ifdef OAL_ILTIMING
; 397  :         if (g_oalILT.active) {
; 398  :             g_oalILT.interrupts++;
; 399  :         }        
; 400  : #endif
; 401  :         // First find if IRQ is claimed by chain
; 402  :         sysIntr = (UINT16)NKCallIntChain((UCHAR)irq);

  00128	e20500ff	 and         r0, r5, #0xFF
  0012c	eb000000	 bl          NKCallIntChain
  00130	e1a04800	 mov         r4, r0, lsl #16
  00134	e1b04824	 movs        r4, r4, lsr #16

; 403  :         
; 404  :         //installable ISR returned SYSINTR_NOP?
; 405  :         if (SYSINTR_NOP == sysIntr)

  00138	1a000018	 bne         |$LN14@OEMInterru@2|

; 406  :         {
; 407  : #ifdef OAL_BSP_CALLBACKS
; 408  :             if (origIrq != irq) {

  0013c	e1560005	 cmp         r6, r5
  00140	0a000003	 beq         |$LN13@OEMInterru@2|

; 409  :                 // BSP specific irq
; 410  :                 BSPIntrEnableIrq (irq);

  00144	e1a00005	 mov         r0, r5
  00148	eb000000	 bl          BSPIntrEnableIrq
  0014c	e3a04000	 mov         r4, #0
  00150	ea000031	 b           |$LN1@OEMInterru@2|
  00154		 |$LN13@OEMInterru@2|

; 411  :             } else
; 412  : #endif
; 413  :             {
; 414  :                 //no additional processing is required.
; 415  :                 //Unmask the interrupt
; 416  :                 if (irq <= IRQ_RTCALARM) {

  00154	e355001f	 cmp         r5, #0x1F

; 417  :                     SETREG32(&g_pICReg->icmr, (1 << irq));

  00158	95972008	 ldrls       r2, [r7, #8]
  0015c	93a01001	 movls       r1, #1
  00160	93a04000	 movls       r4, #0
  00164	95923004	 ldrls       r3, [r2, #4]
  00168	91833511	 orrls       r3, r3, r1, lsl r5
  0016c	95823004	 strls       r3, [r2, #4]
  00170	9a000029	 bls         |$LN1@OEMInterru@2|

; 418  :                 }
; 419  :                 else if ((irq >= IRQ_WTM) && (irq <= IRQ_CAMQCKCAP)) {

  00174	e2453020	 sub         r3, r5, #0x20
  00178	e3530001	 cmp         r3, #1
  0017c	8affffa5	 bhi         |$LN34@OEMInterru@2|

; 420  :                     SETREG32(&g_pICReg->icmr2, (1 << (irq - IRQ_WTM)));

  00180	e5971008	 ldr         r1, [r7, #8]
  00184	e2452020	 sub         r2, r5, #0x20
  00188	e3a00001	 mov         r0, #1
  0018c	e59130a0	 ldr         r3, [r1, #0xA0]
  00190	e3a04000	 mov         r4, #0
  00194	e1833210	 orr         r3, r3, r0, lsl r2
  00198	e58130a0	 str         r3, [r1, #0xA0]
  0019c	ea00001e	 b           |$LN1@OEMInterru@2|
  001a0		 |$LN14@OEMInterru@2|

; 421  :                 }
; 422  :             }
; 423  :             
; 424  :             return SYSINTR_NOP;
; 425  :         }
; 426  :         
; 427  :         if (sysIntr == (UINT16)SYSINTR_CHAIN || !NKIsSysIntrValid(sysIntr))

  001a0	e3540003	 cmp         r4, #3
  001a4	0a000003	 beq         |$LN7@OEMInterru@2|
  001a8	e1a00004	 mov         r0, r4
  001ac	eb000000	 bl          NKIsSysIntrValid
  001b0	e3500000	 cmp         r0, #0
  001b4	1a000002	 bne         |$LN8@OEMInterru@2|
  001b8		 |$LN7@OEMInterru@2|

; 428  :         {
; 429  :             // IRQ wasn't claimed, use static mapping
; 430  :             sysIntr = OALIntrTranslateIrq(irq);

  001b8	e1a00005	 mov         r0, r5
  001bc	eb000000	 bl          OALIntrTranslateIrq
  001c0	e1a04000	 mov         r4, r0
  001c4		 |$LN8@OEMInterru@2|

; 431  :         }
; 432  : 
; 433  :         // unmask interrupts in case it's NOP or invalid
; 434  :         if (SYSINTR_NOP == sysIntr) {

  001c4	e3540000	 cmp         r4, #0
  001c8	1a000013	 bne         |$LN1@OEMInterru@2|

; 435  : #ifdef OAL_BSP_CALLBACKS
; 436  :             if (origIrq != irq) {

  001cc	e1560005	 cmp         r6, r5
  001d0	0a000002	 beq         |$LN5@OEMInterru@2|

; 437  :                 // BSP specific irq
; 438  :                 BSPIntrEnableIrq (irq);

  001d4	e1a00005	 mov         r0, r5
  001d8	eb000000	 bl          BSPIntrEnableIrq

; 439  :             } else

  001dc	ea00000e	 b           |$LN1@OEMInterru@2|
  001e0		 |$LN5@OEMInterru@2|

; 440  : #endif
; 441  :             {
; 442  :                 // Unmask the interrupt
; 443  :                 if (irq <= IRQ_RTCALARM) {

  001e0	e355001f	 cmp         r5, #0x1F

; 444  :                     SETREG32(&g_pICReg->icmr, (1 << irq));

  001e4	95972008	 ldrls       r2, [r7, #8]
  001e8	93a01001	 movls       r1, #1
  001ec	95923004	 ldrls       r3, [r2, #4]
  001f0	91833511	 orrls       r3, r3, r1, lsl r5
  001f4	95823004	 strls       r3, [r2, #4]
  001f8	9a000007	 bls         |$LN1@OEMInterru@2|

; 445  :                 }
; 446  :                 else if ((irq >= IRQ_WTM) && (irq <= IRQ_CAMQCKCAP)) {

  001fc	e2453020	 sub         r3, r5, #0x20
  00200	e3530001	 cmp         r3, #1

; 447  :                     SETREG32(&g_pICReg->icmr2, (1 << (irq - IRQ_WTM)));

  00204	95971008	 ldrls       r1, [r7, #8]
  00208	92452020	 subls       r2, r5, #0x20
  0020c	93a00001	 movls       r0, #1
  00210	959130a0	 ldrls       r3, [r1, #0xA0]
  00214	91833210	 orrls       r3, r3, r0, lsl r2
  00218	958130a0	 strls       r3, [r1, #0xA0]
  0021c		 |$LN1@OEMInterru@2|

; 448  :                 }
; 449  :             }
; 450  :         }
; 451  :     }
; 452  : 
; 453  :     return (sysIntr);
; 454  : }

  0021c	e1a00004	 mov         r0, r4
  00220	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00224	e12fff1e	 bx          lr
  00228		 |$LN38@OEMInterru@2|
  00228		 |$LN39@OEMInterru@2|
  00228	00000000	 DCD         |g_pProfilerISR|
  0022c		 |$M43598|

			 ENDP  ; |OEMInterruptHandler|

	END
