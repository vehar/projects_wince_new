; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\OAL\XDBBROWSER\xdbioctls.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XSCBwrThreadID| [ DATA ]
	EXPORT	|XSCBwrProcessID| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|CurrentTaskID| % 0x4
|CFGBlockvalid| % 0x4

  00000			 AREA	 |.data|, DATA
|XSCBwrThreadID| DCD 0xffffffff
|XSCBwrProcessID| DCD 0xffffffff
	EXPORT	|??_C@_1GM@PINJOMEC@?$AAX?$AAS?$AAC?$AAD?$AAB?$AAG?$AA?3?$AAT?$AAr?$AAa?$AAc?$AAe?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?3?$AA?5?$AAC?$AAF?$AAG?$AA?3?$AA?$CF?$AA0@| [ DATA ] ; `string'
	EXPORT	|XSCBwrInitExecutionTrace|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|XSCBwrTraceSetFillOnce|
	IMPORT	|NKSetDataAbortHandler|
	IMPORT	|XSCBwrTraceDataAbortHandler|

  00008			 AREA	 |.bss|, NOINIT
|pfOSDataAbortHandler| % 0x4
|CFGBlock| %	0x20

  00000			 AREA	 |.pdata|, PDATA
|$T16538| DCD	|$LN5@XSCBwrInit|
	DCD	0x40003604
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\oal\xdbbrowser\xdbioctls.c

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@PINJOMEC@?$AAX?$AAS?$AAC?$AAD?$AAB?$AAG?$AA?3?$AAT?$AAr?$AAa?$AAc?$AAe?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?3?$AA?5?$AAC?$AAF?$AAG?$AA?3?$AA?$CF?$AA0@| DCB "X"
	DCB	0x0, "S", 0x0, "C", 0x0, "D", 0x0, "B", 0x0, "G", 0x0, ":"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i", 0x0, "a"
	DCB	0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, "d", 0x0, ":"
	DCB	0x0, " ", 0x0, "C", 0x0, "F", 0x0, "G", 0x0, ":", 0x0, "%"
	DCB	0x0, "0", 0x0, "8", 0x0, "x", 0x0, " ", 0x0, " ", 0x0, "B"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ","
	DCB	0x0, " ", 0x0, "%", 0x0, "x", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XSCBwrInitExecutionTrace| PROC

; 362  : {       

  00000		 |$LN5@XSCBwrInit|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M16535|

; 363  :     CFGBlock.TraceBufferSize = Size;

  00010	e59d2010	 ldr         r2, [sp, #0x10]
  00014	e59f30b0	 ldr         r3, [pc, #0xB0]
  00018	e583200c	 str         r2, [r3, #0xC]

; 364  :     CFGBlock.pTraceBuffer = (int) pBuffer;      

  0001c	e59d200c	 ldr         r2, [sp, #0xC]
  00020	e59f30a4	 ldr         r3, [pc, #0xA4]
  00024	e5832000	 str         r2, [r3]

; 365  :     CFGBlock.StartAddress = (int) CFGBlock.pTraceBuffer;

  00028	e59f309c	 ldr         r3, [pc, #0x9C]
  0002c	e5932000	 ldr         r2, [r3]
  00030	e59f3094	 ldr         r3, [pc, #0x94]
  00034	e5832004	 str         r2, [r3, #4]

; 366  :     CFGBlock.EndAddress   = (int) CFGBlock.pTraceBuffer;

  00038	e59f308c	 ldr         r3, [pc, #0x8C]
  0003c	e5932000	 ldr         r2, [r3]
  00040	e59f3084	 ldr         r3, [pc, #0x84]
  00044	e5832008	 str         r2, [r3, #8]

; 367  :     CFGBlock.TaskIDAddress = 0;

  00048	e59f207c	 ldr         r2, [pc, #0x7C]
  0004c	e3a03000	 mov         r3, #0
  00050	e5823014	 str         r3, [r2, #0x14]

; 368  :     CFGBlock.TaskIDSize = 0;

  00054	e59f2070	 ldr         r2, [pc, #0x70]
  00058	e3a03000	 mov         r3, #0
  0005c	e5823018	 str         r3, [r2, #0x18]

; 369  :     CFGBlock.CurrentTaskIDs = 0;

  00060	e59f2064	 ldr         r2, [pc, #0x64]
  00064	e3a03000	 mov         r3, #0
  00068	e582301c	 str         r3, [r2, #0x1C]

; 370  : 
; 371  :     /* obtain address of the orginal OS DataAbort handler */
; 372  :     pfOSDataAbortHandler =  NKSetDataAbortHandler(XSCBwrTraceDataAbortHandler);

  0006c	e59f0060	 ldr         r0, [pc, #0x60]
  00070	eb000000	 bl          NKSetDataAbortHandler
  00074	e58d0000	 str         r0, [sp]
  00078	e59d2000	 ldr         r2, [sp]
  0007c	e59f304c	 ldr         r3, [pc, #0x4C]
  00080	e5832000	 str         r2, [r3]

; 373  :     NKSetDataAbortHandler(pfOSDataAbortHandler);

  00084	e59f3044	 ldr         r3, [pc, #0x44]
  00088	e5930000	 ldr         r0, [r3]
  0008c	eb000000	 bl          NKSetDataAbortHandler

; 374  : 
; 375  :     /* set multi trace mode */
; 376  :     CFGBlock.TraceMode = TRACE_OFF;

  00090	e59f2034	 ldr         r2, [pc, #0x34]
  00094	e3a03002	 mov         r3, #2
  00098	e5823010	 str         r3, [r2, #0x10]

; 377  :     XSCBwrTraceSetFillOnce();

  0009c	eb000000	 bl          XSCBwrTraceSetFillOnce

; 378  : 
; 379  :     //clear the current processor Trace 
; 380  :     trace_clear_current();      

  000a0	eb000000	 bl          trace_clear_current

; 381  : 
; 382  :     RETAILMSG(1, (TEXT("XSCDBG:Trace initialized: CFG:%08x  Buffer: %08x, %x\n"),&CFGBlock,CFGBlock.pTraceBuffer, Size ));

  000a4	e59d3010	 ldr         r3, [sp, #0x10]
  000a8	e59f201c	 ldr         r2, [pc, #0x1C]
  000ac	e5922000	 ldr         r2, [r2]
  000b0	e59f1014	 ldr         r1, [pc, #0x14]
  000b4	e59f000c	 ldr         r0, [pc, #0xC]
  000b8	eb000000	 bl          NKDbgPrintfW

; 383  : }

  000bc	e28dd004	 add         sp, sp, #4
  000c0	e89d6000	 ldmia       sp, {sp, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$LN6@XSCBwrInit|
  000c8		 |$LN7@XSCBwrInit|
  000c8	00000000	 DCD         |??_C@_1GM@PINJOMEC@?$AAX?$AAS?$AAC?$AAD?$AAB?$AAG?$AA?3?$AAT?$AAr?$AAa?$AAc?$AAe?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?3?$AA?5?$AAC?$AAF?$AAG?$AA?3?$AA?$CF?$AA0@|
  000cc		 |$LN8@XSCBwrInit|
  000cc	00000000	 DCD         |CFGBlock|
  000d0		 |$LN9@XSCBwrInit|
  000d0	00000000	 DCD         |pfOSDataAbortHandler|
  000d4		 |$LN10@XSCBwrInit|
  000d4	00000000	 DCD         |XSCBwrTraceDataAbortHandler|
  000d8		 |$M16536|

			 ENDP  ; |XSCBwrInitExecutionTrace|

	IMPORT	|XSCBwrReadTraceByte|

  00008			 AREA	 |.pdata|, PDATA
|$T16548| DCD	|$LN8@trace_clea|
	DCD	0x40001602
; Function compile flags: /Odtp

  000d8			 AREA	 |.text|, CODE, ARM

  000d8		 |trace_clear_current| PROC

; 342  : { 

  000d8		 |$LN8@trace_clea|
  000d8	e52de004	 str         lr, [sp, #-4]!
  000dc	e24dd00c	 sub         sp, sp, #0xC
  000e0		 |$M16545|

; 343  :   //clear the Target trace buffer by reading 
; 344  :   unsigned char dummy;
; 345  :   int i = 0;    

  000e0	e3a03000	 mov         r3, #0
  000e4	e58d3000	 str         r3, [sp]

; 346  :   for(i=0;i<256;i++){

  000e8	e3a03000	 mov         r3, #0
  000ec	e58d3000	 str         r3, [sp]
  000f0	ea000002	 b           |$LN3@trace_clea|
  000f4		 |$LN2@trace_clea|
  000f4	e59d3000	 ldr         r3, [sp]
  000f8	e2833001	 add         r3, r3, #1
  000fc	e58d3000	 str         r3, [sp]
  00100		 |$LN3@trace_clea|
  00100	e59d3000	 ldr         r3, [sp]
  00104	e3530c01	 cmp         r3, #1, 24
  00108	aa000005	 bge         |$LN1@trace_clea|

; 347  :     dummy = (unsigned char)XSCBwrReadTraceByte();

  0010c	eb000000	 bl          XSCBwrReadTraceByte
  00110	e58d0008	 str         r0, [sp, #8]
  00114	e59d3008	 ldr         r3, [sp, #8]
  00118	e20330ff	 and         r3, r3, #0xFF
  0011c	e5cd3004	 strb        r3, [sp, #4]

; 348  :   }

  00120	eafffff3	 b           |$LN2@trace_clea|
  00124		 |$LN1@trace_clea|

; 349  : }

  00124	e28dd00c	 add         sp, sp, #0xC
  00128	e49de004	 ldr         lr, [sp], #4
  0012c	e12fff1e	 bx          lr
  00130		 |$M16546|

			 ENDP  ; |trace_clear_current|

	EXPORT	|XSCBwrHandleTraceBufferException|
	IMPORT	|memcpy|
	IMPORT	|XSCBwrSaveTrace|

  0002c			 AREA	 |.bss|, NOINIT
|?NewBuffer@?1??XSCBwrHandleTraceBufferException@@9@9| % 0x10c ; `XSCBwrHandleTraceBufferException'::`2'::NewBuffer

  00010			 AREA	 |.pdata|, PDATA
|$T16553| DCD	|$LN6@XSCBwrHand|
	DCD	0x40001602
; Function compile flags: /Odtp

  00130			 AREA	 |.text|, CODE, ARM

  00130		 |XSCBwrHandleTraceBufferException| PROC

; 525  : {

  00130		 |$LN6@XSCBwrHand|
  00130	e52de004	 str         lr, [sp, #-4]!
  00134	e24dd008	 sub         sp, sp, #8
  00138		 |$M16550|

; 526  :   char* pBuffer;
; 527  :   static BYTE NewBuffer[XDBTRACEBUFFERBLOCKSIZE];
; 528  : 
; 529  :   // temporary stoage for new buffer
; 530  :   //
; 531  :   XSCBwrSaveTrace(&NewBuffer[4]);

  00138	e59f3044	 ldr         r3, [pc, #0x44]
  0013c	e2830004	 add         r0, r3, #4
  00140	eb000000	 bl          XSCBwrSaveTrace

; 532  : 
; 533  :   // check if usermode code is in this capture
; 534  :   //
; 535  :   if ( IsUserModeCapture(&NewBuffer[4]) ) {

  00144	e59f3038	 ldr         r3, [pc, #0x38]
  00148	e2830004	 add         r0, r3, #4
  0014c	eb000000	 bl          IsUserModeCapture
  00150	e58d0004	 str         r0, [sp, #4]
  00154	e59d3004	 ldr         r3, [sp, #4]
  00158	e3530000	 cmp         r3, #0
  0015c	0a000005	 beq         |$LN1@XSCBwrHand|

; 536  :     trace_admin_multi(&pBuffer);

  00160	e28d0000	 add         r0, sp, #0
  00164	eb000000	 bl          trace_admin_multi

; 537  :     memcpy( pBuffer, NewBuffer, XDBTRACEBUFFERBLOCKSIZE);

  00168	e3a02f43	 mov         r2, #0x43, 30
  0016c	e59f1010	 ldr         r1, [pc, #0x10]
  00170	e59d0000	 ldr         r0, [sp]
  00174	eb000000	 bl          memcpy
  00178		 |$LN1@XSCBwrHand|

; 538  :   }
; 539  : }

  00178	e28dd008	 add         sp, sp, #8
  0017c	e49de004	 ldr         lr, [sp], #4
  00180	e12fff1e	 bx          lr
  00184		 |$LN7@XSCBwrHand|
  00184		 |$LN8@XSCBwrHand|
  00184	00000000	 DCD         |?NewBuffer@?1??XSCBwrHandleTraceBufferException@@9@9|
  00188		 |$M16551|

			 ENDP  ; |XSCBwrHandleTraceBufferException|


  00018			 AREA	 |.pdata|, PDATA
|$T16561| DCD	|$LN19@trace_admi|
	DCD	0x40009f04
; Function compile flags: /Odtp

  00188			 AREA	 |.text|, CODE, ARM

  00188		 |trace_admin_multi| PROC

; 430  : {

  00188		 |$LN19@trace_admi|
  00188	e1a0c00d	 mov         r12, sp
  0018c	e92d0001	 stmdb       sp!, {r0}
  00190	e92d5000	 stmdb       sp!, {r12, lr}
  00194	e24dd004	 sub         sp, sp, #4
  00198		 |$M16558|

; 431  :   if(CFGBlock.EndAddress == CFGBlock.StartAddress && 
; 432  :      CFGBlock.StartAddress == (int) CFGBlock.pTraceBuffer){//empty buffer

  00198	e59f3260	 ldr         r3, [pc, #0x260]
  0019c	e5932008	 ldr         r2, [r3, #8]
  001a0	e59f3258	 ldr         r3, [pc, #0x258]
  001a4	e5933004	 ldr         r3, [r3, #4]
  001a8	e1520003	 cmp         r2, r3
  001ac	1a000012	 bne         |$LN14@trace_admi|
  001b0	e59f3248	 ldr         r3, [pc, #0x248]
  001b4	e5932004	 ldr         r2, [r3, #4]
  001b8	e59f3240	 ldr         r3, [pc, #0x240]
  001bc	e5933000	 ldr         r3, [r3]
  001c0	e1520003	 cmp         r2, r3
  001c4	1a00000c	 bne         |$LN14@trace_admi|

; 433  :     /*return address of the current trace buffer block */ 
; 434  :     *pbuffer =(char*) CFGBlock.StartAddress;

  001c8	e59f3230	 ldr         r3, [pc, #0x230]
  001cc	e5932004	 ldr         r2, [r3, #4]
  001d0	e59d300c	 ldr         r3, [sp, #0xC]
  001d4	e5832000	 str         r2, [r3]

; 435  :     CFGBlock.EndAddress += XDBTRACEBUFFERBLOCKSIZE;

  001d8	e59f3220	 ldr         r3, [pc, #0x220]
  001dc	e5933008	 ldr         r3, [r3, #8]
  001e0	e2832f43	 add         r2, r3, #0x43, 30
  001e4	e59f3214	 ldr         r3, [pc, #0x214]
  001e8	e5832008	 str         r2, [r3, #8]

; 436  :     return FALSE; //not full            

  001ec	e3a03000	 mov         r3, #0
  001f0	e58d3000	 str         r3, [sp]
  001f4	ea00007d	 b           |$LN15@trace_admi|

; 437  :   } else {

  001f8	ea00007c	 b           |$LN13@trace_admi|
  001fc		 |$LN14@trace_admi|

; 438  :     if(CFGBlock.EndAddress > CFGBlock.StartAddress){

  001fc	e59f31fc	 ldr         r3, [pc, #0x1FC]
  00200	e5932008	 ldr         r2, [r3, #8]
  00204	e59f31f4	 ldr         r3, [pc, #0x1F4]
  00208	e5933004	 ldr         r3, [r3, #4]
  0020c	e1520003	 cmp         r2, r3
  00210	9a000049	 bls         |$LN12@trace_admi|

; 439  :       //at least one block free for the current Trace block
; 440  :       if(CFGBlock.EndAddress + XDBTRACEBUFFERBLOCKSIZE == 
; 441  :          CFGBlock.StartAddress + CFGBlock.TraceBufferSize) {

  00214	e59f31e4	 ldr         r3, [pc, #0x1E4]
  00218	e5933008	 ldr         r3, [r3, #8]
  0021c	e2831f43	 add         r1, r3, #0x43, 30
  00220	e59f31d8	 ldr         r3, [pc, #0x1D8]
  00224	e5932004	 ldr         r2, [r3, #4]
  00228	e59f31d0	 ldr         r3, [pc, #0x1D0]
  0022c	e593300c	 ldr         r3, [r3, #0xC]
  00230	e0823003	 add         r3, r2, r3
  00234	e1510003	 cmp         r1, r3
  00238	1a000014	 bne         |$LN11@trace_admi|

; 442  :         *pbuffer =(char*) CFGBlock.EndAddress;

  0023c	e59f31bc	 ldr         r3, [pc, #0x1BC]
  00240	e5932008	 ldr         r2, [r3, #8]
  00244	e59d300c	 ldr         r3, [sp, #0xC]
  00248	e5832000	 str         r2, [r3]

; 443  :         CFGBlock.EndAddress += XDBTRACEBUFFERBLOCKSIZE;

  0024c	e59f31ac	 ldr         r3, [pc, #0x1AC]
  00250	e5933008	 ldr         r3, [r3, #8]
  00254	e2832f43	 add         r2, r3, #0x43, 30
  00258	e59f31a0	 ldr         r3, [pc, #0x1A0]
  0025c	e5832008	 str         r2, [r3, #8]

; 444  :         if(CFGBlock.TraceMode == FILL_ONCE){

  00260	e59f3198	 ldr         r3, [pc, #0x198]
  00264	e5933010	 ldr         r3, [r3, #0x10]
  00268	e3530000	 cmp         r3, #0
  0026c	1a000003	 bne         |$LN10@trace_admi|

; 445  :           return TRUE; // full after store this block

  00270	e3a03001	 mov         r3, #1
  00274	e58d3000	 str         r3, [sp]
  00278	ea00005c	 b           |$LN15@trace_admi|

; 446  :         }else { //WRAP AROUND

  0027c	ea000002	 b           |$LN9@trace_admi|
  00280		 |$LN10@trace_admi|

; 447  :           return FALSE; 

  00280	e3a03000	 mov         r3, #0
  00284	e58d3000	 str         r3, [sp]
  00288	ea000058	 b           |$LN15@trace_admi|
  0028c		 |$LN9@trace_admi|

; 448  :         }
; 449  :       }else{

  0028c	ea000029	 b           |$LN8@trace_admi|
  00290		 |$LN11@trace_admi|

; 450  :         if(CFGBlock.EndAddress >= 
; 451  :            CFGBlock.StartAddress + CFGBlock.TraceBufferSize) 

  00290	e59f3168	 ldr         r3, [pc, #0x168]
  00294	e5932004	 ldr         r2, [r3, #4]
  00298	e59f3160	 ldr         r3, [pc, #0x160]
  0029c	e593300c	 ldr         r3, [r3, #0xC]
  002a0	e0822003	 add         r2, r2, r3
  002a4	e59f3154	 ldr         r3, [pc, #0x154]
  002a8	e5933008	 ldr         r3, [r3, #8]
  002ac	e1530002	 cmp         r3, r2
  002b0	3a000017	 bcc         |$LN7@trace_admi|

; 452  :           {// WRAP AROUND occur
; 453  :             if(CFGBlock.TraceMode == FILL_ONCE){

  002b4	e59f3144	 ldr         r3, [pc, #0x144]
  002b8	e5933010	 ldr         r3, [r3, #0x10]
  002bc	e3530000	 cmp         r3, #0
  002c0	1a000002	 bne         |$LN6@trace_admi|

; 454  :               return TRUE;/*buffer already full stop trace*/

  002c4	e3a03001	 mov         r3, #1
  002c8	e58d3000	 str         r3, [sp]
  002cc	ea000047	 b           |$LN15@trace_admi|
  002d0		 |$LN6@trace_admi|

; 455  :             }
; 456  :             *pbuffer =(char*) CFGBlock.StartAddress;

  002d0	e59f3128	 ldr         r3, [pc, #0x128]
  002d4	e5932004	 ldr         r2, [r3, #4]
  002d8	e59d300c	 ldr         r3, [sp, #0xC]
  002dc	e5832000	 str         r2, [r3]

; 457  :             CFGBlock.StartAddress += XDBTRACEBUFFERBLOCKSIZE;

  002e0	e59f3118	 ldr         r3, [pc, #0x118]
  002e4	e5933004	 ldr         r3, [r3, #4]
  002e8	e2832f43	 add         r2, r3, #0x43, 30
  002ec	e59f310c	 ldr         r3, [pc, #0x10C]
  002f0	e5832004	 str         r2, [r3, #4]

; 458  :             CFGBlock.EndAddress = CFGBlock.StartAddress;

  002f4	e59f3104	 ldr         r3, [pc, #0x104]
  002f8	e5932004	 ldr         r2, [r3, #4]
  002fc	e59f30fc	 ldr         r3, [pc, #0xFC]
  00300	e5832008	 str         r2, [r3, #8]

; 459  :             
; 460  :             return FALSE;

  00304	e3a03000	 mov         r3, #0
  00308	e58d3000	 str         r3, [sp]
  0030c	ea000037	 b           |$LN15@trace_admi|

; 461  :           }else{

  00310	ea000008	 b           |$LN5@trace_admi|
  00314		 |$LN7@trace_admi|

; 462  :             *pbuffer =(char*) CFGBlock.EndAddress;

  00314	e59f30e4	 ldr         r3, [pc, #0xE4]
  00318	e5932008	 ldr         r2, [r3, #8]
  0031c	e59d300c	 ldr         r3, [sp, #0xC]
  00320	e5832000	 str         r2, [r3]

; 463  :             CFGBlock.EndAddress += XDBTRACEBUFFERBLOCKSIZE;

  00324	e59f30d4	 ldr         r3, [pc, #0xD4]
  00328	e5933008	 ldr         r3, [r3, #8]
  0032c	e2832f43	 add         r2, r3, #0x43, 30
  00330	e59f30c8	 ldr         r3, [pc, #0xC8]
  00334	e5832008	 str         r2, [r3, #8]
  00338		 |$LN5@trace_admi|
  00338		 |$LN8@trace_admi|

; 464  :           }
; 465  :       }
; 466  :     } 
; 467  :     else

  00338	ea00002a	 b           |$LN4@trace_admi|
  0033c		 |$LN12@trace_admi|

; 468  :       {// has wrapped around // Startaddress == EndAddress
; 469  :         if(CFGBlock.EndAddress ==
; 470  :            (int) CFGBlock.pTraceBuffer + CFGBlock.TraceBufferSize) 

  0033c	e59f30bc	 ldr         r3, [pc, #0xBC]
  00340	e5932000	 ldr         r2, [r3]
  00344	e59f30b4	 ldr         r3, [pc, #0xB4]
  00348	e593300c	 ldr         r3, [r3, #0xC]
  0034c	e0822003	 add         r2, r2, r3
  00350	e59f30a8	 ldr         r3, [pc, #0xA8]
  00354	e5933008	 ldr         r3, [r3, #8]
  00358	e1530002	 cmp         r3, r2
  0035c	1a000014	 bne         |$LN3@trace_admi|

; 471  :           {// WRAP AROUND occur
; 472  :             *pbuffer =(char*) CFGBlock.pTraceBuffer;                                    

  00360	e59f3098	 ldr         r3, [pc, #0x98]
  00364	e5932000	 ldr         r2, [r3]
  00368	e59d300c	 ldr         r3, [sp, #0xC]
  0036c	e5832000	 str         r2, [r3]

; 473  :             CFGBlock.StartAddress = (int)CFGBlock.pTraceBuffer+
; 474  :                                      XDBTRACEBUFFERBLOCKSIZE;

  00370	e59f3088	 ldr         r3, [pc, #0x88]
  00374	e5933000	 ldr         r3, [r3]
  00378	e2832f43	 add         r2, r3, #0x43, 30
  0037c	e59f307c	 ldr         r3, [pc, #0x7C]
  00380	e5832004	 str         r2, [r3, #4]

; 475  :             CFGBlock.EndAddress = CFGBlock.StartAddress;

  00384	e59f3074	 ldr         r3, [pc, #0x74]
  00388	e5932004	 ldr         r2, [r3, #4]
  0038c	e59f306c	 ldr         r3, [pc, #0x6C]
  00390	e5832008	 str         r2, [r3, #8]

; 476  :             if(CFGBlock.TraceMode == FILL_ONCE)

  00394	e59f3064	 ldr         r3, [pc, #0x64]
  00398	e5933010	 ldr         r3, [r3, #0x10]
  0039c	e3530000	 cmp         r3, #0
  003a0	1a000002	 bne         |$LN2@trace_admi|

; 477  :               return TRUE; // full after store this block

  003a4	e3a03001	 mov         r3, #1
  003a8	e58d3000	 str         r3, [sp]
  003ac	ea00000f	 b           |$LN15@trace_admi|
  003b0		 |$LN2@trace_admi|

; 478  :           }else

  003b0	ea00000c	 b           |$LN1@trace_admi|
  003b4		 |$LN3@trace_admi|

; 479  :             {
; 480  :               *pbuffer =(char*) CFGBlock.EndAddress;

  003b4	e59f3044	 ldr         r3, [pc, #0x44]
  003b8	e5932008	 ldr         r2, [r3, #8]
  003bc	e59d300c	 ldr         r3, [sp, #0xC]
  003c0	e5832000	 str         r2, [r3]

; 481  :               CFGBlock.StartAddress += XDBTRACEBUFFERBLOCKSIZE;

  003c4	e59f3034	 ldr         r3, [pc, #0x34]
  003c8	e5933004	 ldr         r3, [r3, #4]
  003cc	e2832f43	 add         r2, r3, #0x43, 30
  003d0	e59f3028	 ldr         r3, [pc, #0x28]
  003d4	e5832004	 str         r2, [r3, #4]

; 482  :               CFGBlock.EndAddress = CFGBlock.StartAddress;

  003d8	e59f3020	 ldr         r3, [pc, #0x20]
  003dc	e5932004	 ldr         r2, [r3, #4]
  003e0	e59f3018	 ldr         r3, [pc, #0x18]
  003e4	e5832008	 str         r2, [r3, #8]
  003e8		 |$LN1@trace_admi|
  003e8		 |$LN4@trace_admi|

; 483  :             }
; 484  :       }
; 485  :     return FALSE;

  003e8	e3a03000	 mov         r3, #0
  003ec	e58d3000	 str         r3, [sp]
  003f0		 |$LN13@trace_admi|
  003f0		 |$LN15@trace_admi|

; 486  :   }
; 487  : }

  003f0	e59d0000	 ldr         r0, [sp]
  003f4	e28dd004	 add         sp, sp, #4
  003f8	e89d6000	 ldmia       sp, {sp, lr}
  003fc	e12fff1e	 bx          lr
  00400		 |$LN20@trace_admi|
  00400		 |$LN21@trace_admi|
  00400	00000000	 DCD         |CFGBlock|
  00404		 |$M16559|

			 ENDP  ; |trace_admin_multi|


  00020			 AREA	 |.pdata|, PDATA
|$T16569| DCD	|$LN12@IsUserMode|
	DCD	0x40003c04
; Function compile flags: /Odtp

  00404			 AREA	 |.text|, CODE, ARM

  00404		 |IsUserModeCapture| PROC

; 499  : {

  00404		 |$LN12@IsUserMode|
  00404	e1a0c00d	 mov         r12, sp
  00408	e92d0001	 stmdb       sp!, {r0}
  0040c	e92d5000	 stmdb       sp!, {r12, lr}
  00410	e24dd010	 sub         sp, sp, #0x10
  00414		 |$M16566|

; 500  :   register BYTE * p;
; 501  :   register DWORD Address;
; 502  : 
; 503  :   for ( p = &pTrcBuf[256]; p > pTrcBuf; p-- ) {

  00414	e59d3018	 ldr         r3, [sp, #0x18]
  00418	e2833c01	 add         r3, r3, #1, 24
  0041c	e58d3000	 str         r3, [sp]
  00420	ea000002	 b           |$LN7@IsUserMode|
  00424		 |$LN6@IsUserMode|
  00424	e59d3000	 ldr         r3, [sp]
  00428	e2433001	 sub         r3, r3, #1
  0042c	e58d3000	 str         r3, [sp]
  00430		 |$LN7@IsUserMode|
  00430	e59d2000	 ldr         r2, [sp]
  00434	e59d3018	 ldr         r3, [sp, #0x18]
  00438	e1520003	 cmp         r2, r3
  0043c	9a000026	 bls         |$LN5@IsUserMode|

; 504  :     switch(*p & 0xF0) {

  00440	e59d3000	 ldr         r3, [sp]
  00444	e5d33000	 ldrb        r3, [r3]
  00448	e20330f0	 and         r3, r3, #0xF0
  0044c	e58d300c	 str         r3, [sp, #0xC]
  00450	e59d300c	 ldr         r3, [sp, #0xC]
  00454	e3530090	 cmp         r3, #0x90
  00458	0a000003	 beq         |$LN2@IsUserMode|
  0045c	e59d300c	 ldr         r3, [sp, #0xC]
  00460	e35300d0	 cmp         r3, #0xD0
  00464	0a000000	 beq         |$LN2@IsUserMode|
  00468	ea00001a	 b           |$LN3@IsUserMode|
  0046c		 |$LN2@IsUserMode|

; 505  :     case 0x90:  // indirect branch
; 506  :     case 0xD0: // indirect branch with chkpt
; 507  :       p -= 4;

  0046c	e59d3000	 ldr         r3, [sp]
  00470	e2433004	 sub         r3, r3, #4
  00474	e58d3000	 str         r3, [sp]

; 508  :       Address = (p[0] << 24) | ( p[1] << 16 ) | (p[2] << 8) | p[3];

  00478	e59d3000	 ldr         r3, [sp]
  0047c	e5d33000	 ldrb        r3, [r3]
  00480	e1a02c03	 mov         r2, r3, lsl #24
  00484	e59d3000	 ldr         r3, [sp]
  00488	e2833001	 add         r3, r3, #1
  0048c	e5d33000	 ldrb        r3, [r3]
  00490	e1a03803	 mov         r3, r3, lsl #16
  00494	e1822003	 orr         r2, r2, r3
  00498	e59d3000	 ldr         r3, [sp]
  0049c	e2833002	 add         r3, r3, #2
  004a0	e5d33000	 ldrb        r3, [r3]
  004a4	e1a03403	 mov         r3, r3, lsl #8
  004a8	e1822003	 orr         r2, r2, r3
  004ac	e59d3000	 ldr         r3, [sp]
  004b0	e2833003	 add         r3, r3, #3
  004b4	e5d33000	 ldrb        r3, [r3]
  004b8	e1823003	 orr         r3, r2, r3
  004bc	e58d3004	 str         r3, [sp, #4]

; 509  :       if ( Address < 0x80000000) {  // user mode ?

  004c0	e59d3004	 ldr         r3, [sp, #4]
  004c4	e3530102	 cmp         r3, #2, 2
  004c8	2a000002	 bcs         |$LN1@IsUserMode|

; 510  :         return TRUE;

  004cc	e3a03001	 mov         r3, #1
  004d0	e58d3008	 str         r3, [sp, #8]
  004d4	ea000002	 b           |$LN8@IsUserMode|
  004d8		 |$LN1@IsUserMode|
  004d8		 |$LN3@IsUserMode|

; 511  :       }
; 512  :       break;
; 513  :     }
; 514  :   }

  004d8	eaffffd1	 b           |$LN6@IsUserMode|
  004dc		 |$LN5@IsUserMode|

; 515  :   return FALSE;

  004dc	e3a03000	 mov         r3, #0
  004e0	e58d3008	 str         r3, [sp, #8]
  004e4		 |$LN8@IsUserMode|

; 516  : }

  004e4	e59d0008	 ldr         r0, [sp, #8]
  004e8	e28dd010	 add         sp, sp, #0x10
  004ec	e89d6000	 ldmia       sp, {sp, lr}
  004f0	e12fff1e	 bx          lr
  004f4		 |$M16567|

			 ENDP  ; |IsUserModeCapture|

	EXPORT	|XSCBwrExecutionTraceOn|
	IMPORT	|XSCBwrEnableTrace|

  00028			 AREA	 |.pdata|, PDATA
|$T16574| DCD	|$LN6@XSCBwrExec|
	DCD	0x40001003
; Function compile flags: /Odtp

  004f4			 AREA	 |.text|, CODE, ARM

  004f4		 |XSCBwrExecutionTraceOn| PROC

; 548  : {

  004f4		 |$LN6@XSCBwrExec|
  004f4	e1a0c00d	 mov         r12, sp
  004f8	e92d0001	 stmdb       sp!, {r0}
  004fc	e92d5000	 stmdb       sp!, {r12, lr}
  00500		 |$M16571|

; 549  :     if (CFGBlock.TraceMode==TRACE_OFF)

  00500	e59f3028	 ldr         r3, [pc, #0x28]
  00504	e5933010	 ldr         r3, [r3, #0x10]
  00508	e3530002	 cmp         r3, #2
  0050c	1a000000	 bne         |$LN1@XSCBwrExec|

; 550  :         return;

  00510	ea000003	 b           |$LN2@XSCBwrExec|
  00514		 |$LN1@XSCBwrExec|

; 551  : 
; 552  :     CurrentTaskID = TID;

  00514	e59d2008	 ldr         r2, [sp, #8]
  00518	e59f300c	 ldr         r3, [pc, #0xC]
  0051c	e5832000	 str         r2, [r3]

; 553  :     XSCBwrEnableTrace();

  00520	eb000000	 bl          XSCBwrEnableTrace
  00524		 |$LN2@XSCBwrExec|

; 554  : }

  00524	e89d6000	 ldmia       sp, {sp, lr}
  00528	e12fff1e	 bx          lr
  0052c		 |$LN7@XSCBwrExec|
  0052c		 |$LN8@XSCBwrExec|
  0052c	00000000	 DCD         |CurrentTaskID|
  00530		 |$LN9@XSCBwrExec|
  00530	00000000	 DCD         |CFGBlock|
  00534		 |$M16572|

			 ENDP  ; |XSCBwrExecutionTraceOn|

	EXPORT	|XSCBwrExecutionTraceOff|
	IMPORT	|XSCBwrDisableTrace|

  00030			 AREA	 |.pdata|, PDATA
|$T16582| DCD	|$LN5@XSCBwrExec@2|
	DCD	0x40000603
; Function compile flags: /Odtp

  00534			 AREA	 |.text|, CODE, ARM

  00534		 |XSCBwrExecutionTraceOff| PROC

; 563  : {

  00534		 |$LN5@XSCBwrExec@2|
  00534	e1a0c00d	 mov         r12, sp
  00538	e92d0001	 stmdb       sp!, {r0}
  0053c	e92d5000	 stmdb       sp!, {r12, lr}
  00540		 |$M16579|

; 564  :     XSCBwrDisableTrace();

  00540	eb000000	 bl          XSCBwrDisableTrace

; 565  : }

  00544	e89d6000	 ldmia       sp, {sp, lr}
  00548	e12fff1e	 bx          lr
  0054c		 |$M16580|

			 ENDP  ; |XSCBwrExecutionTraceOff|

	EXPORT	|XSCBwrIoControl|

  00038			 AREA	 |.pdata|, PDATA
|$T16606| DCD	|$LN18@XSCBwrIoCo|
	DCD	0x4000ae04
; Function compile flags: /Odtp

  0054c			 AREA	 |.text|, CODE, ARM

  0054c		 |XSCBwrIoControl| PROC

; 696  : {

  0054c		 |$LN18@XSCBwrIoCo|
  0054c	e1a0c00d	 mov         r12, sp
  00550	e92d000f	 stmdb       sp!, {r0 - r3}
  00554	e92d5000	 stmdb       sp!, {r12, lr}
  00558	e24dd074	 sub         sp, sp, #0x74
  0055c		 |$M16603|

; 697  :   BOOL retval = FALSE;

  0055c	e3a03000	 mov         r3, #0
  00560	e58d3008	 str         r3, [sp, #8]

; 698  :   
; 699  :   switch( code ) {

  00564	e59d307c	 ldr         r3, [sp, #0x7C]
  00568	e58d3050	 str         r3, [sp, #0x50]
  0056c	e59d2050	 ldr         r2, [sp, #0x50]
  00570	e59f3288	 ldr         r3, [pc, #0x288]
  00574	e1520003	 cmp         r2, r3
  00578	8a000019	 bhi         |$LN14@XSCBwrIoCo|
  0057c	e59d2050	 ldr         r2, [sp, #0x50]
  00580	e59f3278	 ldr         r3, [pc, #0x278]
  00584	e1520003	 cmp         r2, r3
  00588	0a00003c	 beq         |$LN7@XSCBwrIoCo|
  0058c	e59d2050	 ldr         r2, [sp, #0x50]
  00590	e59f3264	 ldr         r3, [pc, #0x264]
  00594	e1520003	 cmp         r2, r3
  00598	8a00000c	 bhi         |$LN15@XSCBwrIoCo|
  0059c	e59d2050	 ldr         r2, [sp, #0x50]
  005a0	e59f3254	 ldr         r3, [pc, #0x254]
  005a4	e1520003	 cmp         r2, r3
  005a8	0a000041	 beq         |$LN6@XSCBwrIoCo|
  005ac	e59d2050	 ldr         r2, [sp, #0x50]
  005b0	e59f3240	 ldr         r3, [pc, #0x240]
  005b4	e1520003	 cmp         r2, r3
  005b8	0a000016	 beq         |$LN9@XSCBwrIoCo|
  005bc	e59d2050	 ldr         r2, [sp, #0x50]
  005c0	e59f322c	 ldr         r3, [pc, #0x22C]
  005c4	e1520003	 cmp         r2, r3
  005c8	0a00001f	 beq         |$LN8@XSCBwrIoCo|
  005cc	ea000079	 b           |$LN1@XSCBwrIoCo|
  005d0		 |$LN15@XSCBwrIoCo|
  005d0	e59d2050	 ldr         r2, [sp, #0x50]
  005d4	e59f3214	 ldr         r3, [pc, #0x214]
  005d8	e1520003	 cmp         r2, r3
  005dc	0a000041	 beq         |$LN5@XSCBwrIoCo|
  005e0	ea000074	 b           |$LN1@XSCBwrIoCo|
  005e4		 |$LN14@XSCBwrIoCo|
  005e4	e59d2050	 ldr         r2, [sp, #0x50]
  005e8	e59f31fc	 ldr         r3, [pc, #0x1FC]
  005ec	e1520003	 cmp         r2, r3
  005f0	0a000049	 beq         |$LN4@XSCBwrIoCo|
  005f4	e59d2050	 ldr         r2, [sp, #0x50]
  005f8	e59f31e8	 ldr         r3, [pc, #0x1E8]
  005fc	e1520003	 cmp         r2, r3
  00600	0a000052	 beq         |$LN3@XSCBwrIoCo|
  00604	e59d2050	 ldr         r2, [sp, #0x50]
  00608	e59f31d4	 ldr         r3, [pc, #0x1D4]
  0060c	e1520003	 cmp         r2, r3
  00610	0a00005b	 beq         |$LN2@XSCBwrIoCo|
  00614	ea000067	 b           |$LN1@XSCBwrIoCo|
  00618		 |$LN9@XSCBwrIoCo|

; 700  :   case IOCTL_XSDBG_READCOPROCESSOR: 
; 701  :       retval =  ReadCoProcessorIoctl( code, pInpBuffer, inpSize,
; 702  :                                       pOutBuffer, outSize, pOutSize);

  00618	e59d3090	 ldr         r3, [sp, #0x90]
  0061c	e58d3004	 str         r3, [sp, #4]
  00620	e59d308c	 ldr         r3, [sp, #0x8C]
  00624	e58d3000	 str         r3, [sp]
  00628	e59d3088	 ldr         r3, [sp, #0x88]
  0062c	e59d2084	 ldr         r2, [sp, #0x84]
  00630	e59d1080	 ldr         r1, [sp, #0x80]
  00634	e59d007c	 ldr         r0, [sp, #0x7C]
  00638	eb000000	 bl          ReadCoProcessorIoctl
  0063c	e58d0054	 str         r0, [sp, #0x54]
  00640	e59d3054	 ldr         r3, [sp, #0x54]
  00644	e58d3008	 str         r3, [sp, #8]

; 703  :       break;

  00648	ea00005e	 b           |$LN10@XSCBwrIoCo|
  0064c		 |$LN8@XSCBwrIoCo|

; 704  : 
; 705  :   case IOCTL_XSDBG_WRITECOPROCESSOR: 
; 706  :       retval = WriteCoProcessorIoctl( code, pInpBuffer, inpSize,
; 707  :                                       pOutBuffer, outSize, pOutSize);

  0064c	e59d3090	 ldr         r3, [sp, #0x90]
  00650	e58d3004	 str         r3, [sp, #4]
  00654	e59d308c	 ldr         r3, [sp, #0x8C]
  00658	e58d3000	 str         r3, [sp]
  0065c	e59d3088	 ldr         r3, [sp, #0x88]
  00660	e59d2084	 ldr         r2, [sp, #0x84]
  00664	e59d1080	 ldr         r1, [sp, #0x80]
  00668	e59d007c	 ldr         r0, [sp, #0x7C]
  0066c	eb000000	 bl          WriteCoProcessorIoctl
  00670	e58d0058	 str         r0, [sp, #0x58]
  00674	e59d3058	 ldr         r3, [sp, #0x58]
  00678	e58d3008	 str         r3, [sp, #8]

; 708  :       break;

  0067c	ea000051	 b           |$LN10@XSCBwrIoCo|
  00680		 |$LN7@XSCBwrIoCo|

; 709  : 
; 710  :   case IOCTL_XSDBG_SETTASK:
; 711  :       retval = SetTaskIoctl( code, pInpBuffer, inpSize,
; 712  :                                       pOutBuffer, outSize, pOutSize);

  00680	e59d3090	 ldr         r3, [sp, #0x90]
  00684	e58d3004	 str         r3, [sp, #4]
  00688	e59d308c	 ldr         r3, [sp, #0x8C]
  0068c	e58d3000	 str         r3, [sp]
  00690	e59d3088	 ldr         r3, [sp, #0x88]
  00694	e59d2084	 ldr         r2, [sp, #0x84]
  00698	e59d1080	 ldr         r1, [sp, #0x80]
  0069c	e59d007c	 ldr         r0, [sp, #0x7C]
  006a0	eb000000	 bl          SetTaskIoctl
  006a4	e58d005c	 str         r0, [sp, #0x5C]
  006a8	e59d305c	 ldr         r3, [sp, #0x5C]
  006ac	e58d3008	 str         r3, [sp, #8]

; 713  :       break;

  006b0	ea000044	 b           |$LN10@XSCBwrIoCo|
  006b4		 |$LN6@XSCBwrIoCo|

; 714  : 
; 715  :   
; 716  : /*  These tree IOCTLs are implemented by the BSP
; 717  :     case IOCTL_XSDBG_QUERYCTXREGS: 
; 718  :       retval = QueryContextRegistersIoctl(code, pInpBuffer, inpSize,
; 719  :                                       pOutBuffer, outSize, pOutSize);
; 720  :       break;
; 721  :     
; 722  :   case IOCTL_XSDBG_READCTXREGS: 
; 723  : 
; 724  :       retval = ReadContextRegisterIoctl( code, pInpBuffer, inpSize,
; 725  :                                       pOutBuffer, outSize, pOutSize);
; 726  :       break;
; 727  : 
; 728  :   case IOCTL_XSDBG_WRITECTXREGS: 
; 729  :       retval = WriteContextRegisterIoctl( code, pInpBuffer, inpSize,
; 730  :                                       pOutBuffer, outSize, pOutSize);
; 731  :       break;
; 732  : */
; 733  : 
; 734  :   case IOCTL_XSDBG_TRACECONTROL:
; 735  :       retval = TraceControlIoctl(code, pInpBuffer, inpSize,
; 736  :                                       pOutBuffer, outSize, pOutSize);

  006b4	e59d3090	 ldr         r3, [sp, #0x90]
  006b8	e58d3004	 str         r3, [sp, #4]
  006bc	e59d308c	 ldr         r3, [sp, #0x8C]
  006c0	e58d3000	 str         r3, [sp]
  006c4	e59d3088	 ldr         r3, [sp, #0x88]
  006c8	e59d2084	 ldr         r2, [sp, #0x84]
  006cc	e59d1080	 ldr         r1, [sp, #0x80]
  006d0	e59d007c	 ldr         r0, [sp, #0x7C]
  006d4	eb000000	 bl          TraceControlIoctl
  006d8	e58d0060	 str         r0, [sp, #0x60]
  006dc	e59d3060	 ldr         r3, [sp, #0x60]
  006e0	e58d3008	 str         r3, [sp, #8]

; 737  :       break;

  006e4	ea000037	 b           |$LN10@XSCBwrIoCo|
  006e8		 |$LN5@XSCBwrIoCo|

; 738  : 
; 739  :   case IOCTL_XSDBG_READTRACE: 
; 740  :       retval = ReadTraceIoctl( code, pInpBuffer, inpSize,
; 741  :                                       pOutBuffer, outSize, pOutSize);

  006e8	e59d3090	 ldr         r3, [sp, #0x90]
  006ec	e58d3004	 str         r3, [sp, #4]
  006f0	e59d308c	 ldr         r3, [sp, #0x8C]
  006f4	e58d3000	 str         r3, [sp]
  006f8	e59d3088	 ldr         r3, [sp, #0x88]
  006fc	e59d2084	 ldr         r2, [sp, #0x84]
  00700	e59d1080	 ldr         r1, [sp, #0x80]
  00704	e59d007c	 ldr         r0, [sp, #0x7C]
  00708	eb000000	 bl          ReadTraceIoctl
  0070c	e58d0064	 str         r0, [sp, #0x64]
  00710	e59d3064	 ldr         r3, [sp, #0x64]
  00714	e58d3008	 str         r3, [sp, #8]

; 742  :       break;

  00718	ea00002a	 b           |$LN10@XSCBwrIoCo|
  0071c		 |$LN4@XSCBwrIoCo|

; 743  : 
; 744  :   case IOCTL_XSDBG_READKMEM:
; 745  : 
; 746  :       retval = ReadKMemIoctl( code, pInpBuffer, inpSize,
; 747  :                                       pOutBuffer, outSize, pOutSize);

  0071c	e59d3090	 ldr         r3, [sp, #0x90]
  00720	e58d3004	 str         r3, [sp, #4]
  00724	e59d308c	 ldr         r3, [sp, #0x8C]
  00728	e58d3000	 str         r3, [sp]
  0072c	e59d3088	 ldr         r3, [sp, #0x88]
  00730	e59d2084	 ldr         r2, [sp, #0x84]
  00734	e59d1080	 ldr         r1, [sp, #0x80]
  00738	e59d007c	 ldr         r0, [sp, #0x7C]
  0073c	eb000000	 bl          ReadKMemIoctl
  00740	e58d0068	 str         r0, [sp, #0x68]
  00744	e59d3068	 ldr         r3, [sp, #0x68]
  00748	e58d3008	 str         r3, [sp, #8]

; 748  :       break;

  0074c	ea00001d	 b           |$LN10@XSCBwrIoCo|
  00750		 |$LN3@XSCBwrIoCo|

; 749  :   case IOCTL_XSDBG_GETTRACECONFIG:
; 750  : 
; 751  :       retval = GetTraceConfigIoctl( code, pInpBuffer, inpSize,
; 752  :                                       pOutBuffer, outSize, pOutSize);

  00750	e59d3090	 ldr         r3, [sp, #0x90]
  00754	e58d3004	 str         r3, [sp, #4]
  00758	e59d308c	 ldr         r3, [sp, #0x8C]
  0075c	e58d3000	 str         r3, [sp]
  00760	e59d3088	 ldr         r3, [sp, #0x88]
  00764	e59d2084	 ldr         r2, [sp, #0x84]
  00768	e59d1080	 ldr         r1, [sp, #0x80]
  0076c	e59d007c	 ldr         r0, [sp, #0x7C]
  00770	eb000000	 bl          GetTraceConfigIoctl
  00774	e58d006c	 str         r0, [sp, #0x6C]
  00778	e59d306c	 ldr         r3, [sp, #0x6C]
  0077c	e58d3008	 str         r3, [sp, #8]

; 753  :       break;

  00780	ea000010	 b           |$LN10@XSCBwrIoCo|
  00784		 |$LN2@XSCBwrIoCo|

; 754  : 
; 755  :   case IOCTL_XSDBG_GETVERSION:
; 756  : 
; 757  :       retval = GetVersionIoctl( code, pInpBuffer, inpSize,
; 758  :                                       pOutBuffer, outSize, pOutSize);

  00784	e59d3090	 ldr         r3, [sp, #0x90]
  00788	e58d3004	 str         r3, [sp, #4]
  0078c	e59d308c	 ldr         r3, [sp, #0x8C]
  00790	e58d3000	 str         r3, [sp]
  00794	e59d3088	 ldr         r3, [sp, #0x88]
  00798	e59d2084	 ldr         r2, [sp, #0x84]
  0079c	e59d1080	 ldr         r1, [sp, #0x80]
  007a0	e59d007c	 ldr         r0, [sp, #0x7C]
  007a4	eb000000	 bl          GetVersionIoctl
  007a8	e58d0070	 str         r0, [sp, #0x70]
  007ac	e59d3070	 ldr         r3, [sp, #0x70]
  007b0	e58d3008	 str         r3, [sp, #8]

; 759  :       break;

  007b4	ea000003	 b           |$LN10@XSCBwrIoCo|
  007b8		 |$LN1@XSCBwrIoCo|

; 760  :   default:
; 761  :     SetLastError(ERROR_NOT_SUPPORTED);

  007b8	e3a00032	 mov         r0, #0x32
  007bc	e59f301c	 ldr         r3, [pc, #0x1C]
  007c0	e1a0e00f	 mov         lr, pc
  007c4	e12fff13	 bx          r3
  007c8		 |$LN10@XSCBwrIoCo|

; 762  :     break;
; 763  :   }
; 764  : 
; 765  :   return retval;

  007c8	e59d3008	 ldr         r3, [sp, #8]
  007cc	e58d304c	 str         r3, [sp, #0x4C]

; 766  : }

  007d0	e59d004c	 ldr         r0, [sp, #0x4C]
  007d4	e28dd074	 add         sp, sp, #0x74
  007d8	e89d6000	 ldmia       sp, {sp, lr}
  007dc	e12fff1e	 bx          lr
  007e0		 |$LN19@XSCBwrIoCo|
  007e0		 |$LN20@XSCBwrIoCo|
  007e0	f101ffb4	 DCD         0xf101ffb4
  007e4		 |$LN21@XSCBwrIoCo|
  007e4	01013f70	 DCD         0x1013f70
  007e8		 |$LN22@XSCBwrIoCo|
  007e8	01013f6c	 DCD         0x1013f6c
  007ec		 |$LN23@XSCBwrIoCo|
  007ec	01013f68	 DCD         0x1013f68
  007f0		 |$LN24@XSCBwrIoCo|
  007f0	01013f60	 DCD         0x1013f60
  007f4		 |$LN25@XSCBwrIoCo|
  007f4	01013f4c	 DCD         0x1013f4c
  007f8		 |$LN26@XSCBwrIoCo|
  007f8	01013f48	 DCD         0x1013f48
  007fc		 |$LN27@XSCBwrIoCo|
  007fc	01013f5c	 DCD         0x1013f5c
  00800		 |$LN28@XSCBwrIoCo|
  00800	01013f64	 DCD         0x1013f64
  00804		 |$M16604|

			 ENDP  ; |XSCBwrIoControl|


  00040			 AREA	 |.pdata|, PDATA
|$T16622| DCD	|$LN7@GetVersion|
	DCD	0x40002b04
; Function compile flags: /Odtp

  00804			 AREA	 |.text|, CODE, ARM

  00804		 |GetVersionIoctl| PROC

; 56   : {

  00804		 |$LN7@GetVersion|
  00804	e1a0c00d	 mov         r12, sp
  00808	e92d000f	 stmdb       sp!, {r0 - r3}
  0080c	e92d5000	 stmdb       sp!, {r12, lr}
  00810	e24dd00c	 sub         sp, sp, #0xC
  00814		 |$M16619|

; 57   :     // output buffer format
; 58   :     PXSCBwrVersion pXSCBwrVersion;
; 59   : 
; 60   :     // Return Value
; 61   :     BOOL retval = FALSE;

  00814	e3a03000	 mov         r3, #0
  00818	e58d3000	 str         r3, [sp]

; 62   : 
; 63   :     if ( (lpOutBuf == NULL ) ||
; 64   :          (sizeof(XSCBwrVersion) > nOutBufSize) || 
; 65   :          (lpBytesReturned == NULL) 
; 66   :        )

  0081c	e59d3020	 ldr         r3, [sp, #0x20]
  00820	e3530000	 cmp         r3, #0
  00824	0a000005	 beq         |$LN1@GetVersion|
  00828	e59d3024	 ldr         r3, [sp, #0x24]
  0082c	e3530008	 cmp         r3, #8
  00830	3a000002	 bcc         |$LN1@GetVersion|
  00834	e59d3028	 ldr         r3, [sp, #0x28]
  00838	e3530000	 cmp         r3, #0
  0083c	1a000006	 bne         |$LN2@GetVersion|
  00840		 |$LN1@GetVersion|

; 67   :     {
; 68   :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00840	e3a0007a	 mov         r0, #0x7A
  00844	e59f3060	 ldr         r3, [pc, #0x60]
  00848	e1a0e00f	 mov         lr, pc
  0084c	e12fff13	 bx          r3

; 69   :         return (retval);

  00850	e59d3000	 ldr         r3, [sp]
  00854	e58d3008	 str         r3, [sp, #8]
  00858	ea00000f	 b           |$LN3@GetVersion|
  0085c		 |$LN2@GetVersion|

; 70   :     }
; 71   : 
; 72   :     pXSCBwrVersion = (PXSCBwrVersion)lpOutBuf;

  0085c	e59d3020	 ldr         r3, [sp, #0x20]
  00860	e58d3004	 str         r3, [sp, #4]

; 73   :     
; 74   :     pXSCBwrVersion->Major = XSCBWR_V_MAJOR;

  00864	e59d2004	 ldr         r2, [sp, #4]
  00868	e3a03001	 mov         r3, #1
  0086c	e5823000	 str         r3, [r2]

; 75   :     pXSCBwrVersion->Minor = XSCBWR_V_MINOR;

  00870	e59d3004	 ldr         r3, [sp, #4]
  00874	e2832004	 add         r2, r3, #4
  00878	e3a03002	 mov         r3, #2
  0087c	e5823000	 str         r3, [r2]

; 76   : 
; 77   :     // Set the Bytes Returned size
; 78   :     *lpBytesReturned = sizeof(XSCBwrVersion);

  00880	e59d2028	 ldr         r2, [sp, #0x28]
  00884	e3a03008	 mov         r3, #8
  00888	e5823000	 str         r3, [r2]

; 79   : 
; 80   :     // Set the return value
; 81   :     retval = TRUE;

  0088c	e3a03001	 mov         r3, #1
  00890	e58d3000	 str         r3, [sp]

; 82   : 
; 83   :     return (retval);

  00894	e59d3000	 ldr         r3, [sp]
  00898	e58d3008	 str         r3, [sp, #8]
  0089c		 |$LN3@GetVersion|

; 84   : }

  0089c	e59d0008	 ldr         r0, [sp, #8]
  008a0	e28dd00c	 add         sp, sp, #0xC
  008a4	e89d6000	 ldmia       sp, {sp, lr}
  008a8	e12fff1e	 bx          lr
  008ac		 |$LN8@GetVersion|
  008ac		 |$LN9@GetVersion|
  008ac	f101ffb4	 DCD         0xf101ffb4
  008b0		 |$M16620|

			 ENDP  ; |GetVersionIoctl|

	IMPORT	|XSCBwrExecuteCoProcCode|

  00048			 AREA	 |.pdata|, PDATA
|$T16630| DCD	|$LN9@ReadCoProc|
	DCD	0x40003604
; Function compile flags: /Odtp

  008b0			 AREA	 |.text|, CODE, ARM

  008b0		 |ReadCoProcessorIoctl| PROC

; 99   : {

  008b0		 |$LN9@ReadCoProc|
  008b0	e1a0c00d	 mov         r12, sp
  008b4	e92d000f	 stmdb       sp!, {r0 - r3}
  008b8	e92d5000	 stmdb       sp!, {r12, lr}
  008bc	e24dd010	 sub         sp, sp, #0x10
  008c0		 |$M16627|

; 100  :     // CoProc Read Input Buffer Ptr
; 101  :     PXSCBwrRdRegIn pXSCBwrRdRegInBuf;
; 102  : 
; 103  :     // CoProc Read Output Buffer Ptr
; 104  :     PXSCBwrRdRegOut pXSCBwrRdRegOutBuf;
; 105  : 
; 106  :     // Return Value
; 107  :     BOOL retval = FALSE;

  008c0	e3a03000	 mov         r3, #0
  008c4	e58d3000	 str         r3, [sp]

; 108  : 
; 109  :     //Check the size of the input & Output buffers      
; 110  :     if ((lpInBuf == NULL) || (lpOutBuf == NULL))

  008c8	e59d301c	 ldr         r3, [sp, #0x1C]
  008cc	e3530000	 cmp         r3, #0
  008d0	0a000002	 beq         |$LN3@ReadCoProc|
  008d4	e59d3024	 ldr         r3, [sp, #0x24]
  008d8	e3530000	 cmp         r3, #0
  008dc	1a000006	 bne         |$LN4@ReadCoProc|
  008e0		 |$LN3@ReadCoProc|

; 111  :     {
; 112  :         SetLastError(ERROR_INVALID_PARAMETER);

  008e0	e3a00057	 mov         r0, #0x57
  008e4	e59f3098	 ldr         r3, [pc, #0x98]
  008e8	e1a0e00f	 mov         lr, pc
  008ec	e12fff13	 bx          r3

; 113  :         return (retval);

  008f0	e59d3000	 ldr         r3, [sp]
  008f4	e58d300c	 str         r3, [sp, #0xC]
  008f8	ea00001d	 b           |$LN5@ReadCoProc|
  008fc		 |$LN4@ReadCoProc|

; 114  :     }
; 115  :     if ( (sizeof(XSCBwrRdRegOut) > nOutBufSize) || (lpBytesReturned == NULL) )

  008fc	e59d3028	 ldr         r3, [sp, #0x28]
  00900	e3530008	 cmp         r3, #8
  00904	3a000002	 bcc         |$LN1@ReadCoProc|
  00908	e59d302c	 ldr         r3, [sp, #0x2C]
  0090c	e3530000	 cmp         r3, #0
  00910	1a000006	 bne         |$LN2@ReadCoProc|
  00914		 |$LN1@ReadCoProc|

; 116  :     {
; 117  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00914	e3a0007a	 mov         r0, #0x7A
  00918	e59f3064	 ldr         r3, [pc, #0x64]
  0091c	e1a0e00f	 mov         lr, pc
  00920	e12fff13	 bx          r3

; 118  :         return (retval);

  00924	e59d3000	 ldr         r3, [sp]
  00928	e58d300c	 str         r3, [sp, #0xC]
  0092c	ea000010	 b           |$LN5@ReadCoProc|
  00930		 |$LN2@ReadCoProc|

; 119  :     }
; 120  : 
; 121  :     pXSCBwrRdRegInBuf = (PXSCBwrRdRegIn)lpInBuf;

  00930	e59d301c	 ldr         r3, [sp, #0x1C]
  00934	e58d3008	 str         r3, [sp, #8]

; 122  :     pXSCBwrRdRegOutBuf = (PXSCBwrRdRegOut)lpOutBuf;

  00938	e59d3024	 ldr         r3, [sp, #0x24]
  0093c	e58d3004	 str         r3, [sp, #4]

; 123  : 
; 124  :     // execute the 'read'
; 125  :     XSCBwrExecuteCoProcCode((pXSCBwrRdRegInBuf->OpCode), 
; 126  :                             (&pXSCBwrRdRegOutBuf->Reg1), 
; 127  :                             (&pXSCBwrRdRegOutBuf->Reg2));

  00940	e59d3004	 ldr         r3, [sp, #4]
  00944	e2832004	 add         r2, r3, #4
  00948	e59d1004	 ldr         r1, [sp, #4]
  0094c	e59d3008	 ldr         r3, [sp, #8]
  00950	e5930000	 ldr         r0, [r3]
  00954	eb000000	 bl          XSCBwrExecuteCoProcCode

; 128  : 
; 129  :     // Set the Bytes Returned size
; 130  :     *lpBytesReturned = sizeof(XSCBwrRdRegOut);

  00958	e59d202c	 ldr         r2, [sp, #0x2C]
  0095c	e3a03008	 mov         r3, #8
  00960	e5823000	 str         r3, [r2]

; 131  : 
; 132  :     // Set the return value
; 133  :     retval = TRUE;

  00964	e3a03001	 mov         r3, #1
  00968	e58d3000	 str         r3, [sp]

; 134  : 
; 135  :     return (retval);

  0096c	e59d3000	 ldr         r3, [sp]
  00970	e58d300c	 str         r3, [sp, #0xC]
  00974		 |$LN5@ReadCoProc|

; 136  : }

  00974	e59d000c	 ldr         r0, [sp, #0xC]
  00978	e28dd010	 add         sp, sp, #0x10
  0097c	e89d6000	 ldmia       sp, {sp, lr}
  00980	e12fff1e	 bx          lr
  00984		 |$LN10@ReadCoProc|
  00984		 |$LN11@ReadCoProc|
  00984	f101ffb4	 DCD         0xf101ffb4
  00988		 |$M16628|

			 ENDP  ; |ReadCoProcessorIoctl|


  00050			 AREA	 |.pdata|, PDATA
|$T16638| DCD	|$LN7@WriteCoPro|
	DCD	0x40002804
; Function compile flags: /Odtp

  00988			 AREA	 |.text|, CODE, ARM

  00988		 |WriteCoProcessorIoctl| PROC

; 152  : {

  00988		 |$LN7@WriteCoPro|
  00988	e1a0c00d	 mov         r12, sp
  0098c	e92d000f	 stmdb       sp!, {r0 - r3}
  00990	e92d5000	 stmdb       sp!, {r12, lr}
  00994	e24dd00c	 sub         sp, sp, #0xC
  00998		 |$M16635|

; 153  :     // CoProc Write Input Buffer Ptr
; 154  :     PXSCBwrWrteRegIn pXSCBwrWrteRegInBuf;
; 155  : 
; 156  :     // Set the default return value
; 157  :     BOOL retval = FALSE;

  00998	e3a03000	 mov         r3, #0
  0099c	e58d3004	 str         r3, [sp, #4]

; 158  : 
; 159  :     //Check the size of the input & Output buffers (no output buffer for write)
; 160  :     //
; 161  :     if ((lpInBuf == NULL) || (nInBufSize < (sizeof(XSCBwrWrteRegIn)) ) )

  009a0	e59d3018	 ldr         r3, [sp, #0x18]
  009a4	e3530000	 cmp         r3, #0
  009a8	0a000002	 beq         |$LN1@WriteCoPro|
  009ac	e59d301c	 ldr         r3, [sp, #0x1C]
  009b0	e353000c	 cmp         r3, #0xC
  009b4	2a000006	 bcs         |$LN2@WriteCoPro|
  009b8		 |$LN1@WriteCoPro|

; 162  :     {
; 163  :         SetLastError(ERROR_INVALID_PARAMETER);

  009b8	e3a00057	 mov         r0, #0x57
  009bc	e59f3060	 ldr         r3, [pc, #0x60]
  009c0	e1a0e00f	 mov         lr, pc
  009c4	e12fff13	 bx          r3

; 164  :         return (retval);

  009c8	e59d3004	 ldr         r3, [sp, #4]
  009cc	e58d3008	 str         r3, [sp, #8]
  009d0	ea00000f	 b           |$LN3@WriteCoPro|
  009d4		 |$LN2@WriteCoPro|

; 165  :     }
; 166  : 
; 167  :     //Now assign the input buffer
; 168  :     pXSCBwrWrteRegInBuf = (PXSCBwrWrteRegIn)lpInBuf;

  009d4	e59d3018	 ldr         r3, [sp, #0x18]
  009d8	e58d3000	 str         r3, [sp]

; 169  : 
; 170  :     // execute the 'write'
; 171  :     //
; 172  :     XSCBwrExecuteCoProcCode((pXSCBwrWrteRegInBuf->OpCode), 
; 173  :                             (&pXSCBwrWrteRegInBuf->Reg1), 
; 174  :                             (&pXSCBwrWrteRegInBuf->Reg2));

  009dc	e59d3000	 ldr         r3, [sp]
  009e0	e2832008	 add         r2, r3, #8
  009e4	e59d3000	 ldr         r3, [sp]
  009e8	e2831004	 add         r1, r3, #4
  009ec	e59d3000	 ldr         r3, [sp]
  009f0	e5930000	 ldr         r0, [r3]
  009f4	eb000000	 bl          XSCBwrExecuteCoProcCode

; 175  : 
; 176  :     // Set the Bytes Returned size
; 177  :     *lpBytesReturned = 0;

  009f8	e59d2028	 ldr         r2, [sp, #0x28]
  009fc	e3a03000	 mov         r3, #0
  00a00	e5823000	 str         r3, [r2]

; 178  : 
; 179  :     // Set the return value
; 180  :     retval = TRUE;

  00a04	e3a03001	 mov         r3, #1
  00a08	e58d3004	 str         r3, [sp, #4]

; 181  : 
; 182  :     return (retval);

  00a0c	e59d3004	 ldr         r3, [sp, #4]
  00a10	e58d3008	 str         r3, [sp, #8]
  00a14		 |$LN3@WriteCoPro|

; 183  : 
; 184  : }

  00a14	e59d0008	 ldr         r0, [sp, #8]
  00a18	e28dd00c	 add         sp, sp, #0xC
  00a1c	e89d6000	 ldmia       sp, {sp, lr}
  00a20	e12fff1e	 bx          lr
  00a24		 |$LN8@WriteCoPro|
  00a24		 |$LN9@WriteCoPro|
  00a24	f101ffb4	 DCD         0xf101ffb4
  00a28		 |$M16636|

			 ENDP  ; |WriteCoProcessorIoctl|


  00058			 AREA	 |.pdata|, PDATA
|$T16646| DCD	|$LN10@SetTaskIoc|
	DCD	0x40004304
; Function compile flags: /Odtp

  00a28			 AREA	 |.text|, CODE, ARM

  00a28		 |SetTaskIoctl| PROC

; 198  : {

  00a28		 |$LN10@SetTaskIoc|
  00a28	e1a0c00d	 mov         r12, sp
  00a2c	e92d000f	 stmdb       sp!, {r0 - r3}
  00a30	e92d5000	 stmdb       sp!, {r12, lr}
  00a34	e24dd00c	 sub         sp, sp, #0xC
  00a38		 |$M16643|

; 199  :     // Set Task Input Buffer Ptr
; 200  :     PXSCBwrSetTaskIn pXSCBwrSetTaskInBuf;
; 201  : 
; 202  :     // Set the default return value 
; 203  :     BOOL retval = FALSE;

  00a38	e3a03000	 mov         r3, #0
  00a3c	e58d3000	 str         r3, [sp]

; 204  : 
; 205  :     //Check the size of the input buffer
; 206  : 
; 207  :     if ((lpInBuf == NULL) || (sizeof(XSCBwrSetTaskIn) > nInBufSize))

  00a40	e59d3018	 ldr         r3, [sp, #0x18]
  00a44	e3530000	 cmp         r3, #0
  00a48	0a000002	 beq         |$LN4@SetTaskIoc|
  00a4c	e59d301c	 ldr         r3, [sp, #0x1C]
  00a50	e3530008	 cmp         r3, #8
  00a54	2a000006	 bcs         |$LN5@SetTaskIoc|
  00a58		 |$LN4@SetTaskIoc|

; 208  :     {
; 209  :         SetLastError(ERROR_INVALID_PARAMETER);

  00a58	e3a00057	 mov         r0, #0x57
  00a5c	e59f30cc	 ldr         r3, [pc, #0xCC]
  00a60	e1a0e00f	 mov         lr, pc
  00a64	e12fff13	 bx          r3

; 210  :         return (retval);

  00a68	e59d3000	 ldr         r3, [sp]
  00a6c	e58d3008	 str         r3, [sp, #8]
  00a70	ea000028	 b           |$LN6@SetTaskIoc|
  00a74		 |$LN5@SetTaskIoc|

; 211  :     }
; 212  :     if ( (lpBytesReturned == NULL) )

  00a74	e59d3028	 ldr         r3, [sp, #0x28]
  00a78	e3530000	 cmp         r3, #0
  00a7c	1a000006	 bne         |$LN3@SetTaskIoc|

; 213  :     {
; 214  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00a80	e3a0007a	 mov         r0, #0x7A
  00a84	e59f30a4	 ldr         r3, [pc, #0xA4]
  00a88	e1a0e00f	 mov         lr, pc
  00a8c	e12fff13	 bx          r3

; 215  :         return (retval);

  00a90	e59d3000	 ldr         r3, [sp]
  00a94	e58d3008	 str         r3, [sp, #8]
  00a98	ea00001e	 b           |$LN6@SetTaskIoc|
  00a9c		 |$LN3@SetTaskIoc|

; 216  :     }
; 217  : 
; 218  :     pXSCBwrSetTaskInBuf = (PXSCBwrSetTaskIn)lpInBuf;

  00a9c	e59d3018	 ldr         r3, [sp, #0x18]
  00aa0	e58d3004	 str         r3, [sp, #4]

; 219  : 
; 220  :     if ( pXSCBwrSetTaskInBuf->ThreadID ) {

  00aa4	e59d3004	 ldr         r3, [sp, #4]
  00aa8	e2833004	 add         r3, r3, #4
  00aac	e5933000	 ldr         r3, [r3]
  00ab0	e3530000	 cmp         r3, #0
  00ab4	0a000009	 beq         |$LN2@SetTaskIoc|

; 221  :       XSCBwrThreadID = pXSCBwrSetTaskInBuf->ThreadID;

  00ab8	e59d3004	 ldr         r3, [sp, #4]
  00abc	e2833004	 add         r3, r3, #4
  00ac0	e5932000	 ldr         r2, [r3]
  00ac4	e59f305c	 ldr         r3, [pc, #0x5C]
  00ac8	e5832000	 str         r2, [r3]

; 222  :       XSCBwrProcessID = pXSCBwrSetTaskInBuf->ProcessID;

  00acc	e59d3004	 ldr         r3, [sp, #4]
  00ad0	e5932000	 ldr         r2, [r3]
  00ad4	e59f3050	 ldr         r3, [pc, #0x50]
  00ad8	e5832000	 str         r2, [r3]

; 223  :     } else {

  00adc	ea000006	 b           |$LN1@SetTaskIoc|
  00ae0		 |$LN2@SetTaskIoc|

; 224  :       // thread set to 0: Browser is detaching from thread
; 225  :       //
; 226  :       XSCBwrThreadID = XSCBwrProcessID = (DWORD)INVALID_HANDLE_VALUE;

  00ae0	e59f2044	 ldr         r2, [pc, #0x44]
  00ae4	e3e03000	 mvn         r3, #0
  00ae8	e5823000	 str         r3, [r2]
  00aec	e59f3038	 ldr         r3, [pc, #0x38]
  00af0	e5932000	 ldr         r2, [r3]
  00af4	e59f302c	 ldr         r3, [pc, #0x2C]
  00af8	e5832000	 str         r2, [r3]
  00afc		 |$LN1@SetTaskIoc|

; 227  :     }
; 228  : 
; 229  :     // Set the Bytes Returned size
; 230  :     *lpBytesReturned = 0;

  00afc	e59d2028	 ldr         r2, [sp, #0x28]
  00b00	e3a03000	 mov         r3, #0
  00b04	e5823000	 str         r3, [r2]

; 231  : 
; 232  :     // Set the return value
; 233  :     retval = TRUE;

  00b08	e3a03001	 mov         r3, #1
  00b0c	e58d3000	 str         r3, [sp]

; 234  : 
; 235  :     return (retval);

  00b10	e59d3000	 ldr         r3, [sp]
  00b14	e58d3008	 str         r3, [sp, #8]
  00b18		 |$LN6@SetTaskIoc|

; 236  : }

  00b18	e59d0008	 ldr         r0, [sp, #8]
  00b1c	e28dd00c	 add         sp, sp, #0xC
  00b20	e89d6000	 ldmia       sp, {sp, lr}
  00b24	e12fff1e	 bx          lr
  00b28		 |$LN11@SetTaskIoc|
  00b28		 |$LN12@SetTaskIoc|
  00b28	00000000	 DCD         |XSCBwrThreadID|
  00b2c		 |$LN13@SetTaskIoc|
  00b2c	00000000	 DCD         |XSCBwrProcessID|
  00b30		 |$LN14@SetTaskIoc|
  00b30	f101ffb4	 DCD         0xf101ffb4
  00b34		 |$M16644|

			 ENDP  ; |SetTaskIoctl|

	IMPORT	|__C_specific_handler|

  00060			 AREA	 |.pdata|, PDATA
|$T16667| DCD	|$LN21@ReadKMemIo|
	DCD	0xc0005805
|$T16669| DCD	|$LN11@ReadKMemIo|
	DCD	0x40000401

  00000			 AREA	 |.xdata|, DATA
|$T16665| DCD	0x1
	DCD	|$LN15@ReadKMemIo|
	DCD	|$LN16@ReadKMemIo|
	DCD	|$LN11@ReadKMemIo|
	DCD	|$LN12@ReadKMemIo|
; Function compile flags: /Odtp

  00b34			 AREA	 |.text|, CODE, ARM

  00b34	00000000	 DCD         |__C_specific_handler|
  00b38	00000000	 DCD         |$T16665|

  00b3c		 |ReadKMemIoctl| PROC

; 251  : {

  00b3c		 |$LN21@ReadKMemIo|
  00b3c	e1a0c00d	 mov         r12, sp
  00b40	e92d000f	 stmdb       sp!, {r0 - r3}
  00b44	e92d5800	 stmdb       sp!, {r11, r12, lr}
  00b48	e28db00c	 add         r11, sp, #0xC
  00b4c	e24dd00c	 sub         sp, sp, #0xC
  00b50		 |$LN19@ReadKMemIo|

; 252  :     // Set kmem read Input Buffer Ptr
; 253  :     PXSCBwrRdKMem pXSCBwrRdKMem;
; 254  : 
; 255  :     // Set the default return value 
; 256  :     BOOL retval = FALSE;

  00b50	e3a03000	 mov         r3, #0
  00b54	e50b3018	 str         r3, [r11, #-0x18]

; 257  : 
; 258  :     //Check the size of the input buffer
; 259  :     //
; 260  :     if ( (lpInBuf == NULL) || (sizeof(XSCBwrRdKMem) > nInBufSize) )  {

  00b58	e59b3004	 ldr         r3, [r11, #4]
  00b5c	e3530000	 cmp         r3, #0
  00b60	0a000002	 beq         |$LN6@ReadKMemIo|
  00b64	e59b3008	 ldr         r3, [r11, #8]
  00b68	e3530008	 cmp         r3, #8
  00b6c	2a000006	 bcs         |$LN7@ReadKMemIo|
  00b70		 |$LN6@ReadKMemIo|

; 261  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00b70	e3a0007a	 mov         r0, #0x7A
  00b74	e59f312c	 ldr         r3, [pc, #0x12C]
  00b78	e1a0e00f	 mov         lr, pc
  00b7c	e12fff13	 bx          r3

; 262  :         return (retval);

  00b80	e51b3018	 ldr         r3, [r11, #-0x18]
  00b84	e50b3010	 str         r3, [r11, #-0x10]
  00b88	ea00003f	 b           |$LN8@ReadKMemIo|
  00b8c		 |$LN7@ReadKMemIo|

; 263  :     }
; 264  : 
; 265  :     if ( (lpBytesReturned == NULL) ){

  00b8c	e59b3014	 ldr         r3, [r11, #0x14]
  00b90	e3530000	 cmp         r3, #0
  00b94	1a000006	 bne         |$LN5@ReadKMemIo|

; 266  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00b98	e3a0007a	 mov         r0, #0x7A
  00b9c	e59f3104	 ldr         r3, [pc, #0x104]
  00ba0	e1a0e00f	 mov         lr, pc
  00ba4	e12fff13	 bx          r3

; 267  :         return (retval);

  00ba8	e51b3018	 ldr         r3, [r11, #-0x18]
  00bac	e50b3010	 str         r3, [r11, #-0x10]
  00bb0	ea000035	 b           |$LN8@ReadKMemIo|
  00bb4		 |$LN5@ReadKMemIo|

; 268  :     }
; 269  :     pXSCBwrRdKMem = (PXSCBwrRdKMem)lpInBuf;

  00bb4	e59b3004	 ldr         r3, [r11, #4]
  00bb8	e50b3014	 str         r3, [r11, #-0x14]

; 270  :     
; 271  :     if ( (pXSCBwrRdKMem->Address & 0x80000000) == 0 ) {

  00bbc	e51b3014	 ldr         r3, [r11, #-0x14]
  00bc0	e5933000	 ldr         r3, [r3]
  00bc4	e3130102	 tst         r3, #2, 2
  00bc8	1a000006	 bne         |$LN4@ReadKMemIo|

; 272  :       SetLastError(ERROR_INVALID_PARAMETER);  // not in kernel space

  00bcc	e3a00057	 mov         r0, #0x57
  00bd0	e59f30d0	 ldr         r3, [pc, #0xD0]
  00bd4	e1a0e00f	 mov         lr, pc
  00bd8	e12fff13	 bx          r3

; 273  :       return (retval);

  00bdc	e51b3018	 ldr         r3, [r11, #-0x18]
  00be0	e50b3010	 str         r3, [r11, #-0x10]
  00be4	ea000028	 b           |$LN8@ReadKMemIo|
  00be8		 |$LN4@ReadKMemIo|

; 274  :     }
; 275  : 
; 276  :     // check output buffer
; 277  :     //
; 278  :     if ( (lpOutBuf == NULL) || (nOutBufSize < pXSCBwrRdKMem->Size ) ) {

  00be8	e59b300c	 ldr         r3, [r11, #0xC]
  00bec	e3530000	 cmp         r3, #0
  00bf0	0a000005	 beq         |$LN2@ReadKMemIo|
  00bf4	e51b3014	 ldr         r3, [r11, #-0x14]
  00bf8	e2833004	 add         r3, r3, #4
  00bfc	e59b2010	 ldr         r2, [r11, #0x10]
  00c00	e5933000	 ldr         r3, [r3]
  00c04	e1520003	 cmp         r2, r3
  00c08	2a000006	 bcs         |$LN3@ReadKMemIo|
  00c0c		 |$LN2@ReadKMemIo|

; 279  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00c0c	e3a0007a	 mov         r0, #0x7A
  00c10	e59f3090	 ldr         r3, [pc, #0x90]
  00c14	e1a0e00f	 mov         lr, pc
  00c18	e12fff13	 bx          r3

; 280  :       return (retval);

  00c1c	e51b3018	 ldr         r3, [r11, #-0x18]
  00c20	e50b3010	 str         r3, [r11, #-0x10]
  00c24	ea000018	 b           |$LN8@ReadKMemIo|
  00c28		 |$LN3@ReadKMemIo|
  00c28		 |$LN15@ReadKMemIo|

; 281  :     }
; 282  :       
; 283  :     // copy kernel memory into output buffer
; 284  :     //
; 285  :     __try {
; 286  :       memcpy( lpOutBuf, (LPVOID)pXSCBwrRdKMem->Address, pXSCBwrRdKMem->Size );

  00c28	e51b3014	 ldr         r3, [r11, #-0x14]
  00c2c	e2833004	 add         r3, r3, #4
  00c30	e5932000	 ldr         r2, [r3]
  00c34	e51b3014	 ldr         r3, [r11, #-0x14]
  00c38	e5931000	 ldr         r1, [r3]
  00c3c	e59b000c	 ldr         r0, [r11, #0xC]
  00c40	eb000000	 bl          memcpy

; 287  :       // Set the Bytes Returned size
; 288  :       *lpBytesReturned = pXSCBwrRdKMem->Size;

  00c44	e51b3014	 ldr         r3, [r11, #-0x14]
  00c48	e2833004	 add         r3, r3, #4
  00c4c	e5932000	 ldr         r2, [r3]
  00c50	e59b3014	 ldr         r3, [r11, #0x14]
  00c54	e5832000	 str         r2, [r3]

; 289  :       
; 290  :       // Set the return value
; 291  :       retval = TRUE;

  00c58	e3a03001	 mov         r3, #1
  00c5c	e50b3018	 str         r3, [r11, #-0x18]
  00c60		 |$LN16@ReadKMemIo|

; 292  :     }

  00c60	ea000007	 b           |$LN17@ReadKMemIo|
  00c64		 |$LN12@ReadKMemIo|

; 294  :       SetLastError(ERROR_INVALID_PARAMETER);

  00c64	e3a00057	 mov         r0, #0x57
  00c68	e59f3038	 ldr         r3, [pc, #0x38]
  00c6c	e1a0e00f	 mov         lr, pc
  00c70	e12fff13	 bx          r3

; 295  :       *lpBytesReturned = 0;

  00c74	e59b2014	 ldr         r2, [r11, #0x14]
  00c78	e3a03000	 mov         r3, #0
  00c7c	e5823000	 str         r3, [r2]
  00c80	eaffffff	 b           |$LN17@ReadKMemIo|
  00c84		 |$LN17@ReadKMemIo|

; 296  :     }
; 297  : 
; 298  :     return (retval);

  00c84	e51b3018	 ldr         r3, [r11, #-0x18]
  00c88	e50b3010	 str         r3, [r11, #-0x10]
  00c8c		 |$LN8@ReadKMemIo|
  00c8c		 |$LN10@ReadKMemIo|

; 299  : }

  00c8c	e51b0010	 ldr         r0, [r11, #-0x10]
  00c90	e24bd00c	 sub         sp, r11, #0xC
  00c94	e89d6800	 ldmia       sp, {r11, sp, lr}
  00c98	e12fff1e	 bx          lr

			 ENDP  ; |ReadKMemIoctl|

  00c9c		 |$LN11@ReadKMemIo|
  00c9c		 |$LN20@ReadKMemIo|

; 293  :     __except(EXCEPTION_EXECUTE_HANDLER) {

  00c9c	e52de004	 str         lr, [sp, #-4]!
  00ca0		 |$LN14@ReadKMemIo|
  00ca0		 |$LN23@ReadKMemIo|
  00ca0	e3a00001	 mov         r0, #1
  00ca4		 |$LN13@ReadKMemIo|
  00ca4	e49df004	 ldr         pc, [sp], #4
  00ca8		 |$LN25@ReadKMemIo|
  00ca8		 |$LN26@ReadKMemIo|
  00ca8	f101ffb4	 DCD         0xf101ffb4
  00cac		 |$LN24@ReadKMemIo|
  00cac		 |$LN22@ReadKMemIo|

  00070			 AREA	 |.pdata|, PDATA
|$T16679| DCD	|$LN7@GetTraceCo|
	DCD	0x40002304
; Function compile flags: /Odtp

  00cac			 AREA	 |.text|, CODE, ARM

  00cac		 |GetTraceConfigIoctl| PROC

; 571  : {

  00cac		 |$LN7@GetTraceCo|
  00cac	e1a0c00d	 mov         r12, sp
  00cb0	e92d000f	 stmdb       sp!, {r0 - r3}
  00cb4	e92d5000	 stmdb       sp!, {r12, lr}
  00cb8	e24dd008	 sub         sp, sp, #8
  00cbc		 |$M16676|

; 572  :     BOOL retval = FALSE;

  00cbc	e3a03000	 mov         r3, #0
  00cc0	e58d3000	 str         r3, [sp]

; 573  : 
; 574  :     // check output buffer
; 575  :     //
; 576  :     if ( (lpOutBuf == NULL) || (nOutBufSize < sizeof(DWORD) ) ) {

  00cc4	e59d301c	 ldr         r3, [sp, #0x1C]
  00cc8	e3530000	 cmp         r3, #0
  00ccc	0a000002	 beq         |$LN1@GetTraceCo|
  00cd0	e59d3020	 ldr         r3, [sp, #0x20]
  00cd4	e3530004	 cmp         r3, #4
  00cd8	2a000006	 bcs         |$LN2@GetTraceCo|
  00cdc		 |$LN1@GetTraceCo|

; 577  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00cdc	e3a0007a	 mov         r0, #0x7A
  00ce0	e59f304c	 ldr         r3, [pc, #0x4C]
  00ce4	e1a0e00f	 mov         lr, pc
  00ce8	e12fff13	 bx          r3

; 578  :       return (retval);

  00cec	e59d3000	 ldr         r3, [sp]
  00cf0	e58d3004	 str         r3, [sp, #4]
  00cf4	ea000009	 b           |$LN3@GetTraceCo|
  00cf8		 |$LN2@GetTraceCo|

; 579  :     }
; 580  : 
; 581  :     *(DWORD *)lpOutBuf = (DWORD)&CFGBlock;

  00cf8	e59f2030	 ldr         r2, [pc, #0x30]
  00cfc	e59d301c	 ldr         r3, [sp, #0x1C]
  00d00	e5832000	 str         r2, [r3]

; 582  : 
; 583  :     // Set the return value
; 584  :       retval = TRUE;

  00d04	e3a03001	 mov         r3, #1
  00d08	e58d3000	 str         r3, [sp]

; 585  :   
; 586  :     *lpBytesReturned = 4;

  00d0c	e59d2024	 ldr         r2, [sp, #0x24]
  00d10	e3a03004	 mov         r3, #4
  00d14	e5823000	 str         r3, [r2]

; 587  : 
; 588  :     return (retval);

  00d18	e59d3000	 ldr         r3, [sp]
  00d1c	e58d3004	 str         r3, [sp, #4]
  00d20		 |$LN3@GetTraceCo|

; 589  : }

  00d20	e59d0004	 ldr         r0, [sp, #4]
  00d24	e28dd008	 add         sp, sp, #8
  00d28	e89d6000	 ldmia       sp, {sp, lr}
  00d2c	e12fff1e	 bx          lr
  00d30		 |$LN8@GetTraceCo|
  00d30		 |$LN9@GetTraceCo|
  00d30	00000000	 DCD         |CFGBlock|
  00d34		 |$LN10@GetTraceCo|
  00d34	f101ffb4	 DCD         0xf101ffb4
  00d38		 |$M16677|

			 ENDP  ; |GetTraceConfigIoctl|

	IMPORT	|memset|
	IMPORT	|OEMCacheRangeFlush|

  00078			 AREA	 |.pdata|, PDATA
|$T16688| DCD	|$LN12@TraceContr|
	DCD	0x40005604
; Function compile flags: /Odtp

  00d38			 AREA	 |.text|, CODE, ARM

  00d38		 |TraceControlIoctl| PROC

; 603  : {

  00d38		 |$LN12@TraceContr|
  00d38	e1a0c00d	 mov         r12, sp
  00d3c	e92d000f	 stmdb       sp!, {r0 - r3}
  00d40	e92d5000	 stmdb       sp!, {r12, lr}
  00d44	e24dd00c	 sub         sp, sp, #0xC
  00d48		 |$M16685|

; 604  :   // Set the default return value 
; 605  :   BOOL retval = FALSE;

  00d48	e3a03000	 mov         r3, #0
  00d4c	e58d3000	 str         r3, [sp]

; 606  :   
; 607  :   if ( (lpInBuf == NULL) || (nInBufSize < 9) || (lpBytesReturned == NULL) )

  00d50	e59d3018	 ldr         r3, [sp, #0x18]
  00d54	e3530000	 cmp         r3, #0
  00d58	0a000005	 beq         |$LN6@TraceContr|
  00d5c	e59d301c	 ldr         r3, [sp, #0x1C]
  00d60	e3530009	 cmp         r3, #9
  00d64	3a000002	 bcc         |$LN6@TraceContr|
  00d68	e59d3028	 ldr         r3, [sp, #0x28]
  00d6c	e3530000	 cmp         r3, #0
  00d70	1a000006	 bne         |$LN7@TraceContr|
  00d74		 |$LN6@TraceContr|

; 608  :     {
; 609  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00d74	e3a0007a	 mov         r0, #0x7A
  00d78	e59f310c	 ldr         r3, [pc, #0x10C]
  00d7c	e1a0e00f	 mov         lr, pc
  00d80	e12fff13	 bx          r3

; 610  :       return (retval);

  00d84	e59d3000	 ldr         r3, [sp]
  00d88	e58d3004	 str         r3, [sp, #4]
  00d8c	ea000037	 b           |$LN8@TraceContr|
  00d90		 |$LN7@TraceContr|

; 611  :     }
; 612  :   switch( ((char *)lpInBuf)[8] ) {

  00d90	e59d3018	 ldr         r3, [sp, #0x18]
  00d94	e2833008	 add         r3, r3, #8
  00d98	e1d330d0	 ldrsb       r3, [r3]
  00d9c	e58d3008	 str         r3, [sp, #8]
  00da0	e59d3008	 ldr         r3, [sp, #8]
  00da4	e3530000	 cmp         r3, #0
  00da8	0a000006	 beq         |$LN3@TraceContr|
  00dac	e59d3008	 ldr         r3, [sp, #8]
  00db0	e3530001	 cmp         r3, #1
  00db4	0a00000e	 beq         |$LN2@TraceContr|
  00db8	e59d3008	 ldr         r3, [sp, #8]
  00dbc	e3530002	 cmp         r3, #2
  00dc0	0a000015	 beq         |$LN1@TraceContr|
  00dc4	ea000022	 b           |$LN4@TraceContr|
  00dc8		 |$LN3@TraceContr|

; 613  :   case 0: // diable trace
; 614  :     CFGBlock.TraceMode = TRACE_OFF;

  00dc8	e59f20b0	 ldr         r2, [pc, #0xB0]
  00dcc	e3a03002	 mov         r3, #2
  00dd0	e5823010	 str         r3, [r2, #0x10]

; 615  :     NKSetDataAbortHandler( pfOSDataAbortHandler );

  00dd4	e59f30ac	 ldr         r3, [pc, #0xAC]
  00dd8	e5930000	 ldr         r0, [r3]
  00ddc	eb000000	 bl          NKSetDataAbortHandler

; 616  : 
; 617  :     // Need to flush caches to have handler written to exception area
; 618  :     OEMCacheRangeFlush(0, 0, CACHE_SYNC_ALL); 

  00de0	e3a0207f	 mov         r2, #0x7F
  00de4	e3a01000	 mov         r1, #0
  00de8	e3a00000	 mov         r0, #0
  00dec	eb000000	 bl          OEMCacheRangeFlush

; 619  : 
; 620  :     break;

  00df0	ea000017	 b           |$LN4@TraceContr|
  00df4		 |$LN2@TraceContr|

; 621  : 
; 622  :   case 1: // enable trace
; 623  :     NKSetDataAbortHandler( XSCBwrTraceDataAbortHandler );

  00df4	e59f0088	 ldr         r0, [pc, #0x88]
  00df8	eb000000	 bl          NKSetDataAbortHandler

; 624  : 
; 625  :     // Need to flush caches to have handler written to exception area
; 626  :     OEMCacheRangeFlush(0, 0, CACHE_SYNC_ALL); 

  00dfc	e3a0207f	 mov         r2, #0x7F
  00e00	e3a01000	 mov         r1, #0
  00e04	e3a00000	 mov         r0, #0
  00e08	eb000000	 bl          OEMCacheRangeFlush

; 627  : 
; 628  :     CFGBlock.TraceMode = WRAP_AROUND;

  00e0c	e59f206c	 ldr         r2, [pc, #0x6C]
  00e10	e3a03001	 mov         r3, #1
  00e14	e5823010	 str         r3, [r2, #0x10]

; 629  : 
; 630  :     break;

  00e18	ea00000d	 b           |$LN4@TraceContr|
  00e1c		 |$LN1@TraceContr|

; 631  :   case 2: // clear trace;
; 632  :     memset( (LPVOID)CFGBlock.pTraceBuffer, 0, CFGBlock.TraceBufferSize);

  00e1c	e59f305c	 ldr         r3, [pc, #0x5C]
  00e20	e593200c	 ldr         r2, [r3, #0xC]
  00e24	e3a01000	 mov         r1, #0
  00e28	e59f3050	 ldr         r3, [pc, #0x50]
  00e2c	e5930000	 ldr         r0, [r3]
  00e30	eb000000	 bl          memset

; 633  :     CFGBlock.StartAddress = CFGBlock.pTraceBuffer;

  00e34	e59f3044	 ldr         r3, [pc, #0x44]
  00e38	e5932000	 ldr         r2, [r3]
  00e3c	e59f303c	 ldr         r3, [pc, #0x3C]
  00e40	e5832004	 str         r2, [r3, #4]

; 634  :     CFGBlock.EndAddress   = CFGBlock.pTraceBuffer;

  00e44	e59f3034	 ldr         r3, [pc, #0x34]
  00e48	e5932000	 ldr         r2, [r3]
  00e4c	e59f302c	 ldr         r3, [pc, #0x2C]
  00e50	e5832008	 str         r2, [r3, #8]
  00e54		 |$LN4@TraceContr|

; 635  :     break;
; 636  :   }
; 637  : 
; 638  :   retval = TRUE;

  00e54	e3a03001	 mov         r3, #1
  00e58	e58d3000	 str         r3, [sp]

; 639  :   *lpBytesReturned = 0;

  00e5c	e59d2028	 ldr         r2, [sp, #0x28]
  00e60	e3a03000	 mov         r3, #0
  00e64	e5823000	 str         r3, [r2]

; 640  : 
; 641  :   return retval;

  00e68	e59d3000	 ldr         r3, [sp]
  00e6c	e58d3004	 str         r3, [sp, #4]
  00e70		 |$LN8@TraceContr|

; 642  : }

  00e70	e59d0004	 ldr         r0, [sp, #4]
  00e74	e28dd00c	 add         sp, sp, #0xC
  00e78	e89d6000	 ldmia       sp, {sp, lr}
  00e7c	e12fff1e	 bx          lr
  00e80		 |$LN13@TraceContr|
  00e80		 |$LN14@TraceContr|
  00e80	00000000	 DCD         |CFGBlock|
  00e84		 |$LN15@TraceContr|
  00e84	00000000	 DCD         |XSCBwrTraceDataAbortHandler|
  00e88		 |$LN16@TraceContr|
  00e88	00000000	 DCD         |pfOSDataAbortHandler|
  00e8c		 |$LN17@TraceContr|
  00e8c	f101ffb4	 DCD         0xf101ffb4
  00e90		 |$M16686|

			 ENDP  ; |TraceControlIoctl|


  00080			 AREA	 |.pdata|, PDATA
|$T16699| DCD	|$LN8@ReadTraceI|
	DCD	0x40002b04
; Function compile flags: /Odtp

  00e90			 AREA	 |.text|, CODE, ARM

  00e90		 |ReadTraceIoctl| PROC

; 656  : {

  00e90		 |$LN8@ReadTraceI|
  00e90	e1a0c00d	 mov         r12, sp
  00e94	e92d000f	 stmdb       sp!, {r0 - r3}
  00e98	e92d5000	 stmdb       sp!, {r12, lr}
  00e9c	e24dd008	 sub         sp, sp, #8
  00ea0		 |$M16696|

; 657  :     // Set the default return value 
; 658  :     BOOL retval = FALSE;

  00ea0	e3a03000	 mov         r3, #0
  00ea4	e58d3000	 str         r3, [sp]

; 659  :     if ( (lpBytesReturned == NULL) )

  00ea8	e59d3024	 ldr         r3, [sp, #0x24]
  00eac	e3530000	 cmp         r3, #0
  00eb0	1a000006	 bne         |$LN3@ReadTraceI|

; 660  :     {
; 661  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00eb4	e3a0007a	 mov         r0, #0x7A
  00eb8	e59f3078	 ldr         r3, [pc, #0x78]
  00ebc	e1a0e00f	 mov         lr, pc
  00ec0	e12fff13	 bx          r3

; 662  :         return (retval);

  00ec4	e59d3000	 ldr         r3, [sp]
  00ec8	e58d3004	 str         r3, [sp, #4]
  00ecc	ea000015	 b           |$LN4@ReadTraceI|
  00ed0		 |$LN3@ReadTraceI|

; 663  :     }
; 664  :  
; 665  :     // check output buffer
; 666  :     //
; 667  :     if ( (lpOutBuf == NULL) || (nOutBufSize < 264 ) )

  00ed0	e59d301c	 ldr         r3, [sp, #0x1C]
  00ed4	e3530000	 cmp         r3, #0
  00ed8	0a000002	 beq         |$LN1@ReadTraceI|
  00edc	e59d3020	 ldr         r3, [sp, #0x20]
  00ee0	e3530f42	 cmp         r3, #0x42, 30
  00ee4	2a000006	 bcs         |$LN2@ReadTraceI|
  00ee8		 |$LN1@ReadTraceI|

; 668  :     {
; 669  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00ee8	e3a0007a	 mov         r0, #0x7A
  00eec	e59f3044	 ldr         r3, [pc, #0x44]
  00ef0	e1a0e00f	 mov         lr, pc
  00ef4	e12fff13	 bx          r3

; 670  :       return (retval);

  00ef8	e59d3000	 ldr         r3, [sp]
  00efc	e58d3004	 str         r3, [sp, #4]
  00f00	ea000008	 b           |$LN4@ReadTraceI|
  00f04		 |$LN2@ReadTraceI|

; 671  :     }
; 672  :       
; 673  :     // copy trace buffer into user buffer
; 674  :     //
; 675  :     XSCBwrSaveTrace(lpOutBuf);

  00f04	e59d001c	 ldr         r0, [sp, #0x1C]
  00f08	eb000000	 bl          XSCBwrSaveTrace

; 676  :     *lpBytesReturned = 264;

  00f0c	e59d2024	 ldr         r2, [sp, #0x24]
  00f10	e3a03f42	 mov         r3, #0x42, 30
  00f14	e5823000	 str         r3, [r2]

; 677  :     retval = TRUE;

  00f18	e3a03001	 mov         r3, #1
  00f1c	e58d3000	 str         r3, [sp]

; 678  : 
; 679  :     return (retval);

  00f20	e59d3000	 ldr         r3, [sp]
  00f24	e58d3004	 str         r3, [sp, #4]
  00f28		 |$LN4@ReadTraceI|

; 680  : }

  00f28	e59d0004	 ldr         r0, [sp, #4]
  00f2c	e28dd008	 add         sp, sp, #8
  00f30	e89d6000	 ldmia       sp, {sp, lr}
  00f34	e12fff1e	 bx          lr
  00f38		 |$LN9@ReadTraceI|
  00f38		 |$LN10@ReadTraceI|
  00f38	f101ffb4	 DCD         0xf101ffb4
  00f3c		 |$M16697|

			 ENDP  ; |ReadTraceIoctl|

	END
