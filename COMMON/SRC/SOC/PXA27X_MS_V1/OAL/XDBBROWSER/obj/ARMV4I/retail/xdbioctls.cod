; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\OAL\XDBBROWSER\xdbioctls.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XSCBwrThreadID| [ DATA ]
	EXPORT	|XSCBwrProcessID| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|CurrentTaskID| % 0x4
|CFGBlockvalid| % 0x4

  00000			 AREA	 |.data|, DATA
|XSCBwrThreadID| DCD 0xffffffff
|XSCBwrProcessID| DCD 0xffffffff
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\oal\xdbbrowser\xdbioctls.c

  00000			 AREA	 |.pdata|, PDATA
|$T16615| DCD	|$LN7@GetVersion|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetVersionIoctl| PROC

; 56   : {

  00000		 |$LN7@GetVersion|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M16612|
  00004	e3530000	 cmp         r3, #0

; 57   :     // output buffer format
; 58   :     PXSCBwrVersion pXSCBwrVersion;
; 59   : 
; 60   :     // Return Value
; 61   :     BOOL retval = FALSE;
; 62   : 
; 63   :     if ( (lpOutBuf == NULL ) ||
; 64   :          (sizeof(XSCBwrVersion) > nOutBufSize) || 
; 65   :          (lpBytesReturned == NULL) 
; 66   :        )

  00008	0a00000e	 beq         |$LN1@GetVersion|
  0000c	e59d2004	 ldr         r2, [sp, #4]
  00010	e3520008	 cmp         r2, #8
  00014	3a00000b	 bcc         |$LN1@GetVersion|
  00018	e59d2008	 ldr         r2, [sp, #8]
  0001c	e3520000	 cmp         r2, #0
  00020	0a000008	 beq         |$LN1@GetVersion|

; 70   :     }
; 71   : 
; 72   :     pXSCBwrVersion = (PXSCBwrVersion)lpOutBuf;
; 73   :     
; 74   :     pXSCBwrVersion->Major = XSCBWR_V_MAJOR;

  00024	e3a01001	 mov         r1, #1

; 75   :     pXSCBwrVersion->Minor = XSCBWR_V_MINOR;

  00028	e3a00002	 mov         r0, #2
  0002c	e5831000	 str         r1, [r3]
  00030	e5830004	 str         r0, [r3, #4]

; 76   : 
; 77   :     // Set the Bytes Returned size
; 78   :     *lpBytesReturned = sizeof(XSCBwrVersion);

  00034	e3a03008	 mov         r3, #8
  00038	e5823000	 str         r3, [r2]

; 79   : 
; 80   :     // Set the return value
; 81   :     retval = TRUE;
; 82   : 
; 83   :     return (retval);

  0003c	e3a00001	 mov         r0, #1

; 84   : }

  00040	e49de004	 ldr         lr, [sp], #4
  00044	e12fff1e	 bx          lr
  00048		 |$LN1@GetVersion|

; 67   :     {
; 68   :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00048	e59f3014	 ldr         r3, [pc, #0x14]
  0004c	e3a0007a	 mov         r0, #0x7A
  00050	e1a0e00f	 mov         lr, pc
  00054	e12fff13	 bx          r3

; 69   :         return (retval);

  00058	e3a00000	 mov         r0, #0

; 84   : }

  0005c	e49de004	 ldr         lr, [sp], #4
  00060	e12fff1e	 bx          lr
  00064		 |$LN8@GetVersion|
  00064		 |$LN9@GetVersion|
  00064	f101ffb4	 DCD         0xf101ffb4
  00068		 |$M16613|

			 ENDP  ; |GetVersionIoctl|

	IMPORT	|XSCBwrExecuteCoProcCode|

  00000			 AREA	 |.pdata|, PDATA
|$T16630| DCD	|$LN10@ReadCoProc|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadCoProcessorIoctl| PROC

; 99   : {

  00000		 |$LN10@ReadCoProc|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M16627|
  00004	e3510000	 cmp         r1, #0

; 100  :     // CoProc Read Input Buffer Ptr
; 101  :     PXSCBwrRdRegIn pXSCBwrRdRegInBuf;
; 102  : 
; 103  :     // CoProc Read Output Buffer Ptr
; 104  :     PXSCBwrRdRegOut pXSCBwrRdRegOutBuf;
; 105  : 
; 106  :     // Return Value
; 107  :     BOOL retval = FALSE;
; 108  : 
; 109  :     //Check the size of the input & Output buffers      
; 110  :     if ((lpInBuf == NULL) || (lpOutBuf == NULL))

  00008	0a000015	 beq         |$LN3@ReadCoProc|
  0000c	e3530000	 cmp         r3, #0
  00010	0a000013	 beq         |$LN3@ReadCoProc|

; 114  :     }
; 115  :     if ( (sizeof(XSCBwrRdRegOut) > nOutBufSize) || (lpBytesReturned == NULL) )

  00014	e59d2008	 ldr         r2, [sp, #8]
  00018	e3520008	 cmp         r2, #8
  0001c	3a00000b	 bcc         |$LN1@ReadCoProc|
  00020	e59d400c	 ldr         r4, [sp, #0xC]
  00024	e3540000	 cmp         r4, #0
  00028	0a000008	 beq         |$LN1@ReadCoProc|

; 119  :     }
; 120  : 
; 121  :     pXSCBwrRdRegInBuf = (PXSCBwrRdRegIn)lpInBuf;
; 122  :     pXSCBwrRdRegOutBuf = (PXSCBwrRdRegOut)lpOutBuf;
; 123  : 
; 124  :     // execute the 'read'
; 125  :     XSCBwrExecuteCoProcCode((pXSCBwrRdRegInBuf->OpCode), 
; 126  :                             (&pXSCBwrRdRegOutBuf->Reg1), 
; 127  :                             (&pXSCBwrRdRegOutBuf->Reg2));

  0002c	e5910000	 ldr         r0, [r1]
  00030	e2832004	 add         r2, r3, #4
  00034	e1a01003	 mov         r1, r3
  00038	eb000000	 bl          XSCBwrExecuteCoProcCode

; 128  : 
; 129  :     // Set the Bytes Returned size
; 130  :     *lpBytesReturned = sizeof(XSCBwrRdRegOut);

  0003c	e3a03008	 mov         r3, #8
  00040	e5843000	 str         r3, [r4]

; 131  : 
; 132  :     // Set the return value
; 133  :     retval = TRUE;
; 134  : 
; 135  :     return (retval);

  00044	e3a00001	 mov         r0, #1

; 136  : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN1@ReadCoProc|

; 116  :     {
; 117  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00050	e59f3028	 ldr         r3, [pc, #0x28]
  00054	e3a0007a	 mov         r0, #0x7A
  00058	e1a0e00f	 mov         lr, pc
  0005c	e12fff13	 bx          r3

; 118  :         return (retval);

  00060	ea000003	 b           |$LN7@ReadCoProc|
  00064		 |$LN3@ReadCoProc|

; 111  :     {
; 112  :         SetLastError(ERROR_INVALID_PARAMETER);

  00064	e59f3014	 ldr         r3, [pc, #0x14]
  00068	e3a00057	 mov         r0, #0x57
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3
  00074		 |$LN7@ReadCoProc|

; 113  :         return (retval);

  00074	e3a00000	 mov         r0, #0

; 136  : }

  00078	e8bd4010	 ldmia       sp!, {r4, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN11@ReadCoProc|
  00080		 |$LN12@ReadCoProc|
  00080	f101ffb4	 DCD         0xf101ffb4
  00084		 |$M16628|

			 ENDP  ; |ReadCoProcessorIoctl|


  00000			 AREA	 |.pdata|, PDATA
|$T16643| DCD	|$LN7@WriteCoPro|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WriteCoProcessorIoctl| PROC

; 152  : {

  00000		 |$LN7@WriteCoPro|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M16640|
  00004	e3510000	 cmp         r1, #0

; 153  :     // CoProc Write Input Buffer Ptr
; 154  :     PXSCBwrWrteRegIn pXSCBwrWrteRegInBuf;
; 155  : 
; 156  :     // Set the default return value
; 157  :     BOOL retval = FALSE;
; 158  : 
; 159  :     //Check the size of the input & Output buffers (no output buffer for write)
; 160  :     //
; 161  :     if ((lpInBuf == NULL) || (nInBufSize < (sizeof(XSCBwrWrteRegIn)) ) )

  00008	0a00000b	 beq         |$LN1@WriteCoPro|
  0000c	e352000c	 cmp         r2, #0xC
  00010	3a000009	 bcc         |$LN1@WriteCoPro|

; 165  :     }
; 166  : 
; 167  :     //Now assign the input buffer
; 168  :     pXSCBwrWrteRegInBuf = (PXSCBwrWrteRegIn)lpInBuf;
; 169  : 
; 170  :     // execute the 'write'
; 171  :     //
; 172  :     XSCBwrExecuteCoProcCode((pXSCBwrWrteRegInBuf->OpCode), 
; 173  :                             (&pXSCBwrWrteRegInBuf->Reg1), 
; 174  :                             (&pXSCBwrWrteRegInBuf->Reg2));

  00014	e5910000	 ldr         r0, [r1]
  00018	e2812008	 add         r2, r1, #8
  0001c	e2811004	 add         r1, r1, #4
  00020	eb000000	 bl          XSCBwrExecuteCoProcCode

; 175  : 
; 176  :     // Set the Bytes Returned size
; 177  :     *lpBytesReturned = 0;

  00024	e59d3008	 ldr         r3, [sp, #8]
  00028	e3a02000	 mov         r2, #0

; 178  : 
; 179  :     // Set the return value
; 180  :     retval = TRUE;
; 181  : 
; 182  :     return (retval);

  0002c	e3a00001	 mov         r0, #1
  00030	e5832000	 str         r2, [r3]

; 183  : 
; 184  : }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN1@WriteCoPro|

; 162  :     {
; 163  :         SetLastError(ERROR_INVALID_PARAMETER);

  0003c	e59f3014	 ldr         r3, [pc, #0x14]
  00040	e3a00057	 mov         r0, #0x57
  00044	e1a0e00f	 mov         lr, pc
  00048	e12fff13	 bx          r3

; 164  :         return (retval);

  0004c	e3a00000	 mov         r0, #0

; 183  : 
; 184  : }

  00050	e49de004	 ldr         lr, [sp], #4
  00054	e12fff1e	 bx          lr
  00058		 |$LN8@WriteCoPro|
  00058		 |$LN9@WriteCoPro|
  00058	f101ffb4	 DCD         0xf101ffb4
  0005c		 |$M16641|

			 ENDP  ; |WriteCoProcessorIoctl|


  00000			 AREA	 |.pdata|, PDATA
|$T16658| DCD	|$LN11@SetTaskIoc|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetTaskIoctl| PROC

; 198  : {

  00000		 |$LN11@SetTaskIoc|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M16655|
  00004	e3510000	 cmp         r1, #0

; 199  :     // Set Task Input Buffer Ptr
; 200  :     PXSCBwrSetTaskIn pXSCBwrSetTaskInBuf;
; 201  : 
; 202  :     // Set the default return value 
; 203  :     BOOL retval = FALSE;
; 204  : 
; 205  :     //Check the size of the input buffer
; 206  : 
; 207  :     if ((lpInBuf == NULL) || (sizeof(XSCBwrSetTaskIn) > nInBufSize))

  00008	0a000018	 beq         |$LN4@SetTaskIoc|
  0000c	e3520008	 cmp         r2, #8
  00010	3a000016	 bcc         |$LN4@SetTaskIoc|

; 211  :     }
; 212  :     if ( (lpBytesReturned == NULL) )

  00014	e59d0008	 ldr         r0, [sp, #8]
  00018	e3500000	 cmp         r0, #0
  0001c	1a000004	 bne         |$LN3@SetTaskIoc|

; 213  :     {
; 214  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00020	e59f3064	 ldr         r3, [pc, #0x64]
  00024	e3a0007a	 mov         r0, #0x7A
  00028	e1a0e00f	 mov         lr, pc
  0002c	e12fff13	 bx          r3

; 215  :         return (retval);

  00030	ea000012	 b           |$LN8@SetTaskIoc|
  00034		 |$LN3@SetTaskIoc|

; 216  :     }
; 217  : 
; 218  :     pXSCBwrSetTaskInBuf = (PXSCBwrSetTaskIn)lpInBuf;
; 219  : 
; 220  :     if ( pXSCBwrSetTaskInBuf->ThreadID ) {

  00034	e5913004	 ldr         r3, [r1, #4]
  00038	e3530000	 cmp         r3, #0

; 221  :       XSCBwrThreadID = pXSCBwrSetTaskInBuf->ThreadID;

  0003c	159f204c	 ldrne       r2, [pc, #0x4C]
  00040	15823000	 strne       r3, [r2]

; 222  :       XSCBwrProcessID = pXSCBwrSetTaskInBuf->ProcessID;

  00044	15913000	 ldrne       r3, [r1]
  00048	15823004	 strne       r3, [r2, #4]

; 223  :     } else {
; 224  :       // thread set to 0: Browser is detaching from thread
; 225  :       //
; 226  :       XSCBwrThreadID = XSCBwrProcessID = (DWORD)INVALID_HANDLE_VALUE;

  0004c	059f303c	 ldreq       r3, [pc, #0x3C]
  00050	03e02000	 mvneq       r2, #0
  00054	05832004	 streq       r2, [r3, #4]
  00058	05832000	 streq       r2, [r3]

; 227  :     }
; 228  : 
; 229  :     // Set the Bytes Returned size
; 230  :     *lpBytesReturned = 0;

  0005c	e3a03000	 mov         r3, #0
  00060	e5803000	 str         r3, [r0]

; 231  : 
; 232  :     // Set the return value
; 233  :     retval = TRUE;
; 234  : 
; 235  :     return (retval);

  00064	e3a00001	 mov         r0, #1

; 236  : }

  00068	e49de004	 ldr         lr, [sp], #4
  0006c	e12fff1e	 bx          lr
  00070		 |$LN4@SetTaskIoc|

; 208  :     {
; 209  :         SetLastError(ERROR_INVALID_PARAMETER);

  00070	e59f3014	 ldr         r3, [pc, #0x14]
  00074	e3a00057	 mov         r0, #0x57
  00078	e1a0e00f	 mov         lr, pc
  0007c	e12fff13	 bx          r3
  00080		 |$LN8@SetTaskIoc|

; 210  :         return (retval);

  00080	e3a00000	 mov         r0, #0

; 236  : }

  00084	e49de004	 ldr         lr, [sp], #4
  00088	e12fff1e	 bx          lr
  0008c		 |$LN12@SetTaskIoc|
  0008c		 |$LN13@SetTaskIoc|
  0008c	f101ffb4	 DCD         0xf101ffb4
  00090		 |$LN14@SetTaskIoc|
  00090	00000000	 DCD         |XSCBwrThreadID|
  00094		 |$M16656|

			 ENDP  ; |SetTaskIoctl|

	IMPORT	|__C_specific_handler|
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T16690| DCD	|$LN24@ReadKMemIo|
	DCD	0xc0003f04

  00000			 AREA	 |.pdata|, PDATA
|$T16692| DCD	|$LN11@ReadKMemIo|
	DCD	0x40000401

  00000			 AREA	 |.xdata|, DATA
|$T16688| DCD	0x1
	DCD	|$LN15@ReadKMemIo|
	DCD	|$LN16@ReadKMemIo|
	DCD	|$LN11@ReadKMemIo|
	DCD	|$LN12@ReadKMemIo|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T16688|

  00008		 |ReadKMemIoctl| PROC

; 251  : {

  00008		 |$LN24@ReadKMemIo|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5830	 stmdb       sp!, {r4, r5, r11, r12, lr}
  00010	e28db014	 add         r11, sp, #0x14
  00014	e24dd008	 sub         sp, sp, #8
  00018		 |$LN22@ReadKMemIo|
  00018	e1a00003	 mov         r0, r3
  0001c	e1b04001	 movs        r4, r1

; 252  :     // Set kmem read Input Buffer Ptr
; 253  :     PXSCBwrRdKMem pXSCBwrRdKMem;
; 254  : 
; 255  :     // Set the default return value 
; 256  :     BOOL retval = FALSE;

  00020	e3a03000	 mov         r3, #0
  00024	e50b301c	 str         r3, [r11, #-0x1C]

; 257  : 
; 258  :     //Check the size of the input buffer
; 259  :     //
; 260  :     if ( (lpInBuf == NULL) || (sizeof(XSCBwrRdKMem) > nInBufSize) )  {

  00028	0a00002d	 beq         |$LN6@ReadKMemIo|
  0002c	e3520008	 cmp         r2, #8
  00030	3a00002b	 bcc         |$LN6@ReadKMemIo|

; 263  :     }
; 264  : 
; 265  :     if ( (lpBytesReturned == NULL) ){

  00034	e59b5004	 ldr         r5, [r11, #4]
  00038	e3550000	 cmp         r5, #0
  0003c	1a000004	 bne         |$LN5@ReadKMemIo|

; 266  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00040	e59f30c8	 ldr         r3, [pc, #0xC8]
  00044	e3a0007a	 mov         r0, #0x7A
  00048	e1a0e00f	 mov         lr, pc
  0004c	e12fff13	 bx          r3

; 267  :         return (retval);

  00050	ea000027	 b           |$LN21@ReadKMemIo|
  00054		 |$LN5@ReadKMemIo|

; 268  :     }
; 269  :     pXSCBwrRdKMem = (PXSCBwrRdKMem)lpInBuf;
; 270  :     
; 271  :     if ( (pXSCBwrRdKMem->Address & 0x80000000) == 0 ) {

  00054	e5941000	 ldr         r1, [r4]
  00058	e3110102	 tst         r1, #2, 2
  0005c	1a000004	 bne         |$LN4@ReadKMemIo|

; 272  :       SetLastError(ERROR_INVALID_PARAMETER);  // not in kernel space

  00060	e59f30a8	 ldr         r3, [pc, #0xA8]
  00064	e3a00057	 mov         r0, #0x57
  00068	e1a0e00f	 mov         lr, pc
  0006c	e12fff13	 bx          r3

; 273  :       return (retval);

  00070	ea00001f	 b           |$LN21@ReadKMemIo|
  00074		 |$LN4@ReadKMemIo|

; 274  :     }
; 275  : 
; 276  :     // check output buffer
; 277  :     //
; 278  :     if ( (lpOutBuf == NULL) || (nOutBufSize < pXSCBwrRdKMem->Size ) ) {

  00074	e3500000	 cmp         r0, #0
  00078	0a000014	 beq         |$LN2@ReadKMemIo|
  0007c	e5942004	 ldr         r2, [r4, #4]
  00080	e59b3000	 ldr         r3, [r11]
  00084	e1530002	 cmp         r3, r2
  00088	3a000010	 bcc         |$LN2@ReadKMemIo|
  0008c		 |$LN15@ReadKMemIo|

; 281  :     }
; 282  :       
; 283  :     // copy kernel memory into output buffer
; 284  :     //
; 285  :     __try {
; 286  :       memcpy( lpOutBuf, (LPVOID)pXSCBwrRdKMem->Address, pXSCBwrRdKMem->Size );

  0008c	eb000000	 bl          memcpy

; 287  :       // Set the Bytes Returned size
; 288  :       *lpBytesReturned = pXSCBwrRdKMem->Size;

  00090	e5943004	 ldr         r3, [r4, #4]
  00094	e5853000	 str         r3, [r5]

; 289  :       
; 290  :       // Set the return value
; 291  :       retval = TRUE;

  00098	e3a00001	 mov         r0, #1
  0009c	e50b001c	 str         r0, [r11, #-0x1C]
  000a0		 |$LN16@ReadKMemIo|

; 292  :     }

  000a0	ea000014	 b           |$LN8@ReadKMemIo|
  000a4		 |$LN12@ReadKMemIo|

; 294  :       SetLastError(ERROR_INVALID_PARAMETER);

  000a4	e59f3064	 ldr         r3, [pc, #0x64]
  000a8	e3a00057	 mov         r0, #0x57
  000ac	e1a0e00f	 mov         lr, pc
  000b0	e12fff13	 bx          r3

; 295  :       *lpBytesReturned = 0;

  000b4	e59b3004	 ldr         r3, [r11, #4]
  000b8	e3a02000	 mov         r2, #0
  000bc	e5832000	 str         r2, [r3]
  000c0	e51b001c	 ldr         r0, [r11, #-0x1C]
  000c4	ea00000b	 b           |$LN8@ReadKMemIo|
  000c8		 |$LN20@ReadKMemIo|

; 262  :         return (retval);

  000c8	e51b0018	 ldr         r0, [r11, #-0x18]
  000cc	ea000009	 b           |$LN8@ReadKMemIo|
  000d0		 |$LN2@ReadKMemIo|

; 279  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  000d0	e59f3038	 ldr         r3, [pc, #0x38]
  000d4	e3a0007a	 mov         r0, #0x7A
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3

; 280  :       return (retval);

  000e0	ea000003	 b           |$LN21@ReadKMemIo|
  000e4		 |$LN6@ReadKMemIo|

; 261  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  000e4	e59f3024	 ldr         r3, [pc, #0x24]
  000e8	e3a0007a	 mov         r0, #0x7A
  000ec	e1a0e00f	 mov         lr, pc
  000f0	e12fff13	 bx          r3
  000f4		 |$LN21@ReadKMemIo|

; 262  :         return (retval);

  000f4	e3a00000	 mov         r0, #0
  000f8		 |$LN8@ReadKMemIo|

; 296  :     }
; 297  : 
; 298  :     return (retval);
; 299  : }

  000f8	e24bd014	 sub         sp, r11, #0x14
  000fc	e89d6830	 ldmia       sp, {r4, r5, r11, sp, lr}
  00100	e12fff1e	 bx          lr

			 ENDP  ; |ReadKMemIoctl|

  00104		 |$LN11@ReadKMemIo|
  00104		 |$LN23@ReadKMemIo|

; 293  :     __except(EXCEPTION_EXECUTE_HANDLER) {

  00104	e52de004	 str         lr, [sp, #-4]!
  00108		 |$LN14@ReadKMemIo|
  00108		 |$LN26@ReadKMemIo|
  00108	e3a00001	 mov         r0, #1
  0010c		 |$LN13@ReadKMemIo|
  0010c	e49df004	 ldr         pc, [sp], #4
  00110		 |$LN28@ReadKMemIo|
  00110		 |$LN29@ReadKMemIo|
  00110	f101ffb4	 DCD         0xf101ffb4
  00114		 |$LN27@ReadKMemIo|
  00114		 |$LN25@ReadKMemIo|
	IMPORT	|XSCBwrReadTraceByte|

  00000			 AREA	 |.pdata|, PDATA
|$T16707| DCD	|$LN10@trace_clea|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |trace_clear_current| PROC

; 342  : { 

  00000		 |$LN10@trace_clea|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M16704|

; 343  :   //clear the Target trace buffer by reading 
; 344  :   unsigned char dummy;
; 345  :   int i = 0;    
; 346  :   for(i=0;i<256;i++){

  00004	e3a04c01	 mov         r4, #1, 24
  00008		 |$LL3@trace_clea|

; 347  :     dummy = (unsigned char)XSCBwrReadTraceByte();

  00008	eb000000	 bl          XSCBwrReadTraceByte
  0000c	e2544001	 subs        r4, r4, #1
  00010	1afffffc	 bne         |$LL3@trace_clea|

; 348  :   }
; 349  : }

  00014	e8bd4010	 ldmia       sp!, {r4, lr}
  00018	e12fff1e	 bx          lr
  0001c		 |$M16705|

			 ENDP  ; |trace_clear_current|

	EXPORT	|XSCBwrInitExecutionTrace|
	EXPORT	|??_C@_1GM@PINJOMEC@?$AAX?$AAS?$AAC?$AAD?$AAB?$AAG?$AA?3?$AAT?$AAr?$AAa?$AAc?$AAe?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?3?$AA?5?$AAC?$AAF?$AAG?$AA?3?$AA?$CF?$AA0@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|XSCBwrTraceSetFillOnce|
	IMPORT	|NKSetDataAbortHandler|
	IMPORT	|XSCBwrTraceDataAbortHandler|

  00008			 AREA	 |.bss|, NOINIT
|CFGBlock| %	0x20
|pfOSDataAbortHandler| % 0x4
|CFGBlock| %	0x20

  00000			 AREA	 |.pdata|, PDATA
|$T16726| DCD	|$LN12@XSCBwrInit|
	DCD	0x40002401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GM@PINJOMEC@?$AAX?$AAS?$AAC?$AAD?$AAB?$AAG?$AA?3?$AAT?$AAr?$AAa?$AAc?$AAe?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?3?$AA?5?$AAC?$AAF?$AAG?$AA?3?$AA?$CF?$AA0@| DCB "X"
	DCB	0x0, "S", 0x0, "C", 0x0, "D", 0x0, "B", 0x0, "G", 0x0, ":"
	DCB	0x0, "T", 0x0, "r", 0x0, "a", 0x0, "c", 0x0, "e", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i", 0x0, "a"
	DCB	0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, "d", 0x0, ":"
	DCB	0x0, " ", 0x0, "C", 0x0, "F", 0x0, "G", 0x0, ":", 0x0, "%"
	DCB	0x0, "0", 0x0, "8", 0x0, "x", 0x0, " ", 0x0, " ", 0x0, "B"
	DCB	0x0, "u", 0x0, "f", 0x0, "f", 0x0, "e", 0x0, "r", 0x0, ":"
	DCB	0x0, " ", 0x0, "%", 0x0, "0", 0x0, "8", 0x0, "x", 0x0, ","
	DCB	0x0, " ", 0x0, "%", 0x0, "x", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XSCBwrInitExecutionTrace| PROC

; 362  : {       

  00000		 |$LN12@XSCBwrInit|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M16723|
  00004	e1a06001	 mov         r6, r1
  00008	e1a03000	 mov         r3, r0

; 363  :     CFGBlock.TraceBufferSize = Size;

  0000c	e59f4078	 ldr         r4, [pc, #0x78]

; 364  :     CFGBlock.pTraceBuffer = (int) pBuffer;      
; 365  :     CFGBlock.StartAddress = (int) CFGBlock.pTraceBuffer;
; 366  :     CFGBlock.EndAddress   = (int) CFGBlock.pTraceBuffer;
; 367  :     CFGBlock.TaskIDAddress = 0;

  00010	e3a02000	 mov         r2, #0

; 368  :     CFGBlock.TaskIDSize = 0;
; 369  :     CFGBlock.CurrentTaskIDs = 0;
; 370  : 
; 371  :     /* obtain address of the orginal OS DataAbort handler */
; 372  :     pfOSDataAbortHandler =  NKSetDataAbortHandler(XSCBwrTraceDataAbortHandler);

  00014	e59f006c	 ldr         r0, [pc, #0x6C]
  00018	e584600c	 str         r6, [r4, #0xC]
  0001c	e5843000	 str         r3, [r4]
  00020	e5843004	 str         r3, [r4, #4]
  00024	e5843008	 str         r3, [r4, #8]
  00028	e3a03000	 mov         r3, #0
  0002c	e5842014	 str         r2, [r4, #0x14]
  00030	e5843018	 str         r3, [r4, #0x18]
  00034	e3a03000	 mov         r3, #0
  00038	e584301c	 str         r3, [r4, #0x1C]
  0003c	eb000000	 bl          NKSetDataAbortHandler
  00040	e1a03000	 mov         r3, r0

; 373  :     NKSetDataAbortHandler(pfOSDataAbortHandler);

  00044	e5843020	 str         r3, [r4, #0x20]
  00048	eb000000	 bl          NKSetDataAbortHandler

; 374  : 
; 375  :     /* set multi trace mode */
; 376  :     CFGBlock.TraceMode = TRACE_OFF;

  0004c	e3a03002	 mov         r3, #2
  00050	e5843010	 str         r3, [r4, #0x10]

; 377  :     XSCBwrTraceSetFillOnce();

  00054	eb000000	 bl          XSCBwrTraceSetFillOnce
  00058	e3a05c01	 mov         r5, #1, 24

; 378  : 
; 379  :     //clear the current processor Trace 
; 380  :     trace_clear_current();      

  0005c		 |$LL5@XSCBwrInit|
  0005c	eb000000	 bl          XSCBwrReadTraceByte
  00060	e2555001	 subs        r5, r5, #1
  00064	1afffffc	 bne         |$LL5@XSCBwrInit|

; 381  : 
; 382  :     RETAILMSG(1, (TEXT("XSCDBG:Trace initialized: CFG:%08x  Buffer: %08x, %x\n"),&CFGBlock,CFGBlock.pTraceBuffer, Size ));

  00068	e5942000	 ldr         r2, [r4]
  0006c	e59f0010	 ldr         r0, [pc, #0x10]
  00070	e1a03006	 mov         r3, r6
  00074	e1a01004	 mov         r1, r4
  00078	eb000000	 bl          NKDbgPrintfW

; 383  : }

  0007c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00080	e12fff1e	 bx          lr
  00084		 |$LN13@XSCBwrInit|
  00084		 |$LN14@XSCBwrInit|
  00084	00000000	 DCD         |??_C@_1GM@PINJOMEC@?$AAX?$AAS?$AAC?$AAD?$AAB?$AAG?$AA?3?$AAT?$AAr?$AAa?$AAc?$AAe?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?3?$AA?5?$AAC?$AAF?$AAG?$AA?3?$AA?$CF?$AA0@|
  00088		 |$LN15@XSCBwrInit|
  00088	00000000	 DCD         |XSCBwrTraceDataAbortHandler|
  0008c		 |$LN16@XSCBwrInit|
  0008c	00000000	 DCD         |CFGBlock|
  00090		 |$M16724|

			 ENDP  ; |XSCBwrInitExecutionTrace|


  00000			 AREA	 |.pdata|, PDATA
|$T16746| DCD	|$LN25@trace_admi|
	DCD	0x40003801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |trace_admin_multi| PROC

; 430  : {

  00000		 |$LN25@trace_admi|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M16743|

; 431  :   if(CFGBlock.EndAddress == CFGBlock.StartAddress && 
; 432  :      CFGBlock.StartAddress == (int) CFGBlock.pTraceBuffer){//empty buffer

  00004	e59f10d0	 ldr         r1, [pc, #0xD0]
  00008	e591e008	 ldr         lr, [r1, #8]
  0000c	e5914004	 ldr         r4, [r1, #4]
  00010	e5912000	 ldr         r2, [r1]
  00014	e15e0004	 cmp         lr, r4
  00018	1a000006	 bne         |$LN17@trace_admi|
  0001c	e1540002	 cmp         r4, r2
  00020	1a000003	 bne         |$LN14@trace_admi|

; 433  :     /*return address of the current trace buffer block */ 
; 434  :     *pbuffer =(char*) CFGBlock.StartAddress;

  00024	e5804000	 str         r4, [r0]
  00028		 |$LN20@trace_admi|

; 435  :     CFGBlock.EndAddress += XDBTRACEBUFFERBLOCKSIZE;

  00028	e5913008	 ldr         r3, [r1, #8]

; 436  :     return FALSE; //not full            

  0002c	e2833f43	 add         r3, r3, #0x43, 30
  00030	ea000025	 b           |$LN18@trace_admi|
  00034		 |$LN14@trace_admi|

; 437  :   } else {
; 438  :     if(CFGBlock.EndAddress > CFGBlock.StartAddress){

  00034	e15e0004	 cmp         lr, r4
  00038		 |$LN17@trace_admi|
  00038	9a000017	 bls         |$LN12@trace_admi|

; 439  :       //at least one block free for the current Trace block
; 440  :       if(CFGBlock.EndAddress + XDBTRACEBUFFERBLOCKSIZE == 
; 441  :          CFGBlock.StartAddress + CFGBlock.TraceBufferSize) {

  0003c	e591200c	 ldr         r2, [r1, #0xC]
  00040	e28e3f43	 add         r3, lr, #0x43, 30
  00044	e0822004	 add         r2, r2, r4
  00048	e1530002	 cmp         r3, r2
  0004c	1a000009	 bne         |$LN11@trace_admi|

; 442  :         *pbuffer =(char*) CFGBlock.EndAddress;

  00050	e580e000	 str         lr, [r0]

; 443  :         CFGBlock.EndAddress += XDBTRACEBUFFERBLOCKSIZE;

  00054	e5913008	 ldr         r3, [r1, #8]
  00058	e2833f43	 add         r3, r3, #0x43, 30
  0005c		 |$LN22@trace_admi|
  0005c	e5813008	 str         r3, [r1, #8]

; 444  :         if(CFGBlock.TraceMode == FILL_ONCE){

  00060	e5913010	 ldr         r3, [r1, #0x10]
  00064	e3530000	 cmp         r3, #0
  00068	1a000018	 bne         |$LN1@trace_admi|
  0006c		 |$LN21@trace_admi|

; 445  :           return TRUE; // full after store this block

  0006c	e3a00001	 mov         r0, #1

; 486  :   }
; 487  : }

  00070	e8bd4010	 ldmia       sp!, {r4, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$LN11@trace_admi|

; 446  :         }else { //WRAP AROUND
; 447  :           return FALSE; 
; 448  :         }
; 449  :       }else{
; 450  :         if(CFGBlock.EndAddress >= 
; 451  :            CFGBlock.StartAddress + CFGBlock.TraceBufferSize) 

  00078	e15e0002	 cmp         lr, r2
  0007c	3a000004	 bcc         |$LN7@trace_admi|

; 452  :           {// WRAP AROUND occur
; 453  :             if(CFGBlock.TraceMode == FILL_ONCE){

  00080	e5913010	 ldr         r3, [r1, #0x10]
  00084	e3530000	 cmp         r3, #0

; 454  :               return TRUE;/*buffer already full stop trace*/

  00088	0afffff7	 beq         |$LN21@trace_admi|

; 455  :             }
; 456  :             *pbuffer =(char*) CFGBlock.StartAddress;

  0008c	e5804000	 str         r4, [r0]

; 457  :             CFGBlock.StartAddress += XDBTRACEBUFFERBLOCKSIZE;
; 458  :             CFGBlock.EndAddress = CFGBlock.StartAddress;
; 459  :             
; 460  :             return FALSE;

  00090	ea00000a	 b           |$LN19@trace_admi|
  00094		 |$LN7@trace_admi|

; 461  :           }else{
; 462  :             *pbuffer =(char*) CFGBlock.EndAddress;

  00094	e580e000	 str         lr, [r0]

; 463  :             CFGBlock.EndAddress += XDBTRACEBUFFERBLOCKSIZE;
; 464  :           }
; 465  :       }
; 466  :     } 
; 467  :     else

  00098	eaffffe2	 b           |$LN20@trace_admi|
  0009c		 |$LN12@trace_admi|

; 468  :       {// has wrapped around // Startaddress == EndAddress
; 469  :         if(CFGBlock.EndAddress ==
; 470  :            (int) CFGBlock.pTraceBuffer + CFGBlock.TraceBufferSize) 

  0009c	e591300c	 ldr         r3, [r1, #0xC]
  000a0	e0833002	 add         r3, r3, r2
  000a4	e15e0003	 cmp         lr, r3

; 471  :           {// WRAP AROUND occur
; 472  :             *pbuffer =(char*) CFGBlock.pTraceBuffer;                                    

  000a8	05802000	 streq       r2, [r0]

; 473  :             CFGBlock.StartAddress = (int)CFGBlock.pTraceBuffer+
; 474  :                                      XDBTRACEBUFFERBLOCKSIZE;

  000ac	05913000	 ldreq       r3, [r1]
  000b0	02833f43	 addeq       r3, r3, #0x43, 30
  000b4	05813004	 streq       r3, [r1, #4]
  000b8	0affffe7	 beq         |$LN22@trace_admi|

; 475  :             CFGBlock.EndAddress = CFGBlock.StartAddress;
; 476  :             if(CFGBlock.TraceMode == FILL_ONCE)
; 477  :               return TRUE; // full after store this block
; 478  :           }else
; 479  :             {
; 480  :               *pbuffer =(char*) CFGBlock.EndAddress;

  000bc	e580e000	 str         lr, [r0]
  000c0		 |$LN19@trace_admi|

; 481  :               CFGBlock.StartAddress += XDBTRACEBUFFERBLOCKSIZE;

  000c0	e5913004	 ldr         r3, [r1, #4]
  000c4	e2833f43	 add         r3, r3, #0x43, 30
  000c8	e5813004	 str         r3, [r1, #4]
  000cc		 |$LN18@trace_admi|

; 482  :               CFGBlock.EndAddress = CFGBlock.StartAddress;

  000cc	e5813008	 str         r3, [r1, #8]
  000d0		 |$LN1@trace_admi|

; 483  :             }
; 484  :       }
; 485  :     return FALSE;

  000d0	e3a00000	 mov         r0, #0

; 486  :   }
; 487  : }

  000d4	e8bd4010	 ldmia       sp!, {r4, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$LN26@trace_admi|
  000dc		 |$LN27@trace_admi|
  000dc	00000000	 DCD         |CFGBlock|
  000e0		 |$M16744|

			 ENDP  ; |trace_admin_multi|


  00000			 AREA	 |.pdata|, PDATA
|$T16763| DCD	|$LN16@IsUserMode|
	DCD	0x40001b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IsUserModeCapture| PROC

; 499  : {

  00000		 |$LN16@IsUserMode|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M16760|

; 500  :   register BYTE * p;
; 501  :   register DWORD Address;
; 502  : 
; 503  :   for ( p = &pTrcBuf[256]; p > pTrcBuf; p-- ) {

  00004	e2804c01	 add         r4, r0, #1, 24
  00008	ea00000f	 b           |$LN13@IsUserMode|
  0000c		 |$LL7@IsUserMode|

; 504  :     switch(*p & 0xF0) {

  0000c	e5d43000	 ldrb        r3, [r4]
  00010	e20330f0	 and         r3, r3, #0xF0
  00014	e3530090	 cmp         r3, #0x90
  00018	0a000001	 beq         |$LN2@IsUserMode|
  0001c	e35300d0	 cmp         r3, #0xD0
  00020	1a000008	 bne         |$LN6@IsUserMode|
  00024		 |$LN2@IsUserMode|

; 505  :     case 0x90:  // indirect branch
; 506  :     case 0xD0: // indirect branch with chkpt
; 507  :       p -= 4;
; 508  :       Address = (p[0] << 24) | ( p[1] << 16 ) | (p[2] << 8) | p[3];
; 509  :       if ( Address < 0x80000000) {  // user mode ?

  00024	e574e004	 ldrb        lr, [r4, #-4]!
  00028	e5d43001	 ldrb        r3, [r4, #1]
  0002c	e5d42002	 ldrb        r2, [r4, #2]
  00030	e5d41003	 ldrb        r1, [r4, #3]
  00034	e183340e	 orr         r3, r3, lr, lsl #8
  00038	e1823403	 orr         r3, r2, r3, lsl #8
  0003c	e1813403	 orr         r3, r1, r3, lsl #8
  00040	e3530102	 cmp         r3, #2, 2
  00044	3a000005	 bcc         |$LN11@IsUserMode|
  00048		 |$LN6@IsUserMode|

; 500  :   register BYTE * p;
; 501  :   register DWORD Address;
; 502  : 
; 503  :   for ( p = &pTrcBuf[256]; p > pTrcBuf; p-- ) {

  00048	e2444001	 sub         r4, r4, #1
  0004c		 |$LN13@IsUserMode|
  0004c	e1540000	 cmp         r4, r0
  00050	8affffed	 bhi         |$LL7@IsUserMode|

; 511  :       }
; 512  :       break;
; 513  :     }
; 514  :   }
; 515  :   return FALSE;

  00054	e3a00000	 mov         r0, #0

; 516  : }

  00058	e8bd4010	 ldmia       sp!, {r4, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$LN11@IsUserMode|

; 510  :         return TRUE;

  00060	e3a00001	 mov         r0, #1

; 516  : }

  00064	e8bd4010	 ldmia       sp!, {r4, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$M16761|

			 ENDP  ; |IsUserModeCapture|

	EXPORT	|XSCBwrHandleTraceBufferException|
	IMPORT	|XSCBwrSaveTrace|

  0004c			 AREA	 |.bss|, NOINIT
|?NewBuffer@?1??XSCBwrHandleTraceBufferException@@9@9| % 0x10c ; `XSCBwrHandleTraceBufferException'::`2'::NewBuffer
|?NewBuffer@?1??XSCBwrHandleTraceBufferException@@9@9| % 0x10c ; `XSCBwrHandleTraceBufferException'::`2'::NewBuffer

  00000			 AREA	 |.pdata|, PDATA
|$T16789| DCD	|$LN19@XSCBwrHand|
	DCD	0x40002402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XSCBwrHandleTraceBufferException| PROC

; 525  : {

  00000		 |$LN19@XSCBwrHand|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M16786|

; 526  :   char* pBuffer;
; 527  :   static BYTE NewBuffer[XDBTRACEBUFFERBLOCKSIZE];
; 528  : 
; 529  :   // temporary stoage for new buffer
; 530  :   //
; 531  :   XSCBwrSaveTrace(&NewBuffer[4]);

  00008	e59f407c	 ldr         r4, [pc, #0x7C]
  0000c	e2840004	 add         r0, r4, #4
  00010	eb000000	 bl          XSCBwrSaveTrace

; 532  : 
; 533  :   // check if usermode code is in this capture
; 534  :   //
; 535  :   if ( IsUserModeCapture(&NewBuffer[4]) ) {

  00014	e284ef41	 add         lr, r4, #0x41, 30
  00018	e2845004	 add         r5, r4, #4
  0001c		 |$LL10@XSCBwrHand|
  0001c	e5de3000	 ldrb        r3, [lr]
  00020	e20330f0	 and         r3, r3, #0xF0
  00024	e3530090	 cmp         r3, #0x90
  00028	0a000001	 beq         |$LN5@XSCBwrHand|
  0002c	e35300d0	 cmp         r3, #0xD0
  00030	1a000008	 bne         |$LN9@XSCBwrHand|
  00034		 |$LN5@XSCBwrHand|
  00034	e57e0004	 ldrb        r0, [lr, #-4]!
  00038	e5de3001	 ldrb        r3, [lr, #1]
  0003c	e5de2002	 ldrb        r2, [lr, #2]
  00040	e5de1003	 ldrb        r1, [lr, #3]
  00044	e1833400	 orr         r3, r3, r0, lsl #8
  00048	e1823403	 orr         r3, r2, r3, lsl #8
  0004c	e1813403	 orr         r3, r1, r3, lsl #8
  00050	e3530102	 cmp         r3, #2, 2
  00054	3a000003	 bcc         |$LN16@XSCBwrHand|
  00058		 |$LN9@XSCBwrHand|
  00058	e24ee001	 sub         lr, lr, #1
  0005c	e15e0005	 cmp         lr, r5
  00060	8affffed	 bhi         |$LL10@XSCBwrHand|
  00064	ea000005	 b           |$LN1@XSCBwrHand|
  00068		 |$LN16@XSCBwrHand|

; 536  :     trace_admin_multi(&pBuffer);

  00068	e28d0000	 add         r0, sp, #0
  0006c	eb000000	 bl          trace_admin_multi

; 537  :     memcpy( pBuffer, NewBuffer, XDBTRACEBUFFERBLOCKSIZE);

  00070	e59d0000	 ldr         r0, [sp]
  00074	e3a02f43	 mov         r2, #0x43, 30
  00078	e1a01004	 mov         r1, r4
  0007c	eb000000	 bl          memcpy
  00080		 |$LN1@XSCBwrHand|

; 538  :   }
; 539  : }

  00080	e28dd004	 add         sp, sp, #4
  00084	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN20@XSCBwrHand|
  0008c		 |$LN21@XSCBwrHand|
  0008c	00000000	 DCD         |?NewBuffer@?1??XSCBwrHandleTraceBufferException@@9@9|
  00090		 |$M16787|

			 ENDP  ; |XSCBwrHandleTraceBufferException|

	EXPORT	|XSCBwrExecutionTraceOn|
	IMPORT	|XSCBwrEnableTrace|

  00000			 AREA	 |.pdata|, PDATA
|$T16799| DCD	|$LN6@XSCBwrExec|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XSCBwrExecutionTraceOn| PROC

; 548  : {

  00000		 |$LN6@XSCBwrExec|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M16796|

; 549  :     if (CFGBlock.TraceMode==TRACE_OFF)

  00004	e59f2014	 ldr         r2, [pc, #0x14]
  00008	e5923010	 ldr         r3, [r2, #0x10]
  0000c	e3530002	 cmp         r3, #2

; 550  :         return;
; 551  : 
; 552  :     CurrentTaskID = TID;

  00010	15820024	 strne       r0, [r2, #0x24]

; 553  :     XSCBwrEnableTrace();

  00014	1b000000	 blne        XSCBwrEnableTrace

; 554  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$LN7@XSCBwrExec|
  00020		 |$LN8@XSCBwrExec|
  00020	00000000	 DCD         |CFGBlock|
  00024		 |$M16797|

			 ENDP  ; |XSCBwrExecutionTraceOn|

	EXPORT	|XSCBwrExecutionTraceOff|
	IMPORT	|XSCBwrDisableTrace|

  00000			 AREA	 |.pdata|, PDATA
|$T16808| DCD	|$LN5@XSCBwrExec@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XSCBwrExecutionTraceOff| PROC

; 563  : {

  00000		 |$LN5@XSCBwrExec@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M16805|

; 564  :     XSCBwrDisableTrace();

  00004	eb000000	 bl          XSCBwrDisableTrace

; 565  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M16806|

			 ENDP  ; |XSCBwrExecutionTraceOff|


  00000			 AREA	 |.pdata|, PDATA
|$T16818| DCD	|$LN7@GetTraceCo|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetTraceConfigIoctl| PROC

; 571  : {

  00000		 |$LN7@GetTraceCo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M16815|
  00004	e3530000	 cmp         r3, #0

; 572  :     BOOL retval = FALSE;
; 573  : 
; 574  :     // check output buffer
; 575  :     //
; 576  :     if ( (lpOutBuf == NULL) || (nOutBufSize < sizeof(DWORD) ) ) {

  00008	0a000009	 beq         |$LN1@GetTraceCo|
  0000c	e59d2004	 ldr         r2, [sp, #4]
  00010	e3520004	 cmp         r2, #4

; 579  :     }
; 580  : 
; 581  :     *(DWORD *)lpOutBuf = (DWORD)&CFGBlock;

  00014	259f2038	 ldrcs       r2, [pc, #0x38]

; 582  : 
; 583  :     // Set the return value
; 584  :       retval = TRUE;
; 585  :   
; 586  :     *lpBytesReturned = 4;

  00018	259d1008	 ldrcs       r1, [sp, #8]
  0001c	23a00004	 movcs       r0, #4
  00020	25832000	 strcs       r2, [r3]
  00024	25810000	 strcs       r0, [r1]

; 587  : 
; 588  :     return (retval);

  00028	23a00001	 movcs       r0, #1

; 589  : }

  0002c	249de004	 ldrcs       lr, [sp], #4
  00030	212fff1e	 bxcs        lr
  00034		 |$LN1@GetTraceCo|

; 577  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00034	e59f3014	 ldr         r3, [pc, #0x14]
  00038	e3a0007a	 mov         r0, #0x7A
  0003c	e1a0e00f	 mov         lr, pc
  00040	e12fff13	 bx          r3

; 578  :       return (retval);

  00044	e3a00000	 mov         r0, #0

; 589  : }

  00048	e49de004	 ldr         lr, [sp], #4
  0004c	e12fff1e	 bx          lr
  00050		 |$LN8@GetTraceCo|
  00050		 |$LN9@GetTraceCo|
  00050	f101ffb4	 DCD         0xf101ffb4
  00054		 |$LN10@GetTraceCo|
  00054	00000000	 DCD         |CFGBlock|
  00058		 |$M16816|

			 ENDP  ; |GetTraceConfigIoctl|

	IMPORT	|OEMCacheRangeFlush|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T16834| DCD	|$LN12@TraceContr|
	DCD	0x40003a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TraceControlIoctl| PROC

; 603  : {

  00000		 |$LN12@TraceContr|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M16831|
  00004	e3510000	 cmp         r1, #0

; 604  :   // Set the default return value 
; 605  :   BOOL retval = FALSE;
; 606  :   
; 607  :   if ( (lpInBuf == NULL) || (nInBufSize < 9) || (lpBytesReturned == NULL) )

  00008	0a00002c	 beq         |$LN6@TraceContr|
  0000c	e3520009	 cmp         r2, #9
  00010	3a00002a	 bcc         |$LN6@TraceContr|
  00014	e59d5010	 ldr         r5, [sp, #0x10]
  00018	e3550000	 cmp         r5, #0
  0001c	0a000027	 beq         |$LN6@TraceContr|

; 611  :     }
; 612  :   switch( ((char *)lpInBuf)[8] ) {

  00020	e1d130d8	 ldrsb       r3, [r1, #8]
  00024	e3530000	 cmp         r3, #0
  00028	0a000016	 beq         |$LN3@TraceContr|
  0002c	e3530001	 cmp         r3, #1
  00030	0a00000a	 beq         |$LN2@TraceContr|
  00034	e3530002	 cmp         r3, #2
  00038	1a00001b	 bne         |$LN4@TraceContr|

; 631  :   case 2: // clear trace;
; 632  :     memset( (LPVOID)CFGBlock.pTraceBuffer, 0, CFGBlock.TraceBufferSize);

  0003c	e59f409c	 ldr         r4, [pc, #0x9C]
  00040	e3a01000	 mov         r1, #0
  00044	e594200c	 ldr         r2, [r4, #0xC]
  00048	e5940000	 ldr         r0, [r4]
  0004c	eb000000	 bl          memset

; 633  :     CFGBlock.StartAddress = CFGBlock.pTraceBuffer;

  00050	e5943000	 ldr         r3, [r4]
  00054	e5843004	 str         r3, [r4, #4]

; 634  :     CFGBlock.EndAddress   = CFGBlock.pTraceBuffer;

  00058	e5843008	 str         r3, [r4, #8]

; 635  :     break;

  0005c	ea000012	 b           |$LN4@TraceContr|
  00060		 |$LN2@TraceContr|

; 619  : 
; 620  :     break;
; 621  : 
; 622  :   case 1: // enable trace
; 623  :     NKSetDataAbortHandler( XSCBwrTraceDataAbortHandler );

  00060	e59f007c	 ldr         r0, [pc, #0x7C]
  00064	eb000000	 bl          NKSetDataAbortHandler

; 624  : 
; 625  :     // Need to flush caches to have handler written to exception area
; 626  :     OEMCacheRangeFlush(0, 0, CACHE_SYNC_ALL); 

  00068	e3a0207f	 mov         r2, #0x7F
  0006c	e3a01000	 mov         r1, #0
  00070	e3a00000	 mov         r0, #0
  00074	eb000000	 bl          OEMCacheRangeFlush

; 627  : 
; 628  :     CFGBlock.TraceMode = WRAP_AROUND;

  00078	e59f3060	 ldr         r3, [pc, #0x60]
  0007c	e3a02001	 mov         r2, #1
  00080	e5832010	 str         r2, [r3, #0x10]

; 629  : 
; 630  :     break;

  00084	ea000008	 b           |$LN4@TraceContr|
  00088		 |$LN3@TraceContr|

; 613  :   case 0: // diable trace
; 614  :     CFGBlock.TraceMode = TRACE_OFF;

  00088	e59f3050	 ldr         r3, [pc, #0x50]
  0008c	e3a02002	 mov         r2, #2

; 615  :     NKSetDataAbortHandler( pfOSDataAbortHandler );

  00090	e5930020	 ldr         r0, [r3, #0x20]
  00094	e5832010	 str         r2, [r3, #0x10]
  00098	eb000000	 bl          NKSetDataAbortHandler

; 616  : 
; 617  :     // Need to flush caches to have handler written to exception area
; 618  :     OEMCacheRangeFlush(0, 0, CACHE_SYNC_ALL); 

  0009c	e3a0207f	 mov         r2, #0x7F
  000a0	e3a01000	 mov         r1, #0
  000a4	e3a00000	 mov         r0, #0
  000a8	eb000000	 bl          OEMCacheRangeFlush
  000ac		 |$LN4@TraceContr|

; 636  :   }
; 637  : 
; 638  :   retval = TRUE;
; 639  :   *lpBytesReturned = 0;

  000ac	e3a03000	 mov         r3, #0
  000b0	e5853000	 str         r3, [r5]

; 640  : 
; 641  :   return retval;

  000b4	e3a00001	 mov         r0, #1

; 642  : }

  000b8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN6@TraceContr|

; 608  :     {
; 609  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  000c0	e59f3014	 ldr         r3, [pc, #0x14]
  000c4	e3a0007a	 mov         r0, #0x7A
  000c8	e1a0e00f	 mov         lr, pc
  000cc	e12fff13	 bx          r3

; 610  :       return (retval);

  000d0	e3a00000	 mov         r0, #0

; 642  : }

  000d4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$LN13@TraceContr|
  000dc		 |$LN14@TraceContr|
  000dc	f101ffb4	 DCD         0xf101ffb4
  000e0		 |$LN15@TraceContr|
  000e0	00000000	 DCD         |CFGBlock|
  000e4		 |$LN16@TraceContr|
  000e4	00000000	 DCD         |XSCBwrTraceDataAbortHandler|
  000e8		 |$M16832|

			 ENDP  ; |TraceControlIoctl|


  00000			 AREA	 |.pdata|, PDATA
|$T16850| DCD	|$LN9@ReadTraceI|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadTraceIoctl| PROC

; 656  : {

  00000		 |$LN9@ReadTraceI|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M16847|
  00004	e1a00003	 mov         r0, r3

; 657  :     // Set the default return value 
; 658  :     BOOL retval = FALSE;
; 659  :     if ( (lpBytesReturned == NULL) )

  00008	e59d400c	 ldr         r4, [sp, #0xC]
  0000c	e3540000	 cmp         r4, #0
  00010	1a000004	 bne         |$LN3@ReadTraceI|

; 660  :     {
; 661  :         SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00014	e59f3054	 ldr         r3, [pc, #0x54]
  00018	e3a0007a	 mov         r0, #0x7A
  0001c	e1a0e00f	 mov         lr, pc
  00020	e12fff13	 bx          r3

; 662  :         return (retval);

  00024	ea00000e	 b           |$LN6@ReadTraceI|
  00028		 |$LN3@ReadTraceI|

; 663  :     }
; 664  :  
; 665  :     // check output buffer
; 666  :     //
; 667  :     if ( (lpOutBuf == NULL) || (nOutBufSize < 264 ) )

  00028	e3500000	 cmp         r0, #0
  0002c	0a000008	 beq         |$LN1@ReadTraceI|
  00030	e59d3008	 ldr         r3, [sp, #8]
  00034	e3530f42	 cmp         r3, #0x42, 30
  00038	3a000005	 bcc         |$LN1@ReadTraceI|

; 671  :     }
; 672  :       
; 673  :     // copy trace buffer into user buffer
; 674  :     //
; 675  :     XSCBwrSaveTrace(lpOutBuf);

  0003c	eb000000	 bl          XSCBwrSaveTrace

; 676  :     *lpBytesReturned = 264;

  00040	e3a03f42	 mov         r3, #0x42, 30
  00044	e5843000	 str         r3, [r4]

; 677  :     retval = TRUE;
; 678  : 
; 679  :     return (retval);

  00048	e3a00001	 mov         r0, #1

; 680  : }

  0004c	e8bd4010	 ldmia       sp!, {r4, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN1@ReadTraceI|

; 668  :     {
; 669  :       SetLastError(ERROR_INSUFFICIENT_BUFFER);

  00054	e59f3014	 ldr         r3, [pc, #0x14]
  00058	e3a0007a	 mov         r0, #0x7A
  0005c	e1a0e00f	 mov         lr, pc
  00060	e12fff13	 bx          r3
  00064		 |$LN6@ReadTraceI|

; 670  :       return (retval);

  00064	e3a00000	 mov         r0, #0

; 680  : }

  00068	e8bd4010	 ldmia       sp!, {r4, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$LN10@ReadTraceI|
  00070		 |$LN11@ReadTraceI|
  00070	f101ffb4	 DCD         0xf101ffb4
  00074		 |$M16848|

			 ENDP  ; |ReadTraceIoctl|

	EXPORT	|XSCBwrIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T16934| DCD	|$LN51@XSCBwrIoCo|
	DCD	0x4000d702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XSCBwrIoControl| PROC

; 696  : {

  00000		 |$LN51@XSCBwrIoCo|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M16931|
  00008	e1a05003	 mov         r5, r3
  0000c	e1a07002	 mov         r7, r2
  00010	e1a06001	 mov         r6, r1

; 697  :   BOOL retval = FALSE;
; 698  :   
; 699  :   switch( code ) {

  00014	e59f333c	 ldr         r3, [pc, #0x33C]
  00018	e3a04000	 mov         r4, #0
  0001c	e1500003	 cmp         r0, r3
  00020	8a000080	 bhi         |$LN14@XSCBwrIoCo|
  00024	0a00005e	 beq         |$LN7@XSCBwrIoCo|
  00028	e59fe324	 ldr         lr, [pc, #0x324]
  0002c	e150000e	 cmp         r0, lr
  00030	0a00003f	 beq         |$LN9@XSCBwrIoCo|
  00034	e59fe314	 ldr         lr, [pc, #0x314]
  00038	e150000e	 cmp         r0, lr
  0003c	0a000029	 beq         |$LN8@XSCBwrIoCo|
  00040	e59fe304	 ldr         lr, [pc, #0x304]
  00044	e150000e	 cmp         r0, lr
  00048	0a00001c	 beq         |$LN6@XSCBwrIoCo|
  0004c	e59f32f4	 ldr         r3, [pc, #0x2F4]
  00050	e1500003	 cmp         r0, r3
  00054	1a00007c	 bne         |$LN1@XSCBwrIoCo|

; 738  : 
; 739  :   case IOCTL_XSDBG_READTRACE: 
; 740  :       retval = ReadTraceIoctl( code, pInpBuffer, inpSize,
; 741  :                                       pOutBuffer, outSize, pOutSize);

  00058	e59d4020	 ldr         r4, [sp, #0x20]
  0005c	e3540000	 cmp         r4, #0
  00060	1a000005	 bne         |$LN34@XSCBwrIoCo|
  00064	e59f32c4	 ldr         r3, [pc, #0x2C4]
  00068	e3a0007a	 mov         r0, #0x7A
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3
  00074	e3a04000	 mov         r4, #0
  00078	ea0000a8	 b           |$LN10@XSCBwrIoCo|
  0007c		 |$LN34@XSCBwrIoCo|
  0007c	e3550000	 cmp         r5, #0
  00080	0a000008	 beq         |$LN32@XSCBwrIoCo|
  00084	e59d301c	 ldr         r3, [sp, #0x1C]
  00088	e3530f42	 cmp         r3, #0x42, 30
  0008c	3a000005	 bcc         |$LN32@XSCBwrIoCo|
  00090	e1a00005	 mov         r0, r5
  00094	eb000000	 bl          XSCBwrSaveTrace
  00098	e3a03f42	 mov         r3, #0x42, 30
  0009c		 |$LN47@XSCBwrIoCo|
  0009c	e5843000	 str         r3, [r4]
  000a0	e3a04001	 mov         r4, #1
  000a4	ea00009d	 b           |$LN10@XSCBwrIoCo|
  000a8		 |$LN32@XSCBwrIoCo|
  000a8	e59f3280	 ldr         r3, [pc, #0x280]
  000ac	e3a0007a	 mov         r0, #0x7A
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3
  000b8	e3a04000	 mov         r4, #0
  000bc	ea000097	 b           |$LN10@XSCBwrIoCo|
  000c0		 |$LN6@XSCBwrIoCo|

; 713  :       break;
; 714  : 
; 715  :   
; 716  : /*  These tree IOCTLs are implemented by the BSP
; 717  :     case IOCTL_XSDBG_QUERYCTXREGS: 
; 718  :       retval = QueryContextRegistersIoctl(code, pInpBuffer, inpSize,
; 719  :                                       pOutBuffer, outSize, pOutSize);
; 720  :       break;
; 721  :     
; 722  :   case IOCTL_XSDBG_READCTXREGS: 
; 723  : 
; 724  :       retval = ReadContextRegisterIoctl( code, pInpBuffer, inpSize,
; 725  :                                       pOutBuffer, outSize, pOutSize);
; 726  :       break;
; 727  : 
; 728  :   case IOCTL_XSDBG_WRITECTXREGS: 
; 729  :       retval = WriteContextRegisterIoctl( code, pInpBuffer, inpSize,
; 730  :                                       pOutBuffer, outSize, pOutSize);
; 731  :       break;
; 732  : */
; 733  : 
; 734  :   case IOCTL_XSDBG_TRACECONTROL:
; 735  :       retval = TraceControlIoctl(code, pInpBuffer, inpSize,
; 736  :                                       pOutBuffer, outSize, pOutSize);

  000c0	e59d2020	 ldr         r2, [sp, #0x20]
  000c4	e59d101c	 ldr         r1, [sp, #0x1C]
  000c8	e1a03005	 mov         r3, r5
  000cc	e58d2004	 str         r2, [sp, #4]
  000d0	e58d1000	 str         r1, [sp]
  000d4	e1a02007	 mov         r2, r7
  000d8	e1a01006	 mov         r1, r6
  000dc	e1a0000e	 mov         r0, lr
  000e0	eb000000	 bl          TraceControlIoctl

; 737  :       break;

  000e4	ea00008c	 b           |$LN45@XSCBwrIoCo|
  000e8		 |$LN8@XSCBwrIoCo|

; 704  : 
; 705  :   case IOCTL_XSDBG_WRITECOPROCESSOR: 
; 706  :       retval = WriteCoProcessorIoctl( code, pInpBuffer, inpSize,
; 707  :                                       pOutBuffer, outSize, pOutSize);

  000e8	e3560000	 cmp         r6, #0
  000ec	0a00000a	 beq         |$LN21@XSCBwrIoCo|
  000f0	e357000c	 cmp         r7, #0xC
  000f4	3a000008	 bcc         |$LN21@XSCBwrIoCo|
  000f8	e5960000	 ldr         r0, [r6]
  000fc	e2862008	 add         r2, r6, #8
  00100	e2861004	 add         r1, r6, #4
  00104	eb000000	 bl          XSCBwrExecuteCoProcCode
  00108	e59d3020	 ldr         r3, [sp, #0x20]
  0010c	e3a02000	 mov         r2, #0
  00110	e3a04001	 mov         r4, #1
  00114	e5832000	 str         r2, [r3]
  00118	ea000080	 b           |$LN10@XSCBwrIoCo|
  0011c		 |$LN21@XSCBwrIoCo|
  0011c	e59f320c	 ldr         r3, [pc, #0x20C]
  00120	e3a00057	 mov         r0, #0x57
  00124	e1a0e00f	 mov         lr, pc
  00128	e12fff13	 bx          r3
  0012c	e3a04000	 mov         r4, #0
  00130	ea00007a	 b           |$LN10@XSCBwrIoCo|
  00134		 |$LN9@XSCBwrIoCo|

; 700  :   case IOCTL_XSDBG_READCOPROCESSOR: 
; 701  :       retval =  ReadCoProcessorIoctl( code, pInpBuffer, inpSize,
; 702  :                                       pOutBuffer, outSize, pOutSize);

  00134	e3560000	 cmp         r6, #0
  00138	0a000013	 beq         |$LN17@XSCBwrIoCo|
  0013c	e3550000	 cmp         r5, #0
  00140	0a000011	 beq         |$LN17@XSCBwrIoCo|
  00144	e59d301c	 ldr         r3, [sp, #0x1C]
  00148	e3530008	 cmp         r3, #8
  0014c	3a000008	 bcc         |$LN15@XSCBwrIoCo|
  00150	e59d4020	 ldr         r4, [sp, #0x20]
  00154	e3540000	 cmp         r4, #0
  00158	0a000005	 beq         |$LN15@XSCBwrIoCo|
  0015c	e5960000	 ldr         r0, [r6]
  00160	e2852004	 add         r2, r5, #4
  00164	e1a01005	 mov         r1, r5
  00168	eb000000	 bl          XSCBwrExecuteCoProcCode
  0016c	e3a03008	 mov         r3, #8
  00170	eaffffc9	 b           |$LN47@XSCBwrIoCo|
  00174		 |$LN15@XSCBwrIoCo|
  00174	e59f31b4	 ldr         r3, [pc, #0x1B4]
  00178	e3a0007a	 mov         r0, #0x7A
  0017c	e1a0e00f	 mov         lr, pc
  00180	e12fff13	 bx          r3
  00184	e3a04000	 mov         r4, #0

; 703  :       break;

  00188	ea000064	 b           |$LN10@XSCBwrIoCo|

; 700  :   case IOCTL_XSDBG_READCOPROCESSOR: 
; 701  :       retval =  ReadCoProcessorIoctl( code, pInpBuffer, inpSize,
; 702  :                                       pOutBuffer, outSize, pOutSize);

  0018c		 |$LN17@XSCBwrIoCo|
  0018c	e59f319c	 ldr         r3, [pc, #0x19C]
  00190	e3a00057	 mov         r0, #0x57
  00194	e1a0e00f	 mov         lr, pc
  00198	e12fff13	 bx          r3
  0019c	e3a04000	 mov         r4, #0

; 703  :       break;

  001a0	ea00005e	 b           |$LN10@XSCBwrIoCo|
  001a4		 |$LN7@XSCBwrIoCo|

; 708  :       break;
; 709  : 
; 710  :   case IOCTL_XSDBG_SETTASK:
; 711  :       retval = SetTaskIoctl( code, pInpBuffer, inpSize,
; 712  :                                       pOutBuffer, outSize, pOutSize);

  001a4	e3560000	 cmp         r6, #0
  001a8	0a000018	 beq         |$LN28@XSCBwrIoCo|
  001ac	e3570008	 cmp         r7, #8
  001b0	3a000016	 bcc         |$LN28@XSCBwrIoCo|
  001b4	e59d1020	 ldr         r1, [sp, #0x20]
  001b8	e3510000	 cmp         r1, #0
  001bc	1a000005	 bne         |$LN27@XSCBwrIoCo|
  001c0	e59f3168	 ldr         r3, [pc, #0x168]
  001c4	e3a0007a	 mov         r0, #0x7A
  001c8	e1a0e00f	 mov         lr, pc
  001cc	e12fff13	 bx          r3
  001d0	e3a04000	 mov         r4, #0
  001d4	ea000051	 b           |$LN10@XSCBwrIoCo|
  001d8		 |$LN27@XSCBwrIoCo|
  001d8	e5963004	 ldr         r3, [r6, #4]

; 738  : 
; 739  :   case IOCTL_XSDBG_READTRACE: 
; 740  :       retval = ReadTraceIoctl( code, pInpBuffer, inpSize,
; 741  :                                       pOutBuffer, outSize, pOutSize);

  001dc	e3a04001	 mov         r4, #1
  001e0	e3530000	 cmp         r3, #0
  001e4	159f2158	 ldrne       r2, [pc, #0x158]
  001e8	15823000	 strne       r3, [r2]
  001ec	15963000	 ldrne       r3, [r6]
  001f0	15823004	 strne       r3, [r2, #4]
  001f4	059f3148	 ldreq       r3, [pc, #0x148]
  001f8	03e02000	 mvneq       r2, #0
  001fc	05832004	 streq       r2, [r3, #4]
  00200	05832000	 streq       r2, [r3]
  00204	e3a03000	 mov         r3, #0
  00208	e5813000	 str         r3, [r1]
  0020c	ea000043	 b           |$LN10@XSCBwrIoCo|

; 708  :       break;
; 709  : 
; 710  :   case IOCTL_XSDBG_SETTASK:
; 711  :       retval = SetTaskIoctl( code, pInpBuffer, inpSize,
; 712  :                                       pOutBuffer, outSize, pOutSize);

  00210		 |$LN28@XSCBwrIoCo|
  00210	e59f3118	 ldr         r3, [pc, #0x118]
  00214	e3a00057	 mov         r0, #0x57
  00218	e1a0e00f	 mov         lr, pc
  0021c	e12fff13	 bx          r3
  00220	e3a04000	 mov         r4, #0
  00224	ea00003d	 b           |$LN10@XSCBwrIoCo|
  00228		 |$LN14@XSCBwrIoCo|

; 697  :   BOOL retval = FALSE;
; 698  :   
; 699  :   switch( code ) {

  00228	e59fe110	 ldr         lr, [pc, #0x110]
  0022c	e150000e	 cmp         r0, lr
  00230	0a000030	 beq         |$LN4@XSCBwrIoCo|
  00234	e59f3100	 ldr         r3, [pc, #0x100]
  00238	e1500003	 cmp         r0, r3
  0023c	0a00001c	 beq         |$LN3@XSCBwrIoCo|
  00240	e59f30f0	 ldr         r3, [pc, #0xF0]
  00244	e1500003	 cmp         r0, r3
  00248	0a000004	 beq         |$LN2@XSCBwrIoCo|
  0024c		 |$LN1@XSCBwrIoCo|

; 759  :       break;
; 760  :   default:
; 761  :     SetLastError(ERROR_NOT_SUPPORTED);

  0024c	e59f30dc	 ldr         r3, [pc, #0xDC]
  00250	e3a00032	 mov         r0, #0x32
  00254	e1a0e00f	 mov         lr, pc
  00258	e12fff13	 bx          r3

; 762  :     break;

  0025c	ea00002f	 b           |$LN10@XSCBwrIoCo|
  00260		 |$LN2@XSCBwrIoCo|

; 753  :       break;
; 754  : 
; 755  :   case IOCTL_XSDBG_GETVERSION:
; 756  : 
; 757  :       retval = GetVersionIoctl( code, pInpBuffer, inpSize,
; 758  :                                       pOutBuffer, outSize, pOutSize);

  00260	e3550000	 cmp         r5, #0
  00264	0a00000c	 beq         |$LN41@XSCBwrIoCo|
  00268	e59d301c	 ldr         r3, [sp, #0x1C]
  0026c	e3530008	 cmp         r3, #8
  00270	3a000009	 bcc         |$LN41@XSCBwrIoCo|
  00274	e59d3020	 ldr         r3, [sp, #0x20]
  00278	e3530000	 cmp         r3, #0
  0027c	13a02001	 movne       r2, #1
  00280	15852000	 strne       r2, [r5]
  00284	13a01002	 movne       r1, #2
  00288	13a02008	 movne       r2, #8
  0028c	15851004	 strne       r1, [r5, #4]
  00290	15832000	 strne       r2, [r3]
  00294	13a04001	 movne       r4, #1
  00298	1a000020	 bne         |$LN10@XSCBwrIoCo|
  0029c		 |$LN41@XSCBwrIoCo|
  0029c	e59f308c	 ldr         r3, [pc, #0x8C]
  002a0	e3a0007a	 mov         r0, #0x7A
  002a4	e1a0e00f	 mov         lr, pc
  002a8	e12fff13	 bx          r3
  002ac	e3a04000	 mov         r4, #0
  002b0	ea00001a	 b           |$LN10@XSCBwrIoCo|
  002b4		 |$LN3@XSCBwrIoCo|

; 748  :       break;
; 749  :   case IOCTL_XSDBG_GETTRACECONFIG:
; 750  : 
; 751  :       retval = GetTraceConfigIoctl( code, pInpBuffer, inpSize,
; 752  :                                       pOutBuffer, outSize, pOutSize);

  002b4	e3550000	 cmp         r5, #0
  002b8	0a000008	 beq         |$LN37@XSCBwrIoCo|
  002bc	e59d301c	 ldr         r3, [sp, #0x1C]
  002c0	e3530004	 cmp         r3, #4
  002c4	259f3068	 ldrcs       r3, [pc, #0x68]
  002c8	259d2020	 ldrcs       r2, [sp, #0x20]
  002cc	23a01004	 movcs       r1, #4
  002d0	25853000	 strcs       r3, [r5]
  002d4	25821000	 strcs       r1, [r2]
  002d8	23a04001	 movcs       r4, #1
  002dc	2a00000f	 bcs         |$LN10@XSCBwrIoCo|
  002e0		 |$LN37@XSCBwrIoCo|
  002e0	e59f3048	 ldr         r3, [pc, #0x48]
  002e4	e3a0007a	 mov         r0, #0x7A
  002e8	e1a0e00f	 mov         lr, pc
  002ec	e12fff13	 bx          r3
  002f0	e3a04000	 mov         r4, #0
  002f4	ea000009	 b           |$LN10@XSCBwrIoCo|
  002f8		 |$LN4@XSCBwrIoCo|

; 742  :       break;
; 743  : 
; 744  :   case IOCTL_XSDBG_READKMEM:
; 745  : 
; 746  :       retval = ReadKMemIoctl( code, pInpBuffer, inpSize,
; 747  :                                       pOutBuffer, outSize, pOutSize);

  002f8	e59d2020	 ldr         r2, [sp, #0x20]
  002fc	e59d101c	 ldr         r1, [sp, #0x1C]
  00300	e1a03005	 mov         r3, r5
  00304	e58d2004	 str         r2, [sp, #4]
  00308	e58d1000	 str         r1, [sp]
  0030c	e1a02007	 mov         r2, r7
  00310	e1a01006	 mov         r1, r6
  00314	e1a0000e	 mov         r0, lr
  00318	eb000000	 bl          ReadKMemIoctl
  0031c		 |$LN45@XSCBwrIoCo|
  0031c	e1a04000	 mov         r4, r0
  00320		 |$LN10@XSCBwrIoCo|

; 763  :   }
; 764  : 
; 765  :   return retval;
; 766  : }

  00320	e1a00004	 mov         r0, r4
  00324	e28dd008	 add         sp, sp, #8
  00328	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0032c	e12fff1e	 bx          lr
  00330		 |$LN52@XSCBwrIoCo|
  00330		 |$LN53@XSCBwrIoCo|
  00330	f101ffb4	 DCD         0xf101ffb4
  00334		 |$LN54@XSCBwrIoCo|
  00334	00000000	 DCD         |CFGBlock|
  00338		 |$LN55@XSCBwrIoCo|
  00338	01013f70	 DCD         0x1013f70
  0033c		 |$LN56@XSCBwrIoCo|
  0033c	01013f6c	 DCD         0x1013f6c
  00340		 |$LN57@XSCBwrIoCo|
  00340	01013f68	 DCD         0x1013f68
  00344		 |$LN58@XSCBwrIoCo|
  00344	00000000	 DCD         |XSCBwrThreadID|
  00348		 |$LN59@XSCBwrIoCo|
  00348	01013f60	 DCD         0x1013f60
  0034c		 |$LN60@XSCBwrIoCo|
  0034c	01013f5c	 DCD         0x1013f5c
  00350		 |$LN61@XSCBwrIoCo|
  00350	01013f4c	 DCD         0x1013f4c
  00354		 |$LN62@XSCBwrIoCo|
  00354	01013f48	 DCD         0x1013f48
  00358		 |$LN63@XSCBwrIoCo|
  00358	01013f64	 DCD         0x1013f64
  0035c		 |$M16932|

			 ENDP  ; |XSCBwrIoControl|

	END
