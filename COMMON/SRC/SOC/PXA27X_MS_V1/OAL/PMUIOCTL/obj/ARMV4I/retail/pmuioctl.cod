; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\OAL\PMUIOCTL\pmuioctl.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|bPMURunning| [ DATA ]
	EXPORT	|dCCFreqLock| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|pPMURegBuf|, 0x4

	 COMMON	|PVTuneReleaseCCF|, 0x4

	 COMMON	|pPMUCCFBuf|, 0x4

	 COMMON	|pCPUIdBuf|, 0x4

	 COMMON	|PVTuneInterrupt|, 0x4

	 COMMON	|PVTuneReleasePMU|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|bPMURunning| %	0x4
|dCCFreqLock| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALIoCtlPMUCCFCall|
	EXPORT	|??_C@_1DO@FNGJILFI@?$AAU?$AAn?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?3?$AA?5?$AA?$CF?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|XllpXSC1ReadCLKCFG|
	IMPORT	|NKSetLastError|
	IMPORT	|INTERRUPTS_ON|
	IMPORT	|XllpXSC1FreqChange|
	IMPORT	|INTERRUPTS_OFF|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|OALPAtoVA|
	IMPORT	|memcpy|

  00008			 AREA	 |.bss|, NOINIT
|savedCLKCFG| %	0x4
|savedCCCR| %	0x4
|savedCLKCFG| %	0x4
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\oal\pmuioctl\pmuioctl.c

  00000			 AREA	 |.pdata|, PDATA
|$T43494| DCD	|$LN29@OALIoCtlPM|
	DCD	0x40009101

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@FNGJILFI@?$AAU?$AAn?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?3?$AA?5?$AA?$CF?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "n", 0x0, "s", 0x0, "u", 0x0, "p", 0x0, "p", 0x0, "o"
	DCB	0x0, "r", 0x0, "t", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "I"
	DCB	0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L", 0x0, " ", 0x0, "c"
	DCB	0x0, "a", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, ":"
	DCB	0x0, " ", 0x0, "%", 0x0, "X", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIoCtlPMUCCFCall| PROC

; 69   : {             

  00000		 |$LN29@OALIoCtlPM|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M43491|
  00004	e1a08003	 mov         r8, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a09000	 mov         r9, r0
  00014	e3a03441	 mov         r3, #0x41, 8

; 70   :     DWORD len;
; 71   :     BOOL retval=FALSE;
; 72   :     unsigned long LMult,NMult,CLKCFGReg,CLKCFGMask;
; 73   :     volatile XLLP_CLKMGR_T  *v_pCLKReg=(volatile XLLP_CLKMGR_T*)OALPAtoVA(BULVERDE_BASE_REG_PA_CLKMGR, FALSE);      

  00018	e3830603	 orr         r0, r3, #3, 12
  0001c	e3a01000	 mov         r1, #0
  00020	e3a04000	 mov         r4, #0
  00024	eb000000	 bl          OALPAtoVA
  00028	e1a07000	 mov         r7, r0

; 74   : 
; 75   :     if ((pInpBuffer == NULL) || (inpSize != sizeof(PMUCCFInfo)))

  0002c	e3560000	 cmp         r6, #0
  00030	0a000077	 beq         |$LN17@OALIoCtlPM|
  00034	e3550010	 cmp         r5, #0x10
  00038	1a000075	 bne         |$LN17@OALIoCtlPM|

; 79   :     }
; 80   :     
; 81   :     pPMUCCFBuf = (PPMUCCFInfo) pInpBuffer;

  0003c	e59f51fc	 ldr         r5, [pc, #0x1FC]

; 82   :     pPMUCCFBuf->curFreq = 0;

  00040	e3a03000	 mov         r3, #0
  00044	e5856000	 str         r6, [r5]
  00048	e5863008	 str         r3, [r6, #8]

; 83   :     
; 84   :     // Check PMU CCF control code
; 85   :     //
; 86   :     switch (pPMUCCFBuf->subcode)

  0004c	e595e000	 ldr         lr, [r5]
  00050	e59e2000	 ldr         r2, [lr]
  00054	e3520001	 cmp         r2, #1
  00058	0a000041	 beq         |$LN14@OALIoCtlPM|
  0005c	e3520002	 cmp         r2, #2
  00060	0a00001a	 beq         |$LN7@OALIoCtlPM|
  00064	e3520003	 cmp         r2, #3
  00068	0a000004	 beq         |$LN3@OALIoCtlPM|

; 316  :         default:
; 317  :             NKDbgPrintfW(TEXT("Unsupported IOCTL called: %X\r\n"), code);

  0006c	e59f01c8	 ldr         r0, [pc, #0x1C8]
  00070	e1a01009	 mov         r1, r9
  00074	eb000000	 bl          NKDbgPrintfW

; 318  :             NKSetLastError(ERROR_NOT_SUPPORTED);

  00078	e3a00032	 mov         r0, #0x32

; 319  :             retval=FALSE;

  0007c	ea000065	 b           |$LN21@OALIoCtlPM|
  00080		 |$LN3@OALIoCtlPM|

; 253  : 
; 254  : 
; 255  :         case PMU_CCF_UNLOCK:
; 256  : 
; 257  :             //
; 258  :             // Restore the prior CCCR settings and run mode
; 259  :             // thereby instantiating another frequency change.
; 260  :             //
; 261  : 
; 262  :             //
; 263  :             // Disable all interrupts
; 264  :             //
; 265  :             INTERRUPTS_OFF();

  00080	eb000000	 bl          INTERRUPTS_OFF

; 266  : 
; 267  :             if (dCCFreqLock == 0)

  00084	e59f41a8	 ldr         r4, [pc, #0x1A8]
  00088	e594300c	 ldr         r3, [r4, #0xC]
  0008c	e3530000	 cmp         r3, #0

; 268  :             {
; 269  :                 //
; 270  :                 // Currently no lock taken out
; 271  :                 // so just return
; 272  :                 //
; 273  :                 INTERRUPTS_ON();
; 274  :                 retval = TRUE;
; 275  :                 break;

  00090	0a000030	 beq         |$LN24@OALIoCtlPM|

; 276  :             }
; 277  : 
; 278  : 
; 279  :             //
; 280  :             // Restore prior CCCR contents
; 281  :             // (Zero reserved bits)
; 282  :             //
; 283  :             v_pCLKReg->cccr = savedCCCR & ~XLLP_CCCR_RESERVED_BITS;

  00094	e59f219c	 ldr         r2, [pc, #0x19C]
  00098	e5943004	 ldr         r3, [r4, #4]

; 284  : 
; 285  :             //
; 286  :             // Notify frequency sensitive drivers to disable themselves
; 287  :             //    - Display driver (LCD frequency (K) is derived from L
; 288  :             //          L = 2-7.   K=1
; 289  :             //          L = 8-15,  K=4
; 290  :             //          L = 16-31, K=8
; 291  :             //
; 292  : 
; 293  :             //
; 294  :             // Program the CLKCFG (CP14, reg6) for a frequency change
; 295  :             // Parameter is the saved clock configuration settings to
; 296  :             // restore proper run and bus modes.
; 297  :             //
; 298  :             XllpXSC1FreqChange(savedCLKCFG);

  0009c	e5940000	 ldr         r0, [r4]
  000a0	e0033002	 and         r3, r3, r2
  000a4	e5873000	 str         r3, [r7]
  000a8	eb000000	 bl          XllpXSC1FreqChange

; 299  : 
; 300  :             //
; 301  :             // TBS: Resume frequency sensitive drivers
; 302  :             //
; 303  : 
; 304  :             //
; 305  :             // Unlock Freq. Change
; 306  :             //
; 307  :             dCCFreqLock--;

  000ac	e594300c	 ldr         r3, [r4, #0xC]
  000b0	e2433001	 sub         r3, r3, #1
  000b4	e584300c	 str         r3, [r4, #0xC]

; 308  : 
; 309  :             INTERRUPTS_ON();

  000b8	eb000000	 bl          INTERRUPTS_ON

; 310  : 
; 311  :             PVTuneReleaseCCF = NULL;

  000bc	e59f3168	 ldr         r3, [pc, #0x168]
  000c0	e3a02000	 mov         r2, #0

; 312  : 
; 313  :             retval = TRUE;

  000c4	e3a04001	 mov         r4, #1
  000c8	e5832000	 str         r2, [r3]

; 314  : 
; 315  :             break;

  000cc	ea000053	 b           |$LN19@OALIoCtlPM|
  000d0		 |$LN7@OALIoCtlPM|

; 144  :              }
; 145  : 
; 146  : 
; 147  :         break;
; 148  : 
; 149  : 
; 150  :         case PMU_CCF_SETLOCK:
; 151  :             //
; 152  :             // Save the current CCCR setting
; 153  :             //
; 154  :             savedCCCR = v_pCLKReg->ccsr;

  000d0	e597300c	 ldr         r3, [r7, #0xC]
  000d4	e59f6158	 ldr         r6, [pc, #0x158]

; 155  : 
; 156  :             //
; 157  :             // Check CPDIS bit.  If we are running in 13MHz mode,
; 158  :             // other frequency changes are invalid.
; 159  :             //
; 160  :             if (savedCCCR & 0x80000000)

  000d8	e3130102	 tst         r3, #2, 2
  000dc	e5863004	 str         r3, [r6, #4]
  000e0	0a000002	 beq         |$LN6@OALIoCtlPM|
  000e4		 |$LN26@OALIoCtlPM|

; 161  :             {
; 162  :                 NKSetLastError(ERROR_INVALID_FUNCTION);

  000e4	e3a00001	 mov         r0, #1
  000e8	eb000000	 bl          NKSetLastError

; 320  :     }   // End switch on pPMUCCFBuf->subcode
; 321  : 
; 322  :     return retval;

  000ec	ea00004b	 b           |$LN19@OALIoCtlPM|
  000f0		 |$LN6@OALIoCtlPM|

; 163  :                 break;
; 164  :             }
; 165  : 
; 166  :             //
; 167  :             // Read Clock Configuration CP14, r6 to get
; 168  :             // curret bus mode and turbo settings
; 169  :             //
; 170  :             savedCLKCFG = XllpXSC1ReadCLKCFG();

  000f0	eb000000	 bl          XllpXSC1ReadCLKCFG

; 171  : 
; 172  :             //
; 173  :             // For new frequency, set F and preserve B setting
; 174  :             //
; 175  :             CLKCFGMask = 0x2 | (savedCLKCFG & 0x8);
; 176  : 
; 177  :             //
; 178  :             // No Turbo Mode; Set N for a turbo multiplier of 1 (== Run Mode);
; 179  :             //
; 180  :             NMult = 2;
; 181  : 
; 182  :             //
; 183  :             // Determine the Run mode multiplier (L) for the new Freq
; 184  :             // PMU frequencies are in KHz.
; 185  :             //
; 186  :             LMult = pPMUCCFBuf->newFreq / CRYSTAL_KHZ;

  000f4	e5959000	 ldr         r9, [r5]
  000f8	e59f3130	 ldr         r3, [pc, #0x130]
  000fc	e2002008	 and         r2, r0, #8
  00100	e599e004	 ldr         lr, [r9, #4]
  00104	e3825002	 orr         r5, r2, #2

; 187  : 
; 188  :             //
; 189  :             // For frequencies about 15, must use normal Bus mode
; 190  :             //
; 191  :             if (LMult > 15)
; 192  :             {
; 193  :                 CLKCFGMask = 0x2;     // B= 0 (Normal), F=1
; 194  :             }
; 195  : 
; 196  :             //
; 197  :             // Save (already translated) callback address
; 198  :             //
; 199  :             PVTuneReleaseCCF = (ReleaseCCFCallback) pPMUCCFBuf->pCallback;

  00108	e59f211c	 ldr         r2, [pc, #0x11C]
  0010c	e083139e	 umull       r1, r3, lr, r3
  00110	e5860000	 str         r0, [r6]
  00114	e1a086a3	 mov         r8, r3, lsr #13
  00118	e599300c	 ldr         r3, [r9, #0xC]
  0011c	e358000f	 cmp         r8, #0xF
  00120	83a05002	 movhi       r5, #2
  00124	e5823000	 str         r3, [r2]

; 200  : 
; 201  :             //
; 202  :             // Disable all interrupts
; 203  :             //
; 204  :             INTERRUPTS_OFF();

  00128	eb000000	 bl          INTERRUPTS_OFF

; 205  : 
; 206  :             //
; 207  :             // Disallow Mode change if PMU is already locked.
; 208  :             //
; 209  :             if (dCCFreqLock)

  0012c	e596300c	 ldr         r3, [r6, #0xC]
  00130	e3530000	 cmp         r3, #0
  00134	0a000001	 beq         |$LN4@OALIoCtlPM|

; 210  :             {
; 211  :                 INTERRUPTS_ON();

  00138	eb000000	 bl          INTERRUPTS_ON

; 212  :                 NKSetLastError(ERROR_INVALID_FUNCTION);
; 213  :                 break;

  0013c	eaffffe8	 b           |$LN26@OALIoCtlPM|
  00140		 |$LN4@OALIoCtlPM|

; 214  :             }
; 215  : 
; 216  :             //
; 217  :             // Setup Lock
; 218  :             //
; 219  :             dCCFreqLock++;

  00140	e3a03001	 mov         r3, #1
  00144	e586300c	 str         r3, [r6, #0xC]

; 220  : 
; 221  :             //
; 222  :             // Set up the new frequency multipliers, N and L
; 223  :             // CPDIS, PPDIS = 0, enable after freq. change.
; 224  :             //
; 225  :             // Check for CPDIS bit is done above and if set
; 226  :             // frequency change is not allowed.
; 227  :             //
; 228  :             v_pCLKReg->cccr =  (NMult << 7) | LMult;

  00148	e3883c01	 orr         r3, r8, #1, 24

; 229  : 
; 230  :             //
; 231  :             // Notify frequency sensitive drivers to disable themselves
; 232  :             //    - Display driver
; 233  :             //
; 234  : 
; 235  :             //
; 236  :             // Program the CCLKCFG (CP14, reg6) for a frequency change
; 237  :             // Parameter is mask to use for CLKCFG register
; 238  :             //
; 239  :             XllpXSC1FreqChange(CLKCFGMask);

  0014c	e1a00005	 mov         r0, r5
  00150	e5873000	 str         r3, [r7]
  00154	eb000000	 bl          XllpXSC1FreqChange
  00158		 |$LN24@OALIoCtlPM|

; 240  : 
; 241  : 
; 242  :             //
; 243  :             // TBD: Resume frequency sensitive drivers
; 244  :             //
; 245  : 
; 246  : 
; 247  :             INTERRUPTS_ON();

  00158	eb000000	 bl          INTERRUPTS_ON

; 248  : 
; 249  :             retval = TRUE;

  0015c	e3a04001	 mov         r4, #1

; 250  : 
; 251  : 
; 252  :             break;

  00160	ea00002e	 b           |$LN19@OALIoCtlPM|
  00164		 |$LN14@OALIoCtlPM|

; 87   :     {
; 88   :     
; 89   :         case PMU_CCF_GETCURRENT:
; 90   :       
; 91   :             //
; 92   :             // Extract the L and N fields from the
; 93   :             // Core Clock Status register (CCSR)
; 94   :             //
; 95   :             
; 96   :             LMult = v_pCLKReg->ccsr & 0x0000001F;

  00164	e597300c	 ldr         r3, [r7, #0xC]
  00168	e3a01c05	 mov         r1, #5, 24

; 97   :             NMult = (v_pCLKReg->ccsr & 0x00000380) >> 7;

  0016c	e597000c	 ldr         r0, [r7, #0xC]
  00170	e203201f	 and         r2, r3, #0x1F

; 98   : 
; 99   :             //
; 100  :             // Compute the current frequency
; 101  :             // Deal in KHz for PMU
; 102  :             // NMult = (N * 10)/2
; 103  :             //
; 104  :             pPMUCCFBuf->curFreq = (LMult * CRYSTAL_KHZDIVTEN);

  00174	e3813014	 orr         r3, r1, #0x14
  00178	e0010392	 mul         r1, r2, r3
  0017c	e1a03b00	 mov         r3, r0, lsl #22
  00180	e1a06ea3	 mov         r6, r3, lsr #29
  00184	e58e1008	 str         r1, [lr, #8]

; 105  : 
; 106  :             //
; 107  :             // Read CCCKCFG to determine if we're in turbo mode
; 108  :             //
; 109  :             CLKCFGReg = XllpXSC1ReadCLKCFG();

  00188	eb000000	 bl          XllpXSC1ReadCLKCFG

; 110  : 
; 111  :             if (CLKCFGReg & 0x01)
; 112  :             {
; 113  :                 //
; 114  :                 // Turbo mode set
; 115  :                 //
; 116  :                 pPMUCCFBuf->curFreq *= (NMult*5);

  0018c	e5952000	 ldr         r2, [r5]
  00190	e3100001	 tst         r0, #1
  00194	e5923008	 ldr         r3, [r2, #8]
  00198	10030396	 mulne       r3, r6, r3
  0019c	10833103	 addne       r3, r3, r3, lsl #2

; 117  :             }
; 118  :             else
; 119  :             {
; 120  :                 pPMUCCFBuf->curFreq *= 10;

  001a0	00833103	 addeq       r3, r3, r3, lsl #2
  001a4	01a03083	 moveq       r3, r3, lsl #1
  001a8	e5823008	 str         r3, [r2, #8]

; 121  :             }
; 122  : 
; 123  : 
; 124  :             if (pPMUCCFBuf->curFreq != 0)

  001ac	e5952000	 ldr         r2, [r5]
  001b0	e5923008	 ldr         r3, [r2, #8]
  001b4	e3530000	 cmp         r3, #0
  001b8	0a000012	 beq         |$LN11@OALIoCtlPM|

; 125  :             {
; 126  :                 //
; 127  :                 // Return frequency in output buffer
; 128  :                 //
; 129  :                 len = sizeof(DWORD);
; 130  :                 if ((outSize == len) && (pOutBuffer != NULL) && (pOutSize != NULL))

  001bc	e59d301c	 ldr         r3, [sp, #0x1C]
  001c0	e3530004	 cmp         r3, #4
  001c4	1a00000c	 bne         |$LN10@OALIoCtlPM|
  001c8	e3580000	 cmp         r8, #0
  001cc	0a00000a	 beq         |$LN10@OALIoCtlPM|
  001d0	e59d5020	 ldr         r5, [sp, #0x20]
  001d4	e3550000	 cmp         r5, #0
  001d8	0a000007	 beq         |$LN10@OALIoCtlPM|

; 131  :                 {
; 132  :                     memcpy(pOutBuffer,&(pPMUCCFBuf->curFreq),len);

  001dc	e2821008	 add         r1, r2, #8
  001e0	e3a02004	 mov         r2, #4
  001e4	e1a00008	 mov         r0, r8
  001e8	eb000000	 bl          memcpy

; 133  :                     *pOutSize = len;

  001ec	e3a03004	 mov         r3, #4
  001f0	e5853000	 str         r3, [r5]

; 248  : 
; 249  :             retval = TRUE;

  001f4	e3a04001	 mov         r4, #1

; 250  : 
; 251  : 
; 252  :             break;

  001f8	ea000008	 b           |$LN19@OALIoCtlPM|
  001fc		 |$LN10@OALIoCtlPM|

; 134  :                     retval = TRUE;
; 135  :                 }
; 136  :                 else
; 137  :                 {
; 138  :                     NKSetLastError(ERROR_INSUFFICIENT_BUFFER);

  001fc	e3a0007a	 mov         r0, #0x7A

; 139  :                 }
; 140  :              }
; 141  :              else
; 142  :              {
; 143  :                 NKSetLastError(ERROR_NOT_SUPPORTED);

  00200	eb000000	 bl          NKSetLastError

; 320  :     }   // End switch on pPMUCCFBuf->subcode
; 321  : 
; 322  :     return retval;

  00204	ea000005	 b           |$LN19@OALIoCtlPM|
  00208		 |$LN11@OALIoCtlPM|

; 139  :                 }
; 140  :              }
; 141  :              else
; 142  :              {
; 143  :                 NKSetLastError(ERROR_NOT_SUPPORTED);

  00208	e3a00032	 mov         r0, #0x32
  0020c	eb000000	 bl          NKSetLastError

; 320  :     }   // End switch on pPMUCCFBuf->subcode
; 321  : 
; 322  :     return retval;

  00210	ea000002	 b           |$LN19@OALIoCtlPM|
  00214		 |$LN17@OALIoCtlPM|

; 76   :     {
; 77   :         NKSetLastError(ERROR_INVALID_PARAMETER);

  00214	e3a00057	 mov         r0, #0x57
  00218		 |$LN21@OALIoCtlPM|
  00218	eb000000	 bl          NKSetLastError

; 78   :         return FALSE;

  0021c	e3a04000	 mov         r4, #0
  00220		 |$LN19@OALIoCtlPM|

; 323  : }

  00220	e1a00004	 mov         r0, r4
  00224	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00228	e12fff1e	 bx          lr
  0022c		 |$LN30@OALIoCtlPM|
  0022c		 |$LN31@OALIoCtlPM|
  0022c	00000000	 DCD         |PVTuneReleaseCCF|
  00230		 |$LN32@OALIoCtlPM|
  00230	a151c331	 DCD         0xa151c331
  00234		 |$LN33@OALIoCtlPM|
  00234	00000000	 DCD         |savedCLKCFG|
  00238		 |$LN34@OALIoCtlPM|
  00238	ce00079f	 DCD         0xce00079f
  0023c		 |$LN35@OALIoCtlPM|
  0023c	00000000	 DCD         |??_C@_1DO@FNGJILFI@?$AAU?$AAn?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?3?$AA?5?$AA?$CF?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00240		 |$LN36@OALIoCtlPM|
  00240	00000000	 DCD         |pPMUCCFBuf|
  00244		 |$M43492|

			 ENDP  ; |OALIoCtlPMUCCFCall|

	EXPORT	|OALIoCtlPMUConfigCall|
	IMPORT	|OALIntrTranslateIrq|
	IMPORT	|WritePMUReg|
	IMPORT	|ReadPMUReg|

  00000			 AREA	 |.pdata|, PDATA
|$T43533| DCD	|$LN41@OALIoCtlPM@2|
	DCD	0x40008501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIoCtlPMUConfigCall| PROC

; 328  : {

  00000		 |$LN41@OALIoCtlPM@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43530|
  00004	e1b0e001	 movs        lr, r1
  00008	e1a01000	 mov         r1, r0
  0000c	e1a05003	 mov         r5, r3

; 329  :     DWORD len;
; 330  :     BOOL retval = FALSE;

  00010	e3a04000	 mov         r4, #0

; 331  :    
; 332  :     if ((pInpBuffer == NULL) || (inpSize != sizeof(PMURegInfo)))

  00014	0a000073	 beq         |$LN19@OALIoCtlPM@2|
  00018	e3520018	 cmp         r2, #0x18
  0001c	1a000071	 bne         |$LN19@OALIoCtlPM@2|

; 336  :     }
; 337  :     //
; 338  :     // Check PMU control code
; 339  :     //
; 340  :     switch (*(LPDWORD)pInpBuffer)

  00020	e59e2000	 ldr         r2, [lr]
  00024	e2423001	 sub         r3, r2, #1
  00028	e3530008	 cmp         r3, #8
  0002c	8a000069	 bhi         |$LN1@OALIoCtlPM@2|
  00030	e1a02083	 mov         r2, r3, lsl #1
  00034	e082200f	 add         r2, r2, pc
  00038	e1d220b4	 ldrh        r2, [r2, #4]
  0003c	e08ff002	 add         pc, pc, r2
  00040		 |$LN29@OALIoCtlPM@2|
  00040		 |$LN28@OALIoCtlPM@2|
  00040		 |$LN30@OALIoCtlPM@2|
  00040	0040		 DCW         0x40
  00042		 |$LN31@OALIoCtlPM@2|
  00042	0068		 DCW         0x68
  00044		 |$LN32@OALIoCtlPM@2|
  00044	0074		 DCW         0x74
  00046		 |$LN33@OALIoCtlPM@2|
  00046	0068		 DCW         0x68
  00048		 |$LN34@OALIoCtlPM@2|
  00048	0088		 DCW         0x88
  0004a		 |$LN35@OALIoCtlPM@2|
  0004a	0104		 DCW         0x104
  0004c		 |$LN36@OALIoCtlPM@2|
  0004c	0010		 DCW         0x10
  0004e		 |$LN37@OALIoCtlPM@2|
  0004e	002c		 DCW         0x2c
  00050		 |$LN38@OALIoCtlPM@2|
  00050	0128		 DCW         0x128
  00052		 |$LN48@OALIoCtlPM@2|

; 487  : }

  00052	0128		 DCW         0x128
  00054		 |$LN16@OALIoCtlPM@2|

; 341  :     {
; 342  :         case PMU_ALLOCATE:
; 343  :             //
; 344  :             // A user has allocated the PMU.
; 345  :             // Register the ReleasePMU callback with the kernel.
; 346  :             // (Address translated in API (Pmudll))
; 347  :             //
; 348  :             pPMURegBuf = (PPMURegInfo)pInpBuffer;

  00054	e59f31a8	 ldr         r3, [pc, #0x1A8]

; 349  :             PVTuneReleasePMU = (ReleasePMUCallback) pPMURegBuf->pCallback;

  00058	e59f21b0	 ldr         r2, [pc, #0x1B0]

; 350  :             return TRUE;

  0005c	e3a04001	 mov         r4, #1
  00060	e583e000	 str         lr, [r3]
  00064	e59e300c	 ldr         r3, [lr, #0xC]
  00068	e5823000	 str         r3, [r2]
  0006c	ea000060	 b           |$LN21@OALIoCtlPM@2|
  00070		 |$LN15@OALIoCtlPM@2|

; 351  :             break;
; 352  : 
; 353  :         case PMU_RELEASE:
; 354  :             //
; 355  :             // A user has released the PMU.
; 356  :             // Unregister the ReleasePMU callback.
; 357  :             //
; 358  :             PVTuneReleasePMU = NULL;

  00070	e59f3198	 ldr         r3, [pc, #0x198]
  00074	e3a02000	 mov         r2, #0

; 359  :             return TRUE;

  00078	e3a04001	 mov         r4, #1
  0007c	e5832000	 str         r2, [r3]
  00080	ea00005b	 b           |$LN21@OALIoCtlPM@2|
  00084		 |$LN14@OALIoCtlPM@2|

; 360  :             break;
; 361  : 
; 362  :         case PMU_ENABLE_IRQ:
; 363  :             pPMURegBuf = (PPMURegInfo)pInpBuffer;

  00084	e59f3178	 ldr         r3, [pc, #0x178]

; 364  :             PVTuneInterrupt = (PMUInterruptCallback) pPMURegBuf->pCallback;

  00088	e59f1178	 ldr         r1, [pc, #0x178]

; 365  :             bPMURunning = TRUE;

  0008c	e3a00001	 mov         r0, #1
  00090	e583e000	 str         lr, [r3]
  00094	e59e300c	 ldr         r3, [lr, #0xC]
  00098	e5813000	 str         r3, [r1]
  0009c		 |$LN27@OALIoCtlPM@2|
  0009c	e59f2168	 ldr         r2, [pc, #0x168]

; 366  : 
; 367  :             //Enable PMU IRQ
; 368  :             //VTune now uses an installable ISR
; 369  :             /*{
; 370  :                 UINT32 irq = IRQ_PMU;
; 371  :                 OALIntrEnableIrqs( 1, &irq);
; 372  :             }*/
; 373  : 
; 374  :             return TRUE;

  000a0	e3a04001	 mov         r4, #1
  000a4	e5820000	 str         r0, [r2]
  000a8	ea000051	 b           |$LN21@OALIoCtlPM@2|
  000ac		 |$LN13@OALIoCtlPM@2|

; 375  :             break;
; 376  : 
; 377  :         case PMU_ENABLE_FIQ:
; 378  :             NKSetLastError(ERROR_INVALID_FUNCTION);

  000ac	e3a00001	 mov         r0, #1
  000b0	eb000000	 bl          NKSetLastError

; 379  :             break;

  000b4	ea00004e	 b           |$LN21@OALIoCtlPM@2|
  000b8		 |$LN12@OALIoCtlPM@2|

; 380  : 
; 381  :         case PMU_DISABLE_IRQ:
; 382  :             PVTuneInterrupt = NULL;

  000b8	e59f3148	 ldr         r3, [pc, #0x148]

; 383  :             //Disable PMU IRQ
; 384  :             //VTune now uses an installable ISR
; 385  :             /*{
; 386  :                 UINT32 irq = IRQ_PMU;
; 387  :                 OALIntrDisableIrqs( 1, &irq);
; 388  :             }*/
; 389  :             bPMURunning = FALSE;

  000bc	e3a01000	 mov         r1, #0
  000c0	e3a00000	 mov         r0, #0
  000c4	e5831000	 str         r1, [r3]

; 390  :             return TRUE;

  000c8	eafffff3	 b           |$LN27@OALIoCtlPM@2|
  000cc		 |$LN10@OALIoCtlPM@2|

; 391  :             break;
; 392  : 
; 393  :         case PMU_DISABLE_FIQ:
; 394  :             NKSetLastError(ERROR_INVALID_FUNCTION);
; 395  :             break;
; 396  : 
; 397  :         case PMU_READ_REG:
; 398  :             //
; 399  :             // Read from the specified PMU register
; 400  :             //      2nd DWORD has register number
; 401  :             //      Register value (DWORD) written to output buffer
; 402  :             //
; 403  :             pPMURegBuf = (PPMURegInfo)pInpBuffer;

  000cc	e59f7130	 ldr         r7, [pc, #0x130]
  000d0	e587e000	 str         lr, [r7]

; 404  : 
; 405  :             if (pPMURegBuf->PMUReg > MAXPMUREG)

  000d4	e59e0004	 ldr         r0, [lr, #4]
  000d8	e3500008	 cmp         r0, #8
  000dc	9a000002	 bls         |$LN9@OALIoCtlPM@2|
  000e0		 |$LN26@OALIoCtlPM@2|

; 406  :             {
; 407  :                 NKSetLastError(ERROR_INVALID_PARAMETER);

  000e0	e3a00057	 mov         r0, #0x57
  000e4	eb000000	 bl          NKSetLastError
  000e8	ea000041	 b           |$LN21@OALIoCtlPM@2|
  000ec		 |$LN9@OALIoCtlPM@2|

; 408  :                 break;
; 409  :             }
; 410  : 
; 411  :             //
; 412  :             // Read the CP14 PMU register
; 413  :             //
; 414  :             pPMURegBuf->PMUValue = ReadPMUReg(pPMURegBuf->PMUReg);

  000ec	eb000000	 bl          ReadPMUReg
  000f0	e5972000	 ldr         r2, [r7]

; 415  : 
; 416  :             //
; 417  :             // Return results
; 418  :             //
; 419  :             len = sizeof(DWORD);
; 420  :             if ((outSize == len) && (pOutBuffer != NULL) && (pOutSize != NULL))

  000f4	e59d3014	 ldr         r3, [sp, #0x14]
  000f8	e5820008	 str         r0, [r2, #8]
  000fc	e3530004	 cmp         r3, #4
  00100	1a00000d	 bne         |$LN8@OALIoCtlPM@2|
  00104	e3550000	 cmp         r5, #0
  00108	0a00000b	 beq         |$LN8@OALIoCtlPM@2|
  0010c	e59d6018	 ldr         r6, [sp, #0x18]
  00110	e3560000	 cmp         r6, #0
  00114	0a000008	 beq         |$LN8@OALIoCtlPM@2|

; 421  :             {
; 422  :                 memcpy(pOutBuffer,&(pPMURegBuf->PMUValue),len);

  00118	e5973000	 ldr         r3, [r7]
  0011c	e3a02004	 mov         r2, #4
  00120	e1a00005	 mov         r0, r5
  00124	e2831008	 add         r1, r3, #8
  00128	eb000000	 bl          memcpy

; 423  :                 *pOutSize = len;

  0012c	e3a03004	 mov         r3, #4
  00130	e5863000	 str         r3, [r6]
  00134	e3a04001	 mov         r4, #1
  00138	ea00002d	 b           |$LN21@OALIoCtlPM@2|
  0013c		 |$LN8@OALIoCtlPM@2|

; 424  :                 retval = TRUE;
; 425  :             }
; 426  :             else
; 427  :             {
; 428  :                 NKSetLastError(ERROR_INSUFFICIENT_BUFFER);

  0013c	e3a0007a	 mov         r0, #0x7A
  00140	eb000000	 bl          NKSetLastError
  00144	ea00002a	 b           |$LN21@OALIoCtlPM@2|
  00148		 |$LN6@OALIoCtlPM@2|

; 429  :             }
; 430  :             break;
; 431  :         case PMU_WRITE_REG:
; 432  :             //
; 433  :             // Write to the specified PMU register
; 434  :             //      2nd DWORD has register number
; 435  :             //      3rd DWORD is value to write to register
; 436  :             //
; 437  :             pPMURegBuf = (PPMURegInfo)pInpBuffer;

  00148	e59f30b4	 ldr         r3, [pc, #0xB4]
  0014c	e583e000	 str         lr, [r3]

; 438  : 
; 439  :             if (pPMURegBuf->PMUReg > MAXPMUREG)

  00150	e59e0004	 ldr         r0, [lr, #4]
  00154	e3500008	 cmp         r0, #8

; 440  :             {
; 441  :                 NKSetLastError(ERROR_INVALID_PARAMETER);
; 442  :                 break;

  00158	8affffe0	 bhi         |$LN26@OALIoCtlPM@2|

; 443  :             }
; 444  : 
; 445  :             //
; 446  :             // Write to the CP14 PMU register and return
; 447  :             //
; 448  :             WritePMUReg (pPMURegBuf->PMUReg, pPMURegBuf->PMUValue);

  0015c	e59e1008	 ldr         r1, [lr, #8]
  00160	eb000000	 bl          WritePMUReg
  00164	e3a04001	 mov         r4, #1
  00168	ea000021	 b           |$LN21@OALIoCtlPM@2|
  0016c		 |$LN4@OALIoCtlPM@2|

; 449  : 
; 450  :             return TRUE;
; 451  :             break;
; 452  : 
; 453  :         case PMU_OEM_INFO:
; 454  :             //
; 455  :             // Obtain the OEM information used for the
; 456  :             //      SYSINTR_PMU interrupt ID
; 457  :             //      VTune's PMU driver global area
; 458  :             //
; 459  :             pPMURegBuf = (PPMURegInfo)pInpBuffer;

  0016c	e59f6090	 ldr         r6, [pc, #0x90]

; 460  :             pPMURegBuf->OEMData.sysintrID = OALIntrTranslateIrq(IRQ_PMU);       //SYSINTR_PMU

  00170	e3a0000c	 mov         r0, #0xC
  00174	e586e000	 str         lr, [r6]
  00178	eb000000	 bl          OALIntrTranslateIrq
  0017c	e5962000	 ldr         r2, [r6]

; 461  : 
; 462  :             // Return results
; 463  :             //
; 464  :             len = (sizeof(OEMInfo));
; 465  :             if ((outSize >= len) && (pOutBuffer != NULL) && (pOutSize != NULL))

  00180	e59d3014	 ldr         r3, [sp, #0x14]
  00184	e5820010	 str         r0, [r2, #0x10]
  00188	e3530008	 cmp         r3, #8
  0018c	3a00000d	 bcc         |$LN3@OALIoCtlPM@2|
  00190	e3550000	 cmp         r5, #0
  00194	0a00000b	 beq         |$LN3@OALIoCtlPM@2|
  00198	e59d4018	 ldr         r4, [sp, #0x18]
  0019c	e3540000	 cmp         r4, #0
  001a0	0a000008	 beq         |$LN3@OALIoCtlPM@2|

; 466  :             {
; 467  :                 memcpy(pOutBuffer,&(pPMURegBuf->OEMData),len);

  001a4	e5963000	 ldr         r3, [r6]
  001a8	e3a02008	 mov         r2, #8
  001ac	e1a00005	 mov         r0, r5
  001b0	e2831010	 add         r1, r3, #0x10
  001b4	eb000000	 bl          memcpy

; 468  :                 *pOutSize = len;

  001b8	e3a03008	 mov         r3, #8
  001bc	e5843000	 str         r3, [r4]
  001c0	e3a04001	 mov         r4, #1
  001c4	ea00000a	 b           |$LN21@OALIoCtlPM@2|
  001c8		 |$LN3@OALIoCtlPM@2|

; 469  :                 retval = TRUE;
; 470  :             }
; 471  :             else
; 472  :             {
; 473  :                 NKSetLastError(ERROR_INSUFFICIENT_BUFFER);

  001c8	e3a0007a	 mov         r0, #0x7A
  001cc	eb000000	 bl          NKSetLastError
  001d0	e3a04001	 mov         r4, #1
  001d4	ea000006	 b           |$LN21@OALIoCtlPM@2|
  001d8		 |$LN1@OALIoCtlPM@2|

; 474  :             }
; 475  : 
; 476  :             return TRUE;
; 477  :             break;
; 478  :         default:
; 479  :             NKDbgPrintfW(TEXT("Unsupported IOCTL called: %X\r\n"), code);

  001d8	e59f0020	 ldr         r0, [pc, #0x20]
  001dc	eb000000	 bl          NKDbgPrintfW

; 480  :             NKSetLastError(ERROR_NOT_SUPPORTED);

  001e0	e3a00032	 mov         r0, #0x32

; 481  :             retval=FALSE;
; 482  : 
; 483  :     }  // end switch
; 484  :     
; 485  :     
; 486  :     return retval;

  001e4	ea000000	 b           |$LN23@OALIoCtlPM@2|
  001e8		 |$LN19@OALIoCtlPM@2|

; 333  :     {
; 334  :         NKSetLastError(ERROR_INVALID_PARAMETER);

  001e8	e3a00057	 mov         r0, #0x57
  001ec		 |$LN23@OALIoCtlPM@2|
  001ec	eb000000	 bl          NKSetLastError

; 335  :         return FALSE;

  001f0	e3a04000	 mov         r4, #0
  001f4		 |$LN21@OALIoCtlPM@2|

; 487  : }

  001f4	e1a00004	 mov         r0, r4
  001f8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  001fc	e12fff1e	 bx          lr
  00200		 |$LN42@OALIoCtlPM@2|
  00200		 |$LN43@OALIoCtlPM@2|
  00200	00000000	 DCD         |??_C@_1DO@FNGJILFI@?$AAU?$AAn?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA?5?$AAc?$AAa?$AAl?$AAl?$AAe?$AAd?$AA?3?$AA?5?$AA?$CF?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  00204		 |$LN44@OALIoCtlPM@2|
  00204	00000000	 DCD         |pPMURegBuf|
  00208		 |$LN45@OALIoCtlPM@2|
  00208	00000000	 DCD         |PVTuneInterrupt|
  0020c		 |$LN46@OALIoCtlPM@2|
  0020c	00000000	 DCD         |bPMURunning|
  00210		 |$LN47@OALIoCtlPM@2|
  00210	00000000	 DCD         |PVTuneReleasePMU|
  00214		 |$M43531|

			 ENDP  ; |OALIoCtlPMUConfigCall|

	EXPORT	|OALIoCtlGetCPUIdCall|
	IMPORT	|XSC1GetCPUId|

  00000			 AREA	 |.pdata|, PDATA
|$T43554| DCD	|$LN9@OALIoCtlGe|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALIoCtlGetCPUIdCall| PROC

; 493  : {

  00000		 |$LN9@OALIoCtlGe|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M43551|
  00004	e1a06003	 mov         r6, r3
  00008	e3510000	 cmp         r1, #0

; 494  :     BOOL retval=FALSE;

  0000c	e3a04000	 mov         r4, #0

; 495  :     DWORD len;
; 496  :     if ((pInpBuffer == NULL) || (inpSize != sizeof(CPUIdInfo)))

  00010	0a000019	 beq         |$LN3@OALIoCtlGe|
  00014	e3520004	 cmp         r2, #4
  00018	1a000017	 bne         |$LN3@OALIoCtlGe|

; 500  :     }
; 501  : 
; 502  :     pCPUIdBuf = (PCPUIdInfo) pInpBuffer;

  0001c	e59f7070	 ldr         r7, [pc, #0x70]
  00020	e5871000	 str         r1, [r7]

; 503  : 
; 504  :     // Read the CP15 R0 Register to get the ID information
; 505  :     //
; 506  :     pCPUIdBuf->CPUId = XSC1GetCPUId();

  00024	eb000000	 bl          XSC1GetCPUId
  00028	e5971000	 ldr         r1, [r7]

; 507  : 
; 508  :     // Return results
; 509  :     //
; 510  :     len = sizeof(DWORD);
; 511  :     if ((outSize == len) && (pOutBuffer != NULL) && (pOutSize != NULL))

  0002c	e59d2014	 ldr         r2, [sp, #0x14]
  00030	e5810000	 str         r0, [r1]
  00034	e3520004	 cmp         r2, #4
  00038	1a00000c	 bne         |$LN2@OALIoCtlGe|
  0003c	e3560000	 cmp         r6, #0
  00040	0a00000a	 beq         |$LN2@OALIoCtlGe|
  00044	e59d5018	 ldr         r5, [sp, #0x18]
  00048	e3550000	 cmp         r5, #0
  0004c	0a000007	 beq         |$LN2@OALIoCtlGe|

; 512  :     {
; 513  :         memcpy(pOutBuffer,&(pCPUIdBuf->CPUId),len);

  00050	e5971000	 ldr         r1, [r7]
  00054	e3a02004	 mov         r2, #4
  00058	e1a00006	 mov         r0, r6
  0005c	eb000000	 bl          memcpy

; 514  :         *pOutSize = len;

  00060	e3a03004	 mov         r3, #4
  00064	e5853000	 str         r3, [r5]

; 515  :         retval = TRUE;

  00068	e3a04001	 mov         r4, #1

; 516  :     }
; 517  :     else

  0006c	ea000005	 b           |$LN5@OALIoCtlGe|
  00070		 |$LN2@OALIoCtlGe|

; 518  :     {
; 519  :         NKSetLastError(ERROR_INSUFFICIENT_BUFFER);

  00070	e3a0007a	 mov         r0, #0x7A
  00074	eb000000	 bl          NKSetLastError

; 520  :     }
; 521  :     return retval;

  00078	ea000002	 b           |$LN5@OALIoCtlGe|
  0007c		 |$LN3@OALIoCtlGe|

; 497  :     {
; 498  :         NKSetLastError(ERROR_INVALID_PARAMETER);

  0007c	e3a00057	 mov         r0, #0x57
  00080	eb000000	 bl          NKSetLastError

; 499  :         return FALSE;

  00084	e3a04000	 mov         r4, #0
  00088		 |$LN5@OALIoCtlGe|

; 522  : }

  00088	e1a00004	 mov         r0, r4
  0008c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$LN10@OALIoCtlGe|
  00094		 |$LN11@OALIoCtlGe|
  00094	00000000	 DCD         |pCPUIdBuf|
  00098		 |$M43552|

			 ENDP  ; |OALIoCtlGetCPUIdCall|

	END
