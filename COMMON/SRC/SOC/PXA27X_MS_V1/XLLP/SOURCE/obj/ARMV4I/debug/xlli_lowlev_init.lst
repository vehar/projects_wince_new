ARM macroassembler      Page:1 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000          ; 
   14 00000000          ; Copyright 2002-2003 Intel Corporation All Rights Reserved. 
   15 00000000          ;** 
   16 00000000          ;** Portions of the source code contained or described herein and all documents 
   17 00000000          ;** related to such source code (Material) are owned by Intel Corporation 
   18 00000000          ;** or its suppliers or licensors and is licensed by Microsoft Corporation for distribution.   
   19 00000000          ;** Title to the Material remains with Intel Corporation or its suppliers and licensors.  
   20 00000000          ;** Use of the Materials is subject to the terms of the Microsoft license agreement which accompanied the Materials.   
   21 00000000          ;** No other license under any patent, copyright, trade secret or other intellectual 
   22 00000000          ;** property right is granted to or conferred upon you by disclosure or 
   23 00000000          ;** delivery of the Materials, either expressly, by implication, inducement, 
   24 00000000          ;** estoppel or otherwise  
   25 00000000          ;** Some portion of the Materials may be copyrighted by Microsoft Corporation. 
   26 00000000          ; 
   27 00000000          ; 
   28 00000000          ;********************************************************************************* 
   29 00000000          ; 
   30 00000000          ;  FILENAME:       xlli_LowLev_Init.s 
   31 00000000          ; 
   32 00000000          ;  PURPOSE:        Provides low Level init procedures written specifically for 
   33 00000000          ;                  the Bulverde/Mainstone platform. 
   34 00000000          ; 
   35 00000000          ; 
   36 00000000          ;  LAST MODIFIED:  25-Feb-2005 
   37 00000000          ;****************************************************************************** 
   38 00000000          ; 
   39 00000000          ; The functions in this source code are called via a branch with link instruction. 
   40 00000000          ; Unless otherwise specified, no system stack is assumed and no registers are preserved. 
   41 00000000          ; 
   42 00000000          ; NOTES: 
   43 00000000          ; 
   44 00000000          ; The use of these subroutines and/or the order in which they are called is, for the most part, 
   45 00000000          ; arbitrary and is left up to the user. Only a few subroutines must be called in a specific order. 
   46 00000000          ; For example, it makes no sense to go to virtual mode before the MMU is initialized and 
   47 00000000          ; the page table is set up.... and, in order to set up the page table, memory needs to be initialized 
   48 00000000          ; first. 
   49 00000000          ; 
   50 00000000                  INCLUDE  xlli_Bulverde_defs.inc                 ; Bulverde specific include file 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000          ;********************************************************************************* 
   14 00000000          ; 
   15 00000000          ;        COPYRIGHT (c) 2002 Intel Corporation 
   16 00000000          ; 
   17 00000000          ;   The information in this file is furnished for informational use only, 
   18 00000000          ;   is subject to change without notice, and should not be construed as 
   19 00000000          ;   a commitment by Intel Corporation. Intel Corporation assumes no 
   20 00000000          ;   responsibility or liability for any errors or inaccuracies that may appear 
   21 00000000          ;   in this document or any software that may be provided in association with 
   22 00000000          ;   this document. 
   23 00000000          ; 
   24 00000000          ;********************************************************************************* 
   25 00000000          ; 
   26 00000000          ;  FILENAME:       xlli_Bulverde_defs.inc (Core processor address definitions) 
   27 00000000          ; 
   28 00000000          ; LAST MODIFIED:   1-Mar-2006 
   29 00000000          ; 
   30 00000000          ;****************************************************************************** 
   31 00000000          ; 
   32 00000000          ; 
   33 00000000          ; Include file for PXA27x Processor based 
   34 00000000          ; Cross Platform Low Level Initialization  (XLLI) 
   35 00000000          ; 
   36 00000000          ;****************************************************************************** 
   37 00000000            
   38 00000000          ;     Bit settings 
   39 00000000          ; 
   40 00000000          xlli_BIT_0      EQU     0x00000001 
   41 00000000          xlli_BIT_1      EQU     0x00000002 
   42 00000000          xlli_BIT_2      EQU     0x00000004 
   43 00000000          xlli_BIT_3      EQU     0x00000008 
   44 00000000          xlli_BIT_4      EQU     0x00000010 
   45 00000000          xlli_BIT_5      EQU     0x00000020 
   46 00000000          xlli_BIT_6      EQU     0x00000040 
   47 00000000          xlli_BIT_7      EQU     0x00000080 
   48 00000000          xlli_BIT_8      EQU     0x00000100 
   49 00000000          xlli_BIT_9      EQU     0x00000200 
   50 00000000          xlli_BIT_10     EQU     0x00000400 
   51 00000000          xlli_BIT_11     EQU     0x00000800 
   52 00000000          xlli_BIT_12     EQU     0x00001000 
   53 00000000          xlli_BIT_13     EQU     0x00002000 
   54 00000000          xlli_BIT_14     EQU     0x00004000 
   55 00000000          xlli_BIT_15     EQU     0x00008000 
   56 00000000          xlli_BIT_16     EQU     0x00010000 
   57 00000000          xlli_BIT_17     EQU     0x00020000 
   58 00000000          xlli_BIT_18     EQU     0x00040000 
   59 00000000          xlli_BIT_19     EQU     0x00080000 
   60 00000000          xlli_BIT_20     EQU     0x00100000 
   61 00000000          xlli_BIT_21     EQU     0x00200000 
   62 00000000          xlli_BIT_22     EQU     0x00400000 
   63 00000000          xlli_BIT_23     EQU     0x00800000 
   64 00000000          xlli_BIT_24     EQU     0x01000000 
   65 00000000          xlli_BIT_25     EQU     0x02000000 
   66 00000000          xlli_BIT_26     EQU     0x04000000 
   67 00000000          xlli_BIT_27     EQU     0x08000000 
   68 00000000          xlli_BIT_28     EQU     0x10000000 
   69 00000000          xlli_BIT_29     EQU     0x20000000 
   70 00000000          xlli_BIT_30     EQU     0x40000000 
   71 00000000          xlli_BIT_31     EQU     0x80000000 
   72 00000000            
   73 00000000          ; 
   74 00000000          ;  Processor stepping Values 
   75 00000000          ; 
   76 00000000          xlli_PXA27x_CP15_A0_Val  EQU (0x69054110) 
   77 00000000          xlli_PXA27x_CP15_A1_Val  EQU (0x69054111) 
   78 00000000          xlli_PXA27x_CP15_B0_Val  EQU (0x69054112) 
   79 00000000          xlli_PXA27x_CP15_B1_Val  EQU (0x69054113) 
   80 00000000          xlli_PXA27x_CP15_C0_Val  EQU (0x69054114) 
   81 00000000          xlli_PXA27x_CP15_C5_Val  EQU (0x69054117) 
   82 00000000            
   83 00000000          xlli_PXA27x_JTAG_A0_Val  EQU (0x09265013) 
   84 00000000          xlli_PXA27x_JTAG_A1_Val  EQU (0x19265013) 
   85 00000000          xlli_PXA27x_JTAG_B0_Val  EQU (0x29265013) 
   86 00000000          xlli_PXA27x_JTAG_B1_Val  EQU (0x39265013) 
   87 00000000          xlli_PXA27x_JTAG_C0_Val  EQU (0x49265013) 
   88 00000000          xlli_PXA27x_JTAG_C5_Val  EQU (0x79265013) 
   89 00000000            
   90 00000000          xlli_PXA27x_A0_stepping  EQU (0x0) 
   91 00000000          xlli_PXA27x_A1_stepping  EQU (0x1) 
   92 00000000          xlli_PXA27x_B0_stepping  EQU (0x2) 
   93 00000000          xlli_PXA27x_B1_stepping  EQU (0x3) 
   94 00000000          xlli_PXA27x_C0_stepping  EQU (0x4) 
   95 00000000          xlli_PXA27x_C5_stepping  EQU (0x7) 
   96 00000000            
   97 00000000            
   98 00000000          ; 
   99 00000000          ; GENERAL PURPOSE I/O (GPIO) base address and register offsets from the base address 
  100 00000000          ; 
  101 00000000            
  102 00000000          xlli_GPIOREGS_PHYSICAL_BASE  EQU    0x40E00000 
  103 00000000            
  104 00000000          ; GPIO register offsets from the base address 
  105 00000000            
  106 00000000          xlli_GPLR0_offset    EQU    (0x000)  ; GPIO Level registers 
  107 00000000          xlli_GPLR1_offset    EQU    (0x004) 
  108 00000000          xlli_GPLR2_offset    EQU    (0x008) 
  109 00000000          xlli_GPLR3_offset    EQU    (0x100) 
  110 00000000            
  111 00000000          xlli_GPDR0_offset    EQU    (0x00C)  ; GPIO Direction registers 
  112 00000000          xlli_GPDR1_offset    EQU    (0x010) 
  113 00000000          xlli_GPDR2_offset    EQU    (0x014) 
  114 00000000          xlli_GPDR3_offset    EQU    (0x10C) 
  115 00000000            
  116 00000000          xlli_GPSR0_offset    EQU    (0x018)  ; GPIO Set registers 
  117 00000000          xlli_GPSR1_offset    EQU    (0x01C) 
  118 00000000          xlli_GPSR2_offset    EQU    (0x020) 
  119 00000000          xlli_GPSR3_offset    EQU    (0x118) 
  120 00000000            
  121 00000000          xlli_GPCR0_offset    EQU    (0x024)  ; GPIO Clear registers 
  122 00000000          xlli_GPCR1_offset    EQU    (0x028) 
  123 00000000          xlli_GPCR2_offset    EQU    (0x02C) 
  124 00000000          xlli_GPCR3_offset    EQU    (0x124) 
  125 00000000            
  126 00000000          xlli_GAFR0_L_offset  EQU    (0x054)  ; GPIO Alternate function registers (Bits 15:0) 
  127 00000000          xlli_GAFR0_U_offset  EQU    (0x058)  ; Bits 31:16 
  128 00000000          xlli_GAFR1_L_offset  EQU    (0x05c)  ; Bits 47:32 
  129 00000000          xlli_GAFR1_U_offset  EQU    (0x060)  ; Bits 63:48 
  130 00000000          xlli_GAFR2_L_offset  EQU    (0x064)  ; Bits 79:64 
  131 00000000          xlli_GAFR2_U_offset  EQU    (0x068)  ; Bits 95:80 
  132 00000000          xlli_GAFR3_L_offset  EQU    (0x06C)  ; Bits 111:96 
  133 00000000          xlli_GAFR3_U_offset  EQU    (0x070)  ; Bits 127:112 
  134 00000000            
  135 00000000          ; 
  136 00000000          ; GPIO register bit masks 
  137 00000000          ; 
  138 00000000          xlli_GPIO_BIT_FFRXD    EQU      (xlli_BIT_2) 
  139 00000000          xlli_GPIO_BIT_FFCTS    EQU      (xlli_BIT_3) 
  140 00000000          xlli_GPIO_BIT_FFDCD    EQU      (xlli_BIT_4) 
  141 00000000          xlli_GPIO_BIT_FFDSR    EQU      (xlli_BIT_5) 
  142 00000000          xlli_GPIO_BIT_FFRI     EQU      (xlli_BIT_6) 
  143 00000000          xlli_GPIO_BIT_FFTXD    EQU      (xlli_BIT_7) 
  144 00000000          xlli_GPIO_BIT_FFDTR    EQU      (xlli_BIT_8) 
  145 00000000          xlli_GPIO_BIT_FFRTS    EQU      (xlli_BIT_9) 
  146 00000000            
  147 00000000          xlli_GPIO_AF_BIT_FFRXD EQU      (xlli_BIT_4) 
  148 00000000          xlli_GPIO_AF_BIT_FFCTS EQU      (xlli_BIT_6) 
  149 00000000          xlli_GPIO_AF_BIT_FFDCD EQU      (xlli_BIT_8) 
  150 00000000          xlli_GPIO_AF_BIT_FFDSR EQU      (xlli_BIT_10) 
  151 00000000          xlli_GPIO_AF_BIT_FFRI  EQU      (xlli_BIT_12) 
  152 00000000          xlli_GPIO_AF_BIT_FFTXD EQU      (xlli_BIT_15) 
  153 00000000          xlli_GPIO_AF_BIT_FFDTR EQU      (xlli_BIT_17) 
  154 00000000          xlli_GPIO_AF_BIT_FFRTS EQU      (xlli_BIT_19) 
  155 00000000            
  156 00000000          ; 
  157 00000000          ; POWER MANAGER base address and register offsets from the base address 
  158 00000000          ; 
  159 00000000            
  160 00000000          xlli_PMRCREGS_PHYSICAL_BASE  EQU    0x40F00000  
  161 00000000            
  162 00000000          xlli_PMCR_offset     EQU    (0x00)      ; Power Manager Control Register 
  163 00000000          xlli_PSSR_offset     EQU    (0x04)      ; Power Manager Sleep Status Register 
  164 00000000          xlli_PSPR_offset     EQU    (0x08)      ; Power Manager Scratch Pad Register 
  165 00000000          xlli_PWER_offset     EQU    (0x0C)      ; Power Manager Wake-up Enable Register 
  166 00000000          xlli_PRER_offset     EQU    (0x10)      ; Power Manager GPIO Rising-edge Detect Enable Register 
  167 00000000          xlli_PFER_offset     EQU    (0x14)      ; Power Manager GPIO Falling-edge Detect Enable Register 
  168 00000000          xlli_PEDR_offset     EQU    (0x18)      ; Power Manager GPIO Edge Detect Status Register 
  169 00000000          xlli_PCFR_offset     EQU    (0x1C)      ; Power Manager General Configuration Register 
  170 00000000          xlli_PGSR0_offset    EQU    (0x20)      ; Power Manager GPIO Sleep State Register for GP [31-0] 
  171 00000000          xlli_PGSR1_offset    EQU    (0x24)      ; Power Manager GPIO Sleep State Register for GP [63-32] 
  172 00000000          xlli_PGSR2_offset    EQU    (0x28)      ; Power Manager GPIO Sleep State Register for GP [95-64] 
  173 00000000          xlli_PGSR3_offset    EQU    (0x2C)      ; Power Manager GPIO Sleep State Register for GP [120-96] 
  174 00000000          xlli_RCSR_offset     EQU    (0x30)      ; Reset Controller Status Register 
  175 00000000          xlli_PSLR_offset     EQU    (0x34)      ; Power Manager Sleep Mode Config Register 
  176 00000000          xlli_PSTR_offset     EQU    (0x38)      ; Power Manager Standby Mode Config Register 
  177 00000000          xlli_PSNR_offset     EQU    (0x3C)      ; Power Manager Sense Moce Config Register 
  178 00000000          xlli_PVCR_offset     EQU    (0x40)      ; Power Manager Voltage Change Control Register 
  179 00000000          xlli_PKWR_offset     EQU    (0x50)      ; Power Manager Keyboard Wake-up Enable Register 
  180 00000000          xlli_PKSR_offset     EQU    (0x54)      ; Power Manager Keyboard Edge-Detect Status Register 
  181 00000000          xlli_PI2DBR_offset   EQU   (0x188)      ; Power I2C Data Buffer Register 
  182 00000000          xlli_PI2CR_offset    EQU   (0x190)      ; Power I2C Control Register 
  183 00000000          xlli_PI2SR_offset    EQU   (0x198)      ; Power I2C Status Register 
  184 00000000          xlli_PI2SAR_offset   EQU   (0x1A0)      ; Power I2C Slave Address Register 
  185 00000000            
  186 00000000          ; 
  187 00000000          ; POWER MANAGER register bit masks  
  188 00000000          ; 
  189 00000000          xlli_PSSR_SSS           EQU    (0x01)   ; Software Sleep Status 
  190 00000000          xlli_PSSR_BFS           EQU    (0x02)   ; Battery Fault Status 
  191 00000000          xlli_PSSR_VFS           EQU    (0x04)   ; VCC Fault Status 
  192 00000000          xlli_PSSR_PH            EQU    (0x10)   ; Peripheral Control Hold 
  193 00000000          xlli_PSSR_RDH           EQU    (0x20)   ; Read Disable Hold 
  194 00000000            
  195 00000000          xlli_PCFR_OPDE          EQU    (0x01)   ; Processor (13MHz) osc power-down enable 
  196 00000000          xlli_PCFR_FP            EQU    (0x02)   ; Float PCMCIA during sleep modes 
  197 00000000          xlli_PCFR_FS            EQU    (0x04)   ; Float Static Chip Selects 
  198 00000000          xlli_PCFR_GPR_EN        EQU    (0x10)   ; GPIO 1 performs GPIO reset 
  199 00000000          xlli_PCFR_SYSEN_EN      EQU    (0x20)   ; SYS_EN pin 
  200 00000000          xlli_PCFR_PI2C_EN       EQU    (0x40)   ; 
  201 00000000          xlli_PCFR_DC_EN         EQU    (0x80)      ; Deep-Sleep Mode 
  202 00000000          xlli_PCFR_FVC           EQU    (0x400)  ; 
  203 00000000          xlli_PCFR_L1_EN         EQU    (0x800)  ; 
  204 00000000          xlli_PCFR_GPROD         EQU    (0x1000) ; 
  205 00000000          xlli_PCFR_PO            EQU    (0x4000) ; 
  206 00000000          xlli_PCFR_RO            EQU    (0x8000) ; 
  207 00000000          xlli_PCFR_USEDBITS      EQU     (xlli_PCFR_OPDE :OR: xlli_PCFR_FP :OR: xlli_PCFR_FS :OR: xlli_PCFR_GPR_EN :OR:                 
                                         xlli_PCFR_SYSEN_EN :OR: xlli_PCFR_PI2C_EN :OR: xlli_PCFR_DC_EN :OR: xlli_PCFR_FVC :OR:                        
                                  xlli_PCFR_L1_EN :OR: xlli_PCFR_GPROD :OR: xlli_PCFR_PO :OR: xlli_PCFR_RO) 
  210 00000000            
  211 00000000          xlli_PSLR_SL_PI_OFF     EQU   (0x00000000)      ; PI power domain is powered off in sleep and deep sleep mode 
  212 00000000          xlli_PSLR_SL_PI_RETAIN  EQU   (0x00000004)      ; PI power domain retains state in sleep and deep sleep mode 
  213 00000000          xlli_PSLR_SL_PI_RUN     EQU   (0x00000008)      ; PI power domain is active with clocks running in sleep mode (DO NOT set for  
                        deep-sleep mode) 
  214 00000000          xlli_PSLR_SL_PI_RSVD    EQU   (0x0000000C)      ; PI power domain reserved bits 
  215 00000000          xlli_PSLR_SL_R0         EQU   (0x00000100)      ; SRAM Bank 0 retains state in sleep mode 
  216 00000000          xlli_PSLR_SL_R1         EQU   (0x00000200)      ; SRAM Bank 1 retains state in sleep mode 
  217 00000000          xlli_PSLR_SL_R2         EQU   (0x00000400)      ; SRAM Bank 2 retains state in sleep mode 
  218 00000000          xlli_PSLR_SL_R3         EQU   (0x00000800)      ; SRAM Bank 3 retains state in sleep mode 
  219 00000000          xlli_PSLR_SL_ROD        EQU   (0x00100000)      ; 1 = nRESET_OUT is not asserted upon entry into sleep or deep-sleep mode 
  220 00000000          xlli_PSLR_IVF           EQU   (0x00400000)      ; 1 = No action taken when nVV_FAULT occurs in sleep mode 
  221 00000000          xlli_PSLR_PSSD          EQU   (0x00800000)      ; 1 = shorten the wake-up delay if all corresponding power supplies are detect 
                        ed to have powered on 
  222 00000000          xlli_PSLR_PWR_DEL_MAX   EQU   (0x0f000000)      ; max power supply PWR_EN ramp delay 
  223 00000000          xlli_PSLR_SYS_DEL_MAX   EQU   (0xf0000000)      ; max system power supply SYS_EN ramp delay 
  224 00000000          xlli_PSLR_USEDBITS      EQU   (xlli_PSLR_SL_PI_RSVD :OR: xlli_PSLR_SL_R0 :OR:                                 xlli_PSLR_SL_R1  
                        :OR: xlli_PSLR_SL_R2 :OR:                                 xlli_PSLR_SL_R3 :OR: xlli_PSLR_SL_ROD :OR:                           
                               xlli_PSLR_IVF :OR: xlli_PSLR_PSSD :OR:                                 xlli_PSLR_PWR_DEL_MAX :OR: xlli_PSLR_SYS_DEL_MAX 
                        ) 
  229 00000000                                           
  230 00000000          xlli_PWER_WE0     EQU    (0x01)      ; Wake-up Enable GPIO pin 0 
  231 00000000          xlli_PWER_WE1     EQU    (0x02)      ; Wake-up Enable GPIO pin 1 
  232 00000000          xlli_PWER_WERTC   EQU    (0x80000000); RTC Standby, Wake-up Enable- 
  233 00000000            
  234 00000000          ; 
  235 00000000          ; MEMORY CONTROLLER base address and register offsets from the base address  
  236 00000000          ; 
  237 00000000            
  238 00000000          xlli_MEMORY_CONFIG_BASE       EQU   0x48000000 
  239 00000000            
  240 00000000          xlli_MDCNFG_offset    EQU     (0x00) 
  241 00000000          xlli_MDREFR_offset    EQU     (0x04) 
  242 00000000          xlli_MSC0_offset      EQU     (0x08) 
  243 00000000          xlli_MSC1_offset      EQU     (0x0C) 
  244 00000000          xlli_MSC2_offset      EQU     (0x10) 
  245 00000000          xlli_MECR_offset      EQU     (0x14) 
  246 00000000          xlli_SXLCR_offset     EQU     (0x18) 
  247 00000000          xlli_SXCNFG_offset    EQU     (0x1C) 
  248 00000000          xlli_FLYCNFG_offset   EQU     (0x20) 
  249 00000000          xlli_SXMRS_offset     EQU     (0x24)                                        
  250 00000000          xlli_MCMEM0_offset    EQU     (0x28) 
  251 00000000          xlli_MCMEM1_offset    EQU     (0x2C) 
  252 00000000          xlli_MCATT0_offset    EQU     (0x30) 
  253 00000000          xlli_MCATT1_offset    EQU     (0x34) 
  254 00000000          xlli_MCIO0_offset     EQU     (0x38) 
  255 00000000          xlli_MCIO1_offset     EQU     (0x3C) 
  256 00000000          xlli_MDMRS_offset     EQU     (0x40) 
  257 00000000          xlli_BOOT_DEF_offset  EQU     (0x44) 
  258 00000000          xlli_ARB_CNTL_offset  EQU     (0x48) 
  259 00000000          xlli_BSCNTR0_offset   EQU     (0x4C) 
  260 00000000          xlli_BSCNTR1_offset   EQU     (0x50) 
  261 00000000          xlli_LCDBSCNTR_offset EQU     (0x54) 
  262 00000000          xlli_MDMRSLP_offset   EQU     (0x58) 
  263 00000000          xlli_BSCNTR2_offset   EQU     (0x5C) 
  264 00000000          xlli_BSCNTR3_offset   EQU     (0x60) 
  265 00000000            
  266 00000000          ; Memory Controller bit defs 
  267 00000000            
  268 00000000          xlli_MDREFR_K0DB4     EQU     (0x20000000)    ; Sync Static Clock 0 divide by 4 control/status 
  269 00000000          xlli_MDREFR_K2FREE    EQU     (0x02000000)    ; Set to force SDCLK[2] to be free running 
  270 00000000          xlli_MDREFR_K1FREE    EQU     (0x01000000)    ; Set to force SDCLK[1] to be free running 
  271 00000000          xlli_MDREFR_K0FREE    EQU     (0x00800000)    ; Set to force SDCLK[0] to be free running 
  272 00000000          xlli_MDREFR_SLFRSH    EQU     (0x00400000)    ; Self Refresh Control Status bit 
  273 00000000          xlli_MDREFR_APD       EQU     (0x00100000)    ; Auto Power Down bit 
  274 00000000          xlli_MDREFR_K2DB2     EQU     (0x00080000)    ; SDRAM clock pin 2 divide by 2 control/status 
  275 00000000          xlli_MDREFR_K2RUN     EQU     (0x00040000)    ; SDRAM clock pin 2 run/control status 
  276 00000000          xlli_MDREFR_K1DB2     EQU     (0x00020000)    ; SDRAM clock pin 1 divide by 2 control/status 
  277 00000000          xlli_MDREFR_K1RUN     EQU     (0x00010000)    ; SDRAM clock pin 1 run/control status 
  278 00000000          xlli_MDREFR_E1PIN     EQU     (0x00008000)    ; SDRAM clock Enable pin 1 level control/status 
  279 00000000          xlli_MDREFR_K0DB2     EQU     (0x00004000)    ; Sync Static Memory Clock divide by 2 control/status 
  280 00000000          xlli_MDREFR_K0RUN     EQU     (0x00002000)    ; Sync Static Memory Clock Pin 0 
  281 00000000          xlli_MDREFR_E0PIN     EQU     (0x00000100)    ; SDRAM clock enable pin 0 (Cotulla ONLY!!) 
  282 00000000            
  283 00000000          xlli_MDCNFG_DE0       EQU     (0x00000001)    ; SDRAM enable bit for partition 0 
  284 00000000          xlli_MDCNFG_DE1       EQU     (0x00000002)    ; SDRAM enable bit for partition 1 
  285 00000000          xlli_MDCNFG_DE2       EQU     (0x00010000)    ; SDRAM enable bit for partition 2 
  286 00000000          xlli_MDCNFG_DE3       EQU     (0x00020000)    ; SDRAM enable bit for partition 3 
  287 00000000          xlli_MDCNFG_DWID0     EQU     (0x00000004)    ; SDRAM bus width (clear = 32 bits, set = 16 bits) 
  288 00000000          xlli_MDCNFG_DWID2     EQU     (0x00040000)    ; SDRAM bus width (clear = 32 bits, set = 16 bits) 
  289 00000000          xlli_MDCNFG_DCAC0     EQU     (0x00000008) 
  290 00000000          xlli_MDCNFG_DCAC2     EQU     (0x00080000) 
  291 00000000            
  292 00000000          ; 
  293 00000000          ; INTERNAL MEMORY CONTROLLER base address and register offsets from the base address  
  294 00000000          ; 
  295 00000000            
  296 00000000          xlli_IMEMORY_CONFIG_BASE      EQU   (0x58000000) 
  297 00000000            
  298 00000000          xlli_IMPMCR_offset   EQU     (0x00)       ; Internal Memory Power Manager Control Register 
  299 00000000          xlli_IMPMSR_offset   EQU     (0x08)       ; Internal Memory Power Management Status Register 
  300 00000000            
  301 00000000            
  302 00000000          ; 
  303 00000000          ; UART Definitions 
  304 00000000          ; 
  305 00000000          xlli_perif_base                 EQU     (0x40000000)    ; Base address of the peripherals 
  306 00000000          xlli_ffuart_offset              EQU     (0x00100000)    ; Offset to the Full-Feature UART in the peripheral block 
  307 00000000          xlli_btuart_offset              EQU     (0x00200000)    ; Offset to the BlueTooth UART in the peripheral block 
  308 00000000          xlli_stuart_offset              EQU     (0x00700000)    ; Offset to the Standard UART in the peripheral block 
  309 00000000            
  310 00000000            
  311 00000000          xlli_uart_thr_offset            EQU     (0x0)       ;DLAB = 0  WO  8bit - Transmit Holding Register 
  312 00000000          xlli_uart_rbr_offset            EQU     (0x0)       ;DLAB = 0  RO  8bit - Recieve Buffer Register 
  313 00000000          xlli_uart_dll_offset            EQU     (0x0)       ;DLAB = 1  RW  8bit - Divisor Latch Low Register 
  314 00000000          xlli_uart_ier_offset            EQU     (0x4)       ;DLAB = 0  RW  8bit - Interrupt Enable Register 
  315 00000000          xlli_uart_dlh_offset            EQU     (0x4)       ;DLAB = 1  RW  8bit - Divisor Latch High Register 
  316 00000000          xlli_uart_iir_offset            EQU     (0x8)       ;DLAB = X  RO  8bit - Interrupt Identification Register 
  317 00000000          xlli_uart_fcr_offset            EQU     (0x8)       ;DLAB = X  WO  8bit - FIFO Control Register 
  318 00000000          xlli_uart_lcr_offset            EQU     (0xC)       ;DLAB = X  RW  8bit - Line Control Register 
  319 00000000          xlli_uart_mcr_offset            EQU     (0x10)      ;DLAB = X  RW  8bit - Modem Control Regiser 
  320 00000000          xlli_uart_lsr_offset            EQU     (0x14)      ;DLAB = X  RO  8bit - Line Status Register 
  321 00000000          xlli_uart_msr_offset            EQU     (0x18)      ;DLAB = X  RO  8bit - Modem Status Register 
  322 00000000          xlli_uart_spr_offset            EQU     (0x1C)      ;DLAB = X  RW  8bit - Scratchpad Register 
  323 00000000          xlli_uart_isr_offset            EQU     (0x20)      ;DLAB = X  RW  8bit - Slow Infrared Select Register 
  324 00000000          xlli_uart_for_offset            EQU     (0x24)      ;DLAB = X  RO  FIFO Occupancy Register 
  325 00000000          xlli_uart_abr_offset            EQU     (0x28)      ;DLAB = X  RW  Autobaud Control Register 
  326 00000000          xlli_uart_acr_offset            EQU     (0x2C)      ;DLAB = X Autobaud Count Register 
  327 00000000            
  328 00000000          ; 
  329 00000000          ; INTERRUPT CONTROLLER base address and register offsets from the base address 
  330 00000000          ;  
  331 00000000          ; 
  332 00000000            
  333 00000000          xlli_INTERREGS_PHYSICAL_BASE      EQU     (0x40D00000) 
  334 00000000            
  335 00000000          xlli_ICIP_offset      EQU     (0x00)   ; Interrupt Controller IRQ Pending Register 
  336 00000000          xlli_ICMR_offset      EQU     (0x04)   ; Interrupt Controller Mask Register 
  337 00000000          xlli_ICLR_offset      EQU     (0x08)   ; Interrupt Controller Level Register 
  338 00000000          xlli_ICFP_offset      EQU     (0x0C)   ; Interrupt Controller FIQ pending Register 
  339 00000000          xlli_ICPR_offset      EQU     (0x10)   ; Interrupt Controller Pending Register 
  340 00000000          xlli_ICCR_offset      EQU     (0x14)   ; Interrupt Controller Control Register 
  341 00000000          xlli_ICHP_offset      EQU     (0x18)   ; Interrupt Controller Highest Priority Reg 
  342 00000000          xlli_ICMR2_offset     EQU     (0xA0)   ; Interrupt Controller Mask Register 2 
  343 00000000          xlli_ICLR2_offset     EQU     (0xA4)   ; Interrupt Controller Level Register 2 
  344 00000000          xlli_ICCR2_offset     EQU     (0xAC)   ; Interrupt Controller Control Register 2 
  345 00000000            
  346 00000000          ; 
  347 00000000          ; SSP SERIAL PORTS base address and register offsets from the base address 
  348 00000000          ;  
  349 00000000            
  350 00000000          xlli_SSP_PHYSICAL_BASE EQU    (0x40100000) 
  351 00000000            
  352 00000000          xlli_SSCR0_1_offset    EQU    (0x00)   ; SSP 1 Control Regsiter 0 
  353 00000000          xlli_SSCR1_1_offset    EQU    (0x04)   ; SSP 1 Control Register 1 
  354 00000000          xlli_SSSR_1_offset     EQU    (0x08)   ; SSP 1 Status Register 
  355 00000000          xlli_SSITR_1_offset    EQU    (0x0C)   ; SSP 1 Interrupt Test Register 
  356 00000000          xlli_SSDR_1_offset     EQU    (0x10)   ; SSP 1 Data Write Register/Data Read Register 
  357 00000000            
  358 00000000          ; 
  359 00000000          ; CLOCK REGISTERS base address and register offsets from the base address 
  360 00000000          ;  
  361 00000000            
  362 00000000          xlli_CLKREGS_PHYSICAL_BASE        EQU     (0x41300000) 
  363 00000000            
  364 00000000          xlli_CCCR_offset     EQU     (0x00)    ; Core Clock Configuration Register 
  365 00000000          xlli_CKEN_offset     EQU     (0x04)    ; Clock-Enable Register 
  366 00000000          xlli_OSCC_offset     EQU     (0x08)    ; Oscillator Configuration Register 
  367 00000000          xlli_CCSR_offset     EQU     (0x0C)    ; Core Clock Status Register 
  368 00000000            
  369 00000000          xlli_CCCR_A_Bit_Mask EQU     (0x1 << 25)  ; "A" bit is bit 25 in CCCR 
  370 00000000          ; 
  371 00000000          ; OS TIMER REGISTERS base address and register offsets from the base address 
  372 00000000          ;  
  373 00000000            
  374 00000000          xlli_OSTREGS_PHYSICAL_BASE        EQU     (0x40A00000) 
  375 00000000            
  376 00000000          xlli_OSMR0_offset    EQU     (0x00)    ; OS Timer Match Register 0 
  377 00000000          xlli_OSMR1_offset    EQU     (0x04)    ; OS Timer Match Register 1 
  378 00000000          xlli_OSMR2_offset    EQU     (0x08)    ; OS Timer Match Register 2 
  379 00000000          xlli_OSMR3_offset    EQU     (0x0C)    ; OS Timer Match Register 3 
  380 00000000            
  381 00000000          xlli_OSCR0_offset    EQU     (0x10)    ; OS Timer Count Register 0 
  382 00000000          xlli_OSSR_offset     EQU     (0x14)    ; OS Timer Status Register 
  383 00000000          xlli_OWER_offset     EQU     (0x18)    ; OS Timer Watchdog Enable Register 
  384 00000000          xlli_OIER_offset     EQU     (0x1C)    ; OS Timer Interrupt Enable Register 
  385 00000000            
  386 00000000          xlli_OSCR4_offset    EQU     (0x40)    ; OS Timer Count Register 4 
  387 00000000          xlli_OSCR5_offset    EQU     (0x44)    ; OS Timer Count Register 5 
  388 00000000          xlli_OSCR6_offset    EQU     (0x48)    ; OS Timer Count Register 6 
  389 00000000          xlli_OSCR7_offset    EQU     (0x4C)    ; OS Timer Count Register 7 
  390 00000000          xlli_OSCR8_offset    EQU     (0x50)    ; OS Timer Count Register 8 
  391 00000000          xlli_OSCR9_offset    EQU     (0x54)    ; OS Timer Count Register 9 
  392 00000000          xlli_OSCR10_offset   EQU     (0x58)    ; OS Timer Count Register 10 
  393 00000000          xlli_OSCR11_offset   EQU     (0x5C)    ; OS Timer Count Register 11 
  394 00000000            
  395 00000000          xlli_OSMR4_offset    EQU     (0x80)    ; OS Timer Match Register 4 
  396 00000000          xlli_OSMR5_offset    EQU     (0x84)    ; OS Timer Match Register 5 
  397 00000000          xlli_OSMR6_offset    EQU     (0x88)    ; OS Timer Match Register 6 
  398 00000000          xlli_OSMR7_offset    EQU     (0x8C)    ; OS Timer Match Register 7 
  399 00000000          xlli_OSMR8_offset    EQU     (0x90)    ; OS Timer Match Register 8 
  400 00000000          xlli_OSMR9_offset    EQU     (0x94)    ; OS Timer Match Register 9 
  401 00000000          xlli_OSMR10_offset   EQU     (0x98)    ; OS Timer Match Register 10 
  402 00000000          xlli_OSMR11_offset   EQU     (0x9C)    ; OS Timer Match Register 11 
  403 00000000            
  404 00000000          xlli_OMCR4_offset    EQU     (0xC0)    ; OS Timer Match Control Register 4 
  405 00000000          xlli_OMCR5_offset    EQU     (0xC4)    ; OS Timer Match Control Register 5 
  406 00000000          xlli_OMCR6_offset    EQU     (0xC8)    ; OS Timer Match Control Register 6 
  407 00000000          xlli_OMCR7_offset    EQU     (0xCC)    ; OS Timer Match Control Register 7 
  408 00000000          xlli_OMCR8_offset    EQU     (0xD0)    ; OS Timer Match Control Register 8 
  409 00000000          xlli_OMCR9_offset    EQU     (0xD4)    ; OS Timer Match Control Register 9 
  410 00000000          xlli_OMCR10_offset   EQU     (0xD8)    ; OS Timer Match Control Register 10 
  411 00000000          xlli_OMCR11_offset   EQU     (0xDC)    ; OS Timer Match Control Register 11 
  412 00000000            
  413 00000000          xlli_OSSR_ALL        EQU     (0xFFF)   ; Match register status "sticky bits" 
  414 00000000          xlli_OIER_E1         EQU     (0x002)   ; Interrupt enable bit for match register #1 
  415 00000000            
  416 00000000          ; 
  417 00000000          ; REAL TIME CLOCK (RTC) REGISTERS base address and register offsets from the base address 
  418 00000000          ;  
  419 00000000            
  420 00000000          xlli_RTCREGS_PHYSICAL_BASE   EQU       (0x40900000) 
  421 00000000            
  422 00000000          xlli_RCNR_offset     EQU     (0x00)    ; RTC Counter Register 
  423 00000000          xlli_RTAR_offset     EQU     (0x04)    ; RTC Alarm Register 
  424 00000000          xlli_RTSR_offset     EQU     (0x08)    ; RTC Status Register 
  425 00000000          xlli_RTTR_offset     EQU     (0x0C)    ; RTC Timer Trim Register 
  426 00000000          xlli_RDCR_offset     EQU     (0x10)    ; RTC Day Counter Register 
  427 00000000          xlli_RYCR_offset     EQU     (0x14)    ; RTC Year Counter Register  
  428 00000000          xlli_RDAR1_offset    EQU     (0x18)    ; RTC Day Alarm Register 1 
  429 00000000          xlli_RYAR1_offset    EQU     (0x1C)    ; RTC Year Alarm Register 2 
  430 00000000          xlli_RDAR2_offset    EQU     (0x20)    ; RTC Day Alarm Register 2 
  431 00000000          xlli_RYAR2_offset    EQU     (0x24)    ; RTC Year Alarm Register 2 
  432 00000000          xlli_SWCR_offset     EQU     (0x28)    ; Stopwatch Counter Register 
  433 00000000          xlli_SWAR1_offset    EQU     (0x2C)    ; Stopwatch Alarm Register 1 
  434 00000000          xlli_SWAR2_offset    EQU     (0x30)    ; Stopwatch Alarm Register 2 
  435 00000000          xlli_PICR_offset     EQU     (0x34)    ; Periodic Interrupt Counter Register 
  436 00000000          xlli_PIAR_offset     EQU     (0x38)    ; Periodic Interrupt Alarm Register 
  437 00000000            
  438 00000000            
  439 00000000          ; Oscillator Controller bit defs 
  440 00000000            
  441 00000000          xlli_OSCC_OOK        EQU     (0x01)    ; Oscillator OK bit 
  442 00000000          xlli_OSCC_OON        EQU     (0x02)    ; Timekeeping (32.768KHz) Osc bit 
  443 00000000          xlli_OSCC_TOUT_EN    EQU     (0x04)    ; Timekeeping Output enable 
  444 00000000          xlli_OSCC_PIO_EN     EQU     (0x08)    ; Processor Oscillator Output Enable 
  445 00000000          xlli_OSCC_CRI        EQU     (0x10)    ; Processor Oscillator Output Enable 
  446 00000000            
  447 00000000          ; 
  448 00000000          ; Coprocessor 15 data bits 
  449 00000000          ;  
  450 00000000            
  451 00000000          xlli_control_icache  EQU     (0x1000)  ; bit 12 -  i-cache bit 
  452 00000000          xlli_control_btb     EQU     (0x0800)  ; bit 11 -  btb bit 
  453 00000000          xlli_control_r       EQU     (0x0200)  ; Bit 9 
  454 00000000          xlli_control_s       EQU     (0x0100)  ; Bit 8 
  455 00000000          xlli_control_dcache  EQU     (0x0004)  ; Bit 2  -  d-cache bit 
  456 00000000          xlli_control_mmu     EQU     (0x0001)  ; Bit 0  -  MMU bit 
  457 00000000            
  458 00000000            
  459 00000000          ; 
  460 00000000          ; CP 15 related settings 
  461 00000000          ; 
  462 00000000            
  463 00000000          xlli_PID                   EQU     (0x00) 
  464 00000000          xlli_DACR                  EQU     (0x01) 
  465 00000000          xlli_CONTROL_DCACHE        EQU     (0x04) 
  466 00000000          xlli_CONTROL_MINIDATA_01   EQU     (0x10) 
  467 00000000          xlli_CONTROL_BTB           EQU     (0x800)   ; Brach Target Buffer bit 
  468 00000000            
  469 00000000          ; 
  470 00000000          ; register bit masks - RCSR 
  471 00000000          ; 
  472 00000000          xlli_RCSR_HWR         EQU     (0x01) 
  473 00000000          xlli_RCSR_WDR         EQU     (0x02) 
  474 00000000          xlli_RCSR_SMR         EQU     (0x04) 
  475 00000000          xlli_RCSR_GPR         EQU     (0x08) 
  476 00000000          xlli_RCSR_ALL         EQU     (0xF) 
  477 00000000            
  478 00000000            
  479 00000000          ; 
  480 00000000          ;  CPSR Processor constants 
  481 00000000            
  482 00000000          xlli_CPSR_Mode_MASK   EQU       (0x0000001F) 
  483 00000000          xlli_CPSR_Mode_USR    EQU       (0x10) 
  484 00000000          xlli_CPSR_Mode_FIQ    EQU       (0x11) 
  485 00000000          xlli_CPSR_Mode_IRQ    EQU       (0x12) 
  486 00000000          xlli_CPSR_Mode_SVC    EQU       (0x13) 
  487 00000000          xlli_CPSR_Mode_ABT    EQU       (0x17) 
  488 00000000          xlli_CPSR_Mode_UND    EQU       (0x1B) 
  489 00000000          xlli_CPSR_Mode_SYS    EQU       (0x1F) 
  490 00000000            
  491 00000000          xlli_CPSR_I_Bit       EQU       (0x80) 
  492 00000000          xlli_CPSR_F_Bit       EQU       (0x40) 
  493 00000000            
  494 00000000            
  495 00000000          xlli_PWRMODE_SLEEP    EQU       (0x00000003) ; Value for cp14: Reg7 to induce sleep. 
  496 00000000            
  497 00000000                END 
   51 00000000                  INCLUDE  xlli_Mainstone_defs.inc                ; Mainstone specific include file 
    1 00000000          ; 
    2 00000000          ; Copyright (c) Microsoft Corporation.  All rights reserved. 
    3 00000000          ; 
    4 00000000          ; 
    5 00000000          ; Use of this sample source code is subject to the terms of the Microsoft 
    6 00000000          ; license agreement under which you licensed this sample source code. If 
    7 00000000          ; you did not accept the terms of the license agreement, you are not 
    8 00000000          ; authorized to use this sample source code. For the terms of the license, 
    9 00000000          ; please see the license agreement between you and Microsoft or, if applicable, 
   10 00000000          ; see the LICENSE.RTF on your install media or the root of your tools installation. 
   11 00000000          ; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES. 
   12 00000000          ; 
   13 00000000          ;********************************************************************************* 
   14 00000000          ; 
   15 00000000          ;        COPYRIGHT (c) 2002 - 2004 Intel Corporation 
   16 00000000          ; 
   17 00000000          ;   The information in this file is furnished for informational use only, 
   18 00000000          ;   is subject to change without notice, and should not be construed as 
   19 00000000          ;   a commitment by Intel Corporation. Intel Corporation assumes no 
   20 00000000          ;   responsibility or liability for any errors or inaccuracies that may appear 
   21 00000000          ;   in this document or any software that may be provided in association with 
   22 00000000          ;   this document. 
   23 00000000          ; 
   24 00000000          ;********************************************************************************* 
   25 00000000          ; 
   26 00000000          ;  FILENAME:       xlli_Mainstone_defs.inc (Platform specific addresses and 
   27 00000000          ;                  defalut values for Mainstone platform bring up) 
   28 00000000          ;                  NOTE: - This file has a def to configure xlli for MCP and non-MCP processors 
   29 00000000          ; 
   30 00000000          ; LAST MODIFIED:   13-Feb-2004 
   31 00000000          ; 
   32 00000000          ;****************************************************************************** 
   33 00000000          ; 
   34 00000000          ; 
   35 00000000          ; Include file for Mainstone specific Cross Platform Low Level Initialization (XLLI) 
   36 00000000          ; 
   37 00000000          ; 
   38 00000000          ; PLATFORM REGISTERS base address and register offsets from the base address 
   39 00000000          ; 
   40 00000000          xlli_PLATFORM_REGISTERS              EQU    0x08000000 
   41 00000000            
   42 00000000          xlli_PLATFORM_HEXLED_DATA_offset     EQU    (0x10)   ; Hex LED Data Register 
   43 00000000          xlli_PLATFORM_LED_CONTROL_offset     EQU    (0x40)   ; LED Control Register 
   44 00000000          xlli_PLATFORM_SWITCH_offset          EQU    (0x60)   ; General Purpose Switch Register 
   45 00000000          xlli_PLATFORM_MISC_WRITE1_offset     EQU    (0x80)   ; Misc Write Register 1 
   46 00000000          xlli_PLATFORM_MISC_WRITE2_offset     EQU    (0x84)   ; Misc Write Register 2 
   47 00000000          xlli_PLATFORM_MISC_READ1_offset      EQU    (0x90)   ; Misc Read Register 1 
   48 00000000          xlli_PLATFORM_INTERR_ME_offset       EQU    (0xC0)   ; Platform Interrupt Mask/Enable Register 1 
   49 00000000          xlli_PLATFORM_INTERR_SC_offset       EQU    (0xD0)   ; Platform Interrupt Set/Clear Register 1 
   50 00000000          xlli_PLATFORM_PCMCIA0_SC_offset      EQU    (0xE0)   ; PCMCIA Socket 0 Status/Control Register 
   51 00000000          xlli_PLATFORM_PCMCIA1_SC_offset      EQU    (0xE4)   ; PCMCIA Socket 1 Status/Control Register 
   52 00000000            
   53 00000000          ; 
   54 00000000          ; Platform specific bits 
   55 00000000          ; 
   56 00000000          xlli_SYS_RESET                       EQU    (0x01)   ; System reset bit 
   57 00000000            
   58 00000000          ; 
   59 00000000          ; platform GPIO pin settings (Bulverde/Mainstone) 
   60 00000000          ; 
   61 00000000          xlli_GPSR0_value          EQU   (0x00008004)   ; Set registers 
   62 00000000          xlli_GPSR1_value          EQU   (0x00020080) 
   63 00000000          xlli_GPSR2_value          EQU   (0x16C14000) 
   64 00000000          xlli_GPSR3_value          EQU   (0x0003E000) 
   65 00000000            
   66 00000000          xlli_GPCR0_value          EQU   (0x0)          ; Clear registers 
   67 00000000          xlli_GPCR1_value          EQU   (0x00000380)   ; FFUART related 
   68 00000000          xlli_GPCR2_value          EQU   (0x0) 
   69 00000000          xlli_GPCR3_value          EQU   (0x0) 
   70 00000000            
   71 00000000          xlli_GRER0_value          EQU   (0x0)          ; Rising Edge Detect 
   72 00000000          xlli_GRER1_value          EQU   (0x0) 
   73 00000000          xlli_GRER2_value          EQU   (0x0) 
   74 00000000          xlli_GRER3_value          EQU   (0x0) 
   75 00000000            
   76 00000000          xlli_GFER0_value          EQU   (0x0)          ; Falling Edge Detect 
   77 00000000          xlli_GFER1_value          EQU   (0x0) 
   78 00000000          xlli_GFER2_value          EQU   (0x0) 
   79 00000000          xlli_GFER3_value          EQU   (0x0) 
   80 00000000            
   81 00000000          xlli_GPLR0_value          EQU   (0x0)          ; Pin Level Registers 
   82 00000000          xlli_GPLR1_value          EQU   (0x0) 
   83 00000000          xlli_GPLR2_value          EQU   (0x0) 
   84 00000000          xlli_GPLR3_value          EQU   (0x0) 
   85 00000000            
   86 00000000          xlli_GEDR0_value          EQU   (0x0)          ; Edge Detect Status 
   87 00000000          xlli_GEDR1_value          EQU   (0x0) 
   88 00000000          xlli_GEDR2_value          EQU   (0x0) 
   89 00000000          xlli_GEDR3_value          EQU   (0x0) 
   90 00000000            
   91 00000000          xlli_GPDR0_value          EQU   (0xCFE3BDE4)   ; Direction Registers 
   92 00000000          xlli_GPDR1_value          EQU   (0x003FAB81) 
   93 00000000          xlli_GPDR2_value          EQU   (0x1EC3FC00) 
   94 00000000          xlli_GPDR3_value          EQU   (0x018FFE8F) 
   95 00000000            
   96 00000000          xlli_GAFR0_L_value EQU  (0x84400000)   ; Alternate function registers 
   97 00000000          xlli_GAFR0_U_value EQU  (0xA5000510) 
   98 00000000          xlli_GAFR1_L_value EQU  (0x000A9558) 
   99 00000000          xlli_GAFR1_U_value EQU  (0x0005A1AA) 
  100 00000000          xlli_GAFR2_L_value EQU  (0x60000000) 
  101 00000000          xlli_GAFR2_U_value EQU  (0x00000802) 
  102 00000000          xlli_GAFR3_L_value EQU  (0x00000000) 
  103 00000000          xlli_GAFR3_U_value EQU  (0x00000000) 
  104 00000000            
  105 00000000          ; 
  106 00000000          ; MEMORY CONTROLLER SETTINGS FOR MAINSTONE 
  107 00000000          ; 
  108 00000000            
  109 00000000          xlli_MDREFR_value  EQU   (0x0000001E) 
  110 00000000                  IF  :DEF:  xlli_FLASH_WIDTH_16_BIT 
  112 00000000                  ELSE 
  113 00000000          xlli_MSC0_DC_value EQU   (0x7FF0B8F2)     ; Bulverde Card Flash value (Non-MCP version) 
  114 00000000                  ENDIF 
  115 00000000          xlli_MSC0_MS_value EQU   (0x23F2B8F2)     ; Mainstone Board Flash value 
  116 00000000          xlli_MSC1_value    EQU   (0x0000CCD1) 
  117 00000000          xlli_MSC2_value    EQU   (0x0000B884) 
  118 00000000          xlli_MECR_value    EQU   (0x00000001) 
  119 00000000          xlli_MCMEM0_value  EQU   (0x00014307) 
  120 00000000          xlli_MCMEM1_value  EQU   (0x00014307) 
  121 00000000          xlli_MCATT0_value  EQU   (0x0001C787) 
  122 00000000          xlli_MCATT1_value  EQU   (0x0001C787) 
  123 00000000          xlli_MCIO0_value   EQU   (0x000D4B3F) 
  124 00000000          xlli_MCIO1_value   EQU   (0x000D4B3F) 
  125 00000000          xlli_FLYCNFG_value EQU   (0x00010001) 
  126 00000000          xlli_MDMRSLP_value EQU   (0x0000C008) 
  127 00000000          xlli_SXCNFG_value  EQU   (0x40044004)   ; Default value at boot up 
  128 00000000            
  129 00000000            
  130 00000000          ; 
  131 00000000          ; Optimal values for MSCO for various MemClk frequencies are listed below 
  132 00000000          ; These values are for L18 async flash 
  133 00000000          ; 
  134 00000000           IF :DEF: xlli_C0_BULVERDE 
  174 00000000              ELSE 
  175 00000000            
  176 00000000          ; This is a hack to get around some B0 timing issue where it doesn't like the optimal 
  177 00000000          ; values according to it's own SPEC!?!  These timing values are relaxed from the above optimal 
  178 00000000          ; but they work for B-step Bulverde... ugh.... 
  179 00000000            
  180 00000000          xlli_MSC0_13       EQU   (0x12101210) 
  181 00000000          xlli_MSC0_19       EQU   (0x12101210) 
  182 00000000          xlli_MSC0_26       EQU   (0x12201220)   ; 26 MHz setting 
  183 00000000          xlli_MSC0_32       EQU   (0x12201220) 
  184 00000000          xlli_MSC0_39       EQU   (0x13301330)   ; 39 MHz setting 
  185 00000000          xlli_MSC0_45       EQU   (0x13301330) 
  186 00000000          xlli_MSC0_52       EQU   (0x13401340)   ; 52 MHz setting 
  187 00000000          xlli_MSC0_58       EQU   (0x13601360) 
  188 00000000          xlli_MSC0_65       EQU   (0x13501350)   ; 65 MHz setting 
  189 00000000          xlli_MSC0_68       EQU   (0x13501350) 
  190 00000000          xlli_MSC0_71       EQU   (0x14601460)   ; 71.5 MHz setting 
  191 00000000          xlli_MSC0_74       EQU   (0x14601460) 
  192 00000000          xlli_MSC0_78       EQU   (0x14601460)   ; 78 MHz setting 
  193 00000000          xlli_MSC0_81       EQU   (0x14701470) 
  194 00000000          xlli_MSC0_84       EQU   (0x14701470)   ; 84.5 MHz setting 
  195 00000000          xlli_MSC0_87       EQU   (0x14701470) 
  196 00000000          xlli_MSC0_91       EQU   (0x14701470)   ; 91 MHz setting 
  197 00000000          xlli_MSC0_94       EQU   (0x14801480)   ; 94.2 MHz setting 
  198 00000000          xlli_MSC0_97       EQU   (0x14801480)   ; 97.5 MHz setting 
  199 00000000          xlli_MSC0_100      EQU   (0x15801580)   ; 100.7 MHz setting 
  200 00000000          xlli_MSC0_104      EQU   (0x15801580)   ; 104 MHz setting 
  201 00000000          xlli_MSC0_110      EQU   (0x15901590) 
  202 00000000          xlli_MSC0_117      EQU   (0x15A015A0)   ; 117 MHz setting 
  203 00000000          xlli_MSC0_124      EQU   (0x15A015A0) 
  204 00000000          xlli_MSC0_130      EQU   (0x15B015B0)   ; 130 MHz setting 
  205 00000000          xlli_MSC0_136      EQU   (0x16B016B0) 
  206 00000000          xlli_MSC0_143      EQU   (0x16C016C0) 
  207 00000000          xlli_MSC0_149      EQU   (0x16C016C0) 
  208 00000000          xlli_MSC0_156      EQU   (0x16C016C0) 
  209 00000000          xlli_MSC0_162      EQU   (0x16C016C0) 
  210 00000000          xlli_MSC0_169      EQU   (0x17D017D0)   ; Given that the optimal value would be 13 (RDF), but according to B0 manual, it's dif 
                        ferent 
  211 00000000          xlli_MSC0_175      EQU   (0x17C017C0) 
  212 00000000          xlli_MSC0_182      EQU   (0x17C017C0) 
  213 00000000          xlli_MSC0_188      EQU   (0x17D017D0) 
  214 00000000          xlli_MSC0_195      EQU   (0x17E017E0) 
  215 00000000          xlli_MSC0_201      EQU   (0x18E018E0) 
  216 00000000          xlli_MSC0_208      EQU   (0x18E018E0) 
  217 00000000            
  218 00000000              ENDIF ; xlli_C0_BULVERDE 
  219 00000000            
  220 00000000          ; 
  221 00000000          ; Optimal values for DTC settings for various MemClk settings (MDCNFG) 
  222 00000000          ; 
  223 00000000              IF  :DEF:  xlli_SDRAM_WIDTH_16_BIT 
  309 00000000              ELSE ; ELSE not MCP package 
  310 00000000            
  311 00000000          ; Now on a discrete MS II platform with slightly better performing SDRAM 
  312 00000000            
  313 00000000          xlli_DTC_13        EQU   (0x00000000)   ; 13 MHz setting 
  314 00000000          xlli_DTC_19        EQU   (0x00000000)   ; 19 MHz setting 
  315 00000000          xlli_DTC_26        EQU   (0x00000000)   ; 26 MHz setting 
  316 00000000          xlli_DTC_32        EQU   (0x00000000)   ; 32 MHz setting 
  317 00000000          xlli_DTC_39        EQU   (0x00000000)   ; 39 MHz setting 
  318 00000000          xlli_DTC_45        EQU   (0x00000000)   ; 45 MHz setting 
  319 00000000          xlli_DTC_52        EQU   (0x00000000)   ; 52 MHz setting 
  320 00000000          xlli_DTC_58        EQU   (0x01000100)   ; 58 MHz setting 
  321 00000000          xlli_DTC_65        EQU   (0x01000100)   ; 65 MHz setting 
  322 00000000          xlli_DTC_68        EQU   (0x01000100)   ; 68 MHz setting 
  323 00000000          xlli_DTC_71        EQU   (0x01000100)   ; 71 MHz setting 
  324 00000000          xlli_DTC_74        EQU   (0x01000100)   ; 74 MHz setting 
  325 00000000          xlli_DTC_78        EQU   (0x01000100)   ; 78 MHz setting 
  326 00000000          xlli_DTC_81        EQU   (0x01000100)   ; 81 MHz setting 
  327 00000000          xlli_DTC_84        EQU   (0x01000100)   ; 84 MHz setting 
  328 00000000          xlli_DTC_87        EQU   (0x01000100)   ; 87 MHz setting 
  329 00000000          xlli_DTC_91        EQU   (0x02000200)   ; 91 MHz setting 
  330 00000000          xlli_DTC_94        EQU   (0x02000200)   ; 94 MHz setting 
  331 00000000          xlli_DTC_97        EQU   (0x02000200)   ; 97 MHz setting 
  332 00000000          xlli_DTC_100       EQU   (0x02000200)   ; 100 MHz setting 
  333 00000000          xlli_DTC_104       EQU   (0x02000200)   ; 104 MHz setting 
  334 00000000          xlli_DTC_110       EQU   (0x01000100)   ; 110 MHz setting - SDCLK Halved 
  335 00000000          xlli_DTC_117       EQU   (0x01000100)   ; 117 MHz setting - SDCLK Halved 
  336 00000000          xlli_DTC_124       EQU   (0x01000100)   ; 124 MHz setting - SDCLK Halved 
  337 00000000          xlli_DTC_130       EQU   (0x01000100)   ; 130 MHz setting - SDCLK Halved 
  338 00000000          xlli_DTC_136       EQU   (0x01000100)   ; 136 MHz setting - SDCLK Halved 
  339 00000000          xlli_DTC_143       EQU   (0x01000100)   ; 143 MHz setting - SDCLK Halved 
  340 00000000          xlli_DTC_149       EQU   (0x01000100)   ; 149 MHz setting - SDCLK Halved 
  341 00000000          xlli_DTC_156       EQU   (0x01000100)   ; 156 MHz setting - SDCLK Halved 
  342 00000000          xlli_DTC_162       EQU   (0x01000100)   ; 162 MHz setting - SDCLK Halved 
  343 00000000          xlli_DTC_169       EQU   (0x01000100)   ; 169 MHz setting - SDCLK Halved 
  344 00000000          xlli_DTC_175       EQU   (0x01000100)   ; 175 MHz setting - SDCLK Halved 
  345 00000000          xlli_DTC_182       EQU   (0x02000200)   ; 182 MHz setting - SDCLK Halved - Close to edge, so bump up 
  346 00000000          xlli_DTC_188       EQU   (0x02000200)   ; 188 MHz setting - SDCLK Halved - Close to edge, so bump up 
  347 00000000          xlli_DTC_195       EQU   (0x02000200)   ; 195 MHz setting - SDCLK Halved - Close to edge, so bump up 
  348 00000000          xlli_DTC_201       EQU   (0x02000200)   ; 201 MHz setting - SDCLK Halved - Close to edge, so bump up 
  349 00000000          xlli_DTC_208       EQU   (0x02000200)   ; 208 MHz setting - SDCLK Halved - Close to edge, so bump up 
  350 00000000            
  351 00000000          ; 
  352 00000000          ; Optimal values for DRI settings for various MemClk settings (MDREFR) 
  353 00000000          ; 
  354 00000000          xlli_DRI_13        EQU   (0x002)   ; 13 MHz setting 
  355 00000000          xlli_DRI_19        EQU   (0x003) 
  356 00000000          xlli_DRI_26        EQU   (0x005)   ; 26 MHz setting 
  357 00000000          xlli_DRI_32        EQU   (0x006) 
  358 00000000          xlli_DRI_39        EQU   (0x008)   ; 39 MHz setting 
  359 00000000          xlli_DRI_45        EQU   (0x00A) 
  360 00000000          xlli_DRI_52        EQU   (0x00B)   ; 52 MHz setting 
  361 00000000          xlli_DRI_58        EQU   (0x00D) 
  362 00000000          xlli_DRI_65        EQU   (0x00E)   ; 65 MHz setting 
  363 00000000          xlli_DRI_68        EQU   (0x00F) 
  364 00000000          xlli_DRI_71        EQU   (0x010)   ; 71 MHz setting 
  365 00000000          xlli_DRI_74        EQU   (0x011) 
  366 00000000          xlli_DRI_78        EQU   (0x012)   ; 78 MHz setting 
  367 00000000          xlli_DRI_81        EQU   (0x012) 
  368 00000000          xlli_DRI_84        EQU   (0x013)   ; 84 MHz setting 
  369 00000000          xlli_DRI_87        EQU   (0x014) 
  370 00000000          xlli_DRI_91        EQU   (0x015)   ; 91 MHz setting 
  371 00000000          xlli_DRI_94        EQU   (0x016)   ; 94 MHz setting 
  372 00000000          xlli_DRI_97        EQU   (0x016)   ; 97 MHz setting 
  373 00000000          xlli_DRI_100       EQU   (0x017)   ; 100 MHz setting 
  374 00000000          xlli_DRI_104       EQU   (0x018)   ; 104 MHz setting 
  375 00000000          xlli_DRI_110       EQU   (0x01A) 
  376 00000000          xlli_DRI_117       EQU   (0x01B)   ; 117 MHz setting 
  377 00000000          xlli_DRI_124       EQU   (0x01D) 
  378 00000000          xlli_DRI_130       EQU   (0x01E)   ; 130 MHz setting 
  379 00000000          xlli_DRI_136       EQU   (0x020) 
  380 00000000          xlli_DRI_143       EQU   (0x021) 
  381 00000000          xlli_DRI_149       EQU   (0x023) 
  382 00000000          xlli_DRI_156       EQU   (0x025) 
  383 00000000          xlli_DRI_162       EQU   (0x026) 
  384 00000000          xlli_DRI_169       EQU   (0x028)   ; 169 MHz setting 
  385 00000000          xlli_DRI_175       EQU   (0x029) 
  386 00000000          xlli_DRI_182       EQU   (0x02B) 
  387 00000000          xlli_DRI_188       EQU   (0x02D) 
  388 00000000          xlli_DRI_195       EQU   (0x02E) 
  389 00000000          xlli_DRI_201       EQU   (0x030) 
  390 00000000          xlli_DRI_208       EQU   (0x031)   ; 208 MHz setting 
  391 00000000            
  392 00000000              ENDIF   ; xlli_SDRAM_WIDTH_16_BIT 
  393 00000000            
  394 00000000          ; SDRAM Settings 
  395 00000000              IF  :DEF:  xlli_SDRAM_WIDTH_16_BIT 
  401 00000000              ELSE 
  402 00000000          xlli_MDCNFG_value  EQU   (0x00000AC8)   ; SDRAM Config Reg (Non-MCP Version) 
  403 00000000              ENDIF 
  404 00000000            
  405 00000000          xlli_MDMRS_value   EQU   (0x00000000)   ; SDRAM Mode Reg Set Config Reg 
  406 00000000            
  407 00000000          ; 
  408 00000000          ; MEMORY PHYSICAL BASE ADDRESS(S) 
  409 00000000          ; 
  410 00000000            
  411 00000000          xlli_SRAM_PHYSICAL_BASE      EQU       (0X5C000000)  ; Physical base address for SRAM 
  412 00000000          xlli_SDRAM_PHYSICAL_BASE     EQU       (0xA0000000)  ; Physical base address for SDRAM 
  413 00000000            
  414 00000000          ; 
  415 00000000          ; CORE, SYSTEM BUS, MEMORY BUS Default frequency setting for Mainstone 
  416 00000000          ; 
  417 00000000          xlli_CCCR_value      EQU     (0x00000107)  ; Bulverde (HW reset value to start) 
  418 00000000          ; 
  419 00000000          ; Clock Enable Register (CKEN) setting 
  420 00000000          ; 
  421 00000000          xlli_CKEN_value      EQU     (0x00400200)  ; Data to be set into the clock enable register 
  422 00000000                                                     ; bit 9 enables OS timers 
  423 00000000                                                     ; Bit 22 enables memory clock 
  424 00000000          ; 
  425 00000000          ; Address where system configuration data is stored 
  426 00000000          ; 
  427 00000000          xlli_SCR_data        EQU     (0x5C03FFFC) ; Address in SRAM where system config data is stored 
  428 00000000            
  429 00000000          ; 
  430 00000000          ; Misc constants 
  431 00000000          ; 
  432 00000000          xlli_MemSize_1Mb     EQU     (0x00100000) 
  433 00000000                  IF  :DEF: xlli_SDRAM_SIZE_32_MB 
  435 00000000                  ELSE 
  436 00000000          xlli_p_PageTable      EQU     (0xA3FFC000)   ; Base address for memory Page Table (Non-MCP version) 
  437 00000000                  ENDIF 
  438 00000000          xlli_s_PageTable      EQU     (0x00004000)   ; Page Table size (4K words - 16 Kb) 
  439 00000000            
  440 00000000              IF :DEF: POST_BUILD 
  442 00000000              ELSE 
  443 00000000          xlli_v_xbBOOTROM          EQU     (0x00000000) 
  444 00000000              ENDIF; 
  445 00000000            
  446 00000000                END 
   52 00000000          ; 
   53                           AREA    |text|, CODE, READONLY, ALIGN=5         ; Align =5 required for "ALIGN 32" feature to work. 
   54 00000000          ; 
   55 00000000          ; List of Low Level Init functions in this source code include: 
   56 00000000          ; 
   57 00000000                  EXPORT xlli_read_SCR              ; Reads the SCR and LCDR virtural registers and places in SRAM 
   58 00000000                  EXPORT xlli_GPIO_init             ; Get SCR and LCDCR data and Initialize the GPIO ports 
   59 00000000                  EXPORT xlli_mem_init              ; Memory controller initialization 
   60 00000000                  EXPORT xlli_mem_restart           ; Restart memory controller 
   61 00000000                  EXPORT xlli_mem_Tmax              ; Sets maximum memory configuration values 
   62 00000000                  EXPORT xlli_mem_Topt              ; Sets optimal memory configuration values based on MemClk frequency 
   63 00000000                  EXPORT xlli_intr_init             ; Interrupt initialization (masks all interrupts) 
   64 00000000                  EXPORT xlli_freq_change           ; Frequency change sequence 
   65 00000000                  EXPORT xlli_clks_init             ; Initialize system clocks 
   66 00000000                  EXPORT xlli_clks_init_sleepReset  ; Initialize system clock after a sleep reset 
   67 00000000                  EXPORT xlli_ost_init              ; Initalize Operating System Timers 
   68 00000000                  EXPORT xlli_icache_enable         ; Enable I-Cache, D-Cache, and Branch Target Buffer 
   69 00000000                  EXPORT xlli_pwrmgr_init           ; Initialize the Power Manager 
   70 00000000                  EXPORT xlli_setPTB                ; Set the Page Tabe Base address (used for sleep resets) 
   71 00000000                  EXPORT xlli_initPageTable         ; Initialize Page Table for MMU unit 
   72 00000000                  EXPORT xlli_MMU_init              ; Initialize the Memory Management Unit 
   73 00000000                  EXPORT xlli_goVirtual             ; Make the transition from physical address to virtual address 
   74 00000000                  EXPORT xlli_IMpwr_init            ; Initialize Internal Memory for use 
   75 00000000                  EXPORT GetSCR                     ; Returns System Configuration Register data to 'C' program caller 
   76 00000000                  EXPORT xlli_setClocks             ; Reads platform switchs and sets Bulverde frequencies 
   77 00000000                  EXPORT xlli_getFreq               ; Returns current system clock settings to 'C' program caller 
   78 00000000                  EXPORT xlli_setBufImpedance       ; Sets SCRAM buffer impedance (C callable) 
   79 00000000                  EXPORT xlli_setBufImp             ; Sets SCRAM buffer impedance (ROM callable) 
   80 00000000            
   81 00000000            
   82 00000000          ;****************************************************************************** 
   83 00000000          ; 
   84 00000000          ; 
   85 00000000          ;       ***************** 
   86 00000000          ;       *               * 
   87 00000000          ;       * xlli_read_SCR * 
   88 00000000          ;       *               * 
   89 00000000          ;       ***************** 
   90 00000000          ; 
   91 00000000          ; This subroutine will reconfigure the GPIO pins in order to read the SCR (system 
   92 00000000          ; Configuration Register) and the LCDCR (LCD Configuration Register) and place this 
   93 00000000          ; information into SRAM for use by other programs. 
   94 00000000          ; 
   95 00000000          ; Once these virtural register have been read, the GPIOs are reconfigured to their 
   96 00000000          ; previous state. 
   97 00000000          ; 
   98 00000000          ; NOTES: Written for the Bulverde Processor on the Mainstone Development Platform. 
   99 00000000          ; 
  100 00000000          ; This subroutine uses and DOES NOT PRESERVE registers r1, r2, r3, r4, r5, r6, r7, r8 and r9 
  101 00000000          ; 
  102 00000000            
  103 00000000          xlli_read_SCR   FUNCTION 
  104 00000000          ; 
  105 00000000          ;       Insure the RDH and PH bits on Bulverde must be clear to enable GPIO pins. 
  106 00000000          ;       They are sticky bits so they must be set to clear them. 
  107 00000000          ; 
  108 00000000 e59f41a0         ldr     r4, =xlli_PMRCREGS_PHYSICAL_BASE 
  109 00000004 e3a02030         mov     r2, #(xlli_PSSR_PH | xlli_PSSR_RDH) ; Set the PH and RDH bits to enable all GPIOs 
  110 00000008 e5842004         str     r2, [r4, #xlli_PSSR_offset]         ; Enable all GPIO lines 
  111 0000000c          ; 
  112 0000000c          ;       Get, and save the present GPIO settings for direction registers 0, 1 and 2 
  113 0000000c          ; 
  114 0000000c e59f4198         ldr     r4,  =xlli_GPIOREGS_PHYSICAL_BASE  ; Get the GPIO registers base address 
  115 00000010 e5945010         ldr     r5,  [r4, #xlli_GPDR1_offset]      ; Save direction values for GPIOs [63:32] 
  116 00000014 e5946014         ldr     r6,  [r4, #xlli_GPDR2_offset]      ; Save direction values for GPIOs [95:64] 
  117 00000018 e5947060         ldr     r7,  [r4, #xlli_GAFR1_U_offset]    ; Save alt function values for GPIOs [63:48] 
  118 0000001c e5948064         ldr     r8,  [r4, #xlli_GAFR2_L_offset]    ; Save alt function values for GPIOs [79:64] 
  119 00000020 e5949068         ldr     r9,  [r4, #xlli_GAFR2_U_offset]    ; Save alt function values for GPIOs [95:80] 
  120 00000024            
  121 00000024          ; 
  122 00000024          ;       Clear the bits of those GPIOs we need to read as inputs and write back to the GPIO 
  123 00000024          ;       direction registers. The alternate function bits also need to be cleared. For this 
  124 00000024          ;       particular code sequence "Magic Numbers" are used for the bit clear masks. 
  125 00000024          ; 
  126 00000024          ;       To cut down on the number of registers used we'll do GPDR1 and GPDR2 now and take care of 
  127 00000024          ;       GPDR0 (and it's alternate function bits) later. Because this code is usually run very early 
  128 00000024          ;       in the boot sequence (before SDRAM is brought up) the code assumes there is no stack to 
  129 00000024          ;       preserve the contents of the registers used. 
  130 00000024          ; 
  131 00000024 e3a0233f         ldr     r2,  =0xFC000000                   ; Register clear mask for GPDR1 
  132 00000028 e1c51002         bic     r1,  r5,  r2                       ; Clear the bits we need to read in GPDR1 
  133 0000002c e5841010         str     r1,  [r4, #xlli_GPDR1_offset]      ; Write direction values for GPIOs [63:32] 
  134 00000030            
  135 00000030 e59f2178         ldr     r2,  =0x00C02FFF                   ; Register clear mask for GPDR2 
  136 00000034 e1c61002         bic     r1,  r6,  r2                       ; Clear the bits we need to read in GPDR2 
  137 00000038 e5841014         str     r1,  [r4, #xlli_GPDR2_offset]      ; Write direction values for GPIOs [95:64] 
  138 0000003c          ; 
  139 0000003c          ;       Clear the alternate function bits for the direction bits we need to look at. 
  140 0000003c          ; 
  141 0000003c e59f2170         ldr     r2,  =0xFFF00000                   ; Register clear mask for GAFR1_U 
  142 00000040 e1c71002         bic     r1,  r7,  r2                       ; Clear the alt func for bits we need to read in GAFR1_U 
  143 00000044 e5841060         str     r1,  [r4, #xlli_GAFR1_U_offset]    ; Write alt function values for GPIOs [63:48] 
  144 00000048            
  145 00000048 e3e024f3         ldr     r2,  =0x0CFFFFFF                   ; Register clear mask for GAFR2_L 
  146 0000004c e1c81002         bic     r1,  r8,  r2                       ; Clear the alt func for bits we need to read in GAFR2_L 
  147 00000050 e5841064         str     r1,  [r4, #xlli_GAFR2_L_offset]    ; Write alt function values for GPIOs [79:64] 
  148 00000054            
  149 00000054 e3a02a0f         ldr     r2,  =0x0000F000                   ; Register clear mask for GAFR2_U 
  150 00000058 e1c91002         bic     r1,  r9,  r2                       ; Clear the alt func for bits we need to read in GAFR2_U 
  151 0000005c e5841068         str     r1,  [r4, #xlli_GAFR2_U_offset]    ; Write alt function values for GPIOs [95:80] 
  152 00000060            
  153 00000060 e3a01c02         mov     r1,  #0x200 
  154 00000064 e2511001 xlli_1  subs    r1,  r1,  #1                       ; Short delay required to allow the new GPIO... 
  155 00000068 1afffffd         bne     xlli_1                             ; ...settings to take effect 
  156 0000006c          ; 
  157 0000006c          ;       With the GPIO direction registers set, the Platform System Configuration Register is read 
  158 0000006c          ;       from GPIO bits 73:58 and are stored in SRAM. 
  159 0000006c          ;       This data is placed in the UPPER 16 BITS (31:16) of this register. 
  160 0000006c          ; 
  161 0000006c e5941004         ldr     r1,  [r4, #xlli_GPLR1_offset]      ; Get levels for GPIOs [63:32] 
  162 00000070 e1a01521         mov     r1,  r1,  LSR #10                  ; Move the data 10 bits to the right 
  163 00000074 e5942008         ldr     r2,  [r4, #xlli_GPLR2_offset]      ; Get levels for GPIOs [95:64] 
  164 00000078 e1a03002         mov     r3,  r2                            ; Save a copy for future reference 
  165 0000007c e1a02b02         mov     r2,  r2,  LSL #22                  ; Move the data 22 bits to the left 
  166 00000080 e1811002         orr     r1,  r1,  r2                       ; This places GPIO data bits [73:58] into bits [31:16] 
  167 00000084 e59f212c         ldr     r2,  =0xFFFF0000                   ; Mask word 
  168 00000088 e0011002         and     r1,  r1,  r2                       ; Make sure the bottom 16 bits are clear 
  169 0000008c          ; 
  170 0000008c          ;       Restore GPDR1, GPDR2, GAFR1_U, GAFR2_L and GAFR2_U to their original values 
  171 0000008c          ; 
  172 0000008c e5845010         str     r5,  [r4, #xlli_GPDR1_offset]      ; Restore direction values for GPIOs [63:32] 
  173 00000090 e5846014         str     r6,  [r4, #xlli_GPDR2_offset]      ; Restore direction values for GPIOs [95:64] 
  174 00000094 e5847060         str     r7,  [r4, #xlli_GAFR1_U_offset]    ; Restore alt function values for GPIOs [63:48] 
  175 00000098 e5848064         str     r8,  [r4, #xlli_GAFR2_L_offset]    ; Restore alt function values for GPIOs [79:64] 
  176 0000009c e5849068         str     r9,  [r4, #xlli_GAFR2_U_offset]    ; Restore alt function values for GPIOs [95:80] 
  177 000000a0          ; 
  178 000000a0          ;       Configure GPDR0, GAFR0_L and GAFR0_U to pick up four status bits we need from this word 
  179 000000a0          ;       NOTE: The values in r1 and r4 must be preserved through this section of code. 
  180 000000a0          ; 
  181 000000a0 e594500c         ldr     r5,  [r4, #xlli_GPDR0_offset]      ; Save direction values for GPIOs [31:0] 
  182 000000a4 e5946054         ldr     r6,  [r4, #xlli_GAFR0_L_offset]    ; Save alt function values for GPIOs [15:0] 
  183 000000a8 e5947058         ldr     r7,  [r4, #xlli_GAFR0_U_offset]    ; Save alt function values for GPIOs [31:16] 
  184 000000ac            
  185 000000ac e59f2108         ldr     r2,  =0xC0084000                   ; Register clear mask for GPDR0 
  186 000000b0 e1c58002         bic     r8,  r5,  r2                       ; Clear the bits we need to read in GPDR0 
  187 000000b4 e584800c         str     r8,  [r4, #xlli_GPDR0_offset]      ; Write direction values for GPIOs [31:0] 
  188 000000b8          ; 
  189 000000b8          ;       Clear the alternate function bits for the direction bits we need to look at. 
  190 000000b8          ; 
  191 000000b8 e3a02203         ldr     r2,  =0x30000000                   ; Register clear mask for GAFR0_L 
  192 000000bc e1c68002         bic     r8,  r6,  r2                       ; Clear the alt func for bits we need to read in GAFR0_L 
  193 000000c0 e5848054         str     r8,  [r4, #xlli_GAFR0_L_offset]    ; Write alt function values for GPIOs [15:0] 
  194 000000c4            
  195 000000c4 e59f20f4         ldr     r2,  =0xF00000C0                   ; Register clear mask for GAFR0_U 
  196 000000c8 e1c78002         bic     r8,  r7,  r2                       ; Clear the alt func for bits we need to read in GAFR0_U 
  197 000000cc e5848058         str     r8,  [r4, #xlli_GAFR0_U_offset]    ; Write alt function values for GPIOs [31:16] 
  198 000000d0            
  199 000000d0 e3a02c02         mov     r2,  #0x200 
  200 000000d4 e2522001 xlli_2  subs    r2,  r2,  #1                       ; Short delay required to allow the new GPIO... 
  201 000000d8 1afffffd         bne     xlli_2                             ; ...settings to take effect 
  202 000000dc          ; 
  203 000000dc          ;       The data that makes up the LCDCR registar (GPIO bits 87, 86, 77, 75, 74, 19, and 14) are 
  204 000000dc          ;       stored in bits 6:0 of the PSPR. The xlli code does not use this data - it is only placed 
  205 000000dc          ;       into the PSPR to make the data accessable to other users who can then take the data and 
  206 000000dc          ;       store it elsewhere or simply ignore it and write over it. 
  207 000000dc          ; 
  208 000000dc          ;       The SCR data is in the upper 16 bits of r1. Now the data for the LCDCR register needs 
  209 000000dc          ;       to be assembled from data saved in r3 in addition to two bits to be read from GPIOs 31:0 
  210 000000dc          ;       and this data needs to be ORed into r1 as well. 
  211 000000dc          ; 
  212 000000dc e2032a02         and     r2,  r3,  #0x2000                  ; isolate bit 77 
  213 000000e0 e1a024a2         mov     r2,  r2,  LSR #9                                   ; Move to bit position #4 
  214 000000e4            
  215 000000e4 e2038b03         and     r8,  r3,  #0xC00                   ; Extract bits 75:74 
  216 000000e8 e1a08428         mov     r8,  r8,  LSR #8                   ; Move GPIO bits 75:74 to bit position 3:2 
  217 000000ec e1822008         orr     r2,  r2,  r8                       ; Save these two bits into r2 
  218 000000f0            
  219 000000f0 e2038503         and     r8,  r3,  #0xC00000                ; Extract bits 87:86 
  220 000000f4 e1a088a8         mov     r8,  r8,  LSR #17                  ; Move GPIO bits 87:86 to bit position 6:5 
  221 000000f8 e1822008         orr     r2,  r2,  r8                       ; Save these two bits into r2 
  222 000000fc            
  223 000000fc e5943000         ldr     r3,  [r4, #xlli_GPLR0_offset]      ; Get levels for GPIOs [31:0] 
  224 00000100 e1a03723         mov     r3,  r3,  LSR #14                  ; Allign GPIO bit 14 with bit position 0 
  225 00000104 e2038001         and     r8,  r3,  #0x1                     ; Extract this bit 
  226 00000108 e1822008         orr     r2,  r2,  r8                       ; OR this bit into r2 
  227 0000010c            
  228 0000010c e1a03223         mov     r3,  r3,  LSR #4                   ; move GPIO bit 19 into bit location 1 
  229 00000110 e2038002         and     r8,  r3,  #0x2                     ; extract this bit 
  230 00000114 e1822008         orr     r2,  r2,  r8                       ; OR this bit value into r2 
  231 00000118            
  232 00000118 e1a032a3         mov     r3,  r3,  LSR #5                   ; move GPIO bits 31:30 into bit locations 8:7 
  233 0000011c e2033d06         and     r3,  r3,  #0x180                   ; isolate these bits 
  234 00000120 e1822003         orr     r2,  r2,  r3                       ; OR this bit value into r2 
  235 00000124          ; 
  236 00000124          ;       Restore GPDR0, GAFR0_L and GAFR0_U to their original values 
  237 00000124          ; 
  238 00000124 e584500c         str     r5,  [r4, #xlli_GPDR0_offset]      ; Restore direction values for GPIOs [31:0] 
  239 00000128 e5846054         str     r6,  [r4, #xlli_GAFR0_L_offset]    ; Restore alt function values for GPIOs [15:0] 
  240 0000012c e5847058         str     r7,  [r4, #xlli_GAFR0_U_offset]    ; Restore alt function values for GPIOs [31:16] 
  241 00000130          ; 
  242 00000130          ;       Now we need to read status from GPIOs 103, 104 and 113 
  243 00000130          ; 
  244 00000130          ;       Configure GPDR3, GAFR3_L and GAFR3_U to pick up three status bits we need from this word 
  245 00000130          ;       NOTE: The values in r1 and r4 must be preserved through this section of code. 
  246 00000130          ; 
  247 00000130 e594510c         ldr     r5,  [r4, #xlli_GPDR3_offset]      ; Save direction values for GPIOs [127:96] 
  248 00000134 e594606c         ldr     r6,  [r4, #xlli_GAFR3_L_offset]    ; Save alt function values for GPIOs [111:96] 
  249 00000138 e5947070         ldr     r7,  [r4, #xlli_GAFR3_U_offset]    ; Save alt function values for GPIOs [127:112] 
  250 0000013c            
  251 0000013c e59f9080         ldr     r9,  =0x00020180                   ; Register clear mask for GPDR3 
  252 00000140 e1c58009         bic     r8,  r5,  r9                       ; Clear the bits we need to read in GPDR3 
  253 00000144 e584810c         str     r8,  [r4, #xlli_GPDR3_offset]      ; Write direction values for GPIOs [127:96] 
  254 00000148          ; 
  255 00000148          ;       Clear the alternate function bits for the direction bits we need to look at. 
  256 00000148          ; 
  257 00000148 e3a0990f         ldr     r9,  =0x0003C000                   ; Register clear mask for GAFR3_L 
  258 0000014c e1c68009         bic     r8,  r6,  r9                       ; Clear the alt func for bits we need to read in GAFR3_L 
  259 00000150 e584806c         str     r8,  [r4, #xlli_GAFR3_L_offset]    ; Write alt function values for GPIOs [111:96] 
  260 00000154            
  261 00000154 e3a0900c         ldr     r9,  =0x0000000C                   ; Register clear mask for GAFR3_U 
  262 00000158 e1c78009         bic     r8,  r7,  r9                       ; Clear the alt func for bits we need to read in GAFR3_U 
  263 0000015c e5848070         str     r8,  [r4, #xlli_GAFR3_U_offset]    ; Write alt function values for GPIOs [127:112] 
  264 00000160            
  265 00000160 e3a09c02         mov     r9,  #0x200 
  266 00000164 e2599001 xlli_15 subs    r9,  r9,  #1                       ; Short delay required to allow the new GPIO... 
  267 00000168 1afffffd         bne     xlli_15                            ; ...settings to take effect 
  268 0000016c            
  269 0000016c e5943100         ldr     r3,  [r4, #xlli_GPLR3_offset]      ; Get levels for GPIOs [127:96] 
  270 00000170          ; 
  271 00000170          ;       Restore GPDR3, GAFR3_L and GAFR3_U to their original values 
  272 00000170          ; 
  273 00000170 e584510c         str     r5,  [r4, #xlli_GPDR3_offset]      ; Restore direction values for GPIOs [127:96] 
  274 00000174 e584606c         str     r6,  [r4, #xlli_GAFR3_L_offset]    ; Restore alt function values for GPIOs [111:96] 
  275 00000178 e5847070         str     r7,  [r4, #xlli_GAFR3_U_offset]    ; Restore alt function values for GPIOs [127:112] 
  276 0000017c            
  277 0000017c e1a03103         mov     r3,  r3,  LSL #2                   ; Move GPIO bits 103:104 to bit locations 11:10 
  278 00000180 e2038b03         and     r8,  r3,  #0xC00                   ; extract settings for bits 11:10 
  279 00000184 e1822008         orr     r2,  r2,  r8                       ; Add in to value for system config word 
  280 00000188            
  281 00000188 e1a03523         mov     r3,  r3,  LSR #10                  ; Move GPIO bits 113 to bit location 9 
  282 0000018c e2038b01         and     r8,  r3,  #0x400                   ; extract setting for bit 9 
  283 00000190 e1822008         orr     r2,  r2,  r8                       ; Add in to value for system config word 
  284 00000194          ; 
  285 00000194          ;       Read back from APB to ensure our writes have completed before continuing 
  286 00000194          ; 
  287 00000194 e5948070         ldr     r8, [r4, #xlli_GAFR3_U_offset] 
  288 00000198            
  289 00000198          ; 
  290 00000198          ;       r2 now contains the SCR2 register data in bits 11:0 
  291 00000198          ;       This value gets ORed with the SCR data in bits 31:16 of r1 
  292 00000198          ; 
  293 00000198 e1811002         orr     r1,  r1,  r2                       ; Generate the data word to be stored 
  294 0000019c          ; 
  295 0000019c          ;       Update SRAM with the above data 
  296 0000019c          ; 
  297 0000019c e59f4024         ldr     r4,  =xlli_SCR_data                ; Get SRAM address where data is to be stored 
  298 000001a0 e5841000         str     r1,  [r4]                          ; Write the contents to SRAM 
  299 000001a4            
  300 000001a4 e1a0f00e         mov     pc, lr                             ; Return to calling program 
  301 000001a8            
  302 000001a8                  ENDFUNC 
  303 000001a8            
  304 000001a8 40f00000 *literal pool: constant 
  304 000001ac 40e00000 *literal pool: constant 
  304 000001b0 00c02fff *literal pool: constant 
  304 000001b4 fff00000 *literal pool: constant 
  304 000001b8 ffff0000 *literal pool: constant 
  304 000001bc c0084000 *literal pool: constant 
  304 000001c0 f00000c0 *literal pool: constant 
  304 000001c4 00020180 *literal pool: constant 
  304 000001c8 5c03fffc *literal pool: constant 
  304 000001a8                  LTORG 
  305 000001cc            
  306 000001cc          ;****************************************************************************** 
  307 000001cc          ; 
  308 000001cc          ; 
  309 000001cc          ;       ****************** 
  310 000001cc          ;       *                * 
  311 000001cc          ;       * xlli_GPIO_init * Subroutine 
  312 000001cc          ;       *                * 
  313 000001cc          ;       ****************** 
  314 000001cc          ; 
  315 000001cc          ; This subroutine sets up the GPIO pins in accordance with the values contained in the platform include file. 
  316 000001cc          ; 
  317 000001cc          ; NOTES: Written for the Bulverde Processor on the Mainstone Development Platform. 
  318 000001cc          ; 
  319 000001cc            
  320 000001cc          xlli_GPIO_init   FUNCTION 
  321 000001cc          ; 
  322 000001cc          ; 
  323 000001cc          ; 
  324 000001cc          ; 
  325 000001cc          ;       Get GPIO registers base address and configure all GPIO lines. 
  326 000001cc          ; 
  327 000001cc e59f00b0         ldr     r0,  =xlli_GPIOREGS_PHYSICAL_BASE   ; Load the GPIO register block base address 
  328 000001d0            
  329 000001d0 e59f10b0         ldr     r1,  =xlli_GPSR0_value              ; Get the pin set values for GPSR0 
  330 000001d4 e5801018         str     r1,  [r0, #xlli_GPSR0_offset]       ; Write the R0 values 
  331 000001d8            
  332 000001d8 e59f20ac         ldr     r2,  =xlli_GPSR1_value              ; Get the pin set values for GPSR1 
  333 000001dc e580201c         str     r2,  [r0, #xlli_GPSR1_offset]       ; Write the R1 values 
  334 000001e0            
  335 000001e0 e59f10a8         ldr     r1,  =xlli_GPSR2_value              ; Get the pin set values for GPSR2 
  336 000001e4 e5801020         str     r1,  [r0, #xlli_GPSR2_offset]       ; Write the R2 values 
  337 000001e8            
  338 000001e8 e3a02a3e         ldr     r2,  =xlli_GPSR3_value              ; Get the pin set values for GPSR3 
  339 000001ec e5802118         str     r2,  [r0, #xlli_GPSR3_offset]       ; Write the R3 values 
  340 000001f0            
  341 000001f0 e3a01000         ldr     r1,  =xlli_GPCR0_value              ; Get the pin clear values for GPCR0 
  342 000001f4 e5801024         str     r1,  [r0, #xlli_GPCR0_offset]       ; Write the R0 values 
  343 000001f8            
  344 000001f8 e3a02d0e         ldr     r2,  =xlli_GPCR1_value              ; Get the pin clear values for GPCR1 
  345 000001fc e5802028         str     r2,  [r0, #xlli_GPCR1_offset]       ; Write the R1 values 
  346 00000200            
  347 00000200 e3a01000         ldr     r1,  =xlli_GPCR2_value              ; Get the pin clear values for GPCR2 
  348 00000204 e580102c         str     r1,  [r0, #xlli_GPCR2_offset]       ; Write the R2 values 
  349 00000208            
  350 00000208 e3a02000         ldr     r2,  =xlli_GPCR3_value              ; Get the pin clear values for GPCR3 
  351 0000020c e5802124         str     r2,  [r0, #xlli_GPCR3_offset]       ; Write the R3 values 
  352 00000210            
  353 00000210 e59f107c         ldr     r1,  =xlli_GPDR0_value              ; Get the pin direction values for GPDR0 
  354 00000214 e580100c         str     r1,  [r0, #xlli_GPDR0_offset]       ; Write the R0 values 
  355 00000218            
  356 00000218 e59f2078         ldr     r2,  =xlli_GPDR1_value              ; Get the pin direction values for GPDR1 
  357 0000021c e5802010         str     r2,  [r0, #xlli_GPDR1_offset]       ; Write the R1 values 
  358 00000220            
  359 00000220 e59f1074         ldr     r1,  =xlli_GPDR2_value              ; Get the pin direction values for GPDR2 
  360 00000224 e5801014         str     r1,  [r0, #xlli_GPDR2_offset]       ; Write the R2 values 
  361 00000228            
  362 00000228 e59f2070         ldr     r2,  =xlli_GPDR3_value              ; Get the pin direction values for GPDR3 
  363 0000022c e580210c         str     r2,  [r0, #xlli_GPDR3_offset]       ; Write the R3 values 
  364 00000230            
  365 00000230 e59f106c         ldr     r1,  =xlli_GAFR0_L_value            ; Get the pin alt function values for GAFR0_L 
  366 00000234 e5801054         str     r1,  [r0, #xlli_GAFR0_L_offset]     ; Write the R0_L values 
  367 00000238            
  368 00000238 e59f2068         ldr     r2,  =xlli_GAFR0_U_value            ; Get the pin alt function values for GAFR0_U 
  369 0000023c e5802058         str     r2,  [r0, #xlli_GAFR0_U_offset]     ; Write the R0_U values 
  370 00000240            
  371 00000240 e59f1064         ldr     r1,  =xlli_GAFR1_L_value            ; Get the pin alt function values for GAFR1_L 
  372 00000244 e580105c         str     r1,  [r0, #xlli_GAFR1_L_offset]     ; Write the R1_L values 
  373 00000248            
  374 00000248 e59f2060         ldr     r2,  =xlli_GAFR1_U_value            ; Get the pin alt function values for GAFR1_U 
  375 0000024c e5802060         str     r2,  [r0, #xlli_GAFR1_U_offset]     ; Write the R1_U values 
  376 00000250            
  377 00000250 e3a01206         ldr     r1,  =xlli_GAFR2_L_value            ; Get the pin alt function values for GAFR2_L 
  378 00000254 e5801064         str     r1,  [r0, #xlli_GAFR2_L_offset]     ; Write the R2_L values 
  379 00000258            
  380 00000258 e59f2054         ldr     r2,  =xlli_GAFR2_U_value            ; Get the pin alt function values for GAFR2_U 
  381 0000025c e5802068         str     r2,  [r0, #xlli_GAFR2_U_offset]     ; Write the R2_U values 
  382 00000260            
  383 00000260 e3a01000         ldr     r1,  =xlli_GAFR3_L_value            ; Get the pin alt function values for GAFR3_L 
  384 00000264 e580106c         str     r1,  [r0, #xlli_GAFR3_L_offset]     ; Write the R3_L values 
  385 00000268            
  386 00000268 e3a02000         ldr     r2,  =xlli_GAFR3_U_value            ; Get the pin alt function values for GAFR3_U 
  387 0000026c e5802070         str     r2,  [r0, #xlli_GAFR3_U_offset]     ; Write the R3_U values 
  388 00000270          ; 
  389 00000270          ;       The RDH and PH bits on Bulverde must be set to enable updated GPIO pins. 
  390 00000270          ;       These are sticky bits. 
  391 00000270          ; 
  392 00000270 e59f0040         ldr     r0, =xlli_PMRCREGS_PHYSICAL_BASE 
  393 00000274 e3a02030         mov     r2, #(xlli_PSSR_PH | xlli_PSSR_RDH) ; Set the PH and RDH bits to enable all GPIOs 
  394 00000278 e5802004         str     r2, [r0, #xlli_PSSR_offset]         ; Enable all GPIO lines 
  395 0000027c          ; 
  396 0000027c          ;       Read back from APB to ensure our writes have completed before continuing 
  397 0000027c          ; 
  398 0000027c e5902004         ldr     r2, [r0, #xlli_PSSR_offset] 
  399 00000280            
  400 00000280 e1a0f00e         mov     pc, lr                              ; Return to calling program 
  401 00000284            
  402 00000284                  ENDFUNC 
  403 00000284            
  404 00000284 40e00000 *literal pool: constant 
  404 00000288 00008004 *literal pool: constant 
  404 0000028c 00020080 *literal pool: constant 
  404 00000290 16c14000 *literal pool: constant 
  404 00000294 cfe3bde4 *literal pool: constant 
  404 00000298 003fab81 *literal pool: constant 
  404 0000029c 1ec3fc00 *literal pool: constant 
  404 000002a0 018ffe8f *literal pool: constant 
  404 000002a4 84400000 *literal pool: constant 
  404 000002a8 a5000510 *literal pool: constant 
  404 000002ac 000a9558 *literal pool: constant 
  404 000002b0 0005a1aa *literal pool: constant 
  404 000002b4 00000802 *literal pool: constant 
  404 000002b8 40f00000 *literal pool: constant 
  404 00000284                  LTORG 
  405 000002bc            
  406 000002bc          ;************************************************************************************************** 
  407 000002bc          ; 
  408 000002bc          ; ************************************************** 
  409 000002bc          ; **********                              ********** 
  410 000002bc          ; ********** INITIALIZE MEMORY CONTROLLER ********** 
  411 000002bc          ; **********                              ********** 
  412 000002bc          ; ************************************************** 
  413 000002bc          ; 
  414 000002bc          ; The sequence below is based on the recommended memory initializing steps detailed 
  415 000002bc          ; in the Bulverde EAS, Volume I (Section 13.17, page 13-72) 
  416 000002bc          ; 
  417 000002bc            
  418 000002bc          xlli_mem_init   FUNCTION 
  419 000002bc            
  420 000002bc          ; 
  421 000002bc          ; ***** STEP 1: ***** 
  422 000002bc          ; 
  423 000002bc          ; Delay 200 uS 
  424 000002bc          ; 
  425 000002bc e59f21c4         ldr     r2,  =xlli_OSTREGS_PHYSICAL_BASE ; Load OS timer base address 
  426 000002c0 e5923010         ldr     r3,  [r2, #xlli_OSCR0_offset]    ; Fetch starting value of OSCR0 
  427 000002c4 e2833c03         add     r3,  r3,  #0x300                 ; Really 0x2E1 is about 200usec, so 0x300 should be plenty 
  428 000002c8 e5921010 xlli_3  ldr     r1,  [r2, #xlli_OSCR0_offset]    ; Fetch current OSCR0 value 
  429 000002cc e1510003         cmp     r1,  r3                          ; Is the timer past the time out value? 
  430 000002d0 4afffffc         bmi     xlli_3                           ; No - Loop until it is 
  431 000002d4          ; 
  432 000002d4          ;  STEP 1 - 1st bullet: Write MSC0, MSC1 and MSC2 (the order is not important) 
  433 000002d4          ;  ******************* 
  434 000002d4          ; 
  435 000002d4          ;       The value that is loaded for MSC0 depends on which FLASH memory was used to 
  436 000002d4          ;       boot from as determined by the switch position of SW2 (SWAP FLASH) on the 
  437 000002d4          ;       Mainstone board. To get the position of this switch, GPIO line #73 must be sensed. 
  438 000002d4          ; 
  439 000002d4 e59f41b0         ldr     r4,  =xlli_GPIOREGS_PHYSICAL_BASE   ; Load the GPIO register block base address 
  440 000002d8            
  441 000002d8 e5942014         ldr     r2,  [r4, #xlli_GPDR2_offset]       ; Read GPDR2 (direction register) data 
  442 000002dc e5945064         ldr     r5,  [r4, #xlli_GAFR2_L_offset]     ; Read alt function register for GPIO #73 
  443 000002e0 e1a01002         mov     r1,  r2                             ; Copy direction register data to r1 
  444 000002e4 e1a03005         mov     r3,  r5                             ; Copy alt function register to r3 
  445 000002e8 e3c11c02         bic     r1,  r1,  #0x200                    ; Clear direction bit for GPIO #73 
  446 000002ec e3c33703         bic     r3,  r3,  #0xC0000                  ; Clear alt function bits for GPIO #73 
  447 000002f0 e5843064         str     r3,  [r4, #xlli_GAFR2_L_offset]     ; Write alt function register 
  448 000002f4 e5841014         str     r1,  [r4, #xlli_GPDR2_offset]       ; Write GPDR2 (direction register) data 
  449 000002f8          ; 
  450 000002f8          ;       It can take many cycles for the GPIO setting to take effect before the read can be 
  451 000002f8          ;       issued. The delay is based on clock cycles rather than elaped time so a simple 
  452 000002f8          ;       do-nothing loop will do the trick. 
  453 000002f8          ; 
  454 000002f8 e3a01c06         mov     r1,  #0x600                         ; Init counter 
  455 000002fc e2511001 xlli_4  subs    r1,  r1,  #1                        ; Decrement counter 
  456 00000300 1afffffd         bne     xlli_4                              ; Loop until zero 
  457 00000304            
  458 00000304 e5941008         ldr     r1,  [r4, #xlli_GPLR2_offset]       ; Read GPLR2 (level register) data 
  459 00000308 e2111c02         ands    r1,  r1,  #0x200                    ; Test status of GPIO #73 
  460 0000030c 059f117c         ldreq   r1,  =xlli_MSC0_DC_value            ; Get MSC0 setting for daughter card Flash 
  461 00000310 159f117c         ldrne   r1,  =xlli_MSC0_MS_value            ; Get MSC0 setting for Mainstone Flash 
  462 00000314            
  463 00000314 e5845064         str     r5,  [r4, #xlli_GAFR2_L_offset]     ; Write back original alt function register 
  464 00000318 e5842014         str     r2,  [r4, #xlli_GPDR2_offset]       ; Write back original GPDR2 data 
  465 0000031c          ; 
  466 0000031c          ;       Read back from APB to ensure our writes have completed before continuing 
  467 0000031c          ;       (spanning a bridge here) 
  468 0000031c          ; 
  469 0000031c e5942014         ldr     r2, [r4, #xlli_GPDR2_offset] 
  470 00000320            
  471 00000320          ; 
  472 00000320          ;       Finally - Write the memory control registers 
  473 00000320          ; 
  474 00000320 e3a04312         ldr     r4,  =xlli_MEMORY_CONFIG_BASE   ; Get memory controller base address 
  475 00000324            
  476 00000324 e5841008         str     r1,  [r4, #xlli_MSC0_offset]    ; Write the value out 
  477 00000328 e5941008         ldr     r1,  [r4, #xlli_MSC0_offset]    ; Read back to latch the data 
  478 0000032c            
  479 0000032c e59f2164         ldr     r2,  =xlli_MSC1_value           ; Get MSC1 setting 
  480 00000330 e584200c         str     r2,  [r4, #xlli_MSC1_offset]    ; Write the value out 
  481 00000334 e594200c         ldr     r2,  [r4, #xlli_MSC1_offset]    ; Read back to latch the data 
  482 00000338            
  483 00000338 e59f115c         ldr     r1,  =xlli_MSC2_value           ; Get MSC2 setting 
  484 0000033c e5841010         str     r1,  [r4, #xlli_MSC2_offset]    ; Write the value out 
  485 00000340 e5941010         ldr     r1,  [r4, #xlli_MSC2_offset]    ; Read back to latch the data 
  486 00000344          ; 
  487 00000344          ;  STEP 1 - 2nd bullet: Write MECR, MCMEM0, MCMEM1, MCATT0, MCATT1, MCIO0, MCIO1 (order not important) 
  488 00000344          ;  ******************* 
  489 00000344          ; 
  490 00000344 e3a02001         ldr     r2,  =xlli_MECR_value           ; write MECR 
  491 00000348 e5842014         str     r2,  [r4, #xlli_MECR_offset] 
  492 0000034c            
  493 0000034c e59f114c         ldr     r1,  =xlli_MCMEM0_value         ; write MCMEM0 
  494 00000350 e5841028         str     r1,  [r4, #xlli_MCMEM0_offset] 
  495 00000354            
  496 00000354 e59f2144         ldr     r2,  =xlli_MCMEM1_value         ; write MCMEM1 
  497 00000358 e584202c         str     r2,  [r4, #xlli_MCMEM1_offset] 
  498 0000035c            
  499 0000035c e59f1140         ldr     r1,  =xlli_MCATT0_value         ; write MCATT0 
  500 00000360 e5841030         str     r1,  [r4, #xlli_MCATT0_offset] 
  501 00000364            
  502 00000364 e59f2138         ldr     r2,  =xlli_MCATT1_value         ; write MCATT1 
  503 00000368 e5842034         str     r2,  [r4, #xlli_MCATT1_offset] 
  504 0000036c            
  505 0000036c e59f1134         ldr     r1,  =xlli_MCIO0_value          ; write MCIO0 
  506 00000370 e5841038         str     r1,  [r4, #xlli_MCIO0_offset] 
  507 00000374            
  508 00000374 e59f212c         ldr     r2,  =xlli_MCIO1_value          ; write MCIO1 
  509 00000378 e584203c         str     r2,  [r4, #xlli_MCIO1_offset] 
  510 0000037c          ; 
  511 0000037c          ;  STEP 1 - 3rd bullet: Write FLYCNFG 
  512 0000037c          ;  ******************* 
  513 0000037c          ; 
  514 0000037c e59f1128         ldr     r1,  =xlli_FLYCNFG_value        ; write FLYCNFG 
  515 00000380 e5841020         str     r1,  [r4, #xlli_FLYCNFG_offset] 
  516 00000384          ; 
  517 00000384            
  518 00000384          ; 
  519 00000384          ;  STEP 1 - 4th bullet: SKIPPED (used only when coming out of sleep) 
  520 00000384          ;  ******************* 
  521 00000384          ; 
  522 00000384          ;     (If required, this would be a write to MDCNFG with enable bits deasserted.) 
  523 00000384            
  524 00000384          ; 
  525 00000384          ;  STEP 1 - 5th bullet: update MDREFR settings 
  526 00000384          ;  ******************* 
  527 00000384          ; 
  528 00000384 e5942004         ldr         r2,  [r4, #xlli_MDREFR_offset] ; Get reset state of MDREFR 
  529 00000388 e1a02622         mov         r2,  r2, lsr #0xC              ; Shift data 12 bits (0xC) to the right 
  530 0000038c e1a02602         mov         r2,  r2, lsl #0xC              ; and shift left 12 bits (Clears DRI field) 
  531 00000390                                                             ; because left shifts fill bits with zeros. 
  532 00000390            
  533 00000390 e3a0101e         ldr     r1,  =xlli_MDREFR_value            ; Fetch MDREFR value for this platform 
  534 00000394 e1a01a01         mov         r1,  r1, lsl #0x14             ; use shifts to extract the DRI field using 
  535 00000398 e1a01a21         mov         r1,  r1, lsr #0x14             ; same method as before but shifting 20 (0x14) 
  536 0000039c                                                             ; bits left, then right again. 
  537 0000039c            
  538 0000039c e1822001         orr     r2,  r2, r1                    ; insert the DRI field extracted above 
  539 000003a0 e5842004         str     r2,  [r4, #xlli_MDREFR_offset] ; write value with valid DRI to MDREFR 
  540 000003a4            
  541 000003a4 e3822a02         orr     r2,  r2, #xlli_MDREFR_K0RUN    ; Enable K0RUN 
  542 000003a8            
  543 000003a8 e3c22901         bic     r2,  r2, #xlli_MDREFR_K0DB2    ; Configure K0DB2 
  544 000003ac            
  545 000003ac e3822202         orr     r2,  r2, #xlli_MDREFR_K0DB4    ; Set K0DB4 = MemClk/4 
  546 000003b0            
  547 000003b0 e3c22403         bic     r2,  r2, #(xlli_MDREFR_K1FREE :OR: xlli_MDREFR_K2FREE)  ; Clear free run clock bits 
  548 000003b4            
  549 000003b4 e3822502         orr     r2,  r2, #xlli_MDREFR_K0FREE   ; Set K0FREE (as per Mainstone spec...) 
  550 000003b8            
  551 000003b8 e5842004         str     r2,  [r4, #xlli_MDREFR_offset] ; Write back MDREFR 
  552 000003bc            
  553 000003bc                  ; 
  554 000003bc                  ; Preserve MDREFR in r2 
  555 000003bc                  ; 
  556 000003bc            
  557 000003bc          ; ***** STEP 2 ***** 
  558 000003bc          ; 
  559 000003bc          ; For systems with Synchronous Flash 
  560 000003bc          ; 
  561 000003bc e59f10ec         ldr     r1,  =xlli_SXCNFG_value 
  562 000003c0 e584101c         str     r1,  [r4, #xlli_SXCNFG_offset] 
  563 000003c4            
  564 000003c4          ; 
  565 000003c4          ; ***** STEP 3 ***** 
  566 000003c4          ; 
  567 000003c4          ; Clear the free run clock bits to enable the use of SDCLK for memory timing 
  568 000003c4          ; 
  569 000003c4 e3c2250e         bic     r2, r2, #(xlli_MDREFR_K2FREE :OR: xlli_MDREFR_K1FREE :OR: xlli_MDREFR_K0FREE) 
  570 000003c8            
  571 000003c8          ; 
  572 000003c8          ; set K1RUN if bank 0 installed 
  573 000003c8          ; 
  574 000003c8 e3822801         orr     r2, r2, #xlli_MDREFR_K1RUN      ; Enable SDCLK[1] 
  575 000003cc e3822802                 orr     r2, r2, #xlli_MDREFR_K1DB2      ; Set K1DB2 to halve Memclk 
  576 000003d0 e3c22702         bic     r2, r2, #xlli_MDREFR_K2DB2      ; Clear K2DB2 
  577 000003d4 e5842004         str     r2, [r4, #xlli_MDREFR_offset]   ; write updated MDREFR 
  578 000003d8 e5942004         ldr     r2, [r4, #xlli_MDREFR_offset]   ; read back 
  579 000003dc            
  580 000003dc e3c22501         bic     r2, r2, #xlli_MDREFR_SLFRSH     ; Disable self refresh 
  581 000003e0 e5842004         str     r2, [r4, #xlli_MDREFR_offset]   ; write updated MDREFR 
  582 000003e4 e5942004         ldr     r2, [r4, #xlli_MDREFR_offset]   ; read back 
  583 000003e8            
  584 000003e8 e3822902         orr     r2, r2, #xlli_MDREFR_E1PIN      ; Assert E1PIN to enable SDCKE[1] 
  585 000003ec e5842004         str     r2, [r4, #xlli_MDREFR_offset]   ; write updated MDREFR (finished with value in r2) 
  586 000003f0 e5942004         ldr     r2, [r4, #xlli_MDREFR_offset]   ; read back 
  587 000003f4            
  588 000003f4 e1a00000         nop                                     ; Do not remove! 
  589 000003f8 e1a00000         nop                                     ; Do not remove! 
  590 000003fc          ; 
  591 000003fc          ; ***** STEP 4 ***** 
  592 000003fc          ; 
  593 000003fc          ; Appropriately configure, but don't enable, each SDRAM partition pair 
  594 000003fc          ; 
  595 000003fc e59f10b0         ldr     r1, =xlli_MDCNFG_value          ; Fetch platform value for MDCNFG 
  596 00000400            
  597 00000400 e3c11003         bic     r1, r1,  #(xlli_MDCNFG_DE0 :OR: xlli_MDCNFG_DE1)   ; Disable all 
  598 00000404 e3c11803         bic     r1, r1,  #(xlli_MDCNFG_DE2 :OR: xlli_MDCNFG_DE3)   ; SDRAM banks 
  599 00000408          ; 
  600 00000408          ;       Check for conditional def for 32 vs 16 bit bus width 
  601 00000408          ; 
  602 00000408                  IF :DEF: xlli_SDRAM_16BIT               ; Set bus width to 16 bits? 
  604 00000408                  ELSE 
  605 00000408 e3c11004         bic     r1, r1,  #xlli_MDCNFG_DWID0     ; Set banks 0/1 for 32 bit width 
  606 0000040c                  ENDIF 
  607 0000040c            
  608 0000040c e3811b02         orr     r1,     r1,     #xlli_BIT_11    ; This reserved bit should always be set 
  609 00000410 e3811302         orr     r1,     r1,     #xlli_BIT_27    ; This reserved bit should always be set 
  610 00000414 e5841000         str     r1, [r4, #xlli_MDCNFG_offset]   ; Write w/o enabling SDRAM banks 
  611 00000418            
  612 00000418          ; 
  613 00000418          ; ***** STEP 5 *****  (Delay at least 200 uS) 
  614 00000418          ; 
  615 00000418 e59f2068         ldr     r2,  =xlli_OSTREGS_PHYSICAL_BASE ; Load OS timer base address 
  616 0000041c e5923010         ldr     r3,  [r2, #xlli_OSCR0_offset]    ; Fetch starting value of OSCR0 
  617 00000420 e2833c03         add     r3,  r3,  #0x300                 ; Really 0x2E1 is about 200usec, so 0x300 should be plenty 
  618 00000424 e5921010 xlli_5  ldr     r1,  [r2, #xlli_OSCR0_offset]    ; Fetch current OSCR0 value 
  619 00000428 e1510003         cmp     r1,  r3                          ; Is the timer past the time out value? 
  620 0000042c 4afffffc         bmi     xlli_5                           ; No - Loop until it is 
  621 00000430          ; 
  622 00000430          ; ***** STEP 6 ***** (Make sure DCACHE is disabled) 
  623 00000430          ; 
  624 00000430 ee112f10         mrc     p15, 0, r2, c1, c0, 0           ; load r2 contents of register 1 in CP 15 
  625 00000434 e3c22004         bic     r2,  r2,  #xlli_CONTROL_DCACHE  ; Disable D-Cache 
  626 00000438 ee012f10         mcr     p15, 0, r2, c1, c0, 0           ; Write back to CP15 
  627 0000043c          ; 
  628 0000043c          ; ***** STEP 7 ***** 
  629 0000043c          ; 
  630 0000043c          ; Access memory *not yet enabled* for CBR refresh cycles (8) 
  631 0000043c          ; - CBR is generated for all banks 
  632 0000043c          ; 
  633 0000043c e3a0120a         ldr     r1, =xlli_SDRAM_PHYSICAL_BASE 
  634 00000440 e5811000         str     r1, [r1] 
  635 00000444 e5811000         str     r1, [r1] 
  636 00000448 e5811000         str     r1, [r1] 
  637 0000044c e5811000         str     r1, [r1] 
  638 00000450 e5811000         str     r1, [r1] 
  639 00000454 e5811000         str     r1, [r1] 
  640 00000458 e5811000         str     r1, [r1] 
  641 0000045c e5811000         str     r1, [r1] 
  642 00000460            
  643 00000460 e5811000         str     r1, [r1]  ;  Fix for erratum #116. Makes up for ineffective 1st mem access. 
  644 00000464                                    ;  This is being left in for Bulverde for the moment 
  645 00000464          ; 
  646 00000464          ; ***** STEP 8 ***** 
  647 00000464          ; 
  648 00000464          ;  Re-enable D-cache if desired (we don't) 
  649 00000464            
  650 00000464          ; 
  651 00000464          ; ***** STEP 9 ***** 
  652 00000464          ; 
  653 00000464          ; Re-enable SDRAM partitions 
  654 00000464          ; 
  655 00000464 e5942000         ldr     r2,  [r4, #xlli_MDCNFG_offset]   ; Fetch the current MDCNFG value 
  656 00000468            
  657 00000468                  IF :DEF: SDRAM_SIZE_64_MB                
  659 00000468                  ELSE 
  660 00000468 e3822003         orr     r2,  r2,  #(xlli_MDCNFG_DE0 :OR: xlli_MDCNFG_DE1)     ; Enable SDRAM bank 0 & 1 
  661 0000046c                  ENDIF 
  662 0000046c                   
  663 0000046c e5842000         str     r2,  [r4, #xlli_MDCNFG_offset]   ; Write back MDCNFG, enabling the SDRAM bank(s) 
  664 00000470          ; 
  665 00000470          ; ***** STEP 10 ***** 
  666 00000470          ; 
  667 00000470          ; Write the MDMRS register to trigger an MRS command to all enabled banks of SDRAM. 
  668 00000470          ; 
  669 00000470          ; 
  670 00000470 e3a01000         ldr     r1,  =xlli_MDMRS_value           ; Fetch platform MDMRS value 
  671 00000474 e5841040         str     r1,  [r4, #xlli_MDMRS_offset]    ; Write the MDMRS value back 
  672 00000478          ; 
  673 00000478          ; ***** STEP 11 ***** 
  674 00000478          ; 
  675 00000478          ; In systems with SDRAM or Synchronous Flash, optionally enable auto-power-down by setting MDREFR:APD 
  676 00000478          ; 
  677 00000478 e5943004         ldr     r3,  [r4, #xlli_MDREFR_offset]   ; Get MDREFR value 
  678 0000047c e3833601         orr     r3,  r3,  #xlli_MDREFR_APD       ; enable auto power down 
  679 00000480 e5843004         str     r3,  [r4, #xlli_MDREFR_offset]   ; Write value back 
  680 00000484            
  681 00000484 e1a0f00e         mov     pc,  lr                         ; return to calling routine 
  682 00000488            
  683 00000488                  ENDFUNC 
  684 00000488            
  685 00000488 40a00000 *literal pool: constant 
  685 0000048c 40e00000 *literal pool: constant 
  685 00000490 7ff0b8f2 *literal pool: constant 
  685 00000494 23f2b8f2 *literal pool: constant 
  685 00000498 0000ccd1 *literal pool: constant 
  685 0000049c 0000b884 *literal pool: constant 
  685 000004a0 00014307 *literal pool: constant 
  685 000004a4 0001c787 *literal pool: constant 
  685 000004a8 000d4b3f *literal pool: constant 
  685 000004ac 00010001 *literal pool: constant 
  685 000004b0 40044004 *literal pool: constant 
  685 000004b4 00000ac8 *literal pool: constant 
  685 00000488                  LTORG 
  686 000004b8            
  687 000004b8          ;************************************************************************************************** 
  688 000004b8          ; 
  689 000004b8          ; *********************************************** 
  690 000004b8          ; **********                           ********** 
  691 000004b8          ; ********** RESTART MEMORY CONTROLLER ********** 
  692 000004b8          ; **********                           ********** 
  693 000004b8          ; *********************************************** 
  694 000004b8          ; 
  695 000004b8          ; This command restarts the memory controller and should be called after a frequency change sequence 
  696 000004b8          ; or when memory controller settings have been changed (such as xlli_mem_Tmax and xlli_memTopt). 
  697 000004b8          ; 
  698 000004b8            
  699 000004b8          xlli_mem_restart   FUNCTION 
  700 000004b8            
  701 000004b8 e3a04312         ldr     r4,  =xlli_MEMORY_CONFIG_BASE    ; Get memory controller base address 
  702 000004bc e5942004         ldr     r2,  [r4, #xlli_MDREFR_offset]   ; Get MDREFR value 
  703 000004c0 e3c23c01         bic     r3,  r2, #xlli_MDREFR_E0PIN      ; Clear E0PIN to disable SDCKE[0] 
  704 000004c4 e3c33902         bic     r3,  r3, #xlli_MDREFR_E1PIN      ; Clear E1PIN to disable SDCKE[1] 
  705 000004c8 ea000004         b       xlli_5A 
  706 000004cc          ; 
  707 000004cc          ;       The next line should start on a cache line boundary so we don't accidently hang the system 
  708 000004cc          ; 
  709 000004cc 00 00 00         ALIGN   32 
               00 00 00   
               00 00 00   
               00 00 00   
               00 00 00   
               00 00 00   
               00 00       
  710 000004e0 e5843004 xlli_5A str     r3,  [r4, #xlli_MDREFR_offset]   ; Write value back with E0PIN and E1PIN cleared 
  711 000004e4 e5842004         str     r2,  [r4, #xlli_MDREFR_offset]   ; Write value back with E0PIN and E1PIN set 
  712 000004e8          ; 
  713 000004e8          ; Disable all SDRAM banks 
  714 000004e8          ; 
  715 000004e8 e5941000         ldr     r1, [r4, #xlli_MDCNFG_offset]    ; Fetch platform value for MDCNFG 
  716 000004ec e3c11003         bic     r1, r1,  #(xlli_MDCNFG_DE0 :OR: xlli_MDCNFG_DE1)   ; Disable all 
  717 000004f0 e3c11803         bic     r1, r1,  #(xlli_MDCNFG_DE2 :OR: xlli_MDCNFG_DE3)   ; SDRAM banks 
  718 000004f4 e5841000         str     r1, [r4, #xlli_MDCNFG_offset]   ; Write w/o enabling SDRAM banks 
  719 000004f8          ; 
  720 000004f8          ; Access memory *not yet enabled* for CBR refresh cycles (8) 
  721 000004f8          ; - CBR is generated for all banks 
  722 000004f8          ; 
  723 000004f8 e3a0120a         ldr     r1, =xlli_SDRAM_PHYSICAL_BASE 
  724 000004fc e5811000         str     r1, [r1] 
  725 00000500 e5811000         str     r1, [r1] 
  726 00000504 e5811000         str     r1, [r1] 
  727 00000508 e5811000         str     r1, [r1] 
  728 0000050c e5811000         str     r1, [r1] 
  729 00000510 e5811000         str     r1, [r1] 
  730 00000514 e5811000         str     r1, [r1] 
  731 00000518 e5811000         str     r1, [r1] 
  732 0000051c            
  733 0000051c e5811000         str     r1, [r1]  ;  Fix for erratum #116. Makes up for ineffective 1st mem access. 
  734 00000520                                    ;  This is being left in for Bulverde for the moment 
  735 00000520          ; 
  736 00000520          ; Re-enable SDRAM partition(s) 
  737 00000520          ; 
  738 00000520 e5942000         ldr     r2,  [r4, #xlli_MDCNFG_offset]   ; Fetch the current MDCNFG value 
  739 00000524            
  740 00000524                  IF :DEF: SDRAM_SIZE_64_MB                
  742 00000524                  ELSE 
  743 00000524 e3822003         orr     r2,  r2,  #(xlli_MDCNFG_DE0 :OR: xlli_MDCNFG_DE1)       ; Enable SDRAM bank 0 & 1 
  744 00000528                  ENDIF 
  745 00000528                   
  746 00000528 e5842000         str     r2,  [r4, #xlli_MDCNFG_offset]   ; Write back MDCNFG, enabling the SDRAM bank(s) 
  747 0000052c          ; 
  748 0000052c          ; Write the MDMRS register to trigger an MRS command to all enabled banks of SDRAM. 
  749 0000052c          ; 
  750 0000052c          ; 
  751 0000052c e5941040         ldr     r1,  [r4, #xlli_MDMRS_offset]    ; Fetch platform MDMRS value 
  752 00000530 e5841040         str     r1,  [r4, #xlli_MDMRS_offset]    ; Write the MDMRS value back 
  753 00000534          ; 
  754 00000534 e5943004         ldr     r3,  [r4, #xlli_MDREFR_offset]   ; Get MDREFR value 
  755 00000538 e5843004         str     r3,  [r4, #xlli_MDREFR_offset]   ; Write value back 
  756 0000053c            
  757 0000053c e1a0f00e         mov     pc,  lr                         ; return to calling routine 
  758 00000540                  ENDFUNC 
  759 00000540            
  760 00000540            
  761 00000540          ;************************************************************************************************** 
  762 00000540          ; 
  763 00000540          ; ******************************************************** 
  764 00000540          ; **********                                    ********** 
  765 00000540          ; ********** MAXIMIZE MEMORY CONTROLLER VALUES  ********** 
  766 00000540          ; **********                                    ********** 
  767 00000540          ; ******************************************************** 
  768 00000540          ; 
  769 00000540          ; NOTE: This function maximizes the timing values in the memory controller so the frequency change 
  770 00000540          ;       sequence can be done safely without the risk of a system hang. Once the frequency change 
  771 00000540          ;       sequence is complete, xlli__mem_Topt may be called to set the optimal timing values. 
  772 00000540          ; 
  773 00000540          ;       This function does not need to be called if the new MemClk frequency is going to be higher 
  774 00000540          ;       than the present MemClk frequency. However, the overhead of this function is minimal so 
  775 00000540          ;       it is suggested this function be called before any change frequency sequence. 
  776 00000540          ; 
  777 00000540          ;       r1, r2, and r3 are used and not preserved. 
  778 00000540          ; 
  779 00000540          xlli_mem_Tmax   FUNCTION 
  780 00000540            
  781 00000540 e3a01312         ldr     r1,  =xlli_MEMORY_CONFIG_BASE   ; Get memory controller base address 
  782 00000544 e59f35a4         ldr     r3,  =0x7FF07FF0                ; Maximize bits for RDF, RDN and RRR 
  783 00000548          ; 
  784 00000548 e5912008         ldr     r2,  [r1, #xlli_MSC0_offset]    ; Get MSC0 value 
  785 0000054c e1822003         orr     r2,  r2,  r3                    ; Set all the RDF, RDN and RRR bits 
  786 00000550 e5812008         str     r2,  [r1, #xlli_MSC0_offset]    ; Set the new MSC0 value 
  787 00000554 e5912008         ldr     r2,  [r1, #xlli_MSC0_offset]    ; Read MSC0 value back to lock the values 
  788 00000558          ; 
  789 00000558 e591200c         ldr     r2,  [r1, #xlli_MSC1_offset]    ; Get MSC1 value 
  790 0000055c e1822003         orr     r2,  r2,  r3                    ; Set all the RDF, RDN and RRR bits 
  791 00000560 e581200c         str     r2,  [r1, #xlli_MSC1_offset]    ; Set the new MSC1 value 
  792 00000564 e591200c         ldr     r2,  [r1, #xlli_MSC1_offset]    ; Read MSC1 value back to lock the values 
  793 00000568          ; 
  794 00000568 e5912010         ldr     r2,  [r1, #xlli_MSC2_offset]    ; Get MSC2 value 
  795 0000056c e1822003         orr     r2,  r2,  r3                    ; Set all the RDF, RDN and RRR bits 
  796 00000570 e5812010         str     r2,  [r1, #xlli_MSC2_offset]    ; Set the new MSC2 value 
  797 00000574 e5912010         ldr     r2,  [r1, #xlli_MSC2_offset]    ; Read MSC2 value back to lock the values 
  798 00000578          ; 
  799 00000578 e59f3574         ldr     r3,  =0x03000300                ; Set up mask bits for DTC0 and DTC2 
  800 0000057c e5912000         ldr     r2,  [r1, #xlli_MDCNFG_offset]  ; Get present MDCNFG value 
  801 00000580 e1822003         orr     r2,  r2,  r3                    ; Clear the DTC0 and DTC2 bits 
  802 00000584 e5812000         str     r2,  [r1, #xlli_MDCNFG_offset]  ; Write back the MDCNFG value 
  803 00000588          ; 
  804 00000588 e59f3568         ldr     r3,  =0xFFF                     ; Set up mask bits for DRI value 
  805 0000058c e5912004         ldr     r2,  [r1, #xlli_MDREFR_offset]  ; Get present MDREFR value 
  806 00000590 e1c22003         bic     r2,  r2,  r3                    ; Clear all the DRI bits 
  807 00000594 e3822013         orr     r2,  r2,  #0x13                 ; Set to lowest safe value 
  808 00000598 e5812004         str     r2,  [r1, #xlli_MDREFR_offset]  ; Write back the MDREFR value 
  809 0000059c            
  810 0000059c e1a0f00e         mov     pc,  lr                         ; return to calling routine 
  811 000005a0            
  812 000005a0                  ENDFUNC 
  813 000005a0            
  814 000005a0          ;************************************************************************************************** 
  815 000005a0          ; 
  816 000005a0          ; *********************************************************** 
  817 000005a0          ; **********                                       ********** 
  818 000005a0          ; ********** SET OPTIMAL MEMORY CONTROLLER VALUES  ********** 
  819 000005a0          ; **********                                       ********** 
  820 000005a0          ; *********************************************************** 
  821 000005a0          ; 
  822 000005a0          ; NOTE: This function sets the TIMING values in the memory controller to the optimum values based on 
  823 000005a0          ;       the frequency of the MemClk. This function should be called AFTER the frequency change 
  824 000005a0          ;       sequence is complete to get optimal performance out of the memory system. 
  825 000005a0          ; 
  826 000005a0          ;       If changing the core frequency to a value that increases the MemClk speed, it is strongly 
  827 000005a0          ;       suggested that xlli_MSCx_max be called before the frequency change sequence. Once the 
  828 000005a0          ;       frequency chage sequence is complete, this routine may be called to reset the optimal 
  829 000005a0          ;       values for the memory system and the memory controller restarted. 
  830 000005a0          ; 
  831 000005a0          ;       r1 through r8 are used and not preserved. 
  832 000005a0          ; 
  833 000005a0          xlli_mem_Topt   FUNCTION 
  834 000005a0            
  835 000005a0 e59f1554         ldr     r1,  =xlli_CLKREGS_PHYSICAL_BASE  ; Get base address of clock registers 
  836 000005a4 e591200c         ldr     r2,  [r1, #xlli_CCSR_offset]      ; Get current clock status 
  837 000005a8 e202201f         and     r2,  r2,  #0x1F                   ; r2 now contains the CCSR L value 
  838 000005ac            
  839 000005ac e5913000         ldr     r3,  [r1, #xlli_CCCR_offset]      ; Get the current CCCR for the "A" bit 
  840 000005b0 e2033402         and     r3,  r3,  #xlli_CCCR_A_Bit_Mask 
  841 000005b4 e1a03ca3         mov     r3,  r3,  LSR #25                 ; Move down to bit position 0 to make comparison easy 
  842 000005b8          ; 
  843 000005b8          ;       Check for the "B" bit from CCCR (CP14,R6) 
  844 000005b8          ; 
  845 000005b8 ee161e10         mrc     p14, 0, r1, c6, c0, 0    ; Get data in CP14, Register 6 
  846 000005bc e2011008         and     r1,  r1,  #0x8           ; Grab just the "B" bit 
  847 000005c0 e1a01121         mov     r1,  r1,  LSR #2         ; move it to bit position 1 
  848 000005c4 e1839001         orr     r9, r3, r1               ; At this point r9 contains the A-bit at pos. 0 & B-bit at pos. 1 
  849 000005c8            
  850 000005c8 e3a01312         ldr     r1,  =xlli_MEMORY_CONFIG_BASE     ; Load r1 with memory controller base address 
  851 000005cc          ; 
  852 000005cc          ;       The MemClk speed is determined by the L, A and B values. 
  853 000005cc          ;       Unfortunaly, the only practical way to do this is to rip through all the legal 
  854 000005cc          ;       values and load a register when there is a match. Illegal values result in no change 
  855 000005cc          ; 
  856 000005cc e59f351c         ldr     r3,  =0x7FF07FF0                ; Bit mask for RDF, RDN and RRR (MSC0) 
  857 000005d0 e5914008         ldr     r4,  [r1, #xlli_MSC0_offset]    ; Get present MSC0 value 
  858 000005d4 e1c44003         bic     r4,  r4,  r3                    ; Clear the RDF, RDN and RRR bits 
  859 000005d8            
  860 000005d8 e59f5514         ldr     r5,  =0x03000300                ; DTC0, DTC2 and RESERVED bit mask (MDCNFG) 
  861 000005dc e5916000         ldr     r6,  [r1, #xlli_MDCNFG_offset]  ; Get present MDCNFG value 
  862 000005e0 e1c66005         bic     r6,  r6,  r5                    ; Clear DTC0 and DTC2 
  863 000005e4 e3a05000         mov     r5,  #0                         ; Clear r5 
  864 000005e8            
  865 000005e8 e59f7510         ldr     r7,  =0xC0200FFF                ; DRI and RESERVED bit mask (MDREFR) 
  866 000005ec e5918004         ldr     r8,  [r1, #xlli_MDREFR_offset]  ; Get present MDREFR value 
  867 000005f0 e1c88007         bic     r8,  r8,  r7                    ; Clear DRI and RESERVED bits 
  868 000005f4 e59f74fc         ldr     r7,  = 0xFFF                    ; Reload r7 with POR DRI value 
  869 000005f8          ; 
  870 000005f8          ;       r9 =  0x0:  A=0, B=0 
  871 000005f8          ;             0x1:  A=1, B=0 
  872 000005f8          ;             0x2:  A=0, B=1 
  873 000005f8          ;             0x3:  A=1, B=1 
  874 000005f8          ; 
  875 000005f8 e3590001         cmp     r9, #0x1                         ; A == 1, B == 0 ? 
  876 000005fc 0a00007a         beq     xlli_A1B0_Table 
  877 00000600            
  878 00000600 e3590003         cmp     r9, #0x3                         ; A == 1, B == 1 ? 
  879 00000604 0a0000f1         beq     xlli_A1B1_Table 
  880 00000608          ; 
  881 00000608          ;       Else drop through to A=0, B=x table 
  882 00000608          ; 
  883 00000608          xlli_A0Bx_Table 
  884 00000608 e3520002         cmp     r2,  #2              ; Is L=2? 
  885 0000060c 059f34f0         ldreq   r3,  =xlli_MSC0_26   ; Yes - load values 
  886 00000610 03a05000         ldreq   r5,  =xlli_DTC_26 
  887 00000614 03a07005         ldreq   r7,  =xlli_DRI_26 
  888 00000618 e3520003         cmp     r2,  #3              ; Is L=3? 
  889 0000061c 059f34e4         ldreq   r3,  =xlli_MSC0_39   ; Yes - load values 
  890 00000620 03a05000         ldreq   r5,  =xlli_DTC_39 
  891 00000624 03a07008         ldreq   r7,  =xlli_DRI_39 
  892 00000628 e3520004         cmp     r2,  #4              ; Is L=4? 
  893 0000062c 059f34d8         ldreq   r3,  =xlli_MSC0_52   ; Yes - load values 
  894 00000630 03a05000         ldreq   r5,  =xlli_DTC_52 
  895 00000634 03a0700b         ldreq   r7,  =xlli_DRI_52 
  896 00000638 e3520005         cmp     r2,  #5              ; Is L=5? 
  897 0000063c 059f34cc         ldreq   r3,  =xlli_MSC0_65   ; Yes - load values 
  898 00000640 059f54cc         ldreq   r5,  =xlli_DTC_65 
  899 00000644 03a0700e         ldreq   r7,  =xlli_DRI_65 
  900 00000648 e3520006         cmp     r2,  #6              ; Is L=6? 
  901 0000064c 059f34c4         ldreq   r3,  =xlli_MSC0_78   ; Yes - load values 
  902 00000650 059f54bc         ldreq   r5,  =xlli_DTC_78 
  903 00000654 03a07012         ldreq   r7,  =xlli_DRI_78 
  904 00000658 e3520007         cmp     r2,  #7              ; Is L=7? 
  905 0000065c 059f34b8         ldreq   r3,  =xlli_MSC0_91   ; Yes - load values 
  906 00000660 059f54b8         ldreq   r5,  =xlli_DTC_91 
  907 00000664 03a07015         ldreq   r7,  =xlli_DRI_91 
  908 00000668 e3520008         cmp     r2,  #8              ; Is L=8? 
  909 0000066c 059f34b0         ldreq   r3,  =xlli_MSC0_104  ; Yes - load values 
  910 00000670 059f54a8         ldreq   r5,  =xlli_DTC_104 
  911 00000674 03a07018         ldreq   r7,  =xlli_DRI_104 
  912 00000678 e3520009         cmp     r2,  #9              ; Is L=9? 
  913 0000067c 059f34a4         ldreq   r3,  =xlli_MSC0_117  ; Yes - load values 
  914 00000680 059f548c         ldreq   r5,  =xlli_DTC_117 
  915 00000684 03a0701b         ldreq   r7,  =xlli_DRI_117 
  916 00000688            
  917 00000688 e352000a         cmp     r2,  #10             ; Is L=10? 
  918 0000068c 059f3498         ldreq   r3,  =xlli_MSC0_130  ; Yes - load values 
  919 00000690 059f547c         ldreq   r5,  =xlli_DTC_130 
  920 00000694 03a0701e         ldreq   r7,  =xlli_DRI_130 
  921 00000698 e352000b         cmp     r2,  #11             ; Is L=11? 
  922 0000069c 059f3474         ldreq   r3,  =xlli_MSC0_71   ; Yes - load values 
  923 000006a0 059f546c         ldreq   r5,  =xlli_DTC_71 
  924 000006a4 03a07010         ldreq   r7,  =xlli_DRI_71 
  925 000006a8 e352000c         cmp     r2,  #12             ; Is L=12? 
  926 000006ac 059f3464         ldreq   r3,  =xlli_MSC0_78   ; Yes - load values 
  927 000006b0 059f545c         ldreq   r5,  =xlli_DTC_78 
  928 000006b4 03a07012         ldreq   r7,  =xlli_DRI_78 
  929 000006b8 e352000d         cmp     r2,  #13             ; Is L=13? 
  930 000006bc 059f3458         ldreq   r3,  =xlli_MSC0_84   ; Yes - load value 
  931 000006c0 059f544c         ldreq   r5,  =xlli_DTC_84 
  932 000006c4 03a07013         ldreq   r7,  =xlli_DRI_84 
  933 000006c8 e352000e         cmp     r2,  #14             ; Is L=14? 
  934 000006cc 059f3448         ldreq   r3,  =xlli_MSC0_91   ; Yes - load values 
  935 000006d0 059f5448         ldreq   r5,  =xlli_DTC_91 
  936 000006d4 03a07015         ldreq   r7,  =xlli_DRI_91 
  937 000006d8 e352000f         cmp     r2,  #15             ; Is L=15? 
  938 000006dc 059f344c         ldreq   r3,  =xlli_MSC0_97   ; Yes - load values 
  939 000006e0 059f5438         ldreq   r5,  =xlli_DTC_97 
  940 000006e4 03a07016         ldreq   r7,  =xlli_DRI_97 
  941 000006e8            
  942 000006e8 e3520010         cmp     r2,  #16             ; Is L=16? 
  943 000006ec 059f3430         ldreq   r3,  =xlli_MSC0_104  ; Yes - load values 
  944 000006f0 059f5428         ldreq   r5,  =xlli_DTC_104 
  945 000006f4 03a07018         ldreq   r7,  =xlli_DRI_104 
  946 000006f8 e3520011         cmp     r2,  #17             ; Is L=17? 
  947 000006fc 059f3430         ldreq   r3,  =xlli_MSC0_110  ; Yes - load values 
  948 00000700 059f540c         ldreq   r5,  =xlli_DTC_110 
  949 00000704 03a0701a         ldreq   r7,  =xlli_DRI_110 
  950 00000708 e3520012         cmp     r2,  #18             ; Is L=18? 
  951 0000070c 059f3414         ldreq   r3,  =xlli_MSC0_117  ; Yes - load values 
  952 00000710 059f53fc         ldreq   r5,  =xlli_DTC_117 
  953 00000714 03a0701b         ldreq   r7,  =xlli_DRI_117 
  954 00000718 e3520013         cmp     r2,  #19             ; Is L=19? 
  955 0000071c 059f3404         ldreq   r3,  =xlli_MSC0_124  ; Yes - load values 
  956 00000720 059f53ec         ldreq   r5,  =xlli_DTC_124 
  957 00000724 03a0701d         ldreq   r7,  =xlli_DRI_124 
  958 00000728 e3520014         cmp     r2,  #20             ; Is L=20? 
  959 0000072c 059f33f8         ldreq   r3,  =xlli_MSC0_130  ; Yes - load values 
  960 00000730 059f53dc         ldreq   r5,  =xlli_DTC_130 
  961 00000734 03a0701e         ldreq   r7,  =xlli_DRI_130 
  962 00000738            
  963 00000738 e3520015         cmp     r2,  #21             ; Is L=21? 
  964 0000073c 059f33cc         ldreq   r3,  =xlli_MSC0_68  ; Yes - load values 
  965 00000740 059f53cc         ldreq   r5,  =xlli_DTC_68 
  966 00000744 03a0700f         ldreq   r7,  =xlli_DRI_68 
  967 00000748 e3520016         cmp     r2,  #22             ; Is L=22? 
  968 0000074c 059f33c4         ldreq   r3,  =xlli_MSC0_71  ; Yes - load values 
  969 00000750 059f53bc         ldreq   r5,  =xlli_DTC_71 
  970 00000754 03a07010         ldreq   r7,  =xlli_DRI_71 
  971 00000758 e3520017         cmp     r2,  #23             ; Is L=23? 
  972 0000075c 059f33b4         ldreq   r3,  =xlli_MSC0_74  ; Yes - load values 
  973 00000760 059f53ac         ldreq   r5,  =xlli_DTC_74 
  974 00000764 03a07011         ldreq   r7,  =xlli_DRI_74 
  975 00000768 e3520018         cmp     r2,  #24             ; Is L=24? 
  976 0000076c 059f33a4         ldreq   r3,  =xlli_MSC0_78  ; Yes - load values 
  977 00000770 059f539c         ldreq   r5,  =xlli_DTC_78 
  978 00000774 03a07012         ldreq   r7,  =xlli_DRI_78 
  979 00000778 e3520019         cmp     r2,  #25             ; Is L=25? 
  980 0000077c 059f3398         ldreq   r3,  =xlli_MSC0_81  ; Yes - load values 
  981 00000780 059f538c         ldreq   r5,  =xlli_DTC_81 
  982 00000784 03a07012         ldreq   r7,  =xlli_DRI_81 
  983 00000788            
  984 00000788 e352001a         cmp     r2,  #26             ; Is L=26? 
  985 0000078c 059f3388         ldreq   r3,  =xlli_MSC0_84  ; Yes - load values 
  986 00000790 059f537c         ldreq   r5,  =xlli_DTC_84 
  987 00000794 03a07013         ldreq   r7,  =xlli_DRI_84 
  988 00000798 e352001b         cmp     r2,  #27             ; Is L=27? 
  989 0000079c 059f3378         ldreq   r3,  =xlli_MSC0_87  ; Yes - load values 
  990 000007a0 059f536c         ldreq   r5,  =xlli_DTC_87 
  991 000007a4 03a07014         ldreq   r7,  =xlli_DRI_87 
  992 000007a8 e352001c         cmp     r2,  #28             ; Is L=28? 
  993 000007ac 059f3368         ldreq   r3,  =xlli_MSC0_91  ; Yes - load values 
  994 000007b0 059f5368         ldreq   r5,  =xlli_DTC_91 
  995 000007b4 03a07015         ldreq   r7,  =xlli_DRI_91 
  996 000007b8 e352001d         cmp     r2,  #29             ; Is L=29? 
  997 000007bc 059f336c         ldreq   r3,  =xlli_MSC0_94   ; Yes - load values 
  998 000007c0 059f5358         ldreq   r5,  =xlli_DTC_94 
  999 000007c4 03a07016         ldreq   r7,  =xlli_DRI_94 
 1000 000007c8 e352001e         cmp     r2,  #30             ; Is L=30? 
 1001 000007cc 059f335c         ldreq   r3,  =xlli_MSC0_97   ; Yes - load values 
 1002 000007d0 059f5348         ldreq   r5,  =xlli_DTC_97 
 1003 000007d4 03a07016         ldreq   r7,  =xlli_DRI_97 
 1004 000007d8 e352001f         cmp     r2,  #31             ; Is L=31? 
 1005 000007dc 059f3340         ldreq   r3,  =xlli_MSC0_100  ; Yes - load values 
 1006 000007e0 059f5338         ldreq   r5,  =xlli_DTC_100 
 1007 000007e4 03a07017         ldreq   r7,  =xlli_DRI_100 
 1008 000007e8            
 1009 000007e8 ea0000b4         b XLLI_Done_MSC0_Opt_Update 
 1010 000007ec            
 1011 000007ec          xlli_A1B0_Table 
 1012 000007ec            
 1013 000007ec e3520002         cmp     r2,  #2              ; Is L=2? 
 1014 000007f0 059f3340         ldreq   r3,  =xlli_MSC0_13   ; Yes - load values 
 1015 000007f4 03a05000         ldreq   r5,  =xlli_DTC_13 
 1016 000007f8 03a07002         ldreq   r7,  =xlli_DRI_13 
 1017 000007fc e3520003         cmp     r2,  #3              ; Is L=3? 
 1018 00000800 059f3330         ldreq   r3,  =xlli_MSC0_19   ; Yes - load values 
 1019 00000804 03a05000         ldreq   r5,  =xlli_DTC_19 
 1020 00000808 03a07003         ldreq   r7,  =xlli_DRI_19 
 1021 0000080c e3520004         cmp     r2,  #4              ; Is L=4? 
 1022 00000810 059f32ec         ldreq   r3,  =xlli_MSC0_26   ; Yes - load values 
 1023 00000814 03a05000         ldreq   r5,  =xlli_DTC_26 
 1024 00000818 03a07005         ldreq   r7,  =xlli_DRI_26 
 1025 0000081c e3520005         cmp     r2,  #5              ; Is L=5? 
 1026 00000820 059f32dc         ldreq   r3,  =xlli_MSC0_32   ; Yes - load values 
 1027 00000824 03a05000         ldreq   r5,  =xlli_DTC_32 
 1028 00000828 03a07006         ldreq   r7,  =xlli_DRI_32 
 1029 0000082c e3520006         cmp     r2,  #6              ; Is L=6? 
 1030 00000830 059f32d0         ldreq   r3,  =xlli_MSC0_39   ; Yes - load values 
 1031 00000834 03a05000         ldreq   r5,  =xlli_DTC_39 
 1032 00000838 03a07008         ldreq   r7,  =xlli_DRI_39 
 1033 0000083c e3520007         cmp     r2,  #7              ; Is L=7? 
 1034 00000840 059f32c0         ldreq   r3,  =xlli_MSC0_45   ; Yes - load values 
 1035 00000844 03a05000         ldreq   r5,  =xlli_DTC_45 
 1036 00000848 03a0700a         ldreq   r7,  =xlli_DRI_45 
 1037 0000084c            
 1038 0000084c e3520008         cmp     r2,  #8              ; Is L=8? 
 1039 00000850 059f32b4         ldreq   r3,  =xlli_MSC0_52  ; Yes - load values 
 1040 00000854 03a05000         ldreq   r5,  =xlli_DTC_52 
 1041 00000858 03a0700b         ldreq   r7,  =xlli_DRI_52 
 1042 0000085c e3520009         cmp     r2,  #9              ; Is L=9? 
 1043 00000860 059f32d4         ldreq   r3,  =xlli_MSC0_58  ; Yes - load values 
 1044 00000864 059f52a8         ldreq   r5,  =xlli_DTC_58 
 1045 00000868 03a0700d         ldreq   r7,  =xlli_DRI_58 
 1046 0000086c            
 1047 0000086c e352000a         cmp     r2,  #10             ; Is L=10? 
 1048 00000870 059f3298         ldreq   r3,  =xlli_MSC0_65  ; Yes - load values 
 1049 00000874 059f5298         ldreq   r5,  =xlli_DTC_65 
 1050 00000878 03a0700e         ldreq   r7,  =xlli_DRI_65 
 1051 0000087c          ; 
 1052 0000087c          ;       L11 - L20 ARE THE SAME for A0Bx 
 1053 0000087c          ; 
 1054 0000087c e352000b         cmp     r2,  #11             ; Is L=11? 
 1055 00000880 059f3290         ldreq   r3,  =xlli_MSC0_71   ; Yes - load values 
 1056 00000884 059f5288         ldreq   r5,  =xlli_DTC_71 
 1057 00000888 03a07010         ldreq   r7,  =xlli_DRI_71 
 1058 0000088c e352000c         cmp     r2,  #12             ; Is L=12? 
 1059 00000890 059f3280         ldreq   r3,  =xlli_MSC0_78   ; Yes - load values 
 1060 00000894 059f5278         ldreq   r5,  =xlli_DTC_78 
 1061 00000898 03a07012         ldreq   r7,  =xlli_DRI_78 
 1062 0000089c e352000d         cmp     r2,  #13             ; Is L=13? 
 1063 000008a0 059f3274         ldreq   r3,  =xlli_MSC0_84   ; Yes - load values 
 1064 000008a4 059f5268         ldreq   r5,  =xlli_DTC_84 
 1065 000008a8 03a07013         ldreq   r7,  =xlli_DRI_84 
 1066 000008ac e352000e         cmp     r2,  #14             ; Is L=14? 
 1067 000008b0 059f3264         ldreq   r3,  =xlli_MSC0_91   ; Yes - load values 
 1068 000008b4 059f5264         ldreq   r5,  =xlli_DTC_91 
 1069 000008b8 03a07015         ldreq   r7,  =xlli_DRI_91 
 1070 000008bc e352000f         cmp     r2,  #15             ; Is L=15? 
 1071 000008c0 059f3268         ldreq   r3,  =xlli_MSC0_97   ; Yes - load values 
 1072 000008c4 059f5254         ldreq   r5,  =xlli_DTC_97 
 1073 000008c8 03a07016         ldreq   r7,  =xlli_DRI_97 
 1074 000008cc e3520010         cmp     r2,  #16             ; Is L=16? 
 1075 000008d0 059f324c         ldreq   r3,  =xlli_MSC0_104  ; Yes - load values 
 1076 000008d4 059f5244         ldreq   r5,  =xlli_DTC_104 
 1077 000008d8 03a07018         ldreq   r7,  =xlli_DRI_104 
 1078 000008dc e3520011         cmp     r2,  #17             ; Is L=17? 
 1079 000008e0 059f324c         ldreq   r3,  =xlli_MSC0_110  ; Yes - load values 
 1080 000008e4 059f5228         ldreq   r5,  =xlli_DTC_110 
 1081 000008e8 03a0701a         ldreq   r7,  =xlli_DRI_110 
 1082 000008ec e3520012         cmp     r2,  #18             ; Is L=18? 
 1083 000008f0 059f3230         ldreq   r3,  =xlli_MSC0_117  ; Yes - load values 
 1084 000008f4 059f5218         ldreq   r5,  =xlli_DTC_117 
 1085 000008f8 03a0701b         ldreq   r7,  =xlli_DRI_117 
 1086 000008fc e3520013         cmp     r2,  #19             ; Is L=19? 
 1087 00000900 059f3220         ldreq   r3,  =xlli_MSC0_124  ; Yes - load values 
 1088 00000904 059f5208         ldreq   r5,  =xlli_DTC_124 
 1089 00000908 03a0701d         ldreq   r7,  =xlli_DRI_124 
 1090 0000090c e3520014         cmp     r2,  #20             ; Is L=20? 
 1091 00000910 059f3214         ldreq   r3,  =xlli_MSC0_130  ; Yes - load values 
 1092 00000914 059f51f8         ldreq   r5,  =xlli_DTC_130 
 1093 00000918 03a0701e         ldreq   r7,  =xlli_DRI_130 
 1094 0000091c            
 1095 0000091c e3520015         cmp     r2,  #21             ; Is L=21? 
 1096 00000920 059f3218         ldreq   r3,  =xlli_MSC0_136  ; Yes - load values 
 1097 00000924 059f51e8         ldreq   r5,  =xlli_DTC_136 
 1098 00000928 03a07020         ldreq   r7,  =xlli_DRI_136 
 1099 0000092c e3520016         cmp     r2,  #22             ; Is L=22? 
 1100 00000930 059f320c         ldreq   r3,  =xlli_MSC0_143  ; Yes - load values 
 1101 00000934 059f51d8         ldreq   r5,  =xlli_DTC_143 
 1102 00000938 03a07021         ldreq   r7,  =xlli_DRI_143 
 1103 0000093c e3520017         cmp     r2,  #23             ; Is L=23? 
 1104 00000940 059f31fc         ldreq   r3,  =xlli_MSC0_149  ; Yes - load values 
 1105 00000944 059f51c8         ldreq   r5,  =xlli_DTC_149 
 1106 00000948 03a07023         ldreq   r7,  =xlli_DRI_149 
 1107 0000094c e3520018         cmp     r2,  #24             ; Is L=24? 
 1108 00000950 059f31ec         ldreq   r3,  =xlli_MSC0_156  ; Yes - load values 
 1109 00000954 059f51b8         ldreq   r5,  =xlli_DTC_156 
 1110 00000958 03a07025         ldreq   r7,  =xlli_DRI_156 
 1111 0000095c e3520019         cmp     r2,  #25             ; Is L=25? 
 1112 00000960 059f31dc         ldreq   r3,  =xlli_MSC0_162  ; Yes - load values 
 1113 00000964 059f51a8         ldreq   r5,  =xlli_DTC_162 
 1114 00000968 03a07026         ldreq   r7,  =xlli_DRI_162 
 1115 0000096c            
 1116 0000096c e352001a         cmp     r2,  #26             ; Is L=26? 
 1117 00000970 059f31d0         ldreq   r3,  =xlli_MSC0_169  ; Yes - load values 
 1118 00000974 059f5198         ldreq   r5,  =xlli_DTC_169 
 1119 00000978 03a07028         ldreq   r7,  =xlli_DRI_169 
 1120 0000097c e352001b         cmp     r2,  #27             ; Is L=27? 
 1121 00000980 059f31c4         ldreq   r3,  =xlli_MSC0_175  ; Yes - load values 
 1122 00000984 059f5188         ldreq   r5,  =xlli_DTC_175 
 1123 00000988 03a07029         ldreq   r7,  =xlli_DRI_175 
 1124 0000098c e352001c         cmp     r2,  #28             ; Is L=28? 
 1125 00000990 059f31b4         ldreq   r3,  =xlli_MSC0_182  ; Yes - load values 
 1126 00000994 059f5184         ldreq   r5,  =xlli_DTC_182 
 1127 00000998 03a0702b         ldreq   r7,  =xlli_DRI_182 
 1128 0000099c e352001d         cmp     r2,  #29             ; Is L=29? 
 1129 000009a0 059f31a0         ldreq   r3,  =xlli_MSC0_188   ; Yes - load values 
 1130 000009a4 059f5174         ldreq   r5,  =xlli_DTC_188 
 1131 000009a8 03a0702d         ldreq   r7,  =xlli_DRI_188 
 1132 000009ac e352001e         cmp     r2,  #30             ; Is L=30? 
 1133 000009b0 059f3198         ldreq   r3,  =xlli_MSC0_195   ; Yes - load values 
 1134 000009b4 059f5164         ldreq   r5,  =xlli_DTC_195 
 1135 000009b8 03a0702e         ldreq   r7,  =xlli_DRI_195 
 1136 000009bc e352001f         cmp     r2,  #31             ; Is L=31? 
 1137 000009c0 059f318c         ldreq   r3,  =xlli_MSC0_201  ; Yes - load values 
 1138 000009c4 059f5154         ldreq   r5,  =xlli_DTC_201 
 1139 000009c8 03a07030         ldreq   r7,  =xlli_DRI_201 
 1140 000009cc            
 1141 000009cc ea00003b         b XLLI_Done_MSC0_Opt_Update 
 1142 000009d0            
 1143 000009d0            
 1144 000009d0          xlli_A1B1_Table 
 1145 000009d0 e3520002         cmp     r2,  #2              ; Is L=2? 
 1146 000009d4 059f3128         ldreq   r3,  =xlli_MSC0_26   ; Yes - load values 
 1147 000009d8 03a05000         ldreq   r5,  =xlli_DTC_26 
 1148 000009dc 03a07005         ldreq   r7,  =xlli_DRI_26 
 1149 000009e0 e3520003         cmp     r2,  #3              ; Is L=3? 
 1150 000009e4 059f311c         ldreq   r3,  =xlli_MSC0_39   ; Yes - load values 
 1151 000009e8 03a05000         ldreq   r5,  =xlli_DTC_39 
 1152 000009ec 03a07008         ldreq   r7,  =xlli_DRI_39 
 1153 000009f0 e3520004         cmp     r2,  #4              ; Is L=4? 
 1154 000009f4 059f3110         ldreq   r3,  =xlli_MSC0_52   ; Yes - load values 
 1155 000009f8 03a05000         ldreq   r5,  =xlli_DTC_52 
 1156 000009fc 03a0700b         ldreq   r7,  =xlli_DRI_52 
 1157 00000a00 e3520005         cmp     r2,  #5              ; Is L=5? 
 1158 00000a04 059f3104         ldreq   r3,  =xlli_MSC0_65   ; Yes - load values 
 1159 00000a08 059f5104         ldreq   r5,  =xlli_DTC_65 
 1160 00000a0c 03a0700e         ldreq   r7,  =xlli_DRI_65 
 1161 00000a10 e3520006         cmp     r2,  #6              ; Is L=6? 
 1162 00000a14 059f30fc         ldreq   r3,  =xlli_MSC0_78   ; Yes - load values 
 1163 00000a18 059f50f4         ldreq   r5,  =xlli_DTC_78 
 1164 00000a1c 03a07012         ldreq   r7,  =xlli_DRI_78 
 1165 00000a20 e3520007         cmp     r2,  #7              ; Is L=7? 
 1166 00000a24 059f30f0         ldreq   r3,  =xlli_MSC0_91   ; Yes - load values 
 1167 00000a28 059f50f0         ldreq   r5,  =xlli_DTC_91 
 1168 00000a2c 03a07015         ldreq   r7,  =xlli_DRI_91 
 1169 00000a30 e3520008         cmp     r2,  #8              ; Is L=8? 
 1170 00000a34 059f30e8         ldreq   r3,  =xlli_MSC0_104  ; Yes - load values 
 1171 00000a38 059f50e0         ldreq   r5,  =xlli_DTC_104 
 1172 00000a3c 03a07018         ldreq   r7,  =xlli_DRI_104 
 1173 00000a40 e3520009         cmp     r2,  #9              ; Is L=9? 
 1174 00000a44 059f30dc         ldreq   r3,  =xlli_MSC0_117  ; Yes - load values 
 1175 00000a48 059f50c4         ldreq   r5,  =xlli_DTC_117 
 1176 00000a4c 03a0701b         ldreq   r7,  =xlli_DRI_117 
 1177 00000a50            
 1178 00000a50 e352000a         cmp     r2,  #10             ; Is L=10? 
 1179 00000a54 059f30d0         ldreq   r3,  =xlli_MSC0_130  ; Yes - load values 
 1180 00000a58 059f50b4         ldreq   r5,  =xlli_DTC_130 
 1181 00000a5c 03a0701e         ldreq   r7,  =xlli_DRI_130 
 1182 00000a60 e352000b         cmp     r2,  #11             ; Is L=11? 
 1183 00000a64 059f30d8         ldreq   r3,  =xlli_MSC0_143   ; Yes - load values 
 1184 00000a68 059f50a4         ldreq   r5,  =xlli_DTC_143 
 1185 00000a6c 03a07021         ldreq   r7,  =xlli_DRI_143 
 1186 00000a70 e352000c         cmp     r2,  #12             ; Is L=12? 
 1187 00000a74 059f30c8         ldreq   r3,  =xlli_MSC0_156   ; Yes - load values 
 1188 00000a78 059f5094         ldreq   r5,  =xlli_DTC_156 
 1189 00000a7c 03a07025         ldreq   r7,  =xlli_DRI_156 
 1190 00000a80 e352000d         cmp     r2,  #13             ; Is L=13? 
 1191 00000a84 059f30bc         ldreq   r3,  =xlli_MSC0_169   ; Yes - load values 
 1192 00000a88 059f5084         ldreq   r5,  =xlli_DTC_169 
 1193 00000a8c 03a07028         ldreq   r7,  =xlli_DRI_169 
 1194 00000a90 e352000e         cmp     r2,  #14             ; Is L=14? 
 1195 00000a94 059f30b0         ldreq   r3,  =xlli_MSC0_182   ; Yes - load values 
 1196 00000a98 059f5080         ldreq   r5,  =xlli_DTC_182 
 1197 00000a9c 03a0702b         ldreq   r7,  =xlli_DRI_182 
 1198 00000aa0 e352000f         cmp     r2,  #15             ; Is L=15? 
 1199 00000aa4 059f30a4         ldreq   r3,  =xlli_MSC0_195   ; Yes - load values 
 1200 00000aa8 059f5070         ldreq   r5,  =xlli_DTC_195 
 1201 00000aac 03a0702e         ldreq   r7,  =xlli_DRI_195 
 1202 00000ab0            
 1203 00000ab0 e3520010         cmp     r2,  #16             ; Is L=16? 
 1204 00000ab4 059f3098         ldreq   r3,  =xlli_MSC0_208  ; Yes - load values 
 1205 00000ab8 059f5060         ldreq   r5,  =xlli_DTC_208 
 1206 00000abc 03a07031         ldreq   r7,  =xlli_DRI_208 
 1207 00000ac0            
 1208 00000ac0          XLLI_Done_MSC0_Opt_Update 
 1209 00000ac0          ; 
 1210 00000ac0          ;       Update MSC0 
 1211 00000ac0          ; 
 1212 00000ac0 e1844003         orr     r4,  r4,  r3                    ; Update the RDF, RDN and RRR bits 
 1213 00000ac4 e5814008         str     r4,  [r1, #xlli_MSC0_offset]    ; Set the new MSC0 value 
 1214 00000ac8 e5914008         ldr     r4,  [r1, #xlli_MSC0_offset]    ; Read MSC0 value back to lock the values 
 1215 00000acc          ; 
 1216 00000acc          ;       Update DRI bits 
 1217 00000acc          ; 
 1218 00000acc e1888007         orr     r8,  r8,  r7                    ; Update the DRI bits 
 1219 00000ad0 e5818004         str     r8,  [r1, #xlli_MDREFR_offset]  ; Set the new MDREFR value 
 1220 00000ad4          ; 
 1221 00000ad4          ;       if SDClk = MemClk, (K1DB2=0) shift the DTC data to the right by 1 bit 
 1222 00000ad4          ; 
 1223 00000ad4 e59f4038         ldr     r4,  =0x01000100                ; DTC mask bits (only need low order DTC bit) 
 1224 00000ad8 e2188802         ands    r8,  r8,   #xlli_MDREFR_K1DB2   ; Test K1DB2 bit (does SDCLK[1] = MemClk freq?) 
 1225 00000adc 11a050a5         movne   r5,  r5, LSR #1                 ; Shift DTC right by 1 bit (divide by 2) 
 1226 00000ae0 10055004         andne   r5,  r5,  r4                    ; r5 now contains the new DTC value 
 1227 00000ae4 e1866005         orr     r6,  r6,  r5                    ; Update DTC0 and DTC2 bits 
 1228 00000ae8 e5816000         str     r6,  [r1, #xlli_MDCNFG_offset]  ; Write back the MDCNFG value 
 1229 00000aec            
 1230 00000aec e1a0f00e         mov     pc,  lr                         ; return to calling routine 
 1231 00000af0            
 1232 00000af0                  ENDFUNC 
 1233 00000af0            
 1234 00000af0 7ff07ff0 *literal pool: constant 
 1234 00000af4 03000300 *literal pool: constant 
 1234 00000af8 00000fff *literal pool: constant 
 1234 00000afc 41300000 *literal pool: constant 
 1234 00000b00 c0200fff *literal pool: constant 
 1234 00000b04 12201220 *literal pool: constant 
 1234 00000b08 13301330 *literal pool: constant 
 1234 00000b0c 13401340 *literal pool: constant 
 1234 00000b10 13501350 *literal pool: constant 
 1234 00000b14 01000100 *literal pool: constant 
 1234 00000b18 14601460 *literal pool: constant 
 1234 00000b1c 14701470 *literal pool: constant 
 1234 00000b20 02000200 *literal pool: constant 
 1234 00000b24 15801580 *literal pool: constant 
 1234 00000b28 15a015a0 *literal pool: constant 
 1234 00000b2c 15b015b0 *literal pool: constant 
 1234 00000b30 14801480 *literal pool: constant 
 1234 00000b34 15901590 *literal pool: constant 
 1234 00000b38 12101210 *literal pool: constant 
 1234 00000b3c 13601360 *literal pool: constant 
 1234 00000b40 16b016b0 *literal pool: constant 
 1234 00000b44 16c016c0 *literal pool: constant 
 1234 00000b48 17d017d0 *literal pool: constant 
 1234 00000b4c 17c017c0 *literal pool: constant 
 1234 00000b50 17e017e0 *literal pool: constant 
 1234 00000b54 18e018e0 *literal pool: constant 
 1234 00000af0                  LTORG 
 1235 00000b58            
 1236 00000b58          ;************************************************************************************************** 
 1237 00000b58          ; 
 1238 00000b58          ; ****************************************************** 
 1239 00000b58          ; **********                                  ********** 
 1240 00000b58          ; ********** INITIALIZE (MASK) ALL INTERRUPTS ********** 
 1241 00000b58          ; **********                                  ********** 
 1242 00000b58          ; ****************************************************** 
 1243 00000b58          ; 
 1244 00000b58          ; NOTE: On system reset, all interrupts should be cleared by hardware. 
 1245 00000b58          ;       This enforces disabling of all interrupts to HW boot default conditions. 
 1246 00000b58          ; 
 1247 00000b58          xlli_intr_init   FUNCTION 
 1248 00000b58            
 1249 00000b58 e59f4840         ldr     r4,  =xlli_INTERREGS_PHYSICAL_BASE  ; Load controller physical base address 
 1250 00000b5c e3a02000         ldr     r2,  =0x0                           ; zero out a work register 
 1251 00000b60 e5842004         str     r2,  [r4, #xlli_ICMR_offset]        ; Mask all interrupts (clear mask register) 
 1252 00000b64 e58420a0         str     r2,  [r4, #xlli_ICMR2_offset]       ; Mask all interrupts (clear mask register) 2 
 1253 00000b68 e5842008         str     r2,  [r4, #xlli_ICLR_offset]        ; Clear the interrupt level register 
 1254 00000b6c e58420a4         str     r2,  [r4, #xlli_ICLR2_offset]       ; Clear the interrupt level register 2 
 1255 00000b70 e5842014         str     r2,  [r4, #xlli_ICCR_offset]        ; Clear Interrupt Control Register 
 1256 00000b74 e58420ac         str     r2,  [r4, #xlli_ICCR2_offset]       ; Clear Interrupt Control Register 2 
 1257 00000b78          ; 
 1258 00000b78          ;       Read back from APB to ensure our writes have completed before continuing 
 1259 00000b78          ; 
 1260 00000b78 e5942004         ldr     r2,  [r4, #xlli_ICMR_offset] 
 1261 00000b7c            
 1262 00000b7c e1a0f00e         mov     pc,  lr                             ; return to calling routine 
 1263 00000b80            
 1264 00000b80                  ENDFUNC 
 1265 00000b80            
 1266 00000b80          ;************************************************************************************************** 
 1267 00000b80          ; 
 1268 00000b80          ; ********************************************** 
 1269 00000b80          ; **********                          ********** 
 1270 00000b80          ; ********** INITIALIZE CLOCK MANAGER ********** 
 1271 00000b80          ; **********                          ********** 
 1272 00000b80          ; ********************************************** 
 1273 00000b80          ; 
 1274 00000b80          ; Disable the peripheral clocks, and set the core clock frequency 
 1275 00000b80          ; 
 1276 00000b80          ; NOTE: The Change Frequency Sequence should be called after this function in order 
 1277 00000b80          ;       for the clock frequencies set in the CCCR register to take effect. 
 1278 00000b80          ; 
 1279 00000b80          ;       The code then spins on the oscillator OK bit until the oscilator is stable 
 1280 00000b80          ;       which can take as long as two seconds. 
 1281 00000b80          ; 
 1282 00000b80            
 1283 00000b80          xlli_clks_init   FUNCTION 
 1284 00000b80            
 1285 00000b80          ; Turn Off ALL on-chip peripheral clocks for re-configuration 
 1286 00000b80          ; 
 1287 00000b80 e59f481c         ldr     r4,  =xlli_CLKREGS_PHYSICAL_BASE; Load clock registers base address 
 1288 00000b84 e3a01501         ldr     r1,  =0x400000                  ; Forces memory clock to stay ON!! 
 1289 00000b88 e59f2818         ldr     r2,  =xlli_CKEN_value           ; Get any other bits required from the include file 
 1290 00000b8c e1811002         orr     r1,  r1,  r2                    ; OR everything together 
 1291 00000b90 e5841004         str     r1,  [r4, #xlli_CKEN_offset]    ; ... and write out to the clock enable register 
 1292 00000b94          ; 
 1293 00000b94          ; Set Crystal: Memory Freq, Memory:RunMode Freq, RunMode, TurboMode Freq Multipliers, 
 1294 00000b94          ; set RunMode & TurboMode to default frequency. 
 1295 00000b94          ; 
 1296 00000b94 e59f2810         ldr     r2,  =xlli_CCCR_value           ; Get CORE_CLK_DEFAULT value 
 1297 00000b98 e5842000         str     r2,  [r4, #xlli_CCCR_offset]    ; Write to the clock config register 
 1298 00000b9c          ; 
 1299 00000b9c          ; Enable the 32 KHz oscillator and set the 32KHz output enable bits 
 1300 00000b9c          ; 
 1301 00000b9c e3a01006         mov     r1,  #(xlli_OSCC_OON :OR: xlli_OSCC_TOUT_EN) 
 1302 00000ba0 e5841008         str     r1,  [r4, #xlli_OSCC_offset]    ; for RTC and Power Manager 
 1303 00000ba4          ; 
 1304 00000ba4          ; Init Real Time Clock (RTC) registers 
 1305 00000ba4          ; 
 1306 00000ba4 e59f4804         ldr     r4,  =xlli_RTCREGS_PHYSICAL_BASE ; Load RTC registers base address 
 1307 00000ba8 e3a02000         mov     r2,  #0                          ; Clear a work register 
 1308 00000bac e5842008         str     r2,  [r4, #xlli_RTSR_offset]     ; Clear RTC Status register 
 1309 00000bb0 e5842000         str     r2,  [r4, #xlli_RCNR_offset]     ; Clear RTC Counter Register 
 1310 00000bb4 e5842004         str     r2,  [r4, #xlli_RTAR_offset]     ; Clear RTC Alarm Register 
 1311 00000bb8 e5842028         str     r2,  [r4, #xlli_SWCR_offset]     ; Clear Stopwatch Counter Register 
 1312 00000bbc e584202c         str     r2,  [r4, #xlli_SWAR1_offset]    ; Clear Stopwatch Alarm Register 1 
 1313 00000bc0 e5842030         str     r2,  [r4, #xlli_SWAR2_offset]    ; Clear Stopwatch Alarm Register 2 
 1314 00000bc4 e5842034         str     r2,  [r4, #xlli_PICR_offset]     ; Clear Periodic Counter Register 
 1315 00000bc8 e5842038         str     r2,  [r4, #xlli_PIAR_offset]     ; Clear Interrupt Alarm Register 
 1316 00000bcc          ;       mov     pc,  lr                          ; DISABLED - Return here if A0 silicon 
 1317 00000bcc          ; 
 1318 00000bcc          ; Check the Oscillator OK (OOK) bit in clock register OSCC to insure the timekeeping oscillator 
 1319 00000bcc          ; is enabled and stable before returning to the calling program. 
 1320 00000bcc          ; 
 1321 00000bcc e59f47d0         ldr     r4,  =xlli_CLKREGS_PHYSICAL_BASE; Reload clock registers base address 
 1322 00000bd0          xlli_6 
 1323 00000bd0 e5941008         ldr     r1,  [r4, #xlli_OSCC_offset]    ; Get the status of the OSCC register 
 1324 00000bd4 e2111001         ands    r1,  r1,  #xlli_OSCC_OOK        ; is the oscillator OK bit set? 
 1325 00000bd8 0afffffc         beq     xlli_6                          ; Spin in this loop until the bit is set 
 1326 00000bdc            
 1327 00000bdc e1a0f00e         mov     pc,  lr                                 ; return to calling routine 
 1328 00000be0            
 1329 00000be0                  ENDFUNC 
 1330 00000be0            
 1331 00000be0          ;************************************************************************************************** 
 1332 00000be0          ; 
 1333 00000be0          ; **************************************************************** 
 1334 00000be0          ; **********                                            ********** 
 1335 00000be0          ; ********** INITIALIZE CLOCK MANAGER (FROM SLEEP MODE) ********** 
 1336 00000be0          ; **********                                            ********** 
 1337 00000be0          ; **************************************************************** 
 1338 00000be0          ; 
 1339 00000be0          ; Disable the peripheral clocks, and set the core clock frequency 
 1340 00000be0          ; 
 1341 00000be0          ;       The code then spins on the oscillator OK bit until the oscilator is stable 
 1342 00000be0          ;       which can take as long as two seconds. 
 1343 00000be0          ; 
 1344 00000be0            
 1345 00000be0          xlli_clks_init_sleepReset   FUNCTION 
 1346 00000be0            
 1347 00000be0          ; Turn Off ALL on-chip peripheral clocks for re-configuration 
 1348 00000be0          ; 
 1349 00000be0 e59f47bc         ldr     r4,  =xlli_CLKREGS_PHYSICAL_BASE; Load clock registers base address 
 1350 00000be4 e3a01501         ldr     r1,  =0x400000                  ; Forces memory clock to stay ON!! 
 1351 00000be8 e59f27b8         ldr     r2,  =xlli_CKEN_value           ; Get any other bits required from the include file 
 1352 00000bec e1811002         orr     r1,  r1,  r2                    ; OR everything together 
 1353 00000bf0 e5841004         str     r1,  [r4, #xlli_CKEN_offset]    ; ... and write out to the clock enable register 
 1354 00000bf4          ; 
 1355 00000bf4          ; Set Crystal: Memory Freq, Memory:RunMode Freq, RunMode, TurboMode Freq Multipliers, 
 1356 00000bf4          ; set RunMode & TurboMode to default frequency. 
 1357 00000bf4          ; 
 1358 00000bf4 e59f27b0         ldr     r2,  =xlli_CCCR_value           ; Get CORE_CLK_DEFAULT value 
 1359 00000bf8 e5842000         str     r2,  [r4, #xlli_CCCR_offset]    ; Write to the clock config register 
 1360 00000bfc          ; 
 1361 00000bfc          ;       Read back from APB to ensure our writes have completed before continuing 
 1362 00000bfc          ; 
 1363 00000bfc e5942000         ldr     r2,  [r4, #xlli_CCCR_offset] 
 1364 00000c00            
 1365 00000c00 e1a0f00e         mov     pc,  lr                                 ; return to calling routine 
 1366 00000c04            
 1367 00000c04                  ENDFUNC 
 1368 00000c04            
 1369 00000c04          ;************************************************************************************************** 
 1370 00000c04          ; 
 1371 00000c04          ; *********************************************** 
 1372 00000c04          ; **********                           ********** 
 1373 00000c04          ; ********** FREQUENCY CHANGE SEQUENCE ********** 
 1374 00000c04          ; **********                           ********** 
 1375 00000c04          ; *********************************************** 
 1376 00000c04          ; 
 1377 00000c04          ; This subroutine initiates the frequency change sequence and restarts the memory controller 
 1378 00000c04          ; 
 1379 00000c04            
 1380 00000c04          xlli_freq_change   FUNCTION 
 1381 00000c04            
 1382 00000c04 ee162e10         mrc     p14, 0, r2, c6, c0, 0       ; Get present status (preserve Turbo and Fast Bus bits) 
 1383 00000c08 e3822002         orr     r2,  r2,  #2                ; Set the F bit 
 1384 00000c0c ee062e10         mcr     p14, 0, r2, c6, c0, 0       ; initiate the frequency change sequence - Wheeeeeeeee! 
 1385 00000c10          ; 
 1386 00000c10          ;       If the clock frequency is chaged, the MDREFR Register must be  rewritten, even 
 1387 00000c10          ;       if it's the same value. This will result in a refresh being performed and the 
 1388 00000c10          ;       refresh counter being reset to the reset interval. (Section 13.10.3, pg 13-17 of EAS) 
 1389 00000c10          ; 
 1390 00000c10 e3a04312         ldr     r4,  =xlli_MEMORY_CONFIG_BASE       ; Get memory controller base address 
 1391 00000c14 e5941004         ldr     r1,  [r4, #xlli_MDREFR_offset]      ; Get the current state of MDREFR 
 1392 00000c18 e5841004         str     r1,  [r4, #xlli_MDREFR_offset]      ; Re-write this value 
 1393 00000c1c            
 1394 00000c1c e1a0f00e         mov     pc,  lr ; return to calling routine 
 1395 00000c20            
 1396 00000c20                  ENDFUNC 
 1397 00000c20            
 1398 00000c20          ;************************************************************************************************** 
 1399 00000c20          ; 
 1400 00000c20          ; ******************************************************** 
 1401 00000c20          ; **********                                    ********** 
 1402 00000c20          ; ********** INITIALIZE OPERATING SYSTEM TIMERS ********** 
 1403 00000c20          ; **********                                    ********** 
 1404 00000c20          ; ******************************************************** 
 1405 00000c20          ; 
 1406 00000c20          ; This code segment initializes the OST count registers to zero, clears the 
 1407 00000c20          ; status bits in OSSR, and zeroes out the match registers. 
 1408 00000c20          ; 
 1409 00000c20          ; After this function is called, the OS timers should be initalized to the 
 1410 00000c20          ; same state as on HW reset. 
 1411 00000c20          ; 
 1412 00000c20          ; The interrupt bit for match register 1 is set for use by timing macros. 
 1413 00000c20          ; 
 1414 00000c20            
 1415 00000c20          xlli_ost_init   FUNCTION 
 1416 00000c20            
 1417 00000c20 e59f278c         ldr    r2,  =xlli_OSTREGS_PHYSICAL_BASE ; get base address for os timer registers 
 1418 00000c24 e3a03000         mov    r3,  #0                          ; clear work register 
 1419 00000c28            
 1420 00000c28 e5823010         str    r3,  [r2, #xlli_OSCR0_offset]    ; zero out OS Timer Count register 
 1421 00000c2c e5823018         str    r3,  [r2, #xlli_OWER_offset]     ; zero out OS Timer Watchdog Match Enable Register 
 1422 00000c30 e582301c         str    r3,  [r2, #xlli_OIER_offset]     ; zero out OS Timer Interrupt Enable register 
 1423 00000c34 e5823014         str    r3,  [r2, #xlli_OSSR_offset]     ; zero out OS Timer Status register 
 1424 00000c38            
 1425 00000c38 e58230c0         str    r3,  [r2, #xlli_OMCR4_offset]    ; Zero out Match Control Registers 
 1426 00000c3c e58230c4         str    r3,  [r2, #xlli_OMCR5_offset] 
 1427 00000c40 e58230c8         str    r3,  [r2, #xlli_OMCR6_offset] 
 1428 00000c44 e58230cc         str    r3,  [r2, #xlli_OMCR7_offset] 
 1429 00000c48 e58230d0         str    r3,  [r2, #xlli_OMCR8_offset] 
 1430 00000c4c e58230d4         str    r3,  [r2, #xlli_OMCR9_offset] 
 1431 00000c50 e58230d8         str    r3,  [r2, #xlli_OMCR10_offset] 
 1432 00000c54 e58230dc         str    r3,  [r2, #xlli_OMCR11_offset] 
 1433 00000c58            
 1434 00000c58 e5823010         str    r3,  [r2, #xlli_OSCR0_offset]    ; Zero out count register 0 
 1435 00000c5c e5823040         str    r3,  [r2, #xlli_OSCR4_offset]    ; Zero out count register 4 - 11 
 1436 00000c60 e5823044         str    r3,  [r2, #xlli_OSCR5_offset] 
 1437 00000c64 e5823048         str    r3,  [r2, #xlli_OSCR6_offset] 
 1438 00000c68 e582304c         str    r3,  [r2, #xlli_OSCR7_offset] 
 1439 00000c6c e5823050         str    r3,  [r2, #xlli_OSCR8_offset] 
 1440 00000c70 e5823054         str    r3,  [r2, #xlli_OSCR9_offset] 
 1441 00000c74 e5823058         str    r3,  [r2, #xlli_OSCR10_offset] 
 1442 00000c78 e582305c         str    r3,  [r2, #xlli_OSCR11_offset] 
 1443 00000c7c            
 1444 00000c7c e5823000         str    r3,  [r2, #xlli_OSMR0_offset]    ; zero-out all 12 match registers 
 1445 00000c80 e5823004         str    r3,  [r2, #xlli_OSMR1_offset] 
 1446 00000c84 e5823008         str    r3,  [r2, #xlli_OSMR2_offset] 
 1447 00000c88 e582300c         str    r3,  [r2, #xlli_OSMR3_offset] 
 1448 00000c8c e5823080         str    r3,  [r2, #xlli_OSMR4_offset] 
 1449 00000c90 e5823084         str    r3,  [r2, #xlli_OSMR5_offset] 
 1450 00000c94 e5823088         str    r3,  [r2, #xlli_OSMR6_offset] 
 1451 00000c98 e582308c         str    r3,  [r2, #xlli_OSMR7_offset] 
 1452 00000c9c e5823090         str    r3,  [r2, #xlli_OSMR8_offset] 
 1453 00000ca0 e5823094         str    r3,  [r2, #xlli_OSMR9_offset] 
 1454 00000ca4 e5823098         str    r3,  [r2, #xlli_OSMR10_offset] 
 1455 00000ca8 e582309c         str    r3,  [r2, #xlli_OSMR11_offset] 
 1456 00000cac            
 1457 00000cac e59f1704         ldr    r1,  =xlli_OSSR_ALL              ; Clear the status bits - these are 'sticky' bits, 
 1458 00000cb0 e5821014         str    r1,  [r2, #xlli_OSSR_offset]     ; These bits are cleared by writing 1's to them 
 1459 00000cb4          ; 
 1460 00000cb4          ;       Read back from APB to ensure our writes have completed before continuing 
 1461 00000cb4          ; 
 1462 00000cb4 e5921014         ldr     r1, [r2, #xlli_OSSR_offset] 
 1463 00000cb8            
 1464 00000cb8 e1a0f00e         mov     pc,  lr                         ; return to calling routine 
 1465 00000cbc            
 1466 00000cbc                  ENDFUNC 
 1467 00000cbc            
 1468 00000cbc          ;************************************************************************************************** 
 1469 00000cbc          ; 
 1470 00000cbc          ; ********************************************************************** 
 1471 00000cbc          ; **********                                                  ********** 
 1472 00000cbc          ; ********** ENABLE I-CACHE, D-CACHE AND BRANCH TARGET BUFFER ********** 
 1473 00000cbc          ; **********                                                  ********** 
 1474 00000cbc          ; ********************************************************************** 
 1475 00000cbc          ; 
 1476 00000cbc          ; This code segment enables the Instruction Cache, Data Cache, and the Branch Target Buffer. 
 1477 00000cbc          ; 
 1478 00000cbc          xlli_icache_enable   FUNCTION 
 1479 00000cbc            
 1480 00000cbc ee112f10         mrc    p15, 0, r2, c1, c0, 0            ; Get the contents of the ARM control register 
 1481 00000cc0 e1a02902         mov    r2,  r2, LSL #18                 ; Upper 18-bits must be written as zero... 
 1482 00000cc4 e1a02922         mov    r2,  r2, LSR #18                 ; ....clear them now 
 1483 00000cc8            
 1484 00000cc8 e3822a01         orr    r2,  r2, #xlli_control_icache    ; set the i-cache bit 
 1485 00000ccc e3822b02         orr    r2,  r2, #xlli_control_btb       ; set the btb bit 
 1486 00000cd0 e3822004         orr    r2,  r2, #xlli_control_dcache    ; set the d-cache bit 
 1487 00000cd4            
 1488 00000cd4                  ; This code segment writes the contents of r2 into the ARM control register. 
 1489 00000cd4                  ; Note: you must either format the contents of w1 so that reserved bits 
 1490 00000cd4                  ;       are written with the proper value, or get the getARMControl values and 
 1491 00000cd4                  ;       modify the control bits you need. 
 1492 00000cd4                          ; 
 1493 00000cd4                  ; make sure this is first instruction in a cache line 
 1494 00000cd4            
 1495 00000cd4 ea000001         b      xlli_7 
 1496 00000cd8 00 00 00         ALIGN  32 
               00 00 00   
               00 00       
 1497 00000ce0          xlli_7 
 1498 00000ce0 ee012f10         mcr    p15, 0, r2, c1, c0, 0 
 1499 00000ce4            
 1500 00000ce4                  ; This code segment guarantees that previous writes to coprocessor 15 have 
 1501 00000ce4                  ; completed. Depending on what is being modified in cp15 (turning on 
 1502 00000ce4                  ; the mmu, for example), these instructions may need to be executed 
 1503 00000ce4                  ; from the icache. 
 1504 00000ce4            
 1505 00000ce4 ee112f10         mrc    p15, 0, r2, c1, c0, 0 
 1506 00000ce8 e1a02002         mov    r2,  r2 
 1507 00000cec e24ff004         sub    pc,  pc, #4 
 1508 00000cf0            
 1509 00000cf0 e1a0f00e         mov     pc,  lr                         ; return to calling routine 
 1510 00000cf4            
 1511 00000cf4                  ENDFUNC 
 1512 00000cf4            
 1513 00000cf4          ;************************************************************************************************** 
 1514 00000cf4          ; 
 1515 00000cf4          ; ************************************************** 
 1516 00000cf4          ; **********                              ********** 
 1517 00000cf4          ; ********** INITIALIZE the POWER MANAGER ********** 
 1518 00000cf4          ; **********                              ********** 
 1519 00000cf4          ; ************************************************** 
 1520 00000cf4          ; 
 1521 00000cf4          ; This code initializes the Power Manager 
 1522 00000cf4          ; 
 1523 00000cf4          xlli_pwrmgr_init   FUNCTION 
 1524 00000cf4            
 1525 00000cf4 e59f26c0         ldr    r2,  =xlli_PMRCREGS_PHYSICAL_BASE ; get base address of power mgr / reset control regs 
 1526 00000cf8            
 1527 00000cf8 e3a01000         mov    r1,  #0                          ; clear a work register 
 1528 00000cfc e582100c         str    r1,  [r2, #xlli_PWER_offset]     ; Reset Power Manager Wake-up register 
 1529 00000d00 e5821010         str    r1,  [r2, #xlli_PRER_offset]     ; Clear Power Manager Rising-Edge Detector Enables 
 1530 00000d04 e5821014         str    r1,  [r2, #xlli_PFER_offset]     ; Clear Power Manager Falling-Edge Detector Enables 
 1531 00000d08 e5821018         str    r1,  [r2, #xlli_PEDR_offset]     ; Clear Power Manager GPIO edge-Detect Status register 
 1532 00000d0c e5821020         str    r1,  [r2, #xlli_PGSR0_offset]    ; Clear GPIO sleep state registers (GPIOs 31:0) 
 1533 00000d10 e5821024         str    r1,  [r2, #xlli_PGSR1_offset]    ; Clear GPIO sleep state registers (GPIOs 63:32) 
 1534 00000d14 e5821028         str    r1,  [r2, #xlli_PGSR2_offset]    ; Clear GPIO sleep state registers (GPIOs 95:64) 
 1535 00000d18 e582102c         str    r1,  [r2, #xlli_PGSR3_offset]    ; Clear GPIO sleep state registers (GPIOs 118:96) 
 1536 00000d1c e5821038         str    r1,  [r2, #xlli_PSTR_offset]     ; Reset Standby Configuration Register 
 1537 00000d20 e5821040         str    r1,  [r2, #xlli_PVCR_offset]     ; Reset Power Manager Voltage Change Control Register 
 1538 00000d24 e5821050         str    r1,  [r2, #xlli_PKWR_offset]     ; Clear Keyboard Wake-up Enable Register 
 1539 00000d28 e5821054         str    r1,  [r2, #xlli_PKSR_offset]     ; Clear Keyboard Edge Detect Status Register 
 1540 00000d2c          ; 
 1541 00000d2c          ;       Initialize the PCFR (Power Manager General Congiguration Manager) 
 1542 00000d2c          ; 
 1543 00000d2c e3a01001         mov    r1,  #xlli_PCFR_OPDE              ; enable 3.68Mhz power-down 
 1544 00000d30          ;        orr    r1,  r1, #xlli_PCFR_FP            ; enable PCMCIA pin float 
 1545 00000d30          ;        orr    r1,  r1, #xlli_PCFR_FS            ; enable static memory pin float 
 1546 00000d30 e3811020                 orr    r1,  r1, #xlli_PCFR_SYSEN_EN      ; System power supply enable pin 
 1547 00000d34 e582101c         str    r1,  [r2, #xlli_PCFR_offset] 
 1548 00000d38            
 1549 00000d38          ;       Init PSLR (Power Manager Sleep Configuration Register)  
 1550 00000d38 e5921034         ldr    r1, [r2, #xlli_PSLR_offset]      ; load value already in PSLR 
 1551 00000d3c e59f367c         ldr    r3, =xlli_PSLR_USEDBITS           
 1552 00000d40 e0011003         and    r1, r1, r3                       ; 0 out reserved bits 
 1553 00000d44 e3811004         orr    r1, r1, #xlli_PSLR_SL_PI_RETAIN  ; PI power domain retains state in sleep and deep sleep mode 
 1554 00000d48 e3811601         orr    r1, r1, #xlli_PSLR_SL_ROD        ; nRESET_OUT is not asserted upon entry into sleep or deep-sleep mode 
 1555 00000d4c e5821034         str    r1, [r2, #xlli_PSLR_offset] 
 1556 00000d50            
 1557 00000d50 e1a0f00e         mov     pc,  lr                         ; return to calling routine 
 1558 00000d54            
 1559 00000d54                  ENDFUNC 
 1560 00000d54            
 1561 00000d54          ;************************************************************************************************** 
 1562 00000d54          ; 
 1563 00000d54          ; ***************************************** 
 1564 00000d54          ; **********                     ********** 
 1565 00000d54          ; ********** SET PAGE TABLE BASE ********** 
 1566 00000d54          ; **********                     ********** 
 1567 00000d54          ; ***************************************** 
 1568 00000d54          ; 
 1569 00000d54          ; Set page table base (used after a sleep reset) 
 1570 00000d54          ; 
 1571 00000d54          xlli_setPTB    FUNCTION 
 1572 00000d54            
 1573 00000d54 e59f1668         ldr    r1,  =xlli_p_PageTable ; Get address of Page Table base 
 1574 00000d58 ee021f10         mcr    p15, 0, r1, c2, c0, 0  ; Load Page Table base into CP 15 
 1575 00000d5c            
 1576 00000d5c e1a0f00e         mov    pc,  lr                ; return to calling routine 
 1577 00000d60            
 1578 00000d60                          ENDFUNC 
 1579 00000d60            
 1580 00000d60          ;************************************************************************************************** 
 1581 00000d60          ; 
 1582 00000d60          ; *************************************************************** 
 1583 00000d60          ; **********                                           ********** 
 1584 00000d60          ; ********** INITIALIZE PAGE TABLES FOR MEMORY MAPPING ********** 
 1585 00000d60          ; **********                                           ********** 
 1586 00000d60          ; *************************************************************** 
 1587 00000d60          ; 
 1588 00000d60          ; Init the Page Table area of memory by writting zeros out to the table 
 1589 00000d60          ; 
 1590 00000d60            
 1591 00000d60          xlli_initPageTable   FUNCTION 
 1592 00000d60            
 1593 00000d60 e59f165c         ldr    r1,  =xlli_p_PageTable ; Get address of Page Table base 
 1594 00000d64 ee021f10         mcr    p15, 0, r1, c2, c0, 0 ; Load Page Table base into CP 15 
 1595 00000d68          ; 
 1596 00000d68          ;       zero-out the page table memory region 
 1597 00000d68          ; 
 1598 00000d68 e3a02901         mov    r2,  #xlli_s_PageTable ; get table size 
 1599 00000d6c e3a03000         mov    r3,  #0 
 1600 00000d70          xlli_8 
 1601 00000d70 e2522004         subs   r2,  r2,  #4          ; Increment offset into table 
 1602 00000d74 e7813002         str    r3,  [r1, r2]         ; Clear table entry 
 1603 00000d78 1afffffc         bne    xlli_8                ; Keep looping until done 
 1604 00000d7c            
 1605 00000d7c e1a0f00e         mov    pc,  lr               ; return to calling routine 
 1606 00000d80            
 1607 00000d80                  ENDFUNC 
 1608 00000d80            
 1609 00000d80          ;************************************************************************************************** 
 1610 00000d80          ; 
 1611 00000d80          ; *********************************************************** 
 1612 00000d80          ; **********                                       ********** 
 1613 00000d80          ; ********** INITIALIZE THE MEMORY MANAGEMENT UNIT ********** 
 1614 00000d80          ; **********                                       ********** 
 1615 00000d80          ; *********************************************************** 
 1616 00000d80          ; 
 1617 00000d80          ;       Initialize the memory management unit 
 1618 00000d80          ; 
 1619 00000d80            
 1620 00000d80          xlli_MMU_init      FUNCTION 
 1621 00000d80            
 1622 00000d80                  ; set DACR 
 1623 00000d80 e3a01001         ldr    r1,  =xlli_DACR 
 1624 00000d84 ee031f10         mcr    p15, 0, r1, c3, c0, 0       ; Set DACR 
 1625 00000d88            
 1626 00000d88 e3a02000         ldr    r2,  =xlli_PID 
 1627 00000d8c e1a02ca2         mov    r2,  r2, LSR #25            ; Clear the lo-order 25 bits 
 1628 00000d90 e1a02c82         mov    r2,  r2, LSL #25            ; (may be unnecessary) 
 1629 00000d94 ee0d2f10         mcr    p15, 0, r2, c13, c0, 0      ; Set PID 
 1630 00000d98            
 1631 00000d98 ee111f30         mrc    p15, 0, r1, c1, c0, 1       ; Get the current aux control settings 
 1632 00000d9c            
 1633 00000d9c          ;       extract the control bits such that reserved bits are 0, this will 
 1634 00000d9c          ;       prep the bits for a subsequent write. 
 1635 00000d9c            
 1636 00000d9c e2011033         and    r1,  r1,  #0x33 
 1637 00000da0 e3811010         orr    r1,  r1,  #xlli_CONTROL_MINIDATA_01 ; orr in the mini-data cache attributes 
 1638 00000da4            
 1639 00000da4 ee011f30         mcr    p15, 0, r1, c1, c0, 1       ; Write back the new settings 
 1640 00000da8            
 1641 00000da8          ;       invalidate and enable the BTB 
 1642 00000da8            
 1643 00000da8 ee071fd5         mcr    p15, 0, r1, c7, c5, 6       ; invalidate the Branch Target Buffer 
 1644 00000dac          ; 
 1645 00000dac          ;       enable the BTB 
 1646 00000dac          ; 
 1647 00000dac ee111f10         mrc    p15, 0, r1, c1, c0, 0 
 1648 00000db0 e1a01901         mov    r1,  r1, LSL #18            ; Upper 18 bits must be 
 1649 00000db4 e1a01921         mov    r1,  r1, LSR #18            ; written as zeros 
 1650 00000db8 e3811b02         orr    r1,  r1, #xlli_CONTROL_BTB  ; set the BTB bit 
 1651 00000dbc            
 1652 00000dbc eaffffff         b     xlli_9                       ; 1st instruction on cache line 
 1653 00000dc0                  ALIGN 32 
 1654 00000dc0          xlli_9 
 1655 00000dc0 ee011f10         mcr    p15, 0, r1, c1, c0, 0       ; write the data back 
 1656 00000dc4 ee121f10         mrc    p15, 0, r1, c2, c0, 0       ; Insure that the write completes 
 1657 00000dc8 e1a01001         mov    r1,  r1                     ; before continuing 
 1658 00000dcc e24ff004         sub    pc,  pc,  #4 
 1659 00000dd0            
 1660 00000dd0 e1a0f00e         mov    pc,  lr                     ; return to calling routine 
 1661 00000dd4            
 1662 00000dd4                  ENDFUNC 
 1663 00000dd4            
 1664 00000dd4          ;************************************************************************************************** 
 1665 00000dd4          ; 
 1666 00000dd4          ; ************************************************************** 
 1667 00000dd4          ; **********                                          ********** 
 1668 00000dd4          ; ********** FIRE UP THE MMU - SWITCH TO VIRTUAL MODE ********** 
 1669 00000dd4          ; **********                                          ********** 
 1670 00000dd4          ; ************************************************************** 
 1671 00000dd4          ; 
 1672 00000dd4          ;      Make the transistion from physical mode to virtual mode. 
 1673 00000dd4          ; 
 1674 00000dd4          ;      This subroutine assumes thaqt execution is from boot ROM and that 
 1675 00000dd4          ;      the MMU is disabled when this subroutine is called. 
 1676 00000dd4          ; 
 1677 00000dd4          ;      NOTES: 
 1678 00000dd4          ; 
 1679 00000dd4          ;      1. The memory system must already be up and running. 
 1680 00000dd4          ;      2. The page table must be initalized (zeroed out) 
 1681 00000dd4          ;      3. The memory to be accessed must have their page table entries filled in. 
 1682 00000dd4          ;      4. The MMU needs to be initialized first. 
 1683 00000dd4          ;      5. When this subroutine returns to the caller, all addresses are virtual. 
 1684 00000dd4          ; 
 1685 00000dd4          ;      Typically this would be the last low level init subroutine to be run before 
 1686 00000dd4          ;      control is turned over to an operating system. 
 1687 00000dd4          ; 
 1688 00000dd4            
 1689 00000dd4          xlli_goVirtual  FUNCTION 
 1690 00000dd4          ; 
 1691 00000dd4          ;       (1) Temporarily overwrite page table entry that maps where we are now. 
 1692 00000dd4          ; 
 1693 00000dd4          ;       This code section effectivly makes the table entry where the program counter 
 1694 00000dd4          ;       (pc) would point now and, the table entry where the new pc value will point, 
 1695 00000dd4          ;       (after going to virtual addressing) result in the code pointing to the same 
 1696 00000dd4          ;       physical address regardless of which pc value is used. This is to 
 1697 00000dd4          ;       cover those cases where the pc is altered after the jump to virtual 
 1698 00000dd4          ;       addresing. If the sections are idenity (flat) mapped, then the following 
 1699 00000dd4          ;       code basicly rewrites a single table entery with a copy of itself. Once the 
 1700 00000dd4          ;       pc has been altered to the virtual address, the original table entry for the 
 1701 00000dd4          ;       address space we are now is is restored to its original value. 
 1702 00000dd4          ; 
 1703 00000dd4          ;       CAUTION: If the page table is mapped to virtual address different from the physical 
 1704 00000dd4          ;       address, this code is likely to result in an exception to 0x10 (Data Abort) unless 
 1705 00000dd4          ;       you modify the code in the section to take this into account. 
 1706 00000dd4          ; 
 1707 00000dd4 e59f15e8         ldr   r1,  =xlli_p_PageTable       ; Get address of Page Table base 
 1708 00000dd8            
 1709 00000dd8 e1a04a2f         mov   r4,  pc,  LSR #(20)          ; Current execution location (divide by 1 Mb) 
 1710 00000ddc e1a04104         mov   r4,  r4,  LSL #(2)           ; Insure lower two bits are zero 
 1711 00000de0 e0844001         add   r4,  r4,  r1                 ; Point to RAM page table entry for this address space 
 1712 00000de4 e5943000         ldr   r3,  [r4]                    ; Save the existing table entry in r3 
 1713 00000de8          ; 
 1714 00000de8          ;       Do not alter r3 or r4 as we will need them later... 
 1715 00000de8          ; 
 1716 00000de8 e3a02000         ldr   r2,  =(xlli_v_xbBOOTROM :SHR: (18)) 
 1717 00000dec e0822001         add   r2,  r2,  r1                 ; Point to new (virtual) ROM page table entry 
 1718 00000df0 e5921000         ldr   r1,  [r2]                    ; Get this (virtural address) table entry.... 
 1719 00000df4          ; 
 1720 00000df4          ;       Overwrite RAM entry for current (physical address) table entry 
 1721 00000df4          ; 
 1722 00000df4 e5841000         str   r1,  [r4]                    ; ....and place it in the current table entry. 
 1723 00000df8            
 1724 00000df8          ;       end-of-part (1) 
 1725 00000df8          ; ------------------------------------------------- 
 1726 00000df8          ;       (2) setup to enable the MMU 
 1727 00000df8          ; 
 1728 00000df8          ;       Generate (in r1) the virtual address the code will jump to once the 
 1729 00000df8          ;       transition has been made to virtual address mode. 
 1730 00000df8          ; 
 1731 00000df8 e28f1050         add   r1,  pc, #xlli_12 - (.+8)    ; Load address of xlli_12 into r1 
 1732 00000dfc e2811000         add   r1,  r1,  #xlli_v_xbBOOTROM  ; add offset to virtual ROM address 
 1733 00000e00          ; 
 1734 00000e00          ;       Invalidate both TLBs 
 1735 00000e00          ; 
 1736 00000e00 ee082f17         mcr p15, 0, r2, c8, c7, 0          ; Invalidates both instruction and data TLBs 
 1737 00000e04          ; 
 1738 00000e04          ;       enable mmu 
 1739 00000e04          ; 
 1740 00000e04 ee112f10         mrc   p15, 0, r2, c1, c0, 0        ; Read current settings in control reg 
 1741 00000e08 e1a02902         mov   r2,  r2, LSL #18             ; Upper 18-bits must be written as zero, 
 1742 00000e0c e1a02922         mov   r2,  r2, LSR #18             ; ... clear them now. 
 1743 00000e10          ; 
 1744 00000e10          ;               Set ROM protection, Clear System protection, Set MMU bit 
 1745 00000e10          ; 
 1746 00000e10 e3822c02         orr   r2, r2, #xlli_control_r      ; set the ROM Protection bit 
 1747 00000e14 e3c22c01         bic   r2, r2, #xlli_control_s      ; clear the System Protection bit 
 1748 00000e18 e3822001         orr   r2, r2, #xlli_control_mmu    ; set the MMU bit 
 1749 00000e1c          ; 
 1750 00000e1c          ;       Write back the new value 
 1751 00000e1c          ; 
 1752 00000e1c eaffffff         b      xlli_11                     ; make sure this is first instruction in a cache line 
 1753 00000e20                  ALIGN  32 
 1754 00000e20          xlli_11 
 1755 00000e20 ee012f10         mcr    p15, 0, r2, c1, c0, 0       ; Go Virtual! 
 1756 00000e24 ee122f10         mrc    p15, 0, r2, c2, c0, 0       ; Insure that the write completes 
 1757 00000e28 e1a02002         mov    r2,  r2                     ; before continuing 
 1758 00000e2c e24ff004         sub    pc,  pc,  #4 
 1759 00000e30          ; 
 1760 00000e30          ;       invalidate both caches, btb 
 1761 00000e30          ; 
 1762 00000e30 ee072f17         mcr    p15, 0, r2, c7, c7, 0 
 1763 00000e34            
 1764 00000e34 e1a0f001         mov    pc,  r1                     ; Load virtual address into the pc 
 1765 00000e38 e1a00000         nop                                ; nop instructions to "empty the pipeline" 
 1766 00000e3c e1a00000         nop 
 1767 00000e40 e1a00000         nop 
 1768 00000e44 e1a00000                 nop 
 1769 00000e48 e1a00000         nop 
 1770 00000e4c e1a00000         nop 
 1771 00000e50          xlli_12 
 1772 00000e50 e28ee000         add   lr,  lr,  #xlli_v_xbBOOTROM  ; Update the link register return address 
 1773 00000e54            
 1774 00000e54          ;       end-of-part (2) 
 1775 00000e54          ; ------------------------------------------------- 
 1776 00000e54          ;       (3) restore the overwritten page table entry, flush all caches 
 1777 00000e54          ;       The following instruction assumes the page table is idenity mapped! 
 1778 00000e54          ; 
 1779 00000e54 e5843000         str   r3,  [r4]                    ; This restores original page table entry 
 1780 00000e58          ; 
 1781 00000e58          ;       Invalidate both TLBs and caches 
 1782 00000e58          ; 
 1783 00000e58 ee082f17         mcr   p15, 0, r2, c8, c7, 0        ; Invalidates both instruction and data TLBs 
 1784 00000e5c ee072f17         mcr   p15, 0, r2, c7, c7, 0        ; invalidate both caches, BTB 
 1785 00000e60            
 1786 00000e60 e1a00000         nop                                ; Make sure the pipe is empty 
 1787 00000e64 e1a00000         nop 
 1788 00000e68 e1a00000         nop 
 1789 00000e6c e1a00000         nop 
 1790 00000e70 e1a00000         nop 
 1791 00000e74 e1a00000         nop 
 1792 00000e78          ; 
 1793 00000e78          ;       end-of-part (3) 
 1794 00000e78          ;       ------------------------------------------------- 
 1795 00000e78          ;       set up cache memory for use 
 1796 00000e78          ; 
 1797 00000e78 ee071f16         mcr   p15, 0, r1, c7, c6, 0        ; Invalidates the D cache 
 1798 00000e7c ee081f16         mcr   p15, 0, r1, c8, c6, 0        ; Invalidates the data TLB 
 1799 00000e80            
 1800 00000e80 ee122f10         mrc    p15, 0, r2, c2, c0, 0       ; Insure that the write completes 
 1801 00000e84 e1a02002         mov    r2,  r2                     ; before continuing 
 1802 00000e88 e24ff004         sub    pc,  pc,  #4 
 1803 00000e8c          ; 
 1804 00000e8c          ;       invalidate the BTB 
 1805 00000e8c          ; 
 1806 00000e8c ee071fd5         mcr    p15, 0, r1, c7, c5, 6       ; invalidate the Branch Target Buffer 
 1807 00000e90          ; 
 1808 00000e90          ;       Enable ICache, DCache, BTB 
 1809 00000e90          ; 
 1810 00000e90 ee112f10         mrc   p15, 0, r2, c1, c0, 0        ; Read current settings in control reg 
 1811 00000e94 e1a02902         mov   r2,  r2, LSL #18             ; Upper 18-bits must be written as zero, 
 1812 00000e98 e1a02922         mov   r2,  r2, LSR #18             ; ... clear them now. 
 1813 00000e9c            
 1814 00000e9c e3822004         orr   r2, r2, #xlli_control_dcache ; set the DCache bit 
 1815 00000ea0 e3822a01         orr   r2, r2, #xlli_control_icache ; set the ICache bit 
 1816 00000ea4 e3822b02         orr   r2, r2, #xlli_control_btb 
 1817 00000ea8          ; 
 1818 00000ea8          ;       Write back the new value 
 1819 00000ea8          ; 
 1820 00000ea8 ea000004         b      xlli_13                     ; make sure this is first instruction in a cache line 
 1821 00000eac 00 00 00         ALIGN  32 
               00 00 00   
               00 00 00   
               00 00 00   
               00 00 00   
               00 00 00   
               00 00       
 1822 00000ec0          xlli_13 
 1823 00000ec0 ee012f10         mcr    p15, 0, r2, c1, c0, 0 
 1824 00000ec4 ee122f10         mrc    p15, 0, r2, c2, c0, 0       ; Insure that the write completes 
 1825 00000ec8 e1a02002         mov    r2,  r2                     ; before continuing 
 1826 00000ecc e24ff004         sub    pc,  pc,  #4 
 1827 00000ed0            
 1828 00000ed0 e1a0f00e         mov    pc,  lr                     ; return to calling routine 
 1829 00000ed4            
 1830 00000ed4                  ENDFUNC 
 1831 00000ed4            
 1832 00000ed4          ;************************************************************************************************** 
 1833 00000ed4          ; 
 1834 00000ed4          ; *************************************************************** 
 1835 00000ed4          ; **********                                           ********** 
 1836 00000ed4          ; ********** INITIALIZE INTERNAL MEMORY POWER REGISTER ********** 
 1837 00000ed4          ; **********                                           ********** 
 1838 00000ed4          ; *************************************************************** 
 1839 00000ed4          ; 
 1840 00000ed4          ; Power up the internal memory for use (Default on system reset) 
 1841 00000ed4          ; 
 1842 00000ed4          ; Note: This subroutine sets the internal memory to the hardware reset default state 
 1843 00000ed4          ;       which is all memory in run mode with auto wake-up disabled and never going 
 1844 00000ed4          ;       into standby mode. 
 1845 00000ed4          ; 
 1846 00000ed4            
 1847 00000ed4          xlli_IMpwr_init      FUNCTION 
 1848 00000ed4            
 1849 00000ed4 e3a02316         ldr    r2,  =xlli_IMEMORY_CONFIG_BASE   ; get base address of IM Power Management control regs 
 1850 00000ed8 e3a01000         mov    r1,  #0                          ; Set all memory to RUN mode and disable auto wakeup 
 1851 00000edc e5821000         str    r1,  [r2, #xlli_IMPMCR_offset]   ; Write the data to the control register 
 1852 00000ee0            
 1853 00000ee0 e1a0f00e         mov    pc,  lr                          ; return to calling routine 
 1854 00000ee4            
 1855 00000ee4                  ENDFUNC 
 1856 00000ee4            
 1857 00000ee4          ;************************************************************************************************** 
 1858 00000ee4          ; 
 1859 00000ee4          ; ******************************************************* 
 1860 00000ee4          ; **********                                   ********** 
 1861 00000ee4          ; ********** GET SYSTEM CONFIGURATION REGISTER ********** 
 1862 00000ee4          ; **********                                   ********** 
 1863 00000ee4          ; ******************************************************* 
 1864 00000ee4          ; 
 1865 00000ee4          ; This is a "C" program callable subroutine that returns the value stored in the 
 1866 00000ee4          ; last SRAM memory location - which presumably still contains the Mainstone 
 1867 00000ee4          ; system configuration data that was put there by the xlli_read_SCR subroutine. 
 1868 00000ee4          ; 
 1869 00000ee4          ; Note: The system stack register must be set up before this subroutine is called. 
 1870 00000ee4          ; 
 1871 00000ee4            
 1872 00000ee4          GetSCR  FUNCTION 
 1873 00000ee4            
 1874 00000ee4 e92d4002         stmfd   sp!, {r1, lr}                     ; Save r1 and link register on the stack 
 1875 00000ee8 e59f14d8         ldr     r1,  =xlli_SCR_data               ; Address where system config data is stored 
 1876 00000eec e5910000         ldr     r0,  [r1]                         ; Read the contents of SCR into r0 
 1877 00000ef0 e8bd8002         ldmfd   sp!, {r1, pc}                     ; Restore r1 and return to caller 
 1878 00000ef4            
 1879 00000ef4                  ENDFUNC 
 1880 00000ef4            
 1881 00000ef4          ;************************************************************************************************** 
 1882 00000ef4          ; 
 1883 00000ef4          ; ************************************************************ 
 1884 00000ef4          ; **********                                        ********** 
 1885 00000ef4          ; ********** SET SYSTEM CLOCKS FROM SWITCH SETTINGS ********** 
 1886 00000ef4          ; **********                                        ********** 
 1887 00000ef4          ; ************************************************************ 
 1888 00000ef4          ; 
 1889 00000ef4          ; This subroutine sets the Bulverde/Mainstone clocks based on the Mainstone platform switch settings 
 1890 00000ef4          ; NOTE: This subroutine just sets the bits according to switch settings. The user needs to call the 
 1891 00000ef4          ;       change frequency sequence subroutine (xlli_freq_change) for the values to take effect. 
 1892 00000ef4          ; 
 1893 00000ef4          xlli_setClocks  FUNCTION 
 1894 00000ef4          ; 
 1895 00000ef4          ;       This code segment gets the platform hex switch settings and loads the appropriate N and L values into 
 1896 00000ef4          ;       the CCCR register. Switch register Bits 15:11 and 7 are ignored by this code. 
 1897 00000ef4          ; 
 1898 00000ef4 e3a01302         ldr    r1,  =xlli_PLATFORM_REGISTERS             ; Get platform register base address 
 1899 00000ef8 e5912060         ldr    r2,  [r1, #xlli_PLATFORM_SWITCH_offset]   ; Load platform switch settings into r2 
 1900 00000efc e202307f         and    r3,  r2, #0x7F                            ; Get both HEX rotary values 
 1901 00000f00 e1a03103         mov    r3,  r3, LSL #2                           ; Multiply by 4 to get word offset 
 1902 00000f04 e28f1f4f         add    r1,  pc, #xlli_CLK_DATA - (.+8)           ; Load address of CLK_DATA into r1 
 1903 00000f08 e0811003         add    r1,  r1,  r3                              ; Point to address that contains the CCCR data to be loaded 
 1904 00000f0c e5915000         ldr    r5,  [r1]                                 ; load CCCR value into r5 
 1905 00000f10 e2123080         ands   r3,  r2,  #0x80                           ; Is bit 7 set (to set the CCCR A bit)? - This is why we only 
 1906 00000f14                                                                   ;  need a table that goes through 7F (they're the same above it) 
 1907 00000f14 13855402         orrne  r5,  r5,  #0x2000000                      ; YES - set the A bit 
 1908 00000f18 e59f1484         ldr    r1,  =xlli_CLKREGS_PHYSICAL_BASE          ; Get clocks register base address 
 1909 00000f1c e5815000         str    r5,  [r1, #xlli_CCCR_offset]              ; Load the new CCCR value 
 1910 00000f20          ; 
 1911 00000f20          ;       Read back from APB to ensure our writes have completed before continuing 
 1912 00000f20          ; 
 1913 00000f20 e5915000         ldr    r5,  [r1, #xlli_CCCR_offset] 
 1914 00000f24            
 1915 00000f24          ; 
 1916 00000f24          ;       Check switch bit 9 for SDCLK setting (MemClk/2 or MemClock) 
 1917 00000f24          ; 
 1918 00000f24 e3a01312         ldr    r1,  =xlli_MEMORY_CONFIG_BASE     ; Clock registers base address 
 1919 00000f28 e5916004         ldr    r6,  [r1,  #xlli_MDREFR_offset]   ; get present value 
 1920 00000f2c e2123c02         ands   r3,  r2,   #0x200                 ; Test switch bit 9 for "dot" or "no dot" position 
 1921 00000f30 13c66802         bicne  r6,  r6,   #xlli_MDREFR_K1DB2     ; clear bit 
 1922 00000f34 03866802         orreq  r6,  r6,   #xlli_MDREFR_K1DB2     ; set bit so SDCLK = 1/2 MCEMCLK 
 1923 00000f38 e5816004         str    r6,  [r1,  #xlli_MDREFR_offset]   ; Write data back to register 
 1924 00000f3c          ; 
 1925 00000f3c          ;       Check switch bit 8 for Fast/Normal bus speed. 
 1926 00000f3c          ;       If hex switch setting is 0x5A - 0x7F or 0xDA and greater, the Fast Bus mode bit must 
 1927 00000f3c          ;       be cleared. 
 1928 00000f3c          ;       NOTE: Do not alter the contents of r5 which has the new CCCR value stored in it! 
 1929 00000f3c          ; 
 1930 00000f3c ee164e10         mrc    p14, 0, r4, c6, c0, 0    ; Get data in CP14, Register 6 
 1931 00000f40 e2123c01         ands   r3,  r2,  #0x100         ; Test bit 8 for "dot" or "no dot" 
 1932 00000f44 03c44008         biceq  r4,  r4,  #0X8           ; Clear Fast Bus speed bit 
 1933 00000f48 0a000007         beq    xlli_14                  ; B=0, so jump over the part that check if it's save to set B=1 
 1934 00000f4c 13844008         orrne  r4,  r4,  #0x8           ; Set Fast Bus speed bit 
 1935 00000f50            
 1936 00000f50          ;       At this point, B=1 so we need to compare against 0x5A through 0x7F and then against 
 1937 00000f50          ;       0xDA through 0xF7.  F8-FA are NECESSARY for A=1, N=3, B=1 is A LEGAL value, so must 
 1938 00000f50          ;       preserve.  Otherswise, we need to see if we've hit a point where the Fast Bus mode bit must be cleared 
 1939 00000f50          ; 
 1940 00000f50 e202307f         and    r3,  r2,  #0x7F          ; Grab just the HEX rotary switch value 
 1941 00000f54            
 1942 00000f54          ;       If we blindly assume A=1 in this compare, we've taken care of most of the problem.  This reduces 
 1943 00000f54          ;       the amount of compares to 2, as we compare against 0x5A which will take care of the 0xDA case also 
 1944 00000f54 e353005a         cmp    r3,  #0x5A               ; Compare to a hex switch setting of 0x5A (A=x, B=1) 
 1945 00000f58 da000003         ble    xlli_14                  ; Less than or Equal, jump over the next few instructions 
 1946 00000f5c            
 1947 00000f5c e20230ff         and    r3,  r2,  #0xFF          ; Grab just the HEX rotary switch value AGAIN 
 1948 00000f60 e35300f7         cmp    r3,  #0xF7               ; We've hit the F8-FA, so jump to end 
 1949 00000f64 ca000000         bgt    xlli_14 
 1950 00000f68            
 1951 00000f68          ;       Now clear the Fast Bus (B-bit) if we've hit this point 
 1952 00000f68 e3c44008         bic    r4,  r4,  #0x8           ; Clear Fast Bus speed bit if greater or equal to 0x5A 
 1953 00000f6c            
 1954 00000f6c          xlli_14 
 1955 00000f6c          ; 
 1956 00000f6c          ;       Check switch bit 10 for Turbo or non-Turbo mode. 
 1957 00000f6c          ; 
 1958 00000f6c e2123b01         ands   r3,  r2,  #0x400         ; Test switch bit 10 for "dot" or "no dot" position 
 1959 00000f70 03c44001         biceq  r4,  r4,  #1             ; Clear Turbo bit 
 1960 00000f74 13844001         orrne  r4,  r4,  #1             ; Set Turbo bit 
 1961 00000f78            
 1962 00000f78 e3c44002         bic    r4,  r4,  #0x2           ; Clear the F bit (so frequency change doesn't happen here) 
 1963 00000f7c            
 1964 00000f7c          ;       Now write the value back 
 1965 00000f7c ee064e10         mcr    p14, 0, r4, c6, c0, 0    ; Write data to CP14, Register 6 
 1966 00000f80            
 1967 00000f80          ;       At this point, although we've already set the MDREFR register based off of switch bit 9 
 1968 00000f80          ;       We need to chack the MDREFR register vs. the desired frequency.  If it's too high, we should 
 1969 00000f80          ;       halve or even quarter (for flash) if it's too hight to run properly.  This is being done here 
 1970 00000f80          ;       as it is the intent to call the frequency change sequency after this function. 
 1971 00000f80          ;       Values that need to halve or quarter MemClk (the rest can be left alone): 
 1972 00000f80          ; 
 1973 00000f80          ;           For A=0, B=0: 
 1974 00000f80          ;               K0DB2=1 (K1DB2 cleared) when L= 5-8 (0x15-0x30), 11-16 (0x3F-0x5A), 21-31 (0x67-0x7F) 
 1975 00000f80          ;               K0DB4=1 and K1DB2=1 when L= 9 (0x31-0x37), 10 (0x38-0x3E), 17-20 (0x5B-0x7F) 
 1976 00000f80          ; 
 1977 00000f80          ;           For A=0, B=1: *NOTE* (L17 and higher are illegal for B=1) 
 1978 00000f80          ;               K0DB2=1 (K1DB2 cleared) when L= 5-8 (0x15-0x30), 11-16 (0x3F-0x5A) 
 1979 00000f80          ;               K0DB4=1 and K1DB2=1 when L= 9 (0x31-0x37), 10 (0x38-0x3E) 
 1980 00000f80          ; 
 1981 00000f80          ;           For A=1, B=0: 
 1982 00000f80          ;               K0DB2=1 (K1DB2 cleared) when L= 9-16 (0xB1-0xDA) 
 1983 00000f80          ;               K0DB4=1 and K1DB2=1 when L= 17-31 (0xDB-0xFF) 
 1984 00000f80          ; 
 1985 00000f80          ;           For A=1, B=1: *NOTE* (L17 and higher are illegal for B=1) 
 1986 00000f80          ;               K0DB2=1 (K1DB2 cleared) when L= 5-8 (0x95-0xB0) 
 1987 00000f80          ;               K0DB4=1 and K1DB2=1 when L= 9-16 (0xB1-0xDA) 
 1988 00000f80          ; 
 1989 00000f80            
 1990 00000f80 e1a03006         mov     r3, r6  ; R6 from way above still contains the value we wrote to teh MDREFR register. 
 1991 00000f84            
 1992 00000f84          ;       Clear the KxDBx bits, so that way we can set it to what we want 
 1993 00000f84            
 1994 00000f84 e59f7440         ldr     r7,  =0x20084000                   ; KxDBx clear mask (leave K1DB2 from above) 
 1995 00000f88 e1c33007         bic     r3,  r3,  r7                       ; Clear the KxDBx bits 
 1996 00000f8c            
 1997 00000f8c          ;       At this point r5 = CCCR, R4 = B bit (CP14,R6). Pull out the relevant bits 
 1998 00000f8c            
 1999 00000f8c e2057402         and    r7,  r5,  #xlli_CCCR_A_Bit_Mask   ; R5 now has just the A bit 
 2000 00000f90 e1a07ca7         mov    r7,  r7,  LSR #25      ; move it down to the lowest bit (for easy comparison's sake) 
 2001 00000f94 e205201f         and    r2,  r5,  #0x1F        ; Get the L value 
 2002 00000f98 e2041008         and    r1,  r4,  #0x8         ; Get the B bit 
 2003 00000f9c e1a011a1         mov    r1,  r1,  LSR #3       ; Move it down (that comparison thing...) 
 2004 00000fa0            
 2005 00000fa0                  ; Now r0 = A-bit, r1 = B-bit, r2 = L-value 
 2006 00000fa0            
 2007 00000fa0 e3570000         cmp    r7,  #0x0              ; A == 0? 
 2008 00000fa4 1a000013         bne    xlli_a_equ_1           ; Nope, A=1, jump to that area of code 
 2009 00000fa8          ; 
 2010 00000fa8          ;       A=0 at this point 
 2011 00000fa8          ; 
 2012 00000fa8 e3510000         cmp    r1, #0x0               ; B == 0? 
 2013 00000fac 1a00000a         bne    xlli_a0_b_equ_1        ; Nope, A=0, B=1 
 2014 00000fb0            
 2015 00000fb0                  ; A=0, B=0 at this point 
 2016 00000fb0 e3520005         cmp    r2,  #0x5              ; r2 < 5 ? 
 2017 00000fb4 3a000020         bcc    xlli_done_mdrefr_check ; L2-L4 need no MemClk division 
 2018 00000fb8 e3520008         cmp    r2,  #0x8              ; r2 <= 8 ? 
 2019 00000fbc 9a000018         bls    xlli_set_k0db2         ; L5-L8 need MemClk/2 
 2020 00000fc0 e352000a         cmp    r2,  #0xA              ; r2 <= 10? 
 2021 00000fc4 9a00001a         bls    xlli_set_k0db4         ; L9-L10 need MemClk/4 
 2022 00000fc8 e3520010         cmp    r2,  #0x10             ; r2 <= 16? 
 2023 00000fcc 9a000014         bls    xlli_set_k0db2         ; L11-L16 need MemClk/2 
 2024 00000fd0 e3520014         cmp    r2,  #0x14             ; r2 <= 20? 
 2025 00000fd4 9a000016         bls    xlli_set_k0db4         ; L17-L20 need MemClk/4 
 2026 00000fd8 8a000011         bhi    xlli_set_k0db2         ; L21-L31 need MemClk/2 
 2027 00000fdc            
 2028 00000fdc          xlli_a0_b_equ_1 
 2029 00000fdc          ; 
 2030 00000fdc          ;       A=0, B=1 
 2031 00000fdc          ; 
 2032 00000fdc e3520005         cmp    r2,  #0x5              ; r2 < 5 ? 
 2033 00000fe0 3a000015         bcc    xlli_done_mdrefr_check ; L2-L4 need no MemClk division 
 2034 00000fe4 e3520008         cmp    r2,  #0x8              ; r2 <= 8 ? 
 2035 00000fe8 9a00000d         bls    xlli_set_k0db2         ; L5-L8 need MemClk/2 
 2036 00000fec e352000a         cmp    r2,  #0xA              ; r2 <= 10? 
 2037 00000ff0 9a00000f         bls    xlli_set_k0db4         ; L9-L10 need MemClk/4 
 2038 00000ff4 8a00000a         bhi    xlli_set_k0db2         ; L11-L16 need MemClk/2 - We've already prevented L above 16 when B=1 
 2039 00000ff8            
 2040 00000ff8          xlli_a_equ_1 
 2041 00000ff8          ; 
 2042 00000ff8          ;       A=1, B=? 
 2043 00000ff8          ; 
 2044 00000ff8 e3510000         cmp    r1, #0x0               ; B == 0? 
 2045 00000ffc 1a000004         bne    xlli_a1_b_equ_1        ; Nope, A=0, B=1 
 2046 00001000          ; 
 2047 00001000          ;       A=1, B=0 at this point 
 2048 00001000          ; 
 2049 00001000 e3520009         cmp    r2,  #0x9              ; r2 < 9 ? 
 2050 00001004 3a00000c         bcc    xlli_done_mdrefr_check ; L2-L8 need no MemClk division 
 2051 00001008 e3520010         cmp    r2,  #0x10              ; r2 <= 16 ? 
 2052 0000100c 9a000004         bls    xlli_set_k0db2         ; L9-L16 need MemClk/2 
 2053 00001010 8a000007         bhi    xlli_set_k0db4         ; L17-L31 need MemClk/4 
 2054 00001014            
 2055 00001014          xlli_a1_b_equ_1 
 2056 00001014          ; 
 2057 00001014          ;       A=1, B=1 
 2058 00001014          ; 
 2059 00001014 e3520005         cmp    r2,  #0x5              ; r2 < 5 ? 
 2060 00001018 3a000007         bcc    xlli_done_mdrefr_check ; L2-L4 need no MemClk division 
 2061 0000101c e3520008         cmp    r2,  #0x8              ; r2 <= 8 ? 
 2062 00001020 8a000003         bhi    xlli_set_k0db4         ; L9-L16 need MemClk/4 
 2063 00001024          ; 
 2064 00001024          ;       Just fall through to k0db2 for L5-8 
 2065 00001024          ; 
 2066 00001024          ;       NOTE:  Since the expected order is to call xlli_mem_Tmax before calling this function, 
 2067 00001024          ;       simply set the KxDBx bits and move on (mem timings already maxed) 
 2068 00001024          ; 
 2069 00001024          xlli_set_k0db2 
 2070 00001024          ; 
 2071 00001024          ;       Set the K0DB2 bit, K1DB2 does not need to be set 
 2072 00001024          ; 
 2073 00001024 e3a02001         mov r2, #0x1 
 2074 00001028 e1a02702         mov r2, r2, LSL #14  ; Set MDREFR bit 14 (K0DB2) 
 2075 0000102c e1833002         orr r3, r3, r2 
 2076 00001030 ea000001         b   xlli_done_mdrefr_check ;skip over the MemClk/4 stuff 
 2077 00001034            
 2078 00001034          xlli_set_k0db4 
 2079 00001034          ; 
 2080 00001034          ; Set the K0DB4 bit, K1DB2 must also be set (frequencies higher than 104MHz) 
 2081 00001034          ; 
 2082 00001034 e59f2394         ldr r2, =0x20020000  ; Set Bits 29 (K0DB4) & 17 (K1DB2) 
 2083 00001038 e1833002         orr r3, r3, r2 
 2084 0000103c          ; 
 2085 0000103c          ;       Now just fall through to setting the MDREFR back 
 2086 0000103c          ; 
 2087 0000103c          xlli_done_mdrefr_check 
 2088 0000103c          ; 
 2089 0000103c          ; Write the MDREFR value back and move on. 
 2090 0000103c          ; 
 2091 0000103c e3a07312         ldr     r7,  =xlli_MEMORY_CONFIG_BASE   ; Reload r0 with memory controller base address 
 2092 00001040 e5873004         str     r3,  [r7, #xlli_MDREFR_offset]  ; Set the new MDREFR value 
 2093 00001044            
 2094 00001044 e1a0f00e         mov     pc,  lr                 ; Return to calling routine 
 2095 00001048          ; 
 2096 00001048          ; The following table is a lookup table for the values of L and N to be used depending on the hex switch 
 2097 00001048          ; setting on the Mainstone development platform. The values listed below are simply the values to be 
 2098 00001048          ; loaded directly into the CCCR register.  "xx" = Hex Switch setting, L = Core frequency, N = Turbo multiplier 
 2099 00001048          ; 
 2100 00001048          xlli_CLK_DATA 
 2101 00001048 00000102         DCD     0x102     ; "00" L=2, N=1 
 2102 0000104c 00000182         DCD     0X182     ; "01" L=2, N=1.5 
 2103 00001050 00000202         DCD     0X202     ; "02" L=2, N=2 
 2104 00001054 00000282         DCD     0X282     ; "03" L=2, N=2.5 
 2105 00001058 00000302         DCD     0X302     ; "04" L=2, N=3 
 2106 0000105c 00000382         DCD     0X382     ; "05" L=2, N=3.5 
 2107 00001060 00000402         DCD     0X402     ; "06" L=2, N=4 
 2108 00001064            
 2109 00001064 00000103         DCD     0x103     ; "07" L=3, N=1 
 2110 00001068 00000183         DCD     0X183     ; "08" L=3, N=1.5 
 2111 0000106c 00000203         DCD     0X203     ; "09" L=3, N=2 
 2112 00001070 00000283         DCD     0X283     ; "0A" L=3, N=2.5 
 2113 00001074 00000303         DCD     0X303     ; "0B" L=3, N=3 
 2114 00001078 00000383         DCD     0X383     ; "0C" L=3, N=3.5 
 2115 0000107c 00000403         DCD     0X403     ; "0D" L=3, N=4 
 2116 00001080            
 2117 00001080 00000104         DCD     0x104     ; "0E" L=4, N=1 
 2118 00001084 00000184         DCD     0X184     ; "0F" L=4, N=1.5 
 2119 00001088 00000204         DCD     0X204     ; "10" L=4, N=2 
 2120 0000108c 00000284         DCD     0X284     ; "11" L=4, N=2.5 
 2121 00001090 00000304         DCD     0X304     ; "12" L=4, N=3 
 2122 00001094 00000384         DCD     0X384     ; "13" L=4, N=3.5 
 2123 00001098 00000404         DCD     0X404     ; "14" L=4, N=4 
 2124 0000109c            
 2125 0000109c 00000105         DCD     0x105     ; "15" L=5, N=1 
 2126 000010a0 00000185         DCD     0X185     ; "16" L=5, N=1.5 
 2127 000010a4 00000205         DCD     0X205     ; "17" L=5, N=2 
 2128 000010a8 00000285         DCD     0X285     ; "18" L=5, N=2.5 
 2129 000010ac 00000305         DCD     0X305     ; "19" L=5, N=3 
 2130 000010b0 00000385         DCD     0X385     ; "1A" L=5, N=3.5 
 2131 000010b4 00000405         DCD     0X405     ; "1B" L=5, N=4 
 2132 000010b8            
 2133 000010b8 00000106         DCD     0x106     ; "1C" L=6, N=1 
 2134 000010bc 00000186         DCD     0X186     ; "1D" L=6, N=1.5 
 2135 000010c0 00000206         DCD     0X206     ; "1E" L=6, N=2 
 2136 000010c4 00000286         DCD     0X286     ; "1F" L=6, N=2.5 
 2137 000010c8 00000306         DCD     0X306     ; "20" L=6, N=3 
 2138 000010cc 00000386         DCD     0X386     ; "21" L=6, N=3.5 
 2139 000010d0 00000406         DCD     0X406     ; "22" L=6, N=4 
 2140 000010d4            
 2141 000010d4 00000107         DCD     0x107     ; "23" L=7, N=1 
 2142 000010d8 00000187         DCD     0X187     ; "24" L=7, N=1.5 
 2143 000010dc 00000207         DCD     0X207     ; "25" L=7, N=2 
 2144 000010e0 00000287         DCD     0X287     ; "26" L=7, N=2.5 
 2145 000010e4 00000307         DCD     0X307     ; "27" L=7, N=3 
 2146 000010e8 00000387         DCD     0X387     ; "28" L=7, N=3.5 
 2147 000010ec 00000407         DCD     0X407     ; "29" L=7, N=4 
 2148 000010f0            
 2149 000010f0 00000108         DCD     0x108     ; "2A" L=8, N=1 
 2150 000010f4 00000188         DCD     0X188     ; "2B" L=8, N=1.5 
 2151 000010f8 00000208         DCD     0X208     ; "2C" L=8, N=2 
 2152 000010fc 00000288         DCD     0X288     ; "2D" L=8, N=2.5 
 2153 00001100 00000308         DCD     0X308     ; "2E" L=8, N=3 
 2154 00001104 00000388         DCD     0X388     ; "2F" L=8, N=3.5 
 2155 00001108 00000408         DCD     0X408     ; "30" L=8, N=4 
 2156 0000110c            
 2157 0000110c 00000109         DCD     0x109     ; "31" L=9, N=1 
 2158 00001110 00000189         DCD     0X189     ; "32" L=9, N=1.5 
 2159 00001114 00000209         DCD     0X209     ; "33" L=9, N=2 
 2160 00001118 00000289         DCD     0X289     ; "34" L=9, N=2.5 
 2161 0000111c 00000309         DCD     0X309     ; "35" L=9, N=3 
 2162 00001120 00000389         DCD     0X389     ; "36" L=9, N=3.5 
 2163 00001124 00000409         DCD     0X409     ; "37" L=9, N=4 
 2164 00001128            
 2165 00001128 0000010a         DCD     0x10A     ; "38" L=10, N=1 
 2166 0000112c 0000018a         DCD     0X18A     ; "39" L=10, N=1.5 
 2167 00001130 0000020a         DCD     0X20A     ; "3A" L=10, N=2 
 2168 00001134 0000028a         DCD     0X28A     ; "3B" L=10, N=2.5 
 2169 00001138 0000030a         DCD     0X30A     ; "3C" L=10, N=3 
 2170 0000113c 0000038a         DCD     0X38A     ; "3D" L=10, N=3.5 
 2171 00001140 0000040a         DCD     0X40A     ; "3E" L=10, N=4 
 2172 00001144            
 2173 00001144 0000010b         DCD     0x10B     ; "3F" L=11, N=1 
 2174 00001148 0000018b         DCD     0X18B     ; "40" L=11, N=1.5 
 2175 0000114c 0000020b         DCD     0X20B     ; "41" L=11, N=2 
 2176 00001150 0000028b         DCD     0X28B     ; "42" L=11, N=2.5 
 2177 00001154 0000030b         DCD     0X30B     ; "43" L=11, N=3 
 2178 00001158 0000038b         DCD     0X38B     ; "44" L=11, N=3.5 
 2179 0000115c            
 2180 0000115c 0000010c         DCD     0x10C     ; "45" L=12, N=1 
 2181 00001160 0000018c         DCD     0X18C     ; "46" L=12, N=1.5 
 2182 00001164 0000020c         DCD     0X20C     ; "47" L=12, N=2 
 2183 00001168 0000028c         DCD     0X28C     ; "48" L=12, N=2.5 
 2184 0000116c 0000030c         DCD     0X30C     ; "49" L=12, N=3 
 2185 00001170            
 2186 00001170 0000010d         DCD     0x10D     ; "4A" L=13, N=1 
 2187 00001174 0000018d         DCD     0X18D     ; "4B" L=13, N=1.5 
 2188 00001178 0000020d         DCD     0X20D     ; "4C" L=13, N=2 
 2189 0000117c 0000028d         DCD     0X28D     ; "4D" L=13, N=2.5 
 2190 00001180 0000030d         DCD     0X30D     ; "4E" L=13, N=3 
 2191 00001184            
 2192 00001184 0000010e         DCD     0x10E     ; "4F" L=14, N=1 
 2193 00001188 0000018e         DCD     0X18E     ; "50" L=14, N=1.5 
 2194 0000118c 0000020e         DCD     0X20E     ; "51" L=14, N=2 
 2195 00001190 0000028e         DCD     0X28E     ; "52" L=14, N=2.5 
 2196 00001194            
 2197 00001194 0000010f         DCD     0x10F     ; "53" L=15, N=1 
 2198 00001198 0000018f         DCD     0X18F     ; "54" L=15, N=1.5 
 2199 0000119c 0000020f         DCD     0X20F     ; "55" L=15, N=2 
 2200 000011a0 0000028f         DCD     0X28F     ; "56" L=15, N=2.5 
 2201 000011a4            
 2202 000011a4 00000110         DCD     0x110     ; "57" L=16, N=1 
 2203 000011a8 00000190         DCD     0X190     ; "58" L=16, N=1.5 
 2204 000011ac 00000210         DCD     0X210     ; "59" L=16, N=2 
 2205 000011b0 00000290         DCD     0X290     ; "5A" L=16, N=2.5 
 2206 000011b4            
 2207 000011b4 00000111         DCD     0x111     ; "5B" L=17, N=1 
 2208 000011b8 00000191         DCD     0x191     ; "5C" L=17, N=1.5 
 2209 000011bc 00000211         DCD     0x211     ; "5D" L=17, N=2 
 2210 000011c0            
 2211 000011c0 00000112         DCD     0x112     ; "5E" L=18, N=1 
 2212 000011c4 00000192         DCD     0x192     ; "5F" L=18, N=1.5 
 2213 000011c8 00000212         DCD     0x212     ; "60" L=18, N=2 
 2214 000011cc            
 2215 000011cc 00000113         DCD     0x113     ; "61" L=19, N=1 
 2216 000011d0 00000193         DCD     0x193     ; "62" L=19, N=1.5 
 2217 000011d4 00000213         DCD     0x213     ; "63" L=19, N=2 
 2218 000011d8            
 2219 000011d8 00000114         DCD     0x114     ; "64" L=20, N=1 
 2220 000011dc 00000194         DCD     0x194     ; "65" L=20, N=1.5 
 2221 000011e0 00000214         DCD     0x214     ; "66" L=20, N=2 
 2222 000011e4            
 2223 000011e4 00000115         DCD     0x115     ; "67" L=21, N=1 
 2224 000011e8 00000195         DCD     0x195     ; "68" L=21, N=1.5 
 2225 000011ec            
 2226 000011ec 00000116         DCD     0x116     ; "69" L=22, N=1 
 2227 000011f0 00000196         DCD     0x196     ; "6A" L=22, N=1.5 
 2228 000011f4            
 2229 000011f4 00000117         DCD     0x117     ; "6B" L=23, N=1 
 2230 000011f8 00000197         DCD     0x197     ; "6C" L=23, N=1.5 
 2231 000011fc            
 2232 000011fc 00000118         DCD     0x118     ; "6D" L=24, N=1 
 2233 00001200 00000198         DCD     0x198     ; "6E" L=24, N=1.5 
 2234 00001204            
 2235 00001204 00000119         DCD     0x119     ; "6F" L=25, N=1 
 2236 00001208 00000199         DCD     0x199     ; "70" L=25, N=1.5 
 2237 0000120c            
 2238 0000120c 0000011a         DCD     0x11A     ; "71" L=26, N=1 
 2239 00001210 0000019a         DCD     0x19A     ; "72" L=26, N=1.5 
 2240 00001214            
 2241 00001214 0000011b         DCD     0x11B     ; "73" L=27, N=1 
 2242 00001218            
 2243 00001218 0000011c         DCD     0x11C     ; "74" L=28, N=1 
 2244 0000121c            
 2245 0000121c 0000011d         DCD     0x11D     ; "75" L=29, N=1 
 2246 00001220            
 2247 00001220 0000011e         DCD     0x11E     ; "76" L=30, N=1 
 2248 00001224            
 2249 00001224 0000011f         DCD     0x11F     ; "77" L=31, N=1 
 2250 00001228            
 2251 00001228 0000030e         DCD     0X30E     ; "78" L=14, N=3 for 546 MHz Turbo Mode 
 2252 0000122c            
 2253 0000122c 0000030f         DCD     0X30F     ; "79" L=15, N=3 for 585 MHz Turbo Mode 
 2254 00001230            
 2255 00001230 00000310         DCD     0X310     ; "7A" L=16, N=3 for 624 MHz Turbo Mode 
 2256 00001234            
 2257 00001234 0000011f         DCD     0x11F     ; "7B" L=31, N=1 (same values as "77") 
 2258 00001238 0000011f         DCD     0x11F     ; "7C" L=31, N=1 (same values as "77") 
 2259 0000123c 0000011f         DCD     0x11F     ; "7D" L=31, N=1 (same values as "77") 
 2260 00001240 0000011f         DCD     0x11F     ; "7E" L=31, N=1 (same values as "77") 
 2261 00001244 0000011f         DCD     0x11F     ; "7F" L=31, N=1 (same values as "77") 
 2262 00001248          ; 
 2263 00001248          ;       For the A bit = 1 
 2264 00001248          ;       This table would be exactly the same as the above, only with the 'A' bit set, 
 2265 00001248          ;       so don't bother reproducting it. 
 2266 00001248          ; 
 2267 00001248                  ENDFUNC 
 2268 00001248          ;************************************************************************************************** 
 2269 00001248          ; 
 2270 00001248          ; ********************************************************** 
 2271 00001248          ; **********                                      ********** 
 2272 00001248          ; ********** GET SYSTEM CLOCKS FREQUENCY SETTINGS ********** 
 2273 00001248          ; **********     ( C Program callable version)    ********** 
 2274 00001248          ; ********************************************************** 
 2275 00001248          ; 
 2276 00001248          ; This subroutine returns all the data required to decode 
 2277 00001248          ; the frequencies of the system busses. 
 2278 00001248          ; 
 2279 00001248          ; R4 returns the following: 
 2280 00001248          ; 
 2281 00001248          ;     bits 4:0 = CCSR value of the L bits 
 2282 00001248          ;     bits 8:5 = CCSR value of the N bits 
 2283 00001248          ;     bit    9 = CLKCFG value for the TURBO bit 
 2284 00001248          ;     bit   10 = CLKCFG value for the B (Fast Bus) bit 
 2285 00001248          ;     bit   11 = CCSR value for the A bit 
 2286 00001248          ;     bit   12 = MDREFR value of K1DB2 bit 
 2287 00001248          ;     bit   13 = MDREFR value of K0DB4 bit 
 2288 00001248          ;     bit   14 = MDREFR value of K0DB2 bit 
 2289 00001248          ;     bit   15 = CLKCFG value of HT bit 
 2290 00001248          ;     bit   16 = PPDIS_S bit in the CCSR register 
 2291 00001248          ;     bit   17 = CPDIS_S bit in the CCSR register 
 2292 00001248          ; 
 2293 00001248            
 2294 00001248          xlli_getFreq  FUNCTION 
 2295 00001248            
 2296 00001248 e92d4006         stmfd   sp!, {r1, r2, lr}                 ; Save r1, r2 and link register on the stack 
 2297 0000124c            
 2298 0000124c e59f1150         ldr     r1,  =xlli_CLKREGS_PHYSICAL_BASE  ; Address base for clock config registers 
 2299 00001250 e591000c         ldr     r0,  [r1, #xlli_CCSR_offset]      ; Read the contents of CCSR into r0 
 2300 00001254 e1a01000         mov     r1,  r0                           ; and copy into r1 
 2301 00001258 e200001f         and     r0,  r0,  #0x1F                   ; Leave just the L bits in r0 
 2302 0000125c            
 2303 0000125c e2012d1e         and     r2,  r1,  #0x780                  ; Leave just the N bits in r2 
 2304 00001260 e1a02122         mov     r2,  r2,  LSR #2                  ; Shift N bits right by 2 bits 
 2305 00001264 e1800002         orr     r0,  r0,  r2                      ; and load into r0 
 2306 00001268 e2112101         ands    r2,  r1, #xlli_BIT_30             ; Is the PPDIS_S bit set? 
 2307 0000126c 13800801         orrne   r0,  r0, #xlli_BIT_16             ; Yes - set bit 16 in R0 
 2308 00001270 e2112102         ands    r2,  r1, #xlli_BIT_31             ; Is the CPDIS_S bit set? 
 2309 00001274 13800802         orrne   r0,  r0, #xlli_BIT_17             ; Yes - set bit 17 in R0 
 2310 00001278            
 2311 00001278 ee162e10         mrc     p14, 0, r2, c6, c0, 0             ; Get data in CP14, Register 6 
 2312 0000127c e2121001         ands    r1,  r2,  #xlli_BIT_0             ; Is the turbo bit set? 
 2313 00001280 13800c02         orrne   r0,  r0,  #xlli_BIT_9             ; Yes - set bit 9 in r0 
 2314 00001284 e2121008         ands    r1,  r2,  #xlli_BIT_3             ; Is the B bit set? 
 2315 00001288 13800b01         orrne   r0,  r0,  #xlli_BIT_10            ; Yes - set bit 10 in r0 
 2316 0000128c e2121004         ands    r1,  r2,  #xlli_BIT_2             ; is the HT bit set? 
 2317 00001290 13800902         orrne   r0,  r0,  #xlli_BIT_15            ; Yes - set bit 15 in r0 
 2318 00001294            
 2319 00001294 e59f1108         ldr     r1,  =xlli_CLKREGS_PHYSICAL_BASE  ; Address base for clock config registers 
 2320 00001298 e5912000         ldr     r2,  [r1, #xlli_CCCR_offset]      ; Read the contents of CCCR into r2 
 2321 0000129c e2121402         ands    r1,  r2,  #0x2000000              ; Is the A bit set? 
 2322 000012a0 13800b02         orrne   r0,  r0,  #xlli_BIT_11            ; Yes - set bit 11 in r0 
 2323 000012a4            
 2324 000012a4 e3a01312         ldr     r1,  =xlli_MEMORY_CONFIG_BASE     ; Get base address of memory registers 
 2325 000012a8 e5912004         ldr     r2,  [r1, #xlli_MDREFR_offset]    ; Get contents of MDREFR register 
 2326 000012ac e2121802         ands    r1,  r2,  #xlli_MDREFR_K1DB2      ; Is the K1DB2 bit set? 
 2327 000012b0 13800a01         orrne   r0,  r0,  #xlli_BIT_12            ; Yes - set bit 12 in r0 
 2328 000012b4 e2121202         ands    r1,  r2,  #xlli_MDREFR_K0DB4      ; Is the K0DB4 bit set? 
 2329 000012b8 13800a02         orrne   r0,  r0,  #xlli_BIT_13            ; Yes - set bit 13 in r0 
 2330 000012bc e2121901         ands    r1,  r2,  #xlli_MDREFR_K0DB2      ; Is the K0DB2 bit set? 
 2331 000012c0 13800901         orrne   r0,  r0,  #xlli_BIT_14            ; Yes - set bit 14 in r0 
 2332 000012c4            
 2333 000012c4 e8bd8006         ldmfd   sp!, {r1, r2, pc}                 ; Restore r1, r2 and return to caller 
 2334 000012c8            
 2335 000012c8                  ENDFUNC 
 2336 000012c8            
 2337 000012c8          ;************************************************************************************************** 
 2338 000012c8          ; 
 2339 000012c8          ; ****************************************************** 
 2340 000012c8          ; **********                                  ********** 
 2341 000012c8          ; ********** SET SDRAM MEMORY BUFFER STRENGTH ********** 
 2342 000012c8          ; **********   ( C Program callable version)  ********** 
 2343 000012c8          ; ****************************************************** 
 2344 000012c8          ; 
 2345 000012c8          ; This subroutine is a "C" callable function that adjusts the buffer drive impedance for SDRAM 
 2346 000012c8          ; 
 2347 000012c8          ; REQUIRED PARAMETER: 
 2348 000012c8          ; 
 2349 000012c8          ;       r0 = buffer strength (Range of 0x0 to 0xF) 
 2350 000012c8          ; 
 2351 000012c8          ;       Default value is 0x5 on system boot. A higher value results in a lower 
 2352 000012c8          ;       buffer impedance. This subroutine only changes buffer impedance that 
 2353 000012c8          ;       affect SDRAM. See Developer's Manual (Memory Controller) for more details. 
 2354 000012c8          ; 
 2355 000012c8            
 2356 000012c8          xlli_setBufImpedance  FUNCTION 
 2357 000012c8            
 2358 000012c8 e92d4006         stmfd   sp!, {r1, r2, lr}                 ; Save r1, r2 and link register on the stack 
 2359 000012cc e3a01312         ldr     r1,  =xlli_MEMORY_CONFIG_BASE     ; Get memory controller base address 
 2360 000012d0          ; 
 2361 000012d0          ;       Duplicate the value in lowest nibble so it is duplicated in all 8 nibbels 
 2362 000012d0          ; 
 2363 000012d0 e200000f         and     r0,  r0,  #0xF                    ; Isolate bits 3:0 of parameter 
 2364 000012d4 e1a02200         mov     r2,  r0,  LSL #4                  ; Shift 4 bits to the left 
 2365 000012d8 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2366 000012dc e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2367 000012e0 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2368 000012e4 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2369 000012e8 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2370 000012ec e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2371 000012f0 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2372 000012f4 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2373 000012f8 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2374 000012fc e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2375 00001300 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2376 00001304 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2377 00001308 e1800002         orr     r0,  r0,  r2                      ; Copy in next significant nibble 
 2378 0000130c          ; 
 2379 0000130c          ;       The 8 nibbles in r0 are now all the same value 
 2380 0000130c          ; 
 2381 0000130c e5810060         str     r0,  [r1, #xlli_BSCNTR3_offset]   ; Set buffer strength for address lines 
 2382 00001310 e581004c         str     r0,  [r1, #xlli_BSCNTR0_offset]   ; Set buffer strength for SDCLK 
 2383 00001314 e5912050         ldr     r2,  [r1, #xlli_BSCNTR1_offset]   ; Get buffer strength for BSCNTR1 
 2384 00001318 e20220f0         and     r2,  r2,  #0xF0                   ; Preserve bits 7:4 in r2 
 2385 0000131c e3c000f0         bic     r0,  r0,  #0xF0                   ; Clear bits 7:4 in r0 
 2386 00001320 e1802002         orr     r2,  r0,  r2                      ; OR with the value from BSCNTR1 
 2387 00001324 e5812050         str     r2,  [r1, #xlli_BSCNTR1_offset]   ; Write buffer strength to BSCNTR1 
 2388 00001328 e581005c         str     r0,  [r1, #xlli_BSCNTR2_offset]   ; Write buffer strength to BSCNTR2         
 2389 0000132c          ; 
 2390 0000132c          ;       Read back from APB to ensure our writes have completed before continuing 
 2391 0000132c          ; 
 2392 0000132c e591005c         ldr     r0,  [r1, #xlli_BSCNTR2_offset] 
 2393 00001330            
 2394 00001330 e8bd8006         ldmfd   sp!, {r1, r2, pc}                 ; Restore r1, r2 and return to caller 
 2395 00001334            
 2396 00001334                  ENDFUNC 
 2397 00001334          ;************************************************************************************************** 
 2398 00001334          ; 
 2399 00001334          ; ****************************************************** 
 2400 00001334          ; **********                                  ********** 
 2401 00001334          ; ********** SET SDRAM MEMORY BUFFER STRENGTH ********** 
 2402 00001334          ; **********       (ROM based version)        ********** 
 2403 00001334          ; ****************************************************** 
 2404 00001334          ; 
 2405 00001334          ; This subroutine adjusts the buffer drive impedance for SDRAM 
 2406 00001334          ; 
 2407 00001334          ; REQUIRED PARAMETER: 
 2408 00001334          ; 
 2409 00001334          ;       r3 = buffer strength (Range of 0x0 to 0xF) 
 2410 00001334          ; 
 2411 00001334          ;       Default value is 0x5 on system boot. A higher value results in a lower 
 2412 00001334          ;       buffer impedance. This subroutine only changes buffer impedance that 
 2413 00001334          ;       affect SDRAM. See Developer's Manual (Memory Controller) for more details. 
 2414 00001334          ; 
 2415 00001334            
 2416 00001334          xlli_setBufImp  FUNCTION 
 2417 00001334            
 2418 00001334 e3a01312         ldr     r1,  =xlli_MEMORY_CONFIG_BASE     ; Get memory controller base address 
 2419 00001338          ; 
 2420 00001338          ;       Duplicate the value in lowest nibble so it is duplicated in all 8 nibbels 
 2421 00001338          ; 
 2422 00001338 e203300f         and     r3,  r3,  #0xF                    ; Isolate bits 3:0 of parameter 
 2423 0000133c e1a02003         mov     r2,  r3                           ; Copy into r2 
 2424 00001340 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2425 00001344 e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2426 00001348 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2427 0000134c e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2428 00001350 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2429 00001354 e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2430 00001358 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2431 0000135c e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2432 00001360 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2433 00001364 e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2434 00001368 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2435 0000136c e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2436 00001370 e1a02202         mov     r2,  r2,  LSL #4                  ; Shift 4 bits to the left 
 2437 00001374 e1832002         orr     r2,  r3,  r2                      ; Copy in next significant nibble 
 2438 00001378          ; 
 2439 00001378          ;       The 8 nibbles in r2 are now all the same value 
 2440 00001378          ; 
 2441 00001378 e5812060         str     r2,  [r1, #xlli_BSCNTR3_offset]   ; Set buffer strength for address lines 
 2442 0000137c e581204c         str     r2,  [r1, #xlli_BSCNTR0_offset]   ; Set buffer strength for SDCLK 
 2443 00001380 e5913050         ldr     r3,  [r1, #xlli_BSCNTR1_offset]   ; Get buffer strength for BSCNTR1 
 2444 00001384 e20330f0         and     r3,  r3,  #0xF0                   ; Preserve bits 7:4 in r3 
 2445 00001388 e3c220f0         bic     r2,  r2,  #0xF0                   ; Clear bits 7:4 in r2 
 2446 0000138c e1833002         orr     r3,  r3,  r2                      ; OR with the value from BSCNTR1 
 2447 00001390 e5813050         str     r3,  [r1, #xlli_BSCNTR1_offset]   ; Write buffer strength to BSCNTR1 
 2448 00001394 e581205c         str     r2,  [r1, #xlli_BSCNTR2_offset]   ; Write buffer strength to BSCNTR2  
 2449 00001398          ; 
 2450 00001398          ;       Read back from APB to ensure our writes have completed before continuing 
 2451 00001398          ; 
 2452 00001398 e591005c         ldr     r0, [r1, #xlli_BSCNTR2_offset] 
 2453 0000139c            
 2454 0000139c e1a0f00e         mov     pc,  lr                           ; Return to calling routine 
 2455 000013a0            
 2456 000013a0                  ENDFUNC 
 2457 000013a0            
 2458 000013a0                  END 
 2459 000013a0 40d00000 *literal pool: constant 
 2459 000013a4 41300000 *literal pool: constant 
 2459 000013a8 00400200 *literal pool: constant 
 2459 000013ac 00000107 *literal pool: constant 
 2459 000013b0 40900000 *literal pool: constant 
 2459 000013b4 40a00000 *literal pool: constant 
 2459 000013b8 00000fff *literal pool: constant 
 2459 000013bc 40f00000 *literal pool: constant 
 2459 000013c0 ffd00f0c *literal pool: constant 
 2459 000013c4 a3ffc000 *literal pool: constant 
 2459 000013c8 5c03fffc *literal pool: constant 
 2459 000013cc 20084000 *literal pool: constant 
 2459 000013d0 20020000 *literal pool: constant 
Assembly terminated, errors: 0, warnings: 0 
