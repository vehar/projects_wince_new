; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_pccardsocket.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XllpPCCardConfigureGPIOs|
	IMPORT	|XllpUnlock|
	IMPORT	|XllpLock|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_pccardsocket.c

  00000			 AREA	 |.pdata|, PDATA
|$T1164| DCD	|$LN5@XllpPCCard|
	DCD	0x40004801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardConfigureGPIOs| PROC

; 194  : {

  00000		 |$LN5@XllpPCCard|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M1161|
  00004	e1a03000	 mov         r3, r0

; 195  :     XLLP_UINT32_T ulLockID;
; 196  :     volatile XLLP_GPIO_T *vpstrBvdGPIORegs = (volatile XLLP_GPIO_T *)pstrSocketHandle->pstrGpioRegsHandle;
; 197  : 
; 198  : 
; 199  :     //
; 200  :     //Configure GPIO Output Set registers for active-low, output GPIO pins.This is a required
; 201  :     //step for programming Bulverde GPIOs.
; 202  :     //
; 203  :     ulLockID = XllpLock(GPSR1);

  00008	e5934000	 ldr         r4, [r3]
  0000c	e3a00008	 mov         r0, #8
  00010	eb000000	 bl          XllpLock

; 204  :     vpstrBvdGPIORegs->GPSR1 |= (XLLP_GPIO_BIT_PCMCIA_nPOE |
; 205  :                                 XLLP_GPIO_BIT_nPWE |
; 206  :                                 XLLP_GPIO_BIT_PCMCIA_nPIOR |
; 207  :                                 XLLP_GPIO_BIT_PCMCIA_nPIOW |
; 208  :                                 XLLP_GPIO_BIT_PCMCIA_nPCE2 |
; 209  :                                 XLLP_GPIO_BIT_PCMCIA_nPREG);

  00014	e594301c	 ldr         r3, [r4, #0x1C]

; 210  :     XllpUnlock(ulLockID);

  00018	e38338cf	 orr         r3, r3, #0xCF, 16
  0001c	e584301c	 str         r3, [r4, #0x1C]
  00020	eb000000	 bl          XllpUnlock

; 211  : 
; 212  :     ulLockID = XllpLock(GPSR2);

  00024	e3a00009	 mov         r0, #9
  00028	eb000000	 bl          XllpLock

; 213  :     vpstrBvdGPIORegs->GPSR2 |= (XLLP_GPIO_BIT_PCMCIA_PSKTSEL |
; 214  :                                 XLLP_GPIO_BIT_PCMCIA_nPCE1);

  0002c	e5943020	 ldr         r3, [r4, #0x20]

; 215  :     XllpUnlock(ulLockID);

  00030	e3833982	 orr         r3, r3, #0x82, 18
  00034	e5843020	 str         r3, [r4, #0x20]
  00038	eb000000	 bl          XllpUnlock

; 216  : 
; 217  :     //
; 218  :     //Configure GPIO pin directions
; 219  :     //
; 220  :     //PC Card interface GPIO Output pins: GPIO 48, 49, 50, 51, 55, 78 and 79
; 221  :     //PC Card interface GPIO Input pins:  GPIO 56 and 57
; 222  :     ulLockID = XllpLock(GPDR1);

  0003c	e3a00005	 mov         r0, #5
  00040	eb000000	 bl          XllpLock

; 223  :     vpstrBvdGPIORegs->GPDR1 |= (XLLP_GPIO_BIT_PCMCIA_nPOE |
; 224  :                                 XLLP_GPIO_BIT_nPWE |
; 225  :                                 XLLP_GPIO_BIT_PCMCIA_nPIOR |
; 226  :                                 XLLP_GPIO_BIT_PCMCIA_nPIOW |
; 227  :                                 XLLP_GPIO_BIT_PCMCIA_nPCE2 |
; 228  :                                 XLLP_GPIO_BIT_PCMCIA_nPREG);

  00044	e5943010	 ldr         r3, [r4, #0x10]

; 229  : 
; 230  :     vpstrBvdGPIORegs->GPDR1 &= ~(XLLP_GPIO_BIT_PCMCIA_nPWAIT);
; 231  :     vpstrBvdGPIORegs->GPDR1 &= ~(XLLP_GPIO_BIT_PCMCIA_nIOIS16);

  00048	e38338cf	 orr         r3, r3, #0xCF, 16
  0004c	e5843010	 str         r3, [r4, #0x10]
  00050	e5943010	 ldr         r3, [r4, #0x10]

; 232  :     XllpUnlock(ulLockID);

  00054	e3c33401	 bic         r3, r3, #1, 8
  00058	e5843010	 str         r3, [r4, #0x10]
  0005c	e5943010	 ldr         r3, [r4, #0x10]
  00060	e3c33402	 bic         r3, r3, #2, 8
  00064	e5843010	 str         r3, [r4, #0x10]
  00068	eb000000	 bl          XllpUnlock

; 233  : 
; 234  :     ulLockID = XllpLock(GPDR2);

  0006c	e3a00006	 mov         r0, #6
  00070	eb000000	 bl          XllpLock

; 235  :     vpstrBvdGPIORegs->GPDR2 |= XLLP_GPIO_BIT_PCMCIA_PSKTSEL;

  00074	e5943014	 ldr         r3, [r4, #0x14]

; 236  :     vpstrBvdGPIORegs->GPDR2 |= XLLP_GPIO_BIT_PCMCIA_nPCE1;
; 237  :     XllpUnlock(ulLockID);

  00078	e3833902	 orr         r3, r3, #2, 18
  0007c	e5843014	 str         r3, [r4, #0x14]
  00080	e5943014	 ldr         r3, [r4, #0x14]
  00084	e3833602	 orr         r3, r3, #2, 12
  00088	e5843014	 str         r3, [r4, #0x14]
  0008c	eb000000	 bl          XllpUnlock

; 238  : 
; 239  :     //
; 240  :     //Configure GPIO pin alternate functions
; 241  :     //
; 242  :     ulLockID = XllpLock(GAFR1_U);

  00090	e3a00019	 mov         r0, #0x19
  00094	eb000000	 bl          XllpLock

; 243  :     vpstrBvdGPIORegs->GAFR1_U &= 0xFFF00F00;  //Clear the alternate function bits

  00098	e5942060	 ldr         r2, [r4, #0x60]
  0009c	e3e03aff	 mvn         r3, #0xFF, 20
  000a0	e22330ff	 eor         r3, r3, #0xFF
  000a4	e0023003	 and         r3, r2, r3
  000a8	e5843060	 str         r3, [r4, #0x60]

; 244  :                                               //for GPIO 48, 49, 50, 51, 55, 56 and 57
; 245  :     //Set Alternate Function 2 for GPIO 48, 49, 50, 51 and 55
; 246  :     vpstrBvdGPIORegs->GAFR1_U |= (XLLP_GPIO_AF_BIT_PCMCIA_nPOE |
; 247  :                                   XLLP_GPIO_AF_BIT_nPWE |
; 248  :                                   XLLP_GPIO_AF_BIT_PCMCIA_nPIOR |
; 249  :                                   XLLP_GPIO_AF_BIT_PCMCIA_nPIOW |
; 250  :                                   XLLP_GPIO_AF_BIT_PCMCIA_nPCE2 |
; 251  :                                   XLLP_GPIO_AF_BIT_PCMCIA_nPREG);

  000ac	e5942060	 ldr         r2, [r4, #0x60]
  000b0	e3a03a0a	 mov         r3, #0xA, 20
  000b4	e38330aa	 orr         r3, r3, #0xAA
  000b8	e1823003	 orr         r3, r2, r3
  000bc	e5843060	 str         r3, [r4, #0x60]

; 252  : 
; 253  :     //Set Alternate Function 1 for GPIO 56 and 57
; 254  :     vpstrBvdGPIORegs->GAFR1_U |= (XLLP_GPIO_AF_BIT_PCMCIA_nPWAIT |
; 255  :                                   XLLP_GPIO_AF_BIT_PCMCIA_nIOIS16);

  000c0	e5943060	 ldr         r3, [r4, #0x60]

; 256  :     XllpUnlock(ulLockID);

  000c4	e3833805	 orr         r3, r3, #5, 16
  000c8	e5843060	 str         r3, [r4, #0x60]
  000cc	eb000000	 bl          XllpUnlock

; 257  : 
; 258  :     ulLockID = XllpLock(GAFR2_L);

  000d0	e3a0001a	 mov         r0, #0x1A
  000d4	eb000000	 bl          XllpLock

; 259  :     vpstrBvdGPIORegs->GAFR2_L &= 0x3FFFFFFF;  //Clear the alternate function bits

  000d8	e5943064	 ldr         r3, [r4, #0x64]
  000dc	e3c33103	 bic         r3, r3, #3, 2
  000e0	e5843064	 str         r3, [r4, #0x64]

; 260  :                                               //for GPIO 79
; 261  :     //Set Alternate Function 1 for GPIO 79
; 262  :     vpstrBvdGPIORegs->GAFR2_L |= XLLP_GPIO_AF_BIT_PCMCIA_PSKTSEL;

  000e4	e5943064	 ldr         r3, [r4, #0x64]

; 263  :     XllpUnlock(ulLockID);

  000e8	e3833101	 orr         r3, r3, #1, 2
  000ec	e5843064	 str         r3, [r4, #0x64]
  000f0	eb000000	 bl          XllpUnlock

; 264  : 
; 265  :     ulLockID = XllpLock(GAFR2_U);

  000f4	e3a0001b	 mov         r0, #0x1B
  000f8	eb000000	 bl          XllpLock

; 266  :     vpstrBvdGPIORegs->GAFR2_U &= 0xFFFFF3FF;  //Clear the alternate function bits for GPIO 85

  000fc	e5943068	 ldr         r3, [r4, #0x68]
  00100	e3c33b03	 bic         r3, r3, #3, 22
  00104	e5843068	 str         r3, [r4, #0x68]

; 267  :     vpstrBvdGPIORegs->GAFR2_U |= XLLP_GPIO_AF_BIT_PCMCIA_nPCE1;

  00108	e5943068	 ldr         r3, [r4, #0x68]

; 268  :     XllpUnlock(ulLockID);

  0010c	e3833b01	 orr         r3, r3, #1, 22
  00110	e5843068	 str         r3, [r4, #0x68]
  00114	eb000000	 bl          XllpUnlock

; 269  : 
; 270  : } //end XllpPCCardConfigureGPIOs()

  00118	e8bd4010	 ldmia       sp!, {r4, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$M1162|

			 ENDP  ; |XllpPCCardConfigureGPIOs|

	EXPORT	|XllpPCCardGetSocketState|

  00000			 AREA	 |.pdata|, PDATA
|$T1176| DCD	|$LN30@XllpPCCard@2|
	DCD	0x40004a03
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardGetSocketState| PROC

; 292  : {

  00000		 |$LN30@XllpPCCard@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M1173|

; 293  : 
; 294  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;
; 295  : 
; 296  : 
; 297  :     //Check the validity of the input arguments to the function
; 298  :     if((ushSocketNumber > XLLP_MAINSTONE_MAX_PCCARD_SOCKETS) ||
; 299  :        (pstrSocketHandle == XLLP_NULL_PTR))

  0000c	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00010	e3a0e000	 mov         lr, #0
  00014	e3530002	 cmp         r3, #2
  00018	8a00003e	 bhi         |$LN23@XllpPCCard@2|
  0001c	e3500000	 cmp         r0, #0
  00020	0a00003c	 beq         |$LN23@XllpPCCard@2|

; 302  :     }
; 303  : 
; 304  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 305  :     {
; 306  :         switch(ushSocketNumber)

  00024	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00028	e3530000	 cmp         r3, #0
  0002c	0a00001d	 beq         |$LN19@XllpPCCard@2|
  00030	e3530001	 cmp         r3, #1
  00034	1a000038	 bne         |$LN11@XllpPCCard@2|

; 364  :                 }
; 365  : 
; 366  :                 break;
; 367  : 
; 368  :             case XLLP_PCCARD_SOCKET1:
; 369  : 
; 370  :                 //
; 371  :                 //Check the CD status bit[5] of the Socket 1 Status Register. If set, it indicates
; 372  :                 //that a card is either not present or is not properly inserted in the socket. If clear,
; 373  :                 //it indicates that a card is present in the socket.
; 374  :                 //
; 375  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BCR_PCMCIA_SCR_S1_nCD))

  00038	e5903004	 ldr         r3, [r0, #4]
  0003c	e3a01000	 mov         r1, #0
  00040	e3a02001	 mov         r2, #1
  00044	e59330e4	 ldr         r3, [r3, #0xE4]
  00048	e3130020	 tst         r3, #0x20

; 376  :                 {
; 377  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1CDState = XLLP_FALSE;

  0004c	e5903008	 ldr         r3, [r0, #8]
  00050	15c31004	 strneb      r1, [r3, #4]

; 378  :                 }
; 379  :                 else
; 380  :                 {
; 381  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1CDState = XLLP_TRUE;

  00054	05c32004	 streqb      r2, [r3, #4]

; 382  :                 }
; 383  : 
; 384  :                 //
; 385  :                 //Check the BVD1 status bit[8] of the Socket 1 Status Register. If set, then it
; 386  :                 //indicates that the card status has not changed. If clear, then it indicates that
; 387  :                 //a card status change event has occurred.
; 388  :                 //
; 389  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BCR_PCMCIA_SCR_S1_nSTSCHG_BVD1))

  00058	e5903004	 ldr         r3, [r0, #4]
  0005c	e59330e4	 ldr         r3, [r3, #0xE4]
  00060	e3130c01	 tst         r3, #1, 24

; 390  :                 {
; 391  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1BVD1State = XLLP_FALSE;

  00064	e5903008	 ldr         r3, [r0, #8]
  00068	15c31005	 strneb      r1, [r3, #5]

; 392  :                 }
; 393  :                 else
; 394  :                 {
; 395  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1BVD1State = XLLP_TRUE;

  0006c	05c32005	 streqb      r2, [r3, #5]

; 396  :                 }
; 397  : 
; 398  :                 //
; 399  :                 //Check the BVD2 status bit[9] of the Socket 1 Status Register. If set, then it
; 400  :                 //indicates that the card status has not changed. If clear, then it indicates that
; 401  :                 //a card status change event has occurred.
; 402  :                 //
; 403  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BCR_PCMCIA_SCR_S1_nSPKR_BVD2))

  00070	e5903004	 ldr         r3, [r0, #4]
  00074	e59330e4	 ldr         r3, [r3, #0xE4]
  00078	e3130c02	 tst         r3, #2, 24

; 404  :                 {
; 405  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1BVD2State = XLLP_FALSE;

  0007c	e5903008	 ldr         r3, [r0, #8]
  00080	15c31006	 strneb      r1, [r3, #6]

; 406  :                 }
; 407  :                 else
; 408  :                 {
; 409  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1BVD2State = XLLP_TRUE;

  00084	05c32006	 streqb      r2, [r3, #6]

; 410  :                 }
; 411  : 
; 412  :                 //
; 413  :                 //Check the IREQ status bit[10] of the Socket 1 Status Register. If set, then it
; 414  :                 //indicates that the card is READY (i.e. no interrupt request is pending). If clear,
; 415  :                 //it indicates that the card is BUSY, pending an interrupt request.
; 416  :                 //
; 417  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BCR_PCMCIA_SCR_S1_nIRQ))

  00088	e5903004	 ldr         r3, [r0, #4]
  0008c	e59330e4	 ldr         r3, [r3, #0xE4]
  00090	e3130b01	 tst         r3, #1, 22

; 418  :                 {
; 419  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1IREQState = XLLP_TRUE;

  00094	e5903008	 ldr         r3, [r0, #8]
  00098	15c32007	 strneb      r2, [r3, #7]
  0009c	1a00001e	 bne         |$LN11@XllpPCCard@2|

; 420  :                 }
; 421  :                 else
; 422  :                 {
; 423  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket1IREQState = XLLP_FALSE;

  000a0	e5c31007	 strb        r1, [r3, #7]

; 424  :                 }
; 425  : 
; 426  :                 break;

  000a4	ea00001c	 b           |$LN11@XllpPCCard@2|
  000a8		 |$LN19@XllpPCCard@2|

; 307  :         {
; 308  :             case XLLP_PCCARD_SOCKET0:
; 309  : 
; 310  :                 //
; 311  :                 //Check the CD status bit[5] of the Socket 0 Status Register. If set, it indicates
; 312  :                 //that a card is either not present or is not properly inserted in the socket. If clear,
; 313  :                 //it indicates that a card is present in the socket.
; 314  :                 //
; 315  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nCD))

  000a8	e5903004	 ldr         r3, [r0, #4]
  000ac	e3a01000	 mov         r1, #0
  000b0	e3a02001	 mov         r2, #1
  000b4	e59330e0	 ldr         r3, [r3, #0xE0]
  000b8	e3130020	 tst         r3, #0x20

; 316  :                 {
; 317  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0CDState = XLLP_FALSE;

  000bc	e5903008	 ldr         r3, [r0, #8]
  000c0	15c31000	 strneb      r1, [r3]

; 318  :                 }
; 319  :                 else
; 320  :                 {
; 321  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0CDState = XLLP_TRUE;

  000c4	05c32000	 streqb      r2, [r3]

; 322  :                 }
; 323  : 
; 324  :                 //
; 325  :                 //Check the BVD1 status bit[8] of the Socket 0 Status Register. If set, then it
; 326  :                 //indicates that the card status has not changed. If clear, then it indicates that
; 327  :                 //a card status change event has occurred.
; 328  :                 //
; 329  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nSTSCHG_BVD1))

  000c8	e5903004	 ldr         r3, [r0, #4]
  000cc	e59330e0	 ldr         r3, [r3, #0xE0]
  000d0	e3130c01	 tst         r3, #1, 24

; 330  :                 {
; 331  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0BVD1State = XLLP_FALSE;

  000d4	e5903008	 ldr         r3, [r0, #8]
  000d8	15c31001	 strneb      r1, [r3, #1]

; 332  :                 }
; 333  :                 else
; 334  :                 {
; 335  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0BVD1State = XLLP_TRUE;

  000dc	05c32001	 streqb      r2, [r3, #1]

; 336  :                 }
; 337  : 
; 338  :                 //
; 339  :                 //Check the BVD2 status bit[9] of the Socket 0 Status Register. If set, then it
; 340  :                 //indicates that the card status has not changed. If clear, then it indicates that
; 341  :                 //a card status change event has occurred.
; 342  :                 //
; 343  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nSPKR_BVD2))

  000e0	e5903004	 ldr         r3, [r0, #4]
  000e4	e59330e0	 ldr         r3, [r3, #0xE0]
  000e8	e3130c02	 tst         r3, #2, 24

; 344  :                 {
; 345  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0BVD2State = XLLP_FALSE;

  000ec	e5903008	 ldr         r3, [r0, #8]
  000f0	15c31002	 strneb      r1, [r3, #2]

; 346  :                 }
; 347  :                 else
; 348  :                 {
; 349  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0BVD2State = XLLP_TRUE;

  000f4	05c32002	 streqb      r2, [r3, #2]

; 350  :                 }
; 351  : 
; 352  :                 //
; 353  :                 //Check the IREQ status bit[10] of the Socket 0 Status Register. If set, then it
; 354  :                 //indicates that the card is READY (i.e. no interrupt request is pending). If clear,
; 355  :                 //it indicates that the card is BUSY, pending an interrupt request.
; 356  :                 //
; 357  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nIRQ))

  000f8	e5903004	 ldr         r3, [r0, #4]
  000fc	e59330e0	 ldr         r3, [r3, #0xE0]
  00100	e3130b01	 tst         r3, #1, 22

; 358  :                 {
; 359  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0IREQState = XLLP_TRUE;

  00104	e5903008	 ldr         r3, [r0, #8]
  00108	15c32003	 strneb      r2, [r3, #3]
  0010c	1a000002	 bne         |$LN11@XllpPCCard@2|

; 360  :                 }
; 361  :                 else
; 362  :                 {
; 363  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0IREQState = XLLP_FALSE;

  00110	e5c31003	 strb        r1, [r3, #3]
  00114	ea000000	 b           |$LN11@XllpPCCard@2|
  00118		 |$LN23@XllpPCCard@2|

; 300  :     {
; 301  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;   

  00118	e3a0e00f	 mov         lr, #0xF

; 360  :                 }
; 361  :                 else
; 362  :                 {
; 363  :                     pstrSocketHandle->pstrPCCardSocketState->blSocket0IREQState = XLLP_FALSE;

  0011c		 |$LN11@XllpPCCard@2|

; 427  : 
; 428  :             default:
; 429  :                 break;
; 430  : 
; 431  :         } //end switch(uSocket)
; 432  : 
; 433  :     } //end if
; 434  : 
; 435  :     return ReturnValue;
; 436  : 
; 437  : } //end XllpPCCardGetSocketState()

  0011c	e1a0000e	 mov         r0, lr
  00120	e89d6000	 ldmia       sp, {sp, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$M1174|

			 ENDP  ; |XllpPCCardGetSocketState|

	EXPORT	|XllpPCCardResetSocket|
	IMPORT	|XllpOstDelayMilliSeconds|

  00000			 AREA	 |.pdata|, PDATA
|$T1195| DCD	|$LN33@XllpPCCard@3|
	DCD	0x40005103
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardResetSocket| PROC

; 458  : {

  00000		 |$LN33@XllpPCCard@3|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5070	 stmdb       sp!, {r4 - r6, r12, lr}
  0000c		 |$M1192|
  0000c	e1a04000	 mov         r4, r0

; 459  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;
; 460  :     XLLP_BOOL_T blCDStatus = XLLP_FALSE;
; 461  :     XLLP_BOOL_T blRDYStatus = XLLP_FALSE;
; 462  :     XLLP_UINT16_T t; //loop counter
; 463  : 
; 464  :     //Check the validity of the input arguments to the function
; 465  :     if((ushSocketNumber > XLLP_MAINSTONE_MAX_PCCARD_SOCKETS) ||
; 466  :        (pstrSocketHandle == XLLP_NULL_PTR))

  00010	e1dd31b8	 ldrh        r3, [sp, #0x18]
  00014	e3a05000	 mov         r5, #0
  00018	e3530002	 cmp         r3, #2
  0001c	8a000044	 bhi         |$LN21@XllpPCCard@3|
  00020	e3540000	 cmp         r4, #0
  00024	0a000042	 beq         |$LN21@XllpPCCard@3|

; 469  :     }
; 470  : 
; 471  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 472  :     {
; 473  :         switch(ushSocketNumber)

  00028	e1dd31b8	 ldrh        r3, [sp, #0x18]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000020	 beq         |$LN17@XllpPCCard@3|
  00034	e3530001	 cmp         r3, #1

; 579  : 
; 580  :             default:
; 581  :                 //TBD. Should not be here at all!!
; 582  :                 ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 583  : 
; 584  :             break;

  00038	1a00003d	 bne         |$LN21@XllpPCCard@3|
  0003c	e5942004	 ldr         r2, [r4, #4]
  00040	e59230e4	 ldr         r3, [r2, #0xE4]
  00044	e2133020	 ands        r3, r3, #0x20
  00048	1a000039	 bne         |$LN21@XllpPCCard@3|
  0004c	e59230e4	 ldr         r3, [r2, #0xE4]
  00050	e3a010c8	 mov         r1, #0xC8
  00054	e3833010	 orr         r3, r3, #0x10
  00058	e58230e4	 str         r3, [r2, #0xE4]
  0005c	e594000c	 ldr         r0, [r4, #0xC]
  00060	eb000000	 bl          XllpOstDelayMilliSeconds
  00064	e5942004	 ldr         r2, [r4, #4]
  00068	e3a01014	 mov         r1, #0x14
  0006c	e59230e4	 ldr         r3, [r2, #0xE4]
  00070	e3c33010	 bic         r3, r3, #0x10
  00074	e58230e4	 str         r3, [r2, #0xE4]
  00078	e594000c	 ldr         r0, [r4, #0xC]
  0007c	eb000000	 bl          XllpOstDelayMilliSeconds
  00080	e3a06000	 mov         r6, #0
  00084		 |$LL7@XllpPCCard@3|
  00084	e5943004	 ldr         r3, [r4, #4]
  00088	e59330e4	 ldr         r3, [r3, #0xE4]
  0008c	e2133b01	 ands        r3, r3, #1, 22
  00090	1a000028	 bne         |$LN10@XllpPCCard@3|
  00094	e594000c	 ldr         r0, [r4, #0xC]
  00098	e3a01032	 mov         r1, #0x32
  0009c	eb000000	 bl          XllpOstDelayMilliSeconds
  000a0	e2863032	 add         r3, r6, #0x32
  000a4	e1a06803	 mov         r6, r3, lsl #16
  000a8	e1a06826	 mov         r6, r6, lsr #16
  000ac	e3560e7d	 cmp         r6, #0x7D, 28
  000b0	3afffff3	 bcc         |$LL7@XllpPCCard@3|

; 521  :                 {
; 522  :                     //Tri-state the socket here.
; 523  :                     ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 524  :                 }
; 525  : 
; 526  :             break;
; 527  : 
; 528  :             case XLLP_PCCARD_SOCKET1:
; 529  :                 //Check if a card is inserted in the socket
; 530  :                 blCDStatus = ((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) &
; 531  :                                                      (XLLP_BCR_PCMCIA_SCR_S1_nCD));
; 532  : 
; 533  :                 //If the CD status bit is *not* set in the PC Card Status register,
; 534  :                 //it implies that a card is properly inserted. Reset the socket
; 535  :                 //in that case.
; 536  :                 if(!blCDStatus)
; 537  :                 {
; 538  :                     //Assert reset
; 539  :                     (pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) |=
; 540  :                                           (XLLP_BCR_PCMCIA_SCR_S1_RESET);
; 541  : 
; 542  : 					// Wait long enough for the device to notice.
; 543  :                     XllpOstDelayMilliSeconds(pstrSocketHandle->pstrOstRegsHandle,200);
; 544  : 
; 545  :                     //Clear reset
; 546  :                     (pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) &=
; 547  :                                          ~(XLLP_BCR_PCMCIA_SCR_S1_RESET);
; 548  :                     XllpOstDelayMilliSeconds(pstrSocketHandle->pstrOstRegsHandle,20);
; 549  : 
; 550  : 
; 551  :                     //Wait for the READY signal to be set.This will indicate that the socket
; 552  :                     //is interrupt-ready and can function normally now.
; 553  :                     for(t = 0; t < XLLP_PCCARD_MAX_READY_WAIT_TIME;  t += XLLP_PCCARD_READY_POLL_INTERVAL)
; 554  :                     {
; 555  :                         blRDYStatus = ((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) &
; 556  :                                                              (XLLP_BCR_PCMCIA_SCR_S1_nIRQ));
; 557  : 
; 558  :                         if(!blRDYStatus)
; 559  :                         {
; 560  :                             XllpOstDelayMilliSeconds(pstrSocketHandle->pstrOstRegsHandle,
; 561  :                                                      XLLP_PCCARD_READY_POLL_INTERVAL);
; 562  :                         }
; 563  :                         else
; 564  :                         {
; 565  :                             break;
; 566  :                         }
; 567  :                     } //end for loop
; 568  : 
; 569  :                 }
; 570  :                 //If no card is inserted or if a card is not properly inserted, then tri-
; 571  :                 //state the socket.
; 572  :                 else
; 573  :                 {
; 574  :                     //Tri-state the socket here
; 575  :                     ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 576  :                 }
; 577  : 
; 578  :             break;

  000b4	ea00001f	 b           |$LN10@XllpPCCard@3|
  000b8		 |$LN17@XllpPCCard@3|

; 474  :         {
; 475  :             case XLLP_PCCARD_SOCKET0:
; 476  : 
; 477  :                 //
; 478  :                 //Check if a card is inserted in the socket
; 479  :                 //
; 480  :                 blCDStatus = ((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nCD));

  000b8	e5942004	 ldr         r2, [r4, #4]
  000bc	e59230e0	 ldr         r3, [r2, #0xE0]
  000c0	e2133020	 ands        r3, r3, #0x20

; 481  : 
; 482  :                 //
; 483  :                 //If the CD status bit is *not* set in the PC Card Status register,
; 484  :                 //it implies that a card is properly inserted. Reset the socket
; 485  :                 //in that case.
; 486  :                 //
; 487  :                 if(!blCDStatus)

  000c4	1a00001a	 bne         |$LN21@XllpPCCard@3|

; 488  :                 {
; 489  :                     //Assert reset
; 490  :                     (pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) |= (XLLP_BCR_PCMCIA_SCR_S0_RESET);

  000c8	e59230e0	 ldr         r3, [r2, #0xE0]

; 491  : 
; 492  : 					// Wait long enough for the device to notice.
; 493  :                     XllpOstDelayMilliSeconds(pstrSocketHandle->pstrOstRegsHandle,200);

  000cc	e3a010c8	 mov         r1, #0xC8
  000d0	e3833010	 orr         r3, r3, #0x10
  000d4	e58230e0	 str         r3, [r2, #0xE0]
  000d8	e594000c	 ldr         r0, [r4, #0xC]
  000dc	eb000000	 bl          XllpOstDelayMilliSeconds

; 494  : 
; 495  :                     //Clear reset
; 496  :                     (pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) &= ~(XLLP_BCR_PCMCIA_SCR_S0_RESET);

  000e0	e5942004	 ldr         r2, [r4, #4]

; 497  : 
; 498  :                     //Wait for the READY signal to be set.This will indicate that the socket
; 499  :                     XllpOstDelayMilliSeconds(pstrSocketHandle->pstrOstRegsHandle,20);

  000e4	e3a01014	 mov         r1, #0x14
  000e8	e59230e0	 ldr         r3, [r2, #0xE0]
  000ec	e3c33010	 bic         r3, r3, #0x10
  000f0	e58230e0	 str         r3, [r2, #0xE0]
  000f4	e594000c	 ldr         r0, [r4, #0xC]
  000f8	eb000000	 bl          XllpOstDelayMilliSeconds

; 500  :                     //is interrupt-ready and can function normally now.
; 501  :                     for(t = 0; t < XLLP_PCCARD_MAX_READY_WAIT_TIME;  t += XLLP_PCCARD_READY_POLL_INTERVAL)

  000fc	e3a06000	 mov         r6, #0
  00100		 |$LL15@XllpPCCard@3|

; 502  :                     {
; 503  :                         blRDYStatus = ((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) &
; 504  :                                                              (XLLP_BCR_PCMCIA_SCR_S0_nIRQ));

  00100	e5943004	 ldr         r3, [r4, #4]
  00104	e59330e0	 ldr         r3, [r3, #0xE0]
  00108	e2133b01	 ands        r3, r3, #1, 22

; 505  : 
; 506  :                         if(!blRDYStatus)

  0010c	1a000009	 bne         |$LN10@XllpPCCard@3|

; 507  :                         {
; 508  :                             XllpOstDelayMilliSeconds(pstrSocketHandle->pstrOstRegsHandle,
; 509  :                                                      XLLP_PCCARD_READY_POLL_INTERVAL);                          

  00110	e594000c	 ldr         r0, [r4, #0xC]
  00114	e3a01032	 mov         r1, #0x32
  00118	eb000000	 bl          XllpOstDelayMilliSeconds
  0011c	e2863032	 add         r3, r6, #0x32
  00120	e1a06803	 mov         r6, r3, lsl #16
  00124	e1a06826	 mov         r6, r6, lsr #16
  00128	e3560e7d	 cmp         r6, #0x7D, 28
  0012c	3afffff3	 bcc         |$LL15@XllpPCCard@3|

; 510  :                         }
; 511  :                         else
; 512  :                         {
; 513  :                             break;
; 514  :                         }
; 515  :                     } //end for loop
; 516  : 
; 517  :                 }
; 518  :                 //If no card is inserted or if a card is not properly inserted, then tri-
; 519  :                 //state the socket.
; 520  :                 else

  00130	ea000000	 b           |$LN10@XllpPCCard@3|
  00134		 |$LN21@XllpPCCard@3|

; 467  :     {
; 468  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;   

  00134	e3a0500f	 mov         r5, #0xF
  00138		 |$LN10@XllpPCCard@3|

; 585  :         } //end switch
; 586  : 
; 587  :     } //end if
; 588  : 
; 589  :     return ReturnValue;
; 590  : 
; 591  : } //end XllpPCCardResetSocket()

  00138	e1a00005	 mov         r0, r5
  0013c	e89d6070	 ldmia       sp, {r4 - r6, sp, lr}
  00140	e12fff1e	 bx          lr
  00144		 |$M1193|

			 ENDP  ; |XllpPCCardResetSocket|

	EXPORT	|XllpPCCardPowerOn|

  00000			 AREA	 |.pdata|, PDATA
|$T1210| DCD	|$LN24@XllpPCCard@4|
	DCD	0x40004c03
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardPowerOn| PROC

; 614  : {

  00000		 |$LN24@XllpPCCard@4|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M1207|
  0000c	e1a01000	 mov         r1, r0

; 615  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;
; 616  : 
; 617  : 
; 618  : 
; 619  :     //
; 620  :     //Check the validity of the input arguments to the function
; 621  :     //
; 622  :     if((ushSocketNumber > XLLP_MAINSTONE_MAX_PCCARD_SOCKETS) ||
; 623  :        (pstrSocketHandle == XLLP_NULL_PTR))

  00010	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00014	e3a00000	 mov         r0, #0
  00018	e3530002	 cmp         r3, #2
  0001c	8a000040	 bhi         |$LN15@XllpPCCard@4|
  00020	e3510000	 cmp         r1, #0
  00024	0a00003e	 beq         |$LN15@XllpPCCard@4|

; 626  :     }
; 627  : 
; 628  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 629  :     {
; 630  :         switch(ushSocketNumber)

  00028	e1dd30bc	 ldrh        r3, [sp, #0xC]
  0002c	e3530000	 cmp         r3, #0
  00030	0a00001e	 beq         |$LN11@XllpPCCard@4|
  00034	e3530001	 cmp         r3, #1

; 683  :                 break;
; 684  : 
; 685  :             default:
; 686  :                 //TBD. Should not be here at all!!
; 687  :                 ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 688  : 
; 689  :             break;

  00038	1a000039	 bne         |$LN15@XllpPCCard@4|

; 658  : 
; 659  :                 break;
; 660  : 
; 661  :             case XLLP_PCCARD_SOCKET1:
; 662  : 
; 663  :                 if(uiCardVoltage == XLLP_PCCARD_5_00VOLTS)

  0003c	e3520002	 cmp         r2, #2
  00040	1a000008	 bne         |$LN5@XllpPCCard@4|

; 664  :                 {
; 665  :                     //5V card detected; set bit[2] of the status register
; 666  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR |= (XLLP_BIT_2);

  00044	e5912004	 ldr         r2, [r1, #4]

; 667  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR &= ~(XLLP_BIT_3);

  00048	e59230e4	 ldr         r3, [r2, #0xE4]
  0004c	e3833004	 orr         r3, r3, #4
  00050	e58230e4	 str         r3, [r2, #0xE4]
  00054	e5912004	 ldr         r2, [r1, #4]
  00058	e59230e4	 ldr         r3, [r2, #0xE4]
  0005c	e3c33008	 bic         r3, r3, #8

; 673  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR &= ~(XLLP_BIT_2);

  00060	e58230e4	 str         r3, [r2, #0xE4]

; 674  :                 }
; 675  :                 else

  00064	ea00000b	 b           |$LN2@XllpPCCard@4|
  00068		 |$LN5@XllpPCCard@4|

; 668  :                 }
; 669  :                 else if(uiCardVoltage == XLLP_PCCARD_3_30VOLTS)

  00068	e3520001	 cmp         r2, #1
  0006c	1a000008	 bne         |$LN3@XllpPCCard@4|

; 670  :                 {
; 671  :                     //3.3V card detected; set bit[3] of the status register
; 672  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR |= (XLLP_BIT_3);

  00070	e5912004	 ldr         r2, [r1, #4]

; 673  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR &= ~(XLLP_BIT_2);

  00074	e59230e4	 ldr         r3, [r2, #0xE4]
  00078	e3833008	 orr         r3, r3, #8
  0007c	e58230e4	 str         r3, [r2, #0xE4]
  00080	e5912004	 ldr         r2, [r1, #4]
  00084	e59230e4	 ldr         r3, [r2, #0xE4]
  00088	e3c33004	 bic         r3, r3, #4
  0008c	e58230e4	 str         r3, [r2, #0xE4]

; 674  :                 }
; 675  :                 else

  00090	ea000000	 b           |$LN2@XllpPCCard@4|
  00094		 |$LN3@XllpPCCard@4|

; 676  :                 {
; 677  :                     //
; 678  :                     //Unsupported PC Card voltage
; 679  :                     //
; 680  :                     ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  00094	e3a0000f	 mov         r0, #0xF
  00098		 |$LN2@XllpPCCard@4|

; 681  :                 }
; 682  :                 (pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) &= ~(XLLP_BCR_PCMCIA_SCR_S1_RESET);

  00098	e5912004	 ldr         r2, [r1, #4]
  0009c	e59230e4	 ldr         r3, [r2, #0xE4]
  000a0	e3c33010	 bic         r3, r3, #0x10
  000a4	e58230e4	 str         r3, [r2, #0xE4]

; 690  :         } //end switch
; 691  :     }
; 692  : 
; 693  :     return ReturnValue;
; 694  : 
; 695  : } //end XllpPCCardEnableSocket()

  000a8	e89d6000	 ldmia       sp, {sp, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN11@XllpPCCard@4|

; 631  :         {
; 632  :             case XLLP_PCCARD_SOCKET0:
; 633  : 
; 634  :                 if(uiCardVoltage == XLLP_PCCARD_5_00VOLTS)

  000b0	e3520002	 cmp         r2, #2
  000b4	1a000008	 bne         |$LN10@XllpPCCard@4|

; 635  :                 {
; 636  :                     //
; 637  :                     //5V card detected; set bit[2] of the status register
; 638  :                     //
; 639  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR |= (XLLP_BIT_2);

  000b8	e5912004	 ldr         r2, [r1, #4]

; 640  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR &= ~(XLLP_BIT_3);

  000bc	e59230e0	 ldr         r3, [r2, #0xE0]
  000c0	e3833004	 orr         r3, r3, #4
  000c4	e58230e0	 str         r3, [r2, #0xE0]
  000c8	e5912004	 ldr         r2, [r1, #4]
  000cc	e59230e0	 ldr         r3, [r2, #0xE0]
  000d0	e3c33008	 bic         r3, r3, #8

; 648  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR &= ~(XLLP_BIT_2);

  000d4	e58230e0	 str         r3, [r2, #0xE0]

; 649  :                 }
; 650  :                 else

  000d8	ea00000b	 b           |$LN7@XllpPCCard@4|
  000dc		 |$LN10@XllpPCCard@4|

; 641  :                 }
; 642  :                 else if(uiCardVoltage == XLLP_PCCARD_3_30VOLTS)

  000dc	e3520001	 cmp         r2, #1
  000e0	1a000008	 bne         |$LN8@XllpPCCard@4|

; 643  :                 {
; 644  :                     //
; 645  :                     //3.3V card detected; set bit[3] of the status register
; 646  :                     //
; 647  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR |= (XLLP_BIT_3);

  000e4	e5912004	 ldr         r2, [r1, #4]

; 648  :                     pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR &= ~(XLLP_BIT_2);

  000e8	e59230e0	 ldr         r3, [r2, #0xE0]
  000ec	e3833008	 orr         r3, r3, #8
  000f0	e58230e0	 str         r3, [r2, #0xE0]
  000f4	e5912004	 ldr         r2, [r1, #4]
  000f8	e59230e0	 ldr         r3, [r2, #0xE0]
  000fc	e3c33004	 bic         r3, r3, #4
  00100	e58230e0	 str         r3, [r2, #0xE0]

; 649  :                 }
; 650  :                 else

  00104	ea000000	 b           |$LN7@XllpPCCard@4|
  00108		 |$LN8@XllpPCCard@4|

; 651  :                 {
; 652  :                     //
; 653  :                     //Unsupported PC Card voltage
; 654  :                     //
; 655  :                     ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  00108	e3a0000f	 mov         r0, #0xF
  0010c		 |$LN7@XllpPCCard@4|

; 656  :                 }
; 657  :                 (pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) &= ~(XLLP_BCR_PCMCIA_SCR_S0_RESET);

  0010c	e5912004	 ldr         r2, [r1, #4]
  00110	e59230e0	 ldr         r3, [r2, #0xE0]
  00114	e3c33010	 bic         r3, r3, #0x10
  00118	e58230e0	 str         r3, [r2, #0xE0]

; 690  :         } //end switch
; 691  :     }
; 692  : 
; 693  :     return ReturnValue;
; 694  : 
; 695  : } //end XllpPCCardEnableSocket()

  0011c	e89d6000	 ldmia       sp, {sp, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN15@XllpPCCard@4|

; 624  :     {
; 625  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  00124	e3a0000f	 mov         r0, #0xF

; 690  :         } //end switch
; 691  :     }
; 692  : 
; 693  :     return ReturnValue;
; 694  : 
; 695  : } //end XllpPCCardEnableSocket()

  00128	e89d6000	 ldmia       sp, {sp, lr}
  0012c	e12fff1e	 bx          lr
  00130		 |$M1208|

			 ENDP  ; |XllpPCCardPowerOn|

	EXPORT	|XllpPCCardPowerOff|

  00000			 AREA	 |.pdata|, PDATA
|$T1222| DCD	|$LN14@XllpPCCard@5|
	DCD	0x40002603
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardPowerOff| PROC

; 717  : {

  00000		 |$LN14@XllpPCCard@5|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M1219|
  0000c	e1a01000	 mov         r1, r0

; 718  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;
; 719  : 
; 720  : 
; 721  : 
; 722  :     //
; 723  :     //Check the validity of the input arguments to the function
; 724  :     //
; 725  :     if((ushSocketNumber > XLLP_MAINSTONE_MAX_PCCARD_SOCKETS) ||
; 726  :        (pstrSocketHandle == XLLP_NULL_PTR))

  00010	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00014	e3a00000	 mov         r0, #0
  00018	e3530002	 cmp         r3, #2
  0001c	8a00001a	 bhi         |$LN7@XllpPCCard@5|
  00020	e3510000	 cmp         r1, #0
  00024	0a000018	 beq         |$LN7@XllpPCCard@5|

; 729  :     }
; 730  : 
; 731  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 732  :     {
; 733  :         switch(ushSocketNumber)

  00028	e1dd30bc	 ldrh        r3, [sp, #0xC]
  0002c	e3530000	 cmp         r3, #0
  00030	0a00000b	 beq         |$LN3@XllpPCCard@5|
  00034	e3530001	 cmp         r3, #1

; 742  : 
; 743  :                 break;
; 744  : 
; 745  :             case XLLP_PCCARD_SOCKET1:
; 746  : 
; 747  :                 //
; 748  :                 //Power off the socket
; 749  :                 //
; 750  :                 pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR |= (XLLP_BIT_2);
; 751  :                 pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR |= (XLLP_BIT_3);
; 752  : 
; 753  :                 break;
; 754  : 
; 755  :             default:
; 756  : 
; 757  :                 //TBD. Should not be here at all!!
; 758  :                 ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 759  : 
; 760  :             break;

  00038	1a000013	 bne         |$LN7@XllpPCCard@5|
  0003c	e5912004	 ldr         r2, [r1, #4]
  00040	e59230e4	 ldr         r3, [r2, #0xE4]
  00044	e3833004	 orr         r3, r3, #4
  00048	e58230e4	 str         r3, [r2, #0xE4]
  0004c	e5912004	 ldr         r2, [r1, #4]
  00050	e59230e4	 ldr         r3, [r2, #0xE4]
  00054	e3833008	 orr         r3, r3, #8
  00058	e58230e4	 str         r3, [r2, #0xE4]

; 761  : 
; 762  :         } //end switch
; 763  :     } //end if
; 764  : 
; 765  :     return ReturnValue;
; 766  : 
; 767  : } //end XllpPCCardResetSocket()

  0005c	e89d6000	 ldmia       sp, {sp, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN3@XllpPCCard@5|

; 734  :         {
; 735  :             case XLLP_PCCARD_SOCKET0:
; 736  : 
; 737  :                 //
; 738  :                 //Power off the socket
; 739  :                 //
; 740  :                 pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR |= (XLLP_BIT_2);

  00064	e5912004	 ldr         r2, [r1, #4]
  00068	e59230e0	 ldr         r3, [r2, #0xE0]
  0006c	e3833004	 orr         r3, r3, #4
  00070	e58230e0	 str         r3, [r2, #0xE0]

; 741  :                 pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR |= (XLLP_BIT_3);

  00074	e5912004	 ldr         r2, [r1, #4]
  00078	e59230e0	 ldr         r3, [r2, #0xE0]
  0007c	e3833008	 orr         r3, r3, #8
  00080	e58230e0	 str         r3, [r2, #0xE0]

; 761  : 
; 762  :         } //end switch
; 763  :     } //end if
; 764  : 
; 765  :     return ReturnValue;
; 766  : 
; 767  : } //end XllpPCCardResetSocket()

  00084	e89d6000	 ldmia       sp, {sp, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$LN7@XllpPCCard@5|

; 727  :     {
; 728  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  0008c	e3a0000f	 mov         r0, #0xF

; 761  : 
; 762  :         } //end switch
; 763  :     } //end if
; 764  : 
; 765  :     return ReturnValue;
; 766  : 
; 767  : } //end XllpPCCardResetSocket()

  00090	e89d6000	 ldmia       sp, {sp, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M1220|

			 ENDP  ; |XllpPCCardPowerOff|

	EXPORT	|XllpPCCardGetVoltageSetting|

  00000			 AREA	 |.pdata|, PDATA
|$T1238| DCD	|$LN25@XllpPCCard@6|
	DCD	0x40002c03
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardGetVoltageSetting| PROC

; 790  : {

  00000		 |$LN25@XllpPCCard@6|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M1235|
  0000c	e1a01000	 mov         r1, r0

; 791  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;
; 792  : 
; 793  : 
; 794  : 
; 795  :     //
; 796  :     //Check the validity of the input arguments to the function
; 797  :     //
; 798  :     if((ushSocketNumber > XLLP_MAINSTONE_MAX_PCCARD_SOCKETS) ||
; 799  :        (pstrSocketHandle == XLLP_NULL_PTR))

  00010	e1dd30bc	 ldrh        r3, [sp, #0xC]
  00014	e3a00000	 mov         r0, #0
  00018	e3530002	 cmp         r3, #2
  0001c	8a000020	 bhi         |$LN15@XllpPCCard@6|
  00020	e3510000	 cmp         r1, #0
  00024	0a00001e	 beq         |$LN15@XllpPCCard@6|

; 802  :     }
; 803  : 
; 804  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 805  :     {
; 806  :         switch(ushSocketNumber)

  00028	e1dd30bc	 ldrh        r3, [sp, #0xC]
  0002c	e3530000	 cmp         r3, #0
  00030	0a00000d	 beq         |$LN11@XllpPCCard@6|
  00034	e3530001	 cmp         r3, #1

; 865  :                     }
; 866  :                 }
; 867  : 
; 868  :                 break;
; 869  : 
; 870  :             default:
; 871  : 
; 872  :                 //TBD. Should not be here at all!!
; 873  :                 ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 874  : 
; 875  :             break;

  00038	1a000019	 bne         |$LN15@XllpPCCard@6|
  0003c	e5911004	 ldr         r1, [r1, #4]
  00040	e59130e4	 ldr         r3, [r1, #0xE4]
  00044	e3130020	 tst         r3, #0x20
  00048	1a000015	 bne         |$LN15@XllpPCCard@6|
  0004c	e59130e4	 ldr         r3, [r1, #0xE4]
  00050	e3130040	 tst         r3, #0x40
  00054	159130e4	 ldrne       r3, [r1, #0xE4]
  00058	1a00000b	 bne         |$LN22@XllpPCCard@6|
  0005c		 |$LN3@XllpPCCard@6|

; 827  :                     }
; 828  :                     else
; 829  :                     {
; 830  :                         //
; 831  :                         //3.3 volt card detected in the socket
; 832  :                         //
; 833  :                         *puiCardVoltage = XLLP_PCCARD_3_30VOLTS;
; 834  :                     }
; 835  :                 }
; 836  : 
; 837  :                 break;
; 838  : 
; 839  :             case XLLP_PCCARD_SOCKET1:
; 840  : 
; 841  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nCD))
; 842  :                 {
; 843  :                     ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 844  :                 }
; 845  :                 else
; 846  :                 {
; 847  :                     //
; 848  :                     //Determine the voltage requirements of the PC Card, else
; 849  :                     //default voltage to 3.3V
; 850  :                     //
; 851  :                     if(((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BIT_6)) &&
; 852  :                        ((pstrSocketHandle->pstrBcrHandle->PCMCIAS1SCR) & (XLLP_BIT_7)))
; 853  :                     {
; 854  :                         //
; 855  :                         //5 volt card detected in the socket
; 856  :                         //
; 857  :                         *puiCardVoltage = XLLP_PCCARD_5_00VOLTS;
; 858  :                     }
; 859  :                     else
; 860  :                     {
; 861  :                         //
; 862  :                         //3.3 volt card detected in the socket
; 863  :                         //
; 864  :                         *puiCardVoltage = XLLP_PCCARD_3_30VOLTS;

  0005c	e3a03001	 mov         r3, #1

; 822  :                     {
; 823  :                         //
; 824  :                         //5 volt card detected in the socket
; 825  :                         //
; 826  :                         *puiCardVoltage = XLLP_PCCARD_5_00VOLTS;

  00060	e5823000	 str         r3, [r2]

; 876  : 
; 877  :         } //end switch
; 878  :     }
; 879  : 
; 880  :     return ReturnValue;
; 881  : 
; 882  : } //end XllpPCCardGetVoltageSetting()

  00064	e89d6000	 ldmia       sp, {sp, lr}
  00068	e12fff1e	 bx          lr
  0006c		 |$LN11@XllpPCCard@6|

; 807  :         {
; 808  :             case XLLP_PCCARD_SOCKET0:
; 809  : 
; 810  :                 if((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BCR_PCMCIA_SCR_S0_nCD))

  0006c	e5911004	 ldr         r1, [r1, #4]
  00070	e59130e0	 ldr         r3, [r1, #0xE0]
  00074	e3130020	 tst         r3, #0x20

; 811  :                 {
; 812  :                     ReturnValue = XLLP_STATUS_PCCARD_FAILURE;
; 813  :                 }
; 814  :                 else

  00078	1a000009	 bne         |$LN15@XllpPCCard@6|

; 815  :                 {
; 816  :                     //
; 817  :                     //Determine the voltage requirements of the PC Card, else
; 818  :                     //default voltage to 3.3V
; 819  :                     //
; 820  :                     if(((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BIT_6)) &&
; 821  :                        ((pstrSocketHandle->pstrBcrHandle->PCMCIAS0SCR) & (XLLP_BIT_7)))

  0007c	e59130e0	 ldr         r3, [r1, #0xE0]
  00080	e3130040	 tst         r3, #0x40
  00084	0afffff4	 beq         |$LN3@XllpPCCard@6|
  00088	e59130e0	 ldr         r3, [r1, #0xE0]
  0008c		 |$LN22@XllpPCCard@6|
  0008c	e3130080	 tst         r3, #0x80
  00090	0afffff1	 beq         |$LN3@XllpPCCard@6|

; 822  :                     {
; 823  :                         //
; 824  :                         //5 volt card detected in the socket
; 825  :                         //
; 826  :                         *puiCardVoltage = XLLP_PCCARD_5_00VOLTS;

  00094	e3a03002	 mov         r3, #2
  00098	e5823000	 str         r3, [r2]

; 876  : 
; 877  :         } //end switch
; 878  :     }
; 879  : 
; 880  :     return ReturnValue;
; 881  : 
; 882  : } //end XllpPCCardGetVoltageSetting()

  0009c	e89d6000	 ldmia       sp, {sp, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN15@XllpPCCard@6|

; 800  :     {
; 801  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  000a4	e3a0000f	 mov         r0, #0xF

; 876  : 
; 877  :         } //end switch
; 878  :     }
; 879  : 
; 880  :     return ReturnValue;
; 881  : 
; 882  : } //end XllpPCCardGetVoltageSetting()

  000a8	e89d6000	 ldmia       sp, {sp, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$M1236|

			 ENDP  ; |XllpPCCardGetVoltageSetting|

	EXPORT	|XllpPCCardSetExpMemTiming|

  00000			 AREA	 |.pdata|, PDATA
|$T1250| DCD	|$LN8@XllpPCCard@7|
	DCD	0x40001d00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardSetExpMemTiming| PROC

; 903  : {

  00000		 |$LN8@XllpPCCard@7|
  00000		 |$M1247|
  00000	e1b01000	 movs        r1, r0

; 904  : 
; 905  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;

  00004	e3a00000	 mov         r0, #0

; 906  : 
; 907  :     //
; 908  :     //Check the validity of the input arguments to the function
; 909  :     //
; 910  :     if(pstrSocketHandle == XLLP_NULL_PTR)
; 911  :     {
; 912  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  00008	03a0000f	 moveq       r0, #0xF

; 925  :     }
; 926  : 
; 927  :     return ReturnValue;
; 928  : 
; 929  : } //end XllpPCCardSetExpMemTiming()

  0000c	012fff1e	 bxeq        lr

; 913  :     }
; 914  : 
; 915  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 916  :     {
; 917  :         pstrSocketHandle->pstrMemCtrlRegsHandle->MCATT0 = pstrSocketHandle->pstrCardTimingHandle->MCATT0;

  00010	e5913010	 ldr         r3, [r1, #0x10]
  00014	e5912014	 ldr         r2, [r1, #0x14]
  00018	e5933008	 ldr         r3, [r3, #8]
  0001c	e5823030	 str         r3, [r2, #0x30]

; 918  :         pstrSocketHandle->pstrMemCtrlRegsHandle->MCATT1 = pstrSocketHandle->pstrCardTimingHandle->MCATT1;

  00020	e5913010	 ldr         r3, [r1, #0x10]
  00024	e5912014	 ldr         r2, [r1, #0x14]
  00028	e593300c	 ldr         r3, [r3, #0xC]
  0002c	e5823034	 str         r3, [r2, #0x34]

; 919  : 
; 920  :         pstrSocketHandle->pstrMemCtrlRegsHandle->MCMEM0 = pstrSocketHandle->pstrCardTimingHandle->MCMEM0;

  00030	e5913010	 ldr         r3, [r1, #0x10]
  00034	e5912014	 ldr         r2, [r1, #0x14]
  00038	e5933000	 ldr         r3, [r3]
  0003c	e5823028	 str         r3, [r2, #0x28]

; 921  :         pstrSocketHandle->pstrMemCtrlRegsHandle->MCMEM1 = pstrSocketHandle->pstrCardTimingHandle->MCMEM1;

  00040	e5913010	 ldr         r3, [r1, #0x10]
  00044	e5912014	 ldr         r2, [r1, #0x14]
  00048	e5933004	 ldr         r3, [r3, #4]
  0004c	e582302c	 str         r3, [r2, #0x2C]

; 922  : 
; 923  :         pstrSocketHandle->pstrMemCtrlRegsHandle->MCIO0 = pstrSocketHandle->pstrCardTimingHandle->MCIO0;

  00050	e5913010	 ldr         r3, [r1, #0x10]
  00054	e5912014	 ldr         r2, [r1, #0x14]
  00058	e5933010	 ldr         r3, [r3, #0x10]
  0005c	e5823038	 str         r3, [r2, #0x38]

; 924  :         pstrSocketHandle->pstrMemCtrlRegsHandle->MCIO1 = pstrSocketHandle->pstrCardTimingHandle->MCIO1;

  00060	e5913010	 ldr         r3, [r1, #0x10]
  00064	e5912014	 ldr         r2, [r1, #0x14]
  00068	e5933014	 ldr         r3, [r3, #0x14]
  0006c	e582303c	 str         r3, [r2, #0x3C]

; 925  :     }
; 926  : 
; 927  :     return ReturnValue;
; 928  : 
; 929  : } //end XllpPCCardSetExpMemTiming()

  00070	e12fff1e	 bx          lr
  00074		 |$M1248|

			 ENDP  ; |XllpPCCardSetExpMemTiming|

	EXPORT	|XllpPCCardGetExpMemTiming|

  00000			 AREA	 |.pdata|, PDATA
|$T1263| DCD	|$LN9@XllpPCCard@8|
	DCD	0x40001a00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardGetExpMemTiming| PROC

; 951  : {

  00000		 |$LN9@XllpPCCard@8|
  00000		 |$M1260|
  00000	e1b02000	 movs        r2, r0

; 952  :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;

  00004	e3a00000	 mov         r0, #0

; 953  : 
; 954  :     //
; 955  :     //Check the validity of the input arguments to the function
; 956  :     //
; 957  :     if((pstrSocketHandle == XLLP_NULL_PTR) ||
; 958  :        (pstrCardTimingHandle == XLLP_NULL_PTR))

  00008	0a000014	 beq         |$LN2@XllpPCCard@8|
  0000c	e3510000	 cmp         r1, #0
  00010	0a000012	 beq         |$LN2@XllpPCCard@8|

; 961  :     }
; 962  : 
; 963  :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 964  :     {
; 965  :         pstrCardTimingHandle->MCATT0 = pstrSocketHandle->pstrMemCtrlRegsHandle->MCATT0;

  00014	e5923014	 ldr         r3, [r2, #0x14]

; 966  :         pstrCardTimingHandle->MCATT1 = pstrSocketHandle->pstrMemCtrlRegsHandle->MCATT1;

  00018	e5933030	 ldr         r3, [r3, #0x30]

; 967  : 
; 968  :         pstrCardTimingHandle->MCMEM0 = pstrSocketHandle->pstrMemCtrlRegsHandle->MCMEM0;
; 969  :         pstrCardTimingHandle->MCMEM1 = pstrSocketHandle->pstrMemCtrlRegsHandle->MCMEM1;
; 970  : 
; 971  :         pstrCardTimingHandle->MCIO0 = pstrSocketHandle->pstrMemCtrlRegsHandle->MCIO0;
; 972  :         pstrCardTimingHandle->MCIO1 = pstrSocketHandle->pstrMemCtrlRegsHandle->MCIO1;

  0001c	e5813008	 str         r3, [r1, #8]
  00020	e5923014	 ldr         r3, [r2, #0x14]
  00024	e5933034	 ldr         r3, [r3, #0x34]
  00028	e581300c	 str         r3, [r1, #0xC]
  0002c	e5923014	 ldr         r3, [r2, #0x14]
  00030	e5933028	 ldr         r3, [r3, #0x28]
  00034	e5813000	 str         r3, [r1]
  00038	e5923014	 ldr         r3, [r2, #0x14]
  0003c	e593302c	 ldr         r3, [r3, #0x2C]
  00040	e5813004	 str         r3, [r1, #4]
  00044	e5923014	 ldr         r3, [r2, #0x14]
  00048	e5933038	 ldr         r3, [r3, #0x38]
  0004c	e5813010	 str         r3, [r1, #0x10]
  00050	e5923014	 ldr         r3, [r2, #0x14]
  00054	e593303c	 ldr         r3, [r3, #0x3C]
  00058	e5813014	 str         r3, [r1, #0x14]

; 973  :     }
; 974  : 
; 975  :     return ReturnValue;
; 976  : 
; 977  : } //end XllpPCCardGetExpMemTiming()

  0005c	e12fff1e	 bx          lr
  00060		 |$LN2@XllpPCCard@8|

; 959  :     {
; 960  :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;

  00060	e3a0000f	 mov         r0, #0xF

; 973  :     }
; 974  : 
; 975  :     return ReturnValue;
; 976  : 
; 977  : } //end XllpPCCardGetExpMemTiming()

  00064	e12fff1e	 bx          lr
  00068		 |$M1261|

			 ENDP  ; |XllpPCCardGetExpMemTiming|

	EXPORT	|XllpPCCardHWSetup|

  00000			 AREA	 |.pdata|, PDATA
|$T1276| DCD	|$LN10@XllpPCCard@9|
	DCD	0x40003f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPCCardHWSetup| PROC

; 78   : {

  00000		 |$LN10@XllpPCCard@9|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1273|
  00008	e1a05000	 mov         r5, r0

; 79   :     volatile XLLP_BCR_T *vpstrMainBLRegs = (volatile XLLP_BCR_T *)pstrSocketHandle->pstrBcrHandle;
; 80   :     XLLP_STATUS_T ReturnValue = XLLP_STATUS_SUCCESS;
; 81   :     XLLP_UINT32_T uiCardVoltage = 0;

  0000c	e3a03000	 mov         r3, #0

; 82   : 
; 83   :     //
; 84   :     //Check the validity of the input arguments to the function
; 85   :     //
; 86   :     if((pstrSocketHandle == XLLP_NULL_PTR))
; 87   :     {
; 88   :         ReturnValue = XLLP_STATUS_PCCARD_FAILURE;   
; 89   :     }
; 90   :     
; 91   :     if(ReturnValue != XLLP_STATUS_PCCARD_FAILURE)
; 92   :     {
; 93   :         XllpPCCardConfigureGPIOs(pstrSocketHandle); 

  00010	e5954004	 ldr         r4, [r5, #4]
  00014	e58d3000	 str         r3, [sp]
  00018	eb000000	 bl          XllpPCCardConfigureGPIOs

; 94   : 
; 95   :         //
; 96   :         //*************************** SOCKET 0 **********************************
; 97   :         //
; 98   :         vpstrMainBLRegs->PCMCIAS0SCR &= ~(XLLP_BCR_PCMCIA_SCR_S0_PWR);

  0001c	e59430e0	 ldr         r3, [r4, #0xE0]

; 99   : 
; 100  :         //
; 101  :         //Deassert RESET for Socket 0: bit[4] of the Socket 0 Status Control Register
; 102  :         //
; 103  :         vpstrMainBLRegs->PCMCIAS0SCR &= ~(XLLP_BCR_PCMCIA_SCR_S0_RESET);
; 104  : 
; 105  :         //
; 106  :         //If a card is inserted, configure the MAX1602EE power IC for
; 107  :         //appropriate power supply to the socket, based on the voltage requirements
; 108  :         //of the card. If no card is present in the socket, then bypass powering
; 109  :         //up the socket at this point
; 110  :         //
; 111  :         ReturnValue = XllpPCCardGetVoltageSetting(pstrSocketHandle, XLLP_PCCARD_SOCKET0, &uiCardVoltage);

  00020	e28d2000	 add         r2, sp, #0
  00024	e3a01000	 mov         r1, #0
  00028	e3c3300f	 bic         r3, r3, #0xF
  0002c	e58430e0	 str         r3, [r4, #0xE0]
  00030	e59430e0	 ldr         r3, [r4, #0xE0]
  00034	e1a00005	 mov         r0, r5
  00038	e3c33010	 bic         r3, r3, #0x10
  0003c	e58430e0	 str         r3, [r4, #0xE0]
  00040	eb000000	 bl          XllpPCCardGetVoltageSetting
  00044	e3500000	 cmp         r0, #0

; 112  : 
; 113  :         if(ReturnValue == XLLP_STATUS_SUCCESS)

  00048	1a000009	 bne         |$LN2@XllpPCCard@9|

; 114  :         {
; 115  :             XllpPCCardPowerOn(pstrSocketHandle, XLLP_PCCARD_SOCKET0, uiCardVoltage);

  0004c	e59d2000	 ldr         r2, [sp]
  00050	e3a01000	 mov         r1, #0
  00054	e1a00005	 mov         r0, r5
  00058	eb000000	 bl          XllpPCCardPowerOn

; 116  : 
; 117  :             //
; 118  :             //Assert RESET for Socket 0: bit[4] of the Socket 0 Status Control Register
; 119  :             //
; 120  :             vpstrMainBLRegs->PCMCIAS0SCR |= XLLP_BCR_PCMCIA_SCR_S0_RESET;

  0005c	e59430e0	 ldr         r3, [r4, #0xE0]
  00060	e3833010	 orr         r3, r3, #0x10
  00064	e58430e0	 str         r3, [r4, #0xE0]

; 121  : 
; 122  :             //
; 123  :             //Deassert RESET for Socket 0: bit[4] of the Socket 0 Status Control Register
; 124  :             //
; 125  :             vpstrMainBLRegs->PCMCIAS0SCR &= ~(XLLP_BCR_PCMCIA_SCR_S0_RESET);

  00068	e59430e0	 ldr         r3, [r4, #0xE0]
  0006c	e3c33010	 bic         r3, r3, #0x10
  00070	e58430e0	 str         r3, [r4, #0xE0]
  00074		 |$LN2@XllpPCCard@9|

; 126  :         }
; 127  : 
; 128  :         //
; 129  :         //*************************** SOCKET 1 **********************************
; 130  :         //
; 131  :         vpstrMainBLRegs->PCMCIAS1SCR &= ~(XLLP_BCR_PCMCIA_SCR_S1_PWR);

  00074	e59430e4	 ldr         r3, [r4, #0xE4]

; 132  : 
; 133  :         //
; 134  :         //Deassert RESET for Socket 1: bit[4] of the Socket 1 Status Control Register
; 135  :         //
; 136  :         vpstrMainBLRegs->PCMCIAS1SCR &= ~(XLLP_BCR_PCMCIA_SCR_S1_RESET);
; 137  : 
; 138  :         //
; 139  :         //If a card is inserted, configure the MAX1602EE power IC for
; 140  :         //appropriate power supply to the socket, based on the voltage requirements
; 141  :         //of the card. If no card is present in the socket, then bypass powering
; 142  :         //up the socket at this point
; 143  :         //
; 144  :         uiCardVoltage = 0;   //reset the value

  00078	e3a0e000	 mov         lr, #0

; 145  :         ReturnValue = XLLP_STATUS_SUCCESS;   //reset the value
; 146  : 
; 147  :         ReturnValue = XllpPCCardGetVoltageSetting(pstrSocketHandle, XLLP_PCCARD_SOCKET1, &uiCardVoltage);

  0007c	e28d2000	 add         r2, sp, #0
  00080	e3c3300f	 bic         r3, r3, #0xF
  00084	e58430e4	 str         r3, [r4, #0xE4]
  00088	e59430e4	 ldr         r3, [r4, #0xE4]
  0008c	e3a01001	 mov         r1, #1
  00090	e1a00005	 mov         r0, r5
  00094	e3c33010	 bic         r3, r3, #0x10
  00098	e58430e4	 str         r3, [r4, #0xE4]
  0009c	e58de000	 str         lr, [sp]
  000a0	eb000000	 bl          XllpPCCardGetVoltageSetting
  000a4	e1b06000	 movs        r6, r0

; 148  : 
; 149  :         if(ReturnValue == XLLP_STATUS_SUCCESS)

  000a8	1a000009	 bne         |$LN1@XllpPCCard@9|

; 150  :         {
; 151  :             XllpPCCardPowerOn(pstrSocketHandle, XLLP_PCCARD_SOCKET1, uiCardVoltage);

  000ac	e59d2000	 ldr         r2, [sp]
  000b0	e3a01001	 mov         r1, #1
  000b4	e1a00005	 mov         r0, r5
  000b8	eb000000	 bl          XllpPCCardPowerOn

; 152  : 
; 153  :             //
; 154  :             //Assert RESET for Socket 1: bit[4] of the Socket 1 Status Control Register
; 155  :             //
; 156  :             vpstrMainBLRegs->PCMCIAS1SCR |= XLLP_BCR_PCMCIA_SCR_S0_RESET;

  000bc	e59430e4	 ldr         r3, [r4, #0xE4]
  000c0	e3833010	 orr         r3, r3, #0x10
  000c4	e58430e4	 str         r3, [r4, #0xE4]

; 157  : 
; 158  :             //
; 159  :             //Deassert RESET for Socket 1: bit[4] of the Socket 1 Status Control Register
; 160  :             //
; 161  :             vpstrMainBLRegs->PCMCIAS1SCR &= ~(XLLP_BCR_PCMCIA_SCR_S0_RESET);

  000c8	e59430e4	 ldr         r3, [r4, #0xE4]
  000cc	e3c33010	 bic         r3, r3, #0x10
  000d0	e58430e4	 str         r3, [r4, #0xE4]
  000d4		 |$LN1@XllpPCCard@9|

; 162  :         }
; 163  : 
; 164  :         //
; 165  :         //Route signals to the PC card interface, as opposed to the Baseband controller
; 166  :         //
; 167  :         vpstrMainBLRegs->MISCWR1 |= (XLLP_BCR_MISCWR1_BB_SEL);

  000d4	e5943080	 ldr         r3, [r4, #0x80]

; 168  :         vpstrMainBLRegs->MISCWR1 &= ~(XLLP_BCR_MISCWR1_BB_SEL);
; 169  :     }
; 170  : 
; 171  :     return ReturnValue;
; 172  : 
; 173  : } //end XllpPCCardHWSetup()

  000d8	e1a00006	 mov         r0, r6
  000dc	e3833c02	 orr         r3, r3, #2, 24
  000e0	e5843080	 str         r3, [r4, #0x80]
  000e4	e5943080	 ldr         r3, [r4, #0x80]
  000e8	e3c33c02	 bic         r3, r3, #2, 24
  000ec	e5843080	 str         r3, [r4, #0x80]
  000f0	e28dd004	 add         sp, sp, #4
  000f4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000f8	e12fff1e	 bx          lr
  000fc		 |$M1274|

			 ENDP  ; |XllpPCCardHWSetup|

	END
