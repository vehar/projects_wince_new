; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_lcd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|LS022Q8DD06_DATA_SET_1| [ DATA ]
	EXPORT	|LS022Q8DD06_DATA_SET_2| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|LS022Q8DD06_DATA_SET_1| DCW 0xf
	DCW	0x101
	DCW	0x4
	DCW	0x101
	DCW	0x0
	DCW	0x103
	DCW	0x1
	DCW	0x10a
	DCW	0x2
	DCW	0x102
	DCW	0x9
	DCW	0x100
	DCW	0xa
	DCW	0x103
	DCW	0x19
	DCW	0x11a
	DCW	0x1a
	DCW	0x115
	DCW	0x1b
	DCW	0x148
	DCW	0x1c
	DCW	0x100
	DCW	0x21
	DCW	0x110
	DCW	0x18
	DCW	0x109
	DCW	0x3
	DCW	0x100
	DCW	0x5
	DCW	0x100
	DCW	0x6
	DCW	0x124
	DCW	0x8
	DCW	0x10e
	DCW	0xb
	DCW	0x105
	DCW	0xc
	DCW	0x100
	DCW	0x24
	DCW	0x102
	DCW	0x25
	DCW	0x10e
	DCW	0x26
	DCW	0x112
	DCW	0x27
	DCW	0x11e
	DCW	0x28
	DCW	0x122
	DCW	0x29
	DCW	0x12e
	DCW	0x2a
	DCW	0x137
	DCW	0x2b
	DCW	0x13a
	DCW	0x2c
	DCW	0x137
	DCW	0x2d
	DCW	0x13a
	DCW	0x2e
	DCW	0x137
	DCW	0x2f
	DCW	0x13a
	DCW	0x30
	DCW	0x180
	DCW	0x31
	DCW	0x101
	DCW	0x32
	DCW	0x136
	DCW	0x33
	DCW	0x101
|LS022Q8DD06_DATA_SET_2| DCW 0x18
	DCW	0x179
	DCW	0x1b
	DCW	0x149
	DCW	0x18
	DCW	0x17f
	DCW	0x36
	DCW	0x101
	DCW	0x6
	DCW	0x125
	DCW	0x4
	DCW	0x100
	DCW	0xc
	DCW	0x152
	DCW	0x21
	DCW	0x100
	DCW	0x6
	DCW	0x135
	EXPORT	|XllpLCDLoadPalette|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_lcd.c

  00000			 AREA	 |.pdata|, PDATA
|$T1296| DCD	|$LN9@XllpLCDLoa|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCDLoadPalette| PROC

; 96   : {   

  00000		 |$LN9@XllpLCDLoa|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1293|

; 97   :     volatile LCDRegs *p_LCDRegs;
; 98   : 
; 99   :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC;
; 100  : 
; 101  :     // Reconfigure the second frame descriptor so that when loaded,
; 102  :     // this descriptor loops to itself.
; 103  :     pXllpLCD->frameDescriptorCh0fd2->FDADR = LCD_FDADR(pXllpLCD->frameDescriptorCh0fd2->PHYSADDR);

  00004	e590206c	 ldr         r2, [r0, #0x6C]
  00008	e5901008	 ldr         r1, [r0, #8]

; 104  : 
; 105  :     // Reconfigure the palette frame descriptor so that it loads the second frame descriptor
; 106  :     pXllpLCD->frameDescriptorPalette->FDADR = LCD_FDADR(pXllpLCD->frameDescriptorCh0fd2->FDADR);
; 107  :     pXllpLCD->frameDescriptorPalette->FSADR = LCD_FSADR(pXllpLCD->_PALETTE_BUFFER_BASE_PHYSICAL); 
; 108  :     pXllpLCD->frameDescriptorPalette->FIDR  = LCD_FIDR(0);

  0000c	e3a0e000	 mov         lr, #0
  00010	e5923010	 ldr         r3, [r2, #0x10]
  00014	e3c3300f	 bic         r3, r3, #0xF
  00018	e5823000	 str         r3, [r2]
  0001c	e590306c	 ldr         r3, [r0, #0x6C]
  00020	e5902074	 ldr         r2, [r0, #0x74]

; 109  : 
; 110  : 
; 111  :     if ( (p_LCDRegs->OVL1C1 & LCD_O1EN) || (p_LCDRegs->OVL2C1 & LCD_O2EN)) 

  00024	e5933000	 ldr         r3, [r3]
  00028	e3c3300f	 bic         r3, r3, #0xF
  0002c	e5823000	 str         r3, [r2]
  00030	e5903038	 ldr         r3, [r0, #0x38]
  00034	e5902074	 ldr         r2, [r0, #0x74]
  00038	e3c33007	 bic         r3, r3, #7
  0003c	e5823004	 str         r3, [r2, #4]
  00040	e5903074	 ldr         r3, [r0, #0x74]
  00044	e583e008	 str         lr, [r3, #8]
  00048	e5913050	 ldr         r3, [r1, #0x50]

; 112  :     {
; 113  :         // Overlays are enabled
; 114  :         pXllpLCD->frameDescriptorPalette->LDCMD = LCD_Len(pXllpLCD->PaletteSize << 1) | LCD_Pal;

  0004c	e5902074	 ldr         r2, [r0, #0x74]
  00050	e3130102	 tst         r3, #2, 2
  00054	05913070	 ldreq       r3, [r1, #0x70]
  00058	03130102	 tsteq       r3, #2, 2

; 115  :     } else
; 116  :     {
; 117  :         // Overlays are disabled
; 118  :         pXllpLCD->frameDescriptorPalette->LDCMD = LCD_Len(pXllpLCD->PaletteSize) | LCD_Pal;

  0005c	05903024	 ldreq       r3, [r0, #0x24]
  00060	03833301	 orreq       r3, r3, #1, 6
  00064	15903024	 ldrne       r3, [r0, #0x24]
  00068	13833402	 orrne       r3, r3, #2, 8
  0006c	11a03083	 movne       r3, r3, lsl #1
  00070	e582300c	 str         r3, [r2, #0xC]

; 119  :     }
; 120  : 
; 121  :     pXllpLCD->frameDescriptorPalette->PHYSADDR = LCD_FDADR(pXllpLCD->_PALETTE_FRAME_DESCRIPTOR_BASE_PHYSICAL);

  00074	e5903058	 ldr         r3, [r0, #0x58]
  00078	e5902074	 ldr         r2, [r0, #0x74]
  0007c	e3c3300f	 bic         r3, r3, #0xF
  00080	e5823010	 str         r3, [r2, #0x10]

; 122  : 
; 123  :     // Insert the palette descriptor into the descriptor chain to load the palette.
; 124  :     // When this load completes, fd2 is automatically loaded next in the chain.  
; 125  :     // fd2 now loops to itself and continues to load frame data.
; 126  :     pXllpLCD->frameDescriptorCh0fd1->FDADR = LCD_FDADR(pXllpLCD->_PALETTE_FRAME_DESCRIPTOR_BASE_PHYSICAL);      

  00084	e5903058	 ldr         r3, [r0, #0x58]
  00088	e5902068	 ldr         r2, [r0, #0x68]
  0008c	e3c3300f	 bic         r3, r3, #0xF
  00090	e5823000	 str         r3, [r2]

; 127  : 
; 128  :     // swap frame descriptor pointers so that this operation is reversed the next time through
; 129  :     pXllpLCD->frameDescriptorTemp   = pXllpLCD->frameDescriptorCh0fd1;

  00094	e5903068	 ldr         r3, [r0, #0x68]

; 130  :     pXllpLCD->frameDescriptorCh0fd1 = pXllpLCD->frameDescriptorCh0fd2;

  00098	e590206c	 ldr         r2, [r0, #0x6C]
  0009c	e5803078	 str         r3, [r0, #0x78]

; 131  :     pXllpLCD->frameDescriptorCh0fd2 = pXllpLCD->frameDescriptorTemp;

  000a0	e5802068	 str         r2, [r0, #0x68]
  000a4	e580306c	 str         r3, [r0, #0x6C]

; 132  : }

  000a8	e49de004	 ldr         lr, [sp], #4
  000ac	e12fff1e	 bx          lr
  000b0		 |$M1294|

			 ENDP  ; |XllpLCDLoadPalette|

	EXPORT	|XllpLCDSuspend|

  00000			 AREA	 |.pdata|, PDATA
|$T1309| DCD	|$LN15@XllpLCDSus|
	DCD	0x40001900
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCDSuspend| PROC

; 135  : {

  00000		 |$LN15@XllpLCDSus|
  00000		 |$M1306|
  00000	e3510000	 cmp         r1, #0

; 136  :     volatile LCDRegs *p_LCDRegs;
; 137  :     volatile XLLP_GPIO_T *p_GPIORegs;
; 138  : 
; 139  :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC;

  00004	e5902008	 ldr         r2, [r0, #8]

; 140  :     p_GPIORegs = (XLLP_GPIO_T *) pXllpLCD->GPIO;

  00008	e5900000	 ldr         r0, [r0]

; 141  : 
; 142  :     switch(SuspendType)

  0000c	0a000004	 beq         |$LN6@XllpLCDSus|
  00010	e3510001	 cmp         r1, #1
  00014	1a00000e	 bne         |$LN5@XllpLCDSus|

; 156  :         }
; 157  :         break;
; 158  :     case Suspend_Immediate:
; 159  :         p_LCDRegs->LCCR0 &= ~LCD_ENB;

  00018	e5923000	 ldr         r3, [r2]
  0001c	e3c33001	 bic         r3, r3, #1

; 160  :         break;

  00020	ea00000a	 b           |$LN12@XllpLCDSus|
  00024		 |$LN6@XllpLCDSus|

; 143  :     {
; 144  :     case Suspend_Graceful:
; 145  :         // suspend if LCD is enabled
; 146  :         if (p_LCDRegs->LCCR0 & LCD_ENB)

  00024	e5923000	 ldr         r3, [r2]
  00028	e3130001	 tst         r3, #1
  0002c	0a000008	 beq         |$LN5@XllpLCDSus|

; 147  :         {
; 148  :             // Initiate power down sequence
; 149  :             p_LCDRegs->LCCR0 |= LCD_DIS;

  00030	e5923000	 ldr         r3, [r2]
  00034	e3833b01	 orr         r3, r3, #1, 22
  00038	e4823038	 str         r3, [r2], #0x38
  0003c		 |$LL4@XllpLCDSus|

; 150  : 
; 151  :             // Wait for LDD bit to get set once the last DMA transfer has completed
; 152  :             while(!(p_LCDRegs->LCSR0 & LCD_LDD));

  0003c	e5923000	 ldr         r3, [r2]
  00040	e3130001	 tst         r3, #1
  00044	0afffffc	 beq         |$LL4@XllpLCDSus|

; 153  : 
; 154  :             // Clear the sticky LDD bit
; 155  :             p_LCDRegs->LCSR0 |= LCD_LDD;

  00048	e5923000	 ldr         r3, [r2]
  0004c	e3833001	 orr         r3, r3, #1
  00050		 |$LN12@XllpLCDSus|
  00050	e5823000	 str         r3, [r2]
  00054		 |$LN5@XllpLCDSus|

; 161  :     default :
; 162  :         break;
; 163  :     }
; 164  : 
; 165  :     // don't use lock/unlock here because system call may be unavailable.
; 166  :     p_GPIORegs->GPCR0   |= XLLP_GPIO_BIT_PWM_OUT0;

  00054	e5903024	 ldr         r3, [r0, #0x24]
  00058	e3833801	 orr         r3, r3, #1, 16
  0005c	e5803024	 str         r3, [r0, #0x24]

; 167  : 
; 168  : }

  00060	e12fff1e	 bx          lr
  00064		 |$M1307|

			 ENDP  ; |XllpLCDSuspend|

	EXPORT	|XllpLCDSetDisplayPage|

  00000			 AREA	 |.pdata|, PDATA
|$T1318| DCD	|$LN5@XllpLCDSet|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCDSetDisplayPage| PROC

; 176  : {

  00000		 |$LN5@XllpLCDSet|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1315|

; 177  :     // Set the physical address of the frame buffer for all three frame descriptors
; 178  :     // Make sure that you've initialized FrameBufferSize before calling this function either manually
; 179  :     // or through a call to XllpLCDInit().
; 180  :     pXllpLCD->CurrentPage = page;
; 181  :     pXllpLCD->frameDescriptorCh0fd1->FSADR = LCD_FSADR(pXllpLCD->_FRAME_BUFFER_BASE_PHYSICAL + pXllpLCD->CurrentPage*pXllpLCD->FrameBufferSize);

  00004	e5902020	 ldr         r2, [r0, #0x20]
  00008	e5903034	 ldr         r3, [r0, #0x34]
  0000c	e590e068	 ldr         lr, [r0, #0x68]
  00010	e5801030	 str         r1, [r0, #0x30]
  00014	e0233192	 mla         r3, r2, r1, r3
  00018	e3c33007	 bic         r3, r3, #7
  0001c	e58e3004	 str         r3, [lr, #4]

; 182  :     pXllpLCD->frameDescriptorCh0fd2->FSADR = LCD_FSADR(pXllpLCD->_FRAME_BUFFER_BASE_PHYSICAL + pXllpLCD->CurrentPage*pXllpLCD->FrameBufferSize);

  00020	e5901030	 ldr         r1, [r0, #0x30]
  00024	e5902020	 ldr         r2, [r0, #0x20]
  00028	e5903034	 ldr         r3, [r0, #0x34]
  0002c	e590e06c	 ldr         lr, [r0, #0x6C]
  00030	e0233291	 mla         r3, r1, r2, r3
  00034	e3c33007	 bic         r3, r3, #7
  00038	e58e3004	 str         r3, [lr, #4]

; 183  :     pXllpLCD->frameDescriptorCh1->FSADR = LCD_FSADR(pXllpLCD->_FRAME_BUFFER_BASE_PHYSICAL + pXllpLCD->CurrentPage*pXllpLCD->FrameBufferSize + (pXllpLCD->FrameBufferSize >> 1));

  0003c	e590e020	 ldr         lr, [r0, #0x20]
  00040	e5902030	 ldr         r2, [r0, #0x30]
  00044	e5901034	 ldr         r1, [r0, #0x34]
  00048	e5900070	 ldr         r0, [r0, #0x70]
  0004c	e0030e92	 mul         r3, r2, lr
  00050	e08330ae	 add         r3, r3, lr, lsr #1
  00054	e0833001	 add         r3, r3, r1
  00058	e3c33007	 bic         r3, r3, #7
  0005c	e5803004	 str         r3, [r0, #4]

; 184  : }

  00060	e49de004	 ldr         lr, [sp], #4
  00064	e12fff1e	 bx          lr
  00068		 |$M1316|

			 ENDP  ; |XllpLCDSetDisplayPage|

	EXPORT	|LCDInitController|
	IMPORT	|XllpOstDelayMicroSeconds|
	IMPORT	|XllpOstDelayMilliSeconds|
	IMPORT	|XllpUnlock|
	IMPORT	|XllpLock|

  00000			 AREA	 |.pdata|, PDATA
|$T1353| DCD	|$LN78@LCDInitCon|
	DCD	0x4001dd02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LCDInitController| PROC

; 187  : {

  00000		 |$LN78@LCDInitCon|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M1350|
  00008	e1a08000	 mov         r8, r0

; 188  :     int i = 0;
; 189  :     int BPP = 0;
; 190  :     int PCD = 0;
; 191  :     unsigned int CCCR_L = 0;
; 192  :     volatile LCDRegs *p_LCDRegs;
; 193  :     volatile XLLP_CLKMGR_T *p_CLKRegs;
; 194  :     volatile XLLP_SSPREGS_T *p_SSPRegs;
; 195  :     volatile XLLP_GPIO_T *p_GPIORegs;
; 196  :     XLLP_OST_T *p_OSTRegs;
; 197  : 
; 198  :     int LCLK = 0;
; 199  : 
; 200  :     XLLP_UINT32_T LockID;
; 201  :     XLLP_UINT32_T LockID2;
; 202  : 
; 203  :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC;

  0000c	e5987008	 ldr         r7, [r8, #8]

; 204  :     p_CLKRegs = (XLLP_CLKMGR_T *) pXllpLCD->CLKMan;
; 205  :     p_GPIORegs = (XLLP_GPIO_T *) pXllpLCD->GPIO;
; 206  :     p_OSTRegs = (XLLP_OST_T *) pXllpLCD->OST;
; 207  :     p_SSPRegs = (XLLP_SSPREGS_T *) pXllpLCD->SSP;
; 208  : 
; 209  :     p_LCDRegs->LCCR0 = 0;
; 210  :     p_LCDRegs->LCCR1 = 0;

  00010	e5983010	 ldr         r3, [r8, #0x10]
  00014	e5986004	 ldr         r6, [r8, #4]
  00018	e5984000	 ldr         r4, [r8]
  0001c	e598500c	 ldr         r5, [r8, #0xC]
  00020	e3a09000	 mov         r9, #0
  00024	e1a0b007	 mov         r11, r7
  00028	e58d3000	 str         r3, [sp]

; 211  :     p_LCDRegs->LCCR2 = 0;
; 212  :     p_LCDRegs->LCCR3 = 0;
; 213  :     p_LCDRegs->LCCR4 = 0;
; 214  :     p_LCDRegs->LCCR5 = (LCD_SOFM1|LCD_SOFM2|LCD_SOFM3|LCD_SOFM4|LCD_SOFM5|LCD_SOFM6|
; 215  :                         LCD_EOFM1|LCD_EOFM2|LCD_EOFM3|LCD_EOFM4|LCD_EOFM5|LCD_EOFM6|
; 216  :                         LCD_BSM1 |LCD_BSM2 |LCD_BSM3 |LCD_BSM4 |LCD_BSM5 |LCD_BSM6 |
; 217  :                         LCD_IUM1 |LCD_IUM2 |LCD_IUM3 |LCD_IUM4 |LCD_IUM5 |LCD_IUM6 );

  0002c	e59f373c	 ldr         r3, [pc, #0x73C]
  00030	e5879000	 str         r9, [r7]
  00034	e5ab9004	 str         r9, [r11, #4]!
  00038	e5879008	 str         r9, [r7, #8]
  0003c	e587900c	 str         r9, [r7, #0xC]
  00040	e5879010	 str         r9, [r7, #0x10]
  00044	e5873014	 str         r3, [r7, #0x14]

; 218  : 
; 219  : 
; 220  :     // Determine the frame buffer size for the DMA transfer length.
; 221  :     // Scale the size based on the bpp of the frame buffer to determine
; 222  :     // an actual size in bytes
; 223  :     pXllpLCD->FrameBufferSize = pXllpLCD->FrameBufferWidth * pXllpLCD->FrameBufferHeight;

  00048	e598201c	 ldr         r2, [r8, #0x1C]
  0004c	e5983018	 ldr         r3, [r8, #0x18]

; 224  :     switch (pXllpLCD->BPP)

  00050	e5981028	 ldr         r1, [r8, #0x28]
  00054	e3a0a000	 mov         r10, #0
  00058	e0030392	 mul         r3, r2, r3
  0005c	e3510020	 cmp         r1, #0x20
  00060	e5883020	 str         r3, [r8, #0x20]
  00064	8a000019	 bhi         |$LN61@LCDInitCon|
  00068	0a000022	 beq         |$LN51@LCDInitCon|
  0006c	e3510001	 cmp         r1, #1
  00070	0a000014	 beq         |$LN56@LCDInitCon|
  00074	e3510002	 cmp         r1, #2
  00078	0a00000e	 beq         |$LN55@LCDInitCon|
  0007c	e3510004	 cmp         r1, #4
  00080	0a000008	 beq         |$LN54@LCDInitCon|
  00084	e3510008	 cmp         r1, #8
  00088	0a000003	 beq         |$LN53@LCDInitCon|
  0008c	e3510010	 cmp         r1, #0x10
  00090	1a00001a	 bne         |$LN57@LCDInitCon|

; 241  :         case BPP_16:
; 242  :             pXllpLCD->FrameBufferSize <<= 1;

  00094	e1a03083	 mov         r3, r3, lsl #1

; 243  :             break;

  00098	ea000017	 b           |$LN70@LCDInitCon|
  0009c		 |$LN53@LCDInitCon|

; 238  :         case BPP_8:
; 239  :             pXllpLCD->PaletteSize = 512;

  0009c	e3a03c02	 mov         r3, #2, 24
  000a0	e5883024	 str         r3, [r8, #0x24]

; 240  :             break;

  000a4	ea000015	 b           |$LN57@LCDInitCon|
  000a8		 |$LN54@LCDInitCon|

; 233  :             break;
; 234  :         case BPP_4:
; 235  :             pXllpLCD->FrameBufferSize >>= 1;
; 236  :             pXllpLCD->PaletteSize = 32;

  000a8	e3a02020	 mov         r2, #0x20
  000ac	e5882024	 str         r2, [r8, #0x24]
  000b0	e1a030a3	 mov         r3, r3, lsr #1

; 237  :             break;

  000b4	ea000010	 b           |$LN70@LCDInitCon|
  000b8		 |$LN55@LCDInitCon|

; 230  :         case BPP_2:
; 231  :             pXllpLCD->FrameBufferSize >>= 2;

  000b8	e1a03123	 mov         r3, r3, lsr #2
  000bc		 |$LN75@LCDInitCon|

; 232  :             pXllpLCD->PaletteSize = 8;

  000bc	e3a02008	 mov         r2, #8

; 233  :             break;
; 234  :         case BPP_4:
; 235  :             pXllpLCD->FrameBufferSize >>= 1;
; 236  :             pXllpLCD->PaletteSize = 32;

  000c0	e5882024	 str         r2, [r8, #0x24]

; 237  :             break;

  000c4	ea00000c	 b           |$LN70@LCDInitCon|
  000c8		 |$LN56@LCDInitCon|

; 225  :     {
; 226  :         case BPP_1:
; 227  :             pXllpLCD->FrameBufferSize >>= 3;

  000c8	e1a031a3	 mov         r3, r3, lsr #3

; 228  :             pXllpLCD->PaletteSize = 8;
; 229  :             break;

  000cc	eafffffa	 b           |$LN75@LCDInitCon|
  000d0		 |$LN61@LCDInitCon|

; 224  :     switch (pXllpLCD->BPP)

  000d0	e3510040	 cmp         r1, #0x40
  000d4	0a000007	 beq         |$LN51@LCDInitCon|
  000d8	e3510080	 cmp         r1, #0x80
  000dc	0a000005	 beq         |$LN51@LCDInitCon|
  000e0	e3510c01	 cmp         r1, #1, 24
  000e4	0a000003	 beq         |$LN51@LCDInitCon|
  000e8	e3510c02	 cmp         r1, #2, 24
  000ec	0a000001	 beq         |$LN51@LCDInitCon|
  000f0	e3510b01	 cmp         r1, #1, 22

; 251  :             break;
; 252  :         default:
; 253  :             break;

  000f4	1a000001	 bne         |$LN57@LCDInitCon|
  000f8		 |$LN51@LCDInitCon|

; 244  :         case BPP_18:        /* Fall through */
; 245  :         case BPP_18_PACKED:
; 246  :         case BPP_19:
; 247  :         case BPP_19_PACKED:
; 248  :         case BPP_24:
; 249  :         case BPP_25:
; 250  :             pXllpLCD->FrameBufferSize <<= 2;

  000f8	e1a03103	 mov         r3, r3, lsl #2
  000fc		 |$LN70@LCDInitCon|
  000fc	e5883020	 str         r3, [r8, #0x20]
  00100		 |$LN57@LCDInitCon|

; 254  :     }
; 255  : 
; 256  :     // Enable the LCD and SRAM clocks
; 257  :     LockID = XllpLock(CKEN);

  00100	e3a00026	 mov         r0, #0x26
  00104	eb000000	 bl          XllpLock

; 258  : 
; 259  :     p_CLKRegs->cken = (p_CLKRegs->cken & XLLP_CLKEN_MASK) | CLK_LCD | CLK_SRAM;

  00108	e5962004	 ldr         r2, [r6, #4]
  0010c	e3e0333f	 mvn         r3, #0x3F, 6
  00110	e2233811	 eor         r3, r3, #0x11, 16
  00114	e0023003	 and         r3, r2, r3
  00118	e3833811	 orr         r3, r3, #0x11, 16
  0011c	e5863004	 str         r3, [r6, #4]

; 260  : 
; 261  :     XllpUnlock(LockID);

  00120	eb000000	 bl          XllpUnlock

; 262  : 
; 263  :     // Configure the general purpose frame descriptors
; 264  :     // Set the physical address of the frame descriptor
; 265  :     pXllpLCD->frameDescriptorCh0fd1->FDADR = LCD_FDADR(pXllpLCD->_DMA_CHANNEL_0_FRAME_DESCRIPTOR_BASE_PHYSICAL);

  00124	e598304c	 ldr         r3, [r8, #0x4C]
  00128	e5982068	 ldr         r2, [r8, #0x68]
  0012c	e3c3300f	 bic         r3, r3, #0xF
  00130	e5823000	 str         r3, [r2]

; 266  : 
; 267  :     // Set the physical address of the frame buffer
; 268  :     pXllpLCD->frameDescriptorCh0fd1->FSADR = LCD_FSADR(pXllpLCD->_FRAME_BUFFER_BASE_PHYSICAL + pXllpLCD->CurrentPage*pXllpLCD->FrameBufferSize);

  00134	e5981030	 ldr         r1, [r8, #0x30]
  00138	e5982020	 ldr         r2, [r8, #0x20]
  0013c	e5983034	 ldr         r3, [r8, #0x34]
  00140	e5980068	 ldr         r0, [r8, #0x68]
  00144	e0233291	 mla         r3, r1, r2, r3
  00148	e3c33007	 bic         r3, r3, #7

; 269  : 
; 270  :     // Clear the frame ID
; 271  :     pXllpLCD->frameDescriptorCh0fd1->FIDR  = LCD_FIDR(0);
; 272  : 
; 273  :     // Set the DMA transfer length to the size of the frame buffer
; 274  :     pXllpLCD->frameDescriptorCh0fd1->LDCMD = LCD_Len(pXllpLCD->FrameBufferSize);
; 275  : 
; 276  :     // Store the physical address of this frame descriptor in the frame descriptor
; 277  :     pXllpLCD->frameDescriptorCh0fd1->PHYSADDR = pXllpLCD->frameDescriptorCh0fd1->FDADR;
; 278  : 
; 279  :     // frameDescriptorCh0fd2 is used only if a palette load is performed.
; 280  :     // Set the physical address of the frame descriptor
; 281  :     pXllpLCD->frameDescriptorCh0fd2->FDADR = LCD_FDADR(pXllpLCD->_DMA_CHANNEL_0_ALT_FRAME_DESCRIPTOR_BASE_PHYSICAL);
; 282  : 
; 283  :     // Set the physical address of the frame buffer
; 284  :     pXllpLCD->frameDescriptorCh0fd2->FSADR = LCD_FSADR(pXllpLCD->_FRAME_BUFFER_BASE_PHYSICAL + pXllpLCD->CurrentPage*pXllpLCD->FrameBufferSize);
; 285  : 
; 286  :     // Clear the frame ID
; 287  :     pXllpLCD->frameDescriptorCh0fd2->FIDR  = LCD_FIDR(0);
; 288  : 
; 289  :     // Set the DMA transfer length to the size of the frame buffer
; 290  :     pXllpLCD->frameDescriptorCh0fd2->LDCMD = LCD_Len(pXllpLCD->FrameBufferSize);
; 291  :     
; 292  :     // Store the physical address of this frame descriptor in the frame descriptor
; 293  :     pXllpLCD->frameDescriptorCh0fd2->PHYSADDR = pXllpLCD->frameDescriptorCh0fd2->FDADR;
; 294  :     
; 295  :     // FBR0 is cleared and is not used.
; 296  :     p_LCDRegs->FBR0 = 0;

  0014c	e5803004	 str         r3, [r0, #4]
  00150	e5983068	 ldr         r3, [r8, #0x68]

; 297  : 
; 298  :     // Load the contents of FDADR0 with the physical address of this frame descriptor
; 299  :     p_LCDRegs->FDADR0 = LCD_FDADR(pXllpLCD->frameDescriptorCh0fd1->FDADR);

  00154	e5839008	 str         r9, [r3, #8]
  00158	e5982068	 ldr         r2, [r8, #0x68]
  0015c	e5983020	 ldr         r3, [r8, #0x20]
  00160	e582300c	 str         r3, [r2, #0xC]
  00164	e5982068	 ldr         r2, [r8, #0x68]
  00168	e5923000	 ldr         r3, [r2]
  0016c	e5823010	 str         r3, [r2, #0x10]
  00170	e5983054	 ldr         r3, [r8, #0x54]
  00174	e598206c	 ldr         r2, [r8, #0x6C]
  00178	e3c3300f	 bic         r3, r3, #0xF
  0017c	e5823000	 str         r3, [r2]
  00180	e5981030	 ldr         r1, [r8, #0x30]
  00184	e5982020	 ldr         r2, [r8, #0x20]
  00188	e5983034	 ldr         r3, [r8, #0x34]
  0018c	e598006c	 ldr         r0, [r8, #0x6C]
  00190	e0233291	 mla         r3, r1, r2, r3
  00194	e3c33007	 bic         r3, r3, #7
  00198	e5803004	 str         r3, [r0, #4]
  0019c	e598306c	 ldr         r3, [r8, #0x6C]
  001a0	e5839008	 str         r9, [r3, #8]
  001a4	e598206c	 ldr         r2, [r8, #0x6C]
  001a8	e5983020	 ldr         r3, [r8, #0x20]
  001ac	e582300c	 str         r3, [r2, #0xC]
  001b0	e598206c	 ldr         r2, [r8, #0x6C]
  001b4	e5923000	 ldr         r3, [r2]
  001b8	e5823010	 str         r3, [r2, #0x10]
  001bc	e5879020	 str         r9, [r7, #0x20]
  001c0	e5983068	 ldr         r3, [r8, #0x68]
  001c4	e5933000	 ldr         r3, [r3]
  001c8	e3c3300f	 bic         r3, r3, #0xF
  001cc	e5873200	 str         r3, [r7, #0x200]

; 300  :             
; 301  :     // Determine the LCLK frequency programmed into the CCCR.
; 302  :     // This value will be used to calculate a Pixel Clock Divisor (PCD)
; 303  :     // for a given display type.
; 304  :     CCCR_L = (p_CLKRegs->cccr & 0x0000001F);

  001d0	e5963000	 ldr         r3, [r6]
  001d4	e203201f	 and         r2, r3, #0x1F

; 305  : 
; 306  : 
; 307  :     if (CCCR_L < 8) // L = [2 - 7]

  001d8	e3520008	 cmp         r2, #8
  001dc	33a03c05	 movcc       r3, #5, 24

; 308  :         LCLK = (13 * CCCR_L) * 100;

  001e0	33833014	 orrcc       r3, r3, #0x14
  001e4	300a0392	 mulcc       r10, r2, r3
  001e8	3a00000a	 bcc         |$LN45@LCDInitCon|

; 309  :     else if (CCCR_L < 17) // L = [8 - 16] 

  001ec	e3520011	 cmp         r2, #0x11
  001f0	33a03c05	 movcc       r3, #5, 24

; 310  :         LCLK = ((13 * CCCR_L) * 100) >> 1;

  001f4	33833014	 orrcc       r3, r3, #0x14
  001f8	30030392	 mulcc       r3, r2, r3
  001fc	31a0a0a3	 movcc       r10, r3, lsr #1
  00200	3a000004	 bcc         |$LN45@LCDInitCon|

; 311  :     else if (CCCR_L < 32) // L = [17 - 31]

  00204	e3520020	 cmp         r2, #0x20
  00208	33a03c05	 movcc       r3, #5, 24

; 312  :         LCLK = ((13 * CCCR_L) * 100) >> 2;

  0020c	33833014	 orrcc       r3, r3, #0x14
  00210	30030392	 mulcc       r3, r2, r3
  00214	31a0a123	 movcc       r10, r3, lsr #2
  00218		 |$LN45@LCDInitCon|

; 313  :         
; 314  :     
; 315  :     // Convert the bpp setting into a value that the LCD controller understands.
; 316  :     switch(pXllpLCD->BPP)

  00218	e5983028	 ldr         r3, [r8, #0x28]
  0021c	e3530020	 cmp         r3, #0x20
  00220	8a000016	 bhi         |$LN62@LCDInitCon|
  00224	0a000013	 beq         |$LN37@LCDInitCon|
  00228	e3530001	 cmp         r3, #1
  0022c	0a00000f	 beq         |$LN42@LCDInitCon|
  00230	e3530002	 cmp         r3, #2
  00234	0a00000b	 beq         |$LN41@LCDInitCon|
  00238	e3530004	 cmp         r3, #4
  0023c	0a000007	 beq         |$LN40@LCDInitCon|
  00240	e3530008	 cmp         r3, #8
  00244	0a000003	 beq         |$LN39@LCDInitCon|
  00248	e3530010	 cmp         r3, #0x10
  0024c	1a000007	 bne         |$LN42@LCDInitCon|

; 330  :         case BPP_16:
; 331  :             BPP = 4;

  00250	e3a09004	 mov         r9, #4

; 332  :             break;

  00254	ea00001c	 b           |$LN43@LCDInitCon|
  00258		 |$LN39@LCDInitCon|

; 327  :         case BPP_8:
; 328  :             BPP = 3;

  00258	e3a09003	 mov         r9, #3

; 329  :             break;

  0025c	ea00001a	 b           |$LN43@LCDInitCon|
  00260		 |$LN40@LCDInitCon|

; 324  :         case BPP_4:
; 325  :             BPP = 2;

  00260	e3a09002	 mov         r9, #2

; 326  :             break;

  00264	ea000018	 b           |$LN43@LCDInitCon|
  00268		 |$LN41@LCDInitCon|

; 321  :         case BPP_2:
; 322  :             BPP = 1;

  00268	e3a09001	 mov         r9, #1

; 323  :             break;

  0026c	ea000016	 b           |$LN43@LCDInitCon|
  00270		 |$LN42@LCDInitCon|

; 317  :     {
; 318  :         case BPP_1:
; 319  :             BPP = 0;

  00270	e3a09000	 mov         r9, #0

; 320  :             break;

  00274	ea000014	 b           |$LN43@LCDInitCon|
  00278		 |$LN37@LCDInitCon|

; 333  :         case BPP_18:
; 334  :             BPP = 5;

  00278	e3a09005	 mov         r9, #5

; 335  :             break;

  0027c	ea000012	 b           |$LN43@LCDInitCon|
  00280		 |$LN62@LCDInitCon|

; 313  :         
; 314  :     
; 315  :     // Convert the bpp setting into a value that the LCD controller understands.
; 316  :     switch(pXllpLCD->BPP)

  00280	e3530040	 cmp         r3, #0x40
  00284	0a00000f	 beq         |$LN36@LCDInitCon|
  00288	e3530080	 cmp         r3, #0x80
  0028c	0a00000b	 beq         |$LN35@LCDInitCon|
  00290	e3530c01	 cmp         r3, #1, 24
  00294	0a000007	 beq         |$LN34@LCDInitCon|
  00298	e3530c02	 cmp         r3, #2, 24
  0029c	0a000003	 beq         |$LN33@LCDInitCon|
  002a0	e3530b01	 cmp         r3, #1, 22

; 351  :         default:
; 352  :         {
; 353  :             BPP = 0;
; 354  :             break;

  002a4	1afffff1	 bne         |$LN42@LCDInitCon|

; 348  :         case BPP_25:
; 349  :             BPP = 10;

  002a8	e3a0900a	 mov         r9, #0xA

; 350  :             break;

  002ac	ea000006	 b           |$LN43@LCDInitCon|
  002b0		 |$LN33@LCDInitCon|

; 345  :         case BPP_24:
; 346  :             BPP = 9;

  002b0	e3a09009	 mov         r9, #9

; 347  :             break;

  002b4	ea000004	 b           |$LN43@LCDInitCon|
  002b8		 |$LN34@LCDInitCon|

; 342  :         case BPP_19_PACKED:
; 343  :             BPP = 8;

  002b8	e3a09008	 mov         r9, #8

; 344  :             break;

  002bc	ea000002	 b           |$LN43@LCDInitCon|
  002c0		 |$LN35@LCDInitCon|

; 338  :             break;
; 339  :         case BPP_19:
; 340  :             BPP = 7;

  002c0	e3a09007	 mov         r9, #7

; 341  :             break;

  002c4	ea000000	 b           |$LN43@LCDInitCon|
  002c8		 |$LN36@LCDInitCon|

; 336  :         case BPP_18_PACKED:
; 337  :             BPP = 6;

  002c8	e3a09006	 mov         r9, #6
  002cc		 |$LN43@LCDInitCon|

; 355  :         }
; 356  :     }
; 357  : 
; 358  :     switch(pXllpLCD->DisplayType)

  002cc	e5983014	 ldr         r3, [r8, #0x14]
  002d0	e3530001	 cmp         r3, #1
  002d4	0a0000f5	 beq         |$LN28@LCDInitCon|
  002d8	e3530002	 cmp         r3, #2
  002dc	0a0000e0	 beq         |$LN19@LCDInitCon|
  002e0	e3530004	 cmp         r3, #4
  002e4	0a0000a1	 beq         |$LN22@LCDInitCon|
  002e8	e3530005	 cmp         r3, #5
  002ec	0a00008c	 beq         |$LN25@LCDInitCon|
  002f0	e3530006	 cmp         r3, #6
  002f4	1a00010a	 bne         |$LN27@LCDInitCon|

; 525  : 
; 526  :     case LS022Q8DD06: // Sharp LS022Q8DD06 Sharp 240 x 320 for ZOAR
; 527  :         {
; 528  :             // 
; 529  :             // The actual equation requires that we take the ceiling of a floating point result.
; 530  :             // Rather than use floats, we'll calculate an approximation to the correct PCD value
; 531  :             // using integers.
; 532  :             //
; 533  : 
; 534  :             PCD = (LCLK / (2 * LS022Q8DD06_PIXEL_CLOCK_FREQUENCY));

  002f8	e59f346c	 ldr         r3, [pc, #0x46C]

; 535  : 
; 536  :             // Configure the LCD Controller Control Registers
; 537  :             p_LCDRegs->LCCR0 = (LCD_LDM | LCD_SFM | LCD_IUM | LCD_EFM | 
; 538  :                         LCD_PAS | LCD_QDM | LCD_BM  | LCD_OUM |
; 539  :                         LCD_RDSTM | LCD_CMDIM | LCD_OUC | LCD_LDDALT);

  002fc	e59f2430	 ldr         r2, [pc, #0x430]

; 540  : 
; 541  :             p_LCDRegs->LCCR1 = (LCD_PPL(0xEF) | LCD_HSW(0x01) | 
; 542  :                         LCD_ELW(0x00)  | LCD_BLW(0x07) );

  00300	e59f1460	 ldr         r1, [pc, #0x460]
  00304	e0c0e39a	 smull       lr, r0, r10, r3

; 543  :             
; 544  :             p_LCDRegs->LCCR2 = (LCD_LPP(0x13f) | LCD_VSW(0x02) |
; 545  :                         LCD_EFW(0x02)  | LCD_BFW(0x00) );

  00308	e59f3454	 ldr         r3, [pc, #0x454]
  0030c	e5872000	 str         r2, [r7]
  00310	e58b1000	 str         r1, [r11]
  00314	e5873008	 str         r3, [r7, #8]
  00318	e080300a	 add         r3, r0, r10

; 546  : 
; 547  :             p_LCDRegs->LCCR3 = (LCD_PCD(PCD)  | LCD_BPP(BPP) | LCD_PCP | 
; 548  :                         LCD_PDFOR(pXllpLCD->PixelDataFormat));

  0031c	e598002c	 ldr         r0, [r8, #0x2C]
  00320	e1a03543	 mov         r3, r3, asr #10
  00324	e2092008	 and         r2, r9, #8
  00328	e0831fa3	 add         r1, r3, r3, lsr #31
  0032c	e1820200	 orr         r0, r2, r0, lsl #4
  00330	e2093007	 and         r3, r9, #7
  00334	e1833100	 orr         r3, r3, r0, lsl #2
  00338	e3812501	 orr         r2, r1, #1, 10
  0033c	e1823c03	 orr         r3, r2, r3, lsl #24
  00340	e587300c	 str         r3, [r7, #0xC]

; 549  :             
; 550  :             p_LCDRegs->LCCR4 = LCD_PAL_FOR(0);

  00344	e3a03000	 mov         r3, #0
  00348	e5873010	 str         r3, [r7, #0x10]

; 551  :             if ( (p_LCDRegs->OVL1C1 & LCD_O1EN) || (p_LCDRegs->OVL2C1 & LCD_O2EN))

  0034c	e5973050	 ldr         r3, [r7, #0x50]
  00350	e3a08902	 mov         r8, #2, 18
  00354	e3130102	 tst         r3, #2, 2
  00358	1a000002	 bne         |$LN14@LCDInitCon|
  0035c	e5973070	 ldr         r3, [r7, #0x70]
  00360	e3130102	 tst         r3, #2, 2
  00364	0a000000	 beq         |$LN15@LCDInitCon|
  00368		 |$LN14@LCDInitCon|

; 552  :             {
; 553  :                 p_LCDRegs->LCCR4 = LCD_PAL_FOR(1);

  00368	e5878010	 str         r8, [r7, #0x10]
  0036c		 |$LN15@LCDInitCon|

; 554  :             }
; 555  : 
; 556  :             LockID = XllpLock(CKEN);

  0036c	e3a00026	 mov         r0, #0x26
  00370	eb000000	 bl          XllpLock

; 557  :             p_CLKRegs->cken = (p_CLKRegs->cken & XLLP_CLKEN_MASK) | CLK_SSP3;

  00374	e5962004	 ldr         r2, [r6, #4]
  00378	e3e0333f	 mvn         r3, #0x3F, 6
  0037c	e2233010	 eor         r3, r3, #0x10
  00380	e0023003	 and         r3, r2, r3
  00384	e3833010	 orr         r3, r3, #0x10
  00388	e5863004	 str         r3, [r6, #4]

; 558  :             XllpUnlock(LockID);

  0038c	eb000000	 bl          XllpUnlock

; 559  : 
; 560  :             // Assert chip select on the LCD
; 561  :             LockID = XllpLock(GPCR2);

  00390	e3a0000c	 mov         r0, #0xC
  00394	eb000000	 bl          XllpLock
  00398	e1a0b000	 mov         r11, r0

; 562  :             LockID2 = XllpLock(GPSR2);

  0039c	e3a00009	 mov         r0, #9
  003a0	eb000000	 bl          XllpLock

; 563  :             
; 564  :             p_GPIORegs->GPCR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  003a4	e594302c	 ldr         r3, [r4, #0x2C]

; 565  :             p_GPIORegs->GPSR2 |= XLLP_GPIO_BIT_L_BIAS;  
; 566  :     
; 567  :             
; 568  :             XllpOstDelayMilliSeconds(p_OSTRegs, 1);

  003a8	e59d9000	 ldr         r9, [sp]
  003ac	e58d0004	 str         r0, [sp, #4]
  003b0	e3c33a02	 bic         r3, r3, #2, 20
  003b4	e584302c	 str         r3, [r4, #0x2C]
  003b8	e5943020	 ldr         r3, [r4, #0x20]
  003bc	e3a01001	 mov         r1, #1
  003c0	e1a00009	 mov         r0, r9
  003c4	e3833a02	 orr         r3, r3, #2, 20
  003c8	e5843020	 str         r3, [r4, #0x20]
  003cc	eb000000	 bl          XllpOstDelayMilliSeconds

; 569  :             p_SSPRegs->sscr0 = 0x00C01030;

  003d0	e59f3388	 ldr         r3, [pc, #0x388]
  003d4	e3a02825	 mov         r2, #0x25, 16

; 570  :             p_SSPRegs->sscr1 = 0x00008000;
; 571  :             p_SSPRegs->sspsp = 0x0025000C;
; 572  :             p_SSPRegs->sscr0 |= 0x8F;

  003d8	e1a07005	 mov         r7, r5
  003dc	e5853000	 str         r3, [r5]
  003e0	e382300c	 orr         r3, r2, #0xC
  003e4	e5858004	 str         r8, [r5, #4]
  003e8	e585302c	 str         r3, [r5, #0x2C]
  003ec	e5953000	 ldr         r3, [r5]
  003f0	e383308f	 orr         r3, r3, #0x8F
  003f4	e4873008	 str         r3, [r7], #8
  003f8		 |$LL13@LCDInitCon|

; 573  : 
; 574  :             // Wait for the operation to complete
; 575  :             while(p_SSPRegs->sssr & 0x10);

  003f8	e5973000	 ldr         r3, [r7]
  003fc	e3130010	 tst         r3, #0x10
  00400	1afffffc	 bne         |$LL13@LCDInitCon|

; 576  : 
; 577  :             for (i = 0; i < sizeof(LS022Q8DD06_DATA_SET_1) >> 1; i+=2)

  00404	e59f8350	 ldr         r8, [pc, #0x350]
  00408	e3a0a023	 mov         r10, #0x23
  0040c	e1a06008	 mov         r6, r8
  00410		 |$LL11@LCDInitCon|

; 578  :             {
; 579  :                 p_GPIORegs->GPCR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  00410	e594302c	 ldr         r3, [r4, #0x2C]
  00414	e3c33a02	 bic         r3, r3, #2, 20
  00418	e584302c	 str         r3, [r4, #0x2C]

; 580  :                 p_GPIORegs->GPSR2 |= XLLP_GPIO_BIT_L_BIAS;  

  0041c	e5943020	 ldr         r3, [r4, #0x20]
  00420	e3833a02	 orr         r3, r3, #2, 20
  00424	e5843020	 str         r3, [r4, #0x20]

; 581  :     
; 582  :                 p_SSPRegs->ssdr = LS022Q8DD06_DATA_SET_1[i];

  00428	e1d630b0	 ldrh        r3, [r6]
  0042c	e5853010	 str         r3, [r5, #0x10]

; 583  :                 p_SSPRegs->ssdr = LS022Q8DD06_DATA_SET_1[i+1];

  00430	e1d630b2	 ldrh        r3, [r6, #2]
  00434	e5853010	 str         r3, [r5, #0x10]
  00438		 |$LL8@LCDInitCon|

; 584  : 
; 585  :                 // Wait for the operation to complete
; 586  :                 while(p_SSPRegs->sssr & 0x10);

  00438	e5973000	 ldr         r3, [r7]
  0043c	e3130010	 tst         r3, #0x10
  00440	1afffffc	 bne         |$LL8@LCDInitCon|

; 587  :     
; 588  :                 XllpOstDelayMicroSeconds(p_OSTRegs, 50);

  00444	e3a01032	 mov         r1, #0x32
  00448	e1a00009	 mov         r0, r9
  0044c	eb000000	 bl          XllpOstDelayMicroSeconds

; 589  :                 p_GPIORegs->GPSR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  00450	e5943020	 ldr         r3, [r4, #0x20]

; 590  :                 p_GPIORegs->GPCR2 |= XLLP_GPIO_BIT_L_BIAS;
; 591  : 
; 592  :                 XllpOstDelayMilliSeconds(p_OSTRegs, 100);

  00454	e3a01064	 mov         r1, #0x64
  00458	e1a00009	 mov         r0, r9
  0045c	e3c33a02	 bic         r3, r3, #2, 20
  00460	e5843020	 str         r3, [r4, #0x20]
  00464	e594302c	 ldr         r3, [r4, #0x2C]
  00468	e3833a02	 orr         r3, r3, #2, 20
  0046c	e584302c	 str         r3, [r4, #0x2C]
  00470	eb000000	 bl          XllpOstDelayMilliSeconds
  00474	e2866004	 add         r6, r6, #4
  00478	e25aa001	 subs        r10, r10, #1
  0047c	1affffe3	 bne         |$LL11@LCDInitCon|

; 593  :             }
; 594  : 
; 595  :             for (i = 0; i < sizeof(LS022Q8DD06_DATA_SET_2) >> 1; i+=2)

  00480	e288608c	 add         r6, r8, #0x8C
  00484	e3a08009	 mov         r8, #9
  00488		 |$LL6@LCDInitCon|

; 596  :             {
; 597  :                 p_GPIORegs->GPCR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  00488	e594302c	 ldr         r3, [r4, #0x2C]
  0048c	e3c33a02	 bic         r3, r3, #2, 20
  00490	e584302c	 str         r3, [r4, #0x2C]

; 598  :                 p_GPIORegs->GPSR2 |= XLLP_GPIO_BIT_L_BIAS;  

  00494	e5943020	 ldr         r3, [r4, #0x20]
  00498	e3833a02	 orr         r3, r3, #2, 20
  0049c	e5843020	 str         r3, [r4, #0x20]

; 599  :     
; 600  :                 p_SSPRegs->ssdr = LS022Q8DD06_DATA_SET_2[i];

  004a0	e1d630b0	 ldrh        r3, [r6]
  004a4	e5853010	 str         r3, [r5, #0x10]

; 601  :                 p_SSPRegs->ssdr = LS022Q8DD06_DATA_SET_2[i+1];

  004a8	e1d630b2	 ldrh        r3, [r6, #2]
  004ac	e5853010	 str         r3, [r5, #0x10]
  004b0		 |$LL3@LCDInitCon|

; 602  : 
; 603  :                 // Wait for the operation to complete
; 604  :                 while(p_SSPRegs->sssr & 0x10);

  004b0	e5973000	 ldr         r3, [r7]
  004b4	e3130010	 tst         r3, #0x10
  004b8	1afffffc	 bne         |$LL3@LCDInitCon|

; 605  :                 XllpOstDelayMicroSeconds(p_OSTRegs, 50);

  004bc	e3a01032	 mov         r1, #0x32
  004c0	e1a00009	 mov         r0, r9
  004c4	eb000000	 bl          XllpOstDelayMicroSeconds

; 606  :                 p_GPIORegs->GPSR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  004c8	e5943020	 ldr         r3, [r4, #0x20]

; 607  :                 p_GPIORegs->GPCR2 |= XLLP_GPIO_BIT_L_BIAS;
; 608  :             
; 609  :                 XllpOstDelayMilliSeconds(p_OSTRegs, 100);

  004cc	e3a01064	 mov         r1, #0x64
  004d0	e1a00009	 mov         r0, r9
  004d4	e3c33a02	 bic         r3, r3, #2, 20
  004d8	e5843020	 str         r3, [r4, #0x20]
  004dc	e594302c	 ldr         r3, [r4, #0x2C]
  004e0	e3833a02	 orr         r3, r3, #2, 20
  004e4	e584302c	 str         r3, [r4, #0x2C]
  004e8	eb000000	 bl          XllpOstDelayMilliSeconds
  004ec	e2866004	 add         r6, r6, #4
  004f0	e2588001	 subs        r8, r8, #1
  004f4	1affffe3	 bne         |$LL6@LCDInitCon|

; 610  :             }
; 611  : 
; 612  : 
; 613  :             // De-assert chip select on the LCD
; 614  :             p_GPIORegs->GPSR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  004f8	e5943020	 ldr         r3, [r4, #0x20]

; 615  :             p_GPIORegs->GPCR2 |= XLLP_GPIO_BIT_L_BIAS;
; 616  :             XllpUnlock(LockID);

  004fc	e1a0000b	 mov         r0, r11
  00500	e3c33a02	 bic         r3, r3, #2, 20
  00504	e5843020	 str         r3, [r4, #0x20]
  00508	e594302c	 ldr         r3, [r4, #0x2C]
  0050c	e3833a02	 orr         r3, r3, #2, 20
  00510	e584302c	 str         r3, [r4, #0x2C]
  00514	eb000000	 bl          XllpUnlock

; 617  :             XllpUnlock(LockID2);

  00518	e59d0004	 ldr         r0, [sp, #4]
  0051c	eb000000	 bl          XllpUnlock

; 618  : 
; 619  :         }
; 620  :         break;

  00520	ea00007f	 b           |$LN27@LCDInitCon|
  00524		 |$LN25@LCDInitCon|

; 388  :             }
; 389  :         }
; 390  :         break;
; 391  : 
; 392  :     case LTM035A776C: // 240x320 16bpp active matrix
; 393  :         {
; 394  : 
; 395  :             // 
; 396  :             // The actual equation requires that we take the ceiling of a floating point result.
; 397  :             // Rather than use floats, we'll calculate an approximation to the correct PCD value
; 398  :             // using integers.
; 399  :             //
; 400  :             PCD = (LCLK / (2 * LTM035A776C_PIXEL_CLOCK_FREQUENCY));

  00524	e59f322c	 ldr         r3, [pc, #0x22C]

; 401  :             
; 402  :             // Configure the LCD Controller Control Registers
; 403  :             p_LCDRegs->LCCR0 = (LCD_LDM | LCD_SFM | LCD_IUM | LCD_EFM | 
; 404  :                                 LCD_PAS | LCD_QDM | LCD_BM  | LCD_OUM |
; 405  :                                 LCD_RDSTM | LCD_CMDIM | LCD_OUC | LCD_LDDALT);

  00528	e59f2204	 ldr         r2, [pc, #0x204]

; 406  : 
; 407  :             p_LCDRegs->LCCR1 = (LCD_PPL(0xEF) | LCD_HSW(0x04) | 
; 408  :                                 LCD_ELW(0x04)  | LCD_BLW(0x05) );

  0052c	e59f1220	 ldr         r1, [pc, #0x220]
  00530	e0c0e39a	 smull       lr, r0, r10, r3

; 409  :             
; 410  :             p_LCDRegs->LCCR2 = (LCD_LPP(0x13f) | LCD_VSW(0x02) |
; 411  :                                 LCD_EFW(0x03)  | LCD_BFW(0x02) );

  00534	e59f3214	 ldr         r3, [pc, #0x214]
  00538	e5872000	 str         r2, [r7]
  0053c	e58b1000	 str         r1, [r11]
  00540	e5873008	 str         r3, [r7, #8]
  00544	e080300a	 add         r3, r0, r10

; 412  : 
; 413  :             p_LCDRegs->LCCR3 = (LCD_PCD(PCD)  | LCD_BPP(BPP) | LCD_PCP | LCD_HSP |
; 414  :                                 LCD_PDFOR(pXllpLCD->PixelDataFormat));

  00548	e598002c	 ldr         r0, [r8, #0x2C]
  0054c	e1a03543	 mov         r3, r3, asr #10
  00550	e2092008	 and         r2, r9, #8
  00554	e0831fa3	 add         r1, r3, r3, lsr #31
  00558	e1820200	 orr         r0, r2, r0, lsl #4
  0055c	e2093007	 and         r3, r9, #7
  00560	e1833100	 orr         r3, r3, r0, lsl #2
  00564	e3812606	 orr         r2, r1, #6, 12
  00568	e1823c03	 orr         r3, r2, r3, lsl #24

; 415  :             
; 416  :             p_LCDRegs->LCCR4 = LCD_PAL_FOR(0);
; 417  :             if ( (p_LCDRegs->OVL1C1 & LCD_O1EN) || (p_LCDRegs->OVL2C1 & LCD_O2EN))
; 418  :             {
; 419  :                 p_LCDRegs->LCCR4 = LCD_PAL_FOR(1);
; 420  :             }
; 421  :         }
; 422  :         break;

  0056c	ea000061	 b           |$LN73@LCDInitCon|
  00570		 |$LN22@LCDInitCon|

; 423  : 
; 424  :     case LM8V31: // 640x480 16bpp dual panel passive
; 425  :         {
; 426  : 
; 427  :             // 
; 428  :             // The actual equation requires that we take the ceiling of a floating point result.
; 429  :             // Rather than use floats, we'll calculate an approximation to the correct PCD value
; 430  :             // using integers.
; 431  :             //
; 432  :             PCD = (LCLK / (2 * LM8V31_PIXEL_CLOCK_FREQUENCY));
; 433  : 
; 434  :             // Reconfigure the upper panel frame descriptors for dual panel operation by
; 435  :             // setting the DMA transfer length to half the size of the frame buffer
; 436  :             pXllpLCD->frameDescriptorCh0fd1->LDCMD = pXllpLCD->FrameBufferSize >> 1;

  00570	e5983020	 ldr         r3, [r8, #0x20]
  00574	e5982068	 ldr         r2, [r8, #0x68]

; 437  :             pXllpLCD->frameDescriptorCh0fd2->LDCMD = pXllpLCD->FrameBufferSize >> 1;
; 438  : 
; 439  :             // Configure the lower panel frame descriptor for dual panel operation.
; 440  :             // Set the physical address of the frame descriptor
; 441  :             pXllpLCD->frameDescriptorCh1->FDADR = LCD_FDADR(pXllpLCD->_DMA_CHANNEL_1_FRAME_DESCRIPTOR_BASE_PHYSICAL);
; 442  : 
; 443  :             // Set the physical address of the frame buffer
; 444  :             pXllpLCD->frameDescriptorCh1->FSADR = LCD_FSADR(pXllpLCD->_FRAME_BUFFER_BASE_PHYSICAL + pXllpLCD->CurrentPage*pXllpLCD->FrameBufferSize + (pXllpLCD->FrameBufferSize >> 1));
; 445  : 
; 446  :             // Clear the frame ID
; 447  :             pXllpLCD->frameDescriptorCh1->FIDR  = LCD_FIDR(0);
; 448  : 
; 449  :             // Set the DMA transfer length to half the size of the frame buffer
; 450  :             pXllpLCD->frameDescriptorCh1->LDCMD = LCD_Len(pXllpLCD->FrameBufferSize >> 1);
; 451  : 
; 452  :             // Store the physical address of this frame descriptor in the frame descriptor
; 453  :             pXllpLCD->frameDescriptorCh1->PHYSADDR = pXllpLCD->frameDescriptorCh1->FDADR;
; 454  :             
; 455  :             // FBR1 is cleared and is not used in this implementation
; 456  :             p_LCDRegs->FBR1 = 0;
; 457  : 
; 458  :             // Load the contents of FDADR1 with the physical address of this frame descriptor
; 459  :             p_LCDRegs->FDADR1 = pXllpLCD->frameDescriptorCh1->FDADR;
; 460  :         
; 461  :             
; 462  :             // Configure the TMED dithering engine
; 463  :             // Use the magic number described in the EAS, 0x00AA5500;
; 464  :             p_LCDRegs->TRGBR = LCD_TRS(0x00) | LCD_TGS(0x55) | LCD_TBS(0xAA);
; 465  : 
; 466  :             // Use the magic number described in the EAS, 0x0000754F;
; 467  :             p_LCDRegs->TCR = LCD_TM2S | LCD_TM1S | LCD_TM2En | LCD_TM1En        |
; 468  :                              LCD_TVBS(0x04) | LCD_THBS(0x05) | LCD_TSCS(0x03)   |  
; 469  :                              LCD_TED;
; 470  : 
; 471  :         
; 472  :             p_LCDRegs->LCCR0 = (LCD_SDS | LCD_LDM | LCD_SFM | LCD_IUM   |
; 473  :                                 LCD_EFM | LCD_PDD(0x01)     | LCD_BM    |
; 474  :                                 LCD_RDSTM | LCD_CMDIM | LCD_OUC | LCD_LDDALT);

  00578	e3a05000	 mov         r5, #0
  0057c	e1a030a3	 mov         r3, r3, lsr #1
  00580	e582300c	 str         r3, [r2, #0xC]
  00584	e5983020	 ldr         r3, [r8, #0x20]
  00588	e598206c	 ldr         r2, [r8, #0x6C]
  0058c	e3a0e8aa	 mov         lr, #0xAA, 16
  00590	e1a030a3	 mov         r3, r3, lsr #1
  00594	e582300c	 str         r3, [r2, #0xC]
  00598	e5983050	 ldr         r3, [r8, #0x50]
  0059c	e5982070	 ldr         r2, [r8, #0x70]
  005a0	e59f61a4	 ldr         r6, [pc, #0x1A4]
  005a4	e3c3300f	 bic         r3, r3, #0xF
  005a8	e5823000	 str         r3, [r2]
  005ac	e5981020	 ldr         r1, [r8, #0x20]
  005b0	e5983030	 ldr         r3, [r8, #0x30]
  005b4	e5982034	 ldr         r2, [r8, #0x34]
  005b8	e5980070	 ldr         r0, [r8, #0x70]
  005bc	e0030391	 mul         r3, r1, r3

; 475  : 
; 476  :             p_LCDRegs->LCCR1 = (LCD_PPL(0x27F)  | LCD_HSW(0x02) |
; 477  :                                 LCD_ELW(0x03)   | LCD_BLW(0x03) );

  005c0	e59f4180	 ldr         r4, [pc, #0x180]
  005c4	e38eec55	 orr         lr, lr, #0x55, 24
  005c8	e08330a1	 add         r3, r3, r1, lsr #1
  005cc	e0833002	 add         r3, r3, r2
  005d0	e3c33007	 bic         r3, r3, #7
  005d4	e5803004	 str         r3, [r0, #4]
  005d8	e5983070	 ldr         r3, [r8, #0x70]
  005dc	e3a01c75	 mov         r1, #0x75, 24
  005e0	e59f015c	 ldr         r0, [pc, #0x15C]
  005e4	e5835008	 str         r5, [r3, #8]
  005e8	e5983020	 ldr         r3, [r8, #0x20]
  005ec	e5982070	 ldr         r2, [r8, #0x70]
  005f0	e1a030a3	 mov         r3, r3, lsr #1
  005f4	e582300c	 str         r3, [r2, #0xC]
  005f8	e5982070	 ldr         r2, [r8, #0x70]
  005fc	e5923000	 ldr         r3, [r2]
  00600	e5823010	 str         r3, [r2, #0x10]
  00604	e5875024	 str         r5, [r7, #0x24]
  00608	e5983070	 ldr         r3, [r8, #0x70]
  0060c	e381204f	 orr         r2, r1, #0x4F
  00610	e3a01b01	 mov         r1, #1, 22
  00614	e5933000	 ldr         r3, [r3]

; 478  : 
; 479  :             p_LCDRegs->LCCR2 = (LCD_LPP(0xef)   | LCD_VSW(0x01) |
; 480  :                                 LCD_EFW(0x00)   | LCD_BFW(0x00) );

  00618	e38110ef	 orr         r1, r1, #0xEF
  0061c	e0c0509a	 smull       r5, r0, r10, r0
  00620	e5873210	 str         r3, [r7, #0x210]
  00624	e587e040	 str         lr, [r7, #0x40]
  00628	e5872044	 str         r2, [r7, #0x44]
  0062c	e5876000	 str         r6, [r7]
  00630	e58b4000	 str         r4, [r11]
  00634	e5871008	 str         r1, [r7, #8]

; 481  : 
; 482  :             p_LCDRegs->LCCR3 = (LCD_PCD(PCD)    | LCD_ACB(0xff) |
; 483  :                                 LCD_PCP         | LCD_BPP(BPP)  |
; 484  :                                 LCD_PDFOR(pXllpLCD->PixelDataFormat));

  00638	e598202c	 ldr         r2, [r8, #0x2C]
  0063c	e2093008	 and         r3, r9, #8
  00640	e1a013c0	 mov         r1, r0, asr #7
  00644	e3a0e501	 mov         lr, #1, 10
  00648	e1830202	 orr         r0, r3, r2, lsl #4
  0064c	e2092007	 and         r2, r9, #7
  00650	e38e3cff	 orr         r3, lr, #0xFF, 24
  00654	e0811fa1	 add         r1, r1, r1, lsr #31
  00658	e1822100	 orr         r2, r2, r0, lsl #2
  0065c	e1813003	 orr         r3, r1, r3

; 485  : 
; 486  :             p_LCDRegs->LCCR4 = LCD_PAL_FOR(0);
; 487  :             if ( (p_LCDRegs->OVL1C1 & LCD_O1EN) || (p_LCDRegs->OVL2C1 & LCD_O2EN))
; 488  :             {
; 489  :                 p_LCDRegs->LCCR4 = LCD_PAL_FOR(1);
; 490  :             }
; 491  :         }
; 492  :         break;

  00660	ea000023	 b           |$LN74@LCDInitCon|
  00664		 |$LN19@LCDInitCon|

; 493  :     case LQ64D341: // 176x220 active matrix Stinger display
; 494  :         {
; 495  : 
; 496  :             // 
; 497  :             // The actual equation requires that we take the ceiling of a floating point result.
; 498  :             // Rather than use floats, we'll calculate an approximation to the correct PCD value
; 499  :             // using integers.
; 500  :             //
; 501  :             PCD = (LCLK / (2 * LQ64D341_PIXEL_CLOCK_FREQUENCY));

  00664	e59f20d4	 ldr         r2, [pc, #0xD4]
  00668	e3a03679	 mov         r3, #0x79, 12

; 502  : 
; 503  :             p_LCDRegs->LCCR0 = ( LCD_LDM | LCD_SFM | LCD_IUM    |
; 504  :                                  LCD_EFM | LCD_PAS | LCD_BM     |
; 505  :                                  LCD_RDSTM | LCD_CMDIM | LCD_OUC | LCD_LDDALT);
; 506  : 
; 507  :             p_LCDRegs->LCCR1 = ( LCD_PPL(0xAF)  | LCD_HSW(0x02) |
; 508  :                                  LCD_ELW(0x7B)  | LCD_BLW(0x03) );

  0066c	e59f10c8	 ldr         r1, [pc, #0xC8]
  00670	e0c2029a	 smull       r0, r2, r10, r2
  00674	e38330f8	 orr         r3, r3, #0xF8
  00678	e3a0eb81	 mov         lr, #0x81, 22
  0067c	e5873000	 str         r3, [r7]

; 509  : 
; 510  :             p_LCDRegs->LCCR2 = ( LCD_LPP(0xdb)  | LCD_VSW(0x01) |
; 511  :                                  LCD_EFW(0x02)  | LCD_BFW(0x00) );

  00680	e38e30db	 orr         r3, lr, #0xDB
  00684	e58b1000	 str         r1, [r11]
  00688	e1a01442	 mov         r1, r2, asr #8
  0068c	e5873008	 str         r3, [r7, #8]

; 512  : 
; 513  :             p_LCDRegs->LCCR3 = ( LCD_PCD(PCD)   | LCD_BPP(BPP)   | 
; 514  :                                  LCD_VSP        | LCD_HSP        | LCD_PCP  | 
; 515  :                                  LCD_OEP        | LCD_PDFOR(pXllpLCD->PixelDataFormat));

  00690	e598202c	 ldr         r2, [r8, #0x2C]
  00694	e2093008	 and         r3, r9, #8
  00698	e0811fa1	 add         r1, r1, r1, lsr #31
  0069c	e1832202	 orr         r2, r3, r2, lsl #4
  006a0	e2093007	 and         r3, r9, #7
  006a4	e1832102	 orr         r2, r3, r2, lsl #2
  006a8	e381360f	 orr         r3, r1, #0xF, 12

; 516  : 
; 517  :             p_LCDRegs->LCCR4 = LCD_PAL_FOR(0);
; 518  :             if ( (p_LCDRegs->OVL1C1 & LCD_O1EN) || (p_LCDRegs->OVL2C1 & LCD_O2EN))
; 519  :             {
; 520  :                 p_LCDRegs->LCCR4 = LCD_PAL_FOR(1);
; 521  :             }
; 522  : 
; 523  :             }
; 524  :         break;

  006ac	ea000010	 b           |$LN74@LCDInitCon|
  006b0		 |$LN28@LCDInitCon|

; 359  :     {
; 360  :         case LTM04C380K: // 640x480 16bpp active matrix
; 361  :         {
; 362  : 
; 363  :             // 
; 364  :             // The actual equation requires that we take the ceiling of a floating point result.
; 365  :             // Rather than use floats, we'll calculate an approximation to the correct PCD value
; 366  :             // using integers.  
; 367  :             //
; 368  :             PCD = (LCLK / (2 * LTM04C380K_PIXEL_CLOCK_FREQUENCY));
; 369  : 
; 370  :             // Configure the LCD Controller Control Registers
; 371  :             p_LCDRegs->LCCR0 = (LCD_LDM | LCD_SFM | LCD_IUM | LCD_EFM | 
; 372  :                                 LCD_PAS | LCD_QDM | LCD_BM  | LCD_OUM |
; 373  :                                 LCD_RDSTM | LCD_CMDIM | LCD_OUC | LCD_LDDALT);

  006b0	e59f2080	 ldr         r2, [pc, #0x80]
  006b4	e59f3078	 ldr         r3, [pc, #0x78]

; 374  : 
; 375  :             p_LCDRegs->LCCR1 = (LCD_PPL(0x27FU) | LCD_HSW(0x01) | 
; 376  :                                 LCD_ELW(0x01)  | LCD_BLW(0x9fU) );

  006b8	e59f1070	 ldr         r1, [pc, #0x70]
  006bc	e0c2029a	 smull       r0, r2, r10, r2
  006c0	e3a0ecb1	 mov         lr, #0xB1, 24
  006c4	e5873000	 str         r3, [r7]

; 377  :             
; 378  :             p_LCDRegs->LCCR2 = (LCD_LPP(0x1df) | LCD_VSW(0x2c) |
; 379  :                                 LCD_EFW(0x00)  | LCD_BFW(0x00) );

  006c8	e38e30df	 orr         r3, lr, #0xDF
  006cc	e58b1000	 str         r1, [r11]
  006d0	e1a015c2	 mov         r1, r2, asr #11
  006d4	e5873008	 str         r3, [r7, #8]

; 380  : 
; 381  :             p_LCDRegs->LCCR3 = (LCD_PCD(PCD)  | LCD_BPP(BPP) | LCD_PCP |
; 382  :                                 LCD_PDFOR(pXllpLCD->PixelDataFormat));

  006d8	e598202c	 ldr         r2, [r8, #0x2C]
  006dc	e2093008	 and         r3, r9, #8
  006e0	e0811fa1	 add         r1, r1, r1, lsr #31
  006e4	e1832202	 orr         r2, r3, r2, lsl #4
  006e8	e2093007	 and         r3, r9, #7
  006ec	e1832102	 orr         r2, r3, r2, lsl #2
  006f0	e3813501	 orr         r3, r1, #1, 10
  006f4		 |$LN74@LCDInitCon|
  006f4	e1833c02	 orr         r3, r3, r2, lsl #24
  006f8		 |$LN73@LCDInitCon|
  006f8	e587300c	 str         r3, [r7, #0xC]

; 383  :             
; 384  :             p_LCDRegs->LCCR4 = LCD_PAL_FOR(0);

  006fc	e3a03000	 mov         r3, #0
  00700	e5873010	 str         r3, [r7, #0x10]

; 385  :             if ( (p_LCDRegs->OVL1C1 & LCD_O1EN) || (p_LCDRegs->OVL2C1 & LCD_O2EN))

  00704	e5973050	 ldr         r3, [r7, #0x50]
  00708	e3130102	 tst         r3, #2, 2
  0070c	1a000002	 bne         |$LN26@LCDInitCon|
  00710	e5973070	 ldr         r3, [r7, #0x70]
  00714	e3130102	 tst         r3, #2, 2
  00718	0a000001	 beq         |$LN27@LCDInitCon|
  0071c		 |$LN26@LCDInitCon|

; 386  :             {
; 387  :                 p_LCDRegs->LCCR4 = LCD_PAL_FOR(1);

  0071c	e3a03902	 mov         r3, #2, 18
  00720	e5873010	 str         r3, [r7, #0x10]
  00724		 |$LN27@LCDInitCon|

; 621  : 
; 622  :     default:
; 623  :         {
; 624  : 
; 625  :         }
; 626  :         break;
; 627  :     }
; 628  : 
; 629  : }

  00724	e28dd008	 add         sp, sp, #8
  00728	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0072c	e12fff1e	 bx          lr
  00730		 |$LN79@LCDInitCon|
  00730		 |$LN80@LCDInitCon|
  00730	9f01067f	 DCD         0x9f01067f
  00734		 |$LN81@LCDInitCon|
  00734	07b008f8	 DCD         0x7b008f8
  00738		 |$LN82@LCDInitCon|
  00738	681ba759	 DCD         0x681ba759
  0073c		 |$LN83@LCDInitCon|
  0073c	037b08af	 DCD         0x37b08af
  00740		 |$LN84@LCDInitCon|
  00740	551c979b	 DCD         0x551c979b
  00744		 |$LN85@LCDInitCon|
  00744	24168e19	 DCD         0x24168e19
  00748		 |$LN86@LCDInitCon|
  00748	03030a7f	 DCD         0x3030a7f
  0074c		 |$LN87@LCDInitCon|
  0074c	0790107c	 DCD         0x790107c
  00750		 |$LN88@LCDInitCon|
  00750	0203093f	 DCD         0x203093f
  00754		 |$LN89@LCDInitCon|
  00754	050410ef	 DCD         0x50410ef
  00758		 |$LN90@LCDInitCon|
  00758	90090091	 DCD         0x90090091
  0075c		 |$LN91@LCDInitCon|
  0075c	00000000	 DCD         |LS022Q8DD06_DATA_SET_1|
  00760		 |$LN92@LCDInitCon|
  00760	00c01030	 DCD         0xc01030
  00764		 |$LN93@LCDInitCon|
  00764	0002093f	 DCD         0x2093f
  00768		 |$LN94@LCDInitCon|
  00768	070004ef	 DCD         0x70004ef
  0076c		 |$LN95@LCDInitCon|
  0076c	f2b9d649	 DCD         0xf2b9d649
  00770		 |$LN96@LCDInitCon|
  00770	3f3f3f3f	 DCD         0x3f3f3f3f
  00774		 |$M1351|

			 ENDP  ; |LCDInitController|

	EXPORT	|LCDClearStatusReg|

  00000			 AREA	 |.pdata|, PDATA
|$T1380| DCD	|$LN5@LCDClearSt|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LCDClearStatusReg| PROC

; 633  : {

  00000		 |$LN5@LCDClearSt|
  00000		 |$M1377|

; 634  :     volatile LCDRegs *p_LCDRegs;
; 635  :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC;

  00000	e5901008	 ldr         r1, [r0, #8]

; 636  : 
; 637  :     // Clear the status registers by writing 1's to each bit.
; 638  :     p_LCDRegs->LCSR0 =  ( LCD_LDD | LCD_SOF0| LCD_BER | LCD_ABC | LCD_IU0   |
; 639  :                           LCD_IU1 | LCD_OU  | LCD_QD  | LCD_EOF0| LCD_BS0   | 
; 640  :                           LCD_SINT| LCD_RD_ST | LCD_CMD_INTR );
; 641  : 
; 642  :     p_LCDRegs->LCSR1 =  ( LCD_SOF1| LCD_SOF2| LCD_SOF3| LCD_SOF4| LCD_SOF5  | LCD_SOF6  |
; 643  :                           LCD_EOF1| LCD_EOF2| LCD_EOF3| LCD_EOF4| LCD_EOF5  | LCD_EOF6  |
; 644  :                           LCD_BS1 | LCD_BS2 | LCD_BS3 | LCD_BS4 | LCD_BS5   | LCD_BS6   |
; 645  :                                     LCD_IU2 | LCD_IU3 | LCD_IU4 | LCD_IU5   | LCD_IU6 );

  00004	e59f2010	 ldr         r2, [pc, #0x10]
  00008	e3a03c1f	 mov         r3, #0x1F, 24
  0000c	e38330ff	 orr         r3, r3, #0xFF
  00010	e5813038	 str         r3, [r1, #0x38]
  00014	e5812034	 str         r2, [r1, #0x34]

; 646  : 
; 647  : }

  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@LCDClearSt|
  0001c		 |$LN7@LCDClearSt|
  0001c	3e3f3f3f	 DCD         0x3e3f3f3f
  00020		 |$M1378|

			 ENDP  ; |LCDClearStatusReg|

	EXPORT	|LCDSetupGPIOs|

  00000			 AREA	 |.pdata|, PDATA
|$T1405| DCD	|$LN19@LCDSetupGP|
	DCD	0x40007001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LCDSetupGPIOs| PROC

; 650  : {

  00000		 |$LN19@LCDSetupGP|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M1402|
  00004	e1a05000	 mov         r5, r0

; 651  :     XLLP_UINT32_T LockID;
; 652  :     volatile XLLP_GPIO_T *p_GPIORegs;
; 653  : 
; 654  :     p_GPIORegs = (XLLP_GPIO_T *) pXllpLCD->GPIO;
; 655  : 
; 656  :     LockID = XllpLock(GPDR0);

  00008	e5954000	 ldr         r4, [r5]
  0000c	e3a00004	 mov         r0, #4
  00010	eb000000	 bl          XllpLock

; 657  : 
; 658  :     if (pXllpLCD->DisplayType != LS022Q8DD06)

  00014	e5953014	 ldr         r3, [r5, #0x14]
  00018	e3530006	 cmp         r3, #6

; 659  :     {
; 660  :         p_GPIORegs->GPDR0 = (p_GPIORegs->GPDR0 & ~XLLP_GPIO_BIT_L_VSYNC) | (XLLP_GPIO_BIT_PWM_OUT0 | XLLP_GPIO_BIT_L_CS);

  0001c	1594300c	 ldrne       r3, [r4, #0xC]
  00020	13c33901	 bicne       r3, r3, #1, 18
  00024	13833809	 orrne       r3, r3, #9, 16
  00028	1584300c	 strne       r3, [r4, #0xC]

; 661  :     }
; 662  : 
; 663  :     XllpUnlock(LockID);

  0002c	eb000000	 bl          XllpUnlock

; 664  : 
; 665  :     LockID = XllpLock(GPDR1);

  00030	e3a00005	 mov         r0, #5
  00034	eb000000	 bl          XllpLock

; 666  :     p_GPIORegs->GPDR1 |= ( XLLP_GPIO_BIT_L_DD0 | XLLP_GPIO_BIT_L_DD1 | XLLP_GPIO_BIT_L_DD2 | XLLP_GPIO_BIT_L_DD3 | XLLP_GPIO_BIT_L_DD4 | XLLP_GPIO_BIT_L_DD5);

  00038	e5943010	 ldr         r3, [r4, #0x10]

; 667  : 
; 668  :     // Set GPIO 38 and 40 as outputs
; 669  :     #if defined XLLP_GPIO_BIT_SSPTXD3 && XLLP_GPIO_BIT_SSPCLK3
; 670  :         if (pXllpLCD->DisplayType == LS022Q8DD06)
; 671  :         {
; 672  :             p_GPIORegs->GPDR1 |= (XLLP_GPIO_BIT_SSPTXD3 | XLLP_GPIO_BIT_SSPCLK3);
; 673  :         }
; 674  :     #endif
; 675  : 
; 676  :     XllpUnlock(LockID);

  0003c	e383333f	 orr         r3, r3, #0x3F, 6
  00040	e5843010	 str         r3, [r4, #0x10]
  00044	eb000000	 bl          XllpUnlock

; 677  : 
; 678  :     LockID = XllpLock(GPDR2);

  00048	e3a00006	 mov         r0, #6
  0004c	eb000000	 bl          XllpLock

; 679  : 
; 680  :     if (pXllpLCD->DisplayType != LS022Q8DD06)

  00050	e5953014	 ldr         r3, [r5, #0x14]

; 681  :     {
; 682  :         p_GPIORegs->GPDR2 |= (  XLLP_GPIO_BIT_L_DD6 | XLLP_GPIO_BIT_L_DD7 | XLLP_GPIO_BIT_L_DD8 | XLLP_GPIO_BIT_L_DD9 | XLLP_GPIO_BIT_L_DD10 | 
; 683  :                             XLLP_GPIO_BIT_L_DD11 | XLLP_GPIO_BIT_L_DD12 | XLLP_GPIO_BIT_L_DD13 | XLLP_GPIO_BIT_L_DD14 | XLLP_GPIO_BIT_L_DD15 |
; 684  :                             XLLP_GPIO_BIT_L_FCLK | XLLP_GPIO_BIT_L_LCLK | XLLP_GPIO_BIT_L_PCLK | XLLP_GPIO_BIT_L_BIAS | XLLP_GPIO_BIT_L_DD16 | 
; 685  :                             XLLP_GPIO_BIT_L_DD17);

  00054	e5942014	 ldr         r2, [r4, #0x14]
  00058	e3530006	 cmp         r3, #6
  0005c	13e034ff	 mvnne       r3, #0xFF, 8
  00060	122339ff	 eorne       r3, r3, #0xFF, 18

; 686  :     } else 
; 687  :     {
; 688  :         p_GPIORegs->GPDR2 |= (  XLLP_GPIO_BIT_L_DD6 | XLLP_GPIO_BIT_L_DD7 | XLLP_GPIO_BIT_L_DD8 | XLLP_GPIO_BIT_L_DD9 | XLLP_GPIO_BIT_L_DD10 | 
; 689  :                             XLLP_GPIO_BIT_L_DD11 | XLLP_GPIO_BIT_L_DD12 | XLLP_GPIO_BIT_L_DD13 | XLLP_GPIO_BIT_L_DD14 | XLLP_GPIO_BIT_L_DD15 |
; 690  :                             XLLP_GPIO_BIT_L_FCLK | XLLP_GPIO_BIT_L_LCLK | XLLP_GPIO_BIT_L_PCLK | XLLP_GPIO_BIT_L_BIAS );

  00064	03a03c3f	 moveq       r3, #0x3F, 24
  00068	038330ff	 orreq       r3, r3, #0xFF
  0006c	e1823003	 orr         r3, r2, r3
  00070	e5843014	 str         r3, [r4, #0x14]

; 691  : 
; 692  :         #if defined XLLP_GPIO_BIT_SSPRXD3
; 693  :             // Set GPIO 89 as input     
; 694  :             p_GPIORegs->GPDR2 &= ~(XLLP_GPIO_BIT_SSPRXD3);
; 695  :         #endif
; 696  :     }
; 697  :     
; 698  :     XllpUnlock(LockID);

  00074	eb000000	 bl          XllpUnlock

; 699  : 
; 700  :     if (pXllpLCD->DisplayType != LS022Q8DD06)

  00078	e5953014	 ldr         r3, [r5, #0x14]
  0007c	e3530006	 cmp         r3, #6
  00080	0a00000d	 beq         |$LN7@LCDSetupGP|

; 701  :     {
; 702  :         // Program the GAFR0_L to select alternate function 1 for GPIO 14.
; 703  :         LockID = XllpLock(GAFR0_L);

  00084	e3a00016	 mov         r0, #0x16
  00088	eb000000	 bl          XllpLock

; 704  :         p_GPIORegs->GAFR0_L = (p_GPIORegs->GAFR0_L & ~XLLP_GPIO_AF_BIT_L_VSYNC_MASK) | (XLLP_GPIO_AF_BIT_L_VSYNC);

  0008c	e5943054	 ldr         r3, [r4, #0x54]
  00090	e3c33203	 bic         r3, r3, #3, 4
  00094	e3833201	 orr         r3, r3, #1, 4
  00098	e5843054	 str         r3, [r4, #0x54]

; 705  :         XllpUnlock(LockID);

  0009c	eb000000	 bl          XllpUnlock

; 706  : 
; 707  :         // Program the GAFR0_U to select alternate function 2 for GPIO 19.
; 708  :         LockID = XllpLock(GAFR0_U);

  000a0	e3a00017	 mov         r0, #0x17
  000a4	eb000000	 bl          XllpLock

; 709  :         p_GPIORegs->GAFR0_U = (p_GPIORegs->GAFR0_U & ~XLLP_GPIO_AF_BIT_L_CS_MASK) | (XLLP_GPIO_AF_BIT_L_CS);

  000a8	e5943058	 ldr         r3, [r4, #0x58]
  000ac	e3c330c0	 bic         r3, r3, #0xC0
  000b0	e3833080	 orr         r3, r3, #0x80
  000b4	e5843058	 str         r3, [r4, #0x58]

; 710  :         XllpUnlock(LockID);

  000b8	eb000000	 bl          XllpUnlock
  000bc		 |$LN7@LCDSetupGP|

; 711  :     }
; 712  : 
; 713  :     if (pXllpLCD->DisplayType == LS022Q8DD06)
; 714  :     {
; 715  :         #if defined XLLP_GPIO_AF_BIT_SSPTXD3_MASK && XLLP_GPIO_AF_BIT_SSPCLK3_MASK && XLLP_GPIO_AF_BIT_SSPTXD3 && XLLP_GPIO_AF_BIT_SSPCLK3
; 716  :             // Program the GAFR1_L to select alternate function 1 for GPIO 38, 40.
; 717  :             LockID = XllpLock(GAFR1_L);
; 718  :             p_GPIORegs->GAFR1_L = (p_GPIORegs->GAFR1_L & ~(XLLP_GPIO_AF_BIT_SSPTXD3_MASK | XLLP_GPIO_AF_BIT_SSPCLK3_MASK)) | 
; 719  :                     (XLLP_GPIO_AF_BIT_SSPTXD3 | XLLP_GPIO_AF_BIT_SSPCLK3);
; 720  :             XllpUnlock(LockID);
; 721  :         #endif
; 722  :     }
; 723  : 
; 724  :     // Program the GAFR1_U to select alternate function 2 for GPIO 58 through 63.
; 725  :     LockID = XllpLock(GAFR1_U);

  000bc	e3a00019	 mov         r0, #0x19
  000c0	eb000000	 bl          XllpLock

; 726  :     p_GPIORegs->GAFR1_U = (p_GPIORegs->GAFR1_U & ~(XLLP_GPIO_AF_BIT_L_DD0_MASK | XLLP_GPIO_AF_BIT_L_DD1_MASK | XLLP_GPIO_AF_BIT_L_DD2_MASK|
; 727  :                                                    XLLP_GPIO_AF_BIT_L_DD3_MASK | XLLP_GPIO_AF_BIT_L_DD4_MASK | XLLP_GPIO_AF_BIT_L_DD5_MASK)) | 
; 728  :                                                   (XLLP_GPIO_AF_BIT_L_DD0 | XLLP_GPIO_AF_BIT_L_DD1 | XLLP_GPIO_AF_BIT_L_DD2 | 
; 729  :                                                    XLLP_GPIO_AF_BIT_L_DD3 | XLLP_GPIO_AF_BIT_L_DD4 | XLLP_GPIO_AF_BIT_L_DD5 );

  000c4	e5942060	 ldr         r2, [r4, #0x60]
  000c8	e3e034ff	 mvn         r3, #0xFF, 8
  000cc	e223360f	 eor         r3, r3, #0xF, 12
  000d0	e3a014aa	 mov         r1, #0xAA, 8
  000d4	e0022003	 and         r2, r2, r3
  000d8	e381360a	 orr         r3, r1, #0xA, 12
  000dc	e1823003	 orr         r3, r2, r3
  000e0	e5843060	 str         r3, [r4, #0x60]

; 730  :     XllpUnlock(LockID);

  000e4	eb000000	 bl          XllpUnlock

; 731  : 
; 732  :     // Program the GAFR2_L to select alternate function 2 for GPIO 64 through 77.
; 733  :     LockID = XllpLock(GAFR2_L);

  000e8	e3a0001a	 mov         r0, #0x1A
  000ec	eb000000	 bl          XllpLock

; 734  :     p_GPIORegs->GAFR2_L = (p_GPIORegs->GAFR2_L & ~(XLLP_GPIO_AF_BIT_L_DD6_MASK  | XLLP_GPIO_AF_BIT_L_DD7_MASK   | XLLP_GPIO_AF_BIT_L_DD8_MASK   |
; 735  :                                                    XLLP_GPIO_AF_BIT_L_DD9_MASK  | XLLP_GPIO_AF_BIT_L_DD10_MASK  | XLLP_GPIO_AF_BIT_L_DD11_MASK  |
; 736  :                                                    XLLP_GPIO_AF_BIT_L_DD12_MASK | XLLP_GPIO_AF_BIT_L_DD13_MASK  | XLLP_GPIO_AF_BIT_L_DD14_MASK  |
; 737  :                                                    XLLP_GPIO_AF_BIT_L_DD15_MASK | XLLP_GPIO_AF_BIT_L_FCLK_RD_MASK | XLLP_GPIO_AF_BIT_L_LCLK_A0_MASK |
; 738  :                                                    XLLP_GPIO_AF_BIT_L_PCLK_WR_MASK | XLLP_GPIO_AF_BIT_L_BIAS_MASK)) |
; 739  :                                                   (XLLP_GPIO_AF_BIT_L_DD6   | XLLP_GPIO_AF_BIT_L_DD7    | XLLP_GPIO_AF_BIT_L_DD8    | 
; 740  :                                                    XLLP_GPIO_AF_BIT_L_DD9   | XLLP_GPIO_AF_BIT_L_DD10   | XLLP_GPIO_AF_BIT_L_DD11   | 
; 741  :                                                    XLLP_GPIO_AF_BIT_L_DD12  | XLLP_GPIO_AF_BIT_L_DD13   | XLLP_GPIO_AF_BIT_L_DD14   | 
; 742  :                                                    XLLP_GPIO_AF_BIT_L_DD15  | XLLP_GPIO_AF_BIT_L_FCLK_RD| XLLP_GPIO_AF_BIT_L_LCLK_A0|
; 743  :                                                    XLLP_GPIO_AF_BIT_L_PCLK_WR   | XLLP_GPIO_AF_BIT_L_BIAS ); 

  000f0	e5943064	 ldr         r3, [r4, #0x64]
  000f4	e59f20c0	 ldr         r2, [pc, #0xC0]
  000f8	e203320f	 and         r3, r3, #0xF, 4
  000fc	e1833002	 orr         r3, r3, r2
  00100	e5843064	 str         r3, [r4, #0x64]

; 744  :     if (pXllpLCD->DisplayType == LS022Q8DD06)

  00104	e5953014	 ldr         r3, [r5, #0x14]
  00108	e3530006	 cmp         r3, #6

; 745  :     {
; 746  :         p_GPIORegs->GAFR2_L = (p_GPIORegs->GAFR2_L & ~XLLP_GPIO_AF_BIT_L_BIAS_MASK); 

  0010c	05943064	 ldreq       r3, [r4, #0x64]
  00110	03c33303	 biceq       r3, r3, #3, 6
  00114	05843064	 streq       r3, [r4, #0x64]

; 747  :     }
; 748  : 
; 749  :     XllpUnlock(LockID);

  00118	eb000000	 bl          XllpUnlock

; 750  : 
; 751  : 
; 752  :     if (pXllpLCD->DisplayType != LS022Q8DD06)

  0011c	e5953014	 ldr         r3, [r5, #0x14]
  00120	e3530006	 cmp         r3, #6
  00124	0a000009	 beq         |$LN13@LCDSetupGP|

; 753  :     {
; 754  :         // Program the GAFR2_U to select alternate function 2 for GPIO 86, 87.
; 755  :         LockID = XllpLock(GAFR2_U);

  00128	e3a0001b	 mov         r0, #0x1B
  0012c	eb000000	 bl          XllpLock

; 756  :         p_GPIORegs->GAFR2_U = (p_GPIORegs->GAFR2_U & ~(XLLP_GPIO_AF_BIT_L_DD16_MASK | XLLP_GPIO_AF_BIT_L_DD17_MASK))  | (XLLP_GPIO_AF_BIT_L_DD16 | XLLP_GPIO_AF_BIT_L_DD17); 

  00130	e5943068	 ldr         r3, [r4, #0x68]
  00134	e3c33a0f	 bic         r3, r3, #0xF, 20
  00138	e3833a0a	 orr         r3, r3, #0xA, 20
  0013c	e5843068	 str         r3, [r4, #0x68]

; 757  :         XllpUnlock(LockID);

  00140	eb000000	 bl          XllpUnlock

; 758  :     }
; 759  :         
; 760  :     if (pXllpLCD->DisplayType == LS022Q8DD06)

  00144	e5953014	 ldr         r3, [r5, #0x14]
  00148	e3530006	 cmp         r3, #6
  0014c	1a000009	 bne         |$LN14@LCDSetupGP|
  00150		 |$LN13@LCDSetupGP|

; 761  :     {
; 762  :         LockID = XllpLock(GAFR2_U);

  00150	e3a0001b	 mov         r0, #0x1B
  00154	eb000000	 bl          XllpLock

; 763  :         #if defined XLLP_GPIO_AF_BIT_SSPRXD3_MASK && XLLP_GPIO_AF_BIT_SSPRXD3
; 764  :             p_GPIORegs->GAFR2_U = (p_GPIORegs->GAFR2_U & ~XLLP_GPIO_AF_BIT_SSPRXD3_MASK)  | XLLP_GPIO_AF_BIT_SSPRXD3; 

  00158	e5943068	 ldr         r3, [r4, #0x68]
  0015c	e3c33030	 bic         r3, r3, #0x30
  00160	e3833010	 orr         r3, r3, #0x10
  00164	e5843068	 str         r3, [r4, #0x68]

; 765  :         #endif
; 766  :         XllpUnlock(LockID);

  00168	eb000000	 bl          XllpUnlock

; 767  :     }
; 768  : 
; 769  :     
; 770  : 
; 771  :     if (pXllpLCD->DisplayType != LS022Q8DD06)

  0016c	e5953014	 ldr         r3, [r5, #0x14]
  00170	e3530006	 cmp         r3, #6
  00174	0a000008	 beq         |$LN15@LCDSetupGP|
  00178		 |$LN14@LCDSetupGP|

; 772  :     {
; 773  :         LockID = XllpLock(GPSR0);

  00178	e3a00007	 mov         r0, #7
  0017c	eb000000	 bl          XllpLock

; 774  :         // Turn on the backlight...
; 775  :         p_GPIORegs->GPSR0 |= XLLP_GPIO_BIT_PWM_OUT0;

  00180	e5943018	 ldr         r3, [r4, #0x18]

; 776  :         XllpUnlock(LockID);

  00184	e3833801	 orr         r3, r3, #1, 16
  00188	e5843018	 str         r3, [r4, #0x18]
  0018c	eb000000	 bl          XllpUnlock

; 777  :     }
; 778  : 
; 779  :     if (pXllpLCD->DisplayType == LS022Q8DD06)

  00190	e5953014	 ldr         r3, [r5, #0x14]
  00194	e3530006	 cmp         r3, #6
  00198	1a000005	 bne         |$LN1@LCDSetupGP|
  0019c		 |$LN15@LCDSetupGP|

; 780  :     {
; 781  :         p_GPIORegs->GPSR2 &= ~XLLP_GPIO_BIT_L_BIAS;

  0019c	e5943020	 ldr         r3, [r4, #0x20]

; 782  :         p_GPIORegs->GPCR2 |= XLLP_GPIO_BIT_L_BIAS;

  001a0	e3c33a02	 bic         r3, r3, #2, 20
  001a4	e5843020	 str         r3, [r4, #0x20]
  001a8	e594302c	 ldr         r3, [r4, #0x2C]
  001ac	e3833a02	 orr         r3, r3, #2, 20
  001b0	e584302c	 str         r3, [r4, #0x2C]
  001b4		 |$LN1@LCDSetupGP|

; 783  :     }
; 784  : 
; 785  : }

  001b4	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001b8	e12fff1e	 bx          lr
  001bc		 |$LN20@LCDSetupGP|
  001bc		 |$LN21@LCDSetupGP|
  001bc	0aaaaaaa	 DCD         0xaaaaaaa
  001c0		 |$M1403|

			 ENDP  ; |LCDSetupGPIOs|

	EXPORT	|LCDEnableController|

  00000			 AREA	 |.pdata|, PDATA
|$T1416| DCD	|$LN5@LCDEnableC|
	DCD	0x40000500
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LCDEnableController| PROC

; 788  : {

  00000		 |$LN5@LCDEnableC|
  00000		 |$M1413|

; 789  :     volatile LCDRegs *p_LCDRegs;
; 790  : 
; 791  :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC;

  00000	e5902008	 ldr         r2, [r0, #8]

; 792  : 
; 793  :     p_LCDRegs->LCCR0 |= LCD_ENB;

  00004	e5923000	 ldr         r3, [r2]
  00008	e3833001	 orr         r3, r3, #1
  0000c	e5823000	 str         r3, [r2]

; 794  : }

  00010	e12fff1e	 bx          lr
  00014		 |$M1414|

			 ENDP  ; |LCDEnableController|

	EXPORT	|XllpLCD_DMALength|

  00000			 AREA	 |.pdata|, PDATA
|$T1432| DCD	|$LN31@XllpLCD_DM|
	DCD	0x40005901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCD_DMALength| PROC

; 880  : {

  00000		 |$LN31@XllpLCD_DM|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M1429|

; 881  :     unsigned int pixels = pXllpOverlay->OverlayHeight * pXllpOverlay->OverlayWidth;

  00004	e5901004	 ldr         r1, [r0, #4]
  00008	e5903000	 ldr         r3, [r0]

; 882  :     unsigned int DMALength = 0;
; 883  : 
; 884  :     // Determine the DMA transfer length
; 885  :     // each DMA transfer length for YUV formatted data must be multiples of 32-bits and adjusted accordingly
; 886  :     if (pXllpOverlay->Format == FORMAT_RGB)

  0000c	e5902010	 ldr         r2, [r0, #0x10]
  00010	e3a04000	 mov         r4, #0
  00014	e00e0391	 mul         lr, r1, r3
  00018	e3a01000	 mov         r1, #0
  0001c	e3520000	 cmp         r2, #0
  00020	1a000018	 bne         |$LN25@XllpLCD_DM|

; 887  :     {
; 888  :         switch(pXllpOverlay->OverlayBPP)

  00024	e5903028	 ldr         r3, [r0, #0x28]
  00028	e3530002	 cmp         r3, #2
  0002c	0a000011	 beq         |$LN22@XllpLCD_DM|
  00030	e3530003	 cmp         r3, #3
  00034	0a00000d	 beq         |$LN21@XllpLCD_DM|
  00038	e3530004	 cmp         r3, #4
  0003c	0a000009	 beq         |$LN20@XllpLCD_DM|
  00040	e3530005	 cmp         r3, #5
  00044	0a000005	 beq         |$LN19@XllpLCD_DM|
  00048	e3530007	 cmp         r3, #7
  0004c	0a000003	 beq         |$LN19@XllpLCD_DM|
  00050	e3530009	 cmp         r3, #9
  00054	0a000001	 beq         |$LN19@XllpLCD_DM|
  00058	e353000a	 cmp         r3, #0xA
  0005c	1a000006	 bne         |$LN23@XllpLCD_DM|
  00060		 |$LN19@XllpLCD_DM|

; 899  :             case O_BPP_18:
; 900  :                 DMALength = pixels << 2;

  00060	e1a0410e	 mov         r4, lr, lsl #2

; 901  :                 break;

  00064	ea000004	 b           |$LN23@XllpLCD_DM|
  00068		 |$LN20@XllpLCD_DM|

; 896  :             case O_BPP_16:
; 897  :                 DMALength = pixels << 1;

  00068	e1a0408e	 mov         r4, lr, lsl #1

; 898  :                 break;

  0006c	ea000002	 b           |$LN23@XllpLCD_DM|
  00070		 |$LN21@XllpLCD_DM|

; 892  :                 break;
; 893  :             case O_BPP_8:
; 894  :                 DMALength = pixels;

  00070	e1a0400e	 mov         r4, lr

; 895  :                 break;

  00074	ea000000	 b           |$LN23@XllpLCD_DM|
  00078		 |$LN22@XllpLCD_DM|

; 889  :         {
; 890  :             case O_BPP_4:
; 891  :                 DMALength = pixels >> 1;

  00078	e1a040ae	 mov         r4, lr, lsr #1
  0007c		 |$LN23@XllpLCD_DM|

; 902  :             case O_BPP_18_PACKED:
; 903  :                 break;
; 904  :             case O_BPP_19:
; 905  :                 DMALength = pixels << 2;
; 906  :                 break;
; 907  :             case O_BPP_19_PACKED:
; 908  :                 break;
; 909  :             case O_BPP_24:
; 910  :                 DMALength = pixels << 2;
; 911  :                 break;
; 912  :             case O_BPP_25:
; 913  :                 DMALength = pixels << 2;
; 914  :                 break;
; 915  :         default:
; 916  :             break;
; 917  :         }
; 918  :         pXllpOverlay->ch2_size = DMALength;

  0007c	e5804034	 str         r4, [r0, #0x34]

; 919  :         pXllpOverlay->ch3_size = 0;

  00080	e5801038	 str         r1, [r0, #0x38]

; 920  :         pXllpOverlay->ch4_size = 0;

  00084	e580103c	 str         r1, [r0, #0x3C]
  00088		 |$LN25@XllpLCD_DM|

; 921  :     }
; 922  :     if (pXllpOverlay->Format == FORMAT_PACKED_444)

  00088	e3520001	 cmp         r2, #1

; 923  :     {
; 924  :         pXllpOverlay->ch2_size = (pixels << 2);

  0008c	01a0310e	 moveq       r3, lr, lsl #2
  00090	05803034	 streq       r3, [r0, #0x34]

; 925  :         pXllpOverlay->ch3_size = 0;

  00094	05801038	 streq       r1, [r0, #0x38]

; 926  :         pXllpOverlay->ch4_size = 0;

  00098	0580103c	 streq       r1, [r0, #0x3C]

; 977  :     }
; 978  : 
; 979  : }

  0009c	08bd4010	 ldmeqia     sp!, {r4, lr}
  000a0	012fff1e	 bxeq        lr

; 927  :     } 
; 928  :     else if (pXllpOverlay->Format == FORMAT_PLANAR_444) 

  000a4	e3520002	 cmp         r2, #2
  000a8	1a000009	 bne         |$LN10@XllpLCD_DM|

; 929  :     {
; 930  :         // calculate the number of bits in the frame (pixels << 3)
; 931  :         // mod by 32 to determine the remainder
; 932  :         // subtract from 32 to determine how many bits to add to the length to make it a multiple of 32 bits
; 933  :         // add this value to the number of bits in the frame
; 934  :         // convert this value back to bytes
; 935  :         DMALength = pixels;
; 936  :         if ((DMALength % 4) > 0)

  000ac	e21e2003	 ands        r2, lr, #3

; 937  :         {
; 938  :             DMALength = (((32 - ((pixels << 3) % 32)) + (pixels << 3)) >> 3);  // 24 bits total

  000b0	128e3004	 addne       r3, lr, #4
  000b4	11a03183	 movne       r3, r3, lsl #3
  000b8	10433182	 subne       r3, r3, r2, lsl #3
  000bc	11a0e1a3	 movne       lr, r3, lsr #3

; 939  :         }
; 940  :         pXllpOverlay->ch2_size = DMALength;

  000c0	e580e034	 str         lr, [r0, #0x34]

; 941  :         pXllpOverlay->ch3_size = DMALength;

  000c4	e580e038	 str         lr, [r0, #0x38]

; 942  :         pXllpOverlay->ch4_size = DMALength;

  000c8	e580e03c	 str         lr, [r0, #0x3C]

; 977  :     }
; 978  : 
; 979  : }

  000cc	e8bd4010	 ldmia       sp!, {r4, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN10@XllpLCD_DM|

; 943  :     }
; 944  :     else if (pXllpOverlay->Format == FORMAT_PLANAR_422)

  000d4	e3520003	 cmp         r2, #3
  000d8	1a00000d	 bne         |$LN7@XllpLCD_DM|

; 945  :     {                                                                           
; 946  :         DMALength = pixels;
; 947  :         if ((DMALength % 4) > 0)

  000dc	e21e1003	 ands        r1, lr, #3

; 948  :         {
; 949  :             DMALength = (((32 - ((pixels << 3) % 32)) + (pixels << 3)) >> 3);   // 16 bits total

  000e0	128e3004	 addne       r3, lr, #4
  000e4	11a03183	 movne       r3, r3, lsl #3
  000e8	10433181	 subne       r3, r3, r1, lsl #3
  000ec	e1a0200e	 mov         r2, lr
  000f0	11a021a3	 movne       r2, r3, lsr #3

; 950  :         }
; 951  :         pXllpOverlay->ch2_size = DMALength;
; 952  : 
; 953  :         DMALength = pixels >> 1;
; 954  :         if (((pixels << 2) % 32) > 0)

  000f4	e20e3007	 and         r3, lr, #7
  000f8	e5802034	 str         r2, [r0, #0x34]
  000fc	e1b02103	 movs        r2, r3, lsl #2
  00100	e1a030ae	 mov         r3, lr, lsr #1
  00104	0a000012	 beq         |$LN1@XllpLCD_DM|

; 955  :         {
; 956  :             DMALength = (((32 - ((pixels << 2) % 32)) + (pixels << 2)) >> 3);

  00108	e28e3008	 add         r3, lr, #8
  0010c	e0623103	 rsb         r3, r2, r3, lsl #2

; 957  :         }
; 958  :         pXllpOverlay->ch3_size = DMALength;
; 959  :         pXllpOverlay->ch4_size = DMALength;

  00110	ea00000e	 b           |$LN28@XllpLCD_DM|
  00114		 |$LN7@XllpLCD_DM|

; 960  :     }
; 961  :     else if (pXllpOverlay->Format == FORMAT_PLANAR_420)

  00114	e3520004	 cmp         r2, #4
  00118	1a00000f	 bne         |$LN3@XllpLCD_DM|

; 962  :     {
; 963  :         DMALength = pixels;
; 964  :         if ((DMALength % 4) > 0)

  0011c	e21e1003	 ands        r1, lr, #3

; 965  :         {
; 966  :             DMALength = (((32 - ((pixels << 3) % 32)) + (pixels << 3)) >> 3);   // 12 bits total

  00120	128e3004	 addne       r3, lr, #4
  00124	11a03183	 movne       r3, r3, lsl #3
  00128	10433181	 subne       r3, r3, r1, lsl #3
  0012c	e1a0200e	 mov         r2, lr
  00130	11a021a3	 movne       r2, r3, lsr #3

; 967  :         }
; 968  :         pXllpOverlay->ch2_size = DMALength;
; 969  : 
; 970  :         DMALength = pixels >> 2;
; 971  :         if (((pixels << 1) % 32) > 0)

  00134	e20e300f	 and         r3, lr, #0xF
  00138	e5802034	 str         r2, [r0, #0x34]
  0013c	e1b02083	 movs        r2, r3, lsl #1
  00140	e1a0312e	 mov         r3, lr, lsr #2
  00144	0a000002	 beq         |$LN1@XllpLCD_DM|

; 972  :         {
; 973  :             DMALength = (((32 - ((pixels << 1) % 32)) + (pixels << 1)) >> 3);

  00148	e28e3010	 add         r3, lr, #0x10
  0014c	e0623083	 rsb         r3, r2, r3, lsl #1
  00150		 |$LN28@XllpLCD_DM|
  00150	e1a031a3	 mov         r3, r3, lsr #3
  00154		 |$LN1@XllpLCD_DM|

; 974  :         }
; 975  :         pXllpOverlay->ch3_size = DMALength;
; 976  :         pXllpOverlay->ch4_size = DMALength;

  00154	e580303c	 str         r3, [r0, #0x3C]
  00158	e5803038	 str         r3, [r0, #0x38]
  0015c		 |$LN3@XllpLCD_DM|

; 977  :     }
; 978  : 
; 979  : }

  0015c	e8bd4010	 ldmia       sp!, {r4, lr}
  00160	e12fff1e	 bx          lr
  00164		 |$M1430|

			 ENDP  ; |XllpLCD_DMALength|

	EXPORT	|XllpLCDInit|

  00000			 AREA	 |.pdata|, PDATA
|$T1452| DCD	|$LN10@XllpLCDIni|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCDInit| PROC

; 70   : {

  00000		 |$LN10@XllpLCDIni|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M1449|
  00004	e1a04000	 mov         r4, r0

; 71   :     XLLP_STATUS_T status = 0;
; 72   : 
; 73   :     // Initialize the GPIO registers for proper LCD Controller operation
; 74   :     LCDSetupGPIOs(pXllpLCD);

  00008	eb000000	 bl          LCDSetupGPIOs

; 75   : 
; 76   :     // Initialize the LCD Controller and frame descriptors
; 77   :     LCDInitController(pXllpLCD);

  0000c	e1a00004	 mov         r0, r4
  00010	eb000000	 bl          LCDInitController

; 78   : 
; 79   :     // Clear LCD Controller status register
; 80   :     LCDClearStatusReg(pXllpLCD);

  00014	e5941008	 ldr         r1, [r4, #8]
  00018	e59f2038	 ldr         r2, [pc, #0x38]
  0001c	e3a03c1f	 mov         r3, #0x1F, 24
  00020	e38330ff	 orr         r3, r3, #0xFF
  00024	e5813038	 str         r3, [r1, #0x38]
  00028	e5812034	 str         r2, [r1, #0x34]

; 81   : 
; 82   :     // Enable the LCD controller
; 83   :     LCDEnableController(pXllpLCD);

  0002c	e5942008	 ldr         r2, [r4, #8]
  00030	e5923000	 ldr         r3, [r2]
  00034	e3833001	 orr         r3, r3, #1
  00038	e5823000	 str         r3, [r2]

; 84   : 
; 85   :     // If required, load the default palette into palette ram
; 86   :     // and feed this to the LCD controller.
; 87   :     if(pXllpLCD->BPP < BPP_16)

  0003c	e5943028	 ldr         r3, [r4, #0x28]
  00040	e3530010	 cmp         r3, #0x10

; 88   :     {
; 89   :         XllpLCDLoadPalette(pXllpLCD);

  00044	31a00004	 movcc       r0, r4
  00048	3b000000	 blcc        XllpLCDLoadPalette

; 90   :     }
; 91   : 
; 92   :     return status;

  0004c	e3a00000	 mov         r0, #0

; 93   : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN11@XllpLCDIni|
  00058		 |$LN12@XllpLCDIni|
  00058	3e3f3f3f	 DCD         0x3e3f3f3f
  0005c		 |$M1450|

			 ENDP  ; |XllpLCDInit|

	EXPORT	|XllpLCDResume|

  00000			 AREA	 |.pdata|, PDATA
|$T1462| DCD	|$LN5@XllpLCDRes|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCDResume| PROC

; 171  : {

  00000		 |$LN5@XllpLCDRes|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1459|

; 172  :     XllpLCDInit(pXllpLCD);

  00004	eb000000	 bl          XllpLCDInit

; 173  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M1460|

			 ENDP  ; |XllpLCDResume|

	EXPORT	|XllpLCD_Overlay2_Enable|

  00000			 AREA	 |.pdata|, PDATA
|$T1477| DCD	|$LN8@XllpLCD_Ov|
	DCD	0x40006401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCD_Overlay2_Enable| PROC

; 798  : {

  00000		 |$LN8@XllpLCD_Ov|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M1474|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 799  :     XLLP_STATUS_T status = 0;
; 800  :     
; 801  :     volatile LCDRegs *p_LCDRegs;
; 802  : 
; 803  :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC; 
; 804  : 
; 805  :     // Set the physical address of the frame descriptor
; 806  :     pXllpLCD->frameDescriptorCh2_YCbCr_Y->FDADR =  LCD_FDADR(pXllpLCD->_DMA_CHANNEL_2_Y_FRAME_DESCRIPTOR_BASE_PHYSICAL);

  0000c	e595305c	 ldr         r3, [r5, #0x5C]
  00010	e595207c	 ldr         r2, [r5, #0x7C]
  00014	e5956008	 ldr         r6, [r5, #8]
  00018	e3c3300f	 bic         r3, r3, #0xF
  0001c	e5823000	 str         r3, [r2]

; 807  :     pXllpLCD->frameDescriptorCh3_YCbCr_Cb->FDADR = LCD_FDADR(pXllpLCD->_DMA_CHANNEL_3_Cb_FRAME_DESCRIPTOR_BASE_PHYSICAL);

  00020	e5953060	 ldr         r3, [r5, #0x60]
  00024	e5952080	 ldr         r2, [r5, #0x80]

; 808  :     pXllpLCD->frameDescriptorCh4_YCbCr_Cr->FDADR = LCD_FDADR(pXllpLCD->_DMA_CHANNEL_4_Cr_FRAME_DESCRIPTOR_BASE_PHYSICAL);
; 809  : 
; 810  :     // Set the physical address of the frame buffer
; 811  :     pXllpLCD->frameDescriptorCh2_YCbCr_Y->FSADR =  LCD_FSADR(pXllpLCD->_OVERLAY2_Y_CHANNEL_BASE_PHYSICAL);
; 812  :     pXllpLCD->frameDescriptorCh3_YCbCr_Cb->FSADR = LCD_FSADR(pXllpLCD->_OVERLAY2_Cb_CHANNEL_BASE_PHYSICAL);
; 813  :     pXllpLCD->frameDescriptorCh4_YCbCr_Cr->FSADR = LCD_FSADR(pXllpLCD->_OVERLAY2_Cr_CHANNEL_BASE_PHYSICAL);
; 814  :     
; 815  :     // Clear the frame ID
; 816  :     pXllpLCD->frameDescriptorCh2_YCbCr_Y->FIDR  = LCD_FIDR(0);

  00028	e3a01000	 mov         r1, #0
  0002c	e3c3300f	 bic         r3, r3, #0xF
  00030	e5823000	 str         r3, [r2]
  00034	e5953064	 ldr         r3, [r5, #0x64]
  00038	e5952084	 ldr         r2, [r5, #0x84]
  0003c	e3c3300f	 bic         r3, r3, #0xF
  00040	e5823000	 str         r3, [r2]
  00044	e5953040	 ldr         r3, [r5, #0x40]
  00048	e595207c	 ldr         r2, [r5, #0x7C]

; 817  :     pXllpLCD->frameDescriptorCh3_YCbCr_Cb->FIDR  = LCD_FIDR(0);
; 818  :     pXllpLCD->frameDescriptorCh4_YCbCr_Cr->FIDR  = LCD_FIDR(0);
; 819  : 
; 820  :     // Set the DMA transfer size (calculated already by XllpLCD_DMALength())
; 821  :     pXllpLCD->frameDescriptorCh2_YCbCr_Y->LDCMD = LCD_Len(pXllpOverlay->ch2_size);
; 822  :     pXllpLCD->frameDescriptorCh3_YCbCr_Cb->LDCMD = LCD_Len(pXllpOverlay->ch3_size);
; 823  :     pXllpLCD->frameDescriptorCh4_YCbCr_Cr->LDCMD = LCD_Len(pXllpOverlay->ch4_size);
; 824  : 
; 825  :     // Store the physical address of each frame descriptor in the frame descriptor
; 826  :     pXllpLCD->frameDescriptorCh2_YCbCr_Y->PHYSADDR = pXllpLCD->frameDescriptorCh2_YCbCr_Y->FDADR;
; 827  :     pXllpLCD->frameDescriptorCh3_YCbCr_Cb->PHYSADDR = pXllpLCD->frameDescriptorCh3_YCbCr_Cb->FDADR;
; 828  :     pXllpLCD->frameDescriptorCh4_YCbCr_Cr->PHYSADDR = pXllpLCD->frameDescriptorCh4_YCbCr_Cr->FDADR;
; 829  :     
; 830  :     // FBRx is cleared and is not used.
; 831  :     p_LCDRegs->FBR2 = 0;

  0004c	e3c33007	 bic         r3, r3, #7
  00050	e5823004	 str         r3, [r2, #4]
  00054	e5953044	 ldr         r3, [r5, #0x44]
  00058	e5952080	 ldr         r2, [r5, #0x80]

; 832  :     p_LCDRegs->FBR3 = 0;

  0005c	e3c33007	 bic         r3, r3, #7
  00060	e5823004	 str         r3, [r2, #4]
  00064	e5953048	 ldr         r3, [r5, #0x48]
  00068	e5952084	 ldr         r2, [r5, #0x84]

; 833  :     p_LCDRegs->FBR4 = 0;

  0006c	e3c33007	 bic         r3, r3, #7
  00070	e5823004	 str         r3, [r2, #4]
  00074	e595307c	 ldr         r3, [r5, #0x7C]

; 834  : 
; 835  :     // Load the contents of FDADRx with the physical address of this frame descriptor
; 836  :     p_LCDRegs->FDADR2 = LCD_FDADR(pXllpLCD->frameDescriptorCh2_YCbCr_Y->FDADR);
; 837  :     p_LCDRegs->FDADR3 = LCD_FDADR(pXllpLCD->frameDescriptorCh3_YCbCr_Cb->FDADR);

  00078	e5831008	 str         r1, [r3, #8]
  0007c	e5953080	 ldr         r3, [r5, #0x80]
  00080	e5831008	 str         r1, [r3, #8]
  00084	e5953084	 ldr         r3, [r5, #0x84]
  00088	e5831008	 str         r1, [r3, #8]
  0008c	e595207c	 ldr         r2, [r5, #0x7C]
  00090	e5943034	 ldr         r3, [r4, #0x34]
  00094	e582300c	 str         r3, [r2, #0xC]
  00098	e5952080	 ldr         r2, [r5, #0x80]
  0009c	e5943038	 ldr         r3, [r4, #0x38]
  000a0	e582300c	 str         r3, [r2, #0xC]
  000a4	e5952084	 ldr         r2, [r5, #0x84]
  000a8	e594303c	 ldr         r3, [r4, #0x3C]
  000ac	e582300c	 str         r3, [r2, #0xC]
  000b0	e595207c	 ldr         r2, [r5, #0x7C]
  000b4	e5923000	 ldr         r3, [r2]
  000b8	e5823010	 str         r3, [r2, #0x10]
  000bc	e5952080	 ldr         r2, [r5, #0x80]
  000c0	e5923000	 ldr         r3, [r2]
  000c4	e5823010	 str         r3, [r2, #0x10]
  000c8	e5952084	 ldr         r2, [r5, #0x84]
  000cc	e5923000	 ldr         r3, [r2]
  000d0	e5823010	 str         r3, [r2, #0x10]
  000d4	e5861028	 str         r1, [r6, #0x28]
  000d8	e586102c	 str         r1, [r6, #0x2C]
  000dc	e5861030	 str         r1, [r6, #0x30]
  000e0	e595307c	 ldr         r3, [r5, #0x7C]

; 838  :     p_LCDRegs->FDADR4 = LCD_FDADR(pXllpLCD->frameDescriptorCh4_YCbCr_Cr->FDADR);
; 839  :     
; 840  : 
; 841  :     // Reinit the LCD controller so that the pixel data format can be updated for use with overlays
; 842  :     XllpLCDSuspend(pXllpLCD, Suspend_Graceful);

  000e4	e3a01000	 mov         r1, #0
  000e8	e5933000	 ldr         r3, [r3]
  000ec	e3c3300f	 bic         r3, r3, #0xF
  000f0	e5863220	 str         r3, [r6, #0x220]
  000f4	e5953080	 ldr         r3, [r5, #0x80]
  000f8	e5933000	 ldr         r3, [r3]
  000fc	e3c3300f	 bic         r3, r3, #0xF
  00100	e5863230	 str         r3, [r6, #0x230]
  00104	e5953084	 ldr         r3, [r5, #0x84]
  00108	e5933000	 ldr         r3, [r3]
  0010c	e3c3300f	 bic         r3, r3, #0xF
  00110	e5863240	 str         r3, [r6, #0x240]
  00114	eb000000	 bl          XllpLCDSuspend

; 843  : 
; 844  :     pXllpOverlay->TmpBPP = pXllpLCD->BPP;
; 845  :     if (pXllpOverlay->DegradeBaseFrame)

  00118	e5942014	 ldr         r2, [r4, #0x14]
  0011c	e5953028	 ldr         r3, [r5, #0x28]
  00120	e3520000	 cmp         r2, #0
  00124	e584302c	 str         r3, [r4, #0x2C]

; 846  :     {
; 847  :         pXllpLCD->BPP = BPP_1;

  00128	13a03001	 movne       r3, #1
  0012c	15853028	 strne       r3, [r5, #0x28]

; 848  :     }
; 849  :     
; 850  :     pXllpLCD->PixelDataFormat = PDFOR_11;

  00130	e3a03003	 mov         r3, #3
  00134	e585302c	 str         r3, [r5, #0x2C]

; 851  : 
; 852  :     // Configure the overlay registers and enable the overlay
; 853  :     p_LCDRegs->OVL2C2 = (LCD_FOR(pXllpOverlay->Format) | LCD_O2YPOS(pXllpOverlay->Y_Position) | LCD_O2XPOS(pXllpOverlay->X_Position));

  00138	e5941010	 ldr         r1, [r4, #0x10]
  0013c	e594300c	 ldr         r3, [r4, #0xC]
  00140	e5942008	 ldr         r2, [r4, #8]
  00144	e1833501	 orr         r3, r3, r1, lsl #10
  00148	e1823503	 orr         r3, r2, r3, lsl #10
  0014c	e5863080	 str         r3, [r6, #0x80]

; 854  :     p_LCDRegs->OVL2C1 = (LCD_O2EN | LCD_BPP2(pXllpOverlay->OverlayBPP) | LCD_LPO2(pXllpOverlay->OverlayHeight-1) | LCD_PPL2(pXllpOverlay->OverlayWidth-1));

  00150	e5942028	 ldr         r2, [r4, #0x28]
  00154	e5941000	 ldr         r1, [r4]
  00158	e3e03c07	 mvn         r3, #7, 24
  0015c	e22330ff	 eor         r3, r3, #0xFF
  00160	e5940004	 ldr         r0, [r4, #4]
  00164	e1822003	 orr         r2, r2, r3
  00168	e2413001	 sub         r3, r1, #1
  0016c	e1832502	 orr         r2, r3, r2, lsl #10
  00170	e2403001	 sub         r3, r0, #1
  00174	e1833502	 orr         r3, r3, r2, lsl #10

; 855  : 
; 856  :     XllpLCDResume(pXllpLCD);

  00178	e1a00005	 mov         r0, r5
  0017c	e5863070	 str         r3, [r6, #0x70]
  00180	eb000000	 bl          XllpLCDInit

; 857  : 
; 858  :     return status;

  00184	e3a00000	 mov         r0, #0

; 859  : }

  00188	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0018c	e12fff1e	 bx          lr
  00190		 |$M1475|

			 ENDP  ; |XllpLCD_Overlay2_Enable|

	EXPORT	|XllpLCD_Overlay2_Disable|

  00000			 AREA	 |.pdata|, PDATA
|$T1490| DCD	|$LN7@XllpLCD_Ov@2|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpLCD_Overlay2_Disable| PROC

; 862  : {

  00000		 |$LN7@XllpLCD_Ov@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M1487|
  00004	e1a04001	 mov         r4, r1
  00008	e1a06000	 mov         r6, r0

; 863  :     volatile LCDRegs *p_LCDRegs;
; 864  :     
; 865  :     p_LCDRegs = (LCDRegs *) pXllpLCD->LCDC; 
; 866  : 
; 867  :     // Reinit the LCD controller so that the pixel data format can be updated for use without overlays
; 868  :     XllpLCDSuspend(pXllpLCD, Suspend_Graceful);

  0000c	e5965008	 ldr         r5, [r6, #8]
  00010	e3a01000	 mov         r1, #0
  00014	eb000000	 bl          XllpLCDSuspend

; 869  : 
; 870  :     pXllpLCD->PixelDataFormat = PDFOR_00;

  00018	e3a03000	 mov         r3, #0
  0001c	e586302c	 str         r3, [r6, #0x2C]

; 871  : 
; 872  :     // Undo the degraded base frame - always.
; 873  :     pXllpLCD->BPP = pXllpOverlay->TmpBPP;

  00020	e594302c	 ldr         r3, [r4, #0x2C]

; 874  : 
; 875  :     p_LCDRegs->OVL2C1 &= 0x00FFFFFF; // Clear the enable bit, and clear the reserved bits 30:24.
; 876  :     XllpLCDResume(pXllpLCD);

  00024	e1a00006	 mov         r0, r6
  00028	e5863028	 str         r3, [r6, #0x28]
  0002c	e5953070	 ldr         r3, [r5, #0x70]
  00030	e3c334ff	 bic         r3, r3, #0xFF, 8
  00034	e5853070	 str         r3, [r5, #0x70]
  00038	eb000000	 bl          XllpLCDInit

; 877  : }

  0003c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M1488|

			 ENDP  ; |XllpLCD_Overlay2_Disable|

	END
