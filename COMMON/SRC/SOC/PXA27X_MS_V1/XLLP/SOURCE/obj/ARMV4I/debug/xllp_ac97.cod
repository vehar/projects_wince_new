; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_ac97.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XllpAc97ColdReset|
	EXPORT	|XllpAc97Init|
	IMPORT	|XllpGpioSetOutput0|
	IMPORT	|XllpGpioSetDirectionOut|
	IMPORT	|XllpGpioSetOutputState1|
	IMPORT	|XllpGpioSetAlternateFn|
	IMPORT	|XllpGpioSetDirectionIn|

  00000			 AREA	 |.pdata|, PDATA
|$T1296| DCD	|$LN6@XllpAc97In|
	DCD	0x40007104
; Function compile flags: /Odtp
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_ac97.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97Init| PROC

; 85   : {

  00000		 |$LN6@XllpAc97In|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd048	 sub         sp, sp, #0x48
  00010		 |$M1293|

; 86   :     XLLP_AC97_ERROR_T	status ;
; 87   :     P_XLLP_GPIO_T		pGPIO = pAc97ctxt->pGpioReg;

  00010	e59d3050	 ldr         r3, [sp, #0x50]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d3004	 str         r3, [sp, #4]

; 88   : 	P_XLLP_INTC_T		pINTC = pAc97ctxt->pIntcReg;

  0001c	e59d3050	 ldr         r3, [sp, #0x50]
  00020	e2833010	 add         r3, r3, #0x10
  00024	e5933000	 ldr         r3, [r3]
  00028	e58d3000	 str         r3, [sp]

; 89   : 	P_XLLP_CLKMGR_T		pCLKMGR = pAc97ctxt->pClockReg;

  0002c	e59d3050	 ldr         r3, [sp, #0x50]
  00030	e2833004	 add         r3, r3, #4
  00034	e5933000	 ldr         r3, [r3]
  00038	e58d3020	 str         r3, [sp, #0x20]

; 90   :     XLLP_UINT32_T		pins[6], fn[6];
; 91   : 	
; 92   :     // Set bitclk, sdata_in_0
; 93   : 	pins[0] = 2;

  0003c	e3a03002	 mov         r3, #2
  00040	e58d3024	 str         r3, [sp, #0x24]

; 94   :     pins[1] = XLLP_GPIO_AC97BITCLK;

  00044	e3a0301c	 mov         r3, #0x1C
  00048	e58d3028	 str         r3, [sp, #0x28]

; 95   :     pins[2] = XLLP_GPIO_AC97_SDATA_IN_0;

  0004c	e3a0301d	 mov         r3, #0x1D
  00050	e58d302c	 str         r3, [sp, #0x2C]

; 96   :     fn[0] = 2;

  00054	e3a03002	 mov         r3, #2
  00058	e58d3008	 str         r3, [sp, #8]

; 97   :     fn[1] = XLLP_GPIO_ALT_FN_1;

  0005c	e3a03001	 mov         r3, #1
  00060	e58d300c	 str         r3, [sp, #0xC]

; 98   :     fn[2] = XLLP_GPIO_ALT_FN_1;

  00064	e3a03001	 mov         r3, #1
  00068	e58d3010	 str         r3, [sp, #0x10]

; 99   :     if (XLLP_TRUE == pAc97ctxt->useSecondaryCodec)

  0006c	e59d3050	 ldr         r3, [sp, #0x50]
  00070	e2833018	 add         r3, r3, #0x18
  00074	e5933000	 ldr         r3, [r3]
  00078	e3530001	 cmp         r3, #1
  0007c	1a000007	 bne         |$LN1@XllpAc97In|

; 100  :     {
; 101  : 		pins[0] = 3;

  00080	e3a03003	 mov         r3, #3
  00084	e58d3024	 str         r3, [sp, #0x24]

; 102  : 		pins[3] = XLLP_GPIO_KP_MKIN5;      // use this pin as AC97_SDATA_IN_1 

  00088	e3a03063	 mov         r3, #0x63
  0008c	e58d3030	 str         r3, [sp, #0x30]

; 103  : 		fn[0] = 3;

  00090	e3a03003	 mov         r3, #3
  00094	e58d3008	 str         r3, [sp, #8]

; 104  : 		fn[3] = XLLP_GPIO_ALT_FN_2;

  00098	e3a03002	 mov         r3, #2
  0009c	e58d3014	 str         r3, [sp, #0x14]
  000a0		 |$LN1@XllpAc97In|

; 105  : 	}
; 106  : 	XllpGpioSetDirectionIn(pGPIO, pins);

  000a0	e28d1024	 add         r1, sp, #0x24
  000a4	e59d0004	 ldr         r0, [sp, #4]
  000a8	eb000000	 bl          XllpGpioSetDirectionIn

; 107  :     XllpGpioSetAlternateFn(pGPIO, pins, fn);

  000ac	e28d2008	 add         r2, sp, #8
  000b0	e28d1024	 add         r1, sp, #0x24
  000b4	e59d0004	 ldr         r0, [sp, #4]
  000b8	eb000000	 bl          XllpGpioSetAlternateFn

; 108  :     
; 109  :     // Set sdata_out, sync, sysclock
; 110  :     pins[0] = 2;

  000bc	e3a03002	 mov         r3, #2
  000c0	e58d3024	 str         r3, [sp, #0x24]

; 111  :     pins[1] = XLLP_GPIO_AC97_SDATA_OUT;

  000c4	e3a0301e	 mov         r3, #0x1E
  000c8	e58d3028	 str         r3, [sp, #0x28]

; 112  :     pins[2] = XLLP_GPIO_AC97_SYNC;

  000cc	e3a0301f	 mov         r3, #0x1F
  000d0	e58d302c	 str         r3, [sp, #0x2C]

; 113  : //    pins[3] = XLLP_GPIO_KP_MKIN4;     // use this pin as AC97_SYSCLK 
; 114  :     fn[0] = 2;

  000d4	e3a03002	 mov         r3, #2
  000d8	e58d3008	 str         r3, [sp, #8]

; 115  :     fn[1] = XLLP_GPIO_ALT_FN_2;

  000dc	e3a03002	 mov         r3, #2
  000e0	e58d300c	 str         r3, [sp, #0xC]

; 116  :     fn[2] = XLLP_GPIO_ALT_FN_2;

  000e4	e3a03002	 mov         r3, #2
  000e8	e58d3010	 str         r3, [sp, #0x10]

; 117  : //    fn[3] = XLLP_GPIO_ALT_FN_1;
; 118  :     XllpGpioSetOutputState1(pGPIO, pins);

  000ec	e28d1024	 add         r1, sp, #0x24
  000f0	e59d0004	 ldr         r0, [sp, #4]
  000f4	eb000000	 bl          XllpGpioSetOutputState1

; 119  :     XllpGpioSetDirectionOut(pGPIO, pins);

  000f8	e28d1024	 add         r1, sp, #0x24
  000fc	e59d0004	 ldr         r0, [sp, #4]
  00100	eb000000	 bl          XllpGpioSetDirectionOut

; 120  :     XllpGpioSetAlternateFn(pGPIO, pins, fn);

  00104	e28d2008	 add         r2, sp, #8
  00108	e28d1024	 add         r1, sp, #0x24
  0010c	e59d0004	 ldr         r0, [sp, #4]
  00110	eb000000	 bl          XllpGpioSetAlternateFn

; 121  :     
; 122  :     // Set sdata_reset_n
; 123  :     pins[0] = 1;

  00114	e3a03001	 mov         r3, #1
  00118	e58d3024	 str         r3, [sp, #0x24]

; 124  :     pins[1] = XLLP_GPIO_AC97_RESET_n;

  0011c	e3a03071	 mov         r3, #0x71
  00120	e58d3028	 str         r3, [sp, #0x28]

; 125  :     fn[0] = 1;

  00124	e3a03001	 mov         r3, #1
  00128	e58d3008	 str         r3, [sp, #8]

; 126  :     fn[1] = XLLP_GPIO_ALT_FN_0;

  0012c	e3a03000	 mov         r3, #0
  00130	e58d300c	 str         r3, [sp, #0xC]

; 127  :     XllpGpioSetOutput0(pGPIO, pins);

  00134	e28d1024	 add         r1, sp, #0x24
  00138	e59d0004	 ldr         r0, [sp, #4]
  0013c	eb000000	 bl          XllpGpioSetOutput0

; 128  :     XllpGpioSetDirectionOut(pGPIO, pins);

  00140	e28d1024	 add         r1, sp, #0x24
  00144	e59d0004	 ldr         r0, [sp, #4]
  00148	eb000000	 bl          XllpGpioSetDirectionOut

; 129  :     XllpGpioSetAlternateFn(pGPIO, pins, fn);

  0014c	e28d2008	 add         r2, sp, #8
  00150	e28d1024	 add         r1, sp, #0x24
  00154	e59d0004	 ldr         r0, [sp, #4]
  00158	eb000000	 bl          XllpGpioSetAlternateFn

; 130  :     
; 131  :     // Disable of ACUNIT interrupt.
; 132  :     pINTC->icmr &= ~XLLP_INTC_AC97;

  0015c	e59d3000	 ldr         r3, [sp]
  00160	e2833004	 add         r3, r3, #4
  00164	e5932000	 ldr         r2, [r3]
  00168	e3e03901	 mvn         r3, #1, 18
  0016c	e0022003	 and         r2, r2, r3
  00170	e59d3000	 ldr         r3, [sp]
  00174	e2833004	 add         r3, r3, #4
  00178	e5832000	 str         r2, [r3]

; 133  : 	
; 134  :     // Enable clocking of AC '97 controller device in processor
; 135  :     pCLKMGR->cken |= XLLP_CLKEN_AC97;

  0017c	e59d3020	 ldr         r3, [sp, #0x20]
  00180	e2833004	 add         r3, r3, #4
  00184	e5933000	 ldr         r3, [r3]
  00188	e3832004	 orr         r2, r3, #4
  0018c	e59d3020	 ldr         r3, [sp, #0x20]
  00190	e2833004	 add         r3, r3, #4
  00194	e5832000	 str         r2, [r3]

; 136  : 	
; 137  :     // Perform the cold reset.
; 138  :     // Also enables the codec(s), control unit and the control unit's FIFOs
; 139  :     status = XllpAc97ColdReset(pAc97ctxt);

  00198	e59d0050	 ldr         r0, [sp, #0x50]
  0019c	eb000000	 bl          XllpAc97ColdReset
  001a0	e58d0044	 str         r0, [sp, #0x44]
  001a4	e59d3044	 ldr         r3, [sp, #0x44]
  001a8	e58d303c	 str         r3, [sp, #0x3C]

; 140  :     
; 141  :     return (status);

  001ac	e59d303c	 ldr         r3, [sp, #0x3C]
  001b0	e58d3040	 str         r3, [sp, #0x40]

; 142  : 
; 143  : } // End XllpAc97Init ()

  001b4	e59d0040	 ldr         r0, [sp, #0x40]
  001b8	e28dd048	 add         sp, sp, #0x48
  001bc	e89d6000	 ldmia       sp, {sp, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$M1294|

			 ENDP  ; |XllpAc97Init|

	EXPORT	|XllpAc97ShutdownAclink|
	EXPORT	|XllpAc97DeInit|
	IMPORT	|XllpGpioClearAlternateFn|

  00008			 AREA	 |.pdata|, PDATA
|$T1302| DCD	|$LN7@XllpAc97De|
	DCD	0x40004f04
; Function compile flags: /Odtp

  001c4			 AREA	 |.text|, CODE, ARM

  001c4		 |XllpAc97DeInit| PROC

; 170  : {

  001c4		 |$LN7@XllpAc97De|
  001c4	e1a0c00d	 mov         r12, sp
  001c8	e92d0001	 stmdb       sp!, {r0}
  001cc	e92d5000	 stmdb       sp!, {r12, lr}
  001d0	e24dd038	 sub         sp, sp, #0x38
  001d4		 |$M1299|

; 171  :     XLLP_AC97_ERROR_T	status ;
; 172  :     P_XLLP_GPIO_T		pGPIO = pAc97ctxt->pGpioReg;

  001d4	e59d3040	 ldr         r3, [sp, #0x40]
  001d8	e5933000	 ldr         r3, [r3]
  001dc	e58d3004	 str         r3, [sp, #4]

; 173  : 	P_XLLP_INTC_T		pINTC = pAc97ctxt->pIntcReg;

  001e0	e59d3040	 ldr         r3, [sp, #0x40]
  001e4	e2833010	 add         r3, r3, #0x10
  001e8	e5933000	 ldr         r3, [r3]
  001ec	e58d3000	 str         r3, [sp]

; 174  : 	P_XLLP_CLKMGR_T		pCLKMGR = pAc97ctxt->pClockReg;

  001f0	e59d3040	 ldr         r3, [sp, #0x40]
  001f4	e2833004	 add         r3, r3, #4
  001f8	e5933000	 ldr         r3, [r3]
  001fc	e58d3008	 str         r3, [sp, #8]

; 175  :     XLLP_UINT32_T		pins[8];
; 176  : 	
; 177  :     status = XllpAc97ShutdownAclink(pAc97ctxt->pAc97Reg, pAc97ctxt->pOstRegs);

  00200	e59d3040	 ldr         r3, [sp, #0x40]
  00204	e283300c	 add         r3, r3, #0xC
  00208	e5931000	 ldr         r1, [r3]
  0020c	e59d3040	 ldr         r3, [sp, #0x40]
  00210	e2833008	 add         r3, r3, #8
  00214	e5930000	 ldr         r0, [r3]
  00218	eb000000	 bl          XllpAc97ShutdownAclink
  0021c	e58d0034	 str         r0, [sp, #0x34]
  00220	e59d3034	 ldr         r3, [sp, #0x34]
  00224	e58d302c	 str         r3, [sp, #0x2C]

; 178  : 
; 179  : 	if (XLLP_AC97_NO_ERROR == status)

  00228	e59d302c	 ldr         r3, [sp, #0x2C]
  0022c	e3530000	 cmp         r3, #0
  00230	1a00002c	 bne         |$LN2@XllpAc97De|

; 180  : 	{
; 181  :         // Disable of ACUNIT interrupt.
; 182  : 	    pINTC->icmr &= ~XLLP_INTC_AC97;

  00234	e59d3000	 ldr         r3, [sp]
  00238	e2833004	 add         r3, r3, #4
  0023c	e5932000	 ldr         r2, [r3]
  00240	e3e03901	 mvn         r3, #1, 18
  00244	e0022003	 and         r2, r2, r3
  00248	e59d3000	 ldr         r3, [sp]
  0024c	e2833004	 add         r3, r3, #4
  00250	e5832000	 str         r2, [r3]

; 183  : 
; 184  : 	    // Disable clocking of AC '97 controller device in processor
; 185  : 	    pCLKMGR->cken &= ~XLLP_CLKEN_AC97;

  00254	e59d3008	 ldr         r3, [sp, #8]
  00258	e2833004	 add         r3, r3, #4
  0025c	e5932000	 ldr         r2, [r3]
  00260	e3e03004	 mvn         r3, #4
  00264	e0022003	 and         r2, r2, r3
  00268	e59d3008	 ldr         r3, [sp, #8]
  0026c	e2833004	 add         r3, r3, #4
  00270	e5832000	 str         r2, [r3]

; 186  : 
; 187  : 		// Set all pins to default general input configuration.
; 188  :     	pins[0] = 6;

  00274	e3a03006	 mov         r3, #6
  00278	e58d300c	 str         r3, [sp, #0xC]

; 189  :         pins[1] = XLLP_GPIO_AC97BITCLK;

  0027c	e3a0301c	 mov         r3, #0x1C
  00280	e58d3010	 str         r3, [sp, #0x10]

; 190  :         pins[2] = XLLP_GPIO_AC97_SDATA_IN_0;

  00284	e3a0301d	 mov         r3, #0x1D
  00288	e58d3014	 str         r3, [sp, #0x14]

; 191  :         pins[3] = XLLP_GPIO_AC97_SDATA_OUT;

  0028c	e3a0301e	 mov         r3, #0x1E
  00290	e58d3018	 str         r3, [sp, #0x18]

; 192  :         pins[4] = XLLP_GPIO_AC97_SYNC;

  00294	e3a0301f	 mov         r3, #0x1F
  00298	e58d301c	 str         r3, [sp, #0x1C]

; 193  :         pins[5] = XLLP_GPIO_KP_MKIN4;     // use this pin as AC97_SYSCLK 

  0029c	e3a03062	 mov         r3, #0x62
  002a0	e58d3020	 str         r3, [sp, #0x20]

; 194  :         pins[6] = XLLP_GPIO_AC97_RESET_n;

  002a4	e3a03071	 mov         r3, #0x71
  002a8	e58d3024	 str         r3, [sp, #0x24]

; 195  : 
; 196  :         if (XLLP_TRUE == pAc97ctxt->useSecondaryCodec)

  002ac	e59d3040	 ldr         r3, [sp, #0x40]
  002b0	e2833018	 add         r3, r3, #0x18
  002b4	e5933000	 ldr         r3, [r3]
  002b8	e3530001	 cmp         r3, #1
  002bc	1a000003	 bne         |$LN1@XllpAc97De|

; 197  :         {
; 198  : 			pins[0] = 7;

  002c0	e3a03007	 mov         r3, #7
  002c4	e58d300c	 str         r3, [sp, #0xC]

; 199  : 			pins[7] = XLLP_GPIO_KP_MKIN5;      // use this pin as AC97_SDATA_IN_1 

  002c8	e3a03063	 mov         r3, #0x63
  002cc	e58d3028	 str         r3, [sp, #0x28]
  002d0		 |$LN1@XllpAc97De|

; 200  : 		}
; 201  : 		XllpGpioSetDirectionIn(pGPIO, pins);

  002d0	e28d100c	 add         r1, sp, #0xC
  002d4	e59d0004	 ldr         r0, [sp, #4]
  002d8	eb000000	 bl          XllpGpioSetDirectionIn

; 202  :         XllpGpioClearAlternateFn(pGPIO, pins);

  002dc	e28d100c	 add         r1, sp, #0xC
  002e0	e59d0004	 ldr         r0, [sp, #4]
  002e4	eb000000	 bl          XllpGpioClearAlternateFn
  002e8		 |$LN2@XllpAc97De|

; 203  : 	}
; 204  :     	
; 205  :     return (status);

  002e8	e59d302c	 ldr         r3, [sp, #0x2C]
  002ec	e58d3030	 str         r3, [sp, #0x30]

; 206  : }

  002f0	e59d0030	 ldr         r0, [sp, #0x30]
  002f4	e28dd038	 add         sp, sp, #0x38
  002f8	e89d6000	 ldmia       sp, {sp, lr}
  002fc	e12fff1e	 bx          lr
  00300		 |$M1300|

			 ENDP  ; |XllpAc97DeInit|

	EXPORT	|XllpAc97GetStatus|

  00010			 AREA	 |.pdata|, PDATA
|$T1311| DCD	|$LN11@XllpAc97Ge|
	DCD	0x40002504
; Function compile flags: /Odtp

  00300			 AREA	 |.text|, CODE, ARM

  00300		 |XllpAc97GetStatus| PROC

; 238  : {

  00300		 |$LN11@XllpAc97Ge|
  00300	e1a0c00d	 mov         r12, sp
  00304	e92d0007	 stmdb       sp!, {r0 - r2}
  00308	e92d5000	 stmdb       sp!, {r12, lr}
  0030c	e24dd008	 sub         sp, sp, #8
  00310		 |$M1308|

; 239  : 	if (XLLP_AC97_CODEC_PRIMARY == codecSel) 

  00310	e59d3018	 ldr         r3, [sp, #0x18]
  00314	e3530000	 cmp         r3, #0
  00318	1a00000d	 bne         |$LN2@XllpAc97Ge|

; 240  : 	{
; 241  : 		pStat->codecReady = (pAc97Reg->GSR & XLLP_AC97_GSR_PCRDY_MSK) ? XLLP_TRUE : XLLP_FALSE;

  0031c	e59d3014	 ldr         r3, [sp, #0x14]
  00320	e283301c	 add         r3, r3, #0x1C
  00324	e5933000	 ldr         r3, [r3]
  00328	e3130c01	 tst         r3, #1, 24
  0032c	0a000002	 beq         |$LN5@XllpAc97Ge|
  00330	e3a03001	 mov         r3, #1
  00334	e58d3000	 str         r3, [sp]
  00338	ea000001	 b           |$LN6@XllpAc97Ge|
  0033c		 |$LN5@XllpAc97Ge|
  0033c	e3a03000	 mov         r3, #0
  00340	e58d3000	 str         r3, [sp]
  00344		 |$LN6@XllpAc97Ge|
  00344	e59d2000	 ldr         r2, [sp]
  00348	e59d3010	 ldr         r3, [sp, #0x10]
  0034c	e5832000	 str         r2, [r3]

; 242  :     }
; 243  : 	else

  00350	ea00000c	 b           |$LN1@XllpAc97Ge|
  00354		 |$LN2@XllpAc97Ge|

; 244  : 	{
; 245  : 	    pStat->codecReady = (pAc97Reg->GSR & XLLP_AC97_GSR_SCRDY_MSK) ? XLLP_TRUE : XLLP_FALSE;

  00354	e59d3014	 ldr         r3, [sp, #0x14]
  00358	e283301c	 add         r3, r3, #0x1C
  0035c	e5933000	 ldr         r3, [r3]
  00360	e3130c02	 tst         r3, #2, 24
  00364	0a000002	 beq         |$LN7@XllpAc97Ge|
  00368	e3a03001	 mov         r3, #1
  0036c	e58d3004	 str         r3, [sp, #4]
  00370	ea000001	 b           |$LN8@XllpAc97Ge|
  00374		 |$LN7@XllpAc97Ge|
  00374	e3a03000	 mov         r3, #0
  00378	e58d3004	 str         r3, [sp, #4]
  0037c		 |$LN8@XllpAc97Ge|
  0037c	e59d2004	 ldr         r2, [sp, #4]
  00380	e59d3010	 ldr         r3, [sp, #0x10]
  00384	e5832000	 str         r2, [r3]
  00388		 |$LN1@XllpAc97Ge|

; 246  : 	}
; 247  : } // Ac97CtrlGetStatus()

  00388	e28dd008	 add         sp, sp, #8
  0038c	e89d6000	 ldmia       sp, {sp, lr}
  00390	e12fff1e	 bx          lr
  00394		 |$M1309|

			 ENDP  ; |XllpAc97GetStatus|

	EXPORT	|XllpAc97Write|
	IMPORT	|XllpOstDelayMicroSeconds|
	IMPORT	|__rt_sdiv|

  00018			 AREA	 |.pdata|, PDATA
|$T1318| DCD	|$LN23@XllpAc97Wr|
	DCD	0x40007404
; Function compile flags: /Odtp

  00394			 AREA	 |.text|, CODE, ARM

  00394		 |XllpAc97Write| PROC

; 291  : {

  00394		 |$LN23@XllpAc97Wr|
  00394	e1a0c00d	 mov         r12, sp
  00398	e92d000f	 stmdb       sp!, {r0 - r3}
  0039c	e92d5000	 stmdb       sp!, {r12, lr}
  003a0	e24dd018	 sub         sp, sp, #0x18
  003a4		 |$M1315|

; 292  :     XLLP_AC97_ERROR_T	status = XLLP_AC97_NO_ERROR;

  003a4	e3a03000	 mov         r3, #0
  003a8	e58d300c	 str         r3, [sp, #0xC]

; 293  :     XLLP_BOOL_T			gotLink;
; 294  :     XLLP_UINT32_T		timeRemaining;
; 295  :     P_XLLP_VUINT32_T	pCodecReg;
; 296  :     
; 297  :     // Point to specified register within area mapped to target codec regs
; 298  : 
; 299  :     // Check for special case register 54h the GPIO status register
; 300  : 
; 301  :     if(offset == XLLP_AC97_CR_E_MDM_GPIO_PIN_STAT)

  003ac	e1dd32b0	 ldrh        r3, [sp, #0x20]
  003b0	e3530054	 cmp         r3, #0x54
  003b4	1a000017	 bne         |$LN18@XllpAc97Wr|

; 302  :     {
; 303  : #ifdef WM9712
; 304  :         
; 305  :         // This is a work around for the WM9712 GPIO status issue.
; 306  :         // Note that the WM9712 can only be used as a primary
; 307  :         // AC97 device.
; 308  :         
; 309  :         XLLP_UINT16_T offsetdata = data << 1;
; 310  :         
; 311  :         pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);
; 312  : 
; 313  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 314  : 
; 315  :         // The data will be sent out on slots 1&2 to register 54h.
; 316  :         *pCodecReg = (XLLP_VUINT32_T)data;
; 317  : 
; 318  :         pCodecReg = &(pAc97Reg->CodecRegsPrimaryMdm[0]);
; 319  : 
; 320  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 321  : 
; 322  :         // The data will be sent out on slot 12.
; 323  :         *pCodecReg = (XLLP_VUINT32_T)offsetdata;
; 324  :        
; 325  : #else
; 326  :         // Select the Primary or Secondary modem IO address space
; 327  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)

  003b8	e59d3034	 ldr         r3, [sp, #0x34]
  003bc	e3530000	 cmp         r3, #0
  003c0	1a000003	 bne         |$LN17@XllpAc97Wr|

; 328  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryMdm[0]);

  003c4	e59d3028	 ldr         r3, [sp, #0x28]
  003c8	e2833b01	 add         r3, r3, #1, 22
  003cc	e58d3004	 str         r3, [sp, #4]

; 329  :         else

  003d0	ea000002	 b           |$LN16@XllpAc97Wr|
  003d4		 |$LN17@XllpAc97Wr|

; 330  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryMdm[0]);

  003d4	e59d3028	 ldr         r3, [sp, #0x28]
  003d8	e2833c05	 add         r3, r3, #5, 24
  003dc	e58d3004	 str         r3, [sp, #4]
  003e0		 |$LN16@XllpAc97Wr|

; 331  : 
; 332  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;

  003e0	e1dd32b0	 ldrh        r3, [sp, #0x20]
  003e4	e1a01003	 mov         r1, r3
  003e8	e3a00002	 mov         r0, #2
  003ec	eb000000	 bl          __rt_sdiv
  003f0	e3a03004	 mov         r3, #4
  003f4	e0020390	 mul         r2, r0, r3
  003f8	e59d3004	 ldr         r3, [sp, #4]
  003fc	e0833002	 add         r3, r3, r2
  00400	e58d3004	 str         r3, [sp, #4]

; 333  : 
; 334  :         // The data will be sent out on slot 12.
; 335  :         *pCodecReg = data;

  00404	e1dd22b4	 ldrh        r2, [sp, #0x24]
  00408	e59d3004	 ldr         r3, [sp, #4]
  0040c	e5832000	 str         r2, [r3]

; 336  :    
; 337  : #endif
; 338  :         goto done;

  00410	ea00004d	 b           |$done$1198|

; 339  :     }
; 340  :     else

  00414	ea000012	 b           |$LN15@XllpAc97Wr|
  00418		 |$LN18@XllpAc97Wr|

; 341  :     {
; 342  :         // Select the Primary or Secondary Audio IO address space
; 343  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)

  00418	e59d3034	 ldr         r3, [sp, #0x34]
  0041c	e3530000	 cmp         r3, #0
  00420	1a000003	 bne         |$LN14@XllpAc97Wr|

; 344  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);

  00424	e59d3028	 ldr         r3, [sp, #0x28]
  00428	e2833c02	 add         r3, r3, #2, 24
  0042c	e58d3004	 str         r3, [sp, #4]

; 345  :         else

  00430	ea000002	 b           |$LN13@XllpAc97Wr|
  00434		 |$LN14@XllpAc97Wr|

; 346  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryAud[0]);

  00434	e59d3028	 ldr         r3, [sp, #0x28]
  00438	e2833c03	 add         r3, r3, #3, 24
  0043c	e58d3004	 str         r3, [sp, #4]
  00440		 |$LN13@XllpAc97Wr|

; 347  : 
; 348  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;  

  00440	e1dd32b0	 ldrh        r3, [sp, #0x20]
  00444	e1a01003	 mov         r1, r3
  00448	e3a00002	 mov         r0, #2
  0044c	eb000000	 bl          __rt_sdiv
  00450	e3a03004	 mov         r3, #4
  00454	e0020390	 mul         r2, r0, r3
  00458	e59d3004	 ldr         r3, [sp, #4]
  0045c	e0833002	 add         r3, r3, r2
  00460	e58d3004	 str         r3, [sp, #4]
  00464		 |$LN15@XllpAc97Wr|

; 349  :     }
; 350  :     
; 351  : 
; 352  : 	//Lock the ACLINK
; 353  :     timeRemaining = XLLP_AC97_LOCK_TIMEOUT_DEF;

  00464	e3a03f4b	 mov         r3, #0x4B, 30
  00468	e58d3008	 str         r3, [sp, #8]
  0046c		 |$LN12@XllpAc97Wr|

; 354  :     do
; 355  :     {
; 356  :         gotLink = XllpAc97LinkLock(pAc97Reg);

  0046c	e59d0028	 ldr         r0, [sp, #0x28]
  00470	eb000000	 bl          XllpAc97LinkLock
  00474	e58d0014	 str         r0, [sp, #0x14]
  00478	e59d3014	 ldr         r3, [sp, #0x14]
  0047c	e58d3000	 str         r3, [sp]

; 357  :         if (XLLP_FALSE == gotLink)	// 1 usec is a long time.  Skip delay if possible.

  00480	e59d3000	 ldr         r3, [sp]
  00484	e3530000	 cmp         r3, #0
  00488	1a000002	 bne         |$LN9@XllpAc97Wr|

; 358  :         {
; 359  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  0048c	e3a01001	 mov         r1, #1
  00490	e59d002c	 ldr         r0, [sp, #0x2C]
  00494	eb000000	 bl          XllpOstDelayMicroSeconds
  00498		 |$LN9@XllpAc97Wr|

; 360  :         }
; 361  :     }        // Wait while time remaining and ACLINK not available
; 362  :     while (timeRemaining-- && (XLLP_FALSE == gotLink));

  00498	e59d3008	 ldr         r3, [sp, #8]
  0049c	e3530000	 cmp         r3, #0
  004a0	e59d3008	 ldr         r3, [sp, #8]
  004a4	e2433001	 sub         r3, r3, #1
  004a8	e58d3008	 str         r3, [sp, #8]
  004ac	0a000002	 beq         |$LN8@XllpAc97Wr|
  004b0	e59d3000	 ldr         r3, [sp]
  004b4	e3530000	 cmp         r3, #0
  004b8	0affffeb	 beq         |$LN12@XllpAc97Wr|
  004bc		 |$LN8@XllpAc97Wr|

; 363  : 
; 364  :     if (XLLP_FALSE == gotLink)	// Didn't get the ACLINK

  004bc	e59d3000	 ldr         r3, [sp]
  004c0	e3530000	 cmp         r3, #0
  004c4	1a000002	 bne         |$LN7@XllpAc97Wr|

; 365  :     {
; 366  :         status = XLLP_AC97_LINK_LOCK_FAIL;

  004c8	e3a03005	 mov         r3, #5
  004cc	e58d300c	 str         r3, [sp, #0xC]

; 367  :     }
; 368  :     else	// We got the link. Perform the write operation and don't wait.

  004d0	ea00001d	 b           |$LN6@XllpAc97Wr|
  004d4		 |$LN7@XllpAc97Wr|

; 369  :     {
; 370  : 
; 371  :         // First, clear old write status indication CDONE by writing a ONE to that bit.
; 372  :         pAc97Reg->GSR = XLLP_AC97_GSR_CDONE_MSK;

  004d4	e59d3028	 ldr         r3, [sp, #0x28]
  004d8	e283201c	 add         r2, r3, #0x1C
  004dc	e3a03702	 mov         r3, #2, 14
  004e0	e5823000	 str         r3, [r2]

; 373  : 
; 374  :         *pCodecReg = data;       // Now the write!

  004e4	e1dd22b4	 ldrh        r2, [sp, #0x24]
  004e8	e59d3004	 ldr         r3, [sp, #4]
  004ec	e5832000	 str         r2, [r3]

; 375  : 
; 376  :         // Wait until write cycle is complete. There should be a way
; 377  :         //  to do this speculatively at the beginning of the procedure.
; 378  :         //  Need to discover it. Too inefficient to always wait.
; 379  : 
; 380  :         timeRemaining = maxRWTimeOutUs;

  004f0	e59d3030	 ldr         r3, [sp, #0x30]
  004f4	e58d3008	 str         r3, [sp, #8]
  004f8		 |$LN5@XllpAc97Wr|

; 381  :         do
; 382  :         {
; 383  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  004f8	e3a01001	 mov         r1, #1
  004fc	e59d002c	 ldr         r0, [sp, #0x2C]
  00500	eb000000	 bl          XllpOstDelayMicroSeconds

; 384  :         }     // Wait while time remaining and command I/O still incomplete.
; 385  :         while ( (timeRemaining--) && !(pAc97Reg->GSR & XLLP_AC97_GSR_CDONE_MSK));

  00504	e59d3008	 ldr         r3, [sp, #8]
  00508	e3530000	 cmp         r3, #0
  0050c	e59d3008	 ldr         r3, [sp, #8]
  00510	e2433001	 sub         r3, r3, #1
  00514	e58d3008	 str         r3, [sp, #8]
  00518	0a000004	 beq         |$LN2@XllpAc97Wr|
  0051c	e59d3028	 ldr         r3, [sp, #0x28]
  00520	e283301c	 add         r3, r3, #0x1C
  00524	e5933000	 ldr         r3, [r3]
  00528	e3130702	 tst         r3, #2, 14
  0052c	0afffff1	 beq         |$LN5@XllpAc97Wr|
  00530		 |$LN2@XllpAc97Wr|

; 386  : 		if (!(pAc97Reg->GSR & XLLP_AC97_GSR_CDONE_MSK))

  00530	e59d3028	 ldr         r3, [sp, #0x28]
  00534	e283301c	 add         r3, r3, #0x1C
  00538	e5933000	 ldr         r3, [r3]
  0053c	e3130702	 tst         r3, #2, 14
  00540	1a000001	 bne         |$LN1@XllpAc97Wr|

; 387  : 			status = XLLP_AC97_CODEC_ACCESS_TIMEOUT;

  00544	e3a03001	 mov         r3, #1
  00548	e58d300c	 str         r3, [sp, #0xC]
  0054c		 |$LN1@XllpAc97Wr|
  0054c		 |$LN6@XllpAc97Wr|
  0054c		 |$done$1198|

; 388  :     }  // Got AC link
; 389  : 
; 390  : done:
; 391  :     return(status);

  0054c	e59d300c	 ldr         r3, [sp, #0xC]
  00550	e58d3010	 str         r3, [sp, #0x10]

; 392  : } // Ac97CtrlCodecWrite()

  00554	e59d0010	 ldr         r0, [sp, #0x10]
  00558	e28dd018	 add         sp, sp, #0x18
  0055c	e89d6000	 ldmia       sp, {sp, lr}
  00560	e12fff1e	 bx          lr
  00564		 |$M1316|

			 ENDP  ; |XllpAc97Write|

	EXPORT	|XllpAc97Read|

  00020			 AREA	 |.pdata|, PDATA
|$T1324| DCD	|$LN24@XllpAc97Re|
	DCD	0x40008004
; Function compile flags: /Odtp

  00564			 AREA	 |.text|, CODE, ARM

  00564		 |XllpAc97Read| PROC

; 436  : {

  00564		 |$LN24@XllpAc97Re|
  00564	e1a0c00d	 mov         r12, sp
  00568	e92d000f	 stmdb       sp!, {r0 - r3}
  0056c	e92d5000	 stmdb       sp!, {r12, lr}
  00570	e24dd018	 sub         sp, sp, #0x18
  00574		 |$M1321|

; 437  :     XLLP_AC97_ERROR_T	status = XLLP_AC97_NO_ERROR;

  00574	e3a03000	 mov         r3, #0
  00578	e58d300c	 str         r3, [sp, #0xC]

; 438  :     XLLP_BOOL_T			gotLink;
; 439  : 	XLLP_UINT32_T		timeRemaining;
; 440  :     P_XLLP_VUINT32_T	pCodecReg;
; 441  : 
; 442  :     // Point to specified register within area mapped to target codec regs
; 443  :     // Check for special case register 54h the GPIO status register
; 444  : #ifdef WM9712
; 445  :     if(offset == XLLP_AC97_CR_E_MDM_GPIO_PIN_STAT)
; 446  :     {
; 447  :         // Select the Primary or Secondary modem IO address space
; 448  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)
; 449  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryMdm[0]);
; 450  :         else
; 451  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryMdm[0]);
; 452  : 
; 453  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 454  : 
; 455  :         // The data is received on Slot 12 and stored by the
; 456  :         // ACUNIT so we can read back straight away.
; 457  :         *pdata = (XLLP_UINT16_T)(*pCodecReg);
; 458  :             
; 459  :         goto done;
; 460  :     }
; 461  :     else
; 462  :     {
; 463  :         // Select the Primary or Secondary Audio IO address space
; 464  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)
; 465  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);
; 466  :         else
; 467  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryAud[0]);
; 468  : 
; 469  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;  
; 470  :     }
; 471  : #else
; 472  :     // Select the Primary or Secondary Audio IO address space
; 473  : 	if (XLLP_AC97_CODEC_PRIMARY == codecSel)

  0057c	e59d3034	 ldr         r3, [sp, #0x34]
  00580	e3530000	 cmp         r3, #0
  00584	1a000003	 bne         |$LN19@XllpAc97Re|

; 474  :         pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);

  00588	e59d3028	 ldr         r3, [sp, #0x28]
  0058c	e2833c02	 add         r3, r3, #2, 24
  00590	e58d3004	 str         r3, [sp, #4]

; 475  :     else

  00594	ea000002	 b           |$LN18@XllpAc97Re|
  00598		 |$LN19@XllpAc97Re|

; 476  :         pCodecReg = &(pAc97Reg->CodecRegsSecondaryAud[0]);

  00598	e59d3028	 ldr         r3, [sp, #0x28]
  0059c	e2833c03	 add         r3, r3, #3, 24
  005a0	e58d3004	 str         r3, [sp, #4]
  005a4		 |$LN18@XllpAc97Re|

; 477  :     pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;  

  005a4	e1dd32b0	 ldrh        r3, [sp, #0x20]
  005a8	e1a01003	 mov         r1, r3
  005ac	e3a00002	 mov         r0, #2
  005b0	eb000000	 bl          __rt_sdiv
  005b4	e3a03004	 mov         r3, #4
  005b8	e0020390	 mul         r2, r0, r3
  005bc	e59d3004	 ldr         r3, [sp, #4]
  005c0	e0833002	 add         r3, r3, r2
  005c4	e58d3004	 str         r3, [sp, #4]

; 478  : #endif
; 479  : 	//Lock the ACLINK
; 480  :     timeRemaining = XLLP_AC97_LOCK_TIMEOUT_DEF;

  005c8	e3a03f4b	 mov         r3, #0x4B, 30
  005cc	e58d3008	 str         r3, [sp, #8]
  005d0		 |$LN17@XllpAc97Re|

; 481  :     do
; 482  :     {
; 483  :         gotLink = XllpAc97LinkLock(pAc97Reg);

  005d0	e59d0028	 ldr         r0, [sp, #0x28]
  005d4	eb000000	 bl          XllpAc97LinkLock
  005d8	e58d0014	 str         r0, [sp, #0x14]
  005dc	e59d3014	 ldr         r3, [sp, #0x14]
  005e0	e58d3000	 str         r3, [sp]

; 484  :         if (XLLP_FALSE == gotLink)	// 1 usec is a long time.  Skip delay if possible.

  005e4	e59d3000	 ldr         r3, [sp]
  005e8	e3530000	 cmp         r3, #0
  005ec	1a000002	 bne         |$LN14@XllpAc97Re|

; 485  :         {
; 486  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  005f0	e3a01001	 mov         r1, #1
  005f4	e59d002c	 ldr         r0, [sp, #0x2C]
  005f8	eb000000	 bl          XllpOstDelayMicroSeconds
  005fc		 |$LN14@XllpAc97Re|

; 487  :         }
; 488  :     }        // Wait while time remaining and ACLINK not available
; 489  :     while (timeRemaining-- && (XLLP_FALSE == gotLink));

  005fc	e59d3008	 ldr         r3, [sp, #8]
  00600	e3530000	 cmp         r3, #0
  00604	e59d3008	 ldr         r3, [sp, #8]
  00608	e2433001	 sub         r3, r3, #1
  0060c	e58d3008	 str         r3, [sp, #8]
  00610	0a000002	 beq         |$LN13@XllpAc97Re|
  00614	e59d3000	 ldr         r3, [sp]
  00618	e3530000	 cmp         r3, #0
  0061c	0affffeb	 beq         |$LN17@XllpAc97Re|
  00620		 |$LN13@XllpAc97Re|

; 490  : 
; 491  :     if (XLLP_FALSE == gotLink)	// Didn't get the ACLINK

  00620	e59d3000	 ldr         r3, [sp]
  00624	e3530000	 cmp         r3, #0
  00628	1a000002	 bne         |$LN12@XllpAc97Re|

; 492  :     {
; 493  :         status = XLLP_AC97_LINK_LOCK_FAIL;

  0062c	e3a03005	 mov         r3, #5
  00630	e58d300c	 str         r3, [sp, #0xC]

; 494  :     }
; 495  :     else	// We got the link. Perform the write operation and don't wait.

  00634	ea000044	 b           |$LN11@XllpAc97Re|
  00638		 |$LN12@XllpAc97Re|

; 496  :     {
; 497  :          // First, clear old read status indications.
; 498  :         pAc97Reg->GSR = XLLP_AC97_GSR_SDONE_MSK | XLLP_AC97_GSR_RCS_ERR_MSK;

  00638	e59d3028	 ldr         r3, [sp, #0x28]
  0063c	e283201c	 add         r2, r3, #0x1C
  00640	e3a03912	 mov         r3, #0x12, 18
  00644	e5823000	 str         r3, [r2]

; 499  : 
; 500  :         *pdata = (XLLP_UINT16_T)(*pCodecReg); // This is THE DUMMY READ.

  00648	e59d3004	 ldr         r3, [sp, #4]
  0064c	e5933000	 ldr         r3, [r3]
  00650	e1a02803	 mov         r2, r3, lsl #16
  00654	e1a02822	 mov         r2, r2, lsr #16
  00658	e59d3024	 ldr         r3, [sp, #0x24]
  0065c	e1c320b0	 strh        r2, [r3]

; 501  : 
; 502  :          // Wait for read I/O with codec to complete before doing real read.
; 503  :         timeRemaining = maxRWTimeOutUs;

  00660	e59d3030	 ldr         r3, [sp, #0x30]
  00664	e58d3008	 str         r3, [sp, #8]
  00668		 |$LN10@XllpAc97Re|

; 504  :         do
; 505  :         {
; 506  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  00668	e3a01001	 mov         r1, #1
  0066c	e59d002c	 ldr         r0, [sp, #0x2C]
  00670	eb000000	 bl          XllpOstDelayMicroSeconds

; 507  :         }   // Wait while time remaining and read I/O still incomplete
; 508  :         while( (timeRemaining--) && (!(pAc97Reg->GSR & XLLP_AC97_GSR_SDONE_MSK)) );

  00674	e59d3008	 ldr         r3, [sp, #8]
  00678	e3530000	 cmp         r3, #0
  0067c	e59d3008	 ldr         r3, [sp, #8]
  00680	e2433001	 sub         r3, r3, #1
  00684	e58d3008	 str         r3, [sp, #8]
  00688	0a000004	 beq         |$LN7@XllpAc97Re|
  0068c	e59d3028	 ldr         r3, [sp, #0x28]
  00690	e283301c	 add         r3, r3, #0x1C
  00694	e5933000	 ldr         r3, [r3]
  00698	e3130701	 tst         r3, #1, 14
  0069c	0afffff1	 beq         |$LN10@XllpAc97Re|
  006a0		 |$LN7@XllpAc97Re|

; 509  : 
; 510  :         if ((pAc97Reg->GSR & XLLP_AC97_GSR_SDONE_MSK) && (!(pAc97Reg->GSR & XLLP_AC97_GSR_RCS_ERR_MSK)) )

  006a0	e59d3028	 ldr         r3, [sp, #0x28]
  006a4	e283301c	 add         r3, r3, #0x1C
  006a8	e5933000	 ldr         r3, [r3]
  006ac	e3130701	 tst         r3, #1, 14
  006b0	0a00001f	 beq         |$LN6@XllpAc97Re|
  006b4	e59d3028	 ldr         r3, [sp, #0x28]
  006b8	e283301c	 add         r3, r3, #0x1C
  006bc	e5933000	 ldr         r3, [r3]
  006c0	e3130902	 tst         r3, #2, 18
  006c4	1a00001a	 bne         |$LN6@XllpAc97Re|

; 511  :         {
; 512  :              // succeed in reading. clear status bits first.
; 513  :              pAc97Reg->GSR = XLLP_AC97_GSR_SDONE_MSK | XLLP_AC97_GSR_RCS_ERR_MSK;

  006c8	e59d3028	 ldr         r3, [sp, #0x28]
  006cc	e283201c	 add         r2, r3, #0x1C
  006d0	e3a03912	 mov         r3, #0x12, 18
  006d4	e5823000	 str         r3, [r2]

; 514  :             *pdata = (XLLP_UINT16_T)(*pCodecReg);	// THE REAL READ.

  006d8	e59d3004	 ldr         r3, [sp, #4]
  006dc	e5933000	 ldr         r3, [r3]
  006e0	e1a02803	 mov         r2, r3, lsl #16
  006e4	e1a02822	 mov         r2, r2, lsr #16
  006e8	e59d3024	 ldr         r3, [sp, #0x24]
  006ec	e1c320b0	 strh        r2, [r3]

; 515  :      		timeRemaining = maxRWTimeOutUs;

  006f0	e59d3030	 ldr         r3, [sp, #0x30]
  006f4	e58d3008	 str         r3, [sp, #8]
  006f8		 |$LN5@XllpAc97Re|

; 516  :     	    do
; 517  : 	        {
; 518  : 				XllpOstDelayMicroSeconds(pOstRegs, 1);

  006f8	e3a01001	 mov         r1, #1
  006fc	e59d002c	 ldr         r0, [sp, #0x2C]
  00700	eb000000	 bl          XllpOstDelayMicroSeconds

; 519  :   		    }   // Wait while time remaining and read I/O still incomplete
; 520  :     	    while( (timeRemaining--) && (!(pAc97Reg->GSR & XLLP_AC97_GSR_SDONE_MSK)) );

  00704	e59d3008	 ldr         r3, [sp, #8]
  00708	e3530000	 cmp         r3, #0
  0070c	e59d3008	 ldr         r3, [sp, #8]
  00710	e2433001	 sub         r3, r3, #1
  00714	e58d3008	 str         r3, [sp, #8]
  00718	0a000004	 beq         |$LN2@XllpAc97Re|
  0071c	e59d3028	 ldr         r3, [sp, #0x28]
  00720	e283301c	 add         r3, r3, #0x1C
  00724	e5933000	 ldr         r3, [r3]
  00728	e3130701	 tst         r3, #1, 14
  0072c	0afffff1	 beq         |$LN5@XllpAc97Re|
  00730		 |$LN2@XllpAc97Re|

; 521  : 
; 522  :         }
; 523  :         else	// failed

  00730	ea000005	 b           |$LN1@XllpAc97Re|
  00734		 |$LN6@XllpAc97Re|

; 524  :         {
; 525  :             status = XLLP_AC97_CODEC_ACCESS_TIMEOUT;

  00734	e3a03001	 mov         r3, #1
  00738	e58d300c	 str         r3, [sp, #0xC]

; 526  :             pAc97Reg->CAR = XLLP_AC97_CAR_CAIP_CLEAR;

  0073c	e59d3028	 ldr         r3, [sp, #0x28]
  00740	e2832020	 add         r2, r3, #0x20
  00744	e3a03000	 mov         r3, #0
  00748	e5823000	 str         r3, [r2]
  0074c		 |$LN1@XllpAc97Re|
  0074c		 |$LN11@XllpAc97Re|

; 527  : 
; 528  :         } // else  (OK to do real read)
; 529  : 
; 530  :     } // else  (We got the link.  Perform the read operations.)
; 531  : 
; 532  :     return (status);

  0074c	e59d300c	 ldr         r3, [sp, #0xC]
  00750	e58d3010	 str         r3, [sp, #0x10]

; 533  : } // XllpAc97Read ()

  00754	e59d0010	 ldr         r0, [sp, #0x10]
  00758	e28dd018	 add         sp, sp, #0x18
  0075c	e89d6000	 ldmia       sp, {sp, lr}
  00760	e12fff1e	 bx          lr
  00764		 |$M1322|

			 ENDP  ; |XllpAc97Read|


  00028			 AREA	 |.pdata|, PDATA
|$T1331| DCD	|$LN16@XllpAc97Co|
	DCD	0x40005f04
; Function compile flags: /Odtp

  00764			 AREA	 |.text|, CODE, ARM

  00764		 |XllpAc97ColdReset| PROC

; 569  : { 

  00764		 |$LN16@XllpAc97Co|
  00764	e1a0c00d	 mov         r12, sp
  00768	e92d0001	 stmdb       sp!, {r0}
  0076c	e92d5000	 stmdb       sp!, {r12, lr}
  00770	e24dd034	 sub         sp, sp, #0x34
  00774		 |$M1328|

; 570  :     XLLP_AC97_ERROR_T	status = XLLP_AC97_NO_ERROR; 

  00774	e3a03000	 mov         r3, #0
  00778	e58d3010	 str         r3, [sp, #0x10]

; 571  :     P_XLLP_AC97_T		pAC97 = pAc97ctxt->pAc97Reg;

  0077c	e59d303c	 ldr         r3, [sp, #0x3C]
  00780	e2833008	 add         r3, r3, #8
  00784	e5933000	 ldr         r3, [r3]
  00788	e58d3014	 str         r3, [sp, #0x14]

; 572  :     P_XLLP_OST_T 		pOstRegs = pAc97ctxt->pOstRegs;

  0078c	e59d303c	 ldr         r3, [sp, #0x3C]
  00790	e283300c	 add         r3, r3, #0xC
  00794	e5933000	 ldr         r3, [r3]
  00798	e58d3008	 str         r3, [sp, #8]

; 573  :     XLLP_BOOL_T			priCodecReady, secCodecReady; 
; 574  :     XLLP_UINT32_T		timeRemaining; 
; 575  : 
; 576  :     pAC97->GCR = 0;    

  0079c	e59d3014	 ldr         r3, [sp, #0x14]
  007a0	e283200c	 add         r2, r3, #0xC
  007a4	e3a03000	 mov         r3, #0
  007a8	e5823000	 str         r3, [r2]

; 577  : 
; 578  :     // Hold reset active for a minimum time
; 579  : 	XllpOstDelayMicroSeconds(pOstRegs, XLLP_AC97_COLD_HOLDTIME);

  007ac	e3a01064	 mov         r1, #0x64
  007b0	e59d0008	 ldr         r0, [sp, #8]
  007b4	eb000000	 bl          XllpOstDelayMicroSeconds

; 580  : 
; 581  :     // Deactivate cold reset condition
; 582  : 	pAC97->GCR |= XLLP_AC97_GCR_COLD_RESET_MSK; 

  007b8	e59d3014	 ldr         r3, [sp, #0x14]
  007bc	e283300c	 add         r3, r3, #0xC
  007c0	e5933000	 ldr         r3, [r3]
  007c4	e3832002	 orr         r2, r3, #2
  007c8	e59d3014	 ldr         r3, [sp, #0x14]
  007cc	e283300c	 add         r3, r3, #0xC
  007d0	e5832000	 str         r2, [r3]

; 583  :     
; 584  :     // Set nReset high. This is a workaround for some strange behavior of nReset pin.
; 585  :     {
; 586  : 	    XLLP_UINT32_T pins[6];
; 587  :     	pins[0] = 1;

  007d4	e3a03001	 mov         r3, #1
  007d8	e58d3018	 str         r3, [sp, #0x18]

; 588  :     	pins[1] = 113;

  007dc	e3a03071	 mov         r3, #0x71
  007e0	e58d301c	 str         r3, [sp, #0x1C]

; 589  :     	XllpGpioSetOutputState1(pAc97ctxt->pGpioReg, pins);

  007e4	e28d1018	 add         r1, sp, #0x18
  007e8	e59d303c	 ldr         r3, [sp, #0x3C]
  007ec	e5930000	 ldr         r0, [r3]
  007f0	eb000000	 bl          XllpGpioSetOutputState1

; 590  :     }
; 591  :     	
; 592  :     // And wait with timeout for all codecs to respond.
; 593  : 
; 594  :     priCodecReady = XLLP_FALSE;

  007f4	e3a03000	 mov         r3, #0
  007f8	e58d3000	 str         r3, [sp]

; 595  : 	if (XLLP_FALSE == pAc97ctxt->useSecondaryCodec)

  007fc	e59d303c	 ldr         r3, [sp, #0x3C]
  00800	e2833018	 add         r3, r3, #0x18
  00804	e5933000	 ldr         r3, [r3]
  00808	e3530000	 cmp         r3, #0
  0080c	1a000002	 bne         |$LN10@XllpAc97Co|

; 596  : 	{
; 597  : 	    secCodecReady = XLLP_TRUE;

  00810	e3a03001	 mov         r3, #1
  00814	e58d3004	 str         r3, [sp, #4]

; 598  : 	}
; 599  : 	else

  00818	ea000001	 b           |$LN9@XllpAc97Co|
  0081c		 |$LN10@XllpAc97Co|

; 600  : 	{
; 601  : 	    secCodecReady = XLLP_FALSE;

  0081c	e3a03000	 mov         r3, #0
  00820	e58d3004	 str         r3, [sp, #4]
  00824		 |$LN9@XllpAc97Co|

; 602  : 	}
; 603  :     timeRemaining = pAc97ctxt->maxSetupTimeOutUs;

  00824	e59d303c	 ldr         r3, [sp, #0x3C]
  00828	e2833014	 add         r3, r3, #0x14
  0082c	e5933000	 ldr         r3, [r3]
  00830	e58d300c	 str         r3, [sp, #0xC]
  00834		 |$LN13@XllpAc97Co|
  00834		 |$LN8@XllpAc97Co|

; 604  :     do
; 605  :     {
; 606  : 		XllpOstDelayMicroSeconds(pOstRegs, 1);

  00834	e3a01001	 mov         r1, #1
  00838	e59d0008	 ldr         r0, [sp, #8]
  0083c	eb000000	 bl          XllpOstDelayMicroSeconds

; 607  :         if (pAC97->GSR & XLLP_AC97_GSR_PCRDY_MSK)

  00840	e59d3014	 ldr         r3, [sp, #0x14]
  00844	e283301c	 add         r3, r3, #0x1C
  00848	e5933000	 ldr         r3, [r3]
  0084c	e3130c01	 tst         r3, #1, 24
  00850	0a000001	 beq         |$LN5@XllpAc97Co|

; 608  :             priCodecReady = XLLP_TRUE;

  00854	e3a03001	 mov         r3, #1
  00858	e58d3000	 str         r3, [sp]
  0085c		 |$LN5@XllpAc97Co|

; 609  :         if (pAC97->GSR & XLLP_AC97_GSR_SCRDY_MSK)

  0085c	e59d3014	 ldr         r3, [sp, #0x14]
  00860	e283301c	 add         r3, r3, #0x1C
  00864	e5933000	 ldr         r3, [r3]
  00868	e3130c02	 tst         r3, #2, 24
  0086c	0a000001	 beq         |$LN4@XllpAc97Co|

; 610  :             secCodecReady = XLLP_TRUE;

  00870	e3a03001	 mov         r3, #1
  00874	e58d3004	 str         r3, [sp, #4]
  00878		 |$LN4@XllpAc97Co|

; 611  :     }
; 612  :     while (timeRemaining-- && ((priCodecReady == XLLP_FALSE) || (secCodecReady == XLLP_FALSE)));

  00878	e59d300c	 ldr         r3, [sp, #0xC]
  0087c	e3530000	 cmp         r3, #0
  00880	e59d300c	 ldr         r3, [sp, #0xC]
  00884	e2433001	 sub         r3, r3, #1
  00888	e58d300c	 str         r3, [sp, #0xC]
  0088c	0a000005	 beq         |$LN3@XllpAc97Co|
  00890	e59d3000	 ldr         r3, [sp]
  00894	e3530000	 cmp         r3, #0
  00898	0affffe5	 beq         |$LN8@XllpAc97Co|
  0089c	e59d3004	 ldr         r3, [sp, #4]
  008a0	e3530000	 cmp         r3, #0
  008a4	0affffe2	 beq         |$LN13@XllpAc97Co|
  008a8		 |$LN3@XllpAc97Co|

; 613  : 
; 614  :     // Timeout status if some of the devices weren't ready.
; 615  :     if ((priCodecReady == XLLP_FALSE) || (secCodecReady == XLLP_FALSE))

  008a8	e59d3000	 ldr         r3, [sp]
  008ac	e3530000	 cmp         r3, #0
  008b0	0a000002	 beq         |$LN1@XllpAc97Co|
  008b4	e59d3004	 ldr         r3, [sp, #4]
  008b8	e3530000	 cmp         r3, #0
  008bc	1a000001	 bne         |$LN2@XllpAc97Co|
  008c0		 |$LN1@XllpAc97Co|

; 616  :     {
; 617  :         status = XLLP_AC97_CODEC_NOT_READY;

  008c0	e3a03002	 mov         r3, #2
  008c4	e58d3010	 str         r3, [sp, #0x10]
  008c8		 |$LN2@XllpAc97Co|

; 618  :     }
; 619  : 
; 620  :     return (status);

  008c8	e59d3010	 ldr         r3, [sp, #0x10]
  008cc	e58d3030	 str         r3, [sp, #0x30]

; 621  : } // XllpAc97ColdReset ()

  008d0	e59d0030	 ldr         r0, [sp, #0x30]
  008d4	e28dd034	 add         sp, sp, #0x34
  008d8	e89d6000	 ldmia       sp, {sp, lr}
  008dc	e12fff1e	 bx          lr
  008e0		 |$M1329|

			 ENDP  ; |XllpAc97ColdReset|


  00030			 AREA	 |.pdata|, PDATA
|$T1337| DCD	|$LN8@XllpAc97Sh|
	DCD	0x40002704
; Function compile flags: /Odtp

  008e0			 AREA	 |.text|, CODE, ARM

  008e0		 |XllpAc97ShutdownAclink| PROC

; 647  : {

  008e0		 |$LN8@XllpAc97Sh|
  008e0	e1a0c00d	 mov         r12, sp
  008e4	e92d0003	 stmdb       sp!, {r0, r1}
  008e8	e92d5000	 stmdb       sp!, {r12, lr}
  008ec	e24dd00c	 sub         sp, sp, #0xC
  008f0		 |$M1334|

; 648  :     XLLP_AC97_ERROR_T status = XLLP_AC97_NO_ERROR; 

  008f0	e3a03000	 mov         r3, #0
  008f4	e58d3004	 str         r3, [sp, #4]

; 649  :     XLLP_UINT32_T timeRemaining = XLLP_AC97_LINKOFF_TIMEOUT_DEF; 

  008f8	e3a03f7d	 mov         r3, #0x7D, 30
  008fc	e58d3000	 str         r3, [sp]

; 650  : 
; 651  :     pAc97Reg->GCR |= XLLP_AC97_GCR_LINK_OFF_MSK;

  00900	e59d3014	 ldr         r3, [sp, #0x14]
  00904	e283300c	 add         r3, r3, #0xC
  00908	e5933000	 ldr         r3, [r3]
  0090c	e3832008	 orr         r2, r3, #8
  00910	e59d3014	 ldr         r3, [sp, #0x14]
  00914	e283300c	 add         r3, r3, #0xC
  00918	e5832000	 str         r2, [r3]
  0091c		 |$LN3@XllpAc97Sh|

; 652  : 	
; 653  : 	while (!(pAc97Reg->GSR & XLLP_AC97_GSR_ACOFFD_MSK))

  0091c	e59d3014	 ldr         r3, [sp, #0x14]
  00920	e283301c	 add         r3, r3, #0x1C
  00924	e5933000	 ldr         r3, [r3]
  00928	e3130008	 tst         r3, #8
  0092c	1a00000c	 bne         |$LN2@XllpAc97Sh|

; 654  : 	{
; 655  : 		timeRemaining --;

  00930	e59d3000	 ldr         r3, [sp]
  00934	e2433001	 sub         r3, r3, #1
  00938	e58d3000	 str         r3, [sp]

; 656  : 		if (0 == timeRemaining)

  0093c	e59d3000	 ldr         r3, [sp]
  00940	e3530000	 cmp         r3, #0
  00944	1a000002	 bne         |$LN1@XllpAc97Sh|

; 657  : 		{
; 658  :     		status = XLLP_AC97_LINK_SHUTDOWN_FAIL;

  00948	e3a03003	 mov         r3, #3
  0094c	e58d3004	 str         r3, [sp, #4]

; 659  :     		break;

  00950	ea000003	 b           |$LN2@XllpAc97Sh|
  00954		 |$LN1@XllpAc97Sh|

; 660  : 		}
; 661  : 		XllpOstDelayMicroSeconds(pOstRegs, 1);

  00954	e3a01001	 mov         r1, #1
  00958	e59d0018	 ldr         r0, [sp, #0x18]
  0095c	eb000000	 bl          XllpOstDelayMicroSeconds

; 662  :     }

  00960	eaffffed	 b           |$LN3@XllpAc97Sh|
  00964		 |$LN2@XllpAc97Sh|

; 663  : 	
; 664  :     return(status);

  00964	e59d3004	 ldr         r3, [sp, #4]
  00968	e58d3008	 str         r3, [sp, #8]

; 665  : }

  0096c	e59d0008	 ldr         r0, [sp, #8]
  00970	e28dd00c	 add         sp, sp, #0xC
  00974	e89d6000	 ldmia       sp, {sp, lr}
  00978	e12fff1e	 bx          lr
  0097c		 |$M1335|

			 ENDP  ; |XllpAc97ShutdownAclink|


  00038			 AREA	 |.pdata|, PDATA
|$T1343| DCD	|$LN6@XllpAc97Li|
	DCD	0x40001504
; Function compile flags: /Odtp

  0097c			 AREA	 |.text|, CODE, ARM

  0097c		 |XllpAc97LinkLock| PROC

; 692  : {

  0097c		 |$LN6@XllpAc97Li|
  0097c	e1a0c00d	 mov         r12, sp
  00980	e92d0001	 stmdb       sp!, {r0}
  00984	e92d5000	 stmdb       sp!, {r12, lr}
  00988	e24dd00c	 sub         sp, sp, #0xC
  0098c		 |$M1340|

; 693  :     XLLP_BOOL_T		status = XLLP_TRUE;

  0098c	e3a03001	 mov         r3, #1
  00990	e58d3004	 str         r3, [sp, #4]

; 694  :     XLLP_VUINT32_T	carTmp;
; 695  : 
; 696  :     carTmp = pAc97Reg->CAR;

  00994	e59d3014	 ldr         r3, [sp, #0x14]
  00998	e2833020	 add         r3, r3, #0x20
  0099c	e5933000	 ldr         r3, [r3]
  009a0	e58d3000	 str         r3, [sp]

; 697  :     if (carTmp & XLLP_AC97_CAR_CAIP_MSK)	// "1" in CAIP bit means lock failed.

  009a4	e59d3000	 ldr         r3, [sp]
  009a8	e3130001	 tst         r3, #1
  009ac	0a000001	 beq         |$LN1@XllpAc97Li|

; 698  :     {
; 699  :         status = XLLP_FALSE;

  009b0	e3a03000	 mov         r3, #0
  009b4	e58d3004	 str         r3, [sp, #4]
  009b8		 |$LN1@XllpAc97Li|

; 700  :     }
; 701  :     return (status);

  009b8	e59d3004	 ldr         r3, [sp, #4]
  009bc	e58d3008	 str         r3, [sp, #8]

; 702  : } // XllpAc97LinkLock()

  009c0	e59d0008	 ldr         r0, [sp, #8]
  009c4	e28dd00c	 add         sp, sp, #0xC
  009c8	e89d6000	 ldmia       sp, {sp, lr}
  009cc	e12fff1e	 bx          lr
  009d0		 |$M1341|

			 ENDP  ; |XllpAc97LinkLock|

	END
