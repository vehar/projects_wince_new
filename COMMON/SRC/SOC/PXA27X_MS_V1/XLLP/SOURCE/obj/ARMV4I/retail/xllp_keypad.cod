; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_keypad.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.data|, DATA
	 COMMON	|KP_Status|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|?xllpKpKIP_Initialized@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::xllpKpKIP_Initialized

  00000			 AREA	 |.data|, DATA
|XllpKpdGpioDirOutList| DCD 0x7
	DCD	0x60
	DCD	0x67
	DCD	0x68
	DCD	0x69
	DCD	0x6a
	DCD	0x6b
	DCD	0x6c
|XllpKpdGpioDirInList| DCD 0x9
	DCD	0x5d
	DCD	0x5e
	DCD	0x5f
	DCD	0x61
	DCD	0x62
	DCD	0x63
	DCD	0x64
	DCD	0x65
	DCD	0x66
|XllpKpdGpioAltFnPinList| DCD 0x10
	DCD	0x5d
	DCD	0x5e
	DCD	0x5f
	DCD	0x60
	DCD	0x61
	DCD	0x62
	DCD	0x63
	DCD	0x64
	DCD	0x65
	DCD	0x66
	DCD	0x67
	DCD	0x68
	DCD	0x69
	DCD	0x6a
	DCD	0x6b
	DCD	0x6c
|?PrevCount@?1??ReadDirectKeys@@9@9| DCD 0x7f		; `ReadDirectKeys'::`2'::PrevCount
|XllpKpdGpioAltFnValList| DCD 0x10
	DCD	0x1
	DCD	0x1
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x3
	DCD	0x1
	DCD	0x1
	DCD	0x1
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
	DCD	0x2
|XllpKpdGpioDirNonScrollWheelInList| DCD 0x7
	DCD	0x5f
	DCD	0x61
	DCD	0x62
	DCD	0x63
	DCD	0x64
	DCD	0x65
	DCD	0x66
	EXPORT	|ReadScanCodeAutomatically|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_keypad.c

  00000			 AREA	 |.pdata|, PDATA
|$T909|	DCD	|$LN71@ReadScanCo|
	DCD	0x40006e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadScanCodeAutomatically| PROC

; 34   : {

  00000		 |$LN71@ReadScanCo|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M906|
  00008	e1a08001	 mov         r8, r1
  0000c	e1a07000	 mov         r7, r0

; 35   :     XLLP_BOOL_T     retval=XLLP_FALSE;
; 36   :     XLLP_UINT32_T   C,R,RthBit,c0,c1,c2,c3,c4,c5,c6,c7;
; 37   :     XLLP_UINT32_T   numOfKeysPressed=0;
; 38   : 
; 39   :     if(KP_Status & MATRIX_INTR_BIT)

  00010	e59f319c	 ldr         r3, [pc, #0x19C]
  00014	e3a00000	 mov         r0, #0
  00018	e5933000	 ldr         r3, [r3]
  0001c	e3130501	 tst         r3, #1, 10
  00020	0a000060	 beq         |$LN54@ReadScanCo|

; 40   :     {
; 41   :         numOfKeysPressed = ((v_pKeyPadRegs->kpAutomaticScanReg & MULTI_KEYS_PRESS) >> 26);

  00024	e5973020	 ldr         r3, [r7, #0x20]
  00028	e1a03083	 mov         r3, r3, lsl #1
  0002c	e1a03da3	 mov         r3, r3, lsr #27

; 42   : //   RETAILMSG(1,(TEXT("XLLP:ReadScanCodeAutomatically numOfKeysPressed %x>\r\n"),numOfKeysPressed));
; 43   : // checks to see if it was a "Major" key that was pressed
; 44   :         if(numOfKeysPressed == 1)

  00030	e3530001	 cmp         r3, #1

; 45   :         {
; 46   :             C =  (v_pKeyPadRegs->kpAutomaticScanReg & COL_SELECTED_MASK);

  00034	05973020	 ldreq       r3, [r7, #0x20]

; 47   :             R =  (v_pKeyPadRegs->kpAutomaticScanReg & ROW_SELECTED_MASK);

  00038	05972020	 ldreq       r2, [r7, #0x20]
  0003c	0203000f	 andeq       r0, r3, #0xF
  00040	020230f0	 andeq       r3, r2, #0xF0

; 48   :             *key = (unsigned char) (C | R);

  00044	01833000	 orreq       r3, r3, r0
  00048	0a000054	 beq         |$LN59@ReadScanCo|

; 49   :         }
; 50   :         else
; 51   : // if it was a "Minor" key, then more than one key was activated and that is how
; 52   : //  you can determine which register to read from.
; 53   :         if(numOfKeysPressed > 1)

  0004c	9a000052	 bls         |$LN51@ReadScanCo|

; 54   :         {
; 55   :             c0 = v_pKeyPadRegs->kpAutoScanMultiKeyPress0 & 0xFF;

  00050	e5976028	 ldr         r6, [r7, #0x28]

; 56   :             c1 = ((v_pKeyPadRegs->kpAutoScanMultiKeyPress0 >> 16) & 0xFF);

  00054	e5972028	 ldr         r2, [r7, #0x28]

; 57   :             c2 = v_pKeyPadRegs->kpAutoScanMultiKeyPress1 & 0xFF;

  00058	e5975030	 ldr         r5, [r7, #0x30]

; 58   :             c3 = ((v_pKeyPadRegs->kpAutoScanMultiKeyPress1 >> 16) & 0xFF);

  0005c	e5971030	 ldr         r1, [r7, #0x30]

; 59   :             c4 = v_pKeyPadRegs->kpAutoScanMultiKeyPress2 & 0xFF;

  00060	e597e038	 ldr         lr, [r7, #0x38]

; 60   :             c5 = ((v_pKeyPadRegs->kpAutoScanMultiKeyPress2 >> 16) & 0xFF);

  00064	e5974038	 ldr         r4, [r7, #0x38]

; 61   :             c6 = v_pKeyPadRegs->kpAutoScanMultiKeyPress3 & 0xFF;

  00068	e5970040	 ldr         r0, [r7, #0x40]

; 62   :             c7 = ((v_pKeyPadRegs->kpAutoScanMultiKeyPress3 >> 16) & 0xFF);

  0006c	e5973040	 ldr         r3, [r7, #0x40]
  00070	e1a01401	 mov         r1, r1, lsl #8
  00074	e1a02402	 mov         r2, r2, lsl #8
  00078	e21670ff	 ands        r7, r6, #0xFF
  0007c	e1a06c22	 mov         r6, r2, lsr #24
  00080	e1a01c21	 mov         r1, r1, lsr #24
  00084	e20550ff	 and         r5, r5, #0xFF
  00088	e20e30ff	 and         r3, lr, #0xFF

; 63   : 
; 64   : // these keys are the "minor keys", the ones that needs top right and bottom left of the
; 65   : // cooresponding 4 keys surrounding them to trigger the correct key. Doing a binary search
; 66   : // there are 5 keys, the middle key reads 0x8, the first key reads 0x2 and the last reads 0x20.
; 67   : // this needs to be done for each row.  This will be encorporated into a routine for the next
; 68   : // upgrade of keypad.
; 69   :             if(c0!=0)

  0008c	0a00000a	 beq         |$LN50@ReadScanCo|

; 70   :             {
; 71   :                 C = 0x7;

  00090	e3a02007	 mov         r2, #7

; 72   :                 if(c0 == 0x8)

  00094	e3570008	 cmp         r7, #8

; 73   :                 {
; 74   :                    RthBit = 0x2;
; 75   :                 }
; 76   :                 else

  00098	0a00002d	 beq         |$LN66@ReadScanCo|

; 77   :                 if(c0 > 0x8)

  0009c	9a000004	 bls         |$LN47@ReadScanCo|

; 78   :                 {
; 79   :                     if (c0 < 0x20)

  000a0	e3570020	 cmp         r7, #0x20
  000a4		 |$LN67@ReadScanCo|
  000a4	2a000030	 bcs         |$LN6@ReadScanCo|

; 80   :                        RthBit = 0x3;

  000a8	e3a03003	 mov         r3, #3

; 177  :                 }       
; 178  :             }       
; 179  :             *key = (unsigned char) ((C<<4) | RthBit);

  000ac	e1833202	 orr         r3, r3, r2, lsl #4

; 180  :         }
; 181  :         else

  000b0	ea00003a	 b           |$LN59@ReadScanCo|
  000b4		 |$LN47@ReadScanCo|

; 81   :                     else
; 82   :                        RthBit = 0x4;
; 83   :                 }else       
; 84   :                 {
; 85   :                     if (c0 > 0x2)

  000b4	e3570002	 cmp         r7, #2

; 86   :                        RthBit = 0x1;
; 87   :                     else

  000b8	ea00002f	 b           |$LN68@ReadScanCo|
  000bc		 |$LN50@ReadScanCo|

; 88   :                        RthBit = 0x0;
; 89   :                 }       
; 90   :             }else       
; 91   :             if(c1!=0)

  000bc	e3560000	 cmp         r6, #0
  000c0	0a000007	 beq         |$LN40@ReadScanCo|

; 92   :             {
; 93   :                 C = 0x8;

  000c4	e3a02008	 mov         r2, #8

; 94   :                 if(c1 == 0x8)

  000c8	e3560008	 cmp         r6, #8

; 95   :                 {
; 96   :                    RthBit = 0x2;
; 97   :                 }
; 98   :                 else

  000cc	0a000020	 beq         |$LN66@ReadScanCo|

; 99   :                 if(c1 > 0x8)

  000d0	9a000001	 bls         |$LN37@ReadScanCo|

; 100  :                 {
; 101  :                     if (c1 < 0x20)

  000d4	e3560020	 cmp         r6, #0x20

; 102  :                        RthBit = 0x3;
; 103  :                     else

  000d8	eafffff1	 b           |$LN67@ReadScanCo|
  000dc		 |$LN37@ReadScanCo|

; 104  :                        RthBit = 0x4;
; 105  :                 }else       
; 106  :                 {
; 107  :                     if (c1 > 0x2)

  000dc	e3560002	 cmp         r6, #2

; 108  :                        RthBit = 0x1;
; 109  :                     else

  000e0	ea000025	 b           |$LN68@ReadScanCo|
  000e4		 |$LN40@ReadScanCo|

; 110  :                        RthBit = 0x0;
; 111  :                 }       
; 112  :             }else       
; 113  :             if(c2!=0)

  000e4	e3550000	 cmp         r5, #0
  000e8	0a000007	 beq         |$LN30@ReadScanCo|

; 114  :             {
; 115  :                 C = 0x9;

  000ec	e3a02009	 mov         r2, #9

; 116  :                 if(c2 == 0x8)

  000f0	e3550008	 cmp         r5, #8

; 117  :                 {
; 118  :                    RthBit = 0x2;
; 119  :                 }
; 120  :                 else

  000f4	0a000016	 beq         |$LN66@ReadScanCo|

; 121  :                 if(c2 > 0x8)

  000f8	9a000001	 bls         |$LN27@ReadScanCo|

; 122  :                 {
; 123  :                     if (c2 < 0x20)

  000fc	e3550020	 cmp         r5, #0x20

; 124  :                        RthBit = 0x3;
; 125  :                     else

  00100	eaffffe7	 b           |$LN67@ReadScanCo|
  00104		 |$LN27@ReadScanCo|

; 126  :                        RthBit = 0x4;
; 127  :                 }else       
; 128  :                 {
; 129  :                     if (c2 > 0x2)

  00104	e3550002	 cmp         r5, #2

; 130  :                        RthBit = 0x1;
; 131  :                     else

  00108	ea00001b	 b           |$LN68@ReadScanCo|
  0010c		 |$LN30@ReadScanCo|

; 132  :                        RthBit = 0x0;
; 133  :                 }       
; 134  :             }else       
; 135  :             if(c3!=0)

  0010c	e3510000	 cmp         r1, #0
  00110	0a00000a	 beq         |$LN20@ReadScanCo|

; 136  :             {
; 137  :                 C = 0xa;

  00114	e3a0200a	 mov         r2, #0xA

; 138  :                 if(c3 == 0x8)

  00118	e3510008	 cmp         r1, #8

; 139  :                 {
; 140  :                    RthBit = 0x2;
; 141  :                 }
; 142  :                 else

  0011c	0a00000c	 beq         |$LN66@ReadScanCo|

; 143  :                 if(c3 > 0x8)

  00120	9a000001	 bls         |$LN17@ReadScanCo|

; 144  :                 {
; 145  :                     if (c3 < 0x20)

  00124	e3510020	 cmp         r1, #0x20

; 146  :                        RthBit = 0x3;
; 147  :                     else

  00128	eaffffdd	 b           |$LN67@ReadScanCo|
  0012c		 |$LN17@ReadScanCo|

; 148  :                        RthBit = 0x4;
; 149  :                 }else       
; 150  :                 {
; 151  :                     if (c3 > 0x2)

  0012c	e3510002	 cmp         r1, #2

; 152  :                        RthBit = 0x1;
; 153  :                     else

  00130	8a000012	 bhi         |$LN65@ReadScanCo|
  00134		 |$LN13@ReadScanCo|

; 154  :                        RthBit = 0x0;

  00134	e3a03000	 mov         r3, #0

; 177  :                 }       
; 178  :             }       
; 179  :             *key = (unsigned char) ((C<<4) | RthBit);

  00138	e1833202	 orr         r3, r3, r2, lsl #4

; 180  :         }
; 181  :         else

  0013c	ea000017	 b           |$LN59@ReadScanCo|
  00140		 |$LN20@ReadScanCo|

; 155  :                 }       
; 156  :             }else       
; 157  :             if(c4!=0)

  00140	e3530000	 cmp         r3, #0
  00144	0a000010	 beq         |$LN57@ReadScanCo|

; 158  :             {
; 159  :                 C = 0xb;

  00148	e3a0200b	 mov         r2, #0xB

; 160  :                 if(c4 == 0x8)

  0014c	e3530008	 cmp         r3, #8
  00150	1a000002	 bne         |$LN64@ReadScanCo|
  00154		 |$LN66@ReadScanCo|

; 161  :                 {
; 162  :                    RthBit = 0x2;

  00154	e3a03002	 mov         r3, #2

; 177  :                 }       
; 178  :             }       
; 179  :             *key = (unsigned char) ((C<<4) | RthBit);

  00158	e1833202	 orr         r3, r3, r2, lsl #4

; 180  :         }
; 181  :         else

  0015c	ea00000f	 b           |$LN59@ReadScanCo|
  00160		 |$LN64@ReadScanCo|

; 163  :                 }
; 164  :                 else
; 165  :                 if(c4 > 0x8)

  00160	9a000004	 bls         |$LN7@ReadScanCo|

; 166  :                 {
; 167  :                     if (c4 < 0x20)

  00164	e3530020	 cmp         r3, #0x20

; 168  :                        RthBit = 0x3;
; 169  :                     else

  00168	eaffffcd	 b           |$LN67@ReadScanCo|
  0016c		 |$LN6@ReadScanCo|

; 170  :                        RthBit = 0x4;

  0016c	e3a03004	 mov         r3, #4

; 177  :                 }       
; 178  :             }       
; 179  :             *key = (unsigned char) ((C<<4) | RthBit);

  00170	e1833202	 orr         r3, r3, r2, lsl #4

; 180  :         }
; 181  :         else

  00174	ea000009	 b           |$LN59@ReadScanCo|
  00178		 |$LN7@ReadScanCo|

; 171  :                 }else       
; 172  :                 {
; 173  :                     if (c4 > 0x2)

  00178	e3530002	 cmp         r3, #2
  0017c		 |$LN68@ReadScanCo|
  0017c	9affffec	 bls         |$LN13@ReadScanCo|
  00180		 |$LN65@ReadScanCo|

; 174  :                        RthBit = 0x1;

  00180	e3a03001	 mov         r3, #1

; 177  :                 }       
; 178  :             }       
; 179  :             *key = (unsigned char) ((C<<4) | RthBit);

  00184	e1833202	 orr         r3, r3, r2, lsl #4

; 180  :         }
; 181  :         else

  00188	ea000004	 b           |$LN59@ReadScanCo|
  0018c		 |$LN57@ReadScanCo|

; 175  :                     else
; 176  :                        RthBit = 0x0;

  0018c	e59d2000	 ldr         r2, [sp]
  00190	e59d3000	 ldr         r3, [sp]

; 177  :                 }       
; 178  :             }       
; 179  :             *key = (unsigned char) ((C<<4) | RthBit);

  00194	e1833202	 orr         r3, r3, r2, lsl #4

; 180  :         }
; 181  :         else

  00198	ea000000	 b           |$LN59@ReadScanCo|
  0019c		 |$LN51@ReadScanCo|

; 182  :             *key = NO_KEY;

  0019c	e3a030ff	 mov         r3, #0xFF
  001a0		 |$LN59@ReadScanCo|
  001a0	e5c83000	 strb        r3, [r8]

; 183  : 
; 184  : //       RETAILMSG(1,(TEXT("R is %x C is %x key is %x\r\n"), RthBit,C,*key));
; 185  : 
; 186  :         retval = XLLP_TRUE;

  001a4	e3a00001	 mov         r0, #1
  001a8		 |$LN54@ReadScanCo|

; 187  :     }
; 188  : //    RETAILMSG(1,(TEXT("ReadScanCodeAutomatically<\r\n")));
; 189  :     return(retval);
; 190  : }

  001a8	e28dd004	 add         sp, sp, #4
  001ac	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  001b0	e12fff1e	 bx          lr
  001b4		 |$LN72@ReadScanCo|
  001b4		 |$LN73@ReadScanCo|
  001b4	00000000	 DCD         |KP_Status|
  001b8		 |$M907|

			 ENDP  ; |ReadScanCodeAutomatically|

	EXPORT	|XllpKpKeypressIsInProgress|

  00004			 AREA	 |.bss|, NOINIT
|?gplr2_OutPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr2_OutPinMask
|?gplr0_AllPinsMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr0_AllPinsMask
|?gplr1_AllPinsMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr1_AllPinsMask
|?gplr2_AllPinsMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr2_AllPinsMask
|?gplr3_AllPinsMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr3_AllPinsMask
|?gplr3_OutPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr3_OutPinMask
|?gplr3_InPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr3_InPinMask
|?gplr2_OutPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr2_OutPinMask
|?gplr2_InPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr2_InPinMask
|?gplr1_OutPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr1_OutPinMask
|?gplr1_InPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr1_InPinMask
|?gplr0_OutPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr0_OutPinMask
|?gplr0_InPinMask@?1??XllpKpKeypressIsInProgress@@9@9| % 0x4 ; `XllpKpKeypressIsInProgress'::`2'::gplr0_InPinMask

  00000			 AREA	 |.pdata|, PDATA
|$T929|	DCD	|$LN29@XllpKpKeyp|
	DCD	0x40009302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpKpKeypressIsInProgress| PROC

; 207  : {

  00000		 |$LN29@XllpKpKeyp|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M926|
  00008	e1a02000	 mov         r2, r0
  0000c	e58d2010	 str         r2, [sp, #0x10]

; 208  :     // Note that GPIOs used here only include MKOUTs, MKINs and non-rotary DKINs.
; 209  : 
; 210  :     static XLLP_BOOL_T xllpKpKIP_Initialized = XLLP_FALSE;
; 211  :     static XLLP_UINT32_T gplr0_InPinMask, gplr0_OutPinMask, gplr0_AllPinsMask,
; 212  :                          gplr1_InPinMask, gplr1_OutPinMask, gplr1_AllPinsMask,
; 213  :                          gplr2_InPinMask, gplr2_OutPinMask, gplr2_AllPinsMask,
; 214  :                          gplr3_InPinMask, gplr3_OutPinMask, gplr3_AllPinsMask;
; 215  : 
; 216  :     XLLP_UINT32_T i;
; 217  :     XLLP_UINT32_T gpioRegTmp;
; 218  :     XLLP_UINT32_T activity  = 0;
; 219  : 
; 220  :     // Set up masks only once.  Do this in code rather than precalculation to expose
; 221  :     //  the algorithm and make it easily re-usable.  Perform full init because fairly
; 222  :     //  fast and only done once.
; 223  : 
; 224  :     if (!xllpKpKIP_Initialized)

  00010	e59f1230	 ldr         r1, [pc, #0x230]
  00014	e5913030	 ldr         r3, [r1, #0x30]
  00018	e3530000	 cmp         r3, #0
  0001c	1a00007a	 bne         |$LN26@XllpKpKeyp|

; 225  :     {
; 226  :         gplr0_InPinMask = gplr0_OutPinMask = gplr0_AllPinsMask =
; 227  :         gplr1_InPinMask = gplr1_OutPinMask = gplr1_AllPinsMask =
; 228  :         gplr2_InPinMask = gplr2_OutPinMask = gplr2_AllPinsMask =
; 229  :         gplr3_InPinMask = gplr3_OutPinMask = gplr3_AllPinsMask = 0;
; 230  : 
; 231  :         for (i=1 ;i<(XllpKpdGpioDirNonScrollWheelInList[0]+1) ;i++ )

  00020	e59fe21c	 ldr         lr, [pc, #0x21C]
  00024	e3a04000	 mov         r4, #0
  00028	e3a07000	 mov         r7, #0
  0002c	e59e30d4	 ldr         r3, [lr, #0xD4]
  00030	e3a05000	 mov         r5, #0
  00034	e3a0a000	 mov         r10, #0
  00038	e2832001	 add         r2, r3, #1
  0003c	e3a08000	 mov         r8, #0
  00040	e3a0b000	 mov         r11, #0
  00044	e3a09000	 mov         r9, #0
  00048	e3a06000	 mov         r6, #0
  0004c	e3520001	 cmp         r2, #1
  00050	e58d7004	 str         r7, [sp, #4]
  00054	e58da008	 str         r10, [sp, #8]
  00058	e58db00c	 str         r11, [sp, #0xC]
  0005c	e58d6000	 str         r6, [sp]
  00060	e5814024	 str         r4, [r1, #0x24]
  00064	e581700c	 str         r7, [r1, #0xC]
  00068	e5815000	 str         r5, [r1]
  0006c	e581a018	 str         r10, [r1, #0x18]
  00070	e5818014	 str         r8, [r1, #0x14]
  00074	e581b02c	 str         r11, [r1, #0x2C]
  00078	e5819004	 str         r9, [r1, #4]
  0007c	e5816008	 str         r6, [r1, #8]
  00080	9a00002c	 bls         |$LN16@XllpKpKeyp|
  00084	e28e30d4	 add         r3, lr, #0xD4
  00088	e2830004	 add         r0, r3, #4
  0008c	e2426001	 sub         r6, r2, #1
  00090	e3a0e000	 mov         lr, #0
  00094	e3a09001	 mov         r9, #1
  00098	e3a08001	 mov         r8, #1
  0009c	e3a05001	 mov         r5, #1
  000a0	e3a04001	 mov         r4, #1
  000a4		 |$LL18@XllpKpKeyp|

; 232  :         {
; 233  :             switch (XllpKpdGpioDirNonScrollWheelInList[i] / 32) // 32 pins per level register

  000a4	e5902000	 ldr         r2, [r0]
  000a8	e1b032a2	 movs        r3, r2, lsr #5
  000ac	0a000010	 beq         |$LN13@XllpKpKeyp|
  000b0	e3530001	 cmp         r3, #1
  000b4	0a00000a	 beq         |$LN12@XllpKpKeyp|
  000b8	e3530002	 cmp         r3, #2
  000bc	0a000004	 beq         |$LN11@XllpKpKeyp|
  000c0	e3530003	 cmp         r3, #3
  000c4	1a00000d	 bne         |$LN17@XllpKpKeyp|

; 244  :                 case 3:
; 245  :                     gplr3_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  000c8	e202301f	 and         r3, r2, #0x1F
  000cc	e1877319	 orr         r7, r7, r9, lsl r3

; 246  :                     break;

  000d0	ea00000a	 b           |$LN17@XllpKpKeyp|
  000d4		 |$LN11@XllpKpKeyp|

; 241  :                 case 2:
; 242  :                     gplr2_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  000d4	e202301f	 and         r3, r2, #0x1F
  000d8	e18aa318	 orr         r10, r10, r8, lsl r3
  000dc	e581a018	 str         r10, [r1, #0x18]

; 243  :                     break;

  000e0	ea000006	 b           |$LN17@XllpKpKeyp|
  000e4		 |$LN12@XllpKpKeyp|

; 237  :                     break;
; 238  :                 case 1:
; 239  :                     gplr1_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  000e4	e202301f	 and         r3, r2, #0x1F
  000e8	e18bb315	 orr         r11, r11, r5, lsl r3
  000ec	e581b02c	 str         r11, [r1, #0x2C]

; 240  :                     break;

  000f0	ea000002	 b           |$LN17@XllpKpKeyp|
  000f4		 |$LN13@XllpKpKeyp|

; 234  :             {
; 235  :                 case 0:
; 236  :                     gplr0_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  000f4	e202301f	 and         r3, r2, #0x1F
  000f8	e18ee314	 orr         lr, lr, r4, lsl r3
  000fc	e581e008	 str         lr, [r1, #8]
  00100		 |$LN17@XllpKpKeyp|
  00100	e2800004	 add         r0, r0, #4
  00104	e2566001	 subs        r6, r6, #1
  00108	1affffe5	 bne         |$LL18@XllpKpKeyp|
  0010c	e58de000	 str         lr, [sp]
  00110	e59fe12c	 ldr         lr, [pc, #0x12C]
  00114	e59d6000	 ldr         r6, [sp]

; 237  :                     break;
; 238  :                 case 1:
; 239  :                     gplr1_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  00118	e58db00c	 str         r11, [sp, #0xC]

; 241  :                 case 2:
; 242  :                     gplr2_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  0011c	e58da008	 str         r10, [sp, #8]

; 244  :                 case 3:
; 245  :                     gplr3_InPinMask |= (1u << (XllpKpdGpioDirNonScrollWheelInList[i] &31));

  00120	e58d7004	 str         r7, [sp, #4]
  00124	e581700c	 str         r7, [r1, #0xC]
  00128	e3a04000	 mov         r4, #0
  0012c	e3a05000	 mov         r5, #0
  00130	e3a08000	 mov         r8, #0
  00134	e3a09000	 mov         r9, #0
  00138		 |$LN16@XllpKpKeyp|

; 247  :             }
; 248  :         }  // Input pin masks
; 249  : 
; 250  :         for (i=1 ;i<XllpKpdGpioDirOutList[0]+1 ;i++ )

  00138	e59e3000	 ldr         r3, [lr]
  0013c	e2833001	 add         r3, r3, #1
  00140	e3530001	 cmp         r3, #1
  00144	9a000024	 bls         |$LN7@XllpKpKeyp|
  00148	e28e0004	 add         r0, lr, #4
  0014c	e243e001	 sub         lr, r3, #1
  00150	e3a06001	 mov         r6, #1
  00154	e3a0a001	 mov         r10, #1
  00158	e3a0b001	 mov         r11, #1
  0015c	e3a07001	 mov         r7, #1
  00160		 |$LL9@XllpKpKeyp|

; 251  :         {
; 252  :             switch (XllpKpdGpioDirOutList[i] / 32) // 32 pins per level register

  00160	e5903000	 ldr         r3, [r0]
  00164	e1b022a3	 movs        r2, r3, lsr #5
  00168	0a000010	 beq         |$LN4@XllpKpKeyp|
  0016c	e3520001	 cmp         r2, #1
  00170	0a00000a	 beq         |$LN3@XllpKpKeyp|
  00174	e3520002	 cmp         r2, #2
  00178	0a000004	 beq         |$LN2@XllpKpKeyp|
  0017c	e3520003	 cmp         r2, #3
  00180	1a00000d	 bne         |$LN8@XllpKpKeyp|

; 263  :                 case 3:
; 264  :                     gplr3_OutPinMask |= (1u << (XllpKpdGpioDirOutList[i] &31));

  00184	e203301f	 and         r3, r3, #0x1F
  00188	e1844316	 orr         r4, r4, r6, lsl r3

; 265  :                     break;

  0018c	ea00000a	 b           |$LN8@XllpKpKeyp|
  00190		 |$LN2@XllpKpKeyp|

; 260  :                 case 2:
; 261  :                     gplr2_OutPinMask |= (1u << (XllpKpdGpioDirOutList[i] &31));

  00190	e203301f	 and         r3, r3, #0x1F
  00194	e185531a	 orr         r5, r5, r10, lsl r3
  00198	e5815000	 str         r5, [r1]

; 262  :                     break;

  0019c	ea000006	 b           |$LN8@XllpKpKeyp|
  001a0		 |$LN3@XllpKpKeyp|

; 256  :                     break;
; 257  :                 case 1:
; 258  :                     gplr1_OutPinMask |= (1u << (XllpKpdGpioDirOutList[i] &31));

  001a0	e203301f	 and         r3, r3, #0x1F
  001a4	e188831b	 orr         r8, r8, r11, lsl r3
  001a8	e5818014	 str         r8, [r1, #0x14]

; 259  :                     break;

  001ac	ea000002	 b           |$LN8@XllpKpKeyp|
  001b0		 |$LN4@XllpKpKeyp|

; 253  :             {
; 254  :                 case 0:
; 255  :                     gplr0_OutPinMask |= (1u << (XllpKpdGpioDirOutList[i] &31));

  001b0	e203301f	 and         r3, r3, #0x1F
  001b4	e1899317	 orr         r9, r9, r7, lsl r3
  001b8	e5819004	 str         r9, [r1, #4]
  001bc		 |$LN8@XllpKpKeyp|
  001bc	e2800004	 add         r0, r0, #4
  001c0	e25ee001	 subs        lr, lr, #1
  001c4	1affffe5	 bne         |$LL9@XllpKpKeyp|
  001c8	e59d7004	 ldr         r7, [sp, #4]
  001cc	e59da008	 ldr         r10, [sp, #8]
  001d0	e59db00c	 ldr         r11, [sp, #0xC]
  001d4	e59d6000	 ldr         r6, [sp]

; 263  :                 case 3:
; 264  :                     gplr3_OutPinMask |= (1u << (XllpKpdGpioDirOutList[i] &31));

  001d8	e5814024	 str         r4, [r1, #0x24]
  001dc		 |$LN7@XllpKpKeyp|

; 266  :             }
; 267  :         }  // Output pin masks
; 268  : 
; 269  :         gplr0_AllPinsMask = gplr0_InPinMask | gplr0_OutPinMask;

  001dc	e1893006	 orr         r3, r9, r6

; 270  :         gplr1_AllPinsMask = gplr1_InPinMask | gplr1_OutPinMask;

  001e0	e188200b	 orr         r2, r8, r11

; 271  :         gplr2_AllPinsMask = gplr2_InPinMask | gplr2_OutPinMask;
; 272  :         gplr3_AllPinsMask = gplr3_InPinMask | gplr3_OutPinMask;
; 273  : 
; 274  :         xllpKpKIP_Initialized = XLLP_TRUE;

  001e4	e3a06001	 mov         r6, #1
  001e8	e185000a	 orr         r0, r5, r10
  001ec	e184e007	 orr         lr, r4, r7
  001f0	e5812020	 str         r2, [r1, #0x20]
  001f4	e59d2010	 ldr         r2, [sp, #0x10]
  001f8	e5816030	 str         r6, [r1, #0x30]
  001fc	e5813028	 str         r3, [r1, #0x28]
  00200	e581001c	 str         r0, [r1, #0x1C]
  00204	e581e010	 str         lr, [r1, #0x10]
  00208	ea000003	 b           |$LN19@XllpKpKeyp|
  0020c		 |$LN26@XllpKpKeyp|
  0020c	e5915000	 ldr         r5, [r1]
  00210	e591001c	 ldr         r0, [r1, #0x1C]
  00214	e5914024	 ldr         r4, [r1, #0x24]
  00218	e591e010	 ldr         lr, [r1, #0x10]
  0021c		 |$LN19@XllpKpKeyp|

; 275  :     }
; 276  : 
; 277  :     // Main calculation
; 278  :     // Platform-specific optimization: For Mainstone, no keypad pins in GPLR[1:0].
; 279  : 
; 280  :     gpioRegTmp = v_pGPIOReg->GPLR2 ;

  0021c	e5923008	 ldr         r3, [r2, #8]

; 281  :     activity =  (gpioRegTmp ^ gplr2_OutPinMask) & gplr2_AllPinsMask;
; 282  : 
; 283  :     gpioRegTmp = v_pGPIOReg->GPLR3 ;

  00220	e5922100	 ldr         r2, [r2, #0x100]
  00224	e0253003	 eor         r3, r5, r3
  00228	e0031000	 and         r1, r3, r0

; 284  :     activity |= (gpioRegTmp ^ gplr3_OutPinMask) & gplr3_AllPinsMask;

  0022c	e0243002	 eor         r3, r4, r2
  00230	e003300e	 and         r3, r3, lr
  00234	e1830001	 orr         r0, r3, r1

; 285  : 
; 286  :     return(activity);
; 287  : 
; 288  : } // XllpKpKeypressIsInProgress()

  00238	e28dd014	 add         sp, sp, #0x14
  0023c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00240	e12fff1e	 bx          lr
  00244		 |$LN30@XllpKpKeyp|
  00244		 |$LN31@XllpKpKeyp|
  00244	00000000	 DCD         |XllpKpdGpioDirOutList|
  00248		 |$LN32@XllpKpKeyp|
  00248	00000000	 DCD         |?gplr2_OutPinMask@?1??XllpKpKeypressIsInProgress@@9@9|
  0024c		 |$M927|

			 ENDP  ; |XllpKpKeypressIsInProgress|

	EXPORT	|ReadDirectKeys|

  00000			 AREA	 |.pdata|, PDATA
|$T950|	DCD	|$LN20@ReadDirect|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ReadDirectKeys| PROC

; 297  : {

  00000		 |$LN20@ReadDirect|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M947|

; 298  :     XLLP_UINT32_T CurrCount,SaveKpRotaryEncoderCountReg;
; 299  :     static XLLP_UINT32_T PrevCount=START_VALUE;
; 300  :     XLLP_BOOL_T retval;
; 301  :     if(KP_Status & DIRECT_INTR_BIT)

  00004	e59f30a8	 ldr         r3, [pc, #0xA8]
  00008	e5933000	 ldr         r3, [r3]
  0000c	e3130020	 tst         r3, #0x20
  00010	0a000023	 beq         |$LN11@ReadDirect|

; 302  :     {
; 303  :         SaveKpRotaryEncoderCountReg = v_pKeyPadRegs->kpRotaryEncoderCountReg;

  00014	e5902010	 ldr         r2, [r0, #0x10]

; 304  :         CurrCount = SaveKpRotaryEncoderCountReg & COUNT_MASK;
; 305  :         if(SaveKpRotaryEncoderCountReg & OVERFLOW_ROTARY_ENC_0)

  00018	e3120902	 tst         r2, #2, 18

; 306  :         {
; 307  :             v_pKeyPadRegs->kpRotaryEncoderCountReg = START_VALUE;
; 308  :             PrevCount   = START_VALUE;
; 309  :             *key    = SCAN_CODE_SCROLL_UP;                  // Scroll Up

  0001c	13a0400a	 movne       r4, #0xA
  00020	e20230ff	 and         r3, r2, #0xFF
  00024	1a000002	 bne         |$LN17@ReadDirect|

; 310  :         }
; 311  :         else if(SaveKpRotaryEncoderCountReg & UNDERFLOW_ROTARY_ENC_0)

  00028	e3120901	 tst         r2, #1, 18
  0002c	0a000009	 beq         |$LN8@ReadDirect|

; 315  :             *key    = SCAN_CODE_SCROLL_DOWN;                // Scroll Down

  00030	e3a0400b	 mov         r4, #0xB
  00034		 |$LN17@ReadDirect|

; 312  :         {
; 313  :             v_pKeyPadRegs->kpRotaryEncoderCountReg = START_VALUE;
; 314  :             PrevCount   = START_VALUE;

  00034	e59f3074	 ldr         r3, [pc, #0x74]
  00038	e3a0207f	 mov         r2, #0x7F
  0003c	e3a0e07f	 mov         lr, #0x7F

; 315  :             *key    = SCAN_CODE_SCROLL_DOWN;                // Scroll Down

  00040	e5802010	 str         r2, [r0, #0x10]
  00044	e583e000	 str         lr, [r3]
  00048	e5c14000	 strb        r4, [r1]

; 328  :         {
; 329  :             *key    = SCAN_CODE_ACTION;                     // Action Key       
; 330  :         }
; 331  : 
; 332  :         retval = XLLP_TRUE;                                 // Signal availability

  0004c	e3a00001	 mov         r0, #1

; 337  :     }
; 338  : 
; 339  :     return(retval);
; 340  : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$LN8@ReadDirect|

; 316  :         }
; 317  :         else if(CurrCount > PrevCount)

  00058	e59f2050	 ldr         r2, [pc, #0x50]
  0005c	e592e000	 ldr         lr, [r2]
  00060	e153000e	 cmp         r3, lr

; 318  :         {
; 319  :             *key    = SCAN_CODE_SCROLL_UP;

  00064	83a0000a	 movhi       r0, #0xA
  00068	8a000001	 bhi         |$LN15@ReadDirect|

; 320  :             PrevCount   = CurrCount;                        // Scroll Up
; 321  :         }
; 322  :         else if(CurrCount < PrevCount)

  0006c	2a000005	 bcs         |$LN4@ReadDirect|

; 323  :         {
; 324  :             *key    = SCAN_CODE_SCROLL_DOWN;

  00070	e3a0000b	 mov         r0, #0xB
  00074		 |$LN15@ReadDirect|
  00074	e5c10000	 strb        r0, [r1]

; 328  :         {
; 329  :             *key    = SCAN_CODE_ACTION;                     // Action Key       
; 330  :         }
; 331  : 
; 332  :         retval = XLLP_TRUE;                                 // Signal availability

  00078	e3a00001	 mov         r0, #1
  0007c	e5823000	 str         r3, [r2]

; 337  :     }
; 338  : 
; 339  :     return(retval);
; 340  : }

  00080	e8bd4010	 ldmia       sp!, {r4, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$LN4@ReadDirect|

; 325  :             PrevCount   = CurrCount;                        // Scroll Down
; 326  :         }
; 327  :         else if(v_pKeyPadRegs->kpDirectKeyReg & DIRECT_KEY_IN_2)

  00088	e5903008	 ldr         r3, [r0, #8]

; 328  :         {
; 329  :             *key    = SCAN_CODE_ACTION;                     // Action Key       
; 330  :         }
; 331  : 
; 332  :         retval = XLLP_TRUE;                                 // Signal availability

  0008c	e3a00001	 mov         r0, #1
  00090	e3130004	 tst         r3, #4
  00094	13a0300c	 movne       r3, #0xC
  00098	15c13000	 strneb      r3, [r1]

; 337  :     }
; 338  : 
; 339  :     return(retval);
; 340  : }

  0009c	e8bd4010	 ldmia       sp!, {r4, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN11@ReadDirect|

; 333  :     }
; 334  :     else
; 335  :     {
; 336  :         retval = XLLP_FALSE;

  000a4	e3a00000	 mov         r0, #0

; 337  :     }
; 338  : 
; 339  :     return(retval);
; 340  : }

  000a8	e8bd4010	 ldmia       sp!, {r4, lr}
  000ac	e12fff1e	 bx          lr
  000b0		 |$LN21@ReadDirect|
  000b0		 |$LN22@ReadDirect|
  000b0	00000000	 DCD         |?PrevCount@?1??ReadDirectKeys@@9@9|
  000b4		 |$LN23@ReadDirect|
  000b4	00000000	 DCD         |KP_Status|
  000b8		 |$M948|

			 ENDP  ; |ReadDirectKeys|

	EXPORT	|XllpReadScanCode|

  00000			 AREA	 |.pdata|, PDATA
|$T965|	DCD	|$LN8@XllpReadSc|
	DCD	0x40001402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpReadScanCode| PROC

; 349  : {

  00000		 |$LN8@XllpReadSc|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M962|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 350  :     // Initialise to NO Key scan code, same as key UP
; 351  :     XLLP_UINT8_T key = NO_KEY;

  00010	e3a030ff	 mov         r3, #0xFF

; 352  : 
; 353  :     if(!ReadDirectKeys(v_pKeyPadRegs,&key))

  00014	e28d1000	 add         r1, sp, #0
  00018	e5cd3000	 strb        r3, [sp]
  0001c	eb000000	 bl          ReadDirectKeys
  00020	e3500000	 cmp         r0, #0

; 354  :         ReadScanCodeAutomatically(v_pKeyPadRegs,&key);

  00024	028d1000	 addeq       r1, sp, #0
  00028	01a00004	 moveq       r0, r4
  0002c	0b000000	 bleq        ReadScanCodeAutomatically

; 355  : 
; 356  :     // Assign the Key Here
; 357  :     *pui8Data = key;

  00030	e5dd3000	 ldrb        r3, [sp]

; 358  : 
; 359  :     if(*pui8Data == NO_KEY)

  00034	e35300ff	 cmp         r3, #0xFF

; 360  :         return(XLLP_FALSE);

  00038	03a00000	 moveq       r0, #0

; 361  :     else
; 362  :         return(XLLP_TRUE);      // Enjoy

  0003c	13a00001	 movne       r0, #1
  00040	e5c53000	 strb        r3, [r5]

; 363  : }

  00044	e28dd004	 add         sp, sp, #4
  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M963|

			 ENDP  ; |XllpReadScanCode|

	EXPORT	|XllpSetUpKeyPadInterrupts|

  00000			 AREA	 |.pdata|, PDATA
|$T977|	DCD	|$LN8@XllpSetUpK|
	DCD	0x40001100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpSetUpKeyPadInterrupts| PROC

; 371  : {

  00000		 |$LN8@XllpSetUpK|
  00000		 |$M974|
  00000	e3510000	 cmp         r1, #0

; 372  :     KP_Status = v_pKeyPadRegs->kpControlReg;

  00004	e59f2034	 ldr         r2, [pc, #0x34]
  00008	e5903000	 ldr         r3, [r0]
  0000c	e5823000	 str         r3, [r2]

; 373  : 
; 374  :     if(fEnDis)
; 375  :     {
; 376  :         EN_DIRECT_KEYS_INTR();

  00010	e5903000	 ldr         r3, [r0]
  00014	13833001	 orrne       r3, r3, #1
  00018	15803000	 strne       r3, [r0]

; 377  :         EN_MAT_KEYS_INTR();

  0001c	15903000	 ldrne       r3, [r0]
  00020	13833b02	 orrne       r3, r3, #2, 22

; 378  :     }
; 379  :     else
; 380  :     {
; 381  :         DISABLE_DIRECT_KEYS_INTR();
; 382  :         DISABLE_MAT_KEYS_INTR();

  00024	03c33001	 biceq       r3, r3, #1
  00028	05803000	 streq       r3, [r0]
  0002c	05903000	 ldreq       r3, [r0]
  00030	03c33b02	 biceq       r3, r3, #2, 22
  00034	e5803000	 str         r3, [r0]

; 383  :     }
; 384  :     return(XLLP_TRUE);

  00038	e3a00001	 mov         r0, #1

; 385  : }

  0003c	e12fff1e	 bx          lr
  00040		 |$LN9@XllpSetUpK|
  00040		 |$LN10@XllpSetUpK|
  00040	00000000	 DCD         |KP_Status|
  00044		 |$M975|

			 ENDP  ; |XllpSetUpKeyPadInterrupts|

	EXPORT	|XllpKeyPadConfigure|
	IMPORT	|XllpGpioSetAlternateFn|
	IMPORT	|XllpGpioSetOutput0|
	IMPORT	|XllpGpioSetDirectionOut|
	IMPORT	|XllpGpioSetDirectionIn|

  00000			 AREA	 |.pdata|, PDATA
|$T991|	DCD	|$LN7@XllpKeyPad|
	DCD	0x40008602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpKeyPadConfigure| PROC

; 416  : {

  00000		 |$LN7@XllpKeyPad|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd0d0	 sub         sp, sp, #0xD0
  00008		 |$M988|
  00008	e1b04001	 movs        r4, r1
  0000c	e1a05000	 mov         r5, r0

; 417  :     XLLP_BOOL_T retval=XLLP_FALSE;
; 418  :     XLLP_UINT32_T GpioDirOutList[]={7,96,103,104,105,106,107,108};
; 419  :     XLLP_UINT32_T GpioDirInList[]={9,93,94,95,97,98,99,100,101,102};
; 420  :     XLLP_UINT32_T GpioAltFnPinList[]={16,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108};
; 421  :     XLLP_UINT32_T GpioAltFnValList[]={16,1,1,3,3,3,3,3,1,1,1,2,2,2,2,2,2};

  00010	e3a03007	 mov         r3, #7
  00014	e58d3000	 str         r3, [sp]
  00018	e3a0305f	 mov         r3, #0x5F
  0001c	e58d302c	 str         r3, [sp, #0x2C]
  00020	e3a03061	 mov         r3, #0x61
  00024	e58d3030	 str         r3, [sp, #0x30]
  00028	e3a03062	 mov         r3, #0x62
  0002c	e58d3034	 str         r3, [sp, #0x34]
  00030	e3a03063	 mov         r3, #0x63
  00034	e58d3038	 str         r3, [sp, #0x38]
  00038	e3a03064	 mov         r3, #0x64
  0003c	e58d303c	 str         r3, [sp, #0x3C]
  00040	e3a03065	 mov         r3, #0x65
  00044	e58d3040	 str         r3, [sp, #0x40]
  00048	e3a03066	 mov         r3, #0x66
  0004c	e58d3044	 str         r3, [sp, #0x44]
  00050	e3a03010	 mov         r3, #0x10
  00054	e58d308c	 str         r3, [sp, #0x8C]
  00058	e3a0305d	 mov         r3, #0x5D
  0005c	e58d3090	 str         r3, [sp, #0x90]
  00060	e3a0305e	 mov         r3, #0x5E
  00064	e58d3094	 str         r3, [sp, #0x94]
  00068	e3a0305f	 mov         r3, #0x5F
  0006c	e58d3098	 str         r3, [sp, #0x98]
  00070	e3a03060	 mov         r3, #0x60
  00074	e58d309c	 str         r3, [sp, #0x9C]
  00078	e3a03061	 mov         r3, #0x61
  0007c	e58d30a0	 str         r3, [sp, #0xA0]
  00080	e3a03062	 mov         r3, #0x62
  00084	e58d30a4	 str         r3, [sp, #0xA4]
  00088	e3a03063	 mov         r3, #0x63
  0008c	e58d30a8	 str         r3, [sp, #0xA8]
  00090	e3a03064	 mov         r3, #0x64
  00094	e58d30ac	 str         r3, [sp, #0xAC]
  00098	e3a03065	 mov         r3, #0x65
  0009c	e58d30b0	 str         r3, [sp, #0xB0]
  000a0	e3a03066	 mov         r3, #0x66
  000a4	e58d30b4	 str         r3, [sp, #0xB4]
  000a8	e3a03067	 mov         r3, #0x67
  000ac	e58d30b8	 str         r3, [sp, #0xB8]
  000b0	e3a03068	 mov         r3, #0x68
  000b4	e58d30bc	 str         r3, [sp, #0xBC]
  000b8	e3a03069	 mov         r3, #0x69
  000bc	e58d30c0	 str         r3, [sp, #0xC0]
  000c0	e3a0306a	 mov         r3, #0x6A
  000c4	e58d30c4	 str         r3, [sp, #0xC4]
  000c8	e3a0306b	 mov         r3, #0x6B
  000cc	e58d30c8	 str         r3, [sp, #0xC8]
  000d0	e3a0306c	 mov         r3, #0x6C
  000d4	e58d30cc	 str         r3, [sp, #0xCC]
  000d8	e3a03010	 mov         r3, #0x10
  000dc	e58d3048	 str         r3, [sp, #0x48]
  000e0	e3a03001	 mov         r3, #1
  000e4	e58d304c	 str         r3, [sp, #0x4C]
  000e8	e3a03001	 mov         r3, #1
  000ec	e58d3050	 str         r3, [sp, #0x50]
  000f0	e3a03003	 mov         r3, #3
  000f4	e3a02060	 mov         r2, #0x60
  000f8	e3a01067	 mov         r1, #0x67
  000fc	e3a00068	 mov         r0, #0x68
  00100	e3a0e069	 mov         lr, #0x69
  00104	e3a0606a	 mov         r6, #0x6A
  00108	e3a0706b	 mov         r7, #0x6B
  0010c	e3a0806c	 mov         r8, #0x6C
  00110	e3a09009	 mov         r9, #9
  00114	e3a0a05d	 mov         r10, #0x5D
  00118	e3a0b05e	 mov         r11, #0x5E
  0011c	e58d3054	 str         r3, [sp, #0x54]
  00120	e58d2004	 str         r2, [sp, #4]
  00124	e58d1008	 str         r1, [sp, #8]
  00128	e58d000c	 str         r0, [sp, #0xC]
  0012c	e58de010	 str         lr, [sp, #0x10]
  00130	e58d6014	 str         r6, [sp, #0x14]
  00134	e58d7018	 str         r7, [sp, #0x18]
  00138	e58d801c	 str         r8, [sp, #0x1C]
  0013c	e58d9020	 str         r9, [sp, #0x20]
  00140	e58da024	 str         r10, [sp, #0x24]
  00144	e58db028	 str         r11, [sp, #0x28]
  00148	e3a03003	 mov         r3, #3
  0014c	e58d3058	 str         r3, [sp, #0x58]
  00150	e3a03003	 mov         r3, #3
  00154	e58d305c	 str         r3, [sp, #0x5C]
  00158	e3a03002	 mov         r3, #2
  0015c	e58d3084	 str         r3, [sp, #0x84]
  00160	e3a03002	 mov         r3, #2
  00164	e3a02003	 mov         r2, #3
  00168	e3a01003	 mov         r1, #3
  0016c	e3a00001	 mov         r0, #1
  00170	e3a0e001	 mov         lr, #1
  00174	e3a07001	 mov         r7, #1
  00178	e3a08002	 mov         r8, #2
  0017c	e3a09002	 mov         r9, #2
  00180	e3a0a002	 mov         r10, #2
  00184	e3a0b002	 mov         r11, #2
  00188	e58d3088	 str         r3, [sp, #0x88]
  0018c	e3a06000	 mov         r6, #0
  00190	e58d2060	 str         r2, [sp, #0x60]
  00194	e58d1064	 str         r1, [sp, #0x64]
  00198	e58d0068	 str         r0, [sp, #0x68]
  0019c	e58de06c	 str         lr, [sp, #0x6C]
  001a0	e58d7070	 str         r7, [sp, #0x70]
  001a4	e58d8074	 str         r8, [sp, #0x74]
  001a8	e58d9078	 str         r9, [sp, #0x78]
  001ac	e58da07c	 str         r10, [sp, #0x7C]
  001b0	e58db080	 str         r11, [sp, #0x80]

; 422  :     if(v_pGPIOReg != 0)

  001b4	0a00000c	 beq         |$LN2@XllpKeyPad|

; 423  :     {
; 424  :         XllpGpioSetDirectionIn(v_pGPIOReg, GpioDirInList);

  001b8	e28d1020	 add         r1, sp, #0x20
  001bc	e1a00004	 mov         r0, r4
  001c0	eb000000	 bl          XllpGpioSetDirectionIn

; 425  :         XllpGpioSetDirectionOut(v_pGPIOReg, GpioDirOutList);

  001c4	e28d1000	 add         r1, sp, #0
  001c8	e1a00004	 mov         r0, r4
  001cc	eb000000	 bl          XllpGpioSetDirectionOut

; 426  :         XllpGpioSetOutput0(v_pGPIOReg, GpioDirOutList);

  001d0	e28d1000	 add         r1, sp, #0
  001d4	e1a00004	 mov         r0, r4
  001d8	eb000000	 bl          XllpGpioSetOutput0

; 427  :         XllpGpioSetAlternateFn(v_pGPIOReg, GpioAltFnPinList, GpioAltFnValList);

  001dc	e28d2048	 add         r2, sp, #0x48
  001e0	e28d108c	 add         r1, sp, #0x8C
  001e4	e1a00004	 mov         r0, r4
  001e8	eb000000	 bl          XllpGpioSetAlternateFn
  001ec		 |$LN2@XllpKeyPad|

; 428  :     }
; 429  : 
; 430  : 
; 431  :     if(v_pKeyPadRegs != 0)

  001ec	e3550000	 cmp         r5, #0

; 432  :     {
; 433  :         // Init the control regs for direct keys
; 434  :         v_pKeyPadRegs->kpControlReg = (MATRIX_KP_NUMBER_OF_ROWS |  MATRIX_KP_NUMBER_OF_COLUMNS |
; 435  :                                         MAT_SCAN_LINE0 | MAT_SCAN_LINE1 | MAT_SCAN_LINE2 |
; 436  :                                         MAT_SCAN_LINE3 | MAT_SCAN_LINE4 | MAT_SCAN_LINE5 |
; 437  :                                         MAT_SCAN_LINE6 | MAT_SCAN_LINE7 | IGNORE_MULTIPLE_KEY_PRESS |
; 438  :                                         AUTO_SCAN_ON_ACTIVITY | MATRIX_INTR_ENABLE |
; 439  :                                         MATRIX_KP_ENABLE | ROTARY_ENCODER_ZERO_DEB |
; 440  :                                         DIRECT_KP_INTR_ENABLE | DIRECT_KEY_NUMS |
; 441  :                                         DIRECT_KP_ENABLE | ROTARY_ENCODER_0_ENABLE) ;    //NMD

  001f0	159f301c	 ldrne       r3, [pc, #0x1C]

; 442  : 
; 443  :         v_pKeyPadRegs->kpRotaryEncoderCountReg = START_VALUE;

  001f4	13a0207f	 movne       r2, #0x7F

; 444  : 
; 445  :         retval = XLLP_TRUE;     

  001f8	13a06001	 movne       r6, #1
  001fc	15853000	 strne       r3, [r5]
  00200	15852010	 strne       r2, [r5, #0x10]

; 446  :     }
; 447  :     return(retval);
; 448  : }

  00204	e1a00006	 mov         r0, r6
  00208	e28dd0d0	 add         sp, sp, #0xD0
  0020c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00210	e12fff1e	 bx          lr
  00214		 |$LN8@XllpKeyPad|
  00214		 |$LN9@XllpKeyPad|
  00214	3f3ff8d7	 DCD         0x3f3ff8d7
  00218		 |$M989|

			 ENDP  ; |XllpKeyPadConfigure|

	END
