; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_i2c.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XllpI2cInit|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_i2c.c

  00000			 AREA	 |.pdata|, PDATA
|$T973|	DCD	|$LN5@XllpI2cIni|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpI2cInit| PROC

; 59   : {

  00000		 |$LN5@XllpI2cIni|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M970|
  00004	e1a04000	 mov         r4, r0

; 60   : 	I2C_regs->ICR = 0;

  00008	e3a00000	 mov         r0, #0
  0000c	e5840010	 str         r0, [r4, #0x10]

; 61   : 
; 62   : 	clkMgr->cken |=  XLLP_CLKEN_I2C;

  00010	e592e004	 ldr         lr, [r2, #4]

; 63   : 
; 64   : 	gpio->GPDR3 |= (XLLP_GPIO_BIT_SCL | XLLP_GPIO_BIT_SDA);
; 65   : 
; 66   : 	gpio->GAFR3_U |=  ( XLLP_GPIO_AF_BIT_SCL | XLLP_GPIO_AF_BIT_SDA);
; 67   : 
; 68   : 	/* Setup I2C slave address */
; 69   : 	I2C_regs->ISAR =  dev_id;
; 70   : 
; 71   : 	I2C_regs->ICR = XLLP_ICR_SCLEA;
; 72   : 	I2C_regs->ICR |= XLLP_ICR_UIE;
; 73   : 
; 74   : 	return(XLLP_FALSE);

  00014	e3a00000	 mov         r0, #0
  00018	e38ee901	 orr         lr, lr, #1, 18
  0001c	e582e004	 str         lr, [r2, #4]
  00020	e591210c	 ldr         r2, [r1, #0x10C]
  00024	e3a0e020	 mov         lr, #0x20
  00028	e3822606	 orr         r2, r2, #6, 12
  0002c	e581210c	 str         r2, [r1, #0x10C]
  00030	e5912070	 ldr         r2, [r1, #0x70]
  00034	e3822b05	 orr         r2, r2, #5, 22
  00038	e5812070	 str         r2, [r1, #0x70]
  0003c	e5843020	 str         r3, [r4, #0x20]
  00040	e584e010	 str         lr, [r4, #0x10]
  00044	e5943010	 ldr         r3, [r4, #0x10]
  00048	e3833040	 orr         r3, r3, #0x40
  0004c	e5843010	 str         r3, [r4, #0x10]

; 75   : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M971|

			 ENDP  ; |XllpI2cInit|

	EXPORT	|XllpPI2cInit|

  00000			 AREA	 |.pdata|, PDATA
|$T985|	DCD	|$LN5@XllpPI2cIn|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpPI2cInit| PROC

; 94   : {

  00000		 |$LN5@XllpPI2cIn|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M982|
  00004	e1a0e000	 mov         lr, r0

; 95   : 
; 96   : 	clkMgr->cken |=  XLLP_CLKEN_PWRI2C;

  00008	e5921004	 ldr         r1, [r2, #4]

; 97   : 
; 98   : 	I2C_regs->PCFR |= 0x40;
; 99   : 	
; 100  : 	I2C_regs->ICR = 0;
; 101  : 	/* Setup I2C slave address */
; 102  : 	I2C_regs->ISAR =  dev_id;
; 103  : 
; 104  : 	I2C_regs->ICR = XLLP_ICR_SCLEA;
; 105  : 	I2C_regs->ICR |= XLLP_ICR_UIE;
; 106  : 
; 107  : 	return(XLLP_FALSE);

  0000c	e3a00000	 mov         r0, #0
  00010	e3811902	 orr         r1, r1, #2, 18
  00014	e5821004	 str         r1, [r2, #4]
  00018	e59e201c	 ldr         r2, [lr, #0x1C]
  0001c	e3a01000	 mov         r1, #0
  00020	e3822040	 orr         r2, r2, #0x40
  00024	e58e201c	 str         r2, [lr, #0x1C]
  00028	e58e1190	 str         r1, [lr, #0x190]
  0002c	e58e31a0	 str         r3, [lr, #0x1A0]
  00030	e3a03020	 mov         r3, #0x20
  00034	e58e3190	 str         r3, [lr, #0x190]
  00038	e59e3190	 ldr         r3, [lr, #0x190]
  0003c	e3833040	 orr         r3, r3, #0x40
  00040	e58e3190	 str         r3, [lr, #0x190]

; 108  : }

  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$M983|

			 ENDP  ; |XllpPI2cInit|

	EXPORT	|XllpI2cRxFull|
	IMPORT	|XllpOstDelayMilliSeconds|

  00000			 AREA	 |.pdata|, PDATA
|$T1002| DCD	|$LN12@XllpI2cRxF|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpI2cRxFull| PROC

; 118  : {

  00000		 |$LN12@XllpI2cRxF|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M999|
  00004	e1b04002	 movs        r4, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 119  : 	XLLP_UINT32_T temp;
; 120  : 
; 121  : 	while (timeout--)

  00010	0a000009	 beq         |$LN8@XllpI2cRxF|
  00014		 |$LL3@XllpI2cRxF|

; 122  : 	{
; 123  : 		temp = I2C_regs->ISR;

  00014	e595e018	 ldr         lr, [r5, #0x18]
  00018	e2444001	 sub         r4, r4, #1

; 124  : 		if ((temp & XLLP_ISR_IRF) == XLLP_ISR_IRF)

  0001c	e20e3080	 and         r3, lr, #0x80
  00020	e3530080	 cmp         r3, #0x80
  00024	0a000007	 beq         |$LN7@XllpI2cRxF|

; 128  : 		}
; 129  : 		// delay 1 ms here
; 130  : 		XllpOstDelayMilliSeconds(pOSTRegs, 1);

  00028	e3a01001	 mov         r1, #1
  0002c	e1a00006	 mov         r0, r6
  00030	eb000000	 bl          XllpOstDelayMilliSeconds
  00034	e3540000	 cmp         r4, #0
  00038	1afffff5	 bne         |$LL3@XllpI2cRxF|
  0003c		 |$LN8@XllpI2cRxF|

; 131  : 	}
; 132  : 
; 133  :   return XLLP_TRUE;

  0003c	e3a00001	 mov         r0, #1

; 134  : }

  00040	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN7@XllpI2cRxF|

; 125  : 		{
; 126  : 			I2C_regs->ISR = temp | XLLP_ISR_IRF;

  00048	e38e3080	 orr         r3, lr, #0x80
  0004c	e5853018	 str         r3, [r5, #0x18]

; 127  : 			return XLLP_FALSE;

  00050	e3a00000	 mov         r0, #0

; 134  : }

  00054	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M1000|

			 ENDP  ; |XllpI2cRxFull|

	EXPORT	|XllpI2cTxEmpty|

  00000			 AREA	 |.pdata|, PDATA
|$T1019| DCD	|$LN13@XllpI2cTxE|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpI2cTxEmpty| PROC

; 142  : {

  00000		 |$LN13@XllpI2cTxE|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M1016|
  00004	e1b05002	 movs        r5, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 143  : 	XLLP_UINT32_T temp;
; 144  : 
; 145  : 	while (timeout--)

  00010	0a000009	 beq         |$LN9@XllpI2cTxE|
  00014		 |$LL4@XllpI2cTxE|

; 146  : 	{
; 147  : 		temp = I2C_regs->ISR;

  00014	e5940018	 ldr         r0, [r4, #0x18]
  00018	e2455001	 sub         r5, r5, #1

; 148  : 		if((temp & XLLP_ISR_ITE) == XLLP_ISR_ITE)

  0001c	e2003040	 and         r3, r0, #0x40
  00020	e3530040	 cmp         r3, #0x40
  00024	0a000007	 beq         |$LN8@XllpI2cTxE|

; 156  : 		}
; 157  : 		// delay 1 ms here
; 158  : 		XllpOstDelayMilliSeconds(pOSTRegs, 1);

  00028	e3a01001	 mov         r1, #1
  0002c	e1a00006	 mov         r0, r6
  00030	eb000000	 bl          XllpOstDelayMilliSeconds
  00034	e3550000	 cmp         r5, #0
  00038	1afffff5	 bne         |$LL4@XllpI2cTxE|
  0003c		 |$LN9@XllpI2cTxE|

; 159  : 	}
; 160  : 	return XLLP_TRUE;

  0003c	e3a00001	 mov         r0, #1

; 161  : }

  00040	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN8@XllpI2cTxE|

; 149  : 		{
; 150  : 			I2C_regs->ISR = temp | XLLP_ISR_ITE;
; 151  : 			if ((temp & XLLP_ISR_ALD) == XLLP_ISR_ALD)

  00048	e2002020	 and         r2, r0, #0x20
  0004c	e3803040	 orr         r3, r0, #0x40
  00050	e3520020	 cmp         r2, #0x20
  00054	e5843018	 str         r3, [r4, #0x18]

; 152  : 			{
; 153  : 				I2C_regs->ISR |= XLLP_ISR_ALD;

  00058	05943018	 ldreq       r3, [r4, #0x18]

; 154  : 			}
; 155  : 			return XLLP_FALSE;

  0005c	e3a00000	 mov         r0, #0
  00060	03833020	 orreq       r3, r3, #0x20
  00064	05843018	 streq       r3, [r4, #0x18]

; 161  : }

  00068	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0006c	e12fff1e	 bx          lr
  00070		 |$M1017|

			 ENDP  ; |XllpI2cTxEmpty|

	EXPORT	|XllpI2CWrite|

  00000			 AREA	 |.pdata|, PDATA
|$T1041| DCD	|$LN14@XllpI2CWri|
	DCD	0x40003301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpI2CWrite| PROC

; 165  : {

  00000		 |$LN14@XllpI2CWri|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M1038|
  00004	e1a08003	 mov         r8, r3
  00008	e1a09001	 mov         r9, r1
  0000c	e1a04000	 mov         r4, r0

; 166  : 	XLLP_UINT32_T reg;
; 167  : 	int timer = 0;
; 168  : 	
; 169  : 	I2C_regs->IDBR = (slaveAddr << 1) & ~XLLP_IDBR_MODE;

  00010	e1a02082	 mov         r2, r2, lsl #1
  00014	e5842008	 str         r2, [r4, #8]

; 170  : 	reg = I2C_regs->ICR;

  00018	e594e010	 ldr         lr, [r4, #0x10]
  0001c	e3e03a01	 mvn         r3, #1, 20
  00020	e2232002	 eor         r2, r3, #2
  00024	e00e2002	 and         r2, lr, r2

; 171  : 	reg |= (XLLP_ICR_START | XLLP_ICR_TB);

  00028	e3822009	 orr         r2, r2, #9

; 172  : 	reg &= ~(XLLP_ICR_STOP | XLLP_ICR_ALDIE);
; 173  : 	I2C_regs->ICR = reg;

  0002c	e5842010	 str         r2, [r4, #0x10]

; 174  : 
; 175  : 	if (XllpI2cTxEmpty(I2C_regs, pOSTRegs,20) == XLLP_TRUE)

  00030	e3a02014	 mov         r2, #0x14
  00034	eb000000	 bl          XllpI2cTxEmpty
  00038	e3500001	 cmp         r0, #1
  0003c	1a000002	 bne         |$LN9@XllpI2CWri|
  00040		 |$LN10@XllpI2CWri|

; 176  : 	{
; 177  : 		return XLLP_TRUE;

  00040	e3a00001	 mov         r0, #1

; 206  : }

  00044	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00048	e12fff1e	 bx          lr
  0004c		 |$LN9@XllpI2CWri|

; 178  : 	}
; 179  : 
; 180  : 	// Send all the bytes
; 181  : 	while (bytesCount--)

  0004c	e59d501c	 ldr         r5, [sp, #0x1C]
  00050	e3550000	 cmp         r5, #0
  00054	0a000016	 beq         |$LN11@XllpI2CWri|
  00058	e3a03a01	 mov         r3, #1, 20
  0005c	e59d6020	 ldr         r6, [sp, #0x20]
  00060	e3837008	 orr         r7, r3, #8
  00064		 |$LL5@XllpI2CWri|

; 182  : 	{
; 183  : 		I2C_regs->IDBR = (XLLP_UINT32_T)(*bytesBuf++);

  00064	e4d83001	 ldrb        r3, [r8], #1
  00068	e2555001	 subs        r5, r5, #1
  0006c	e5843008	 str         r3, [r4, #8]

; 184  : 		
; 185  : 		reg = I2C_regs->ICR;

  00070	e5943010	 ldr         r3, [r4, #0x10]

; 186  : 		
; 187  : 		reg &= ~XLLP_ICR_START;

  00074	e3c33001	 bic         r3, r3, #1

; 188  : 		reg |= (XLLP_ICR_ALDIE | XLLP_ICR_TB);

  00078	e1833007	 orr         r3, r3, r7

; 189  : 		
; 190  : 		if ((bytesCount == 0) && bSendStop)

  0007c	1a000002	 bne         |$LN3@XllpI2CWri|
  00080	e3560000	 cmp         r6, #0

; 191  : 			reg |= XLLP_ICR_STOP;

  00084	13833002	 orrne       r3, r3, #2
  00088	1a000000	 bne         |$LN2@XllpI2CWri|
  0008c		 |$LN3@XllpI2CWri|

; 192  : 		else
; 193  : 			reg &= ~XLLP_ICR_STOP;

  0008c	e3c33002	 bic         r3, r3, #2
  00090		 |$LN2@XllpI2CWri|

; 194  : 
; 195  : 		I2C_regs->ICR = reg;
; 196  : 
; 197  : 		if (XllpI2cTxEmpty(I2C_regs, pOSTRegs, 250) == XLLP_TRUE)

  00090	e3a020fa	 mov         r2, #0xFA
  00094	e1a01009	 mov         r1, r9
  00098	e1a00004	 mov         r0, r4
  0009c	e5843010	 str         r3, [r4, #0x10]
  000a0	eb000000	 bl          XllpI2cTxEmpty
  000a4	e3500001	 cmp         r0, #1
  000a8	0affffe4	 beq         |$LN10@XllpI2CWri|

; 178  : 	}
; 179  : 
; 180  : 	// Send all the bytes
; 181  : 	while (bytesCount--)

  000ac	e3550000	 cmp         r5, #0
  000b0	1affffeb	 bne         |$LL5@XllpI2CWri|
  000b4		 |$LN11@XllpI2CWri|

; 198  : 		{
; 199  : 			return XLLP_TRUE;
; 200  : 		}
; 201  : 	}
; 202  : 
; 203  : 	// Clear the STOP bit always
; 204  : 	I2C_regs->ICR &= ~XLLP_ICR_STOP;

  000b4	e5943010	 ldr         r3, [r4, #0x10]

; 205  : 	return XLLP_FALSE;

  000b8	e3a00000	 mov         r0, #0
  000bc	e3c33002	 bic         r3, r3, #2
  000c0	e5843010	 str         r3, [r4, #0x10]

; 206  : }

  000c4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000c8	e12fff1e	 bx          lr
  000cc		 |$M1039|

			 ENDP  ; |XllpI2CWrite|

	EXPORT	|XllpI2CRead|

  00000			 AREA	 |.pdata|, PDATA
|$T1066| DCD	|$LN17@XllpI2CRea|
	DCD	0x40003801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpI2CRead| PROC

; 209  : {

  00000		 |$LN17@XllpI2CRea|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M1063|
  00004	e1a08003	 mov         r8, r3
  00008	e1a09001	 mov         r9, r1
  0000c	e1a04000	 mov         r4, r0

; 210  : 	XLLP_UINT32_T reg;
; 211  : 
; 212  : 	I2C_regs->IDBR = (slaveAddr << 1) | XLLP_IDBR_MODE;

  00010	e1a02082	 mov         r2, r2, lsl #1
  00014	e3822001	 orr         r2, r2, #1
  00018	e5842008	 str         r2, [r4, #8]

; 213  : 
; 214  : 	reg = I2C_regs->ICR;

  0001c	e594e010	 ldr         lr, [r4, #0x10]
  00020	e3e03a01	 mvn         r3, #1, 20
  00024	e2232002	 eor         r2, r3, #2
  00028	e00e2002	 and         r2, lr, r2

; 215  : 	reg |= (XLLP_ICR_START | XLLP_ICR_TB);

  0002c	e3822009	 orr         r2, r2, #9

; 216  : 	reg &= ~(XLLP_ICR_STOP | XLLP_ICR_ALDIE);
; 217  : 	I2C_regs->ICR = reg;

  00030	e5842010	 str         r2, [r4, #0x10]

; 218  : 
; 219  : 	if (XllpI2cTxEmpty(I2C_regs, pOSTRegs,20) == XLLP_TRUE)

  00034	e3a02014	 mov         r2, #0x14
  00038	eb000000	 bl          XllpI2cTxEmpty
  0003c	e3500001	 cmp         r0, #1
  00040	1a000002	 bne         |$LN11@XllpI2CRea|
  00044		 |$LN12@XllpI2CRea|

; 220  : 	{
; 221  : 		return XLLP_TRUE;

  00044	e3a00001	 mov         r0, #1

; 253  : }

  00048	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$LN11@XllpI2CRea|

; 222  : 	}
; 223  : 
; 224  : 	while (bytesCount--)

  00050	e59d501c	 ldr         r5, [sp, #0x1C]
  00054	e3550000	 cmp         r5, #0
  00058	0a00001a	 beq         |$LN13@XllpI2CRea|
  0005c	e3a03a01	 mov         r3, #1, 20
  00060	e59d6020	 ldr         r6, [sp, #0x20]
  00064	e3837008	 orr         r7, r3, #8
  00068		 |$LL7@XllpI2CRea|

; 225  : 	{
; 226  : 		reg = I2C_regs->ICR;

  00068	e5943010	 ldr         r3, [r4, #0x10]
  0006c	e2555001	 subs        r5, r5, #1

; 227  : 		reg &= ~XLLP_ICR_START;

  00070	e3c33001	 bic         r3, r3, #1

; 228  : 		reg |= XLLP_ICR_ALDIE | XLLP_ICR_TB;

  00074	e1833007	 orr         r3, r3, r7

; 229  : 		if (bytesCount == 0)

  00078	1a000005	 bne         |$LN5@XllpI2CRea|

; 230  : 		{
; 231  : 			reg |= XLLP_ICR_ACKNACK;

  0007c	e3833004	 orr         r3, r3, #4

; 232  : 			if (bSendStop)

  00080	e3560000	 cmp         r6, #0

; 233  : 				reg |= XLLP_ICR_STOP;

  00084	13833002	 orrne       r3, r3, #2
  00088	1a000002	 bne         |$LN2@XllpI2CRea|

; 234  : 			else
; 235  : 				reg &= ~XLLP_ICR_STOP;

  0008c	e3c33002	 bic         r3, r3, #2

; 236  : 		} else

  00090	ea000000	 b           |$LN2@XllpI2CRea|
  00094		 |$LN5@XllpI2CRea|

; 237  : 		{
; 238  : 			reg &= ~XLLP_ICR_ACKNACK;

  00094	e3c33004	 bic         r3, r3, #4
  00098		 |$LN2@XllpI2CRea|

; 239  : 		}
; 240  : 		I2C_regs->ICR = reg;
; 241  : 
; 242  : 		if (XllpI2cRxFull(I2C_regs, pOSTRegs, 60) == XLLP_TRUE)

  00098	e3a0203c	 mov         r2, #0x3C
  0009c	e1a01009	 mov         r1, r9
  000a0	e1a00004	 mov         r0, r4
  000a4	e5843010	 str         r3, [r4, #0x10]
  000a8	eb000000	 bl          XllpI2cRxFull
  000ac	e3500001	 cmp         r0, #1
  000b0	0affffe3	 beq         |$LN12@XllpI2CRea|

; 243  : 		{	
; 244  : 			return XLLP_TRUE;
; 245  : 		}
; 246  : 		reg = I2C_regs->IDBR & 0xFF;

  000b4	e5943008	 ldr         r3, [r4, #8]
  000b8	e3550000	 cmp         r5, #0
  000bc	e20330ff	 and         r3, r3, #0xFF

; 247  : 		*bytesBuf++ = (XLLP_UINT8_T)reg;

  000c0	e4c83001	 strb        r3, [r8], #1
  000c4	1affffe7	 bne         |$LL7@XllpI2CRea|
  000c8		 |$LN13@XllpI2CRea|

; 248  : 	}
; 249  : 
; 250  : 	I2C_regs->ICR &= ~(XLLP_ICR_STOP | XLLP_ICR_ACKNACK);

  000c8	e5943010	 ldr         r3, [r4, #0x10]

; 251  : 
; 252  : 	return XLLP_FALSE;

  000cc	e3a00000	 mov         r0, #0
  000d0	e3c33006	 bic         r3, r3, #6
  000d4	e5843010	 str         r3, [r4, #0x10]

; 253  : }

  000d8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$M1064|

			 ENDP  ; |XllpI2CRead|

	END
