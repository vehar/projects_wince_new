; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_ac97.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XllpAc97GetStatus|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_ac97.c

  00000			 AREA	 |.pdata|, PDATA
|$T1408| DCD	|$LN12@XllpAc97Ge|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97GetStatus| PROC

; 238  : {

  00000		 |$LN12@XllpAc97Ge|
  00000		 |$M1405|
  00000	e3520000	 cmp         r2, #0

; 239  : 	if (XLLP_AC97_CODEC_PRIMARY == codecSel) 
; 240  : 	{
; 241  : 		pStat->codecReady = (pAc97Reg->GSR & XLLP_AC97_GSR_PCRDY_MSK) ? XLLP_TRUE : XLLP_FALSE;

  00004	e591301c	 ldr         r3, [r1, #0x1C]
  00008	1a000001	 bne         |$LN2@XllpAc97Ge|
  0000c	e3130c01	 tst         r3, #1, 24
  00010	ea000000	 b           |$LN9@XllpAc97Ge|
  00014		 |$LN2@XllpAc97Ge|

; 242  :     }
; 243  : 	else
; 244  : 	{
; 245  : 	    pStat->codecReady = (pAc97Reg->GSR & XLLP_AC97_GSR_SCRDY_MSK) ? XLLP_TRUE : XLLP_FALSE;

  00014	e3130c02	 tst         r3, #2, 24
  00018		 |$LN9@XllpAc97Ge|
  00018	13a03001	 movne       r3, #1
  0001c	15803000	 strne       r3, [r0]
  00020	03a03000	 moveq       r3, #0
  00024	05803000	 streq       r3, [r0]

; 246  : 	}
; 247  : } // Ac97CtrlGetStatus()

  00028	e12fff1e	 bx          lr
  0002c		 |$M1406|

			 ENDP  ; |XllpAc97GetStatus|

	EXPORT	|XllpAc97ColdReset|
	IMPORT	|XllpGpioSetOutputState1|
	IMPORT	|XllpOstDelayMicroSeconds|

  00000			 AREA	 |.pdata|, PDATA
|$T1426| DCD	|$LN17@XllpAc97Co|
	DCD	0x40003402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97ColdReset| PROC

; 569  : { 

  00000		 |$LN17@XllpAc97Co|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M1423|
  00008	e1a05000	 mov         r5, r0

; 570  :     XLLP_AC97_ERROR_T	status = XLLP_AC97_NO_ERROR; 
; 571  :     P_XLLP_AC97_T		pAC97 = pAc97ctxt->pAc97Reg;
; 572  :     P_XLLP_OST_T 		pOstRegs = pAc97ctxt->pOstRegs;

  0000c	e595900c	 ldr         r9, [r5, #0xC]
  00010	e5958008	 ldr         r8, [r5, #8]

; 573  :     XLLP_BOOL_T			priCodecReady, secCodecReady; 
; 574  :     XLLP_UINT32_T		timeRemaining; 
; 575  : 
; 576  :     pAC97->GCR = 0;    

  00014	e3a03000	 mov         r3, #0

; 577  : 
; 578  :     // Hold reset active for a minimum time
; 579  : 	XllpOstDelayMicroSeconds(pOstRegs, XLLP_AC97_COLD_HOLDTIME);

  00018	e1a00009	 mov         r0, r9
  0001c	e3a01064	 mov         r1, #0x64
  00020	e588300c	 str         r3, [r8, #0xC]
  00024	e3a07000	 mov         r7, #0
  00028	eb000000	 bl          XllpOstDelayMicroSeconds

; 580  : 
; 581  :     // Deactivate cold reset condition
; 582  : 	pAC97->GCR |= XLLP_AC97_GCR_COLD_RESET_MSK; 

  0002c	e598300c	 ldr         r3, [r8, #0xC]

; 583  :     
; 584  :     // Set nReset high. This is a workaround for some strange behavior of nReset pin.
; 585  :     {
; 586  : 	    XLLP_UINT32_T pins[6];
; 587  :     	pins[0] = 1;

  00030	e3a02001	 mov         r2, #1

; 588  :     	pins[1] = 113;

  00034	e3a0e071	 mov         lr, #0x71
  00038	e3833002	 orr         r3, r3, #2
  0003c	e588300c	 str         r3, [r8, #0xC]

; 589  :     	XllpGpioSetOutputState1(pAc97ctxt->pGpioReg, pins);

  00040	e5950000	 ldr         r0, [r5]
  00044	e28d1000	 add         r1, sp, #0
  00048	e58d2000	 str         r2, [sp]
  0004c	e58de004	 str         lr, [sp, #4]
  00050	eb000000	 bl          XllpGpioSetOutputState1

; 590  :     }
; 591  :     	
; 592  :     // And wait with timeout for all codecs to respond.
; 593  : 
; 594  :     priCodecReady = XLLP_FALSE;
; 595  : 	if (XLLP_FALSE == pAc97ctxt->useSecondaryCodec)

  00054	e5953018	 ldr         r3, [r5, #0x18]

; 596  : 	{
; 597  : 	    secCodecReady = XLLP_TRUE;
; 598  : 	}
; 599  : 	else
; 600  : 	{
; 601  : 	    secCodecReady = XLLP_FALSE;
; 602  : 	}
; 603  :     timeRemaining = pAc97ctxt->maxSetupTimeOutUs;

  00058	e5955014	 ldr         r5, [r5, #0x14]
  0005c	e3a06000	 mov         r6, #0
  00060	e3530000	 cmp         r3, #0
  00064	03a04001	 moveq       r4, #1
  00068	13a04000	 movne       r4, #0
  0006c		 |$LL8@XllpAc97Co|

; 604  :     do
; 605  :     {
; 606  : 		XllpOstDelayMicroSeconds(pOstRegs, 1);

  0006c	e3a01001	 mov         r1, #1
  00070	e1a00009	 mov         r0, r9
  00074	eb000000	 bl          XllpOstDelayMicroSeconds

; 607  :         if (pAC97->GSR & XLLP_AC97_GSR_PCRDY_MSK)

  00078	e598301c	 ldr         r3, [r8, #0x1C]
  0007c	e3130c01	 tst         r3, #1, 24

; 608  :             priCodecReady = XLLP_TRUE;
; 609  :         if (pAC97->GSR & XLLP_AC97_GSR_SCRDY_MSK)

  00080	e598301c	 ldr         r3, [r8, #0x1C]
  00084	13a06001	 movne       r6, #1
  00088	e3130c02	 tst         r3, #2, 24

; 610  :             secCodecReady = XLLP_TRUE;

  0008c	13a04001	 movne       r4, #1

; 611  :     }
; 612  :     while (timeRemaining-- && ((priCodecReady == XLLP_FALSE) || (secCodecReady == XLLP_FALSE)));

  00090	e3550000	 cmp         r5, #0
  00094	e2455001	 sub         r5, r5, #1
  00098	0a000003	 beq         |$LN3@XllpAc97Co|
  0009c	e3560000	 cmp         r6, #0
  000a0	0afffff1	 beq         |$LL8@XllpAc97Co|
  000a4	e3540000	 cmp         r4, #0
  000a8	0affffef	 beq         |$LL8@XllpAc97Co|
  000ac		 |$LN3@XllpAc97Co|

; 613  : 
; 614  :     // Timeout status if some of the devices weren't ready.
; 615  :     if ((priCodecReady == XLLP_FALSE) || (secCodecReady == XLLP_FALSE))

  000ac	e3560000	 cmp         r6, #0
  000b0	0a000001	 beq         |$LN1@XllpAc97Co|
  000b4	e3540000	 cmp         r4, #0
  000b8	1a000000	 bne         |$LN2@XllpAc97Co|
  000bc		 |$LN1@XllpAc97Co|

; 616  :     {
; 617  :         status = XLLP_AC97_CODEC_NOT_READY;

  000bc	e3a07002	 mov         r7, #2
  000c0		 |$LN2@XllpAc97Co|

; 618  :     }
; 619  : 
; 620  :     return (status);
; 621  : } // XllpAc97ColdReset ()

  000c0	e1a00007	 mov         r0, r7
  000c4	e28dd018	 add         sp, sp, #0x18
  000c8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$M1424|

			 ENDP  ; |XllpAc97ColdReset|

	EXPORT	|XllpAc97ShutdownAclink|

  00000			 AREA	 |.pdata|, PDATA
|$T1444| DCD	|$LN13@XllpAc97Sh|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97ShutdownAclink| PROC

; 647  : {

  00000		 |$LN13@XllpAc97Sh|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M1441|
  00004	e1a07001	 mov         r7, r1
  00008	e1a06000	 mov         r6, r0

; 648  :     XLLP_AC97_ERROR_T status = XLLP_AC97_NO_ERROR; 
; 649  :     XLLP_UINT32_T timeRemaining = XLLP_AC97_LINKOFF_TIMEOUT_DEF; 
; 650  : 
; 651  :     pAc97Reg->GCR |= XLLP_AC97_GCR_LINK_OFF_MSK;

  0000c	e596300c	 ldr         r3, [r6, #0xC]

; 652  : 	
; 653  : 	while (!(pAc97Reg->GSR & XLLP_AC97_GSR_ACOFFD_MSK))

  00010	e3a04000	 mov         r4, #0
  00014	e3a05f7d	 mov         r5, #0x7D, 30
  00018	e3833008	 orr         r3, r3, #8
  0001c	e586300c	 str         r3, [r6, #0xC]
  00020	ea000004	 b           |$LN10@XllpAc97Sh|
  00024		 |$LL3@XllpAc97Sh|

; 654  : 	{
; 655  : 		timeRemaining --;

  00024	e2555001	 subs        r5, r5, #1

; 656  : 		if (0 == timeRemaining)

  00028	0a000006	 beq         |$LN7@XllpAc97Sh|

; 659  :     		break;
; 660  : 		}
; 661  : 		XllpOstDelayMicroSeconds(pOstRegs, 1);

  0002c	e3a01001	 mov         r1, #1
  00030	e1a00007	 mov         r0, r7
  00034	eb000000	 bl          XllpOstDelayMicroSeconds
  00038		 |$LN10@XllpAc97Sh|
  00038	e596301c	 ldr         r3, [r6, #0x1C]
  0003c	e3130008	 tst         r3, #8
  00040	0afffff7	 beq         |$LL3@XllpAc97Sh|

; 656  : 		if (0 == timeRemaining)

  00044	ea000000	 b           |$LN2@XllpAc97Sh|
  00048		 |$LN7@XllpAc97Sh|

; 657  : 		{
; 658  :     		status = XLLP_AC97_LINK_SHUTDOWN_FAIL;

  00048	e3a04003	 mov         r4, #3
  0004c		 |$LN2@XllpAc97Sh|

; 662  :     }
; 663  : 	
; 664  :     return(status);
; 665  : }

  0004c	e1a00004	 mov         r0, r4
  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M1442|

			 ENDP  ; |XllpAc97ShutdownAclink|


  00000			 AREA	 |.pdata|, PDATA
|$T1455| DCD	|$LN6@XllpAc97Li|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97LinkLock| PROC

; 692  : {

  00000		 |$LN6@XllpAc97Li|
  00000	e24dd004	 sub         sp, sp, #4
  00004		 |$M1452|

; 693  :     XLLP_BOOL_T		status = XLLP_TRUE;
; 694  :     XLLP_VUINT32_T	carTmp;
; 695  : 
; 696  :     carTmp = pAc97Reg->CAR;

  00004	e5903020	 ldr         r3, [r0, #0x20]
  00008	e3a00001	 mov         r0, #1
  0000c	e58d3000	 str         r3, [sp]

; 697  :     if (carTmp & XLLP_AC97_CAR_CAIP_MSK)	// "1" in CAIP bit means lock failed.

  00010	e59d3000	 ldr         r3, [sp]
  00014	e3130001	 tst         r3, #1

; 698  :     {
; 699  :         status = XLLP_FALSE;

  00018	13a00000	 movne       r0, #0

; 700  :     }
; 701  :     return (status);
; 702  : } // XllpAc97LinkLock()

  0001c	e28dd004	 add         sp, sp, #4
  00020	e12fff1e	 bx          lr
  00024		 |$M1453|

			 ENDP  ; |XllpAc97LinkLock|

	EXPORT	|XllpAc97Init|
	IMPORT	|XllpGpioSetOutput0|
	IMPORT	|XllpGpioSetDirectionOut|
	IMPORT	|XllpGpioSetAlternateFn|
	IMPORT	|XllpGpioSetDirectionIn|

  00000			 AREA	 |.pdata|, PDATA
|$T1468| DCD	|$LN6@XllpAc97In|
	DCD	0x40005602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97Init| PROC

; 85   : {

  00000		 |$LN6@XllpAc97In|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd030	 sub         sp, sp, #0x30
  00008		 |$M1465|
  00008	e1a04000	 mov         r4, r0

; 86   :     XLLP_AC97_ERROR_T	status ;
; 87   :     P_XLLP_GPIO_T		pGPIO = pAc97ctxt->pGpioReg;
; 88   : 	P_XLLP_INTC_T		pINTC = pAc97ctxt->pIntcReg;
; 89   : 	P_XLLP_CLKMGR_T		pCLKMGR = pAc97ctxt->pClockReg;
; 90   :     XLLP_UINT32_T		pins[6], fn[6];
; 91   : 	
; 92   :     // Set bitclk, sdata_in_0
; 93   : 	pins[0] = 2;
; 94   :     pins[1] = XLLP_GPIO_AC97BITCLK;
; 95   :     pins[2] = XLLP_GPIO_AC97_SDATA_IN_0;
; 96   :     fn[0] = 2;
; 97   :     fn[1] = XLLP_GPIO_ALT_FN_1;
; 98   :     fn[2] = XLLP_GPIO_ALT_FN_1;
; 99   :     if (XLLP_TRUE == pAc97ctxt->useSecondaryCodec)

  0000c	e5943018	 ldr         r3, [r4, #0x18]
  00010	e3a0101c	 mov         r1, #0x1C
  00014	e3a0001d	 mov         r0, #0x1D
  00018	e5945000	 ldr         r5, [r4]
  0001c	e3530001	 cmp         r3, #1
  00020	e3a02002	 mov         r2, #2
  00024	e3a0e002	 mov         lr, #2
  00028	e58d1004	 str         r1, [sp, #4]
  0002c	e58d0008	 str         r0, [sp, #8]

; 100  :     {
; 101  : 		pins[0] = 3;
; 102  : 		pins[3] = XLLP_GPIO_KP_MKIN5;      // use this pin as AC97_SDATA_IN_1 
; 103  : 		fn[0] = 3;

  00030	03a01003	 moveq       r1, #3

; 104  : 		fn[3] = XLLP_GPIO_ALT_FN_2;

  00034	03a00002	 moveq       r0, #2
  00038	e58d2000	 str         r2, [sp]
  0003c	e58de018	 str         lr, [sp, #0x18]
  00040	058d1018	 streq       r1, [sp, #0x18]
  00044	058d0024	 streq       r0, [sp, #0x24]
  00048	e3a08001	 mov         r8, #1
  0004c	e3a09001	 mov         r9, #1
  00050	e5946010	 ldr         r6, [r4, #0x10]
  00054	e5947004	 ldr         r7, [r4, #4]
  00058	03a03003	 moveq       r3, #3
  0005c	03a02063	 moveq       r2, #0x63

; 105  : 	}
; 106  : 	XllpGpioSetDirectionIn(pGPIO, pins);

  00060	e28d1000	 add         r1, sp, #0
  00064	e1a00005	 mov         r0, r5
  00068	e58d801c	 str         r8, [sp, #0x1C]
  0006c	e58d9020	 str         r9, [sp, #0x20]
  00070	058d3000	 streq       r3, [sp]
  00074	058d200c	 streq       r2, [sp, #0xC]
  00078	eb000000	 bl          XllpGpioSetDirectionIn

; 107  :     XllpGpioSetAlternateFn(pGPIO, pins, fn);

  0007c	e28d2018	 add         r2, sp, #0x18
  00080	e28d1000	 add         r1, sp, #0
  00084	e1a00005	 mov         r0, r5
  00088	eb000000	 bl          XllpGpioSetAlternateFn

; 108  :     
; 109  :     // Set sdata_out, sync, sysclock
; 110  :     pins[0] = 2;
; 111  :     pins[1] = XLLP_GPIO_AC97_SDATA_OUT;
; 112  :     pins[2] = XLLP_GPIO_AC97_SYNC;

  0008c	e3a0101f	 mov         r1, #0x1F

; 113  : //    pins[3] = XLLP_GPIO_KP_MKIN4;     // use this pin as AC97_SYSCLK 
; 114  :     fn[0] = 2;

  00090	e3a00002	 mov         r0, #2

; 115  :     fn[1] = XLLP_GPIO_ALT_FN_2;
; 116  :     fn[2] = XLLP_GPIO_ALT_FN_2;

  00094	e58d1008	 str         r1, [sp, #8]
  00098	e58d0018	 str         r0, [sp, #0x18]
  0009c	e3a03002	 mov         r3, #2
  000a0	e3a0201e	 mov         r2, #0x1E
  000a4	e3a0e002	 mov         lr, #2
  000a8	e3a08002	 mov         r8, #2

; 117  : //    fn[3] = XLLP_GPIO_ALT_FN_1;
; 118  :     XllpGpioSetOutputState1(pGPIO, pins);

  000ac	e28d1000	 add         r1, sp, #0
  000b0	e1a00005	 mov         r0, r5
  000b4	e58d3000	 str         r3, [sp]
  000b8	e58d2004	 str         r2, [sp, #4]
  000bc	e58de01c	 str         lr, [sp, #0x1C]
  000c0	e58d8020	 str         r8, [sp, #0x20]
  000c4	eb000000	 bl          XllpGpioSetOutputState1

; 119  :     XllpGpioSetDirectionOut(pGPIO, pins);

  000c8	e28d1000	 add         r1, sp, #0
  000cc	e1a00005	 mov         r0, r5
  000d0	eb000000	 bl          XllpGpioSetDirectionOut

; 120  :     XllpGpioSetAlternateFn(pGPIO, pins, fn);

  000d4	e28d2018	 add         r2, sp, #0x18
  000d8	e28d1000	 add         r1, sp, #0
  000dc	e1a00005	 mov         r0, r5
  000e0	eb000000	 bl          XllpGpioSetAlternateFn

; 121  :     
; 122  :     // Set sdata_reset_n
; 123  :     pins[0] = 1;
; 124  :     pins[1] = XLLP_GPIO_AC97_RESET_n;
; 125  :     fn[0] = 1;

  000e4	e3a01001	 mov         r1, #1

; 126  :     fn[1] = XLLP_GPIO_ALT_FN_0;

  000e8	e3a00000	 mov         r0, #0
  000ec	e58d1018	 str         r1, [sp, #0x18]
  000f0	e58d001c	 str         r0, [sp, #0x1C]
  000f4	e3a03001	 mov         r3, #1
  000f8	e3a02071	 mov         r2, #0x71

; 127  :     XllpGpioSetOutput0(pGPIO, pins);

  000fc	e28d1000	 add         r1, sp, #0
  00100	e1a00005	 mov         r0, r5
  00104	e58d3000	 str         r3, [sp]
  00108	e58d2004	 str         r2, [sp, #4]
  0010c	eb000000	 bl          XllpGpioSetOutput0

; 128  :     XllpGpioSetDirectionOut(pGPIO, pins);

  00110	e28d1000	 add         r1, sp, #0
  00114	e1a00005	 mov         r0, r5
  00118	eb000000	 bl          XllpGpioSetDirectionOut

; 129  :     XllpGpioSetAlternateFn(pGPIO, pins, fn);

  0011c	e28d2018	 add         r2, sp, #0x18
  00120	e28d1000	 add         r1, sp, #0
  00124	e1a00005	 mov         r0, r5
  00128	eb000000	 bl          XllpGpioSetAlternateFn

; 130  :     
; 131  :     // Disable of ACUNIT interrupt.
; 132  :     pINTC->icmr &= ~XLLP_INTC_AC97;

  0012c	e5963004	 ldr         r3, [r6, #4]

; 133  : 	
; 134  :     // Enable clocking of AC '97 controller device in processor
; 135  :     pCLKMGR->cken |= XLLP_CLKEN_AC97;
; 136  : 	
; 137  :     // Perform the cold reset.
; 138  :     // Also enables the codec(s), control unit and the control unit's FIFOs
; 139  :     status = XllpAc97ColdReset(pAc97ctxt);

  00130	e1a00004	 mov         r0, r4
  00134	e3c33901	 bic         r3, r3, #1, 18
  00138	e5863004	 str         r3, [r6, #4]
  0013c	e5973004	 ldr         r3, [r7, #4]
  00140	e3833004	 orr         r3, r3, #4
  00144	e5873004	 str         r3, [r7, #4]
  00148	eb000000	 bl          XllpAc97ColdReset

; 140  :     
; 141  :     return (status);
; 142  : 
; 143  : } // End XllpAc97Init ()

  0014c	e28dd030	 add         sp, sp, #0x30
  00150	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00154	e12fff1e	 bx          lr
  00158		 |$M1466|

			 ENDP  ; |XllpAc97Init|

	EXPORT	|XllpAc97DeInit|
	IMPORT	|XllpGpioClearAlternateFn|

  00000			 AREA	 |.pdata|, PDATA
|$T1482| DCD	|$LN7@XllpAc97De|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97DeInit| PROC

; 170  : {

  00000		 |$LN7@XllpAc97De|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M1479|
  00008	e1a04000	 mov         r4, r0

; 171  :     XLLP_AC97_ERROR_T	status ;
; 172  :     P_XLLP_GPIO_T		pGPIO = pAc97ctxt->pGpioReg;
; 173  : 	P_XLLP_INTC_T		pINTC = pAc97ctxt->pIntcReg;
; 174  : 	P_XLLP_CLKMGR_T		pCLKMGR = pAc97ctxt->pClockReg;
; 175  :     XLLP_UINT32_T		pins[8];
; 176  : 	
; 177  :     status = XllpAc97ShutdownAclink(pAc97ctxt->pAc97Reg, pAc97ctxt->pOstRegs);

  0000c	e594100c	 ldr         r1, [r4, #0xC]
  00010	e5940008	 ldr         r0, [r4, #8]
  00014	e5945000	 ldr         r5, [r4]
  00018	e5947010	 ldr         r7, [r4, #0x10]
  0001c	e5948004	 ldr         r8, [r4, #4]
  00020	eb000000	 bl          XllpAc97ShutdownAclink
  00024	e1b06000	 movs        r6, r0

; 178  : 
; 179  : 	if (XLLP_AC97_NO_ERROR == status)

  00028	1a00001f	 bne         |$LN2@XllpAc97De|

; 180  : 	{
; 181  :         // Disable of ACUNIT interrupt.
; 182  : 	    pINTC->icmr &= ~XLLP_INTC_AC97;

  0002c	e5973004	 ldr         r3, [r7, #4]

; 183  : 
; 184  : 	    // Disable clocking of AC '97 controller device in processor
; 185  : 	    pCLKMGR->cken &= ~XLLP_CLKEN_AC97;
; 186  : 
; 187  : 		// Set all pins to default general input configuration.
; 188  :     	pins[0] = 6;
; 189  :         pins[1] = XLLP_GPIO_AC97BITCLK;
; 190  :         pins[2] = XLLP_GPIO_AC97_SDATA_IN_0;
; 191  :         pins[3] = XLLP_GPIO_AC97_SDATA_OUT;
; 192  :         pins[4] = XLLP_GPIO_AC97_SYNC;
; 193  :         pins[5] = XLLP_GPIO_KP_MKIN4;     // use this pin as AC97_SYSCLK 
; 194  :         pins[6] = XLLP_GPIO_AC97_RESET_n;
; 195  : 
; 196  :         if (XLLP_TRUE == pAc97ctxt->useSecondaryCodec)

  00030	e3a0201c	 mov         r2, #0x1C
  00034	e3a0101d	 mov         r1, #0x1D
  00038	e3c33901	 bic         r3, r3, #1, 18
  0003c	e5873004	 str         r3, [r7, #4]
  00040	e5983004	 ldr         r3, [r8, #4]
  00044	e3a0001e	 mov         r0, #0x1E
  00048	e3a09006	 mov         r9, #6
  0004c	e3c33004	 bic         r3, r3, #4
  00050	e5883004	 str         r3, [r8, #4]
  00054	e5943018	 ldr         r3, [r4, #0x18]
  00058	e58d2004	 str         r2, [sp, #4]
  0005c	e3a0e01f	 mov         lr, #0x1F
  00060	e3530001	 cmp         r3, #1

; 197  :         {
; 198  : 			pins[0] = 7;

  00064	03a03007	 moveq       r3, #7

; 199  : 			pins[7] = XLLP_GPIO_KP_MKIN5;      // use this pin as AC97_SDATA_IN_1 

  00068	03a02063	 moveq       r2, #0x63
  0006c	e3a04062	 mov         r4, #0x62
  00070	e3a07071	 mov         r7, #0x71
  00074	e58d1008	 str         r1, [sp, #8]
  00078	e58d000c	 str         r0, [sp, #0xC]
  0007c	e58d9000	 str         r9, [sp]

; 200  : 		}
; 201  : 		XllpGpioSetDirectionIn(pGPIO, pins);

  00080	e28d1000	 add         r1, sp, #0
  00084	e1a00005	 mov         r0, r5
  00088	058d3000	 streq       r3, [sp]
  0008c	058d201c	 streq       r2, [sp, #0x1C]
  00090	e58de010	 str         lr, [sp, #0x10]
  00094	e58d4014	 str         r4, [sp, #0x14]
  00098	e58d7018	 str         r7, [sp, #0x18]
  0009c	eb000000	 bl          XllpGpioSetDirectionIn

; 202  :         XllpGpioClearAlternateFn(pGPIO, pins);

  000a0	e28d1000	 add         r1, sp, #0
  000a4	e1a00005	 mov         r0, r5
  000a8	eb000000	 bl          XllpGpioClearAlternateFn
  000ac		 |$LN2@XllpAc97De|

; 203  : 	}
; 204  :     	
; 205  :     return (status);
; 206  : }

  000ac	e1a00006	 mov         r0, r6
  000b0	e28dd020	 add         sp, sp, #0x20
  000b4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M1480|

			 ENDP  ; |XllpAc97DeInit|

	EXPORT	|XllpAc97Write|

  00000			 AREA	 |.pdata|, PDATA
|$T1510| DCD	|$LN28@XllpAc97Wr|
	DCD	0x40003b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97Write| PROC

; 291  : {

  00000		 |$LN28@XllpAc97Wr|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1507|
  00008	e1a0a003	 mov         r10, r3
  0000c	e1a04002	 mov         r4, r2
  00010	e1a08001	 mov         r8, r1

; 292  :     XLLP_AC97_ERROR_T	status = XLLP_AC97_NO_ERROR;
; 293  :     XLLP_BOOL_T			gotLink;
; 294  :     XLLP_UINT32_T		timeRemaining;
; 295  :     P_XLLP_VUINT32_T	pCodecReg;
; 296  :     
; 297  :     // Point to specified register within area mapped to target codec regs
; 298  : 
; 299  :     // Check for special case register 54h the GPIO status register
; 300  : 
; 301  :     if(offset == XLLP_AC97_CR_E_MDM_GPIO_PIN_STAT)
; 302  :     {
; 303  : #ifdef WM9712
; 304  :         
; 305  :         // This is a work around for the WM9712 GPIO status issue.
; 306  :         // Note that the WM9712 can only be used as a primary
; 307  :         // AC97 device.
; 308  :         
; 309  :         XLLP_UINT16_T offsetdata = data << 1;
; 310  :         
; 311  :         pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);
; 312  : 
; 313  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 314  : 
; 315  :         // The data will be sent out on slots 1&2 to register 54h.
; 316  :         *pCodecReg = (XLLP_VUINT32_T)data;
; 317  : 
; 318  :         pCodecReg = &(pAc97Reg->CodecRegsPrimaryMdm[0]);
; 319  : 
; 320  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 321  : 
; 322  :         // The data will be sent out on slot 12.
; 323  :         *pCodecReg = (XLLP_VUINT32_T)offsetdata;
; 324  :        
; 325  : #else
; 326  :         // Select the Primary or Secondary modem IO address space
; 327  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)

  00014	e59d3028	 ldr         r3, [sp, #0x28]
  00018	e3a05000	 mov         r5, #0
  0001c	e3500054	 cmp         r0, #0x54
  00020	1a000006	 bne         |$LN18@XllpAc97Wr|
  00024	e3530000	 cmp         r3, #0

; 328  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryMdm[0]);

  00028	02843b01	 addeq       r3, r4, #1, 22

; 329  :         else
; 330  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryMdm[0]);
; 331  : 
; 332  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 333  : 
; 334  :         // The data will be sent out on slot 12.
; 335  :         *pCodecReg = data;

  0002c	058380a8	 streq       r8, [r3, #0xA8]
  00030	0a000029	 beq         |$done$1277|
  00034	e2843c05	 add         r3, r4, #5, 24
  00038	e58380a8	 str         r8, [r3, #0xA8]

; 336  :    
; 337  : #endif
; 338  :         goto done;

  0003c	ea000026	 b           |$done$1277|
  00040		 |$LN18@XllpAc97Wr|

; 339  :     }
; 340  :     else
; 341  :     {
; 342  :         // Select the Primary or Secondary Audio IO address space
; 343  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)

  00040	e3530000	 cmp         r3, #0

; 344  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);

  00044	02842c02	 addeq       r2, r4, #2, 24

; 345  :         else
; 346  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryAud[0]);

  00048	12842c03	 addne       r2, r4, #3, 24

; 347  : 
; 348  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;  

  0004c	e1a030a0	 mov         r3, r0, lsr #1
  00050	e0829103	 add         r9, r2, r3, lsl #2

; 349  :     }
; 350  :     
; 351  : 
; 352  : 	//Lock the ACLINK
; 353  :     timeRemaining = XLLP_AC97_LOCK_TIMEOUT_DEF;

  00054	e3a07f4b	 mov         r7, #0x4B, 30
  00058		 |$LL12@XllpAc97Wr|

; 354  :     do
; 355  :     {
; 356  :         gotLink = XllpAc97LinkLock(pAc97Reg);

  00058	e5943020	 ldr         r3, [r4, #0x20]
  0005c	e3a06001	 mov         r6, #1
  00060	e58d3000	 str         r3, [sp]
  00064	e59d3000	 ldr         r3, [sp]
  00068	e3130001	 tst         r3, #1

; 357  :         if (XLLP_FALSE == gotLink)	// 1 usec is a long time.  Skip delay if possible.
; 358  :         {
; 359  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  0006c	13a01001	 movne       r1, #1
  00070	11a0000a	 movne       r0, r10
  00074	13a06000	 movne       r6, #0
  00078	1b000000	 blne        XllpOstDelayMicroSeconds

; 360  :         }
; 361  :     }        // Wait while time remaining and ACLINK not available
; 362  :     while (timeRemaining-- && (XLLP_FALSE == gotLink));

  0007c	e3570000	 cmp         r7, #0
  00080	e2477001	 sub         r7, r7, #1
  00084	0a000001	 beq         |$LN8@XllpAc97Wr|
  00088	e3560000	 cmp         r6, #0
  0008c	0afffff1	 beq         |$LL12@XllpAc97Wr|
  00090		 |$LN8@XllpAc97Wr|

; 363  : 
; 364  :     if (XLLP_FALSE == gotLink)	// Didn't get the ACLINK

  00090	e3560000	 cmp         r6, #0

; 365  :     {
; 366  :         status = XLLP_AC97_LINK_LOCK_FAIL;

  00094	03a05005	 moveq       r5, #5
  00098	0a00000f	 beq         |$done$1277|

; 367  :     }
; 368  :     else	// We got the link. Perform the write operation and don't wait.
; 369  :     {
; 370  : 
; 371  :         // First, clear old write status indication CDONE by writing a ONE to that bit.
; 372  :         pAc97Reg->GSR = XLLP_AC97_GSR_CDONE_MSK;

  0009c	e3a03702	 mov         r3, #2, 14

; 373  : 
; 374  :         *pCodecReg = data;       // Now the write!
; 375  : 
; 376  :         // Wait until write cycle is complete. There should be a way
; 377  :         //  to do this speculatively at the beginning of the procedure.
; 378  :         //  Need to discover it. Too inefficient to always wait.
; 379  : 
; 380  :         timeRemaining = maxRWTimeOutUs;

  000a0	e59d6024	 ldr         r6, [sp, #0x24]
  000a4	e584301c	 str         r3, [r4, #0x1C]
  000a8	e5898000	 str         r8, [r9]
  000ac		 |$LL5@XllpAc97Wr|

; 381  :         do
; 382  :         {
; 383  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  000ac	e3a01001	 mov         r1, #1
  000b0	e1a0000a	 mov         r0, r10
  000b4	eb000000	 bl          XllpOstDelayMicroSeconds

; 384  :         }     // Wait while time remaining and command I/O still incomplete.
; 385  :         while ( (timeRemaining--) && !(pAc97Reg->GSR & XLLP_AC97_GSR_CDONE_MSK));

  000b8	e3560000	 cmp         r6, #0
  000bc	e2466001	 sub         r6, r6, #1
  000c0	0a000002	 beq         |$LN2@XllpAc97Wr|
  000c4	e594301c	 ldr         r3, [r4, #0x1C]
  000c8	e3130702	 tst         r3, #2, 14
  000cc	0afffff6	 beq         |$LL5@XllpAc97Wr|
  000d0		 |$LN2@XllpAc97Wr|

; 386  : 		if (!(pAc97Reg->GSR & XLLP_AC97_GSR_CDONE_MSK))

  000d0	e594301c	 ldr         r3, [r4, #0x1C]
  000d4	e3130702	 tst         r3, #2, 14

; 387  : 			status = XLLP_AC97_CODEC_ACCESS_TIMEOUT;

  000d8	03a05001	 moveq       r5, #1
  000dc		 |$done$1277|

; 388  :     }  // Got AC link
; 389  : 
; 390  : done:
; 391  :     return(status);
; 392  : } // Ac97CtrlCodecWrite()

  000dc	e1a00005	 mov         r0, r5
  000e0	e28dd004	 add         sp, sp, #4
  000e4	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M1508|

			 ENDP  ; |XllpAc97Write|

	EXPORT	|XllpAc97Read|

  00000			 AREA	 |.pdata|, PDATA
|$T1540| DCD	|$LN30@XllpAc97Re|
	DCD	0x40004702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpAc97Read| PROC

; 436  : {

  00000		 |$LN30@XllpAc97Re|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1537|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a04002	 mov         r4, r2
  00010	e1a0a001	 mov         r10, r1

; 437  :     XLLP_AC97_ERROR_T	status = XLLP_AC97_NO_ERROR;
; 438  :     XLLP_BOOL_T			gotLink;
; 439  : 	XLLP_UINT32_T		timeRemaining;
; 440  :     P_XLLP_VUINT32_T	pCodecReg;
; 441  : 
; 442  :     // Point to specified register within area mapped to target codec regs
; 443  :     // Check for special case register 54h the GPIO status register
; 444  : #ifdef WM9712
; 445  :     if(offset == XLLP_AC97_CR_E_MDM_GPIO_PIN_STAT)
; 446  :     {
; 447  :         // Select the Primary or Secondary modem IO address space
; 448  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)
; 449  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryMdm[0]);
; 450  :         else
; 451  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryMdm[0]);
; 452  : 
; 453  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;
; 454  : 
; 455  :         // The data is received on Slot 12 and stored by the
; 456  :         // ACUNIT so we can read back straight away.
; 457  :         *pdata = (XLLP_UINT16_T)(*pCodecReg);
; 458  :             
; 459  :         goto done;
; 460  :     }
; 461  :     else
; 462  :     {
; 463  :         // Select the Primary or Secondary Audio IO address space
; 464  : 	    if (XLLP_AC97_CODEC_PRIMARY == codecSel)
; 465  :             pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);
; 466  :         else
; 467  :             pCodecReg = &(pAc97Reg->CodecRegsSecondaryAud[0]);
; 468  : 
; 469  :         pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;  
; 470  :     }
; 471  : #else
; 472  :     // Select the Primary or Secondary Audio IO address space
; 473  : 	if (XLLP_AC97_CODEC_PRIMARY == codecSel)

  00014	e59de02c	 ldr         lr, [sp, #0x2C]

; 474  :         pCodecReg = &(pAc97Reg->CodecRegsPrimaryAud[0]);
; 475  :     else
; 476  :         pCodecReg = &(pAc97Reg->CodecRegsSecondaryAud[0]);
; 477  :     pCodecReg += offset / XLLP_AC97_CODEC_REGS_PER_WORD;  

  00018	e1a030a0	 mov         r3, r0, lsr #1
  0001c	e3a05000	 mov         r5, #0
  00020	e35e0000	 cmp         lr, #0
  00024	02842c02	 addeq       r2, r4, #2, 24
  00028	12842c03	 addne       r2, r4, #3, 24
  0002c	e0829103	 add         r9, r2, r3, lsl #2

; 478  : #endif
; 479  : 	//Lock the ACLINK
; 480  :     timeRemaining = XLLP_AC97_LOCK_TIMEOUT_DEF;

  00030	e3a07f4b	 mov         r7, #0x4B, 30
  00034		 |$LL17@XllpAc97Re|

; 481  :     do
; 482  :     {
; 483  :         gotLink = XllpAc97LinkLock(pAc97Reg);

  00034	e5943020	 ldr         r3, [r4, #0x20]
  00038	e3a06001	 mov         r6, #1
  0003c	e58d3000	 str         r3, [sp]
  00040	e59d3000	 ldr         r3, [sp]
  00044	e3130001	 tst         r3, #1

; 484  :         if (XLLP_FALSE == gotLink)	// 1 usec is a long time.  Skip delay if possible.
; 485  :         {
; 486  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  00048	13a01001	 movne       r1, #1
  0004c	11a00008	 movne       r0, r8
  00050	13a06000	 movne       r6, #0
  00054	1b000000	 blne        XllpOstDelayMicroSeconds

; 487  :         }
; 488  :     }        // Wait while time remaining and ACLINK not available
; 489  :     while (timeRemaining-- && (XLLP_FALSE == gotLink));

  00058	e3570000	 cmp         r7, #0
  0005c	e2477001	 sub         r7, r7, #1
  00060	0a000001	 beq         |$LN13@XllpAc97Re|
  00064	e3560000	 cmp         r6, #0
  00068	0afffff1	 beq         |$LL17@XllpAc97Re|
  0006c		 |$LN13@XllpAc97Re|

; 490  : 
; 491  :     if (XLLP_FALSE == gotLink)	// Didn't get the ACLINK

  0006c	e3560000	 cmp         r6, #0

; 492  :     {
; 493  :         status = XLLP_AC97_LINK_LOCK_FAIL;

  00070	03a05005	 moveq       r5, #5
  00074	0a000024	 beq         |$LN1@XllpAc97Re|

; 494  :     }
; 495  :     else	// We got the link. Perform the write operation and don't wait.
; 496  :     {
; 497  :          // First, clear old read status indications.
; 498  :         pAc97Reg->GSR = XLLP_AC97_GSR_SDONE_MSK | XLLP_AC97_GSR_RCS_ERR_MSK;

  00078	e3a0b912	 mov         r11, #0x12, 18

; 499  : 
; 500  :         *pdata = (XLLP_UINT16_T)(*pCodecReg); // This is THE DUMMY READ.
; 501  : 
; 502  :          // Wait for read I/O with codec to complete before doing real read.
; 503  :         timeRemaining = maxRWTimeOutUs;

  0007c	e59d6028	 ldr         r6, [sp, #0x28]
  00080	e584b01c	 str         r11, [r4, #0x1C]
  00084	e5993000	 ldr         r3, [r9]
  00088	e1a07006	 mov         r7, r6
  0008c	e1ca30b0	 strh        r3, [r10]
  00090		 |$LL10@XllpAc97Re|

; 504  :         do
; 505  :         {
; 506  : 			XllpOstDelayMicroSeconds(pOstRegs, 1);

  00090	e3a01001	 mov         r1, #1
  00094	e1a00008	 mov         r0, r8
  00098	eb000000	 bl          XllpOstDelayMicroSeconds

; 507  :         }   // Wait while time remaining and read I/O still incomplete
; 508  :         while( (timeRemaining--) && (!(pAc97Reg->GSR & XLLP_AC97_GSR_SDONE_MSK)) );

  0009c	e3570000	 cmp         r7, #0
  000a0	e2477001	 sub         r7, r7, #1
  000a4	0a000002	 beq         |$LN7@XllpAc97Re|
  000a8	e594301c	 ldr         r3, [r4, #0x1C]
  000ac	e3130701	 tst         r3, #1, 14
  000b0	0afffff6	 beq         |$LL10@XllpAc97Re|
  000b4		 |$LN7@XllpAc97Re|

; 509  : 
; 510  :         if ((pAc97Reg->GSR & XLLP_AC97_GSR_SDONE_MSK) && (!(pAc97Reg->GSR & XLLP_AC97_GSR_RCS_ERR_MSK)) )

  000b4	e594301c	 ldr         r3, [r4, #0x1C]
  000b8	e3130701	 tst         r3, #1, 14
  000bc	0a00000f	 beq         |$LN6@XllpAc97Re|
  000c0	e594301c	 ldr         r3, [r4, #0x1C]
  000c4	e3130902	 tst         r3, #2, 18
  000c8	1a00000c	 bne         |$LN6@XllpAc97Re|

; 511  :         {
; 512  :              // succeed in reading. clear status bits first.
; 513  :              pAc97Reg->GSR = XLLP_AC97_GSR_SDONE_MSK | XLLP_AC97_GSR_RCS_ERR_MSK;

  000cc	e584b01c	 str         r11, [r4, #0x1C]

; 514  :             *pdata = (XLLP_UINT16_T)(*pCodecReg);	// THE REAL READ.

  000d0	e5993000	 ldr         r3, [r9]

; 515  :      		timeRemaining = maxRWTimeOutUs;

  000d4	e1ca30b0	 strh        r3, [r10]
  000d8		 |$LL5@XllpAc97Re|

; 516  :     	    do
; 517  : 	        {
; 518  : 				XllpOstDelayMicroSeconds(pOstRegs, 1);

  000d8	e3a01001	 mov         r1, #1
  000dc	e1a00008	 mov         r0, r8
  000e0	eb000000	 bl          XllpOstDelayMicroSeconds

; 519  :   		    }   // Wait while time remaining and read I/O still incomplete
; 520  :     	    while( (timeRemaining--) && (!(pAc97Reg->GSR & XLLP_AC97_GSR_SDONE_MSK)) );

  000e4	e3560000	 cmp         r6, #0
  000e8	e2466001	 sub         r6, r6, #1
  000ec	0a000006	 beq         |$LN1@XllpAc97Re|
  000f0	e594301c	 ldr         r3, [r4, #0x1C]
  000f4	e3130701	 tst         r3, #1, 14
  000f8	0afffff6	 beq         |$LL5@XllpAc97Re|

; 521  : 
; 522  :         }
; 523  :         else	// failed

  000fc	ea000002	 b           |$LN1@XllpAc97Re|
  00100		 |$LN6@XllpAc97Re|

; 524  :         {
; 525  :             status = XLLP_AC97_CODEC_ACCESS_TIMEOUT;
; 526  :             pAc97Reg->CAR = XLLP_AC97_CAR_CAIP_CLEAR;

  00100	e3a03000	 mov         r3, #0
  00104	e5843020	 str         r3, [r4, #0x20]
  00108	e3a05001	 mov         r5, #1
  0010c		 |$LN1@XllpAc97Re|

; 527  : 
; 528  :         } // else  (OK to do real read)
; 529  : 
; 530  :     } // else  (We got the link.  Perform the read operations.)
; 531  : 
; 532  :     return (status);
; 533  : } // XllpAc97Read ()

  0010c	e1a00005	 mov         r0, r5
  00110	e28dd004	 add         sp, sp, #4
  00114	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00118	e12fff1e	 bx          lr
  0011c		 |$M1538|

			 ENDP  ; |XllpAc97Read|

	END
