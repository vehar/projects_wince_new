; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\XLLP\SOURCE\xllp_gpio.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|XllpGpioGetState|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\xllp\source\xllp_gpio.c

  00000			 AREA	 |.pdata|, PDATA
|$T1256| DCD	|$LN12@XllpGpioGe|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioGetState| PROC

; 69   : 	{

  00000		 |$LN12@XllpGpioGe|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1253|

; 70   : 	XLLP_UINT32_T aGpioPinMask;
; 71   : 
; 72   : 	aGpioPinMask = 0x1 << (aGpioPin & 0x1F);
; 73   : 
; 74   : 	if(aGpioPin > 95)

  00004	e351005f	 cmp         r1, #0x5F

; 75   : 		return (pGPIO->GPLR3 & aGpioPinMask);

  00008	85903100	 ldrhi       r3, [r0, #0x100]
  0000c	e201201f	 and         r2, r1, #0x1F
  00010	e3a0e001	 mov         lr, #1
  00014	8a000005	 bhi         |$LN9@XllpGpioGe|

; 76   : 	else if(aGpioPin > 63) 

  00018	e351003f	 cmp         r1, #0x3F

; 77   : 		return (pGPIO->GPLR2 & aGpioPinMask);

  0001c	85903008	 ldrhi       r3, [r0, #8]
  00020	8a000002	 bhi         |$LN9@XllpGpioGe|

; 78   : 	else if(aGpioPin > 31) 

  00024	e351001f	 cmp         r1, #0x1F

; 79   : 		return (pGPIO->GPLR1 & aGpioPinMask);

  00028	85903004	 ldrhi       r3, [r0, #4]

; 80   : 	else return (pGPIO->GPLR0 & aGpioPinMask);

  0002c	95903000	 ldrls       r3, [r0]
  00030		 |$LN9@XllpGpioGe|
  00030	e003021e	 and         r0, r3, lr, lsl r2

; 81   : 	}

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M1254|

			 ENDP  ; |XllpGpioGetState|

	EXPORT	|XllpGpioGetDirection|

  00000			 AREA	 |.pdata|, PDATA
|$T1269| DCD	|$LN12@XllpGpioGe@2|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioGetDirection| PROC

; 93   :     {

  00000		 |$LN12@XllpGpioGe@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1266|

; 94   : 	XLLP_UINT32_T aGpioPinMask;
; 95   : 
; 96   : 	aGpioPinMask = 0x1 << (aGpioPin & 0x1F);
; 97   : 
; 98   : 	if(aGpioPin > 95)

  00004	e351005f	 cmp         r1, #0x5F

; 99   : 		return (pGPIO->GPDR3 & aGpioPinMask);

  00008	8590310c	 ldrhi       r3, [r0, #0x10C]
  0000c	e201201f	 and         r2, r1, #0x1F
  00010	e3a0e001	 mov         lr, #1
  00014	8a000005	 bhi         |$LN9@XllpGpioGe@2|

; 100  : 	else if(aGpioPin > 63) 

  00018	e351003f	 cmp         r1, #0x3F

; 101  : 		return (pGPIO->GPDR2 & aGpioPinMask);

  0001c	85903014	 ldrhi       r3, [r0, #0x14]
  00020	8a000002	 bhi         |$LN9@XllpGpioGe@2|

; 102  : 	else if(aGpioPin > 31) 

  00024	e351001f	 cmp         r1, #0x1F

; 103  : 		return (pGPIO->GPDR1 & aGpioPinMask);

  00028	85903010	 ldrhi       r3, [r0, #0x10]

; 104  : 	else return (pGPIO->GPDR0 & aGpioPinMask);

  0002c	9590300c	 ldrls       r3, [r0, #0xC]
  00030		 |$LN9@XllpGpioGe@2|
  00030	e003021e	 and         r0, r3, lr, lsl r2

; 105  :     }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M1267|

			 ENDP  ; |XllpGpioGetDirection|

	EXPORT	|XllpGpioSetDirectionIn|
	IMPORT	|XllpUnlock|
	IMPORT	|XllpLock|

  00000			 AREA	 |.pdata|, PDATA
|$T1294| DCD	|$LN20@XllpGpioSe|
	DCD	0x40004902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetDirectionIn| PROC

; 116  :     {

  00000		 |$LN20@XllpGpioSe|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1291|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 117  : 	XLLP_UINT32_T LockID;
; 118  : 	XLLP_UINT32_T aGpioPinMask;
; 119  : 	XLLP_UINT32_T aSizeArray;
; 120  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 121  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 122  : 	XLLP_UINT32_T i;
; 123  : 
; 124  : 	//determine size of array
; 125  : 	aSizeArray = aGpioPinArray[0];

  00010	e5910000	 ldr         r0, [r1]

; 126  : 	aMask0=aMask1=aMask2=aMask3=0;

  00014	e3a0b000	 mov         r11, #0
  00018	e3a07000	 mov         r7, #0

; 127  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 128  : 
; 129  : 	for(i=1; i<=aSizeArray; i++)

  0001c	e3500001	 cmp         r0, #1
  00020	e3a09000	 mov         r9, #0
  00024	e3a0a000	 mov         r10, #0
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a05000	 mov         r5, #0
  00030	e3a06000	 mov         r6, #0
  00034	e3a08000	 mov         r8, #0
  00038	3a000036	 bcc         |$LN1@XllpGpioSe|
  0003c	e2811004	 add         r1, r1, #4
  00040	e3a04001	 mov         r4, #1
  00044		 |$LL13@XllpGpioSe|

; 130  : 	{
; 131  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00044	e5913000	 ldr         r3, [r1]
  00048	e203201f	 and         r2, r3, #0x1F

; 132  : 		if(aGpioPinArray[i] > 95)

  0004c	e353005f	 cmp         r3, #0x5F

; 133  : 		{
; 134  : 			aMask3 |= aGpioPinMask;

  00050	818bb214	 orrhi       r11, r11, r4, lsl r2

; 135  : 			aSet3=XLLP_TRUE;

  00054	83a0e001	 movhi       lr, #1
  00058	8a000009	 bhi         |$LN12@XllpGpioSe|

; 136  : 		}
; 137  : 		else if(aGpioPinArray[i] > 63)

  0005c	e5913000	 ldr         r3, [r1]
  00060	e353003f	 cmp         r3, #0x3F

; 138  : 		{
; 139  : 			aMask2 |= aGpioPinMask;

  00064	81877214	 orrhi       r7, r7, r4, lsl r2

; 140  : 			aSet2=XLLP_TRUE;

  00068	83a05001	 movhi       r5, #1
  0006c	8a000004	 bhi         |$LN12@XllpGpioSe|

; 141  : 		}
; 142  : 		else if(aGpioPinArray[i] > 31)

  00070	e353001f	 cmp         r3, #0x1F

; 143  : 		{ 
; 144  : 			aMask1 |= aGpioPinMask;

  00074	81899214	 orrhi       r9, r9, r4, lsl r2

; 145  : 			aSet1=XLLP_TRUE;

  00078	83a06001	 movhi       r6, #1

; 146  : 		}
; 147  : 		else
; 148  : 		{
; 149  : 			aMask0 |= aGpioPinMask;

  0007c	918aa214	 orrls       r10, r10, r4, lsl r2

; 150  : 			aSet0=XLLP_TRUE;

  00080	93a08001	 movls       r8, #1
  00084		 |$LN12@XllpGpioSe|
  00084	e2811004	 add         r1, r1, #4
  00088	e2500001	 subs        r0, r0, #1
  0008c	1affffec	 bne         |$LL13@XllpGpioSe|

; 151  : 		}
; 152  : 			
; 153  : 	}
; 154  : 	
; 155  : 	if(aSet3)

  00090	e59d4000	 ldr         r4, [sp]
  00094	e35e0000	 cmp         lr, #0
  00098	0a000006	 beq         |$LN4@XllpGpioSe|

; 156  : 	{
; 157  : 		LockID = XllpLock(GPDR3);

  0009c	e3a0001f	 mov         r0, #0x1F
  000a0	eb000000	 bl          XllpLock

; 158  : 		pGPIO->GPDR3=((pGPIO->GPDR3&~aMask3)&~XLLP_GPIO_PIN_RESERVED_BITS);

  000a4	e594310c	 ldr         r3, [r4, #0x10C]
  000a8	e1c3300b	 bic         r3, r3, r11
  000ac	e3c334fe	 bic         r3, r3, #0xFE, 8
  000b0	e584310c	 str         r3, [r4, #0x10C]

; 159  : 		XllpUnlock(LockID);

  000b4	eb000000	 bl          XllpUnlock
  000b8		 |$LN4@XllpGpioSe|

; 160  : 	}
; 161  : 	if(aSet2)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000005	 beq         |$LN3@XllpGpioSe|

; 162  : 	{
; 163  : 		LockID = XllpLock(GPDR2);

  000c0	e3a00006	 mov         r0, #6
  000c4	eb000000	 bl          XllpLock

; 164  : 		pGPIO->GPDR2=((pGPIO->GPDR2)&~aMask2);

  000c8	e5943014	 ldr         r3, [r4, #0x14]
  000cc	e1c33007	 bic         r3, r3, r7
  000d0	e5843014	 str         r3, [r4, #0x14]

; 165  : 		XllpUnlock(LockID);

  000d4	eb000000	 bl          XllpUnlock
  000d8		 |$LN3@XllpGpioSe|

; 166  : 	}
; 167  : 	if(aSet1)

  000d8	e3560000	 cmp         r6, #0
  000dc	0a000005	 beq         |$LN2@XllpGpioSe|

; 168  : 	{
; 169  : 		LockID = XllpLock(GPDR1);

  000e0	e3a00005	 mov         r0, #5
  000e4	eb000000	 bl          XllpLock

; 170  : 		pGPIO->GPDR1=((pGPIO->GPDR1)&~aMask1);

  000e8	e5943010	 ldr         r3, [r4, #0x10]
  000ec	e1c33009	 bic         r3, r3, r9
  000f0	e5843010	 str         r3, [r4, #0x10]

; 171  : 		XllpUnlock(LockID);

  000f4	eb000000	 bl          XllpUnlock
  000f8		 |$LN2@XllpGpioSe|

; 172  : 	}
; 173  : 	if(aSet0)

  000f8	e3580000	 cmp         r8, #0
  000fc	0a000005	 beq         |$LN1@XllpGpioSe|

; 174  : 	{
; 175  : 		LockID = XllpLock(GPDR0);

  00100	e3a00004	 mov         r0, #4
  00104	eb000000	 bl          XllpLock

; 176  : 		pGPIO->GPDR0=((pGPIO->GPDR0)&~aMask0);

  00108	e594300c	 ldr         r3, [r4, #0xC]
  0010c	e1c3300a	 bic         r3, r3, r10
  00110	e584300c	 str         r3, [r4, #0xC]

; 177  : 		XllpUnlock(LockID);

  00114	eb000000	 bl          XllpUnlock
  00118		 |$LN1@XllpGpioSe|

; 178  : 	}
; 179  :     }

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M1292|

			 ENDP  ; |XllpGpioSetDirectionIn|

	EXPORT	|XllpGpioSetDirectionOut|

  00000			 AREA	 |.pdata|, PDATA
|$T1319| DCD	|$LN20@XllpGpioSe@2|
	DCD	0x40004902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetDirectionOut| PROC

; 190  :     {

  00000		 |$LN20@XllpGpioSe@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1316|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 191  : 	XLLP_UINT32_T LockID;
; 192  : 	XLLP_UINT32_T aGpioPinMask;
; 193  : 	XLLP_UINT32_T aSizeArray;
; 194  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 195  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 196  : 	XLLP_UINT32_T i;
; 197  : 
; 198  : 	//determine size of array
; 199  : 	aSizeArray = aGpioPinArray[0];

  00010	e5910000	 ldr         r0, [r1]

; 200  : 	aMask0=aMask1=aMask2=aMask3=0;

  00014	e3a0b000	 mov         r11, #0
  00018	e3a08000	 mov         r8, #0

; 201  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 202  : 	
; 203  : 	for(i=1; i<=aSizeArray; i++)

  0001c	e3500001	 cmp         r0, #1
  00020	e3a0a000	 mov         r10, #0
  00024	e3a09000	 mov         r9, #0
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a05000	 mov         r5, #0
  00030	e3a06000	 mov         r6, #0
  00034	e3a07000	 mov         r7, #0
  00038	3a000036	 bcc         |$LN1@XllpGpioSe@2|
  0003c	e2811004	 add         r1, r1, #4
  00040	e3a04001	 mov         r4, #1
  00044		 |$LL13@XllpGpioSe@2|

; 204  : 	{
; 205  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00044	e5913000	 ldr         r3, [r1]
  00048	e203201f	 and         r2, r3, #0x1F

; 206  : 		if(aGpioPinArray[i] > 95)

  0004c	e353005f	 cmp         r3, #0x5F

; 207  : 		{
; 208  : 			aMask3 |= aGpioPinMask;

  00050	818bb214	 orrhi       r11, r11, r4, lsl r2

; 209  : 			aSet3=XLLP_TRUE;

  00054	83a0e001	 movhi       lr, #1
  00058	8a000009	 bhi         |$LN12@XllpGpioSe@2|

; 210  : 		}
; 211  : 		else if(aGpioPinArray[i] > 63)

  0005c	e5913000	 ldr         r3, [r1]
  00060	e353003f	 cmp         r3, #0x3F

; 212  : 		{
; 213  : 			aMask2 |= aGpioPinMask;

  00064	81888214	 orrhi       r8, r8, r4, lsl r2

; 214  : 			aSet2=XLLP_TRUE;

  00068	83a05001	 movhi       r5, #1
  0006c	8a000004	 bhi         |$LN12@XllpGpioSe@2|

; 215  : 		}
; 216  : 		else if(aGpioPinArray[i] > 31)

  00070	e353001f	 cmp         r3, #0x1F

; 217  : 		{
; 218  : 			aMask1 |= aGpioPinMask;

  00074	818aa214	 orrhi       r10, r10, r4, lsl r2

; 219  : 			aSet1=XLLP_TRUE;

  00078	83a06001	 movhi       r6, #1

; 220  : 		}
; 221  : 		else
; 222  : 		{
; 223  : 			aMask0 |= aGpioPinMask;

  0007c	91899214	 orrls       r9, r9, r4, lsl r2

; 224  : 			aSet0=XLLP_TRUE;

  00080	93a07001	 movls       r7, #1
  00084		 |$LN12@XllpGpioSe@2|
  00084	e2811004	 add         r1, r1, #4
  00088	e2500001	 subs        r0, r0, #1
  0008c	1affffec	 bne         |$LL13@XllpGpioSe@2|

; 225  : 		}
; 226  : 	}
; 227  : 	if(aSet3)

  00090	e59d4000	 ldr         r4, [sp]
  00094	e35e0000	 cmp         lr, #0
  00098	0a000006	 beq         |$LN4@XllpGpioSe@2|

; 228  : 	{
; 229  : 		LockID = XllpLock(GPDR3);

  0009c	e3a0001f	 mov         r0, #0x1F
  000a0	eb000000	 bl          XllpLock

; 230  : 		pGPIO->GPDR3=((pGPIO->GPDR3| aMask3)&~XLLP_GPIO_PIN_RESERVED_BITS);

  000a4	e594310c	 ldr         r3, [r4, #0x10C]
  000a8	e183300b	 orr         r3, r3, r11
  000ac	e3c334fe	 bic         r3, r3, #0xFE, 8
  000b0	e584310c	 str         r3, [r4, #0x10C]

; 231  : 		XllpUnlock(LockID);

  000b4	eb000000	 bl          XllpUnlock
  000b8		 |$LN4@XllpGpioSe@2|

; 232  : 	}
; 233  : 	if(aSet2)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000005	 beq         |$LN3@XllpGpioSe@2|

; 234  : 	{
; 235  : 		LockID = XllpLock(GPDR2);

  000c0	e3a00006	 mov         r0, #6
  000c4	eb000000	 bl          XllpLock

; 236  : 		pGPIO->GPDR2=((pGPIO->GPDR2)| aMask2);

  000c8	e5943014	 ldr         r3, [r4, #0x14]

; 237  : 		XllpUnlock(LockID);

  000cc	e1833008	 orr         r3, r3, r8
  000d0	e5843014	 str         r3, [r4, #0x14]
  000d4	eb000000	 bl          XllpUnlock
  000d8		 |$LN3@XllpGpioSe@2|

; 238  : 	}
; 239  : 	if(aSet1)

  000d8	e3560000	 cmp         r6, #0
  000dc	0a000005	 beq         |$LN2@XllpGpioSe@2|

; 240  : 	{
; 241  : 		LockID = XllpLock(GPDR1);

  000e0	e3a00005	 mov         r0, #5
  000e4	eb000000	 bl          XllpLock

; 242  : 		pGPIO->GPDR1=((pGPIO->GPDR1)| aMask1);

  000e8	e5943010	 ldr         r3, [r4, #0x10]

; 243  : 		XllpUnlock(LockID);

  000ec	e183300a	 orr         r3, r3, r10
  000f0	e5843010	 str         r3, [r4, #0x10]
  000f4	eb000000	 bl          XllpUnlock
  000f8		 |$LN2@XllpGpioSe@2|

; 244  : 	}
; 245  : 	if(aSet0)

  000f8	e3570000	 cmp         r7, #0
  000fc	0a000005	 beq         |$LN1@XllpGpioSe@2|

; 246  : 	{
; 247  : 		LockID = XllpLock(GPDR0);

  00100	e3a00004	 mov         r0, #4
  00104	eb000000	 bl          XllpLock

; 248  : 		pGPIO->GPDR0=((pGPIO->GPDR0)| aMask0);

  00108	e594300c	 ldr         r3, [r4, #0xC]

; 249  : 		XllpUnlock(LockID);

  0010c	e1833009	 orr         r3, r3, r9
  00110	e584300c	 str         r3, [r4, #0xC]
  00114	eb000000	 bl          XllpUnlock
  00118		 |$LN1@XllpGpioSe@2|

; 250  : 	}
; 251  :     }

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M1317|

			 ENDP  ; |XllpGpioSetDirectionOut|

	EXPORT	|XllpGpioSetOutputState1|

  00000			 AREA	 |.pdata|, PDATA
|$T1340| DCD	|$LN20@XllpGpioSe@3|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetOutputState1| PROC

; 261  : 	{

  00000		 |$LN20@XllpGpioSe@3|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1337|
  00008	e58d0000	 str         r0, [sp]

; 262  : 	XLLP_UINT32_T aGpioPinMask;
; 263  : 	XLLP_UINT32_T aSizeArray;
; 264  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 265  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 266  : 	XLLP_UINT32_T i;
; 267  : 
; 268  : 	//determine size of array
; 269  : 	aSizeArray = aGpioPinArray[0];

  0000c	e5917000	 ldr         r7, [r1]

; 270  : 	aMask0=aMask1=aMask2=aMask3=0;

  00010	e3a05000	 mov         r5, #0
  00014	e3a06000	 mov         r6, #0

; 271  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 272  : 
; 273  : 	for(i=1; i<=aSizeArray; i++)

  00018	e3570001	 cmp         r7, #1
  0001c	e3a04000	 mov         r4, #0
  00020	e3a0e000	 mov         lr, #0
  00024	e3a09000	 mov         r9, #0
  00028	e3a0b000	 mov         r11, #0
  0002c	e3a0a000	 mov         r10, #0
  00030	e3a08000	 mov         r8, #0
  00034	3a00001d	 bcc         |$LN1@XllpGpioSe@3|
  00038	e2811004	 add         r1, r1, #4
  0003c	e3a00001	 mov         r0, #1
  00040		 |$LL13@XllpGpioSe@3|

; 274  : 	{
; 275  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00040	e5913000	 ldr         r3, [r1]
  00044	e203201f	 and         r2, r3, #0x1F

; 276  : 		if(aGpioPinArray[i] > 95)

  00048	e353005f	 cmp         r3, #0x5F

; 277  : 		{
; 278  : 			aMask3 |= aGpioPinMask;

  0004c	81855210	 orrhi       r5, r5, r0, lsl r2

; 279  : 			aSet3=XLLP_TRUE;

  00050	83a09001	 movhi       r9, #1
  00054	8a000009	 bhi         |$LN12@XllpGpioSe@3|

; 280  : 		}
; 281  : 		else if(aGpioPinArray[i] > 63)

  00058	e5913000	 ldr         r3, [r1]
  0005c	e353003f	 cmp         r3, #0x3F

; 282  : 		{
; 283  : 			aMask2 |= aGpioPinMask;

  00060	81866210	 orrhi       r6, r6, r0, lsl r2

; 284  : 			aSet2=XLLP_TRUE;

  00064	83a0b001	 movhi       r11, #1
  00068	8a000004	 bhi         |$LN12@XllpGpioSe@3|

; 285  : 		}
; 286  : 		else if(aGpioPinArray[i] > 31)

  0006c	e353001f	 cmp         r3, #0x1F

; 287  : 		{
; 288  : 			aMask1 |= aGpioPinMask;

  00070	81844210	 orrhi       r4, r4, r0, lsl r2

; 289  : 			aSet1=XLLP_TRUE;

  00074	83a0a001	 movhi       r10, #1

; 290  : 		}
; 291  : 		else
; 292  : 		{
; 293  : 			aMask0 |= aGpioPinMask;

  00078	918ee210	 orrls       lr, lr, r0, lsl r2

; 294  : 			aSet0=XLLP_TRUE;

  0007c	93a08001	 movls       r8, #1
  00080		 |$LN12@XllpGpioSe@3|
  00080	e2811004	 add         r1, r1, #4
  00084	e2577001	 subs        r7, r7, #1
  00088	1affffec	 bne         |$LL13@XllpGpioSe@3|

; 295  : 		}
; 296  : 	}
; 297  : 	if(aSet3)

  0008c	e59d0000	 ldr         r0, [sp]
  00090	e3590000	 cmp         r9, #0

; 298  : 		pGPIO->GPSR3=aMask3;

  00094	15805118	 strne       r5, [r0, #0x118]

; 299  : 	if(aSet2)

  00098	e35b0000	 cmp         r11, #0

; 300  : 		pGPIO->GPSR2=aMask2;

  0009c	15806020	 strne       r6, [r0, #0x20]

; 301  : 	if(aSet1)

  000a0	e35a0000	 cmp         r10, #0

; 302  : 		pGPIO->GPSR1=aMask1;

  000a4	1580401c	 strne       r4, [r0, #0x1C]

; 303  : 	if(aSet0)

  000a8	e3580000	 cmp         r8, #0

; 304  : 		pGPIO->GPSR0=aMask0;

  000ac	1580e018	 strne       lr, [r0, #0x18]
  000b0		 |$LN1@XllpGpioSe@3|

; 305  : 	}

  000b0	e28dd004	 add         sp, sp, #4
  000b4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M1338|

			 ENDP  ; |XllpGpioSetOutputState1|

	EXPORT	|XllpGpioSetOutput0|

  00000			 AREA	 |.pdata|, PDATA
|$T1361| DCD	|$LN20@XllpGpioSe@4|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetOutput0| PROC

; 315  : 	{

  00000		 |$LN20@XllpGpioSe@4|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1358|
  00008	e58d0000	 str         r0, [sp]

; 316  : 	XLLP_UINT32_T aGpioPinMask;
; 317  : 	XLLP_UINT32_T aSizeArray;
; 318  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 319  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 320  : 	XLLP_UINT32_T i;
; 321  : 
; 322  : 	//determine size of array
; 323  : 	aSizeArray = aGpioPinArray[0];

  0000c	e5917000	 ldr         r7, [r1]

; 324  : 	aMask0=aMask1=aMask2=aMask3=0;

  00010	e3a05000	 mov         r5, #0
  00014	e3a06000	 mov         r6, #0

; 325  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 326  : 
; 327  : 	for(i=1; i<=aSizeArray; i++)

  00018	e3570001	 cmp         r7, #1
  0001c	e3a04000	 mov         r4, #0
  00020	e3a0e000	 mov         lr, #0
  00024	e3a09000	 mov         r9, #0
  00028	e3a0b000	 mov         r11, #0
  0002c	e3a0a000	 mov         r10, #0
  00030	e3a08000	 mov         r8, #0
  00034	3a00001d	 bcc         |$LN1@XllpGpioSe@4|
  00038	e2811004	 add         r1, r1, #4
  0003c	e3a00001	 mov         r0, #1
  00040		 |$LL13@XllpGpioSe@4|

; 328  : 	{
; 329  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00040	e5913000	 ldr         r3, [r1]
  00044	e203201f	 and         r2, r3, #0x1F

; 330  : 		if(aGpioPinArray[i] > 95)

  00048	e353005f	 cmp         r3, #0x5F

; 331  : 		{
; 332  : 			aMask3 |= aGpioPinMask;

  0004c	81855210	 orrhi       r5, r5, r0, lsl r2

; 333  : 			aSet3=XLLP_TRUE;

  00050	83a09001	 movhi       r9, #1
  00054	8a000009	 bhi         |$LN12@XllpGpioSe@4|

; 334  : 		}
; 335  : 		else if(aGpioPinArray[i] > 63)

  00058	e5913000	 ldr         r3, [r1]
  0005c	e353003f	 cmp         r3, #0x3F

; 336  : 		{
; 337  : 			aMask2 |= aGpioPinMask;

  00060	81866210	 orrhi       r6, r6, r0, lsl r2

; 338  : 			aSet2=XLLP_TRUE;

  00064	83a0b001	 movhi       r11, #1
  00068	8a000004	 bhi         |$LN12@XllpGpioSe@4|

; 339  : 		}
; 340  : 		else if(aGpioPinArray[i] > 31)

  0006c	e353001f	 cmp         r3, #0x1F

; 341  : 		{
; 342  : 			aMask1 |= aGpioPinMask;

  00070	81844210	 orrhi       r4, r4, r0, lsl r2

; 343  : 			aSet1=XLLP_TRUE;

  00074	83a0a001	 movhi       r10, #1

; 344  : 		}
; 345  : 		else
; 346  : 		{
; 347  : 			aMask0 |= aGpioPinMask;

  00078	918ee210	 orrls       lr, lr, r0, lsl r2

; 348  : 			aSet0=XLLP_TRUE;

  0007c	93a08001	 movls       r8, #1
  00080		 |$LN12@XllpGpioSe@4|
  00080	e2811004	 add         r1, r1, #4
  00084	e2577001	 subs        r7, r7, #1
  00088	1affffec	 bne         |$LL13@XllpGpioSe@4|

; 349  : 		}
; 350  : 	}
; 351  : 	if(aSet3)

  0008c	e59d0000	 ldr         r0, [sp]
  00090	e3590000	 cmp         r9, #0

; 352  : 		pGPIO->GPCR3=aMask3;

  00094	15805124	 strne       r5, [r0, #0x124]

; 353  : 	if(aSet2)

  00098	e35b0000	 cmp         r11, #0

; 354  : 		pGPIO->GPCR2=aMask2;

  0009c	1580602c	 strne       r6, [r0, #0x2C]

; 355  : 	if(aSet1)

  000a0	e35a0000	 cmp         r10, #0

; 356  : 		pGPIO->GPCR1=aMask1;

  000a4	15804028	 strne       r4, [r0, #0x28]

; 357  : 	if(aSet0)

  000a8	e3580000	 cmp         r8, #0

; 358  : 		pGPIO->GPCR0=aMask0;

  000ac	1580e024	 strne       lr, [r0, #0x24]
  000b0		 |$LN1@XllpGpioSe@4|

; 359  : 	}

  000b0	e28dd004	 add         sp, sp, #4
  000b4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M1359|

			 ENDP  ; |XllpGpioSetOutput0|

	EXPORT	|XllpGpioGetRisingDetectEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T1374| DCD	|$LN12@XllpGpioGe@3|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioGetRisingDetectEnable| PROC

; 370  : 	{

  00000		 |$LN12@XllpGpioGe@3|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1371|

; 371  : 	
; 372  : 	XLLP_UINT32_T aGpioPinMask;
; 373  : 
; 374  : 	aGpioPinMask = 0x1 << (aGpioPin & 0x1F);
; 375  : 
; 376  : 	if(aGpioPin > 95)

  00004	e351005f	 cmp         r1, #0x5F

; 377  : 		return (pGPIO->GRER3& aGpioPinMask);

  00008	85903130	 ldrhi       r3, [r0, #0x130]
  0000c	e201201f	 and         r2, r1, #0x1F
  00010	e3a0e001	 mov         lr, #1
  00014	8a000005	 bhi         |$LN9@XllpGpioGe@3|

; 378  : 	else if(aGpioPin > 63) 

  00018	e351003f	 cmp         r1, #0x3F

; 379  : 		return (pGPIO->GRER2 & aGpioPinMask);

  0001c	85903038	 ldrhi       r3, [r0, #0x38]
  00020	8a000002	 bhi         |$LN9@XllpGpioGe@3|

; 380  : 	else if(aGpioPin > 31) 

  00024	e351001f	 cmp         r1, #0x1F

; 381  : 		return (pGPIO->GRER1 & aGpioPinMask);

  00028	85903034	 ldrhi       r3, [r0, #0x34]

; 382  : 	else return (pGPIO->GRER0 & aGpioPinMask);

  0002c	95903030	 ldrls       r3, [r0, #0x30]
  00030		 |$LN9@XllpGpioGe@3|
  00030	e003021e	 and         r0, r3, lr, lsl r2

; 383  : 	}

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M1372|

			 ENDP  ; |XllpGpioGetRisingDetectEnable|

	EXPORT	|XllpGpioSetRisingDetectDisable|

  00000			 AREA	 |.pdata|, PDATA
|$T1399| DCD	|$LN20@XllpGpioSe@5|
	DCD	0x40004902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetRisingDetectDisable| PROC

; 392  : 	{

  00000		 |$LN20@XllpGpioSe@5|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1396|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 393  : 	XLLP_UINT32_T LockID;
; 394  : 	XLLP_UINT32_T aGpioPinMask;
; 395  : 	XLLP_UINT32_T aSizeArray;
; 396  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 397  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 398  : 	XLLP_UINT32_T i;
; 399  : 
; 400  : 	//determine size of array
; 401  : 	aSizeArray = aGpioPinArray[0];

  00010	e5910000	 ldr         r0, [r1]

; 402  : 	aMask0=aMask1=aMask2=aMask3=0;

  00014	e3a0b000	 mov         r11, #0
  00018	e3a07000	 mov         r7, #0

; 403  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 404  : 
; 405  : 	for(i=1; i<=aSizeArray; i++)

  0001c	e3500001	 cmp         r0, #1
  00020	e3a09000	 mov         r9, #0
  00024	e3a0a000	 mov         r10, #0
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a05000	 mov         r5, #0
  00030	e3a06000	 mov         r6, #0
  00034	e3a08000	 mov         r8, #0
  00038	3a000036	 bcc         |$LN1@XllpGpioSe@5|
  0003c	e2811004	 add         r1, r1, #4
  00040	e3a04001	 mov         r4, #1
  00044		 |$LL13@XllpGpioSe@5|

; 406  : 	{
; 407  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00044	e5913000	 ldr         r3, [r1]
  00048	e203201f	 and         r2, r3, #0x1F

; 408  : 		if(aGpioPinArray[i] > 95)

  0004c	e353005f	 cmp         r3, #0x5F

; 409  : 		{
; 410  : 			aMask3 |= aGpioPinMask;

  00050	818bb214	 orrhi       r11, r11, r4, lsl r2

; 411  : 			aSet3=XLLP_TRUE;

  00054	83a0e001	 movhi       lr, #1
  00058	8a000009	 bhi         |$LN12@XllpGpioSe@5|

; 412  : 		}
; 413  : 		else if(aGpioPinArray[i] > 63)

  0005c	e5913000	 ldr         r3, [r1]
  00060	e353003f	 cmp         r3, #0x3F

; 414  : 		{
; 415  : 			aMask2 |= aGpioPinMask;

  00064	81877214	 orrhi       r7, r7, r4, lsl r2

; 416  : 			aSet2=XLLP_TRUE;

  00068	83a05001	 movhi       r5, #1
  0006c	8a000004	 bhi         |$LN12@XllpGpioSe@5|

; 417  : 		}
; 418  : 		else if(aGpioPinArray[i] > 31)

  00070	e353001f	 cmp         r3, #0x1F

; 419  : 		{
; 420  : 			aMask1 |= aGpioPinMask;

  00074	81899214	 orrhi       r9, r9, r4, lsl r2

; 421  : 			aSet1=XLLP_TRUE;

  00078	83a06001	 movhi       r6, #1

; 422  : 		}
; 423  : 		else
; 424  : 		{
; 425  : 			aMask0 |= aGpioPinMask;

  0007c	918aa214	 orrls       r10, r10, r4, lsl r2

; 426  : 			aSet0=XLLP_TRUE;

  00080	93a08001	 movls       r8, #1
  00084		 |$LN12@XllpGpioSe@5|
  00084	e2811004	 add         r1, r1, #4
  00088	e2500001	 subs        r0, r0, #1
  0008c	1affffec	 bne         |$LL13@XllpGpioSe@5|

; 427  : 		}
; 428  : 	}
; 429  : 	if(aSet3)

  00090	e59d4000	 ldr         r4, [sp]
  00094	e35e0000	 cmp         lr, #0
  00098	0a000006	 beq         |$LN4@XllpGpioSe@5|

; 430  : 	{
; 431  : 		LockID = XllpLock(GRER3);

  0009c	e3a00022	 mov         r0, #0x22
  000a0	eb000000	 bl          XllpLock

; 432  : 		pGPIO->GRER3=((pGPIO->GRER3&~aMask3)&~XLLP_GPIO_PIN_RESERVED_BITS);

  000a4	e5943130	 ldr         r3, [r4, #0x130]
  000a8	e1c3300b	 bic         r3, r3, r11
  000ac	e3c334fe	 bic         r3, r3, #0xFE, 8
  000b0	e5843130	 str         r3, [r4, #0x130]

; 433  : 		XllpUnlock(LockID);

  000b4	eb000000	 bl          XllpUnlock
  000b8		 |$LN4@XllpGpioSe@5|

; 434  : 	}
; 435  : 	if(aSet2)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000005	 beq         |$LN3@XllpGpioSe@5|

; 436  : 	{
; 437  : 		LockID = XllpLock(GRER2);

  000c0	e3a0000f	 mov         r0, #0xF
  000c4	eb000000	 bl          XllpLock

; 438  : 		pGPIO->GRER2=((pGPIO->GRER2)&~aMask2);

  000c8	e5943038	 ldr         r3, [r4, #0x38]
  000cc	e1c33007	 bic         r3, r3, r7
  000d0	e5843038	 str         r3, [r4, #0x38]

; 439  : 		XllpUnlock(LockID);

  000d4	eb000000	 bl          XllpUnlock
  000d8		 |$LN3@XllpGpioSe@5|

; 440  : 	}
; 441  : 	if(aSet1)

  000d8	e3560000	 cmp         r6, #0
  000dc	0a000005	 beq         |$LN2@XllpGpioSe@5|

; 442  : 	{
; 443  : 		LockID = XllpLock(GRER1);

  000e0	e3a0000e	 mov         r0, #0xE
  000e4	eb000000	 bl          XllpLock

; 444  : 		pGPIO->GRER1=((pGPIO->GRER1)&~aMask1);

  000e8	e5943034	 ldr         r3, [r4, #0x34]
  000ec	e1c33009	 bic         r3, r3, r9
  000f0	e5843034	 str         r3, [r4, #0x34]

; 445  : 		XllpUnlock(LockID);

  000f4	eb000000	 bl          XllpUnlock
  000f8		 |$LN2@XllpGpioSe@5|

; 446  : 	}
; 447  : 	if(aSet0)

  000f8	e3580000	 cmp         r8, #0
  000fc	0a000005	 beq         |$LN1@XllpGpioSe@5|

; 448  : 	{
; 449  : 		LockID = XllpLock(GRER0);

  00100	e3a0000d	 mov         r0, #0xD
  00104	eb000000	 bl          XllpLock

; 450  : 		pGPIO->GRER0=((pGPIO->GRER0)&~aMask0);

  00108	e5943030	 ldr         r3, [r4, #0x30]
  0010c	e1c3300a	 bic         r3, r3, r10
  00110	e5843030	 str         r3, [r4, #0x30]

; 451  : 		XllpUnlock(LockID);

  00114	eb000000	 bl          XllpUnlock
  00118		 |$LN1@XllpGpioSe@5|

; 452  : 	}
; 453  : 	}

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M1397|

			 ENDP  ; |XllpGpioSetRisingDetectDisable|

	EXPORT	|XllpGpioSetRisingDetectEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T1424| DCD	|$LN20@XllpGpioSe@6|
	DCD	0x40004902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetRisingDetectEnable| PROC

; 462  : 	{

  00000		 |$LN20@XllpGpioSe@6|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1421|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 463  : 	XLLP_UINT32_T LockID;
; 464  : 	XLLP_UINT32_T aGpioPinMask;
; 465  : 	XLLP_UINT32_T aSizeArray;
; 466  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 467  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 468  : 	XLLP_UINT32_T i;
; 469  : 
; 470  : 	//determine size of array
; 471  : 	aSizeArray = aGpioPinArray[0];

  00010	e5910000	 ldr         r0, [r1]

; 472  : 	aMask0=aMask1=aMask2=aMask3=0;

  00014	e3a0b000	 mov         r11, #0
  00018	e3a08000	 mov         r8, #0

; 473  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 474  : 
; 475  : 	for(i=1; i<=aSizeArray; i++)

  0001c	e3500001	 cmp         r0, #1
  00020	e3a0a000	 mov         r10, #0
  00024	e3a09000	 mov         r9, #0
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a05000	 mov         r5, #0
  00030	e3a06000	 mov         r6, #0
  00034	e3a07000	 mov         r7, #0
  00038	3a000036	 bcc         |$LN1@XllpGpioSe@6|
  0003c	e2811004	 add         r1, r1, #4
  00040	e3a04001	 mov         r4, #1
  00044		 |$LL13@XllpGpioSe@6|

; 476  : 	{
; 477  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00044	e5913000	 ldr         r3, [r1]
  00048	e203201f	 and         r2, r3, #0x1F

; 478  : 		if(aGpioPinArray[i] > 95)

  0004c	e353005f	 cmp         r3, #0x5F

; 479  : 		{
; 480  : 			aMask3 |= aGpioPinMask;

  00050	818bb214	 orrhi       r11, r11, r4, lsl r2

; 481  : 			aSet3=XLLP_TRUE;

  00054	83a0e001	 movhi       lr, #1
  00058	8a000009	 bhi         |$LN12@XllpGpioSe@6|

; 482  : 		}
; 483  : 		else if(aGpioPinArray[i] > 63)

  0005c	e5913000	 ldr         r3, [r1]
  00060	e353003f	 cmp         r3, #0x3F

; 484  : 		{
; 485  : 			aMask2 |= aGpioPinMask;

  00064	81888214	 orrhi       r8, r8, r4, lsl r2

; 486  : 			aSet2=XLLP_TRUE;

  00068	83a05001	 movhi       r5, #1
  0006c	8a000004	 bhi         |$LN12@XllpGpioSe@6|

; 487  : 		}
; 488  : 		else if(aGpioPinArray[i] > 31)

  00070	e353001f	 cmp         r3, #0x1F

; 489  : 		{
; 490  : 			aMask1 |= aGpioPinMask;

  00074	818aa214	 orrhi       r10, r10, r4, lsl r2

; 491  : 			aSet1=XLLP_TRUE;

  00078	83a06001	 movhi       r6, #1

; 492  : 		}
; 493  : 		else
; 494  : 		{
; 495  : 			aMask0 |= aGpioPinMask;

  0007c	91899214	 orrls       r9, r9, r4, lsl r2

; 496  : 			aSet0=XLLP_TRUE;

  00080	93a07001	 movls       r7, #1
  00084		 |$LN12@XllpGpioSe@6|
  00084	e2811004	 add         r1, r1, #4
  00088	e2500001	 subs        r0, r0, #1
  0008c	1affffec	 bne         |$LL13@XllpGpioSe@6|

; 497  : 		}
; 498  : 	}
; 499  : 	if(aSet3)

  00090	e59d4000	 ldr         r4, [sp]
  00094	e35e0000	 cmp         lr, #0
  00098	0a000006	 beq         |$LN4@XllpGpioSe@6|

; 500  : 	{
; 501  : 		LockID = XllpLock(GRER3);

  0009c	e3a00022	 mov         r0, #0x22
  000a0	eb000000	 bl          XllpLock

; 502  : 		pGPIO->GRER3=((pGPIO->GRER3|aMask3)&~XLLP_GPIO_PIN_RESERVED_BITS);

  000a4	e5943130	 ldr         r3, [r4, #0x130]
  000a8	e183300b	 orr         r3, r3, r11
  000ac	e3c334fe	 bic         r3, r3, #0xFE, 8
  000b0	e5843130	 str         r3, [r4, #0x130]

; 503  : 		XllpUnlock(LockID);

  000b4	eb000000	 bl          XllpUnlock
  000b8		 |$LN4@XllpGpioSe@6|

; 504  : 	}
; 505  : 	if(aSet2)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000005	 beq         |$LN3@XllpGpioSe@6|

; 506  : 	{
; 507  : 		LockID = XllpLock(GRER2);

  000c0	e3a0000f	 mov         r0, #0xF
  000c4	eb000000	 bl          XllpLock

; 508  : 		pGPIO->GRER2=((pGPIO->GRER2)|aMask2);

  000c8	e5943038	 ldr         r3, [r4, #0x38]

; 509  : 		XllpUnlock(LockID);

  000cc	e1833008	 orr         r3, r3, r8
  000d0	e5843038	 str         r3, [r4, #0x38]
  000d4	eb000000	 bl          XllpUnlock
  000d8		 |$LN3@XllpGpioSe@6|

; 510  : 	}
; 511  : 	if(aSet1)

  000d8	e3560000	 cmp         r6, #0
  000dc	0a000005	 beq         |$LN2@XllpGpioSe@6|

; 512  : 	{
; 513  : 		LockID = XllpLock(GRER1);

  000e0	e3a0000e	 mov         r0, #0xE
  000e4	eb000000	 bl          XllpLock

; 514  : 		pGPIO->GRER1=((pGPIO->GRER1)|aMask1);

  000e8	e5943034	 ldr         r3, [r4, #0x34]

; 515  : 		XllpUnlock(LockID);

  000ec	e183300a	 orr         r3, r3, r10
  000f0	e5843034	 str         r3, [r4, #0x34]
  000f4	eb000000	 bl          XllpUnlock
  000f8		 |$LN2@XllpGpioSe@6|

; 516  : 	}
; 517  : 	if(aSet0)

  000f8	e3570000	 cmp         r7, #0
  000fc	0a000005	 beq         |$LN1@XllpGpioSe@6|

; 518  : 	{
; 519  : 		LockID = XllpLock(GRER0);

  00100	e3a0000d	 mov         r0, #0xD
  00104	eb000000	 bl          XllpLock

; 520  : 		pGPIO->GRER0=((pGPIO->GRER0)|aMask0);

  00108	e5943030	 ldr         r3, [r4, #0x30]

; 521  : 		XllpUnlock(LockID);

  0010c	e1833009	 orr         r3, r3, r9
  00110	e5843030	 str         r3, [r4, #0x30]
  00114	eb000000	 bl          XllpUnlock
  00118		 |$LN1@XllpGpioSe@6|

; 522  : 	}
; 523  : 	}

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M1422|

			 ENDP  ; |XllpGpioSetRisingDetectEnable|

	EXPORT	|XllpGpioGetFallingDetectEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T1437| DCD	|$LN12@XllpGpioGe@4|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioGetFallingDetectEnable| PROC

; 534  : 	{

  00000		 |$LN12@XllpGpioGe@4|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1434|

; 535  : 	XLLP_UINT32_T aGpioPinMask;
; 536  : 
; 537  : 	aGpioPinMask = 0x1 << (aGpioPin & 0x1F);
; 538  : 
; 539  : 	if(aGpioPin > 95)

  00004	e351005f	 cmp         r1, #0x5F

; 540  : 		return (pGPIO->GFER3 & aGpioPinMask);

  00008	8590313c	 ldrhi       r3, [r0, #0x13C]
  0000c	e201201f	 and         r2, r1, #0x1F
  00010	e3a0e001	 mov         lr, #1
  00014	8a000005	 bhi         |$LN9@XllpGpioGe@4|

; 541  : 	else if(aGpioPin > 63) 

  00018	e351003f	 cmp         r1, #0x3F

; 542  : 		return (pGPIO->GFER2 & aGpioPinMask);

  0001c	85903044	 ldrhi       r3, [r0, #0x44]
  00020	8a000002	 bhi         |$LN9@XllpGpioGe@4|

; 543  : 	else if(aGpioPin > 31) 

  00024	e351001f	 cmp         r1, #0x1F

; 544  : 		return (pGPIO->GFER1 & aGpioPinMask);

  00028	85903040	 ldrhi       r3, [r0, #0x40]

; 545  : 	else return (pGPIO->GFER0 & aGpioPinMask);

  0002c	9590303c	 ldrls       r3, [r0, #0x3C]
  00030		 |$LN9@XllpGpioGe@4|
  00030	e003021e	 and         r0, r3, lr, lsl r2

; 546  : 	}

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M1435|

			 ENDP  ; |XllpGpioGetFallingDetectEnable|

	EXPORT	|XllpGpioSetFallingEdgeDetectDisable|

  00000			 AREA	 |.pdata|, PDATA
|$T1462| DCD	|$LN20@XllpGpioSe@7|
	DCD	0x40004902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetFallingEdgeDetectDisable| PROC

; 555  : 	{

  00000		 |$LN20@XllpGpioSe@7|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1459|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 556  : 	XLLP_UINT32_T LockID;
; 557  : 	XLLP_UINT32_T aGpioPinMask;
; 558  : 	XLLP_UINT32_T aSizeArray;
; 559  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 560  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 561  : 	XLLP_UINT32_T i;
; 562  : 
; 563  : 	//determine size of array
; 564  : 	aSizeArray = aGpioPinArray[0];

  00010	e5910000	 ldr         r0, [r1]

; 565  : 	aMask0=aMask1=aMask2=aMask3=0;

  00014	e3a0b000	 mov         r11, #0
  00018	e3a07000	 mov         r7, #0

; 566  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 567  : 
; 568  : 	for(i=1; i<=aSizeArray; i++)

  0001c	e3500001	 cmp         r0, #1
  00020	e3a09000	 mov         r9, #0
  00024	e3a0a000	 mov         r10, #0
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a05000	 mov         r5, #0
  00030	e3a06000	 mov         r6, #0
  00034	e3a08000	 mov         r8, #0
  00038	3a000036	 bcc         |$LN1@XllpGpioSe@7|
  0003c	e2811004	 add         r1, r1, #4
  00040	e3a04001	 mov         r4, #1
  00044		 |$LL13@XllpGpioSe@7|

; 569  : 	{
; 570  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00044	e5913000	 ldr         r3, [r1]
  00048	e203201f	 and         r2, r3, #0x1F

; 571  : 		if(aGpioPinArray[i] > 95)

  0004c	e353005f	 cmp         r3, #0x5F

; 572  : 		{
; 573  : 			aMask3 |= aGpioPinMask;

  00050	818bb214	 orrhi       r11, r11, r4, lsl r2

; 574  : 			aSet3=XLLP_TRUE;

  00054	83a0e001	 movhi       lr, #1
  00058	8a000009	 bhi         |$LN12@XllpGpioSe@7|

; 575  : 		}
; 576  : 		else if(aGpioPinArray[i] > 63)

  0005c	e5913000	 ldr         r3, [r1]
  00060	e353003f	 cmp         r3, #0x3F

; 577  : 		{
; 578  : 			aMask2 |= aGpioPinMask;

  00064	81877214	 orrhi       r7, r7, r4, lsl r2

; 579  : 			aSet2=XLLP_TRUE;

  00068	83a05001	 movhi       r5, #1
  0006c	8a000004	 bhi         |$LN12@XllpGpioSe@7|

; 580  : 		}
; 581  : 		else if(aGpioPinArray[i] > 31)

  00070	e353001f	 cmp         r3, #0x1F

; 582  : 		{
; 583  : 			aMask1 |= aGpioPinMask;

  00074	81899214	 orrhi       r9, r9, r4, lsl r2

; 584  : 			aSet1=XLLP_TRUE;

  00078	83a06001	 movhi       r6, #1

; 585  : 		}
; 586  : 		else
; 587  : 		{
; 588  : 			aMask0 |= aGpioPinMask;

  0007c	918aa214	 orrls       r10, r10, r4, lsl r2

; 589  : 			aSet0=XLLP_TRUE;

  00080	93a08001	 movls       r8, #1
  00084		 |$LN12@XllpGpioSe@7|
  00084	e2811004	 add         r1, r1, #4
  00088	e2500001	 subs        r0, r0, #1
  0008c	1affffec	 bne         |$LL13@XllpGpioSe@7|

; 590  : 		}
; 591  : 	}
; 592  : 	if(aSet3)

  00090	e59d4000	 ldr         r4, [sp]
  00094	e35e0000	 cmp         lr, #0
  00098	0a000006	 beq         |$LN4@XllpGpioSe@7|

; 593  : 	{
; 594  : 		LockID = XllpLock(GFER3);

  0009c	e3a00023	 mov         r0, #0x23
  000a0	eb000000	 bl          XllpLock

; 595  : 		pGPIO->GFER3=((pGPIO->GFER3&~aMask3)&~XLLP_GPIO_PIN_RESERVED_BITS);

  000a4	e594313c	 ldr         r3, [r4, #0x13C]
  000a8	e1c3300b	 bic         r3, r3, r11
  000ac	e3c334fe	 bic         r3, r3, #0xFE, 8
  000b0	e584313c	 str         r3, [r4, #0x13C]

; 596  : 		XllpUnlock(LockID);

  000b4	eb000000	 bl          XllpUnlock
  000b8		 |$LN4@XllpGpioSe@7|

; 597  : 	}
; 598  : 	if(aSet2)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000005	 beq         |$LN3@XllpGpioSe@7|

; 599  : 	{
; 600  : 		LockID = XllpLock(GFER2);

  000c0	e3a00012	 mov         r0, #0x12
  000c4	eb000000	 bl          XllpLock

; 601  : 		pGPIO->GFER2=((pGPIO->GFER2)&~aMask2);

  000c8	e5943044	 ldr         r3, [r4, #0x44]
  000cc	e1c33007	 bic         r3, r3, r7
  000d0	e5843044	 str         r3, [r4, #0x44]

; 602  : 		XllpUnlock(LockID);

  000d4	eb000000	 bl          XllpUnlock
  000d8		 |$LN3@XllpGpioSe@7|

; 603  : 	}
; 604  : 	if(aSet1)

  000d8	e3560000	 cmp         r6, #0
  000dc	0a000005	 beq         |$LN2@XllpGpioSe@7|

; 605  : 	{
; 606  : 		LockID = XllpLock(GFER1);

  000e0	e3a00011	 mov         r0, #0x11
  000e4	eb000000	 bl          XllpLock

; 607  : 		pGPIO->GFER1=((pGPIO->GFER1)&~aMask1);

  000e8	e5943040	 ldr         r3, [r4, #0x40]
  000ec	e1c33009	 bic         r3, r3, r9
  000f0	e5843040	 str         r3, [r4, #0x40]

; 608  : 		XllpUnlock(LockID);

  000f4	eb000000	 bl          XllpUnlock
  000f8		 |$LN2@XllpGpioSe@7|

; 609  : 	}
; 610  : 	if(aSet0)

  000f8	e3580000	 cmp         r8, #0
  000fc	0a000005	 beq         |$LN1@XllpGpioSe@7|

; 611  : 	{
; 612  : 		LockID = XllpLock(GFER0);

  00100	e3a00010	 mov         r0, #0x10
  00104	eb000000	 bl          XllpLock

; 613  : 		pGPIO->GFER0=((pGPIO->GFER0)&~aMask0);

  00108	e594303c	 ldr         r3, [r4, #0x3C]
  0010c	e1c3300a	 bic         r3, r3, r10
  00110	e584303c	 str         r3, [r4, #0x3C]

; 614  : 		XllpUnlock(LockID);

  00114	eb000000	 bl          XllpUnlock
  00118		 |$LN1@XllpGpioSe@7|

; 615  : 	}
; 616  : 	}

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M1460|

			 ENDP  ; |XllpGpioSetFallingEdgeDetectDisable|

	EXPORT	|XllpGpioSetFallingEdgeDetectEnable|

  00000			 AREA	 |.pdata|, PDATA
|$T1487| DCD	|$LN20@XllpGpioSe@8|
	DCD	0x40004902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetFallingEdgeDetectEnable| PROC

; 625  : 	{

  00000		 |$LN20@XllpGpioSe@8|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1484|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4000	 str         r4, [sp]

; 626  : 	XLLP_UINT32_T LockID;
; 627  : 	XLLP_UINT32_T aGpioPinMask;
; 628  : 	XLLP_UINT32_T aSizeArray;
; 629  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 630  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 631  : 	XLLP_UINT32_T i;
; 632  : 
; 633  : 	//determine size of array
; 634  : 	aSizeArray = aGpioPinArray[0];

  00010	e5910000	 ldr         r0, [r1]

; 635  : 	aMask0=aMask1=aMask2=aMask3=0;

  00014	e3a0b000	 mov         r11, #0
  00018	e3a08000	 mov         r8, #0

; 636  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 637  : 	
; 638  : 	for(i=1; i<=aSizeArray; i++)

  0001c	e3500001	 cmp         r0, #1
  00020	e3a0a000	 mov         r10, #0
  00024	e3a09000	 mov         r9, #0
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a05000	 mov         r5, #0
  00030	e3a06000	 mov         r6, #0
  00034	e3a07000	 mov         r7, #0
  00038	3a000036	 bcc         |$LN1@XllpGpioSe@8|
  0003c	e2811004	 add         r1, r1, #4
  00040	e3a04001	 mov         r4, #1
  00044		 |$LL13@XllpGpioSe@8|

; 639  : 	{
; 640  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00044	e5913000	 ldr         r3, [r1]
  00048	e203201f	 and         r2, r3, #0x1F

; 641  : 		if(aGpioPinArray[i] > 95)

  0004c	e353005f	 cmp         r3, #0x5F

; 642  : 		{
; 643  : 			aMask3 |= aGpioPinMask;

  00050	818bb214	 orrhi       r11, r11, r4, lsl r2

; 644  : 			aSet3=XLLP_TRUE;

  00054	83a0e001	 movhi       lr, #1
  00058	8a000009	 bhi         |$LN12@XllpGpioSe@8|

; 645  : 		}
; 646  : 		else if(aGpioPinArray[i] > 63)

  0005c	e5913000	 ldr         r3, [r1]
  00060	e353003f	 cmp         r3, #0x3F

; 647  : 		{
; 648  : 			aMask2 |= aGpioPinMask;

  00064	81888214	 orrhi       r8, r8, r4, lsl r2

; 649  : 			aSet2=XLLP_TRUE;

  00068	83a05001	 movhi       r5, #1
  0006c	8a000004	 bhi         |$LN12@XllpGpioSe@8|

; 650  : 		}
; 651  : 		else if(aGpioPinArray[i] > 31)

  00070	e353001f	 cmp         r3, #0x1F

; 652  : 		{
; 653  : 			aMask1 |= aGpioPinMask;

  00074	818aa214	 orrhi       r10, r10, r4, lsl r2

; 654  : 			aSet1=XLLP_TRUE;

  00078	83a06001	 movhi       r6, #1

; 655  : 		}
; 656  : 		else
; 657  : 		{
; 658  : 			aMask0 |= aGpioPinMask;

  0007c	91899214	 orrls       r9, r9, r4, lsl r2

; 659  : 			aSet0=XLLP_TRUE;

  00080	93a07001	 movls       r7, #1
  00084		 |$LN12@XllpGpioSe@8|
  00084	e2811004	 add         r1, r1, #4
  00088	e2500001	 subs        r0, r0, #1
  0008c	1affffec	 bne         |$LL13@XllpGpioSe@8|

; 660  : 		}
; 661  : 	}
; 662  : 	if(aSet3)

  00090	e59d4000	 ldr         r4, [sp]
  00094	e35e0000	 cmp         lr, #0
  00098	0a000006	 beq         |$LN4@XllpGpioSe@8|

; 663  : 	{
; 664  : 		LockID = XllpLock(GFER3);

  0009c	e3a00023	 mov         r0, #0x23
  000a0	eb000000	 bl          XllpLock

; 665  : 		pGPIO->GFER3=((pGPIO->GFER3|aMask3)&~XLLP_GPIO_PIN_RESERVED_BITS);

  000a4	e594313c	 ldr         r3, [r4, #0x13C]
  000a8	e183300b	 orr         r3, r3, r11
  000ac	e3c334fe	 bic         r3, r3, #0xFE, 8
  000b0	e584313c	 str         r3, [r4, #0x13C]

; 666  : 		XllpUnlock(LockID);

  000b4	eb000000	 bl          XllpUnlock
  000b8		 |$LN4@XllpGpioSe@8|

; 667  : 	}
; 668  : 	if(aSet2)

  000b8	e3550000	 cmp         r5, #0
  000bc	0a000005	 beq         |$LN3@XllpGpioSe@8|

; 669  : 	{
; 670  : 		LockID = XllpLock(GFER2);

  000c0	e3a00012	 mov         r0, #0x12
  000c4	eb000000	 bl          XllpLock

; 671  : 		pGPIO->GFER2=((pGPIO->GFER2)|aMask2);

  000c8	e5943044	 ldr         r3, [r4, #0x44]

; 672  : 		XllpUnlock(LockID);

  000cc	e1833008	 orr         r3, r3, r8
  000d0	e5843044	 str         r3, [r4, #0x44]
  000d4	eb000000	 bl          XllpUnlock
  000d8		 |$LN3@XllpGpioSe@8|

; 673  : 	}
; 674  : 	if(aSet1)

  000d8	e3560000	 cmp         r6, #0
  000dc	0a000005	 beq         |$LN2@XllpGpioSe@8|

; 675  : 	{
; 676  : 		LockID = XllpLock(GFER1);

  000e0	e3a00011	 mov         r0, #0x11
  000e4	eb000000	 bl          XllpLock

; 677  : 		pGPIO->GFER1=((pGPIO->GFER1)|aMask1);

  000e8	e5943040	 ldr         r3, [r4, #0x40]

; 678  : 		XllpUnlock(LockID);

  000ec	e183300a	 orr         r3, r3, r10
  000f0	e5843040	 str         r3, [r4, #0x40]
  000f4	eb000000	 bl          XllpUnlock
  000f8		 |$LN2@XllpGpioSe@8|

; 679  : 	}
; 680  : 	if(aSet0)

  000f8	e3570000	 cmp         r7, #0
  000fc	0a000005	 beq         |$LN1@XllpGpioSe@8|

; 681  : 	{
; 682  : 		LockID = XllpLock(GFER0);

  00100	e3a00010	 mov         r0, #0x10
  00104	eb000000	 bl          XllpLock

; 683  : 		pGPIO->GFER0=((pGPIO->GFER0)|aMask0);

  00108	e594303c	 ldr         r3, [r4, #0x3C]

; 684  : 		XllpUnlock(LockID);

  0010c	e1833009	 orr         r3, r3, r9
  00110	e584303c	 str         r3, [r4, #0x3C]
  00114	eb000000	 bl          XllpUnlock
  00118		 |$LN1@XllpGpioSe@8|

; 685  : 	}
; 686  : 	}

  00118	e28dd004	 add         sp, sp, #4
  0011c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$M1485|

			 ENDP  ; |XllpGpioSetFallingEdgeDetectEnable|

	EXPORT	|XllpGpioGetEdgeDetectStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T1500| DCD	|$LN12@XllpGpioGe@5|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioGetEdgeDetectStatus| PROC

; 697  : 	{

  00000		 |$LN12@XllpGpioGe@5|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1497|

; 698  : 	XLLP_UINT32_T aGpioPinMask;
; 699  : 
; 700  : 	aGpioPinMask = 0x1 << (aGpioPin & 0x1F);
; 701  : 
; 702  : 	if(aGpioPin > 95)

  00004	e351005f	 cmp         r1, #0x5F

; 703  : 		return (pGPIO->GEDR3& aGpioPinMask); 

  00008	85903148	 ldrhi       r3, [r0, #0x148]
  0000c	e201201f	 and         r2, r1, #0x1F
  00010	e3a0e001	 mov         lr, #1
  00014	8a000005	 bhi         |$LN9@XllpGpioGe@5|

; 704  : 	else if(aGpioPin > 63) 

  00018	e351003f	 cmp         r1, #0x3F

; 705  : 		return (pGPIO->GEDR2 & aGpioPinMask);

  0001c	85903050	 ldrhi       r3, [r0, #0x50]
  00020	8a000002	 bhi         |$LN9@XllpGpioGe@5|

; 706  : 	else if(aGpioPin > 31) 

  00024	e351001f	 cmp         r1, #0x1F

; 707  : 		return (pGPIO->GEDR1 & aGpioPinMask);

  00028	8590304c	 ldrhi       r3, [r0, #0x4C]

; 708  : 	else return (pGPIO->GEDR0 & aGpioPinMask);

  0002c	95903048	 ldrls       r3, [r0, #0x48]
  00030		 |$LN9@XllpGpioGe@5|
  00030	e003021e	 and         r0, r3, lr, lsl r2

; 709  : 	}

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$M1498|

			 ENDP  ; |XllpGpioGetEdgeDetectStatus|

	EXPORT	|XllpGpioClearEdgeDetectStatus|

  00000			 AREA	 |.pdata|, PDATA
|$T1521| DCD	|$LN20@XllpGpioCl|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioClearEdgeDetectStatus| PROC

; 718  : 	{

  00000		 |$LN20@XllpGpioCl|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M1518|
  00008	e58d0000	 str         r0, [sp]

; 719  : 	XLLP_UINT32_T aGpioPinMask;
; 720  : 	XLLP_UINT32_T aSizeArray;
; 721  : 	XLLP_UINT32_T aMask0, aMask1, aMask2, aMask3;
; 722  : 	XLLP_BOOL_T aSet0, aSet1, aSet2, aSet3;
; 723  : 	XLLP_UINT32_T i;
; 724  : 
; 725  : 	//determine size of array
; 726  : 	aSizeArray = aGpioPinArray[0];

  0000c	e5917000	 ldr         r7, [r1]

; 727  : 	aMask0=aMask1=aMask2=aMask3=0;

  00010	e3a05000	 mov         r5, #0
  00014	e3a06000	 mov         r6, #0

; 728  : 	aSet0=aSet1=aSet2=aSet3=XLLP_FALSE;
; 729  : 	
; 730  : 	for(i=1; i<=aSizeArray; i++)

  00018	e3570001	 cmp         r7, #1
  0001c	e3a04000	 mov         r4, #0
  00020	e3a0e000	 mov         lr, #0
  00024	e3a09000	 mov         r9, #0
  00028	e3a0b000	 mov         r11, #0
  0002c	e3a0a000	 mov         r10, #0
  00030	e3a08000	 mov         r8, #0
  00034	3a00001d	 bcc         |$LN1@XllpGpioCl|
  00038	e2811004	 add         r1, r1, #4
  0003c	e3a00001	 mov         r0, #1
  00040		 |$LL13@XllpGpioCl|

; 731  : 	{
; 732  : 		aGpioPinMask = 0x1u << (aGpioPinArray[i] & 0x1F);

  00040	e5913000	 ldr         r3, [r1]
  00044	e203201f	 and         r2, r3, #0x1F

; 733  : 		if(aGpioPinArray[i] > 95)

  00048	e353005f	 cmp         r3, #0x5F

; 734  : 		{
; 735  : 			aMask3 |= aGpioPinMask;

  0004c	81855210	 orrhi       r5, r5, r0, lsl r2

; 736  : 			aSet3=XLLP_TRUE;

  00050	83a09001	 movhi       r9, #1
  00054	8a000009	 bhi         |$LN12@XllpGpioCl|

; 737  : 		}
; 738  : 		else if(aGpioPinArray[i] > 63)

  00058	e5913000	 ldr         r3, [r1]
  0005c	e353003f	 cmp         r3, #0x3F

; 739  : 		{
; 740  : 			aMask2 |= aGpioPinMask;

  00060	81866210	 orrhi       r6, r6, r0, lsl r2

; 741  : 			aSet2=XLLP_TRUE;

  00064	83a0b001	 movhi       r11, #1
  00068	8a000004	 bhi         |$LN12@XllpGpioCl|

; 742  : 		}
; 743  : 		else if(aGpioPinArray[i] > 31)

  0006c	e353001f	 cmp         r3, #0x1F

; 744  : 		{
; 745  : 			aMask1 |= aGpioPinMask;

  00070	81844210	 orrhi       r4, r4, r0, lsl r2

; 746  : 			aSet1=XLLP_TRUE;

  00074	83a0a001	 movhi       r10, #1

; 747  : 		}
; 748  : 		else
; 749  : 		{
; 750  : 			aMask0 |= aGpioPinMask;

  00078	918ee210	 orrls       lr, lr, r0, lsl r2

; 751  : 			aSet0=XLLP_TRUE;

  0007c	93a08001	 movls       r8, #1
  00080		 |$LN12@XllpGpioCl|
  00080	e2811004	 add         r1, r1, #4
  00084	e2577001	 subs        r7, r7, #1
  00088	1affffec	 bne         |$LL13@XllpGpioCl|

; 752  : 		}
; 753  : 	}
; 754  : 	if(aSet3)

  0008c	e59d0000	 ldr         r0, [sp]
  00090	e3590000	 cmp         r9, #0

; 755  : 		pGPIO->GEDR3= aMask3;

  00094	15805148	 strne       r5, [r0, #0x148]

; 756  : 	if(aSet2)

  00098	e35b0000	 cmp         r11, #0

; 757  : 		pGPIO->GEDR2= aMask2;

  0009c	15806050	 strne       r6, [r0, #0x50]

; 758  : 	if(aSet1)

  000a0	e35a0000	 cmp         r10, #0

; 759  : 		pGPIO->GEDR1= aMask1;

  000a4	1580404c	 strne       r4, [r0, #0x4C]

; 760  : 	if(aSet0)

  000a8	e3580000	 cmp         r8, #0

; 761  : 		pGPIO->GEDR0= aMask0;

  000ac	1580e048	 strne       lr, [r0, #0x48]
  000b0		 |$LN1@XllpGpioCl|

; 762  : 	}

  000b0	e28dd004	 add         sp, sp, #4
  000b4	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M1519|

			 ENDP  ; |XllpGpioClearEdgeDetectStatus|

	EXPORT	|XllpGpioGetAlternateFn|

  00000			 AREA	 |.pdata|, PDATA
|$T1534| DCD	|$LN20@XllpGpioGe@6|
	DCD	0x40001c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioGetAlternateFn| PROC

; 774  : 	{

  00000		 |$LN20@XllpGpioGe@6|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M1531|

; 775  : 	XLLP_UINT32_T aGpioPinAFMask;
; 776  : 
; 777  : 	aGpioPinAFMask = 0x3u << ((aGpioPin & 0xF)*2);

  00004	e201300f	 and         r3, r1, #0xF

; 778  : 
; 779  : 	if (aGpioPin>111)

  00008	e351006f	 cmp         r1, #0x6F
  0000c	e1a02083	 mov         r2, r3, lsl #1

; 780  : 		return (pGPIO->GAFR3_U & aGpioPinAFMask);

  00010	85903070	 ldrhi       r3, [r0, #0x70]
  00014	e3a0e003	 mov         lr, #3
  00018	8a000011	 bhi         |$LN17@XllpGpioGe@6|

; 781  : 	else if (aGpioPin>95)

  0001c	e351005f	 cmp         r1, #0x5F

; 782  : 		return (pGPIO->GAFR3_L & aGpioPinAFMask);

  00020	8590306c	 ldrhi       r3, [r0, #0x6C]
  00024	8a00000e	 bhi         |$LN17@XllpGpioGe@6|

; 783  : 	else if (aGpioPin>79)

  00028	e351004f	 cmp         r1, #0x4F

; 784  : 		return (pGPIO->GAFR2_U & aGpioPinAFMask);

  0002c	85903068	 ldrhi       r3, [r0, #0x68]
  00030	8a00000b	 bhi         |$LN17@XllpGpioGe@6|

; 785  : 	else if (aGpioPin>63)

  00034	e351003f	 cmp         r1, #0x3F

; 786  : 		return (pGPIO->GAFR2_L & aGpioPinAFMask);

  00038	85903064	 ldrhi       r3, [r0, #0x64]
  0003c	8a000008	 bhi         |$LN17@XllpGpioGe@6|

; 787  : 	else if (aGpioPin>47)

  00040	e351002f	 cmp         r1, #0x2F

; 788  : 		return (pGPIO->GAFR1_U & aGpioPinAFMask);

  00044	85903060	 ldrhi       r3, [r0, #0x60]
  00048	8a000005	 bhi         |$LN17@XllpGpioGe@6|

; 789  : 	else if (aGpioPin>31)

  0004c	e351001f	 cmp         r1, #0x1F

; 790  : 		return (pGPIO->GAFR1_L & aGpioPinAFMask);

  00050	8590305c	 ldrhi       r3, [r0, #0x5C]
  00054	8a000002	 bhi         |$LN17@XllpGpioGe@6|

; 791  : 	else if (aGpioPin>15)

  00058	e351000f	 cmp         r1, #0xF

; 792  : 		return (pGPIO->GAFR0_U & aGpioPinAFMask);

  0005c	85903058	 ldrhi       r3, [r0, #0x58]

; 793  : 	else return (pGPIO->GAFR0_L & aGpioPinAFMask);

  00060	95903054	 ldrls       r3, [r0, #0x54]
  00064		 |$LN17@XllpGpioGe@6|
  00064	e003021e	 and         r0, r3, lr, lsl r2

; 794  : 	}

  00068	e49de004	 ldr         lr, [sp], #4
  0006c	e12fff1e	 bx          lr
  00070		 |$M1532|

			 ENDP  ; |XllpGpioGetAlternateFn|

	EXPORT	|XllpGpioSetAlternateFn|

  00000			 AREA	 |.pdata|, PDATA
|$T1581| DCD	|$LN32@XllpGpioSe@9|
	DCD	0x4000ee02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioSetAlternateFn| PROC

; 808  : 	{

  00000		 |$LN32@XllpGpioSe@9|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd04c	 sub         sp, sp, #0x4C
  00008		 |$M1578|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4048	 str         r4, [sp, #0x48]

; 809  : 	XLLP_UINT32_T LockID;
; 810  : 	XLLP_UINT32_T aGpioPinAFMask;
; 811  : 	XLLP_UINT32_T aGpioPinAFValue;
; 812  : 	XLLP_UINT32_T aSizeArray;
; 813  : 	XLLP_UINT32_T aMask0_U, aMask0_L, aMask1_U, aMask1_L; 
; 814  : 	XLLP_UINT32_T aMask2_U, aMask2_L, aMask3_U, aMask3_L;
; 815  : 	XLLP_UINT32_T aAFnV0_U, aAFnV0_L, aAFnV1_U, aAFnV1_L; 
; 816  : 	XLLP_UINT32_T aAFnV2_U, aAFnV2_L, aAFnV3_U, aAFnV3_L;
; 817  : 	XLLP_BOOL_T aSet0_U, aSet0_L, aSet1_U, aSet1_L; 
; 818  : 	XLLP_BOOL_T aSet2_U, aSet2_L, aSet3_U, aSet3_L;
; 819  : 	XLLP_UINT32_T i;
; 820  : 
; 821  : 	//determine size of array
; 822  : 	aSizeArray = aGpioPinArray[0];
; 823  : 	aMask0_U=aMask0_L=aMask1_U=aMask1_L=0;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3018	 str         r3, [sp, #0x18]
  00018	e3a03000	 mov         r3, #0
  0001c	e58d3010	 str         r3, [sp, #0x10]

; 824  : 	aMask2_U=aMask2_L=aMask3_U=aMask3_L=0;
; 825  : 	aAFnV0_U=aAFnV0_L=aAFnV1_U=aAFnV1_L=0;
; 826  : 	aAFnV2_U=aAFnV2_L=aAFnV3_U=aAFnV3_L=0;
; 827  : 	aSet0_U=aSet0_L=aSet1_U=aSet1_L=XLLP_FALSE;
; 828  : 	aSet2_U=aSet2_L=aSet3_U=aSet3_L=XLLP_FALSE;
; 829  : 
; 830  : 	for(i=1; i<=aSizeArray; i++)

  00020	e3a03000	 mov         r3, #0
  00024	e58d3028	 str         r3, [sp, #0x28]
  00028	e3a03000	 mov         r3, #0
  0002c	e58d3020	 str         r3, [sp, #0x20]
  00030	e3a03000	 mov         r3, #0
  00034	e58d3008	 str         r3, [sp, #8]
  00038	e3a03000	 mov         r3, #0
  0003c	e58d3000	 str         r3, [sp]
  00040	e3a03000	 mov         r3, #0
  00044	e58d301c	 str         r3, [sp, #0x1C]
  00048	e3a03000	 mov         r3, #0
  0004c	e58d3014	 str         r3, [sp, #0x14]
  00050	e3a03000	 mov         r3, #0
  00054	e58d302c	 str         r3, [sp, #0x2C]
  00058	e3a03000	 mov         r3, #0
  0005c	e58d3024	 str         r3, [sp, #0x24]
  00060	e3a03000	 mov         r3, #0
  00064	e58d3030	 str         r3, [sp, #0x30]
  00068	e3a03000	 mov         r3, #0
  0006c	e58d300c	 str         r3, [sp, #0xC]
  00070	e3a03000	 mov         r3, #0
  00074	e58d3004	 str         r3, [sp, #4]
  00078	e3a03000	 mov         r3, #0
  0007c	e58d303c	 str         r3, [sp, #0x3C]
  00080	e3a03000	 mov         r3, #0
  00084	e58d3038	 str         r3, [sp, #0x38]
  00088	e3a03000	 mov         r3, #0
  0008c	e58d3044	 str         r3, [sp, #0x44]
  00090	e591e000	 ldr         lr, [r1]
  00094	e3a03000	 mov         r3, #0
  00098	e58d3040	 str         r3, [sp, #0x40]
  0009c	e3a03000	 mov         r3, #0
  000a0	e58d3034	 str         r3, [sp, #0x34]
  000a4	e35e0001	 cmp         lr, #1
  000a8	e3a0b000	 mov         r11, #0
  000ac	e3a07000	 mov         r7, #0
  000b0	e3a08000	 mov         r8, #0
  000b4	e3a06000	 mov         r6, #0
  000b8	e3a05000	 mov         r5, #0
  000bc	e3a0a000	 mov         r10, #0
  000c0	3a0000b9	 bcc         |$LN1@XllpGpioSe@9|
  000c4	e2810004	 add         r0, r1, #4
  000c8	e0429001	 sub         r9, r2, r1
  000cc	e3a04000	 mov         r4, #0
  000d0		 |$LL25@XllpGpioSe@9|

; 831  : 	{
; 832  : 		aGpioPinAFMask = 0x3u << ((aGpioPinArray[i] & 0xF)*2);

  000d0	e5902000	 ldr         r2, [r0]

; 833  : 		aGpioPinAFValue = aAfValueArray[i] << ((aGpioPinArray[i] & 0xF)*2);

  000d4	e7991000	 ldr         r1, [r9, +r0]
  000d8	e202300f	 and         r3, r2, #0xF

; 834  : 		if (aGpioPinArray[i]>111)

  000dc	e352006f	 cmp         r2, #0x6F
  000e0	e1a03083	 mov         r3, r3, lsl #1

; 835  : 		{
; 836  : 			aAFnV3_U |= aGpioPinAFValue;
; 837  : 			aMask3_U |= aGpioPinAFMask;

  000e4	83a02003	 movhi       r2, #3
  000e8	81888311	 orrhi       r8, r8, r1, lsl r3
  000ec	81877312	 orrhi       r7, r7, r2, lsl r3

; 838  : 			aSet3_U=XLLP_TRUE;

  000f0	83a05001	 movhi       r5, #1
  000f4	8a00004a	 bhi         |$LN24@XllpGpioSe@9|

; 839  : 		}
; 840  : 		else if (aGpioPinArray[i]>95)

  000f8	e5902000	 ldr         r2, [r0]
  000fc	e352005f	 cmp         r2, #0x5F

; 841  : 		{
; 842  : 			aAFnV3_L |= aGpioPinAFValue;
; 843  : 			aMask3_L |= aGpioPinAFMask;

  00100	83a02003	 movhi       r2, #3
  00104	818bb312	 orrhi       r11, r11, r2, lsl r3
  00108	81844311	 orrhi       r4, r4, r1, lsl r3

; 844  : 			aSet3_L=XLLP_TRUE;

  0010c	83a06001	 movhi       r6, #1
  00110	8a000043	 bhi         |$LN24@XllpGpioSe@9|

; 845  : 		}
; 846  : 		else if (aGpioPinArray[i]>79)

  00114	e352004f	 cmp         r2, #0x4F
  00118	9a000008	 bls         |$LN18@XllpGpioSe@9|

; 847  : 		{
; 848  : 			aAFnV2_U |= aGpioPinAFValue;

  0011c	e59d2004	 ldr         r2, [sp, #4]

; 849  : 			aMask2_U |= aGpioPinAFMask;
; 850  : 			aSet2_U=XLLP_TRUE;

  00120	e3a0a001	 mov         r10, #1
  00124	e1822311	 orr         r2, r2, r1, lsl r3
  00128	e3a01003	 mov         r1, #3
  0012c	e58d2004	 str         r2, [sp, #4]
  00130	e59d2000	 ldr         r2, [sp]
  00134	e1822311	 orr         r2, r2, r1, lsl r3
  00138	e58d2000	 str         r2, [sp]
  0013c	ea000038	 b           |$LN24@XllpGpioSe@9|
  00140		 |$LN18@XllpGpioSe@9|

; 851  : 		}
; 852  : 		else if (aGpioPinArray[i]>63)

  00140	e352003f	 cmp         r2, #0x3F
  00144	9a000009	 bls         |$LN16@XllpGpioSe@9|

; 853  : 		{
; 854  : 			aAFnV2_L |= aGpioPinAFValue;

  00148	e59d200c	 ldr         r2, [sp, #0xC]
  0014c	e1822311	 orr         r2, r2, r1, lsl r3

; 855  : 			aMask2_L |= aGpioPinAFMask;

  00150	e3a01003	 mov         r1, #3
  00154	e58d200c	 str         r2, [sp, #0xC]
  00158	e59d2008	 ldr         r2, [sp, #8]
  0015c	e1822311	 orr         r2, r2, r1, lsl r3

; 856  : 			aSet2_L=XLLP_TRUE;

  00160	e3a03001	 mov         r3, #1
  00164	e58d2008	 str         r2, [sp, #8]
  00168	e58d3034	 str         r3, [sp, #0x34]
  0016c	ea00002c	 b           |$LN24@XllpGpioSe@9|
  00170		 |$LN16@XllpGpioSe@9|

; 857  : 		}
; 858  : 		else if (aGpioPinArray[i]>47)

  00170	e352002f	 cmp         r2, #0x2F
  00174	9a000009	 bls         |$LN14@XllpGpioSe@9|

; 859  : 		{
; 860  : 			aAFnV1_U |= aGpioPinAFValue;

  00178	e59d2014	 ldr         r2, [sp, #0x14]
  0017c	e1822311	 orr         r2, r2, r1, lsl r3

; 861  : 			aMask1_U |= aGpioPinAFMask;

  00180	e3a01003	 mov         r1, #3
  00184	e58d2014	 str         r2, [sp, #0x14]
  00188	e59d2010	 ldr         r2, [sp, #0x10]
  0018c	e1822311	 orr         r2, r2, r1, lsl r3

; 862  : 			aSet1_U=XLLP_TRUE;

  00190	e3a03001	 mov         r3, #1
  00194	e58d2010	 str         r2, [sp, #0x10]
  00198	e58d3038	 str         r3, [sp, #0x38]
  0019c	ea000020	 b           |$LN24@XllpGpioSe@9|
  001a0		 |$LN14@XllpGpioSe@9|

; 863  : 		}
; 864  : 		else if (aGpioPinArray[i]>31)

  001a0	e352001f	 cmp         r2, #0x1F
  001a4	9a000009	 bls         |$LN12@XllpGpioSe@9|

; 865  : 		{
; 866  : 			aAFnV1_L |= aGpioPinAFValue;

  001a8	e59d201c	 ldr         r2, [sp, #0x1C]
  001ac	e1822311	 orr         r2, r2, r1, lsl r3

; 867  : 			aMask1_L |= aGpioPinAFMask;

  001b0	e3a01003	 mov         r1, #3
  001b4	e58d201c	 str         r2, [sp, #0x1C]
  001b8	e59d2018	 ldr         r2, [sp, #0x18]
  001bc	e1822311	 orr         r2, r2, r1, lsl r3

; 868  : 			aSet1_L=XLLP_TRUE;

  001c0	e3a03001	 mov         r3, #1
  001c4	e58d2018	 str         r2, [sp, #0x18]
  001c8	e58d303c	 str         r3, [sp, #0x3C]
  001cc	ea000014	 b           |$LN24@XllpGpioSe@9|
  001d0		 |$LN12@XllpGpioSe@9|

; 869  : 		}
; 870  : 		else if (aGpioPinArray[i]>15)

  001d0	e352000f	 cmp         r2, #0xF
  001d4	9a000009	 bls         |$LN10@XllpGpioSe@9|

; 871  : 		{
; 872  : 			aAFnV0_U |= aGpioPinAFValue;

  001d8	e59d2024	 ldr         r2, [sp, #0x24]
  001dc	e1822311	 orr         r2, r2, r1, lsl r3

; 873  : 			aMask0_U |= aGpioPinAFMask;

  001e0	e3a01003	 mov         r1, #3
  001e4	e58d2024	 str         r2, [sp, #0x24]
  001e8	e59d2020	 ldr         r2, [sp, #0x20]
  001ec	e1822311	 orr         r2, r2, r1, lsl r3

; 874  : 			aSet0_U=XLLP_TRUE;

  001f0	e3a03001	 mov         r3, #1
  001f4	e58d2020	 str         r2, [sp, #0x20]
  001f8	e58d3040	 str         r3, [sp, #0x40]

; 875  : 		}
; 876  : 		else 

  001fc	ea000008	 b           |$LN24@XllpGpioSe@9|
  00200		 |$LN10@XllpGpioSe@9|

; 877  : 		{
; 878  : 			aAFnV0_L |= aGpioPinAFValue;

  00200	e59d202c	 ldr         r2, [sp, #0x2C]
  00204	e1822311	 orr         r2, r2, r1, lsl r3

; 879  : 			aMask0_L |= aGpioPinAFMask;

  00208	e3a01003	 mov         r1, #3
  0020c	e58d202c	 str         r2, [sp, #0x2C]
  00210	e59d2028	 ldr         r2, [sp, #0x28]
  00214	e1822311	 orr         r2, r2, r1, lsl r3

; 880  : 			aSet0_L=XLLP_TRUE;

  00218	e3a03001	 mov         r3, #1
  0021c	e58d2028	 str         r2, [sp, #0x28]
  00220	e58d3044	 str         r3, [sp, #0x44]
  00224		 |$LN24@XllpGpioSe@9|
  00224	e2800004	 add         r0, r0, #4
  00228	e25ee001	 subs        lr, lr, #1
  0022c	1affffa7	 bne         |$LL25@XllpGpioSe@9|
  00230	e58d4030	 str         r4, [sp, #0x30]

; 881  : 		}
; 882  : 	}
; 883  : 	if(aSet3_U)

  00234	e59d4048	 ldr         r4, [sp, #0x48]
  00238	e3550000	 cmp         r5, #0
  0023c	0a000009	 beq         |$LN8@XllpGpioSe@9|

; 884  : 	{
; 885  : 		LockID = XllpLock(GAFR3_U);

  00240	e3a0001d	 mov         r0, #0x1D
  00244	eb000000	 bl          XllpLock

; 886  : 		pGPIO->GAFR3_U=(((pGPIO->GAFR3_U&~aMask3_U)|aAFnV3_U)&~XLLP_GPIO_ALT_RESERVED_BITS);

  00248	e5943070	 ldr         r3, [r4, #0x70]
  0024c	e3e014ff	 mvn         r1, #0xFF, 8
  00250	e1c33007	 bic         r3, r3, r7
  00254	e1832008	 orr         r2, r3, r8
  00258	e221373f	 eor         r3, r1, #0x3F, 14
  0025c	e0023003	 and         r3, r2, r3
  00260	e5843070	 str         r3, [r4, #0x70]

; 887  : 		XllpUnlock(LockID);

  00264	eb000000	 bl          XllpUnlock
  00268		 |$LN8@XllpGpioSe@9|

; 888  : 	}
; 889  : 	if(aSet3_L)

  00268	e3560000	 cmp         r6, #0
  0026c	0a000007	 beq         |$LN7@XllpGpioSe@9|

; 890  : 	{
; 891  : 		LockID = XllpLock(GAFR3_L);

  00270	e3a0001c	 mov         r0, #0x1C
  00274	eb000000	 bl          XllpLock

; 892  : 		pGPIO->GAFR3_L=((pGPIO->GAFR3_L&~aMask3_L)|aAFnV3_L);

  00278	e594306c	 ldr         r3, [r4, #0x6C]
  0027c	e59d2030	 ldr         r2, [sp, #0x30]
  00280	e1c3300b	 bic         r3, r3, r11
  00284	e1833002	 orr         r3, r3, r2
  00288	e584306c	 str         r3, [r4, #0x6C]

; 893  : 		XllpUnlock(LockID);

  0028c	eb000000	 bl          XllpUnlock
  00290		 |$LN7@XllpGpioSe@9|

; 894  : 	}
; 895  : 	if(aSet2_U)

  00290	e35a0000	 cmp         r10, #0
  00294	0a000008	 beq         |$LN6@XllpGpioSe@9|

; 896  : 	{
; 897  : 		LockID = XllpLock(GAFR2_U);

  00298	e3a0001b	 mov         r0, #0x1B
  0029c	eb000000	 bl          XllpLock

; 898  : 		pGPIO->GAFR2_U=((pGPIO->GAFR2_U&~aMask2_U)|aAFnV2_U);

  002a0	e5943068	 ldr         r3, [r4, #0x68]
  002a4	e59d2000	 ldr         r2, [sp]
  002a8	e1c33002	 bic         r3, r3, r2
  002ac	e59d2004	 ldr         r2, [sp, #4]
  002b0	e1833002	 orr         r3, r3, r2
  002b4	e5843068	 str         r3, [r4, #0x68]

; 899  : 		XllpUnlock(LockID);

  002b8	eb000000	 bl          XllpUnlock
  002bc		 |$LN6@XllpGpioSe@9|

; 900  : 	}
; 901  : 	if(aSet2_L)

  002bc	e59d3034	 ldr         r3, [sp, #0x34]
  002c0	e3530000	 cmp         r3, #0
  002c4	0a000008	 beq         |$LN5@XllpGpioSe@9|

; 902  : 	{
; 903  : 		LockID = XllpLock(GAFR2_L);

  002c8	e3a0001a	 mov         r0, #0x1A
  002cc	eb000000	 bl          XllpLock

; 904  : 		pGPIO->GAFR2_L=((pGPIO->GAFR2_L&~aMask2_L)|aAFnV2_L);

  002d0	e5943064	 ldr         r3, [r4, #0x64]
  002d4	e59d2008	 ldr         r2, [sp, #8]
  002d8	e1c33002	 bic         r3, r3, r2
  002dc	e59d200c	 ldr         r2, [sp, #0xC]
  002e0	e1833002	 orr         r3, r3, r2
  002e4	e5843064	 str         r3, [r4, #0x64]

; 905  : 		XllpUnlock(LockID);

  002e8	eb000000	 bl          XllpUnlock
  002ec		 |$LN5@XllpGpioSe@9|

; 906  : 	}
; 907  : 	if(aSet1_U)

  002ec	e59d3038	 ldr         r3, [sp, #0x38]
  002f0	e3530000	 cmp         r3, #0
  002f4	0a000008	 beq         |$LN4@XllpGpioSe@9|

; 908  : 	{
; 909  : 		LockID = XllpLock(GAFR1_U);

  002f8	e3a00019	 mov         r0, #0x19
  002fc	eb000000	 bl          XllpLock

; 910  : 		pGPIO->GAFR1_U=((pGPIO->GAFR1_U&~aMask1_U)|aAFnV1_U);

  00300	e5943060	 ldr         r3, [r4, #0x60]
  00304	e59d2010	 ldr         r2, [sp, #0x10]
  00308	e1c33002	 bic         r3, r3, r2
  0030c	e59d2014	 ldr         r2, [sp, #0x14]
  00310	e1833002	 orr         r3, r3, r2
  00314	e5843060	 str         r3, [r4, #0x60]

; 911  : 		XllpUnlock(LockID);

  00318	eb000000	 bl          XllpUnlock
  0031c		 |$LN4@XllpGpioSe@9|

; 912  : 	}
; 913  : 	if(aSet1_L)

  0031c	e59d303c	 ldr         r3, [sp, #0x3C]
  00320	e3530000	 cmp         r3, #0
  00324	0a000008	 beq         |$LN3@XllpGpioSe@9|

; 914  : 	{
; 915  : 		LockID = XllpLock(GAFR1_L);

  00328	e3a00018	 mov         r0, #0x18
  0032c	eb000000	 bl          XllpLock

; 916  : 		pGPIO->GAFR1_L=((pGPIO->GAFR1_L&~aMask1_L)|aAFnV1_L);

  00330	e594305c	 ldr         r3, [r4, #0x5C]
  00334	e59d2018	 ldr         r2, [sp, #0x18]
  00338	e1c33002	 bic         r3, r3, r2
  0033c	e59d201c	 ldr         r2, [sp, #0x1C]
  00340	e1833002	 orr         r3, r3, r2
  00344	e584305c	 str         r3, [r4, #0x5C]

; 917  : 		XllpUnlock(LockID);

  00348	eb000000	 bl          XllpUnlock
  0034c		 |$LN3@XllpGpioSe@9|

; 918  : 	}
; 919  : 	if(aSet0_U)

  0034c	e59d3040	 ldr         r3, [sp, #0x40]
  00350	e3530000	 cmp         r3, #0
  00354	0a000008	 beq         |$LN2@XllpGpioSe@9|

; 920  : 	{
; 921  : 		LockID = XllpLock(GAFR0_U);

  00358	e3a00017	 mov         r0, #0x17
  0035c	eb000000	 bl          XllpLock

; 922  : 		pGPIO->GAFR0_U=((pGPIO->GAFR0_U&~aMask0_U)|aAFnV0_U);

  00360	e5943058	 ldr         r3, [r4, #0x58]
  00364	e59d2020	 ldr         r2, [sp, #0x20]
  00368	e1c33002	 bic         r3, r3, r2
  0036c	e59d2024	 ldr         r2, [sp, #0x24]
  00370	e1833002	 orr         r3, r3, r2
  00374	e5843058	 str         r3, [r4, #0x58]

; 923  : 		XllpUnlock(LockID);

  00378	eb000000	 bl          XllpUnlock
  0037c		 |$LN2@XllpGpioSe@9|

; 924  : 	}
; 925  : 	if(aSet0_L)

  0037c	e59d3044	 ldr         r3, [sp, #0x44]
  00380	e3530000	 cmp         r3, #0
  00384	0a000008	 beq         |$LN1@XllpGpioSe@9|

; 926  : 	{
; 927  : 		LockID = XllpLock(GAFR0_L);

  00388	e3a00016	 mov         r0, #0x16
  0038c	eb000000	 bl          XllpLock

; 928  : 		pGPIO->GAFR0_L=((pGPIO->GAFR0_L&~aMask0_L)|aAFnV0_L);

  00390	e5943054	 ldr         r3, [r4, #0x54]
  00394	e59d2028	 ldr         r2, [sp, #0x28]
  00398	e1c33002	 bic         r3, r3, r2
  0039c	e59d202c	 ldr         r2, [sp, #0x2C]
  003a0	e1833002	 orr         r3, r3, r2
  003a4	e5843054	 str         r3, [r4, #0x54]

; 929  : 		XllpUnlock(LockID);

  003a8	eb000000	 bl          XllpUnlock
  003ac		 |$LN1@XllpGpioSe@9|

; 930  : 	}
; 931  : 	}

  003ac	e28dd04c	 add         sp, sp, #0x4C
  003b0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  003b4	e12fff1e	 bx          lr
  003b8		 |$M1579|

			 ENDP  ; |XllpGpioSetAlternateFn|

	EXPORT	|XllpGpioClearAlternateFn|

  00000			 AREA	 |.pdata|, PDATA
|$T1619| DCD	|$LN33@XllpGpioCl@2|
	DCD	0x4000a602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XllpGpioClearAlternateFn| PROC

; 941  : 	{

  00000		 |$LN33@XllpGpioCl@2|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M1616|
  00008	e1a04000	 mov         r4, r0
  0000c	e58d4020	 str         r4, [sp, #0x20]

; 942  : 	XLLP_UINT32_T LockID;
; 943  : 	XLLP_UINT32_T aGpioPinAFMask;
; 944  : 	XLLP_UINT32_T aSizeArray;
; 945  : 	XLLP_UINT32_T aMask0_U, aMask0_L, aMask1_U, aMask1_L; 
; 946  : 	XLLP_UINT32_T aMask2_U, aMask2_L, aMask3_U, aMask3_L;
; 947  : 	XLLP_BOOL_T aSet0_U, aSet0_L, aSet1_U, aSet1_L; 
; 948  : 	XLLP_BOOL_T aSet2_U, aSet2_L, aSet3_U, aSet3_L;
; 949  : 	XLLP_UINT32_T i;
; 950  : 
; 951  : 	//determine size of array
; 952  : 	aSizeArray = aGpioPinArray[0];
; 953  : 	aMask0_U=aMask0_L=aMask1_U=aMask1_L=0;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3004	 str         r3, [sp, #4]
  00018	e3a03000	 mov         r3, #0
  0001c	e58d3000	 str         r3, [sp]

; 954  : 	aMask2_U=aMask2_L=aMask3_U=aMask3_L=0;
; 955  : 	aSet0_U=aSet0_L=aSet1_U=aSet1_L=XLLP_FALSE;
; 956  : 	aSet2_U=aSet2_L=aSet3_U=aSet3_L=XLLP_FALSE;
; 957  : 
; 958  : 	for(i=1; i<=aSizeArray; i++)

  00020	e3a03000	 mov         r3, #0
  00024	e58d300c	 str         r3, [sp, #0xC]
  00028	e3a03000	 mov         r3, #0
  0002c	e58d3008	 str         r3, [sp, #8]
  00030	e3a03000	 mov         r3, #0
  00034	e58d3014	 str         r3, [sp, #0x14]
  00038	e3a03000	 mov         r3, #0
  0003c	e58d3010	 str         r3, [sp, #0x10]
  00040	e5910000	 ldr         r0, [r1]
  00044	e3a03000	 mov         r3, #0
  00048	e58d301c	 str         r3, [sp, #0x1C]
  0004c	e3a03000	 mov         r3, #0
  00050	e58d3018	 str         r3, [sp, #0x18]
  00054	e3500001	 cmp         r0, #1
  00058	e3a07000	 mov         r7, #0
  0005c	e3a06000	 mov         r6, #0
  00060	e3a0b000	 mov         r11, #0
  00064	e3a09000	 mov         r9, #0
  00068	e3a05000	 mov         r5, #0
  0006c	e3a0e000	 mov         lr, #0
  00070	e3a0a000	 mov         r10, #0
  00074	e3a08000	 mov         r8, #0
  00078	3a000083	 bcc         |$LN1@XllpGpioCl@2|
  0007c	e2811004	 add         r1, r1, #4
  00080	e3a04000	 mov         r4, #0
  00084		 |$LL25@XllpGpioCl@2|

; 959  : 	{
; 960  : 		aGpioPinAFMask = 0x3u << ((aGpioPinArray[i] & 0xF)*2);

  00084	e5912000	 ldr         r2, [r1]
  00088	e202300f	 and         r3, r2, #0xF

; 961  : 		if (aGpioPinArray[i]>111)

  0008c	e352006f	 cmp         r2, #0x6F
  00090	e1a03083	 mov         r3, r3, lsl #1

; 962  : 		{
; 963  : 			aMask3_U |= aGpioPinAFMask;

  00094	83a02003	 movhi       r2, #3
  00098	81866312	 orrhi       r6, r6, r2, lsl r3

; 964  : 			aSet3_U=XLLP_TRUE;

  0009c	83a0e001	 movhi       lr, #1
  000a0	8a00002a	 bhi         |$LN24@XllpGpioCl@2|

; 965  : 		}
; 966  : 		else if (aGpioPinArray[i]>95)

  000a4	e5912000	 ldr         r2, [r1]
  000a8	e352005f	 cmp         r2, #0x5F

; 967  : 		{
; 968  : 			aMask3_L |= aGpioPinAFMask;

  000ac	83a02003	 movhi       r2, #3
  000b0	81877312	 orrhi       r7, r7, r2, lsl r3

; 969  : 			aSet3_L=XLLP_TRUE;

  000b4	83a05001	 movhi       r5, #1
  000b8	8a000024	 bhi         |$LN24@XllpGpioCl@2|

; 970  : 		}
; 971  : 		else if (aGpioPinArray[i]>79)

  000bc	e352004f	 cmp         r2, #0x4F

; 972  : 		{
; 973  : 			aMask2_U |= aGpioPinAFMask;

  000c0	83a02003	 movhi       r2, #3
  000c4	81899312	 orrhi       r9, r9, r2, lsl r3

; 974  : 			aSet2_U=XLLP_TRUE;

  000c8	83a08001	 movhi       r8, #1
  000cc	8a00001f	 bhi         |$LN24@XllpGpioCl@2|

; 975  : 		}
; 976  : 		else if (aGpioPinArray[i]>63)

  000d0	e352003f	 cmp         r2, #0x3F

; 977  : 		{
; 978  : 			aMask2_L |= aGpioPinAFMask;

  000d4	83a02003	 movhi       r2, #3
  000d8	818bb312	 orrhi       r11, r11, r2, lsl r3

; 979  : 			aSet2_L=XLLP_TRUE;

  000dc	83a0a001	 movhi       r10, #1
  000e0	8a00001a	 bhi         |$LN24@XllpGpioCl@2|

; 980  : 		}
; 981  : 		else if (aGpioPinArray[i]>47)

  000e4	e352002f	 cmp         r2, #0x2F

; 982  : 		{
; 983  : 			aMask1_U |= aGpioPinAFMask;

  000e8	83a02003	 movhi       r2, #3
  000ec	81844312	 orrhi       r4, r4, r2, lsl r3

; 984  : 			aSet1_U=XLLP_TRUE;

  000f0	83a03001	 movhi       r3, #1
  000f4	858d4000	 strhi       r4, [sp]
  000f8	858d3010	 strhi       r3, [sp, #0x10]
  000fc	8a000013	 bhi         |$LN24@XllpGpioCl@2|

; 985  : 		}
; 986  : 		else if (aGpioPinArray[i]>31)

  00100	e352001f	 cmp         r2, #0x1F

; 987  : 		{
; 988  : 			aMask1_L |= aGpioPinAFMask;

  00104	859d2004	 ldrhi       r2, [sp, #4]
  00108	e3a04003	 mov         r4, #3
  0010c	81822314	 orrhi       r2, r2, r4, lsl r3

; 989  : 			aSet1_L=XLLP_TRUE;

  00110	83a03001	 movhi       r3, #1
  00114	858d2004	 strhi       r2, [sp, #4]
  00118	858d3014	 strhi       r3, [sp, #0x14]
  0011c	8a00000a	 bhi         |$LN30@XllpGpioCl@2|

; 990  : 		}
; 991  : 		else if (aGpioPinArray[i]>15)

  00120	e352000f	 cmp         r2, #0xF

; 992  : 		{
; 993  : 			aMask0_U |= aGpioPinAFMask;

  00124	859d2008	 ldrhi       r2, [sp, #8]
  00128	81822314	 orrhi       r2, r2, r4, lsl r3

; 994  : 			aSet0_U=XLLP_TRUE;

  0012c	83a03001	 movhi       r3, #1
  00130	858d2008	 strhi       r2, [sp, #8]

; 995  : 		}
; 996  : 		else
; 997  : 		{
; 998  : 			aMask0_L |= aGpioPinAFMask;

  00134	959d200c	 ldrls       r2, [sp, #0xC]
  00138	858d3018	 strhi       r3, [sp, #0x18]
  0013c	91822314	 orrls       r2, r2, r4, lsl r3

; 999  : 			aSet0_L=XLLP_TRUE;

  00140	93a03001	 movls       r3, #1
  00144	958d200c	 strls       r2, [sp, #0xC]
  00148	958d301c	 strls       r3, [sp, #0x1C]
  0014c		 |$LN30@XllpGpioCl@2|

; 982  : 		{
; 983  : 			aMask1_U |= aGpioPinAFMask;

  0014c	e59d4000	 ldr         r4, [sp]

; 999  : 			aSet0_L=XLLP_TRUE;

  00150		 |$LN24@XllpGpioCl@2|
  00150	e2811004	 add         r1, r1, #4
  00154	e2500001	 subs        r0, r0, #1
  00158	1affffc9	 bne         |$LL25@XllpGpioCl@2|

; 1000 : 		}
; 1001 : 	}
; 1002 : 	if(aSet3_U)

  0015c	e59d4020	 ldr         r4, [sp, #0x20]
  00160	e35e0000	 cmp         lr, #0
  00164	0a000008	 beq         |$LN8@XllpGpioCl@2|

; 1003 : 	{
; 1004 : 		LockID = XllpLock(GAFR3_U);

  00168	e3a0001d	 mov         r0, #0x1D
  0016c	eb000000	 bl          XllpLock

; 1005 : 		pGPIO->GAFR3_U=((pGPIO->GAFR3_U&~aMask3_U)&~XLLP_GPIO_ALT_RESERVED_BITS);

  00170	e5943070	 ldr         r3, [r4, #0x70]
  00174	e3e014ff	 mvn         r1, #0xFF, 8
  00178	e1c32006	 bic         r2, r3, r6
  0017c	e221373f	 eor         r3, r1, #0x3F, 14
  00180	e0023003	 and         r3, r2, r3
  00184	e5843070	 str         r3, [r4, #0x70]

; 1006 : 		XllpUnlock(LockID);

  00188	eb000000	 bl          XllpUnlock
  0018c		 |$LN8@XllpGpioCl@2|

; 1007 : 	}
; 1008 : 	if(aSet3_L)

  0018c	e3550000	 cmp         r5, #0
  00190	0a000005	 beq         |$LN7@XllpGpioCl@2|

; 1009 : 	{
; 1010 : 		LockID = XllpLock(GAFR3_L);

  00194	e3a0001c	 mov         r0, #0x1C
  00198	eb000000	 bl          XllpLock

; 1011 : 		pGPIO->GAFR3_L=(pGPIO->GAFR3_L&~aMask3_L);

  0019c	e594306c	 ldr         r3, [r4, #0x6C]
  001a0	e1c33007	 bic         r3, r3, r7
  001a4	e584306c	 str         r3, [r4, #0x6C]

; 1012 : 		XllpUnlock(LockID);

  001a8	eb000000	 bl          XllpUnlock
  001ac		 |$LN7@XllpGpioCl@2|

; 1013 : 	}
; 1014 : 	if(aSet2_U)

  001ac	e3580000	 cmp         r8, #0
  001b0	0a000005	 beq         |$LN6@XllpGpioCl@2|

; 1015 : 	{
; 1016 : 		LockID = XllpLock(GAFR2_U);

  001b4	e3a0001b	 mov         r0, #0x1B
  001b8	eb000000	 bl          XllpLock

; 1017 : 		pGPIO->GAFR2_U=(pGPIO->GAFR2_U&~aMask2_U);

  001bc	e5943068	 ldr         r3, [r4, #0x68]
  001c0	e1c33009	 bic         r3, r3, r9
  001c4	e5843068	 str         r3, [r4, #0x68]

; 1018 : 		XllpUnlock(LockID);

  001c8	eb000000	 bl          XllpUnlock
  001cc		 |$LN6@XllpGpioCl@2|

; 1019 : 	}
; 1020 : 	if(aSet2_L)

  001cc	e35a0000	 cmp         r10, #0
  001d0	0a000005	 beq         |$LN5@XllpGpioCl@2|

; 1021 : 	{
; 1022 : 		LockID = XllpLock(GAFR2_L);

  001d4	e3a0001a	 mov         r0, #0x1A
  001d8	eb000000	 bl          XllpLock

; 1023 : 		pGPIO->GAFR2_L=(pGPIO->GAFR2_L&~aMask2_L);

  001dc	e5943064	 ldr         r3, [r4, #0x64]
  001e0	e1c3300b	 bic         r3, r3, r11
  001e4	e5843064	 str         r3, [r4, #0x64]

; 1024 : 		XllpUnlock(LockID);

  001e8	eb000000	 bl          XllpUnlock
  001ec		 |$LN5@XllpGpioCl@2|

; 1025 : 	}
; 1026 : 	if(aSet1_U)

  001ec	e59d3010	 ldr         r3, [sp, #0x10]
  001f0	e3530000	 cmp         r3, #0
  001f4	0a000006	 beq         |$LN4@XllpGpioCl@2|

; 1027 : 	{
; 1028 : 		LockID = XllpLock(GAFR1_U);

  001f8	e3a00019	 mov         r0, #0x19
  001fc	eb000000	 bl          XllpLock

; 1029 : 		pGPIO->GAFR1_U=(pGPIO->GAFR1_U&~aMask1_U);

  00200	e5943060	 ldr         r3, [r4, #0x60]
  00204	e59d2000	 ldr         r2, [sp]
  00208	e1c33002	 bic         r3, r3, r2
  0020c	e5843060	 str         r3, [r4, #0x60]

; 1030 : 		XllpUnlock(LockID);

  00210	eb000000	 bl          XllpUnlock
  00214		 |$LN4@XllpGpioCl@2|

; 1031 : 	}
; 1032 : 	if(aSet1_L)

  00214	e59d3014	 ldr         r3, [sp, #0x14]
  00218	e3530000	 cmp         r3, #0
  0021c	0a000006	 beq         |$LN3@XllpGpioCl@2|

; 1033 : 	{
; 1034 : 		LockID = XllpLock(GAFR1_L);

  00220	e3a00018	 mov         r0, #0x18
  00224	eb000000	 bl          XllpLock

; 1035 : 		pGPIO->GAFR1_L=(pGPIO->GAFR1_L&~aMask1_L);

  00228	e594305c	 ldr         r3, [r4, #0x5C]
  0022c	e59d2004	 ldr         r2, [sp, #4]
  00230	e1c33002	 bic         r3, r3, r2
  00234	e584305c	 str         r3, [r4, #0x5C]

; 1036 : 		XllpUnlock(LockID);

  00238	eb000000	 bl          XllpUnlock
  0023c		 |$LN3@XllpGpioCl@2|

; 1037 : 	}
; 1038 : 	if(aSet0_U)

  0023c	e59d3018	 ldr         r3, [sp, #0x18]
  00240	e3530000	 cmp         r3, #0
  00244	0a000006	 beq         |$LN2@XllpGpioCl@2|

; 1039 : 	{
; 1040 : 		LockID = XllpLock(GAFR0_U);

  00248	e3a00017	 mov         r0, #0x17
  0024c	eb000000	 bl          XllpLock

; 1041 : 		pGPIO->GAFR0_U=(pGPIO->GAFR0_U&~aMask0_U);

  00250	e5943058	 ldr         r3, [r4, #0x58]
  00254	e59d2008	 ldr         r2, [sp, #8]
  00258	e1c33002	 bic         r3, r3, r2
  0025c	e5843058	 str         r3, [r4, #0x58]

; 1042 : 		XllpUnlock(LockID);

  00260	eb000000	 bl          XllpUnlock
  00264		 |$LN2@XllpGpioCl@2|

; 1043 : 	}
; 1044 : 	if(aSet0_L)

  00264	e59d301c	 ldr         r3, [sp, #0x1C]
  00268	e3530000	 cmp         r3, #0
  0026c	0a000006	 beq         |$LN1@XllpGpioCl@2|

; 1045 : 	{
; 1046 : 		LockID = XllpLock(GAFR0_L);

  00270	e3a00016	 mov         r0, #0x16
  00274	eb000000	 bl          XllpLock

; 1047 : 		pGPIO->GAFR0_L=(pGPIO->GAFR0_L&~aMask0_L);

  00278	e5943054	 ldr         r3, [r4, #0x54]
  0027c	e59d200c	 ldr         r2, [sp, #0xC]
  00280	e1c33002	 bic         r3, r3, r2
  00284	e5843054	 str         r3, [r4, #0x54]

; 1048 : 		XllpUnlock(LockID);

  00288	eb000000	 bl          XllpUnlock
  0028c		 |$LN1@XllpGpioCl@2|

; 1049 : 	}
; 1050 : 	}

  0028c	e28dd024	 add         sp, sp, #0x24
  00290	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00294	e12fff1e	 bx          lr
  00298		 |$M1617|

			 ENDP  ; |XllpGpioClearAlternateFn|

	END
