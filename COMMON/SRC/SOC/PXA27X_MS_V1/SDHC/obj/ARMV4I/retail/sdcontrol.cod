; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\PXA27X_MS_V1\SDHC\sdcontrol.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|SDClockTable| [ DATA ]

  00000			 AREA	 |.data|, DATA
|SDClockTable| DCD 0x4c4b4
	DCB	0x6
	%	3
	DCD	0x98968
	DCB	0x5
	%	3
	DCD	0x1312d0
	DCB	0x4
	%	3
	DCD	0x2625a0
	DCB	0x3
	%	3
	DCD	0x4c4b40
	DCB	0x2
	%	3
	DCD	0x989680
	DCB	0x1
	%	3
	DCD	0x1312d00
	DCB	0x0
	%	3
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44339| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44336|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44337|

			 ENDP  ; |SetEvent|

	EXPORT	|GetCurrentThread|

  00000			 AREA	 |.pdata|, PDATA
|$T44348| DCD	|$LN5@GetCurrent|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetCurrentThread| PROC

; 351  : _inline HANDLE GetCurrentThread(void) {

  00000		 |$LN5@GetCurrent|
  00000		 |$M44345|

; 352  : 	return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));

  00000	e3a00041	 mov         r0, #0x41

; 353  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44346|

			 ENDP  ; |GetCurrentThread|

	EXPORT	|WRITE_MMC_REGISTER_DWORD|
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\sdhc\sdcontrol.c

  00000			 AREA	 |.pdata|, PDATA
|$T44358| DCD	|$LN5@WRITE_MMC_|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WRITE_MMC_REGISTER_DWORD| PROC

; 115  : {

  00000		 |$LN5@WRITE_MMC_|
  00000		 |$M44355|

; 116  :     BYTE *pRegBaseAddr, *regAddr;
; 117  :     volatile DWORD *pdwRegAddr;
; 118  :     pRegBaseAddr = (BYTE*)(pHc->pSDMMCRegisters);
; 119  :     regAddr = pRegBaseAddr + RegOffset;

  00000	e5903004	 ldr         r3, [r0, #4]

; 120  :     pdwRegAddr = (DWORD*)regAddr;
; 121  :     *pdwRegAddr = Value;

  00004	e7832001	 str         r2, [r3, +r1]

; 122  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M44356|

			 ENDP  ; |WRITE_MMC_REGISTER_DWORD|

	EXPORT	|READ_MMC_REGISTER_DWORD|

  00000			 AREA	 |.pdata|, PDATA
|$T44370| DCD	|$LN5@READ_MMC_R|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |READ_MMC_REGISTER_DWORD| PROC

; 125  : {

  00000		 |$LN5@READ_MMC_R|
  00000		 |$M44367|

; 126  :     BYTE *pRegBaseAddr, *regAddr;
; 127  :     volatile DWORD *pdwRegAddr;
; 128  :     pRegBaseAddr = (BYTE*)(pHc->pSDMMCRegisters);
; 129  :     regAddr = pRegBaseAddr + RegOffset;

  00000	e5903004	 ldr         r3, [r0, #4]

; 130  :     pdwRegAddr = (DWORD*)regAddr;
; 131  :     return (*pdwRegAddr);

  00004	e7930001	 ldr         r0, [r3, +r1]

; 132  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M44368|

			 ENDP  ; |READ_MMC_REGISTER_DWORD|

	EXPORT	|CLOCK_IS_ON|

  00000			 AREA	 |.pdata|, PDATA
|$T44387| DCD	|$LN9@CLOCK_IS_O|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CLOCK_IS_ON| PROC

; 144  : {

  00000		 |$LN9@CLOCK_IS_O|
  00000		 |$M44384|

; 145  :     if( READ_MMC_REGISTER_DWORD( pHc, MMC_STAT ) & MMC_STAT_CLOCK_ENABLED )

  00000	e5903004	 ldr         r3, [r0, #4]
  00004	e5933004	 ldr         r3, [r3, #4]
  00008	e3130c01	 tst         r3, #1, 24

; 146  :     {
; 147  :         return TRUE;

  0000c	13a00001	 movne       r0, #1

; 148  :     }
; 149  :     else
; 150  :     {
; 151  :         return FALSE;

  00010	03a00000	 moveq       r0, #0

; 152  :     }
; 153  : }

  00014	e12fff1e	 bx          lr
  00018		 |$M44385|

			 ENDP  ; |CLOCK_IS_ON|

	EXPORT	|READ_MOD_WRITE_MMC_REGISTER_AND_OR|

  00000			 AREA	 |.pdata|, PDATA
|$T44412| DCD	|$LN9@READ_MOD_W|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |READ_MOD_WRITE_MMC_REGISTER_AND_OR| PROC

; 156  : {

  00000		 |$LN9@READ_MOD_W|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44409|

; 157  :     DWORD regValue;
; 158  :     regValue = READ_MMC_REGISTER_DWORD(pHc, RegOffset);

  00004	e590e004	 ldr         lr, [r0, #4]
  00008	e79e0001	 ldr         r0, [lr, +r1]

; 159  :     regValue &= (AndValue);

  0000c	e0002002	 and         r2, r0, r2

; 160  :     regValue |= (OrValue);

  00010	e1823003	 orr         r3, r2, r3

; 161  :     DEBUGMSG(SDCARD_ZONE_INFO, (TEXT("SHCDriver: - Setting MMC Reg 0x%x to 0x%x\r\n"), RegOffset, regValue));
; 162  :     WRITE_MMC_REGISTER_DWORD(pHc, RegOffset, regValue);

  00014	e78e3001	 str         r3, [lr, +r1]

; 163  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$M44410|

			 ENDP  ; |READ_MOD_WRITE_MMC_REGISTER_AND_OR|

	EXPORT	|READ_MOD_WRITE_MMC_IMASK_AND_OR|
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T44450| DCD	|$LN11@READ_MOD_W@2|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |READ_MOD_WRITE_MMC_IMASK_AND_OR| PROC

; 182  : {

  00000		 |$LN11@READ_MOD_W@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44447|
  00004	e1a06002	 mov         r6, r2
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 183  :     EnterCriticalSection(&(pHc->intrRegCriticalSection));

  00010	e2840ed5	 add         r0, r4, #0xD5, 28
  00014	eb000000	 bl          EnterCriticalSection

; 184  :     READ_MOD_WRITE_MMC_REGISTER_AND_OR( pHc, MMC_IMASK, AndValue, OrValue );

  00018	e594e004	 ldr         lr, [r4, #4]

; 185  :     LeaveCriticalSection(&(pHc->intrRegCriticalSection));

  0001c	e2840ed5	 add         r0, r4, #0xD5, 28
  00020	e59e3028	 ldr         r3, [lr, #0x28]
  00024	e0033005	 and         r3, r3, r5
  00028	e1833006	 orr         r3, r3, r6
  0002c	e58e3028	 str         r3, [lr, #0x28]
  00030	eb000000	 bl          LeaveCriticalSection

; 186  : }

  00034	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M44448|

			 ENDP  ; |READ_MOD_WRITE_MMC_IMASK_AND_OR|

	EXPORT	|SDClockOff|

  00000			 AREA	 |.pdata|, PDATA
|$T44502| DCD	|$LN24@SDClockOff|
	DCD	0x40000b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDClockOff| PROC

; 281  : {

  00000		 |$LN24@SDClockOff|
  00000		 |$M44499|

; 282  :         // check to see if the clock is on
; 283  :     if (!CLOCK_IS_ON(pHc)) {

  00000	e5902004	 ldr         r2, [r0, #4]
  00004	e5923004	 ldr         r3, [r2, #4]
  00008	e3130c01	 tst         r3, #1, 24
  0000c	0a000005	 beq         |$LN15@SDClockOff|

; 284  :         return;
; 285  :     }
; 286  : 
; 287  :     DbgPrintZo(SDH_CLOCK_ZONE, (TEXT("SDClockOff - turning off clock \n")));
; 288  :         // turn off the clock
; 289  :     WRITE_MMC_REGISTER_DWORD(pHc, MMC_STRPCL, MMC_STRPCL_STOP_CLOCK);

  00010	e3a03001	 mov         r3, #1
  00014	e5823000	 str         r3, [r2]
  00018	e5902004	 ldr         r2, [r0, #4]
  0001c		 |$LL2@SDClockOff|

; 290  :        
; 291  :     while (CLOCK_IS_ON(pHc)) {

  0001c	e5923004	 ldr         r3, [r2, #4]
  00020	e3130c01	 tst         r3, #1, 24
  00024	1afffffc	 bne         |$LL2@SDClockOff|
  00028		 |$LN15@SDClockOff|

; 292  :         // sit here and wait for the clock to turn off
; 293  :         DbgPrintZo(SDH_CLOCK_ZONE, (TEXT("Waiting for clock off\n")));
; 294  :     }
; 295  : 
; 296  :     DbgPrintZo(SDH_CLOCK_ZONE, (TEXT("SDClockOff - Clock is now off \n")));
; 297  : }

  00028	e12fff1e	 bx          lr
  0002c		 |$M44500|

			 ENDP  ; |SDClockOff|

	EXPORT	|SDClockOn|

  00000			 AREA	 |.pdata|, PDATA
|$T44516| DCD	|$LN7@SDClockOn|
	DCD	0x40000400
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDClockOn| PROC

; 310  : {

  00000		 |$LN7@SDClockOn|
  00000		 |$M44513|

; 311  :         // turn on the clock
; 312  :     WRITE_MMC_REGISTER_DWORD(pHc, MMC_STRPCL, MMC_STRPCL_START_CLOCK);

  00000	e5903004	 ldr         r3, [r0, #4]
  00004	e3a02002	 mov         r2, #2
  00008	e5832000	 str         r2, [r3]

; 313  : }

  0000c	e12fff1e	 bx          lr
  00010		 |$M44514|

			 ENDP  ; |SDClockOn|

	EXPORT	|SDSetRate|

  00000			 AREA	 |.pdata|, PDATA
|$T44644| DCD	|$LN50@SDSetRate|
	DCD	0x40003501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDSetRate| PROC

; 326  : {

  00000		 |$LN50@SDSetRate|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44641|
  00004	e1a06001	 mov         r6, r1
  00008	e1a0e000	 mov         lr, r0

; 327  :     ULONG ii;           // table index variable
; 328  :     DWORD rate;
; 329  :     BOOL fClockRunning;
; 330  : 
; 331  :     fClockRunning = CLOCK_IS_ON(pHc);

  0000c	e59e2004	 ldr         r2, [lr, #4]
  00010	e5923004	 ldr         r3, [r2, #4]
  00014	e3130c01	 tst         r3, #1, 24

; 332  :     SDClockOff(pHc);

  00018	e5923004	 ldr         r3, [r2, #4]
  0001c	13a05001	 movne       r5, #1
  00020	03a05000	 moveq       r5, #0
  00024	e3130c01	 tst         r3, #1, 24
  00028	0a000005	 beq         |$LN31@SDSetRate|
  0002c	e3a03001	 mov         r3, #1
  00030	e5823000	 str         r3, [r2]
  00034	e59e2004	 ldr         r2, [lr, #4]
  00038		 |$LL18@SDSetRate|
  00038	e5923004	 ldr         r3, [r2, #4]
  0003c	e3130c01	 tst         r3, #1, 24
  00040	1afffffc	 bne         |$LL18@SDSetRate|
  00044		 |$LN31@SDSetRate|

; 333  : 
; 334  :     rate = *pRate;

  00044	e5962000	 ldr         r2, [r6]

; 335  :     if( rate > pHc->dwMaximumSDClockFrequency )

  00048	e59e3d4c	 ldr         r3, [lr, #0xD4C]

; 336  :         rate = pHc->dwMaximumSDClockFrequency;
; 337  :    
; 338  :         // check to see if the rate is below the first entry in the table
; 339  :     if (rate <= SDClockTable[0].Frequency) {

  0004c	e59f407c	 ldr         r4, [pc, #0x7C]

; 340  :         ii = 0;

  00050	e3a01000	 mov         r1, #0
  00054	e1520003	 cmp         r2, r3
  00058	81a02003	 movhi       r2, r3
  0005c	e5943000	 ldr         r3, [r4]
  00060	e1520003	 cmp         r2, r3

; 341  :     } else {

  00064	9a00000a	 bls         |$LN47@SDSetRate|

; 342  : 
; 343  :             // scan through the table looking for a frequency that
; 344  :             // is close to the requested rate
; 345  :         for (ii = 0; ii < (NUM_CLOCK_ENTRIES - 1); ii++) {

  00068	e1a00004	 mov         r0, r4
  0006c		 |$LL5@SDSetRate|

; 346  :             if ((rate >= SDClockTable[ii].Frequency) &&
; 347  :                 (rate < SDClockTable[ii+1].Frequency)) {

  0006c	e5903000	 ldr         r3, [r0]
  00070	e1520003	 cmp         r2, r3
  00074	3a000002	 bcc         |$LN4@SDSetRate|
  00078	e5903008	 ldr         r3, [r0, #8]
  0007c	e1520003	 cmp         r2, r3
  00080	3a000003	 bcc         |$LN47@SDSetRate|
  00084		 |$LN4@SDSetRate|

; 342  : 
; 343  :             // scan through the table looking for a frequency that
; 344  :             // is close to the requested rate
; 345  :         for (ii = 0; ii < (NUM_CLOCK_ENTRIES - 1); ii++) {

  00084	e2811001	 add         r1, r1, #1
  00088	e3510006	 cmp         r1, #6
  0008c	e2800008	 add         r0, r0, #8
  00090	3afffff5	 bcc         |$LL5@SDSetRate|
  00094		 |$LN47@SDSetRate|

; 348  :                 break;
; 349  :             } 
; 350  :         }
; 351  :     }
; 352  : 
; 353  :     DbgPrintZo(SDH_CLOCK_ZONE, (TEXT("SDClockOn - Requested Rate: %d, Setting clock rate to %d Hz \n"),
; 354  :            *pRate, SDClockTable[ii].Frequency ));
; 355  : 
; 356  :         // return the actual fruency
; 357  :     *pRate = SDClockTable[ii].Frequency;

  00094	e1a00004	 mov         r0, r4
  00098	e7b03181	 ldr         r3, [r0, +r1, lsl #3]!

; 358  : 
; 359  :          // set the clock rate
; 360  :     WRITE_MMC_REGISTER_DWORD(pHc, MMC_CLKRT, SDClockTable[ii].ControlValue);

  0009c	e0841181	 add         r1, r4, r1, lsl #3

; 361  :     pHc->dwSDClockFrequency = SDClockTable[ii].Frequency;
; 362  :         
; 363  :     if( fClockRunning )

  000a0	e3550000	 cmp         r5, #0
  000a4	e5863000	 str         r3, [r6]
  000a8	e59e2004	 ldr         r2, [lr, #4]
  000ac	e5d13004	 ldrb        r3, [r1, #4]
  000b0	e5823008	 str         r3, [r2, #8]
  000b4	e5903000	 ldr         r3, [r0]

; 364  :     {
; 365  :         SDClockOn( pHc );

  000b8	13a02002	 movne       r2, #2
  000bc	e58e3d48	 str         r3, [lr, #0xD48]
  000c0	159e3004	 ldrne       r3, [lr, #4]
  000c4	15832000	 strne       r2, [r3]

; 366  :     }
; 367  : }

  000c8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN51@SDSetRate|
  000d0		 |$LN52@SDSetRate|
  000d0	00000000	 DCD         |SDClockTable|
  000d4		 |$M44642|

			 ENDP  ; |SDSetRate|

	IMPORT	|SDHCDIndicateBusRequestComplete|

  00000			 AREA	 |.pdata|, PDATA
|$T44660| DCD	|$LN9@IndicateBu|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |IndicateBusRequestComplete| PROC

; 371  : {

  00000		 |$LN9@IndicateBu|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44657|
  00004	e1a04000	 mov         r4, r0

; 372  :     BOOL fRet = FALSE;
; 373  :     PSDH_HARDWARE_CONTEXT pController = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);

  00008	e594304c	 ldr         r3, [r4, #0x4C]
  0000c	e3a00000	 mov         r0, #0
  00010	e1b0e003	 movs        lr, r3

; 374  :     if (pController && pController->pCurrentRequest == pRequest) {

  00014	0a00000e	 beq         |$LN4@IndicateBu|
  00018	e59e301c	 ldr         r3, [lr, #0x1C]
  0001c	e1530001	 cmp         r3, r1
  00020	1a00000b	 bne         |$LN4@IndicateBu|

; 375  :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("IndicateBusRequestComplete - pRequest = %x, Status = %d\n"),pRequest,Status));
; 376  :         pController->pCurrentRequest = NULL;
; 377  :         if (pController->fCurrentRequestFastPath ) {

  00024	e59e3020	 ldr         r3, [lr, #0x20]
  00028	e3a00000	 mov         r0, #0
  0002c	e58e001c	 str         r0, [lr, #0x1C]
  00030	e3530000	 cmp         r3, #0
  00034	0a000003	 beq         |$LN3@IndicateBu|

; 378  :             if (Status == SD_API_STATUS_SUCCESS) {

  00038	e3520000	 cmp         r2, #0

; 379  :                 Status = SD_API_STATUS_FAST_PATH_SUCCESS;

  0003c	03a02002	 moveq       r2, #2

; 380  :             }
; 381  :             pController->FastPathStatus = Status ;

  00040	e58e2024	 str         r2, [lr, #0x24]

; 382  :         }
; 383  :         else 

  00044	ea000001	 b           |$LN1@IndicateBu|
  00048		 |$LN3@IndicateBu|

; 384  :             SDHCDIndicateBusRequestComplete(pHCContext,pRequest,Status);

  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          SDHCDIndicateBusRequestComplete
  00050		 |$LN1@IndicateBu|

; 385  :         fRet = TRUE;

  00050	e3a00001	 mov         r0, #1
  00054		 |$LN4@IndicateBu|

; 386  :     }
; 387  :     ASSERT(fRet);
; 388  :     return fRet;
; 389  : }

  00054	e8bd4010	 ldmia       sp!, {r4, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$M44658|

			 ENDP  ; |IndicateBusRequestComplete|

	EXPORT	|SDDeinitialize|
	IMPORT	|DeleteCriticalSection|
	IMPORT	|UnInitializeHardware|
	IMPORT	|CloseBusAccessHandle|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|SDHCDIndicateSlotStateChange|
	IMPORT	|MMCPowerControl|
	IMPORT	|CleanupCardDetectIST|
	IMPORT	|HalFreeCommonBuffer|
	IMPORT	|FreeIntChainHandler|
	IMPORT	|KernelIoControl|
	IMPORT	|InterruptDisable|
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T44753| DCD	|$LN48@SDDeinitia|
	DCD	0x4000ad02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDDeinitialize| PROC

; 403  : {

  00000		 |$LN48@SDDeinitia|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44750|
  00008	e1a05000	 mov         r5, r0

; 404  :     PSDH_HARDWARE_CONTEXT pHardwareContext; // hardware context
; 405  :     PSD_BUS_REQUEST     pRequest = NULL;       // the request to complete
; 406  : 
; 407  :     pHardwareContext = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);

  0000c	e595404c	 ldr         r4, [r5, #0x4C]

; 408  : 
; 409  :         // mark for shutdown
; 410  :     pHardwareContext->DriverShutdown = TRUE;

  00010	e3a08001	 mov         r8, #1

; 411  : 
; 412  :     if( pHardwareContext->hControllerInterruptEvent )

  00014	e5943030	 ldr         r3, [r4, #0x30]
  00018	e5848ad0	 str         r8, [r4, #0xAD0]
  0001c	e3530000	 cmp         r3, #0

; 413  :     {
; 414  :         // wake up the controller IST
; 415  :         SetEvent(pHardwareContext->hControllerInterruptEvent);

  00020	13a01003	 movne       r1, #3
  00024	11a00003	 movne       r0, r3
  00028	1b000000	 blne        EventModify

; 416  :     }
; 417  : 
; 418  :     if (NULL != pHardwareContext->hDMAInterruptEvent) 

  0002c	e5943a98	 ldr         r3, [r4, #0xA98]
  00030	e3530000	 cmp         r3, #0

; 419  :     {
; 420  :         // wake up the DMA IST
; 421  :         SetEvent(pHardwareContext->hDMAInterruptEvent);

  00034	13a01003	 movne       r1, #3
  00038	11a00003	 movne       r0, r3
  0003c	1b000000	 blne        EventModify

; 422  :     }
; 423  : 
; 424  :     // clean up controller IST
; 425  :     if (NULL != pHardwareContext->hControllerInterruptThread) {

  00040	e5943034	 ldr         r3, [r4, #0x34]
  00044	e3e07000	 mvn         r7, #0
  00048	e3a06000	 mov         r6, #0
  0004c	e3530000	 cmp         r3, #0
  00050	0a000005	 beq         |$LN16@SDDeinitia|

; 426  :             // wait for the thread to exit
; 427  :         WaitForSingleObject(pHardwareContext->hControllerInterruptThread, INFINITE); 

  00054	e1a01007	 mov         r1, r7
  00058	e1a00003	 mov         r0, r3
  0005c	eb000000	 bl          WaitForSingleObject

; 428  :         CloseHandle(pHardwareContext->hControllerInterruptThread);

  00060	e5940034	 ldr         r0, [r4, #0x34]
  00064	eb000000	 bl          CloseHandle

; 429  :         pHardwareContext->hControllerInterruptThread = NULL;

  00068	e5846034	 str         r6, [r4, #0x34]
  0006c		 |$LN16@SDDeinitia|

; 430  :     }
; 431  :         
; 432  :     // clean up DMA IST
; 433  :     if (NULL != pHardwareContext->hDmaInterruptThread) {

  0006c	e5943aa0	 ldr         r3, [r4, #0xAA0]
  00070	e3530000	 cmp         r3, #0
  00074	0a000005	 beq         |$LN15@SDDeinitia|

; 434  :         // wait for the thread to exit
; 435  :         WaitForSingleObject(pHardwareContext->hDmaInterruptThread, INFINITE); 

  00078	e1a01007	 mov         r1, r7
  0007c	e1a00003	 mov         r0, r3
  00080	eb000000	 bl          WaitForSingleObject

; 436  :         CloseHandle(pHardwareContext->hDmaInterruptThread);

  00084	e5940aa0	 ldr         r0, [r4, #0xAA0]
  00088	eb000000	 bl          CloseHandle

; 437  :         pHardwareContext->hDmaInterruptThread = NULL;

  0008c	e5846aa0	 str         r6, [r4, #0xAA0]
  00090		 |$LN15@SDDeinitia|

; 438  :     }
; 439  :         
; 440  :         // free controller interrupt event
; 441  :     if (NULL != pHardwareContext->hControllerInterruptEvent) {

  00090	e5943030	 ldr         r3, [r4, #0x30]
  00094	e3530000	 cmp         r3, #0
  00098	0a000002	 beq         |$LN14@SDDeinitia|

; 442  :         CloseHandle(pHardwareContext->hControllerInterruptEvent);

  0009c	e1a00003	 mov         r0, r3
  000a0	eb000000	 bl          CloseHandle

; 443  :         pHardwareContext->hControllerInterruptEvent = NULL;

  000a4	e5846030	 str         r6, [r4, #0x30]
  000a8		 |$LN14@SDDeinitia|

; 444  :     }
; 445  : 
; 446  :         // free the DMA interrupt event
; 447  :     if( pHardwareContext->hDMAInterruptEvent )

  000a8	e5943a98	 ldr         r3, [r4, #0xA98]
  000ac	e3530000	 cmp         r3, #0
  000b0	0a000002	 beq         |$LN13@SDDeinitia|

; 448  :     {
; 449  :         CloseHandle(pHardwareContext->hDMAInterruptEvent);

  000b4	e1a00003	 mov         r0, r3
  000b8	eb000000	 bl          CloseHandle

; 450  :         pHardwareContext->hDMAInterruptEvent = NULL;

  000bc	e5846a98	 str         r6, [r4, #0xA98]
  000c0		 |$LN13@SDDeinitia|

; 451  :     }
; 452  : 
; 453  :         // make sure all interrupt sources are disabled
; 454  :     if( pHardwareContext->dwSysintrSDMMC != SYSINTR_UNDEFINED )

  000c0	e594002c	 ldr         r0, [r4, #0x2C]
  000c4	e3700001	 cmn         r0, #1
  000c8	0a000008	 beq         |$LN12@SDDeinitia|

; 455  :     {
; 456  :         InterruptDisable (pHardwareContext->dwSysintrSDMMC);

  000cc	eb000000	 bl          InterruptDisable

; 457  :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, &pHardwareContext->dwSysintrSDMMC, sizeof(DWORD), NULL, 0, NULL);

  000d0	e59f01d8	 ldr         r0, [pc, #0x1D8]
  000d4	e3a03000	 mov         r3, #0
  000d8	e3a02004	 mov         r2, #4
  000dc	e284102c	 add         r1, r4, #0x2C
  000e0	e58d6004	 str         r6, [sp, #4]
  000e4	e58d6000	 str         r6, [sp]
  000e8	eb000000	 bl          KernelIoControl

; 458  :         pHardwareContext->dwSysintrSDMMC = SYSINTR_UNDEFINED;

  000ec	e584702c	 str         r7, [r4, #0x2C]
  000f0		 |$LN12@SDDeinitia|

; 459  :     }
; 460  :     if( pHardwareContext->dwDmaSysIntr != SYSINTR_UNDEFINED )

  000f0	e5940a90	 ldr         r0, [r4, #0xA90]
  000f4	e3700001	 cmn         r0, #1
  000f8	0a000008	 beq         |$LN11@SDDeinitia|

; 461  :     {
; 462  :         InterruptDisable (pHardwareContext->dwDmaSysIntr);

  000fc	eb000000	 bl          InterruptDisable

; 463  :         KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, &pHardwareContext->dwDmaSysIntr, sizeof(DWORD), NULL, 0, NULL);

  00100	e59f01a8	 ldr         r0, [pc, #0x1A8]
  00104	e3a03000	 mov         r3, #0
  00108	e3a02004	 mov         r2, #4
  0010c	e2841ea9	 add         r1, r4, #0xA9, 28
  00110	e58d6004	 str         r6, [sp, #4]
  00114	e58d6000	 str         r6, [sp]
  00118	eb000000	 bl          KernelIoControl

; 464  :         pHardwareContext->dwDmaSysIntr = SYSINTR_UNDEFINED;

  0011c	e5847a90	 str         r7, [r4, #0xA90]
  00120		 |$LN11@SDDeinitia|

; 465  :     }
; 466  : 
; 467  :         // unload the DMA ISR DLL
; 468  :     if( pHardwareContext->hDMAIsrHandler )

  00120	e5943a94	 ldr         r3, [r4, #0xA94]
  00124	e3530000	 cmp         r3, #0
  00128	0a000002	 beq         |$LN10@SDDeinitia|

; 469  :     {
; 470  :         FreeIntChainHandler(pHardwareContext->hDMAIsrHandler);

  0012c	e1a00003	 mov         r0, r3
  00130	eb000000	 bl          FreeIntChainHandler

; 471  :         pHardwareContext->hDMAIsrHandler = NULL;

  00134	e5846a94	 str         r6, [r4, #0xA94]
  00138		 |$LN10@SDDeinitia|

; 472  :     }
; 473  : 
; 474  :         // free the DMA buffer
; 475  :     if( pHardwareContext->pDMABuffer )

  00138	e5943068	 ldr         r3, [r4, #0x68]
  0013c	e1b0e003	 movs        lr, r3
  00140	0a000008	 beq         |$LN9@SDDeinitia|

; 476  :     {
; 477  :         HalFreeCommonBuffer( NULL, 0, pHardwareContext->pDMABufferPhys, pHardwareContext->pDMABuffer, FALSE );

  00144	e5942070	 ldr         r2, [r4, #0x70]
  00148	e5943074	 ldr         r3, [r4, #0x74]
  0014c	e3a01000	 mov         r1, #0
  00150	e3a00000	 mov         r0, #0
  00154	e58d6004	 str         r6, [sp, #4]
  00158	e58de000	 str         lr, [sp]
  0015c	eb000000	 bl          HalFreeCommonBuffer

; 478  :         pHardwareContext->pDMABuffer = NULL;

  00160	e5846068	 str         r6, [r4, #0x68]

; 479  :         pHardwareContext->dwDmaBufferSize = 0;

  00164	e5846088	 str         r6, [r4, #0x88]
  00168		 |$LN9@SDDeinitia|

; 480  :     }
; 481  : 
; 482  :         // free the DMA descriptors buffer
; 483  :     if( pHardwareContext->pDMADescriptors )

  00168	e5943078	 ldr         r3, [r4, #0x78]
  0016c	e1b0e003	 movs        lr, r3
  00170	0a000007	 beq         |$LN8@SDDeinitia|

; 484  :     {
; 485  :         DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SHCDriver: - Unable to allocate memory for DMA descriptors!\r\n")));
; 486  :         HalFreeCommonBuffer( NULL, 0, pHardwareContext->pDMADescriptorsPhys, (PVOID)pHardwareContext->pDMADescriptors, FALSE );

  00174	e5942080	 ldr         r2, [r4, #0x80]
  00178	e5943084	 ldr         r3, [r4, #0x84]
  0017c	e3a01000	 mov         r1, #0
  00180	e3a00000	 mov         r0, #0
  00184	e58d6004	 str         r6, [sp, #4]
  00188	e58de000	 str         lr, [sp]
  0018c	eb000000	 bl          HalFreeCommonBuffer

; 487  :         pHardwareContext->pDMADescriptors = NULL;

  00190	e5846078	 str         r6, [r4, #0x78]
  00194		 |$LN8@SDDeinitia|

; 488  :     }
; 489  : 
; 490  :         // clean up card insertion IST and free card insertion interrupt
; 491  :     CleanupCardDetectIST();

  00194	eb000000	 bl          CleanupCardDetectIST

; 492  : 
; 493  :         // turn the hardware off
; 494  :     SDClockOff( pHardwareContext );

  00198	e5942004	 ldr         r2, [r4, #4]
  0019c	e5923004	 ldr         r3, [r2, #4]
  001a0	e3130c01	 tst         r3, #1, 24
  001a4	0a000004	 beq         |$LN39@SDDeinitia|
  001a8	e5828000	 str         r8, [r2]
  001ac	e5942004	 ldr         r2, [r4, #4]
  001b0		 |$LL26@SDDeinitia|
  001b0	e5923004	 ldr         r3, [r2, #4]
  001b4	e3130c01	 tst         r3, #1, 24
  001b8	1afffffc	 bne         |$LL26@SDDeinitia|
  001bc		 |$LN39@SDDeinitia|

; 495  :     MMCPowerControl( FALSE );

  001bc	e3a00000	 mov         r0, #0
  001c0	eb000000	 bl          MMCPowerControl

; 496  : 
; 497  :         // if there is a pending request, cancel it
; 498  :     if( pHardwareContext && (pRequest = pHardwareContext->pCurrentRequest) != NULL)

  001c4	e594301c	 ldr         r3, [r4, #0x1C]
  001c8	e3530000	 cmp         r3, #0

; 499  :     {
; 500  :         DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SDHCD:SHCDriver() - aborting current request!\r\n")));
; 501  :         IndicateBusRequestComplete(pHCContext, pRequest, SD_API_STATUS_SHUT_DOWN);

  001cc	13a02163	 movne       r2, #0x63, 2
  001d0	11a01003	 movne       r1, r3
  001d4	11a00005	 movne       r0, r5
  001d8	1b000000	 blne        IndicateBusRequestComplete

; 502  :     }
; 503  : 
; 504  : 
; 505  :         // If a card is inserted, signal that it was ejected...
; 506  :     if(pHardwareContext && pHardwareContext->DevicePresent)

  001dc	e5943d44	 ldr         r3, [r4, #0xD44]
  001e0	e3530000	 cmp         r3, #0
  001e4	0a000004	 beq         |$LN6@SDDeinitia|

; 507  :     {
; 508  :         // indicate the slot change 
; 509  :         SDHCDIndicateSlotStateChange(pHCContext, 0, DeviceEjected); 

  001e8	e3a02001	 mov         r2, #1
  001ec	e3a01000	 mov         r1, #0
  001f0	e1a00005	 mov         r0, r5
  001f4	eb000000	 bl          SDHCDIndicateSlotStateChange

; 510  :         pHardwareContext->DevicePresent = FALSE;

  001f8	e5846d44	 str         r6, [r4, #0xD44]
  001fc		 |$LN6@SDDeinitia|

; 511  :     }
; 512  : 
; 513  :         // free memory mapped resources
; 514  : 
; 515  :     if (NULL != pHardwareContext->pSDMMCRegisters) {

  001fc	e5943004	 ldr         r3, [r4, #4]
  00200	e3530000	 cmp         r3, #0
  00204	0a000003	 beq         |$LN5@SDDeinitia|

; 516  :         MmUnmapIoSpace((PVOID)pHardwareContext->pSDMMCRegisters, sizeof(BULVERDE_MMC_REG));

  00208	e3a01048	 mov         r1, #0x48
  0020c	e1a00003	 mov         r0, r3
  00210	eb000000	 bl          MmUnmapIoSpace

; 517  :         pHardwareContext->pSDMMCRegisters = NULL;

  00214	e5846004	 str         r6, [r4, #4]
  00218		 |$LN5@SDDeinitia|

; 518  :     }
; 519  : 
; 520  :     if (NULL != pHardwareContext->pGPIORegisters) {

  00218	e5943000	 ldr         r3, [r4]
  0021c	e3530000	 cmp         r3, #0
  00220	0a000003	 beq         |$LN4@SDDeinitia|

; 521  :         MmUnmapIoSpace((PVOID)pHardwareContext->pGPIORegisters, sizeof(BULVERDE_GPIO_REG));

  00224	e3a01f53	 mov         r1, #0x53, 30
  00228	e1a00003	 mov         r0, r3
  0022c	eb000000	 bl          MmUnmapIoSpace

; 522  :         pHardwareContext->pGPIORegisters = NULL;

  00230	e5846000	 str         r6, [r4]
  00234		 |$LN4@SDDeinitia|

; 523  :     }
; 524  : 
; 525  :     if (NULL != pHardwareContext->pClkMgrRegisters) {

  00234	e5943008	 ldr         r3, [r4, #8]
  00238	e3530000	 cmp         r3, #0
  0023c	0a000003	 beq         |$LN3@SDDeinitia|

; 526  :         MmUnmapIoSpace((PVOID)pHardwareContext->pClkMgrRegisters, sizeof(BULVERDE_CLKMGR_REG));

  00240	e3a01010	 mov         r1, #0x10
  00244	e1a00003	 mov         r0, r3
  00248	eb000000	 bl          MmUnmapIoSpace

; 527  :         pHardwareContext->pClkMgrRegisters = NULL;

  0024c	e5846008	 str         r6, [r4, #8]
  00250		 |$LN3@SDDeinitia|

; 528  :     }
; 529  : 
; 530  :     if (NULL != pHardwareContext->pDMARegisters) {

  00250	e594300c	 ldr         r3, [r4, #0xC]
  00254	e3530000	 cmp         r3, #0
  00258	0a000004	 beq         |$LN2@SDDeinitia|
  0025c	e3a02c11	 mov         r2, #0x11, 24

; 531  :         MmUnmapIoSpace((PVOID)pHardwareContext->pDMARegisters, sizeof(BULVERDE_DMA_REG));

  00260	e382102c	 orr         r1, r2, #0x2C
  00264	e1a00003	 mov         r0, r3
  00268	eb000000	 bl          MmUnmapIoSpace

; 532  :         pHardwareContext->pDMARegisters = NULL;

  0026c	e584600c	 str         r6, [r4, #0xC]
  00270		 |$LN2@SDDeinitia|

; 533  :     }
; 534  : 
; 535  :     if(NULL != pHardwareContext->hBusAccessHandle) {

  00270	e5943014	 ldr         r3, [r4, #0x14]
  00274	e3530000	 cmp         r3, #0
  00278	0a000002	 beq         |$LN1@SDDeinitia|

; 536  :         CloseBusAccessHandle(pHardwareContext->hBusAccessHandle);

  0027c	e1a00003	 mov         r0, r3
  00280	eb000000	 bl          CloseBusAccessHandle

; 537  :         pHardwareContext->hBusAccessHandle = NULL;

  00284	e5846014	 str         r6, [r4, #0x14]
  00288		 |$LN1@SDDeinitia|

; 538  :     }
; 539  :     UnInitializeHardware();

  00288	eb000000	 bl          UnInitializeHardware

; 540  : 
; 541  :     DeleteCriticalSection(&pHardwareContext->ControllerCriticalSection);

  0028c	e2843c0a	 add         r3, r4, #0xA, 24
  00290	e28300d4	 add         r0, r3, #0xD4
  00294	eb000000	 bl          DeleteCriticalSection

; 542  :     DeleteCriticalSection(&pHardwareContext->intrRegCriticalSection);

  00298	e2840ed5	 add         r0, r4, #0xD5, 28
  0029c	eb000000	 bl          DeleteCriticalSection

; 543  : 
; 544  :     return SD_API_STATUS_SUCCESS;

  002a0	e3a00000	 mov         r0, #0

; 545  : }

  002a4	e28dd008	 add         sp, sp, #8
  002a8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  002ac	e12fff1e	 bx          lr
  002b0		 |$LN49@SDDeinitia|
  002b0		 |$LN50@SDDeinitia|
  002b0	010100d8	 DCD         0x10100d8
  002b4		 |$M44751|

			 ENDP  ; |SDDeinitialize|

	EXPORT	|SDHCancelIoHandler|

  00000			 AREA	 |.pdata|, PDATA
|$T44766| DCD	|$LN5@SDHCancelI|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDHCancelIoHandler| PROC

; 898  : {

  00000		 |$LN5@SDHCancelI|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44763|
  00004	e1a04002	 mov         r4, r2
  00008	e1a05000	 mov         r5, r0

; 899  :     PSDH_HARDWARE_CONTEXT    pController;
; 900  : 
; 901  :         // for now, we should never get here because all requests are non-cancelable
; 902  :         // the hardware supports timeouts so it is impossible for the controller to get stuck
; 903  :     DEBUG_ASSERT(FALSE);
; 904  : 
; 905  :         // get our extension 
; 906  :     pController = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);
; 907  : 
; 908  :         // --- Stop hardware, cancel the request!
; 909  : 
; 910  :         // release the lock before we complete the request
; 911  :     SDHCDReleaseHCLock(pHCContext);

  0000c	e2850024	 add         r0, r5, #0x24
  00010	eb000000	 bl          LeaveCriticalSection

; 912  :  
; 913  :         // complete the request with a cancelled status
; 914  :     IndicateBusRequestComplete(pHCContext,
; 915  :                                     pRequest,
; 916  :                                     SD_API_STATUS_CANCELED);

  00014	e3a0214f	 mov         r2, #0x4F, 2
  00018	e1a01004	 mov         r1, r4
  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          IndicateBusRequestComplete

; 917  : 
; 918  :     return TRUE;

  00024	e3a00001	 mov         r0, #1

; 919  : }

  00028	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M44764|

			 ENDP  ; |SDHCancelIoHandler|

	EXPORT	|SDHSlotOptionHandler|
	IMPORT	|IsCardWriteProtected|

  00000			 AREA	 |.pdata|, PDATA
|$T44943| DCD	|$LN75@SDHSlotOpt|
	DCD	0x40007c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDHSlotOptionHandler| PROC

; 1184 : {

  00000		 |$LN75@SDHSlotOpt|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M44940|
  00004	e1a04003	 mov         r4, r3

; 1185 :     SD_API_STATUS status = SD_API_STATUS_SUCCESS;   // status
; 1186 :     PSDH_HARDWARE_CONTEXT    pController;         // the controller
; 1187 :     PSD_HOST_BLOCK_CAPABILITY  pBlockCaps;          // queried block capabilities
; 1188 : 
; 1189 :         // get our extension 
; 1190 :     pController = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);

  00008	e590504c	 ldr         r5, [r0, #0x4C]
  0000c	e3a06000	 mov         r6, #0

; 1191 : 
; 1192 :     switch (Option) {

  00010	e352000b	 cmp         r2, #0xB
  00014	8a000071	 bhi         |$LN1@SDHSlotOpt|
  00018	e1a01082	 mov         r1, r2, lsl #1
  0001c	e081100f	 add         r1, r1, pc
  00020	e1d110b4	 ldrh        r1, [r1, #4]
  00024	e08ff001	 add         pc, pc, r1
  00028		 |$LN60@SDHSlotOpt|
  00028		 |$LN59@SDHSlotOpt|
  00028		 |$LN61@SDHSlotOpt|
  00028	01b8		 DCW         0x1b8
  0002a		 |$LN62@SDHSlotOpt|
  0002a	0014		 DCW         0x14
  0002c		 |$LN63@SDHSlotOpt|
  0002c	0038		 DCW         0x38
  0002e		 |$LN64@SDHSlotOpt|
  0002e	00e4		 DCW         0xe4
  00030		 |$LN65@SDHSlotOpt|
  00030	0064		 DCW         0x64
  00032		 |$LN66@SDHSlotOpt|
  00032	0110		 DCW         0x110
  00034		 |$LN67@SDHSlotOpt|
  00034	0130		 DCW         0x130
  00036		 |$LN68@SDHSlotOpt|
  00036	01b4		 DCW         0x1b4
  00038		 |$LN69@SDHSlotOpt|
  00038	01b4		 DCW         0x1b4
  0003a		 |$LN70@SDHSlotOpt|
  0003a	01b4		 DCW         0x1b4
  0003c		 |$LN71@SDHSlotOpt|
  0003c	01b4		 DCW         0x1b4
  0003e		 |$LN72@SDHSlotOpt|
  0003e	0174		 DCW         0x174
  00040		 |$LN22@SDHSlotOpt|

; 1193 : 
; 1194 :         case SDHCDSetSlotPower:
; 1195 :             DbgPrintZo(SDCARD_ZONE_INIT, 
; 1196 :                 (TEXT("SDHSlotOptionHandler - called - SetSlotPower : 0x%08X  \n"), 
; 1197 :                 *((PDWORD)pData)));
; 1198 :             break;
; 1199 : 
; 1200 :         case SDHCDSetSlotInterface:
; 1201 :             DbgPrintZo(SDCARD_ZONE_INIT, 
; 1202 :                 (TEXT("SDHSlotOptionHandler - called - SetSlotInterface : Clock Setting: %d \n"), 
; 1203 :                 ((PSD_CARD_INTERFACE)pData)->ClockRate));
; 1204 :             
; 1205 :             if (SD_INTERFACE_SD_MMC_1BIT == 
; 1206 :                 ((PSD_CARD_INTERFACE)pData)->InterfaceMode) {

  00040	e5942000	 ldr         r2, [r4]

; 1207 :                 DbgPrintZo(SDCARD_ZONE_INIT, 
; 1208 :                         (TEXT("SDHSlotOptionHandler - called - SetSlotInterface : setting for 1 bit mode \n")));
; 1209 :                 pController->f4BitMode = FALSE;
; 1210 :             } else {
; 1211 :                 DbgPrintZo(SDCARD_ZONE_INIT, 
; 1212 :                         (TEXT("SDHSlotOptionHandler - called - SetSlotInterface : setting for 4 bit mode \n")));
; 1213 :                 pController->f4BitMode = TRUE;
; 1214 :             }
; 1215 :                 // set rate
; 1216 :             SDSetRate(pController, &((PSD_CARD_INTERFACE)pData)->ClockRate);

  00044	e2841004	 add         r1, r4, #4
  00048	e1a00005	 mov         r0, r5
  0004c	e3520000	 cmp         r2, #0
  00050	03a03000	 moveq       r3, #0
  00054	13a03001	 movne       r3, #1
  00058	e5853d38	 str         r3, [r5, #0xD38]
  0005c	eb000000	 bl          SDSetRate

; 1217 :             
; 1218 :             break;

  00060	ea00005f	 b           |$LN24@SDHSlotOpt|
  00064		 |$LN19@SDHSlotOpt|

; 1219 : 
; 1220 :         case SDHCDEnableSDIOInterrupts:
; 1221 :             
; 1222 :             DbgPrintZo(SDCARD_ZONE_INIT, 
; 1223 :                 (TEXT("SDHSlotOptionHandler - called - EnableSDIOInterrupts : on slot %d  \n"),
; 1224 :                 SlotNumber));
; 1225 : 
; 1226 :             SDIO_INTERRUPT_ON(pController);

  00064	e2850ed5	 add         r0, r5, #0xD5, 28
  00068	eb000000	 bl          EnterCriticalSection
  0006c	e5952004	 ldr         r2, [r5, #4]
  00070	e2850ed5	 add         r0, r5, #0xD5, 28
  00074	e5923028	 ldr         r3, [r2, #0x28]
  00078	e3c33b02	 bic         r3, r3, #2, 22
  0007c	e5823028	 str         r3, [r2, #0x28]
  00080	eb000000	 bl          LeaveCriticalSection

; 1227 :             pController->fSDIOEnabled = TRUE;

  00084	e3a03001	 mov         r3, #1
  00088	e5853d30	 str         r3, [r5, #0xD30]

; 1228 : 
; 1229 :             break;

  0008c	ea000054	 b           |$LN24@SDHSlotOpt|
  00090		 |$LN18@SDHSlotOpt|

; 1230 : 
; 1231 :         case SDHCDAckSDIOInterrupt:
; 1232 : 
; 1233 :                 // acquire the lock to block the SDIO interrupt thread
; 1234 :             ACQUIRE_LOCK(pController);

  00090	e2854c0a	 add         r4, r5, #0xA, 24
  00094	e28400d4	 add         r0, r4, #0xD4
  00098	eb000000	 bl          EnterCriticalSection

; 1235 : 
; 1236 :             if ( ( READ_MMC_REGISTER_DWORD( pController, MMC_STAT ) & 0x8000 ) &&
; 1237 :                  ( READ_MMC_REGISTER_DWORD( pController, MMC_IREG ) & 0x0800 ) &&
; 1238 :                  pController->fSDIOEnabled )

  0009c	e5952004	 ldr         r2, [r5, #4]
  000a0	e5923004	 ldr         r3, [r2, #4]
  000a4	e3130902	 tst         r3, #2, 18
  000a8	0a00000a	 beq         |$LN17@SDHSlotOpt|
  000ac	e592302c	 ldr         r3, [r2, #0x2C]
  000b0	e3130b02	 tst         r3, #2, 22
  000b4	0a000007	 beq         |$LN17@SDHSlotOpt|
  000b8	e5953d30	 ldr         r3, [r5, #0xD30]
  000bc	e3530000	 cmp         r3, #0
  000c0	0a00000f	 beq         |$LN40@SDHSlotOpt|

; 1239 :             {
; 1240 :                 DbgPrintZo(/*SDCARD_ZONE_INIT*/SDH_INTERRUPT_ZONE, (TEXT("SDIO INT (still)!\n")));
; 1241 :                 SDHCDIndicateSlotStateChange(pController->pHCContext, 
; 1242 :                                                 0,
; 1243 :                                                 DeviceInterrupting);

  000c4	e5950018	 ldr         r0, [r5, #0x18]
  000c8	e3a02003	 mov         r2, #3
  000cc	e3a01000	 mov         r1, #0
  000d0	eb000000	 bl          SDHCDIndicateSlotStateChange
  000d4	ea00000a	 b           |$LN40@SDHSlotOpt|
  000d8		 |$LN17@SDHSlotOpt|

; 1244 :             }
; 1245 :             else if( pController->fSDIOEnabled )

  000d8	e5953d30	 ldr         r3, [r5, #0xD30]
  000dc	e3530000	 cmp         r3, #0
  000e0	0a000007	 beq         |$LN40@SDHSlotOpt|

; 1246 :             {
; 1247 :                 SDIO_INTERRUPT_ON(pController);

  000e4	e2850ed5	 add         r0, r5, #0xD5, 28
  000e8	eb000000	 bl          EnterCriticalSection
  000ec	e5952004	 ldr         r2, [r5, #4]
  000f0	e2850ed5	 add         r0, r5, #0xD5, 28
  000f4	e5923028	 ldr         r3, [r2, #0x28]
  000f8	e3c33b02	 bic         r3, r3, #2, 22
  000fc	e5823028	 str         r3, [r2, #0x28]
  00100	eb000000	 bl          LeaveCriticalSection
  00104		 |$LN40@SDHSlotOpt|

; 1248 :             }
; 1249 : 
; 1250 :             RELEASE_LOCK(pController);

  00104	e28400d4	 add         r0, r4, #0xD4
  00108	eb000000	 bl          LeaveCriticalSection

; 1251 : 
; 1252 :             break;

  0010c	ea000034	 b           |$LN24@SDHSlotOpt|
  00110		 |$LN14@SDHSlotOpt|

; 1253 : 
; 1254 :         case SDHCDDisableSDIOInterrupts:
; 1255 :             DbgPrintZo(SDCARD_ZONE_INIT, 
; 1256 :                 (TEXT("SDHSlotOptionHandler - called - DisableSDIOInterrupts : on slot %d  \n"),
; 1257 :                 SlotNumber));
; 1258 : 
; 1259 :             SDIO_INTERRUPT_OFF(pController);

  00110	e2850ed5	 add         r0, r5, #0xD5, 28
  00114	eb000000	 bl          EnterCriticalSection
  00118	e5952004	 ldr         r2, [r5, #4]
  0011c	e2850ed5	 add         r0, r5, #0xD5, 28
  00120	e5923028	 ldr         r3, [r2, #0x28]
  00124	e3833b02	 orr         r3, r3, #2, 22
  00128	e5823028	 str         r3, [r2, #0x28]
  0012c	eb000000	 bl          LeaveCriticalSection

; 1260 :             pController->fSDIOEnabled = FALSE;

  00130	e3a03000	 mov         r3, #0
  00134	e5853d30	 str         r3, [r5, #0xD30]
  00138	ea000029	 b           |$LN24@SDHSlotOpt|
  0013c		 |$LN13@SDHSlotOpt|

; 1261 : 
; 1262 :             break;
; 1263 : 
; 1264 :         case SDHCDGetWriteProtectStatus:
; 1265 :             
; 1266 :             DbgPrintZo(SDCARD_ZONE_INIT, 
; 1267 :                 (TEXT("SDHSlotOptionHandler - called - SDHCDGetWriteProtectStatus : on slot %d  \n"),
; 1268 :                  SlotNumber)); 
; 1269 :             
; 1270 :             if( IsCardWriteProtected() ) {

  0013c	eb000000	 bl          IsCardWriteProtected
  00140	e3500000	 cmp         r0, #0

; 1271 :                 ((PSD_CARD_INTERFACE)pData)->WriteProtected = TRUE;

  00144	13a03001	 movne       r3, #1

; 1272 :                 DbgPrintZo(SDCARD_ZONE_INIT, (TEXT("SDHSlotOptionHandler - Card is write protected \n"))); 
; 1273 :             } else {
; 1274 :                 ((PSD_CARD_INTERFACE)pData)->WriteProtected = FALSE;

  00148	15843008	 strne       r3, [r4, #8]
  0014c	1a000024	 bne         |$LN24@SDHSlotOpt|
  00150	e3a03000	 mov         r3, #0
  00154	e5843008	 str         r3, [r4, #8]

; 1275 :                 DbgPrintZo(SDCARD_ZONE_INIT, (TEXT("SDHSlotOptionHandler - Card is write enabled \n"))); 
; 1276 :             }
; 1277 : 
; 1278 :             break;

  00158	ea000021	 b           |$LN24@SDHSlotOpt|
  0015c		 |$LN10@SDHSlotOpt|

; 1279 : 
; 1280 :          case SDHCDQueryBlockCapability:
; 1281 :             pBlockCaps = (PSD_HOST_BLOCK_CAPABILITY)pData;
; 1282 : 
; 1283 :              DbgPrintZo(SDCARD_ZONE_INIT, 
; 1284 :              (TEXT("SDHSlotOptionHandler: Read Block Length: %d , Read Blocks: %d\n"), 
; 1285 :                 pBlockCaps->ReadBlockSize, 
; 1286 :                 pBlockCaps->ReadBlocks));
; 1287 :              DbgPrintZo(SDCARD_ZONE_INIT, 
; 1288 :              (TEXT("SDHSlotOptionHandler: Write Block Length: %d , Write Blocks: %d\n"), 
; 1289 :                 pBlockCaps->WriteBlockSize, 
; 1290 :                 pBlockCaps->WriteBlocks));
; 1291 : 
; 1292 :                 // the PXA27x controller can only handle up to 1024 bytes
; 1293 :                 // with a minimum of 32 bytes per transfer
; 1294 :             if (pBlockCaps->ReadBlockSize > SDH_MAX_BLOCK_SIZE) {

  0015c	e1d430b0	 ldrh        r3, [r4]
  00160	e3a02c03	 mov         r2, #3, 24
  00164	e38220ff	 orr         r2, r2, #0xFF
  00168	e1530002	 cmp         r3, r2

; 1295 :                 pBlockCaps->ReadBlockSize = SDH_MAX_BLOCK_SIZE;

  0016c	81c420b0	 strhih      r2, [r4]

; 1296 :             }
; 1297 : 
; 1298 :             if (pBlockCaps->ReadBlockSize < SDH_MIN_BLOCK_SIZE ) {

  00170	e1d430b0	 ldrh        r3, [r4]
  00174	e3a01020	 mov         r1, #0x20
  00178	e3530020	 cmp         r3, #0x20

; 1299 :                 pBlockCaps->ReadBlockSize = SDH_MIN_BLOCK_SIZE;
; 1300 :             }
; 1301 : 
; 1302 :             if (pBlockCaps->WriteBlockSize > SDH_MAX_BLOCK_SIZE) {

  0017c	e1d430b2	 ldrh        r3, [r4, #2]
  00180	31c410b0	 strcch      r1, [r4]
  00184	e1530002	 cmp         r3, r2

; 1303 :                 pBlockCaps->WriteBlockSize = SDH_MAX_BLOCK_SIZE;

  00188	81c420b2	 strhih      r2, [r4, #2]

; 1304 :             }
; 1305 :             
; 1306 :             if (pBlockCaps->WriteBlockSize < SDH_MIN_BLOCK_SIZE ) {

  0018c	e1d430b2	 ldrh        r3, [r4, #2]
  00190	e3530020	 cmp         r3, #0x20
  00194	2a000012	 bcs         |$LN24@SDHSlotOpt|

; 1307 :                 pBlockCaps->WriteBlockSize = SDH_MIN_BLOCK_SIZE;

  00198	e1c410b2	 strh        r1, [r4, #2]

; 1308 :             }
; 1309 : 
; 1310 :                 // the PXA27x controller can handle 64K blocks,
; 1311 :                 // we leave the number of blocks alone
; 1312 :              
; 1313 :             break;

  0019c	ea000010	 b           |$LN24@SDHSlotOpt|
  001a0		 |$LN5@SDHSlotOpt|

; 1314 : 
; 1315 :         case SDHCDGetSlotInfo:
; 1316 :             if( OptionSize != sizeof(SDCARD_HC_SLOT_INFO) || pData == NULL )

  001a0	e59d3010	 ldr         r3, [sp, #0x10]
  001a4	e3530014	 cmp         r3, #0x14
  001a8	1a00000c	 bne         |$LN1@SDHSlotOpt|
  001ac	e3540000	 cmp         r4, #0
  001b0	0a00000a	 beq         |$LN1@SDHSlotOpt|

; 1317 :             {
; 1318 :                 status = SD_API_STATUS_INVALID_PARAMETER;
; 1319 :             }
; 1320 :             else
; 1321 :             {
; 1322 :                 PSDCARD_HC_SLOT_INFO pSlotInfo = (PSDCARD_HC_SLOT_INFO)pData;
; 1323 : 
; 1324 :                 // set the slot capabilities
; 1325 :                 SDHCDSetSlotCapabilities(pSlotInfo, SD_SLOT_SD_1BIT_CAPABLE | 
; 1326 :                                                     SD_SLOT_SD_4BIT_CAPABLE |
; 1327 :                                                     SD_SLOT_SDIO_CAPABLE);

  001b4	e3a0302c	 mov         r3, #0x2C

; 1328 : 
; 1329 :                 SDHCDSetVoltageWindowMask(pSlotInfo, (SD_VDD_WINDOW_3_2_TO_3_3 | SD_VDD_WINDOW_3_3_TO_3_4)); 

  001b8	e3a02603	 mov         r2, #3, 12

; 1330 : 
; 1331 :                 // Set optimal voltage
; 1332 :                 SDHCDSetDesiredSlotVoltage(pSlotInfo, SD_VDD_WINDOW_3_2_TO_3_3);

  001bc	e3a01601	 mov         r1, #1, 12
  001c0	e5843000	 str         r3, [r4]
  001c4	e5842004	 str         r2, [r4, #4]
  001c8	e5841008	 str         r1, [r4, #8]

; 1333 : 
; 1334 :                 SDHCDSetMaxClockRate(pSlotInfo, pController->dwMaximumSDClockFrequency);

  001cc	e5953d4c	 ldr         r3, [r5, #0xD4C]

; 1335 : 
; 1336 :                 // Set power up delay. We handle this in SetVoltage().
; 1337 :                 SDHCDSetPowerUpDelay(pSlotInfo, 300);

  001d0	e3a02f4b	 mov         r2, #0x4B, 30
  001d4	e5842010	 str         r2, [r4, #0x10]
  001d8	e584300c	 str         r3, [r4, #0xC]
  001dc	ea000000	 b           |$LN24@SDHSlotOpt|
  001e0		 |$LN1@SDHSlotOpt|

; 1338 :             }
; 1339 :             break;
; 1340 : 
; 1341 :         default:
; 1342 :            status = SD_API_STATUS_INVALID_PARAMETER;

  001e0	e3a0611f	 mov         r6, #0x1F, 2
  001e4		 |$LN24@SDHSlotOpt|

; 1343 : 
; 1344 :     }
; 1345 : 
; 1346 :     return status;
; 1347 : }

  001e4	e1a00006	 mov         r0, r6
  001e8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  001ec	e12fff1e	 bx          lr
  001f0		 |$M44941|

			 ENDP  ; |SDHSlotOptionHandler|

	EXPORT	|HandleProgramDone|

  00000			 AREA	 |.pdata|, PDATA
|$T45069| DCD	|$LN37@HandleProg|
	DCD	0x40002701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HandleProgramDone| PROC

; 1357 : {

  00000		 |$LN37@HandleProg|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45066|
  00004	e1a04000	 mov         r4, r0

; 1358 :     PSD_BUS_REQUEST pRequest;       // current request
; 1359 : 
; 1360 :     PROGRAM_DONE_INTERRUPT_OFF(pController);

  00008	e2840ed5	 add         r0, r4, #0xD5, 28
  0000c	eb000000	 bl          EnterCriticalSection
  00010	e5942004	 ldr         r2, [r4, #4]
  00014	e2840ed5	 add         r0, r4, #0xD5, 28
  00018	e5923028	 ldr         r3, [r2, #0x28]
  0001c	e3833002	 orr         r3, r3, #2
  00020	e5823028	 str         r3, [r2, #0x28]
  00024	eb000000	 bl          LeaveCriticalSection

; 1361 : 
; 1362 :         // get the current request  
; 1363 :     pRequest = pController->pCurrentRequest;

  00028	e594301c	 ldr         r3, [r4, #0x1C]
  0002c	e1b01003	 movs        r1, r3

; 1364 : 
; 1365 :         // this should never happen because we mark the request as un-cancelable.
; 1366 :     DEBUG_ASSERT(NULL != pRequest);
; 1367 :     if(NULL == pRequest)

  00030	0a000017	 beq         |$LN4@HandleProg|

; 1368 :     {
; 1369 :         return;
; 1370 :     }
; 1371 : 
; 1372 :     SetCurrentState(pController, WriteDataDone);
; 1373 : 
; 1374 :         // notice there is no status to check for a programming error
; 1375 :         // this is up to the upper level drivers to send a card status command
; 1376 :     DbgPrintZo(SDH_TRANSMIT_ZONE, (TEXT("HandleProgramDone: Programming Complete \n")));
; 1377 : 
; 1378 :     if( !( pController->fClockAlwaysOn || ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00034	e5943d3c	 ldr         r3, [r4, #0xD3C]
  00038	e3a02007	 mov         r2, #7
  0003c	e5842cec	 str         r2, [r4, #0xCEC]
  00040	e3530000	 cmp         r3, #0
  00044	1a00000f	 bne         |$LN28@HandleProg|
  00048	e5943d40	 ldr         r3, [r4, #0xD40]
  0004c	e3530000	 cmp         r3, #0
  00050	0a000002	 beq         |$LN1@HandleProg|
  00054	e5943d30	 ldr         r3, [r4, #0xD30]
  00058	e3530000	 cmp         r3, #0
  0005c	1a000009	 bne         |$LN28@HandleProg|
  00060		 |$LN1@HandleProg|

; 1379 :     {
; 1380 :             // turn off the clock
; 1381 :         SDClockOff(pController);

  00060	e5942004	 ldr         r2, [r4, #4]
  00064	e5923004	 ldr         r3, [r2, #4]
  00068	e3130c01	 tst         r3, #1, 24
  0006c	0a000005	 beq         |$LN28@HandleProg|
  00070	e3a03001	 mov         r3, #1
  00074	e5823000	 str         r3, [r2]
  00078	e5942004	 ldr         r2, [r4, #4]
  0007c		 |$LL15@HandleProg|
  0007c	e5923004	 ldr         r3, [r2, #4]
  00080	e3130c01	 tst         r3, #1, 24
  00084	1afffffc	 bne         |$LL15@HandleProg|
  00088		 |$LN28@HandleProg|

; 1382 :             // complete the request
; 1383 :     }
; 1384 : 
; 1385 :     DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleProgramDone reports Bus Request Succeeded\n")));
; 1386 : 
; 1387 :     IndicateBusRequestComplete(pController->pHCContext,
; 1388 :                                     pRequest ,
; 1389 :                                     SD_API_STATUS_SUCCESS);

  00088	e5940018	 ldr         r0, [r4, #0x18]
  0008c	e3a02000	 mov         r2, #0
  00090	eb000000	 bl          IndicateBusRequestComplete
  00094		 |$LN4@HandleProg|

; 1390 : }

  00094	e8bd4010	 ldmia       sp!, {r4, lr}
  00098	e12fff1e	 bx          lr
  0009c		 |$M45067|

			 ENDP  ; |HandleProgramDone|

	EXPORT	|EmptyReceiveFifo|

  00000			 AREA	 |.pdata|, PDATA
|$T45091| DCD	|$LN18@EmptyRecei|
	DCD	0x40002902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EmptyReceiveFifo| PROC

; 1407 : {   

  00000		 |$LN18@EmptyRecei|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45088|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a05001	 mov         r5, r1

; 1408 :     ULONG MaxBytesToRead;
; 1409 :     PBYTE pCurPtr;
; 1410 :     DWORD dwTotalRead;
; 1411 : 
; 1412 :     volatile UCHAR *pMMC_RX_Fifo = (volatile UCHAR *)&(pController->pSDMMCRegisters->rxfifo);
; 1413 :     volatile DWORD *pMMC_RX_FifoDW = (volatile DWORD *)&(pController->pSDMMCRegisters->rxfifo);
; 1414 : 
; 1415 : 
; 1416 :     MaxBytesToRead = MaxBytes - pRequest->HCParam;

  00010	e595e044	 ldr         lr, [r5, #0x44]
  00014	e5906004	 ldr         r6, [r0, #4]

; 1417 :     pCurPtr = pRequest->pBlockBuffer+pRequest->HCParam;

  00018	e5950048	 ldr         r0, [r5, #0x48]
  0001c	e043300e	 sub         r3, r3, lr

; 1418 :     
; 1419 :     if( ByteCount > MaxBytesToRead )

  00020	e1540003	 cmp         r4, r3

; 1420 :     {
; 1421 :         ByteCount = MaxBytesToRead;

  00024	81a04003	 movhi       r4, r3
  00028	e080000e	 add         r0, r0, lr

; 1422 :     }
; 1423 :     dwTotalRead = ByteCount;

  0002c	e1a0e004	 mov         lr, r4
  00030	ea000013	 b           |$LN15@EmptyRecei|
  00034		 |$LL6@EmptyRecei|

; 1429 :             if( ByteCount >= 4 )

  00034	e3540004	 cmp         r4, #4
  00038	3a00000b	 bcc         |$LN11@EmptyRecei|

; 1430 :             {
; 1431 :                 union {
; 1432 :                     BYTE    dataByte[4];
; 1433 :                     DWORD   dataLong;
; 1434 :                 } data;
; 1435 :                 register PBYTE pSrc = data.dataByte;
; 1436 :                 // read in the dword from the FIFO
; 1437 :                 data.dataLong = *pMMC_RX_FifoDW;

  0003c	e5963040	 ldr         r3, [r6, #0x40]

; 1438 :                 *(pCurPtr++) = *(pSrc++);
; 1439 :                 *(pCurPtr++) = *(pSrc++);
; 1440 :                 *(pCurPtr++) = *(pSrc++);
; 1441 :                 *(pCurPtr++) = *(pSrc++);
; 1442 :                 ByteCount -= 4;

  00040	e2444004	 sub         r4, r4, #4
  00044	e58d3000	 str         r3, [sp]
  00048	e5dd3000	 ldrb        r3, [sp]
  0004c	e5dd2001	 ldrb        r2, [sp, #1]
  00050	e5dd1002	 ldrb        r1, [sp, #2]
  00054	e4c03001	 strb        r3, [r0], #1
  00058	e5dd3003	 ldrb        r3, [sp, #3]
  0005c	e4c02001	 strb        r2, [r0], #1
  00060	e4c01001	 strb        r1, [r0], #1
  00064	e4c03001	 strb        r3, [r0], #1
  00068	ea000005	 b           |$LN15@EmptyRecei|
  0006c		 |$LN11@EmptyRecei|

; 1443 :                 
; 1444 :             }
; 1445 :             else while (ByteCount)  {

  0006c	e3540000	 cmp         r4, #0
  00070	0a000005	 beq         |$LN14@EmptyRecei|
  00074		 |$LL2@EmptyRecei|

; 1446 :                // read in the byte from the FIFO
; 1447 :                 *(pCurPtr++) = *pMMC_RX_Fifo;

  00074	e5d63040	 ldrb        r3, [r6, #0x40]

; 1448 :                 ByteCount--;

  00078	e2544001	 subs        r4, r4, #1
  0007c	e4c03001	 strb        r3, [r0], #1
  00080	1afffffb	 bne         |$LL2@EmptyRecei|
  00084		 |$LN15@EmptyRecei|

; 1424 :     
; 1425 :     // we are touching the block buffer, we must set the process permissions
; 1426 : 
; 1427 :             // empty the FIFO
; 1428 :         while (ByteCount) {

  00084	e3540000	 cmp         r4, #0
  00088	1affffe9	 bne         |$LL6@EmptyRecei|
  0008c		 |$LN14@EmptyRecei|

; 1449 :             }
; 1450 :         };
; 1451 :     pRequest->HCParam += dwTotalRead;

  0008c	e5953044	 ldr         r3, [r5, #0x44]
  00090	e083300e	 add         r3, r3, lr
  00094	e5853044	 str         r3, [r5, #0x44]

; 1452 : }

  00098	e28dd004	 add         sp, sp, #4
  0009c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$M45089|

			 ENDP  ; |EmptyReceiveFifo|

	EXPORT	|HandleTransferDone|
	IMPORT	|SDPerformSafeCopy|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T45837| DCD	|$LN220@HandleTran|
	DCD	0xc000f505

  00000			 AREA	 |.pdata|, PDATA
|$T45839| DCD	|$LN40@HandleTran|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T45835| DCD	0x1
	DCD	|$LN44@HandleTran|
	DCD	|$LN45@HandleTran|
	DCD	|$LN40@HandleTran|
	DCD	|$LN41@HandleTran|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T45835|

  00008		 |HandleTransferDone| PROC

; 1463 : {

  00008		 |$LN220@HandleTran|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0003	 stmdb       sp!, {r0, r1}
  00010	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00014	e28db018	 add         r11, sp, #0x18
  00018	e24dd004	 sub         sp, sp, #4
  0001c		 |$LN218@HandleTran|
  0001c	e1a06001	 mov         r6, r1
  00020	e1a04000	 mov         r4, r0
  00024	e58b4000	 str         r4, [r11]

; 1464 :     PSD_BUS_REQUEST pRequest;       // current request
; 1465 :     DWORD           regValue;       // intermediate byte value
; 1466 :     ULONG           maxBytes;       // max bytes
; 1467 : 
; 1468 :         // turn off the transfer done interrupt
; 1469 :     TRANSFER_DONE_INTERRUPT_OFF(pController);

  00028	e2840ed5	 add         r0, r4, #0xD5, 28
  0002c	eb000000	 bl          EnterCriticalSection
  00030	e5942004	 ldr         r2, [r4, #4]
  00034	e2840ed5	 add         r0, r4, #0xD5, 28
  00038	e5923028	 ldr         r3, [r2, #0x28]
  0003c	e3833001	 orr         r3, r3, #1
  00040	e5823028	 str         r3, [r2, #0x28]
  00044	eb000000	 bl          LeaveCriticalSection

; 1470 :         // turn off data error interrupt
; 1471 :     PROGRAM_DATA_ERROR_INTERRUPT_OFF(pController);

  00048	e2840ed5	 add         r0, r4, #0xD5, 28
  0004c	eb000000	 bl          EnterCriticalSection
  00050	e5942004	 ldr         r2, [r4, #4]
  00054	e2840ed5	 add         r0, r4, #0xD5, 28
  00058	e5923028	 ldr         r3, [r2, #0x28]
  0005c	e3833c01	 orr         r3, r3, #1, 24
  00060	e5823028	 str         r3, [r2, #0x28]
  00064	eb000000	 bl          LeaveCriticalSection

; 1472 :       
; 1473 :     pController->dwControllerIstTimeout = INFINITE;
; 1474 : 
; 1475 :         // get the current request  
; 1476 :     pRequest = pController->pCurrentRequest; 

  00068	e594301c	 ldr         r3, [r4, #0x1C]
  0006c	e3e02000	 mvn         r2, #0
  00070	e584203c	 str         r2, [r4, #0x3C]
  00074	e1b05003	 movs        r5, r3
  00078	e50b501c	 str         r5, [r11, #-0x1C]

; 1477 : 
; 1478 :         // this should never happen because we mark the request as un-cancelable
; 1479 :     DEBUG_ASSERT(NULL != pRequest);
; 1480 :     if( !pRequest ) 

  0007c	1a000010	 bne         |$LN36@HandleTran|

; 1481 :     {
; 1482 :         RX_FIFO_INTERRUPT_OFF(pController);

  00080	e2840ed5	 add         r0, r4, #0xD5, 28
  00084	eb000000	 bl          EnterCriticalSection
  00088	e5942004	 ldr         r2, [r4, #4]
  0008c	e2840ed5	 add         r0, r4, #0xD5, 28
  00090	e5923028	 ldr         r3, [r2, #0x28]
  00094	e3833020	 orr         r3, r3, #0x20
  00098	e5823028	 str         r3, [r2, #0x28]
  0009c	eb000000	 bl          LeaveCriticalSection

; 1483 :         TX_FIFO_INTERRUPT_OFF(pController);

  000a0	e2840ed5	 add         r0, r4, #0xD5, 28
  000a4	eb000000	 bl          EnterCriticalSection
  000a8	e5942004	 ldr         r2, [r4, #4]
  000ac	e2840ed5	 add         r0, r4, #0xD5, 28
  000b0	e5923028	 ldr         r3, [r2, #0x28]
  000b4	e3833040	 orr         r3, r3, #0x40
  000b8	e5823028	 str         r3, [r2, #0x28]
  000bc	eb000000	 bl          LeaveCriticalSection

; 1484 :         return;

  000c0	ea0000c2	 b           |$LN37@HandleTran|
  000c4		 |$LN36@HandleTran|

; 1485 :     }
; 1486 : 
; 1487 :     if (TRANSFER_IS_READ(pRequest)) {

  000c4	e5953010	 ldr         r3, [r5, #0x10]
  000c8	e3530000	 cmp         r3, #0
  000cc	1a000005	 bne         |$LN35@HandleTran|

; 1488 :             // make sure RX fifo interrupt is off 
; 1489 :         RX_FIFO_INTERRUPT_OFF(pController);

  000d0	e2840ed5	 add         r0, r4, #0xD5, 28
  000d4	eb000000	 bl          EnterCriticalSection
  000d8	e5942004	 ldr         r2, [r4, #4]
  000dc	e5923028	 ldr         r3, [r2, #0x28]
  000e0	e3833020	 orr         r3, r3, #0x20
  000e4	ea000006	 b           |$LN216@HandleTran|
  000e8		 |$LN35@HandleTran|

; 1490 :     } else if (TRANSFER_IS_WRITE(pRequest)) {

  000e8	e3530001	 cmp         r3, #1
  000ec	1a000007	 bne         |$LN33@HandleTran|

; 1491 :             // make sure TX fifo interrupt is off 
; 1492 :         TX_FIFO_INTERRUPT_OFF(pController);

  000f0	e2840ed5	 add         r0, r4, #0xD5, 28
  000f4	eb000000	 bl          EnterCriticalSection
  000f8	e5942004	 ldr         r2, [r4, #4]
  000fc	e5923028	 ldr         r3, [r2, #0x28]
  00100	e3833040	 orr         r3, r3, #0x40
  00104		 |$LN216@HandleTran|
  00104	e5823028	 str         r3, [r2, #0x28]
  00108	e2840ed5	 add         r0, r4, #0xD5, 28
  0010c	eb000000	 bl          LeaveCriticalSection
  00110		 |$LN33@HandleTran|

; 1493 :             // can't turn off the clock until the prog done interrupt!
; 1494 :     } else {
; 1495 :         DEBUG_ASSERT(FALSE);
; 1496 :     }
; 1497 : 
; 1498 :         // check the transfer status
; 1499 :     regValue = READ_MMC_REGISTER_DWORD(pController, MMC_STAT);

  00110	e5942004	 ldr         r2, [r4, #4]
  00114	e5923004	 ldr         r3, [r2, #4]

; 1500 : 
; 1501 :         // check for errors
; 1502 :     if (regValue & MMC_STAT_FLASH_ERROR) {

  00118	e3130c02	 tst         r3, #2, 24

; 1503 :         ASSERT(0);
; 1504 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports FLASH ERROR\n")));
; 1505 :         IndicateBusRequestComplete(pController->pHCContext,
; 1506 :                                         pRequest ,
; 1507 :                                         SD_API_STATUS_DATA_ERROR);

  0011c	13a02133	 movne       r2, #0x33, 2

; 1500 : 
; 1501 :         // check for errors
; 1502 :     if (regValue & MMC_STAT_FLASH_ERROR) {

  00120	1a0000a7	 bne         |$LN217@HandleTran|

; 1508 :         return;
; 1509 :     }
; 1510 : 
; 1511 :     if (regValue & MMC_STAT_SPI_WR_ERROR) {
; 1512 :         ASSERT(0);
; 1513 :     }
; 1514 : 
; 1515 :     if (regValue & MMC_STAT_RD_STALLED) {
; 1516 :         ASSERT(0);
; 1517 :     }
; 1518 : 
; 1519 :     if ( ( regValue & MMC_STAT_READ_TIMEOUT ) || fForceTimeout ) {

  00124	e3130001	 tst         r3, #1
  00128	1a000092	 bne         |$LN27@HandleTran|
  0012c	e3560000	 cmp         r6, #0
  00130	1a000090	 bne         |$LN27@HandleTran|

; 1533 :         return;
; 1534 : 
; 1535 :     } else if (regValue & MMC_STAT_READ_DATA_CRC_ERROR) {

  00134	e3130008	 tst         r3, #8
  00138	0a000013	 beq         |$LN23@HandleTran|

; 1536 : 
; 1537 :         DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleTransferDoneInterrupt: Read Data Contains CRC error \n"))); 
; 1538 :         if( !( pController->fClockAlwaysOn || 
; 1539 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  0013c	e5943d3c	 ldr         r3, [r4, #0xD3C]
  00140	e3530000	 cmp         r3, #0
  00144	1a00000e	 bne         |$LN130@HandleTran|
  00148	e5943d40	 ldr         r3, [r4, #0xD40]
  0014c	e3530000	 cmp         r3, #0
  00150	0a000002	 beq         |$LN21@HandleTran|
  00154	e5943d30	 ldr         r3, [r4, #0xD30]
  00158	e3530000	 cmp         r3, #0
  0015c	1a000008	 bne         |$LN130@HandleTran|
  00160		 |$LN21@HandleTran|

; 1540 :         {
; 1541 :                 // turn off the clock
; 1542 :             SDClockOff(pController);

  00160	e5923004	 ldr         r3, [r2, #4]
  00164	e3130c01	 tst         r3, #1, 24
  00168	0a000005	 beq         |$LN130@HandleTran|
  0016c	e3a03001	 mov         r3, #1
  00170	e5823000	 str         r3, [r2]
  00174	e5942004	 ldr         r2, [r4, #4]
  00178		 |$LL117@HandleTran|
  00178	e5923004	 ldr         r3, [r2, #4]
  0017c	e3130c01	 tst         r3, #1, 24
  00180	1afffffc	 bne         |$LL117@HandleTran|
  00184		 |$LN130@HandleTran|

; 1543 :         }
; 1544 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports CRC ERROR\n")));
; 1545 :         IndicateBusRequestComplete(pController->pHCContext,
; 1546 :                                         pRequest ,
; 1547 :                                         SD_API_STATUS_CRC_ERROR);

  00184	e3a02137	 mov         r2, #0x37, 2
  00188	ea00008d	 b           |$LN217@HandleTran|
  0018c		 |$LN23@HandleTran|

; 1548 :         return;
; 1549 :     } else if (regValue & MMC_STAT_WRITE_DATA_CRC_ERROR) {

  0018c	e3130004	 tst         r3, #4
  00190	0a000013	 beq         |$LN19@HandleTran|

; 1550 : 
; 1551 :         DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleTransferDoneInterrupt: Card received Write Data with CRC error \n"))); 
; 1552 :         if( !( pController->fClockAlwaysOn || 
; 1553 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00194	e5943d3c	 ldr         r3, [r4, #0xD3C]
  00198	e3530000	 cmp         r3, #0
  0019c	1afffff8	 bne         |$LN130@HandleTran|
  001a0	e5943d40	 ldr         r3, [r4, #0xD40]
  001a4	e3530000	 cmp         r3, #0
  001a8	0a000002	 beq         |$LN17@HandleTran|
  001ac	e5943d30	 ldr         r3, [r4, #0xD30]
  001b0	e3530000	 cmp         r3, #0
  001b4	1afffff2	 bne         |$LN130@HandleTran|
  001b8		 |$LN17@HandleTran|

; 1554 :         {
; 1555 :                 // turn off the clock
; 1556 :             SDClockOff(pController);

  001b8	e5923004	 ldr         r3, [r2, #4]
  001bc	e3130c01	 tst         r3, #1, 24
  001c0	0affffef	 beq         |$LN130@HandleTran|
  001c4	e3a03001	 mov         r3, #1
  001c8	e5823000	 str         r3, [r2]
  001cc	e5942004	 ldr         r2, [r4, #4]
  001d0		 |$LL136@HandleTran|
  001d0	e5923004	 ldr         r3, [r2, #4]
  001d4	e3130c01	 tst         r3, #1, 24
  001d8	1afffffc	 bne         |$LL136@HandleTran|

; 1543 :         }
; 1544 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports CRC ERROR\n")));
; 1545 :         IndicateBusRequestComplete(pController->pHCContext,
; 1546 :                                         pRequest ,
; 1547 :                                         SD_API_STATUS_CRC_ERROR);

  001dc	e3a02137	 mov         r2, #0x37, 2
  001e0	ea000077	 b           |$LN217@HandleTran|
  001e4		 |$LN19@HandleTran|

; 1557 :         }
; 1558 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports CRC ERROR\n")));
; 1559 :         IndicateBusRequestComplete(pController->pHCContext,
; 1560 :                                         pRequest ,
; 1561 :                                         SD_API_STATUS_CRC_ERROR);
; 1562 :         return;
; 1563 :     }
; 1564 : 
; 1565 :     
; 1566 : #ifdef DEBUG
; 1567 :     ASSERT( pController->fDMATransferInProgress == FALSE );
; 1568 : #endif
; 1569 : 
; 1570 :     if(pController->fDMATransfer)

  001e4	e5943aa8	 ldr         r3, [r4, #0xAA8]
  001e8	e3530000	 cmp         r3, #0

; 1571 :     {
; 1572 :         pRequest->HCParam = pRequest->NumBlocks * pRequest->BlockSize;

  001ec	15952040	 ldrne       r2, [r5, #0x40]
  001f0	1595303c	 ldrne       r3, [r5, #0x3C]
  001f4	10030392	 mulne       r3, r2, r3
  001f8	15853044	 strne       r3, [r5, #0x44]

; 1573 :     }
; 1574 : 
; 1575 : 
; 1576 :     if (TRANSFER_IS_READ(pRequest)) {

  001fc	e5953010	 ldr         r3, [r5, #0x10]
  00200	e3530000	 cmp         r3, #0
  00204	1a000045	 bne         |$LN187@HandleTran|

; 1577 : 
; 1578 :         if( pController->fDMATransfer ) {

  00208	e5943aa8	 ldr         r3, [r4, #0xAA8]
  0020c	e3530000	 cmp         r3, #0
  00210	0a00001f	 beq         |$LN14@HandleTran|

; 1579 :             if( pController->fDMAUsingDriverBuffer )

  00214	e5943aac	 ldr         r3, [r4, #0xAAC]
  00218	e3530000	 cmp         r3, #0
  0021c	0a00002a	 beq         |$LN46@HandleTran|

; 1580 :             {
; 1581 :                 // copy data from our DMA buffer into client buffer
; 1582 :                 if( !SDPerformSafeCopy(pRequest->pBlockBuffer,
; 1583 :                                        pController->pDMABuffer,
; 1584 :                                        pRequest->BlockSize * pRequest->NumBlocks) )

  00220	e595e040	 ldr         lr, [r5, #0x40]
  00224	e595303c	 ldr         r3, [r5, #0x3C]
  00228	e5941068	 ldr         r1, [r4, #0x68]
  0022c	e5950048	 ldr         r0, [r5, #0x48]
  00230	e002039e	 mul         r2, lr, r3
  00234	eb000000	 bl          SDPerformSafeCopy
  00238	e3500000	 cmp         r0, #0
  0023c	1a000022	 bne         |$LN46@HandleTran|

; 1585 :                 {
; 1586 :                     ASSERT(0);
; 1587 : 
; 1588 :                     DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleTransferDoneInterrupt: Access Violation\n")));
; 1589 :     
; 1590 :                     if( !( pController->fClockAlwaysOn || 
; 1591 :                            ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00240	e5943d3c	 ldr         r3, [r4, #0xD3C]
  00244	e3530000	 cmp         r3, #0
  00248	1a00000f	 bne         |$LN168@HandleTran|
  0024c	e5943d40	 ldr         r3, [r4, #0xD40]
  00250	e3530000	 cmp         r3, #0
  00254	0a000002	 beq         |$LN10@HandleTran|
  00258	e5943d30	 ldr         r3, [r4, #0xD30]
  0025c	e3530000	 cmp         r3, #0
  00260	1a000009	 bne         |$LN168@HandleTran|
  00264		 |$LN10@HandleTran|

; 1592 :                     {
; 1593 :                             // turn off the clock
; 1594 :                         SDClockOff(pController);

  00264	e5942004	 ldr         r2, [r4, #4]
  00268	e5923004	 ldr         r3, [r2, #4]
  0026c	e3130c01	 tst         r3, #1, 24
  00270	0a000005	 beq         |$LN168@HandleTran|
  00274	e3a03001	 mov         r3, #1
  00278	e5823000	 str         r3, [r2]
  0027c	e5942004	 ldr         r2, [r4, #4]
  00280		 |$LL155@HandleTran|
  00280	e5923004	 ldr         r3, [r2, #4]
  00284	e3130c01	 tst         r3, #1, 24
  00288	1afffffc	 bne         |$LL155@HandleTran|
  0028c		 |$LN168@HandleTran|

; 1595 :                     }
; 1596 : 
; 1597 :                     DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports Access Violation\n")));
; 1598 :                     IndicateBusRequestComplete(pController->pHCContext,
; 1599 :                                                     pRequest ,
; 1600 :                                                     SD_API_STATUS_ACCESS_VIOLATION);

  0028c	e3a02117	 mov         r2, #0x17, 2

; 1601 :                     return;

  00290	ea00004b	 b           |$LN217@HandleTran|
  00294		 |$LN14@HandleTran|

; 1602 :                 }
; 1603 :             }
; 1604 : 
; 1605 :         } else {
; 1606 :                 // why are we doing this here? If the remaining read data is less than a Fifo's worth (32)
; 1607 :                 // we won't get the RX Fifo Read Request interrupt because the fifo won't be full.
; 1608 :                 // also even if it is full or if this isn't the case the TRANSFER_DONE bit seems to mask it out
; 1609 :                 // anyways this prevents the problem where there are bytes stuck in the Fifo
; 1610 :             maxBytes = pRequest->NumBlocks * pRequest->BlockSize;

  00294	e5952040	 ldr         r2, [r5, #0x40]
  00298	e595303c	 ldr         r3, [r5, #0x3C]

; 1611 : 
; 1612 :             if (pRequest->HCParam < maxBytes) {

  0029c	e5950044	 ldr         r0, [r5, #0x44]
  002a0	e0010392	 mul         r1, r2, r3
  002a4	e1500001	 cmp         r0, r1
  002a8	2a000007	 bcs         |$LN46@HandleTran|
  002ac		 |$LN44@HandleTran|

; 1613 :                 DbgPrintZo(SDH_RECEIVE_ZONE, (TEXT("HandleTransferDoneInterrupt: Fifo contains remaining data, Max: %d, current count %d  \n"),
; 1614 :                     maxBytes, pRequest->HCParam));
; 1615 :                     // get the remaining bytes out of the FIFO
; 1616 :                     __try {
; 1617 :                         EmptyReceiveFifo(pController, 
; 1618 :                                  pRequest, 
; 1619 :                                  (maxBytes - pRequest->HCParam), 
; 1620 :                                  maxBytes);

  002ac	e1a03001	 mov         r3, r1
  002b0	e0412000	 sub         r2, r1, r0
  002b4	e1a01005	 mov         r1, r5
  002b8	e1a00004	 mov         r0, r4
  002bc	eb000000	 bl          EmptyReceiveFifo
  002c0		 |$LN45@HandleTran|
  002c0	ea000001	 b           |$LN46@HandleTran|
  002c4		 |$LN41@HandleTran|

; 1621 :                     }__except(EXCEPTION_EXECUTE_HANDLER) {

  002c4	e59b4000	 ldr         r4, [r11]
  002c8	e51b501c	 ldr         r5, [r11, #-0x1C]
  002cc		 |$LN46@HandleTran|

; 1622 :                     }
; 1623 :             }
; 1624 :         }
; 1625 : 
; 1626 :         SetCurrentState(pController, ReadDataDone);
; 1627 : 
; 1628 :         if( !( pController->fClockAlwaysOn || 
; 1629 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  002cc	e5943d3c	 ldr         r3, [r4, #0xD3C]
  002d0	e3a0200a	 mov         r2, #0xA
  002d4	e5842cec	 str         r2, [r4, #0xCEC]
  002d8	e3530000	 cmp         r3, #0
  002dc	1a00000f	 bne         |$LN187@HandleTran|
  002e0	e5943d40	 ldr         r3, [r4, #0xD40]
  002e4	e3530000	 cmp         r3, #0
  002e8	0a000002	 beq         |$LN5@HandleTran|
  002ec	e5943d30	 ldr         r3, [r4, #0xD30]
  002f0	e3530000	 cmp         r3, #0
  002f4	1a000009	 bne         |$LN187@HandleTran|
  002f8		 |$LN5@HandleTran|

; 1630 :         {
; 1631 :                 // now it is safe to turn off the clock
; 1632 :             SDClockOff(pController);

  002f8	e5942004	 ldr         r2, [r4, #4]
  002fc	e5923004	 ldr         r3, [r2, #4]
  00300	e3130c01	 tst         r3, #1, 24
  00304	0a000005	 beq         |$LN187@HandleTran|
  00308	e3a03001	 mov         r3, #1
  0030c	e5823000	 str         r3, [r2]
  00310	e5942004	 ldr         r2, [r4, #4]
  00314		 |$LL174@HandleTran|
  00314	e5923004	 ldr         r3, [r2, #4]
  00318	e3130c01	 tst         r3, #1, 24
  0031c	1afffffc	 bne         |$LL174@HandleTran|
  00320		 |$LN187@HandleTran|

; 1633 :         }
; 1634 : 
; 1635 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("Bytes read: [%S]\n"), HexDisplay( pRequest->pBlockBuffer, TRANSFER_SIZE(pRequest) ) ) );
; 1636 :     }
; 1637 : 
; 1638 : 
; 1639 :     if (TRANSFER_IS_WRITE(pRequest)) {

  00320	e5953010	 ldr         r3, [r5, #0x10]
  00324	e3530001	 cmp         r3, #1
  00328	1a000010	 bne         |$LN3@HandleTran|

; 1640 : 
; 1641 :         if (!IS_PROGRAM_DONE(pController)) {

  0032c	e5943004	 ldr         r3, [r4, #4]
  00330	e5933004	 ldr         r3, [r3, #4]
  00334	e3130a01	 tst         r3, #1, 20
  00338	1a00000c	 bne         |$LN3@HandleTran|

; 1642 :             SetCurrentState(pController, ProgramWait);
; 1643 :             
; 1644 :                 // turn on programming done interrupt
; 1645 :             PROGRAM_DONE_INTERRUPT_ON(pController); 

  0033c	e3a03006	 mov         r3, #6
  00340	e2840ed5	 add         r0, r4, #0xD5, 28
  00344	e5843cec	 str         r3, [r4, #0xCEC]
  00348	eb000000	 bl          EnterCriticalSection
  0034c	e5942004	 ldr         r2, [r4, #4]
  00350	e2840ed5	 add         r0, r4, #0xD5, 28
  00354	e5923028	 ldr         r3, [r2, #0x28]
  00358	e3c33002	 bic         r3, r3, #2
  0035c	e5823028	 str         r3, [r2, #0x28]
  00360	eb000000	 bl          LeaveCriticalSection

; 1646 :             //Sleep(500);
; 1647 : 
; 1648 :                 // check to see if programming is finished
; 1649 :             if (!IS_PROGRAM_DONE(pController)) {

  00364	e5943004	 ldr         r3, [r4, #4]
  00368	e5933004	 ldr         r3, [r3, #4]

; 1650 :                 DbgPrintZo(SDH_TRANSMIT_ZONE, (TEXT("HandleTransferDoneInterrupt: Programming Not Complete \n")));   
; 1651 :             }
; 1652 : 
; 1653 :             // if we wait on the programming done interrupt this could
; 1654 :             // go on forever because now it is up to the memory card, 
; 1655 :             // we may have to make this request cancelable at this point
; 1656 :             
; 1657 :             return;

  0036c	ea000017	 b           |$LN37@HandleTran|
  00370		 |$LN3@HandleTran|

; 1658 :         }
; 1659 :     } 
; 1660 : 
; 1661 :     DEBUG_ASSERT((pRequest->HCParam >= (pRequest->NumBlocks * pRequest->BlockSize)));
; 1662 :         // complete the request
; 1663 :     DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports Data Transfer Completed\n")));
; 1664 :     if (TRANSFER_IS_READ(pRequest)) {
; 1665 : 		DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("Bytes read: [%S]\n"), HexDisplay( pRequest->pBlockBuffer, TRANSFER_SIZE(pRequest) ) ) );
; 1666 : 	}
; 1667 : 
; 1668 :     IndicateBusRequestComplete(pController->pHCContext,
; 1669 :                                     pRequest ,
; 1670 :                                     SD_API_STATUS_SUCCESS);

  00370	e3a02000	 mov         r2, #0
  00374	ea000012	 b           |$LN217@HandleTran|
  00378		 |$LN27@HandleTran|

; 1520 :         DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleTransferDoneInterrupt: Read Data TimedOut \n")));     
; 1521 :         
; 1522 :         if( !( pController->fClockAlwaysOn || 
; 1523 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00378	e5943d3c	 ldr         r3, [r4, #0xD3C]
  0037c	e3530000	 cmp         r3, #0
  00380	1a00000e	 bne         |$LN111@HandleTran|
  00384	e5943d40	 ldr         r3, [r4, #0xD40]
  00388	e3530000	 cmp         r3, #0
  0038c	0a000002	 beq         |$LN25@HandleTran|
  00390	e5943d30	 ldr         r3, [r4, #0xD30]
  00394	e3530000	 cmp         r3, #0
  00398	1a000008	 bne         |$LN111@HandleTran|
  0039c		 |$LN25@HandleTran|

; 1524 :         {
; 1525 :                 // turn off the clock
; 1526 :             SDClockOff(pController);

  0039c	e5923004	 ldr         r3, [r2, #4]
  003a0	e3130c01	 tst         r3, #1, 24
  003a4	0a000005	 beq         |$LN111@HandleTran|
  003a8	e3a03001	 mov         r3, #1
  003ac	e5823000	 str         r3, [r2]
  003b0	e5942004	 ldr         r2, [r4, #4]
  003b4		 |$LL98@HandleTran|
  003b4	e5923004	 ldr         r3, [r2, #4]
  003b8	e3130c01	 tst         r3, #1, 24
  003bc	1afffffc	 bne         |$LL98@HandleTran|
  003c0		 |$LN111@HandleTran|

; 1527 :         }
; 1528 : 
; 1529 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleTransferDone reports DATA TIMEOUT\n")));
; 1530 :         IndicateBusRequestComplete(pController->pHCContext,
; 1531 :                                         pRequest ,
; 1532 :                                         SD_API_STATUS_DATA_TIMEOUT);

  003c0	e3a02157	 mov         r2, #0x57, 2
  003c4		 |$LN217@HandleTran|
  003c4	e1a01005	 mov         r1, r5
  003c8	e5940018	 ldr         r0, [r4, #0x18]
  003cc	eb000000	 bl          IndicateBusRequestComplete
  003d0		 |$LN37@HandleTran|

; 1671 : }

  003d0	e24bd018	 sub         sp, r11, #0x18
  003d4	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  003d8	e12fff1e	 bx          lr

			 ENDP  ; |HandleTransferDone|

  003dc		 |$LN40@HandleTran|
  003dc		 |$LN219@HandleTran|

; 1621 :                     }__except(EXCEPTION_EXECUTE_HANDLER) {

  003dc	e52de004	 str         lr, [sp, #-4]!
  003e0		 |$LN43@HandleTran|
  003e0		 |$LN222@HandleTran|
  003e0	e3a00001	 mov         r0, #1
  003e4		 |$LN42@HandleTran|
  003e4	e49df004	 ldr         pc, [sp], #4
  003e8		 |$LN223@HandleTran|
  003e8		 |$LN221@HandleTran|
	EXPORT	|SDLoadXmitFifo|

  00000			 AREA	 |.pdata|, PDATA
|$T45874| DCD	|$LN18@SDLoadXmit|
	DCD	0x40003102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDLoadXmitFifo| PROC

; 1683 : {

  00000		 |$LN18@SDLoadXmit|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M45871|
  00008	e1a07002	 mov         r7, r2

; 1684 :     ULONG           remainingBytes; // remaining bytes in the transfer
; 1685 :     DWORD           ii;
; 1686 :     volatile UCHAR *pMMC_TX_Fifo = (volatile UCHAR *)&(pController->pSDMMCRegisters->txfifo);

  0000c	e5906004	 ldr         r6, [r0, #4]

; 1687 :     volatile DWORD *pMMC_TX_FifoDW = (volatile DWORD *)&(pController->pSDMMCRegisters->txfifo);
; 1688 :     PBYTE pSrc;
; 1689 : 
; 1690 :     DbgPrintZo(SDH_TRANSMIT_ZONE, (TEXT("SDLoadXmitFifo: Current %d \n"),pRequest->HCParam));
; 1691 : 
; 1692 :         // make sure the partial full flag is cleared
; 1693 :     TX_BUFFER_PARTIAL_NOT_FULL(pController);

  00010	e3a03000	 mov         r3, #0

; 1694 : 
; 1695 : 
; 1696 :         // figure out how much to prefetch from the user
; 1697 :         // buffer safely
; 1698 :     remainingBytes = maxBytes - pRequest->HCParam;
; 1699 : 
; 1700 :     if (remainingBytes > MMC_TXFIFO_SIZE) {
; 1701 :             // fix it
; 1702 :         remainingBytes = MMC_TXFIFO_SIZE;
; 1703 :     } 
; 1704 :     pSrc = pRequest->pBlockBuffer+pRequest->HCParam;
; 1705 : 
; 1706 :             // according to the spec (15.2.8.3) the TX Fifo interrupt asserts for every empty fifo
; 1707 :             // (32 bytes)
; 1708 :             // so we write a Fifo's worth, as per spec 
; 1709 :     ii = 0;

  00014	e3a04000	 mov         r4, #0
  00018	e5863024	 str         r3, [r6, #0x24]
  0001c	e5915044	 ldr         r5, [r1, #0x44]
  00020	e5913048	 ldr         r3, [r1, #0x48]
  00024	e047e005	 sub         lr, r7, r5
  00028	e35e0020	 cmp         lr, #0x20
  0002c	83a0e020	 movhi       lr, #0x20

; 1710 :     while( remainingBytes > 0 )

  00030	e0835005	 add         r5, r3, r5
  00034	ea000012	 b           |$LN15@SDLoadXmit|
  00038		 |$LL6@SDLoadXmit|

; 1711 :     {
; 1712 :         if( remainingBytes >= 4 )

  00038	e35e0004	 cmp         lr, #4
  0003c	3a00000c	 bcc         |$LN4@SDLoadXmit|

; 1713 :         {
; 1714 :             union {
; 1715 :                 BYTE dataByte[4];
; 1716 :                 DWORD dataLong;
; 1717 :             } data;
; 1718 :             register PBYTE pDst = data.dataByte;
; 1719 :             *(pDst++) = *(pSrc++);

  00040	e4d52001	 ldrb        r2, [r5], #1

; 1720 :             *(pDst++) = *(pSrc++);
; 1721 :             *(pDst++) = *(pSrc++);
; 1722 :             *(pDst++) = *(pSrc++);
; 1723 :             // transfer bytes to the fifo from the safe buffer
; 1724 :             *pMMC_TX_FifoDW = data.dataLong;
; 1725 :             
; 1726 :             remainingBytes-=4;

  00044	e24ee004	 sub         lr, lr, #4

; 1727 :             ii+=4;

  00048	e2844004	 add         r4, r4, #4
  0004c	e4d53001	 ldrb        r3, [r5], #1
  00050	e5cd2000	 strb        r2, [sp]
  00054	e4d52001	 ldrb        r2, [r5], #1
  00058	e5cd3001	 strb        r3, [sp, #1]
  0005c	e4d53001	 ldrb        r3, [r5], #1
  00060	e5cd2002	 strb        r2, [sp, #2]
  00064	e5cd3003	 strb        r3, [sp, #3]
  00068	e59d3000	 ldr         r3, [sp]
  0006c	e5863044	 str         r3, [r6, #0x44]

; 1728 :         }
; 1729 :         else

  00070	ea000003	 b           |$LN15@SDLoadXmit|
  00074		 |$LN4@SDLoadXmit|

; 1730 :         {
; 1731 :                 // transfer bytes to the fifo from the safe buffer
; 1732 :             *pMMC_TX_Fifo = *(pSrc++);

  00074	e4d53001	 ldrb        r3, [r5], #1

; 1733 :             remainingBytes--;

  00078	e24ee001	 sub         lr, lr, #1

; 1734 :             ii++;

  0007c	e2844001	 add         r4, r4, #1
  00080	e5c63044	 strb        r3, [r6, #0x44]
  00084		 |$LN15@SDLoadXmit|

; 1710 :     while( remainingBytes > 0 )

  00084	e35e0000	 cmp         lr, #0
  00088	1affffea	 bne         |$LL6@SDLoadXmit|

; 1735 :         }
; 1736 :     } // while
; 1737 :     pRequest->HCParam += ii;

  0008c	e5913044	 ldr         r3, [r1, #0x44]

; 1738 : 
; 1739 :         // check for a partial buffer
; 1740 :     if (ii < MMC_TXFIFO_SIZE) {

  00090	e3540020	 cmp         r4, #0x20

; 1741 :         TX_BUFFER_PARTIAL_FULL(pController);

  00094	33a02001	 movcc       r2, #1
  00098	e0833004	 add         r3, r3, r4
  0009c	e5813044	 str         r3, [r1, #0x44]
  000a0	35903004	 ldrcc       r3, [r0, #4]
  000a4	35832024	 strcc       r2, [r3, #0x24]

; 1742 :     }
; 1743 : 
; 1744 :     DbgPrintZo(SDH_TRANSMIT_ZONE, (TEXT("SDLoadXmitFifo: New Current %d  \n"),pRequest->HCParam));
; 1745 :     
; 1746 :         // see if we are done
; 1747 :     if (pRequest->HCParam >= maxBytes) {

  000a8	e5913044	 ldr         r3, [r1, #0x44]
  000ac	e1530007	 cmp         r3, r7

; 1748 :         return TRUE;

  000b0	23a00001	 movcs       r0, #1

; 1749 :     } 
; 1750 : 
; 1751 :     return FALSE;

  000b4	33a00000	 movcc       r0, #0

; 1752 : }

  000b8	e28dd004	 add         sp, sp, #4
  000bc	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M45872|

			 ENDP  ; |SDLoadXmitFifo|

	EXPORT	|PrepareDmaTransferOnDriverBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T45892| DCD	|$LN16@PrepareDma|
	DCD	0x40004601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PrepareDmaTransferOnDriverBuffer| PROC

; 1887 : {

  00000		 |$LN16@PrepareDma|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M45889|
  00004	e1a07001	 mov         r7, r1
  00008	e1a05000	 mov         r5, r0

; 1888 :     DWORD dwTransferLength;
; 1889 :     DWORD dwDataAddress;
; 1890 :     DWORD dwNextDescriptorAddress;
; 1891 :     DWORD dwDescriptorIndex = 0;
; 1892 : 
; 1893 :     ASSERT( MAXIMUM_DMA_TRANSFER_SIZE >= pController->systemInfo.dwPageSize );
; 1894 : 
; 1895 :     dwTransferLength = pRequest->BlockSize * pRequest->NumBlocks;

  0000c	e5974040	 ldr         r4, [r7, #0x40]
  00010	e597303c	 ldr         r3, [r7, #0x3C]

; 1896 :     dwDataAddress = pController->pDMABufferPhys.LowPart;
; 1897 :     dwNextDescriptorAddress = pController->pDMADescriptorsPhys.LowPart + sizeof(DMADescriptorChannelType);

  00014	e5952080	 ldr         r2, [r5, #0x80]

; 1898 : 
; 1899 :     // copy the data to the driver buffer for writing
; 1900 :     if( !(TRANSFER_IS_READ(pRequest)) )

  00018	e597e010	 ldr         lr, [r7, #0x10]
  0001c	e5958070	 ldr         r8, [r5, #0x70]
  00020	e0060394	 mul         r6, r4, r3
  00024	e2824010	 add         r4, r2, #0x10
  00028	e35e0000	 cmp         lr, #0
  0002c	0a000007	 beq         |$LN11@PrepareDma|

; 1901 :     {
; 1902 :         if( !SDPerformSafeCopy(pController->pDMABuffer,
; 1903 :                                pRequest->pBlockBuffer,
; 1904 :                                dwTransferLength) )

  00030	e5971048	 ldr         r1, [r7, #0x48]
  00034	e5950068	 ldr         r0, [r5, #0x68]
  00038	e1a02006	 mov         r2, r6
  0003c	eb000000	 bl          SDPerformSafeCopy
  00040	e3500000	 cmp         r0, #0

; 1905 :         {
; 1906 :             return FALSE;

  00044	03a00000	 moveq       r0, #0

; 1960 : }

  00048	08bd4ff0	 ldmeqia     sp!, {r4 - r11, lr}
  0004c	012fff1e	 bxeq        lr
  00050		 |$LN11@PrepareDma|

; 1907 :         }
; 1908 :     }
; 1909 : 
; 1910 :     // prepare the descriptors
; 1911 :     while( dwTransferLength > 0 )

  00050	e3560000	 cmp         r6, #0
  00054	0a000026	 beq         |$LN5@PrepareDma|
  00058	e3a03206	 mov         r3, #6, 4
  0005c	e3a02209	 mov         r2, #9, 4
  00060	e59fa0ac	 ldr         r10, [pc, #0xAC]
  00064	e59fb0a4	 ldr         r11, [pc, #0xA4]
  00068	e383e90f	 orr         lr, r3, #0xF, 18
  0006c	e382990f	 orr         r9, r2, #0xF, 18
  00070	e3a01000	 mov         r1, #0
  00074		 |$LL6@PrepareDma|

; 1912 :     {
; 1913 :         DWORD dwBlockLength = dwTransferLength;
; 1914 :         if( dwBlockLength > pController->systemInfo.dwPageSize )

  00074	e5953048	 ldr         r3, [r5, #0x48]
  00078	e1a00006	 mov         r0, r6
  0007c	e1560003	 cmp         r6, r3

; 1915 :         {
; 1916 :             dwBlockLength = pController->systemInfo.dwPageSize;

  00080	81a00003	 movhi       r0, r3

; 1917 :         }
; 1918 : 
; 1919 :         ASSERT( dwNextDescriptorAddress % 16 == 0 ); // make sure the address is 128 bit aligned
; 1920 :         pController->pDMADescriptors[dwDescriptorIndex].ddadr = dwNextDescriptorAddress;

  00084	e5953078	 ldr         r3, [r5, #0x78]
  00088	e7814003	 str         r4, [r1, +r3]

; 1921 : 
; 1922 :         if( (TRANSFER_IS_READ(pRequest)) )

  0008c	e5973010	 ldr         r3, [r7, #0x10]

; 1923 :         {
; 1924 :             pController->pDMADescriptors[dwDescriptorIndex].dsadr = SDIO_RX_FIFO;
; 1925 :             pController->pDMADescriptors[dwDescriptorIndex].dtadr = dwDataAddress;
; 1926 :             pController->pDMADescriptors[dwDescriptorIndex].dcmd  = DCMD_INC_TRG_ADDR |
; 1927 :                                                        DCMD_FLOW_SRC | 
; 1928 :                                                        //DCMD_END_IRQ_EN |
; 1929 :                                                        ( 3 << 16 ) | // 32 bytes maximum burst size of each data transfer
; 1930 :                                                        ( 3 << 14 ) | // 4 bytes width
; 1931 :                                                        dwBlockLength;
; 1932 :         }
; 1933 :         else
; 1934 :         {
; 1935 :             pController->pDMADescriptors[dwDescriptorIndex].dsadr = dwDataAddress;
; 1936 :             pController->pDMADescriptors[dwDescriptorIndex].dtadr = SDIO_TX_FIFO;
; 1937 :             pController->pDMADescriptors[dwDescriptorIndex].dcmd  = DCMD_INC_SRC_ADDR |
; 1938 :                                                        DCMD_FLOW_TRG | 
; 1939 :                                                        //DCMD_END_IRQ_EN |
; 1940 :                                                        ( 3 << 16 ) | // 32 bytes maximum burst size of each data transfer
; 1941 :                                                        ( 3 << 14 ) | // 4 bytes width
; 1942 :                                                        dwBlockLength;
; 1943 :         }
; 1944 : 
; 1945 :         dwTransferLength -= dwBlockLength;
; 1946 : 
; 1947 :         if( dwTransferLength == 0 )
; 1948 :         {
; 1949 :             pController->pDMADescriptors[dwDescriptorIndex].ddadr = 1; // this is the last descriptor, set the STOP bit
; 1950 :         }
; 1951 : 
; 1952 :         dwDataAddress += dwBlockLength;
; 1953 :         dwNextDescriptorAddress += sizeof(DMADescriptorChannelType);

  00090	e2844010	 add         r4, r4, #0x10
  00094	e3530000	 cmp         r3, #0
  00098	e5953078	 ldr         r3, [r5, #0x78]
  0009c	0180200e	 orreq       r2, r0, lr
  000a0	11802009	 orrne       r2, r0, r9
  000a4	e0813003	 add         r3, r1, r3
  000a8	0583a004	 streq       r10, [r3, #4]
  000ac	05953078	 ldreq       r3, [r5, #0x78]
  000b0	00813003	 addeq       r3, r1, r3
  000b4	05838008	 streq       r8, [r3, #8]
  000b8	15838004	 strne       r8, [r3, #4]
  000bc	15953078	 ldrne       r3, [r5, #0x78]
  000c0	e0888000	 add         r8, r8, r0
  000c4	10813003	 addne       r3, r1, r3
  000c8	1583b008	 strne       r11, [r3, #8]
  000cc	e5953078	 ldr         r3, [r5, #0x78]
  000d0	e0566000	 subs        r6, r6, r0
  000d4	e0813003	 add         r3, r1, r3
  000d8	e583200c	 str         r2, [r3, #0xC]
  000dc	05953078	 ldreq       r3, [r5, #0x78]
  000e0	03a02001	 moveq       r2, #1
  000e4	07812003	 streq       r2, [r1, +r3]

; 1954 :         dwDescriptorIndex++;

  000e8	e2811010	 add         r1, r1, #0x10
  000ec	e3560000	 cmp         r6, #0
  000f0	1affffdf	 bne         |$LL6@PrepareDma|
  000f4		 |$LN5@PrepareDma|

; 1955 :     } // while
; 1956 : 
; 1957 :     pController->fDMAUsingDriverBuffer = TRUE;
; 1958 :     pController->dwBytesRemaining = 0;

  000f4	e3a03000	 mov         r3, #0
  000f8	e5853acc	 str         r3, [r5, #0xACC]
  000fc	e3a03001	 mov         r3, #1
  00100	e5853aac	 str         r3, [r5, #0xAAC]

; 1959 :     return TRUE;

  00104	e3a00001	 mov         r0, #1

; 1960 : }

  00108	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN17@PrepareDma|
  00110		 |$LN18@PrepareDma|
  00110	41100044	 DCD         0x41100044
  00114		 |$LN19@PrepareDma|
  00114	41100040	 DCD         0x41100040
  00118		 |$M45890|

			 ENDP  ; |PrepareDmaTransferOnDriverBuffer|

	EXPORT	|PrepareDmaTransfer|
	IMPORT	|CacheRangeFlush|
	IMPORT	|LockPages|
	IMPORT	|LocalReAlloc|
	IMPORT	|LocalAlloc|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T45916| DCD	|$LN20@PrepareDma@2|
	DCD	0x40005b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PrepareDmaTransfer| PROC

; 1970 : {

  00000		 |$LN20@PrepareDma@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M45913|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 1971 :     DWORD dwTransferLength;
; 1972 :     DWORD dwMaximumPages;
; 1973 :     BOOL fRetVal = TRUE;
; 1974 : 
; 1975 :     dwTransferLength = pRequest->BlockSize * pRequest->NumBlocks;

  0000c	e596e040	 ldr         lr, [r6, #0x40]
  00010	e596303c	 ldr         r3, [r6, #0x3C]

; 1976 :     pController->fDMAUsingDriverBuffer = FALSE;
; 1977 : 
; 1978 :     pController->dwClientBufferSize = 0;
; 1979 :     pController->pClientBuffer = NULL;
; 1980 : 
; 1981 :     if( pController->dwDmaChannel == 0xffffffff )

  00014	e5942aa4	 ldr         r2, [r4, #0xAA4]
  00018	e3a09000	 mov         r9, #0
  0001c	e008039e	 mul         r8, lr, r3
  00020	e3720001	 cmn         r2, #1
  00024	e3a05001	 mov         r5, #1
  00028	e5849aac	 str         r9, [r4, #0xAAC]
  0002c	e5849ab4	 str         r9, [r4, #0xAB4]
  00030	e5849ab8	 str         r9, [r4, #0xAB8]
  00034	1a000001	 bne         |$LN10@PrepareDma@2|
  00038		 |$LN17@PrepareDma@2|

; 1982 :     { // DMA is disabled in registry
; 1983 :         return FALSE;

  00038	e3a05000	 mov         r5, #0
  0003c	ea000047	 b           |$LN11@PrepareDma@2|
  00040		 |$LN10@PrepareDma@2|

; 1984 :     }
; 1985 : 
; 1986 :     if( 0 != dwTransferLength % MMC_TXFIFO_SIZE )

  00040	e318001f	 tst         r8, #0x1F

; 1987 :     {
; 1988 :         return FALSE; // data size not a multiple of FIFO size

  00044	1afffffb	 bne         |$LN17@PrepareDma@2|

; 1989 :     }
; 1990 :     
; 1991 :     if( ( 0 != (((DWORD)pRequest->pBlockBuffer) % SDIO_DMA_ALIGNMENT )) &&
; 1992 :         ( dwTransferLength > pController->dwDmaBufferSize ) )

  00048	e596e048	 ldr         lr, [r6, #0x48]
  0004c	e21e201f	 ands        r2, lr, #0x1F
  00050	0a000002	 beq         |$LN8@PrepareDma@2|
  00054	e5943088	 ldr         r3, [r4, #0x88]
  00058	e1580003	 cmp         r8, r3

; 1993 :     {
; 1994 :         return FALSE; // buffer is not 32 bytes aligned, and is too large to fit in driver's allocated buffer

  0005c	8afffff5	 bhi         |$LN17@PrepareDma@2|
  00060		 |$LN8@PrepareDma@2|

; 1995 :     }
; 1996 : 
; 1997 :     if( 0 != ((DWORD)pRequest->pBlockBuffer) % SDIO_DMA_ALIGNMENT )

  00060	e3520000	 cmp         r2, #0
  00064	0a000004	 beq         |$LN7@PrepareDma@2|

; 1998 :     {
; 1999 :         // buffer is not 32 bytes aligned, we will use driver allocated DMA buffer
; 2000 :         return PrepareDmaTransferOnDriverBuffer( pController, pRequest );

  00068	e1a01006	 mov         r1, r6
  0006c	e1a00004	 mov         r0, r4
  00070	eb000000	 bl          PrepareDmaTransferOnDriverBuffer
  00074	e1a05000	 mov         r5, r0
  00078	ea000038	 b           |$LN11@PrepareDma@2|
  0007c		 |$LN7@PrepareDma@2|

; 2001 :     }
; 2002 : 
; 2003 :     // buffer is 32 bytes aligned.  We will do DMA on client provided buffer
; 2004 : 
; 2005 :     // calculate the number of physical pages that the buffer occupies
; 2006 :     dwMaximumPages = COMPUTE_PAGES_SPANNED(pRequest->pBlockBuffer, dwTransferLength);

  0007c	e3e03b0d	 mvn         r3, #0xD, 22
  00080	e22320fb	 eor         r2, r3, #0xFB
  00084	e5923000	 ldr         r3, [r2]
  00088	e5922000	 ldr         r2, [r2]

; 2007 :     
; 2008 :     if( pController->pPFNs == NULL )

  0008c	e5941abc	 ldr         r1, [r4, #0xABC]
  00090	e3530a01	 cmp         r3, #1, 20
  00094	e2423001	 sub         r3, r2, #1
  00098	e003300e	 and         r3, r3, lr
  0009c	e0833002	 add         r3, r3, r2
  000a0	e0833008	 add         r3, r3, r8
  000a4	03a0000c	 moveq       r0, #0xC
  000a8	e2433001	 sub         r3, r3, #1
  000ac	13a0000a	 movne       r0, #0xA
  000b0	e1a07033	 mov         r7, r3, lsr r0
  000b4	e1b00001	 movs        r0, r1
  000b8	1a000007	 bne         |$LN6@PrepareDma@2|

; 2009 :     {
; 2010 :         // allocate a buffer for PFNs
; 2011 :         pController->pPFNs = (PDWORD)LocalAlloc(0, dwMaximumPages * sizeof(DWORD) );

  000bc	e1a01107	 mov         r1, r7, lsl #2
  000c0	e3a00000	 mov         r0, #0
  000c4	eb000000	 bl          LocalAlloc
  000c8	e3500000	 cmp         r0, #0
  000cc	e5840abc	 str         r0, [r4, #0xABC]

; 2012 :         if( pController->pPFNs == NULL )

  000d0	1a00000a	 bne         |$LN5@PrepareDma@2|

; 1982 :     { // DMA is disabled in registry
; 1983 :         return FALSE;

  000d4	e3a05000	 mov         r5, #0
  000d8	ea000020	 b           |$LN11@PrepareDma@2|
  000dc		 |$LN6@PrepareDma@2|

; 2013 :         {
; 2014 :             return FALSE;
; 2015 :         }
; 2016 :         pController->nPFNCount = dwMaximumPages;
; 2017 :     }
; 2018 :     else if( dwMaximumPages > pController->nPFNCount )

  000dc	e5943ac0	 ldr         r3, [r4, #0xAC0]
  000e0	e1570003	 cmp         r7, r3
  000e4	9a000006	 bls         |$LN3@PrepareDma@2|

; 2019 :     {
; 2020 :         // increase the buffer for PFNs
; 2021 :         HLOCAL hTemp = LocalReAlloc( pController->pPFNs, dwMaximumPages * sizeof(DWORD), LMEM_MOVEABLE );

  000e8	e3a02002	 mov         r2, #2
  000ec	e1a01107	 mov         r1, r7, lsl #2
  000f0	eb000000	 bl          LocalReAlloc
  000f4	e3500000	 cmp         r0, #0

; 2022 :         if( hTemp == NULL )
; 2023 :         {
; 2024 :             return FALSE;

  000f8	0affffce	 beq         |$LN17@PrepareDma@2|

; 2025 :         }
; 2026 : 
; 2027 :         pController->pPFNs = (PDWORD)hTemp;

  000fc	e5840abc	 str         r0, [r4, #0xABC]
  00100		 |$LN5@PrepareDma@2|

; 2028 :         pController->nPFNCount = dwMaximumPages;

  00100	e5847ac0	 str         r7, [r4, #0xAC0]
  00104		 |$LN3@PrepareDma@2|

; 2029 :     }
; 2030 : 
; 2031 :     // lock the pages containing the client provided buffer
; 2032 :     if( !LockPages( pRequest->pBlockBuffer, dwTransferLength, pController->pPFNs, (TRANSFER_IS_READ(pRequest)) ? LOCKFLAG_READ : LOCKFLAG_WRITE ) )

  00104	e5963010	 ldr         r3, [r6, #0x10]
  00108	e5942abc	 ldr         r2, [r4, #0xABC]
  0010c	e5960048	 ldr         r0, [r6, #0x48]
  00110	e3530000	 cmp         r3, #0
  00114	03a03004	 moveq       r3, #4
  00118	13a03001	 movne       r3, #1
  0011c	e1a01008	 mov         r1, r8
  00120	eb000000	 bl          LockPages
  00124	e3500000	 cmp         r0, #0

; 2033 :     {
; 2034 :         fRetVal = FALSE;
; 2035 :     }
; 2036 :     CacheRangeFlush( pRequest->pBlockBuffer, dwTransferLength, CACHE_SYNC_ALL );

  00128	e5960048	 ldr         r0, [r6, #0x48]
  0012c	e3a0207f	 mov         r2, #0x7F
  00130	e1a01008	 mov         r1, r8
  00134	03a05000	 moveq       r5, #0
  00138	eb000000	 bl          CacheRangeFlush

; 2037 :     
; 2038 :     // set the transfer parameters
; 2039 :     pController->dwPFNIndex = 0;
; 2040 :     pController->dwPageOffset = ((DWORD)pRequest->pBlockBuffer) % pController->systemInfo.dwPageSize;

  0013c	e5940048	 ldr         r0, [r4, #0x48]
  00140	e5849ac8	 str         r9, [r4, #0xAC8]
  00144	e5961048	 ldr         r1, [r6, #0x48]
  00148	eb000000	 bl          __rt_udiv
  0014c	e5841ac4	 str         r1, [r4, #0xAC4]

; 2041 :     pController->dwBytesRemaining = dwTransferLength;

  00150	e5848acc	 str         r8, [r4, #0xACC]

; 2042 : 
; 2043 :     pController->dwClientBufferSize = dwTransferLength;

  00154	e5848ab4	 str         r8, [r4, #0xAB4]

; 2044 :     pController->pClientBuffer = pRequest->pBlockBuffer;

  00158	e5963048	 ldr         r3, [r6, #0x48]
  0015c	e5843ab8	 str         r3, [r4, #0xAB8]

; 2045 : 
; 2046 :     return fRetVal;

  00160		 |$LN11@PrepareDma@2|

; 2047 : }

  00160	e1a00005	 mov         r0, r5
  00164	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$M45914|

			 ENDP  ; |PrepareDmaTransfer|

	EXPORT	|DoDMATransferOnDriverBuffer|

  00000			 AREA	 |.pdata|, PDATA
|$T45925| DCD	|$LN7@DoDMATrans|
	DCD	0x40001f00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DoDMATransferOnDriverBuffer| PROC

; 2050 : {

  00000		 |$LN7@DoDMATrans|
  00000		 |$M45922|

; 2051 :     if (TRANSFER_IS_READ(pRequest)){

  00000	e5913010	 ldr         r3, [r1, #0x10]

; 2052 :         pController->pDMARegisters->drcmr[DMA_CHMAP_SDIO_TX] = 0;

  00004	e3a01000	 mov         r1, #0
  00008	e3530000	 cmp         r3, #0
  0000c	e590300c	 ldr         r3, [r0, #0xC]
  00010	05831158	 streq       r1, [r3, #0x158]

; 2053 :         pController->pDMARegisters->drcmr[DMA_CHMAP_SDIO_RX] = DMA_MAP_VALID_MASK | pController->dwDmaChannel;

  00014	05903aa4	 ldreq       r3, [r0, #0xAA4]
  00018	0590200c	 ldreq       r2, [r0, #0xC]
  0001c	03833080	 orreq       r3, r3, #0x80
  00020	05823154	 streq       r3, [r2, #0x154]

; 2054 :     } else {
; 2055 :         pController->pDMARegisters->drcmr[DMA_CHMAP_SDIO_RX] = 0;

  00024	15831154	 strne       r1, [r3, #0x154]

; 2056 :         pController->pDMARegisters->drcmr[DMA_CHMAP_SDIO_TX] = DMA_MAP_VALID_MASK | pController->dwDmaChannel;

  00028	15903aa4	 ldrne       r3, [r0, #0xAA4]
  0002c	1590200c	 ldrne       r2, [r0, #0xC]
  00030	13833080	 orrne       r3, r3, #0x80
  00034	15823158	 strne       r3, [r2, #0x158]

; 2057 :     } 
; 2058 : 
; 2059 :     // Set the DESCRIPTOR FETCH mode
; 2060 :     pController->pDMARegisters->dcsr[pController->dwDmaChannel] =  0;

  00038	e5902aa4	 ldr         r2, [r0, #0xAA4]
  0003c	e590300c	 ldr         r3, [r0, #0xC]
  00040	e0833102	 add         r3, r3, r2, lsl #2
  00044	e5831000	 str         r1, [r3]

; 2061 : 
; 2062 :     // program the transfer descriptor
; 2063 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].ddadr = pController->pDMADescriptorsPhys.LowPart;

  00048	e5903aa4	 ldr         r3, [r0, #0xAA4]
  0004c	e590200c	 ldr         r2, [r0, #0xC]
  00050	e5901080	 ldr         r1, [r0, #0x80]
  00054	e2833020	 add         r3, r3, #0x20
  00058	e0823203	 add         r3, r2, r3, lsl #4
  0005c	e5831000	 str         r1, [r3]

; 2064 : 
; 2065 : #ifdef DEBUG
; 2066 :     pController->fDMATransferInProgress = TRUE;
; 2067 : #endif
; 2068 : 
; 2069 :     pController->pDMARegisters->dcsr[pController->dwDmaChannel] |=  DCSR_RUN | DCSR_STOPIRQEN;          // set the RUN bit

  00060	e5902aa4	 ldr         r2, [r0, #0xAA4]
  00064	e590300c	 ldr         r3, [r0, #0xC]
  00068	e0832102	 add         r2, r3, r2, lsl #2
  0006c	e5923000	 ldr         r3, [r2]
  00070	e383320a	 orr         r3, r3, #0xA, 4
  00074	e5823000	 str         r3, [r2]

; 2070 : }

  00078	e12fff1e	 bx          lr
  0007c		 |$M45923|

			 ENDP  ; |DoDMATransferOnDriverBuffer|

	EXPORT	|DoDMATransferRead|

  00000			 AREA	 |.pdata|, PDATA
|$T45935| DCD	|$LN6@DoDMATrans@2|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DoDMATransferRead| PROC

; 2073 : {

  00000		 |$LN6@DoDMATrans@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M45932|
  00004	e1a07000	 mov         r7, r0

; 2074 :     DWORD dwTransferLength;
; 2075 :     DWORD dwTargetAddress;
; 2076 : 
; 2077 :     ASSERT( MAXIMUM_DMA_TRANSFER_SIZE >= pController->systemInfo.dwPageSize );
; 2078 : 
; 2079 :     // calculate how much data should be read in this DMA transfer
; 2080 :     dwTransferLength = pController->systemInfo.dwPageSize - pController->dwPageOffset;

  00008	e5979ac4	 ldr         r9, [r7, #0xAC4]
  0000c	e5973048	 ldr         r3, [r7, #0x48]

; 2081 :     if( dwTransferLength > pController->dwBytesRemaining )

  00010	e5972acc	 ldr         r2, [r7, #0xACC]

; 2082 :     {
; 2083 :         dwTransferLength = pController->dwBytesRemaining;
; 2084 :     }
; 2085 : 
; 2086 :     // calculate the target physical address
; 2087 :     dwTargetAddress = ( pController->pPFNs[pController->dwPFNIndex] << UserKInfo[KINX_PFN_SHIFT] ) + pController->dwPageOffset;
; 2088 : 
; 2089 :     // Set the NO DESCRIPTOR FETCH mode
; 2090 :     pController->pDMARegisters->dcsr[pController->dwDmaChannel] =  DCSR_NOFETCH;// | DCSR_ENDINTR;

  00014	e597eaa4	 ldr         lr, [r7, #0xAA4]
  00018	e0438009	 sub         r8, r3, r9
  0001c	e1580002	 cmp         r8, r2
  00020	81a08002	 movhi       r8, r2
  00024	e597200c	 ldr         r2, [r7, #0xC]
  00028	e5974ac8	 ldr         r4, [r7, #0xAC8]
  0002c	e5971abc	 ldr         r1, [r7, #0xABC]
  00030	e3e03b0d	 mvn         r3, #0xD, 22
  00034	e22330f7	 eor         r3, r3, #0xF7
  00038	e7916104	 ldr         r6, [r1, +r4, lsl #2]
  0003c	e5935000	 ldr         r5, [r3]
  00040	e082210e	 add         r2, r2, lr, lsl #2
  00044	e3a00101	 mov         r0, #1, 2
  00048	e5820000	 str         r0, [r2]

; 2091 : 
; 2092 :     pController->dwPFNIndex++;
; 2093 :     pController->dwPageOffset = 0;
; 2094 :     pController->dwBytesRemaining -= dwTransferLength;
; 2095 : 
; 2096 :     // program the source, target and transfer parameters
; 2097 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].dsadr = SDIO_RX_FIFO;

  0004c	e5972aa4	 ldr         r2, [r7, #0xAA4]
  00050	e597300c	 ldr         r3, [r7, #0xC]
  00054	e5971ac8	 ldr         r1, [r7, #0xAC8]
  00058	e5970acc	 ldr         r0, [r7, #0xACC]
  0005c	e59fe07c	 ldr         lr, [pc, #0x7C]
  00060	e0834202	 add         r4, r3, r2, lsl #4
  00064	e2813001	 add         r3, r1, #1
  00068	e3a01000	 mov         r1, #0
  0006c	e0402008	 sub         r2, r0, r8
  00070	e5871ac4	 str         r1, [r7, #0xAC4]
  00074	e5873ac8	 str         r3, [r7, #0xAC8]
  00078	e5872acc	 str         r2, [r7, #0xACC]
  0007c	e584e204	 str         lr, [r4, #0x204]

; 2098 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].dtadr = dwTargetAddress;

  00080	e5972aa4	 ldr         r2, [r7, #0xAA4]
  00084	e597300c	 ldr         r3, [r7, #0xC]
  00088	e0891516	 add         r1, r9, r6, lsl r5
  0008c	e3a0e206	 mov         lr, #6, 4
  00090	e0833202	 add         r3, r3, r2, lsl #4
  00094	e5831208	 str         r1, [r3, #0x208]

; 2099 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].dcmd = DCMD_INC_TRG_ADDR |
; 2100 :                                                                        DCMD_FLOW_SRC | 
; 2101 :                                                                        //DCMD_END_IRQ_EN |
; 2102 :                                                                        ( 3 << 16 ) | // 32 bytes maximum burst size of each data transfer
; 2103 :                                                                        ( 3 << 14 ) | // 4 bytes width
; 2104 :                                                                        dwTransferLength;

  00098	e5970aa4	 ldr         r0, [r7, #0xAA4]
  0009c	e597200c	 ldr         r2, [r7, #0xC]
  000a0	e38e390f	 orr         r3, lr, #0xF, 18
  000a4	e1881003	 orr         r1, r8, r3
  000a8	e0823200	 add         r3, r2, r0, lsl #4
  000ac	e583120c	 str         r1, [r3, #0x20C]

; 2105 : 
; 2106 : #ifdef DEBUG
; 2107 :     pController->fDMATransferInProgress = TRUE;
; 2108 : #endif
; 2109 : 
; 2110 :     pController->pDMARegisters->drcmr[DMA_CHMAP_SDIO_RX] = DMA_MAP_VALID_MASK | pController->dwDmaChannel;

  000b0	e5973aa4	 ldr         r3, [r7, #0xAA4]
  000b4	e597200c	 ldr         r2, [r7, #0xC]
  000b8	e3833080	 orr         r3, r3, #0x80
  000bc	e5823154	 str         r3, [r2, #0x154]

; 2111 :     pController->pDMARegisters->dcsr[pController->dwDmaChannel] |=  DCSR_RUN | DCSR_STOPIRQEN;          // set the RUN bit

  000c0	e5972aa4	 ldr         r2, [r7, #0xAA4]
  000c4	e597300c	 ldr         r3, [r7, #0xC]
  000c8	e0832102	 add         r2, r3, r2, lsl #2
  000cc	e5923000	 ldr         r3, [r2]
  000d0	e383320a	 orr         r3, r3, #0xA, 4
  000d4	e5823000	 str         r3, [r2]

; 2112 : }

  000d8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN7@DoDMATrans@2|
  000e0		 |$LN8@DoDMATrans@2|
  000e0	41100040	 DCD         0x41100040
  000e4		 |$M45933|

			 ENDP  ; |DoDMATransferRead|

	EXPORT	|DoDMATransferWrite|

  00000			 AREA	 |.pdata|, PDATA
|$T45947| DCD	|$LN6@DoDMATrans@3|
	DCD	0x40003901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DoDMATransferWrite| PROC

; 2115 : {

  00000		 |$LN6@DoDMATrans@3|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M45944|
  00004	e1a06000	 mov         r6, r0

; 2116 :     DWORD dwTransferLength;
; 2117 :     DWORD dwSourceAddress;
; 2118 : 
; 2119 :     ASSERT( MAXIMUM_DMA_TRANSFER_SIZE >= pController->systemInfo.dwPageSize );
; 2120 : 
; 2121 :     // calculate how much data should be written in this DMA transfer
; 2122 :     dwTransferLength = pController->systemInfo.dwPageSize - pController->dwPageOffset;

  00008	e5968ac4	 ldr         r8, [r6, #0xAC4]
  0000c	e5963048	 ldr         r3, [r6, #0x48]

; 2123 :     if( dwTransferLength > pController->dwBytesRemaining )

  00010	e5962acc	 ldr         r2, [r6, #0xACC]

; 2124 :     {
; 2125 :         dwTransferLength = pController->dwBytesRemaining;
; 2126 :     }
; 2127 : 
; 2128 :     // calculate the target physical address
; 2129 :     dwSourceAddress = ( pController->pPFNs[pController->dwPFNIndex] << UserKInfo[KINX_PFN_SHIFT] ) + pController->dwPageOffset;
; 2130 : 
; 2131 :     // Set the NO DESCRIPTOR FETCH mode
; 2132 :     pController->pDMARegisters->dcsr[pController->dwDmaChannel] =  DCSR_NOFETCH; // | DCSR_ENDINTR;

  00014	e596eaa4	 ldr         lr, [r6, #0xAA4]
  00018	e0437008	 sub         r7, r3, r8
  0001c	e1570002	 cmp         r7, r2
  00020	81a07002	 movhi       r7, r2
  00024	e596200c	 ldr         r2, [r6, #0xC]
  00028	e5964ac8	 ldr         r4, [r6, #0xAC8]
  0002c	e5961abc	 ldr         r1, [r6, #0xABC]
  00030	e3e03b0d	 mvn         r3, #0xD, 22
  00034	e22330f7	 eor         r3, r3, #0xF7
  00038	e7914104	 ldr         r4, [r1, +r4, lsl #2]
  0003c	e082210e	 add         r2, r2, lr, lsl #2
  00040	e593e000	 ldr         lr, [r3]
  00044	e3a00101	 mov         r0, #1, 2
  00048	e5820000	 str         r0, [r2]

; 2133 : 
; 2134 :     pController->dwPFNIndex++;
; 2135 :     pController->dwPageOffset = 0;
; 2136 :     pController->dwBytesRemaining -= dwTransferLength;
; 2137 : 
; 2138 :     // program the source, target and transfer parameters
; 2139 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].dsadr = dwSourceAddress;

  0004c	e5962aa4	 ldr         r2, [r6, #0xAA4]
  00050	e596300c	 ldr         r3, [r6, #0xC]
  00054	e5961ac8	 ldr         r1, [r6, #0xAC8]
  00058	e5960acc	 ldr         r0, [r6, #0xACC]
  0005c	e0835202	 add         r5, r3, r2, lsl #4
  00060	e2813001	 add         r3, r1, #1
  00064	e3a01000	 mov         r1, #0
  00068	e088ee14	 add         lr, r8, r4, lsl lr
  0006c	e0402007	 sub         r2, r0, r7
  00070	e5861ac4	 str         r1, [r6, #0xAC4]
  00074	e5863ac8	 str         r3, [r6, #0xAC8]
  00078	e5862acc	 str         r2, [r6, #0xACC]
  0007c	e585e204	 str         lr, [r5, #0x204]

; 2140 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].dtadr = SDIO_TX_FIFO;

  00080	e5962aa4	 ldr         r2, [r6, #0xAA4]
  00084	e596300c	 ldr         r3, [r6, #0xC]
  00088	e59f1050	 ldr         r1, [pc, #0x50]
  0008c	e3a0e209	 mov         lr, #9, 4
  00090	e0833202	 add         r3, r3, r2, lsl #4
  00094	e5831208	 str         r1, [r3, #0x208]

; 2141 :     pController->pDMARegisters->ddg[pController->dwDmaChannel].dcmd = DCMD_INC_SRC_ADDR |
; 2142 :                                                                        DCMD_FLOW_TRG | 
; 2143 :                                                                        //DCMD_END_IRQ_EN |
; 2144 :                                                                        ( 3 << 16 ) | // 32 bytes maximum burst size of each data transfer
; 2145 :                                                                        ( 3 << 14 ) | // 1 byte width
; 2146 :                                                                        dwTransferLength;

  00098	e5960aa4	 ldr         r0, [r6, #0xAA4]
  0009c	e596200c	 ldr         r2, [r6, #0xC]
  000a0	e38e390f	 orr         r3, lr, #0xF, 18
  000a4	e1871003	 orr         r1, r7, r3
  000a8	e0823200	 add         r3, r2, r0, lsl #4
  000ac	e583120c	 str         r1, [r3, #0x20C]

; 2147 : 
; 2148 : #ifdef DEBUG
; 2149 :     pController->fDMATransferInProgress = TRUE;
; 2150 : #endif
; 2151 : 
; 2152 :     pController->pDMARegisters->drcmr[DMA_CHMAP_SDIO_TX] = DMA_MAP_VALID_MASK | pController->dwDmaChannel;

  000b0	e5963aa4	 ldr         r3, [r6, #0xAA4]
  000b4	e596200c	 ldr         r2, [r6, #0xC]
  000b8	e3833080	 orr         r3, r3, #0x80
  000bc	e5823158	 str         r3, [r2, #0x158]

; 2153 :     pController->pDMARegisters->dcsr[pController->dwDmaChannel] |=  DCSR_RUN | DCSR_STOPIRQEN;          // set the RUN bit

  000c0	e5962aa4	 ldr         r2, [r6, #0xAA4]
  000c4	e596300c	 ldr         r3, [r6, #0xC]
  000c8	e0832102	 add         r2, r3, r2, lsl #2
  000cc	e5923000	 ldr         r3, [r2]
  000d0	e383320a	 orr         r3, r3, #0xA, 4
  000d4	e5823000	 str         r3, [r2]

; 2154 : }

  000d8	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000dc	e12fff1e	 bx          lr
  000e0		 |$LN7@DoDMATrans@3|
  000e0		 |$LN8@DoDMATrans@3|
  000e0	41100044	 DCD         0x41100044
  000e4		 |$M45945|

			 ENDP  ; |DoDMATransferWrite|

	EXPORT	|HandleDMAInterrupt|
	IMPORT	|IsCardPresent|
	IMPORT	|UnlockPages|

  00000			 AREA	 |.pdata|, PDATA
|$T46108| DCD	|$LN74@HandleDMAI|
	DCD	0x40007a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HandleDMAInterrupt| PROC

; 2164 : {

  00000		 |$LN74@HandleDMAI|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M46105|
  00004	e1a04000	 mov         r4, r0

; 2165 :     DWORD DCSR;
; 2166 :     PSD_BUS_REQUEST     pRequest;       // the request to complete
; 2167 : 
; 2168 :     // abort if we are trying to stop the DMA transfer from the ProcessCardRemoval routine
; 2169 :     if( pController->fDMATransferCancelled )

  00008	e5943ab0	 ldr         r3, [r4, #0xAB0]
  0000c	e3530000	 cmp         r3, #0
  00010	1a000072	 bne         |$LN1@HandleDMAI|

; 2170 :         return;
; 2171 : 
; 2172 :         // get the current request  
; 2173 :     pRequest = pController->pCurrentRequest;

  00014	e594301c	 ldr         r3, [r4, #0x1C]

; 2174 : 
; 2175 :     if(NULL == pRequest)
; 2176 :     {
; 2177 :         pController->pDMARegisters->dcsr[pController->dwDmaChannel] = DCSR_NOFETCH;// | DCSR_ENDINTR;

  00018	e5942aa4	 ldr         r2, [r4, #0xAA4]
  0001c	e1b05003	 movs        r5, r3
  00020	e594300c	 ldr         r3, [r4, #0xC]
  00024	03a01101	 moveq       r1, #1, 2
  00028	00833102	 addeq       r3, r3, r2, lsl #2
  0002c	05831000	 streq       r1, [r3]
  00030	0a00005e	 beq         |$LN69@HandleDMAI|

; 2178 :         if( !(pController->fDMAUsingDriverBuffer) )
; 2179 :         { // we use client provided DMA buffer.  Unlock the memory pages where it is located.
; 2180 :             if( pController->pClientBuffer )
; 2181 :             {
; 2182 :                 UnlockPages( pController->pClientBuffer, pController->dwClientBufferSize );
; 2183 :                 pController->pClientBuffer = NULL;
; 2184 :                 pController->dwClientBufferSize = 0;
; 2185 :             }
; 2186 :         }
; 2187 :         return;
; 2188 :     }
; 2189 : 
; 2190 :     ASSERT(pController->fDMATransfer);
; 2191 :     
; 2192 : #ifdef DEBUG
; 2193 :     pController->fDMATransferInProgress = FALSE;
; 2194 : #endif
; 2195 : 
; 2196 :     DCSR = pController->pDMARegisters->dcsr[pController->dwDmaChannel];

  00034	e0832102	 add         r2, r3, r2, lsl #2
  00038	e5923000	 ldr         r3, [r2]

; 2197 : 
; 2198 :     // check for DMA bus errors
; 2199 :     if( DCSR & DCSR_BUSERRINTR )

  0003c	e3130001	 tst         r3, #1
  00040	0a000024	 beq         |$LN20@HandleDMAI|

; 2200 :     {
; 2201 :         ASSERT(0); // DMA Bus error!
; 2202 : 
; 2203 :         DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleDMAInterrupt: DMA BUS ERROR\n")));     
; 2204 :         
; 2205 :         if( !( pController->fClockAlwaysOn || 
; 2206 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00044	e5943d3c	 ldr         r3, [r4, #0xD3C]
  00048	e3530000	 cmp         r3, #0
  0004c	1a00000f	 bne         |$LN41@HandleDMAI|
  00050	e5943d40	 ldr         r3, [r4, #0xD40]
  00054	e3530000	 cmp         r3, #0
  00058	0a000002	 beq         |$LN18@HandleDMAI|
  0005c	e5943d30	 ldr         r3, [r4, #0xD30]
  00060	e3530000	 cmp         r3, #0
  00064	1a000009	 bne         |$LN41@HandleDMAI|
  00068		 |$LN18@HandleDMAI|

; 2207 :         {
; 2208 :                 // turn off the clock
; 2209 :             SDClockOff(pController);

  00068	e5942004	 ldr         r2, [r4, #4]
  0006c	e5923004	 ldr         r3, [r2, #4]
  00070	e3130c01	 tst         r3, #1, 24
  00074	0a000005	 beq         |$LN41@HandleDMAI|
  00078	e3a03001	 mov         r3, #1
  0007c	e5823000	 str         r3, [r2]
  00080	e5942004	 ldr         r2, [r4, #4]
  00084		 |$LL28@HandleDMAI|
  00084	e5923004	 ldr         r3, [r2, #4]
  00088	e3130c01	 tst         r3, #1, 24
  0008c	1afffffc	 bne         |$LL28@HandleDMAI|
  00090		 |$LN41@HandleDMAI|

; 2210 :         }
; 2211 : 
; 2212 :         if( !(pController->fDMAUsingDriverBuffer) )

  00090	e5943aac	 ldr         r3, [r4, #0xAAC]
  00094	e3530000	 cmp         r3, #0
  00098	1a000008	 bne         |$LN16@HandleDMAI|

; 2213 :         { // we use client provided DMA buffer.  Unlock the memory pages where it is located.
; 2214 :             if( pController->pClientBuffer )

  0009c	e5943ab8	 ldr         r3, [r4, #0xAB8]
  000a0	e3530000	 cmp         r3, #0
  000a4	0a000005	 beq         |$LN16@HandleDMAI|

; 2215 :             {
; 2216 :                 UnlockPages( pController->pClientBuffer, pController->dwClientBufferSize );

  000a8	e5941ab4	 ldr         r1, [r4, #0xAB4]
  000ac	e1a00003	 mov         r0, r3
  000b0	eb000000	 bl          UnlockPages

; 2217 :                 pController->pClientBuffer = NULL;

  000b4	e3a03000	 mov         r3, #0
  000b8	e5843ab8	 str         r3, [r4, #0xAB8]

; 2218 :                 pController->dwClientBufferSize = 0;

  000bc	e5843ab4	 str         r3, [r4, #0xAB4]
  000c0		 |$LN16@HandleDMAI|

; 2219 :             }
; 2220 :         }
; 2221 : 
; 2222 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleDMAInterrupt reports DMA BUS ERROR\n")));
; 2223 :         IndicateBusRequestComplete(pController->pHCContext,
; 2224 :                                         pRequest ,
; 2225 :                                         SD_API_STATUS_UNSUCCESSFUL);

  000c0	e3a0210f	 mov         r2, #0xF, 2
  000c4		 |$LN71@HandleDMAI|
  000c4	e5940018	 ldr         r0, [r4, #0x18]
  000c8	e1a01005	 mov         r1, r5
  000cc	eb000000	 bl          IndicateBusRequestComplete

; 2294 :                 }
; 2295 :             }
; 2296 :         }
; 2297 :     }
; 2298 : }

  000d0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN20@HandleDMAI|

; 2226 :         return;
; 2227 :     }
; 2228 : 
; 2229 :     if( DCSR & DCSR_STARTINTR )
; 2230 :     {
; 2231 :         ASSERT( FALSE ); // unexpected
; 2232 :     }
; 2233 : 
; 2234 :     if( DCSR & DCSR_ENDINTR )
; 2235 :     {
; 2236 :         ASSERT( FALSE ); // unexpected
; 2237 :     }
; 2238 : 
; 2239 :     if( DCSR & DCSR_EOR_INTR )
; 2240 :     {
; 2241 :         ASSERT( FALSE ); // unexpected
; 2242 :     }
; 2243 : 
; 2244 :     if( DCSR & DCSR_STOPINTR )

  000d8	e3130008	 tst         r3, #8
  000dc	0a00003f	 beq         |$LN1@HandleDMAI|

; 2245 :     {
; 2246 :         // check if there is more data to transfer
; 2247 :         if( pController->dwBytesRemaining > 0 )

  000e0	e5943acc	 ldr         r3, [r4, #0xACC]
  000e4	e3530000	 cmp         r3, #0
  000e8	9a00002e	 bls         |$LN11@HandleDMAI|

; 2248 :         {
; 2249 :             // if card was ejected
; 2250 :             if( !IsCardPresent() )

  000ec	eb000000	 bl          IsCardPresent
  000f0	e3500000	 cmp         r0, #0
  000f4	1a000020	 bne         |$LN10@HandleDMAI|

; 2251 :             {
; 2252 :                 DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleDMAInterrupt: Card ejected!\n")));     
; 2253 : 
; 2254 :                 if( !( pController->fClockAlwaysOn || 
; 2255 :                        ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  000f8	e5943d3c	 ldr         r3, [r4, #0xD3C]
  000fc	e3530000	 cmp         r3, #0
  00100	1a00000f	 bne         |$LN60@HandleDMAI|
  00104	e5943d40	 ldr         r3, [r4, #0xD40]
  00108	e3530000	 cmp         r3, #0
  0010c	0a000002	 beq         |$LN8@HandleDMAI|
  00110	e5943d30	 ldr         r3, [r4, #0xD30]
  00114	e3530000	 cmp         r3, #0
  00118	1a000009	 bne         |$LN60@HandleDMAI|
  0011c		 |$LN8@HandleDMAI|

; 2256 :                 {
; 2257 :                         // turn off the clock
; 2258 :                     SDClockOff(pController);

  0011c	e5942004	 ldr         r2, [r4, #4]
  00120	e5923004	 ldr         r3, [r2, #4]
  00124	e3130c01	 tst         r3, #1, 24
  00128	0a000005	 beq         |$LN60@HandleDMAI|
  0012c	e3a03001	 mov         r3, #1
  00130	e5823000	 str         r3, [r2]
  00134	e5942004	 ldr         r2, [r4, #4]
  00138		 |$LL47@HandleDMAI|
  00138	e5923004	 ldr         r3, [r2, #4]
  0013c	e3130c01	 tst         r3, #1, 24
  00140	1afffffc	 bne         |$LL47@HandleDMAI|
  00144		 |$LN60@HandleDMAI|

; 2259 :                 }
; 2260 : 
; 2261 :                 if( !(pController->fDMAUsingDriverBuffer) )

  00144	e5943aac	 ldr         r3, [r4, #0xAAC]
  00148	e3530000	 cmp         r3, #0
  0014c	1a000008	 bne         |$LN6@HandleDMAI|

; 2262 :                 { // we use client provided DMA buffer.  Unlock the memory pages where it is located.
; 2263 :                     if( pController->pClientBuffer )

  00150	e5943ab8	 ldr         r3, [r4, #0xAB8]
  00154	e3530000	 cmp         r3, #0
  00158	0a000005	 beq         |$LN6@HandleDMAI|

; 2264 :                     {
; 2265 :                         UnlockPages( pController->pClientBuffer, pController->dwClientBufferSize );

  0015c	e5941ab4	 ldr         r1, [r4, #0xAB4]
  00160	e1a00003	 mov         r0, r3
  00164	eb000000	 bl          UnlockPages

; 2266 :                         pController->pClientBuffer = NULL;

  00168	e3a03000	 mov         r3, #0
  0016c	e5843ab8	 str         r3, [r4, #0xAB8]

; 2267 :                         pController->dwClientBufferSize = 0;

  00170	e5843ab4	 str         r3, [r4, #0xAB4]
  00174		 |$LN6@HandleDMAI|

; 2268 :                     }
; 2269 :                 }
; 2270 : 
; 2271 :                 DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleDMAInterrupt reports Card ejected\n")));
; 2272 :                 IndicateBusRequestComplete(pController->pHCContext,
; 2273 :                                                 pRequest ,
; 2274 :                                                 SD_API_STATUS_DEVICE_REMOVED);

  00174	e3a02147	 mov         r2, #0x47, 2

; 2275 :                 return;

  00178	eaffffd1	 b           |$LN71@HandleDMAI|
  0017c		 |$LN10@HandleDMAI|

; 2276 :             }
; 2277 : 
; 2278 :             if (TRANSFER_IS_READ(pRequest)){

  0017c	e5953010	 ldr         r3, [r5, #0x10]

; 2279 :                 DoDMATransferRead( pController, pRequest );

  00180	e1a01005	 mov         r1, r5
  00184	e1a00004	 mov         r0, r4
  00188	e3530000	 cmp         r3, #0
  0018c	1a000002	 bne         |$LN5@HandleDMAI|
  00190	eb000000	 bl          DoDMATransferRead

; 2294 :                 }
; 2295 :             }
; 2296 :         }
; 2297 :     }
; 2298 : }

  00194	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00198	e12fff1e	 bx          lr
  0019c		 |$LN5@HandleDMAI|

; 2280 :             } else {
; 2281 :                 DoDMATransferWrite( pController, pRequest );

  0019c	eb000000	 bl          DoDMATransferWrite

; 2294 :                 }
; 2295 :             }
; 2296 :         }
; 2297 :     }
; 2298 : }

  001a0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001a4	e12fff1e	 bx          lr
  001a8		 |$LN11@HandleDMAI|

; 2282 :             }
; 2283 :         }
; 2284 :         else
; 2285 :         {
; 2286 :             pController->pDMARegisters->dcsr[pController->dwDmaChannel] = DCSR_NOFETCH;// | DCSR_ENDINTR;

  001a8	e3a03101	 mov         r3, #1, 2
  001ac	e5823000	 str         r3, [r2]
  001b0		 |$LN69@HandleDMAI|

; 2287 :             if( !(pController->fDMAUsingDriverBuffer) )

  001b0	e5943aac	 ldr         r3, [r4, #0xAAC]
  001b4	e3530000	 cmp         r3, #0
  001b8	1a000008	 bne         |$LN1@HandleDMAI|

; 2288 :             { // we use client provided DMA buffer.  Unlock the memory pages where it is located.
; 2289 :                 if( pController->pClientBuffer )

  001bc	e5943ab8	 ldr         r3, [r4, #0xAB8]
  001c0	e3530000	 cmp         r3, #0
  001c4	0a000005	 beq         |$LN1@HandleDMAI|

; 2290 :                 {
; 2291 :                     UnlockPages( pController->pClientBuffer, pController->dwClientBufferSize );

  001c8	e5941ab4	 ldr         r1, [r4, #0xAB4]
  001cc	e1a00003	 mov         r0, r3
  001d0	eb000000	 bl          UnlockPages

; 2292 :                     pController->pClientBuffer = NULL;

  001d4	e3a03000	 mov         r3, #0

; 2293 :                     pController->dwClientBufferSize = 0;

  001d8	e5843ab4	 str         r3, [r4, #0xAB4]
  001dc	e5843ab8	 str         r3, [r4, #0xAB8]
  001e0		 |$LN1@HandleDMAI|

; 2294 :                 }
; 2295 :             }
; 2296 :         }
; 2297 :     }
; 2298 : }

  001e0	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  001e4	e12fff1e	 bx          lr
  001e8		 |$M46106|

			 ENDP  ; |HandleDMAInterrupt|

	EXPORT	|CalculateTransferTimeout|
	IMPORT	|__rt_udiv64by64|

  00000			 AREA	 |.pdata|, PDATA
|$T46124| DCD	|$LN7@CalculateT|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |CalculateTransferTimeout| PROC

; 2309 : {

  00000		 |$LN7@CalculateT|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46121|
  00004	e1a04000	 mov         r4, r0

; 2310 :     unsigned __int64 dwTransferTime;
; 2311 : 
; 2312 :     // get the number of bytes to transfer
; 2313 :     dwTransferTime = pRequest->BlockSize * pRequest->NumBlocks;

  00008	e591e040	 ldr         lr, [r1, #0x40]
  0000c	e591303c	 ldr         r3, [r1, #0x3C]

; 2314 :     
; 2315 :     // now calculate the number of bits to transfer
; 2316 :     if( pController->f4BitMode )

  00010	e5942d38	 ldr         r2, [r4, #0xD38]
  00014	e3a00000	 mov         r0, #0
  00018	e001039e	 mul         r1, lr, r3
  0001c	e3520000	 cmp         r2, #0

; 2317 :     {
; 2318 :         dwTransferTime *= 2;

  00020	11a03080	 movne       r3, r0, lsl #1
  00024	11833fa1	 orrne       r3, r3, r1, lsr #31

; 2319 :     }
; 2320 :     else
; 2321 :     {
; 2322 :         dwTransferTime *= 8;

  00028	01a03180	 moveq       r3, r0, lsl #3
  0002c	11a02081	 movne       r2, r1, lsl #1
  00030	01833ea1	 orreq       r3, r3, r1, lsr #29
  00034	01a02181	 moveq       r2, r1, lsl #3

; 2323 :     }
; 2324 : 
; 2325 :     // increase the transfer time estimate by a factor of 5
; 2326 :     dwTransferTime *= TRANSFER_TIMEOUT_FACTOR; 

  00038	e3a01005	 mov         r1, #5
  0003c	e0810192	 umull       r0, r1, r2, r1

; 2327 :     
; 2328 :     // now calculate how long (in seconds) it will take to transfer
; 2329 :     dwTransferTime /= pController->dwSDClockFrequency;
; 2330 : 
; 2331 :     // add a 10 seconds constant delay
; 2332 :     dwTransferTime += TRANSFER_TIMEOUT_CONSTANT; 
; 2333 : 
; 2334 :     // return the delay in milliseconds
; 2335 :     return (DWORD)(dwTransferTime * 1000);

  00040	e5942d48	 ldr         r2, [r4, #0xD48]
  00044	e0833103	 add         r3, r3, r3, lsl #2
  00048	e0831001	 add         r1, r3, r1
  0004c	e3a03000	 mov         r3, #0
  00050	eb000000	 bl          __rt_udiv64by64
  00054	e280300a	 add         r3, r0, #0xA
  00058	e3a02ffa	 mov         r2, #0xFA, 30

; 2336 : }

  0005c	e0000293	 mul         r0, r3, r2
  00060	e8bd4010	 ldmia       sp!, {r4, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M46122|

			 ENDP  ; |CalculateTransferTimeout|

	EXPORT	|HandleEndCommandInterrupt|

  00000			 AREA	 |.pdata|, PDATA
|$T47091| DCD	|$LN267@HandleEndC|
	DCD	0xc0013004

  00000			 AREA	 |.pdata|, PDATA
|$T47093| DCD	|$LN44@HandleEndC|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T47089| DCD	0x1
	DCD	|$LN48@HandleEndC|
	DCD	|$LN49@HandleEndC|
	DCD	|$LN44@HandleEndC|
	DCD	|$LN45@HandleEndC|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T47089|

  00008		 |HandleEndCommandInterrupt| PROC

; 2345 : {

  00008		 |$LN267@HandleEndC|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5870	 stmdb       sp!, {r4 - r6, r11, r12, lr}
  00010	e28db018	 add         r11, sp, #0x18
  00014	e24dd004	 sub         sp, sp, #4
  00018		 |$LN265@HandleEndC|
  00018	e1a04000	 mov         r4, r0

; 2346 :     DWORD               statRegister;   // status register
; 2347 :     PSD_BUS_REQUEST     pRequest;       // the request to complete
; 2348 :     DWORD               regValue;       // intermediate reg value
; 2349 :     LONG                fifoCount;     // starting offset in response buffer
; 2350 :     PBYTE               pSrcPtr;
; 2351 : 
; 2352 :         // get the current request  
; 2353 :     pRequest = pController->pCurrentRequest;

  0001c	e594301c	 ldr         r3, [r4, #0x1C]
  00020	e1b05003	 movs        r5, r3

; 2358 :     {
; 2359 :         END_CMD_INTERRUPT_OFF(pController);

  00024	e2840ed5	 add         r0, r4, #0xD5, 28

; 2354 : 
; 2355 :         // this should never happen because we mark the request as un-cancelable
; 2356 :     DEBUG_ASSERT(NULL != pRequest);
; 2357 :     if( pRequest == NULL )

  00028	1a000004	 bne         |$LN40@HandleEndC|

; 2358 :     {
; 2359 :         END_CMD_INTERRUPT_OFF(pController);

  0002c	eb000000	 bl          EnterCriticalSection
  00030	e5942004	 ldr         r2, [r4, #4]
  00034	e5923028	 ldr         r3, [r2, #0x28]
  00038	e3833004	 orr         r3, r3, #4

; 2360 :         return;

  0003c	ea0000e2	 b           |$LN263@HandleEndC|
  00040		 |$LN40@HandleEndC|

; 2361 :     }
; 2362 : 
; 2363 :         // get the stat register
; 2364 :     statRegister = READ_MMC_REGISTER_DWORD(pController, MMC_STAT);

  00040	e5943004	 ldr         r3, [r4, #4]

; 2365 : 
; 2366 :         // mask the END_CMD interrupt, the command is complete , however
; 2367 :         // reading the STAT register doesn't clear the interrupt
; 2368 :         // we need to just mask this interrupt out
; 2369 :     END_CMD_INTERRUPT_OFF(pController);

  00044	e5936004	 ldr         r6, [r3, #4]
  00048	eb000000	 bl          EnterCriticalSection
  0004c	e5942004	 ldr         r2, [r4, #4]
  00050	e2840ed5	 add         r0, r4, #0xD5, 28
  00054	e5923028	 ldr         r3, [r2, #0x28]
  00058	e3833004	 orr         r3, r3, #4
  0005c	e5823028	 str         r3, [r2, #0x28]
  00060	eb000000	 bl          LeaveCriticalSection

; 2370 :         // mask the RESPONSE_ERROR interrupt
; 2371 :     PROGRAM_RESPONSE_ERROR_INTERRUPT_OFF(pController);

  00064	e2840ed5	 add         r0, r4, #0xD5, 28
  00068	eb000000	 bl          EnterCriticalSection
  0006c	e5942004	 ldr         r2, [r4, #4]
  00070	e2840ed5	 add         r0, r4, #0xD5, 28
  00074	e5923028	 ldr         r3, [r2, #0x28]
  00078	e3833c02	 orr         r3, r3, #2, 24
  0007c	e5823028	 str         r3, [r2, #0x28]
  00080	eb000000	 bl          LeaveCriticalSection

; 2372 :        
; 2373 :     if (statRegister & MMC_STAT_FLASH_ERROR) {

  00084	e3160c02	 tst         r6, #2, 24
  00088	0a000015	 beq         |$LN39@HandleEndC|

; 2374 :         ASSERT(0);
; 2375 :         regValue = READ_MMC_REGISTER_DWORD(pController, MMC_CMD);

  0008c	e5941004	 ldr         r1, [r4, #4]

; 2376 :         DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("HandleEndCommandInterrupt: response for command %d , FLASH ERROR \n"),regValue));
; 2377 : 
; 2378 :         if( !( pController->fClockAlwaysOn || 
; 2379 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00090	e5942d3c	 ldr         r2, [r4, #0xD3C]
  00094	e5913030	 ldr         r3, [r1, #0x30]
  00098	e3520000	 cmp         r2, #0
  0009c	1a00000e	 bne         |$LN93@HandleEndC|
  000a0	e5943d40	 ldr         r3, [r4, #0xD40]
  000a4	e3530000	 cmp         r3, #0
  000a8	0a000002	 beq         |$LN37@HandleEndC|
  000ac	e5943d30	 ldr         r3, [r4, #0xD30]
  000b0	e3530000	 cmp         r3, #0
  000b4	1a000008	 bne         |$LN93@HandleEndC|
  000b8		 |$LN37@HandleEndC|

; 2380 :         {
; 2381 :                 // turn off the clock
; 2382 :             SDClockOff(pController);

  000b8	e5913004	 ldr         r3, [r1, #4]
  000bc	e3130c01	 tst         r3, #1, 24
  000c0	0a000005	 beq         |$LN93@HandleEndC|
  000c4	e3a03001	 mov         r3, #1
  000c8	e5813000	 str         r3, [r1]
  000cc	e5942004	 ldr         r2, [r4, #4]
  000d0		 |$LL80@HandleEndC|
  000d0	e5923004	 ldr         r3, [r2, #4]
  000d4	e3130c01	 tst         r3, #1, 24
  000d8	1afffffc	 bne         |$LL80@HandleEndC|
  000dc		 |$LN93@HandleEndC|

; 2383 :         }
; 2384 :             // complete the current request with a timeout
; 2385 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt reports FLASH ERROR\n")));
; 2386 :         IndicateBusRequestComplete(pController->pHCContext,
; 2387 :                                         pRequest ,
; 2388 :                                         SD_API_STATUS_UNSUCCESSFUL);

  000dc	e3a0210f	 mov         r2, #0xF, 2

; 2389 :         return;

  000e0	ea00007a	 b           |$LN264@HandleEndC|
  000e4		 |$LN39@HandleEndC|

; 2390 :     }
; 2391 : 
; 2392 :     if (statRegister & MMC_STAT_SPI_WR_ERROR) {
; 2393 :         ASSERT(0);
; 2394 :     }
; 2395 : 
; 2396 :     if (statRegister & MMC_STAT_RD_STALLED) {
; 2397 :         ASSERT(0);
; 2398 :     }
; 2399 : 
; 2400 :     if (statRegister & MMC_STAT_RESPONSE_TIMEOUT) {

  000e4	e3160002	 tst         r6, #2
  000e8	0a000015	 beq         |$LN34@HandleEndC|

; 2401 :         regValue = READ_MMC_REGISTER_DWORD(pController, MMC_CMD);

  000ec	e5941004	 ldr         r1, [r4, #4]

; 2402 :         regValue &= 0x3F;
; 2403 :         DbgPrintZo(SDCARD_ZONE_WARN, (TEXT("HandleEndCommandInterrupt: response for command %d , timed - out \n"),regValue));
; 2404 : 
; 2405 :         if( !( pController->fClockAlwaysOn || 
; 2406 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  000f0	e5942d3c	 ldr         r2, [r4, #0xD3C]
  000f4	e5913030	 ldr         r3, [r1, #0x30]
  000f8	e3520000	 cmp         r2, #0
  000fc	1a00000e	 bne         |$LN114@HandleEndC|
  00100	e5943d40	 ldr         r3, [r4, #0xD40]
  00104	e3530000	 cmp         r3, #0
  00108	0a000002	 beq         |$LN32@HandleEndC|
  0010c	e5943d30	 ldr         r3, [r4, #0xD30]
  00110	e3530000	 cmp         r3, #0
  00114	1a000008	 bne         |$LN114@HandleEndC|
  00118		 |$LN32@HandleEndC|

; 2407 :         {
; 2408 :                 // turn off the clock
; 2409 :             SDClockOff(pController);

  00118	e5913004	 ldr         r3, [r1, #4]
  0011c	e3130c01	 tst         r3, #1, 24
  00120	0a000005	 beq         |$LN114@HandleEndC|
  00124	e3a03001	 mov         r3, #1
  00128	e5813000	 str         r3, [r1]
  0012c	e5942004	 ldr         r2, [r4, #4]
  00130		 |$LL101@HandleEndC|
  00130	e5923004	 ldr         r3, [r2, #4]
  00134	e3130c01	 tst         r3, #1, 24
  00138	1afffffc	 bne         |$LL101@HandleEndC|
  0013c		 |$LN114@HandleEndC|

; 2410 :         }
; 2411 :             // complete the current request with a timeout
; 2412 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt reports RESPONSE TIMEOUT\n")));
; 2413 :         IndicateBusRequestComplete(pController->pHCContext,
; 2414 :                                         pRequest ,
; 2415 :                                         SD_API_STATUS_RESPONSE_TIMEOUT);

  0013c	e3a02153	 mov         r2, #0x53, 2

; 2416 :         return;

  00140	ea000062	 b           |$LN264@HandleEndC|
  00144		 |$LN34@HandleEndC|

; 2417 :     }
; 2418 : 
; 2419 :     if (statRegister & MMC_STAT_RESPONSE_CRC_ERROR)   {

  00144	e3160020	 tst         r6, #0x20
  00148	0a00001f	 beq         |$LN258@HandleEndC|

; 2420 :       // Intel PXA27x has bug calculating CRC for CMD2, CMD9, CMD10.
; 2421 :       // See "Intel(R) PXA27x Family Processor, Specification Update
; 2422 :       // - Revision 001" of April 2004 (order number 280071-001), 
; 2423 :       // Errata "E42" for details.
; 2424 :       // The recommended workaround is to ignore the error.
; 2425 :       // Note: Because the CRC just fails when bit 128 is set, one
; 2426 :       // could ignore the CRC only in instances where that bit was
; 2427 :       // set.  One could also calculate the CRC for the case where
; 2428 :       // bit 128 is set.
; 2429 :       // The developer chose not to spend time implementing these
; 2430 :       // workaround, and took the simple way out.
; 2431 :       // If there are problems with a device, especially during the
; 2432 :       // initial device handshaking, then adding these workarounds
; 2433 :       // would make more sense.
; 2434 :       //
; 2435 :       // Added CMD3 to list of CRC errors to ignore because it also has CRC errors!
; 2436 :       if ((pRequest->CommandCode == SD_CMD_ALL_SEND_CID) ||   // CMD2
; 2437 :          (pRequest->CommandCode == SD_CMD_MMC_SET_RCA) ||   // CMD3
; 2438 :          (pRequest->CommandCode == SD_CMD_SEND_CSD) ||      // CMD9
; 2439 :          (pRequest->CommandCode == SD_CMD_SEND_CID)) {      // CMD10

  0014c	e5d53014	 ldrb        r3, [r5, #0x14]
  00150	e3530002	 cmp         r3, #2
  00154	0a00001b	 beq         |$LN29@HandleEndC|
  00158	e3530003	 cmp         r3, #3
  0015c	0a000019	 beq         |$LN29@HandleEndC|
  00160	e3530009	 cmp         r3, #9
  00164	0a000017	 beq         |$LN29@HandleEndC|
  00168	e353000a	 cmp         r3, #0xA
  0016c	0a000015	 beq         |$LN29@HandleEndC|

; 2444 :          DbgPrintZo(SDCARD_ZONE_ERROR, 
; 2445 :                   (TEXT("HandleEndCommandInterrupt: Ignoring CRC ERROR for CMD%d\n"), pRequest->CommandCode));
; 2446 :       }
; 2447 :       else
; 2448 :       {
; 2449 :             // Report the CRC error and fail.
; 2450 :             regValue = READ_MMC_REGISTER_DWORD(pController, MMC_CMD);

  00170	e5941004	 ldr         r1, [r4, #4]

; 2451 :             regValue &= 0x3F;
; 2452 : 
; 2453 :             if( !( pController->fClockAlwaysOn || 
; 2454 :                    ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00174	e5942d3c	 ldr         r2, [r4, #0xD3C]
  00178	e5913030	 ldr         r3, [r1, #0x30]
  0017c	e3520000	 cmp         r2, #0
  00180	1a00000e	 bne         |$LN135@HandleEndC|
  00184	e5943d40	 ldr         r3, [r4, #0xD40]
  00188	e3530000	 cmp         r3, #0
  0018c	0a000002	 beq         |$LN26@HandleEndC|
  00190	e5943d30	 ldr         r3, [r4, #0xD30]
  00194	e3530000	 cmp         r3, #0
  00198	1a000008	 bne         |$LN135@HandleEndC|
  0019c		 |$LN26@HandleEndC|

; 2455 :             {
; 2456 :                     // turn off the clock
; 2457 :                 SDClockOff(pController);

  0019c	e5913004	 ldr         r3, [r1, #4]
  001a0	e3130c01	 tst         r3, #1, 24
  001a4	0a000005	 beq         |$LN135@HandleEndC|
  001a8	e3a03001	 mov         r3, #1
  001ac	e5813000	 str         r3, [r1]
  001b0	e5942004	 ldr         r2, [r4, #4]
  001b4		 |$LL122@HandleEndC|
  001b4	e5923004	 ldr         r3, [r2, #4]
  001b8	e3130c01	 tst         r3, #1, 24
  001bc	1afffffc	 bne         |$LL122@HandleEndC|
  001c0		 |$LN135@HandleEndC|

; 2458 :             }
; 2459 :             DbgPrintZo(SDCARD_ZONE_ERROR, (TEXT("HandleEndCommandInterrupt: response for command %d , contains a CRC error \n"), regValue));
; 2460 :                 // complete the current request with a CRC error status
; 2461 :             DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt reports CRC ERROR\n")));
; 2462 :             IndicateBusRequestComplete(pController->pHCContext,
; 2463 :                                             pRequest ,
; 2464 :                                             SD_API_STATUS_CRC_ERROR);

  001c0	e3a02137	 mov         r2, #0x37, 2

; 2465 :             return;

  001c4	ea000041	 b           |$LN264@HandleEndC|
  001c8		 |$LN29@HandleEndC|

; 2440 :          // If this is one of the commands that is affected by the
; 2441 :          // errata mentioned above, then clear the status register
; 2442 :          // of this error and continue as if it didn't occur.
; 2443 :          statRegister &= ~MMC_STAT_RESPONSE_CRC_ERROR;

  001c8	e3c66020	 bic         r6, r6, #0x20
  001cc		 |$LN258@HandleEndC|

; 2466 :         }
; 2467 :     }
; 2468 : 
; 2469 :    
; 2470 :     if (NoResponse == pRequest->CommandResponse.ResponseType) {

  001cc	e595301c	 ldr         r3, [r5, #0x1C]
  001d0	e3530000	 cmp         r3, #0

; 2471 :         pSrcPtr = NULL;

  001d4	051b001c	 ldreq       r0, [r11, #-0x1C]
  001d8	03a01000	 moveq       r1, #0

; 2466 :         }
; 2467 :     }
; 2468 : 
; 2469 :    
; 2470 :     if (NoResponse == pRequest->CommandResponse.ResponseType) {

  001dc	0a000004	 beq         |$LN22@HandleEndC|

; 2472 :     } else if (ResponseR2 == pRequest->CommandResponse.ResponseType) {

  001e0	e3530003	 cmp         r3, #3

; 2473 :             // 8 words - 128 bits
; 2474 :         fifoCount = SDH_RESPONSE_FIFO_DEPTH;

  001e4	03a00008	 moveq       r0, #8

; 2475 :         pSrcPtr = pRequest->CommandResponse.ResponseBuffer + sizeof(pRequest->CommandResponse.ResponseBuffer);

  001e8	02851031	 addeq       r1, r5, #0x31

; 2476 :     } else {
; 2477 :         // 3 WORDS - 48 bits
; 2478 :         fifoCount = 3;

  001ec	13a00003	 movne       r0, #3

; 2479 :         pSrcPtr = pRequest->CommandResponse.ResponseBuffer + 3*sizeof(WORD);

  001f0	12851026	 addne       r1, r5, #0x26
  001f4		 |$LN22@HandleEndC|

; 2480 :     }
; 2481 : 
; 2482 :     if (NoResponse != pRequest->CommandResponse.ResponseType && pSrcPtr!=NULL) {

  001f4	e3530000	 cmp         r3, #0
  001f8	0a00000c	 beq         |$LN251@HandleEndC|
  001fc	e3510000	 cmp         r1, #0
  00200	0a00000a	 beq         |$LN251@HandleEndC|

; 2483 :         while (fifoCount--) {

  00204	e3500000	 cmp         r0, #0
  00208	0a000008	 beq         |$LN251@HandleEndC|
  0020c		 |$LL20@HandleEndC|

; 2484 :             union {
; 2485 :                 WORD wDataWord;
; 2486 :                 BYTE bDataByte[2];
; 2487 :             } data;
; 2488 :             data.wDataWord = (USHORT)(READ_MMC_REGISTER_DWORD(pController, MMC_RES));

  0020c	e5943004	 ldr         r3, [r4, #4]
  00210	e2500001	 subs        r0, r0, #1
  00214	e593303c	 ldr         r3, [r3, #0x3C]
  00218	e14b31bc	 strh        r3, [r11, #-0x1C]

; 2489 :             *(--pSrcPtr)=data.bDataByte[1];

  0021c	e55b301b	 ldrb        r3, [r11, #-0x1B]

; 2490 :             *(--pSrcPtr)=data.bDataByte[0];

  00220	e55b201c	 ldrb        r2, [r11, #-0x1C]
  00224	e5613001	 strb        r3, [r1, #-1]!
  00228	e5612001	 strb        r2, [r1, #-1]!
  0022c	1afffff6	 bne         |$LL20@HandleEndC|
  00230		 |$LN251@HandleEndC|

; 2491 :         }
; 2492 :     }
; 2493 : 
; 2494 :         // check for command/response only
; 2495 :     if (SD_COMMAND == pRequest->TransferClass) {

  00230	e5953010	 ldr         r3, [r5, #0x10]
  00234	e3530002	 cmp         r3, #2
  00238	1a000028	 bne         |$LN18@HandleEndC|

; 2496 : 
; 2497 :             // check to see if this request was a response with busy
; 2498 :         if (ResponseR1b == pRequest->CommandResponse.ResponseType) { 

  0023c	e595301c	 ldr         r3, [r5, #0x1C]
  00240	e3530002	 cmp         r3, #2
  00244	1a00000b	 bne         |$LN259@HandleEndC|

; 2499 : 
; 2500 :             while( ( !( statRegister & MMC_STAT_PROGRAM_DONE ) ) &&
; 2501 :                    ( !( pController->DriverShutdown ) ) &&
; 2502 :                    IsCardPresent() )

  00248	e3160a01	 tst         r6, #1, 20
  0024c	1a000009	 bne         |$LN259@HandleEndC|
  00250		 |$LL16@HandleEndC|
  00250	e5943ad0	 ldr         r3, [r4, #0xAD0]
  00254	e3530000	 cmp         r3, #0
  00258	1a000006	 bne         |$LN259@HandleEndC|
  0025c	eb000000	 bl          IsCardPresent
  00260	e3500000	 cmp         r0, #0
  00264	0a000003	 beq         |$LN259@HandleEndC|

; 2503 :             {
; 2504 :                 statRegister = READ_MMC_REGISTER_DWORD(pController, MMC_STAT);

  00268	e5943004	 ldr         r3, [r4, #4]
  0026c	e5933004	 ldr         r3, [r3, #4]
  00270	e3130a01	 tst         r3, #1, 20
  00274	0afffff5	 beq         |$LL16@HandleEndC|
  00278		 |$LN259@HandleEndC|

; 2505 :             }
; 2506 :         }
; 2507 : 
; 2508 :         if( !( pController->fClockAlwaysOn || 
; 2509 :                ( pController->fClockOnIfInterruptsEnabled && pController->fSDIOEnabled ) ) )

  00278	e5943d3c	 ldr         r3, [r4, #0xD3C]
  0027c	e3530000	 cmp         r3, #0
  00280	1a00000f	 bne         |$LN158@HandleEndC|
  00284	e5943d40	 ldr         r3, [r4, #0xD40]
  00288	e3530000	 cmp         r3, #0
  0028c	0a000002	 beq         |$LN13@HandleEndC|
  00290	e5943d30	 ldr         r3, [r4, #0xD30]
  00294	e3530000	 cmp         r3, #0
  00298	1a000009	 bne         |$LN158@HandleEndC|
  0029c		 |$LN13@HandleEndC|

; 2510 :         {
; 2511 :                 // complete the current request here, there's no data phase
; 2512 :                 // turn off the clock
; 2513 :             SDClockOff(pController);

  0029c	e5942004	 ldr         r2, [r4, #4]
  002a0	e5923004	 ldr         r3, [r2, #4]
  002a4	e3130c01	 tst         r3, #1, 24
  002a8	0a000005	 beq         |$LN158@HandleEndC|
  002ac	e3a03001	 mov         r3, #1
  002b0	e5823000	 str         r3, [r2]
  002b4	e5942004	 ldr         r2, [r4, #4]
  002b8		 |$LL145@HandleEndC|
  002b8	e5923004	 ldr         r3, [r2, #4]
  002bc	e3130c01	 tst         r3, #1, 24
  002c0	1afffffc	 bne         |$LL145@HandleEndC|
  002c4		 |$LN158@HandleEndC|

; 2514 :         }
; 2515 : 
; 2516 :         SetCurrentState(pController, CommandComplete);
; 2517 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt reports Bus Request Completed\n")));
; 2518 :         IndicateBusRequestComplete(pController->pHCContext,
; 2519 :                                         pRequest ,
; 2520 :                                         SD_API_STATUS_SUCCESS);    

  002c4	e3a03002	 mov         r3, #2
  002c8	e3a02000	 mov         r2, #0
  002cc	e5843cec	 str         r3, [r4, #0xCEC]
  002d0		 |$LN264@HandleEndC|
  002d0	e1a01005	 mov         r1, r5
  002d4	e5940018	 ldr         r0, [r4, #0x18]
  002d8	eb000000	 bl          IndicateBusRequestComplete

; 2521 :     } else {

  002dc	ea000076	 b           |$LN50@HandleEndC|
  002e0		 |$LN18@HandleEndC|

; 2522 : 
; 2523 :         // set the transfer timeout
; 2524 :         pController->dwControllerIstTimeout = CalculateTransferTimeout(pController, pRequest);

  002e0	e1a01005	 mov         r1, r5
  002e4	e1a00004	 mov         r0, r4
  002e8	eb000000	 bl          CalculateTransferTimeout
  002ec	e584003c	 str         r0, [r4, #0x3C]

; 2525 :         if (TRANSFER_IS_READ(pRequest)){   

  002f0	e5953010	 ldr         r3, [r5, #0x10]
  002f4	e3530000	 cmp         r3, #0

; 2526 :             DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt starting READ TRANSFER of %d blocks of %d bytes\n"), pRequest->NumBlocks, pRequest->BlockSize ));
; 2527 : 
; 2528 :             if( pController->fDMATransfer )

  002f8	e5943aa8	 ldr         r3, [r4, #0xAA8]

; 2531 :                 //RX_FIFO_INTERRUPT_ON(pController);
; 2532 :                 TRANSFER_DONE_INTERRUPT_ON(pController);

  002fc	e2840ed5	 add         r0, r4, #0xD5, 28

; 2525 :         if (TRANSFER_IS_READ(pRequest)){   

  00300	1a000035	 bne         |$LN11@HandleEndC|

; 2526 :             DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt starting READ TRANSFER of %d blocks of %d bytes\n"), pRequest->NumBlocks, pRequest->BlockSize ));
; 2527 : 
; 2528 :             if( pController->fDMATransfer )

  00304	e3530000	 cmp         r3, #0
  00308	0a000019	 beq         |$LN10@HandleEndC|

; 2529 :             {
; 2530 :                 SetCurrentState(pController, ReadDataTransfer);

  0030c	e3a03008	 mov         r3, #8
  00310	e5843cec	 str         r3, [r4, #0xCEC]

; 2531 :                 //RX_FIFO_INTERRUPT_ON(pController);
; 2532 :                 TRANSFER_DONE_INTERRUPT_ON(pController);

  00314	eb000000	 bl          EnterCriticalSection
  00318	e5942004	 ldr         r2, [r4, #4]
  0031c	e2840ed5	 add         r0, r4, #0xD5, 28
  00320	e5923028	 ldr         r3, [r2, #0x28]
  00324	e3c33001	 bic         r3, r3, #1
  00328	e5823028	 str         r3, [r2, #0x28]
  0032c	eb000000	 bl          LeaveCriticalSection

; 2533 :                 PROGRAM_DATA_ERROR_INTERRUPT_ON(pController);

  00330	e2840ed5	 add         r0, r4, #0xD5, 28
  00334	eb000000	 bl          EnterCriticalSection
  00338	e5942004	 ldr         r2, [r4, #4]
  0033c	e2840ed5	 add         r0, r4, #0xD5, 28
  00340	e5923028	 ldr         r3, [r2, #0x28]
  00344	e3c33c01	 bic         r3, r3, #1, 24
  00348	e5823028	 str         r3, [r2, #0x28]
  0034c	eb000000	 bl          LeaveCriticalSection

; 2534 :                 if( pController->fDMAUsingDriverBuffer )

  00350	e5943aac	 ldr         r3, [r4, #0xAAC]
  00354	e3530000	 cmp         r3, #0

; 2535 :                 {
; 2536 :                     DoDMATransferOnDriverBuffer( pController, pRequest );

  00358	e1a01005	 mov         r1, r5
  0035c	e1a00004	 mov         r0, r4

; 2534 :                 if( pController->fDMAUsingDriverBuffer )

  00360	0a000001	 beq         |$LN9@HandleEndC|
  00364		 |$LN262@HandleEndC|

; 2535 :                 {
; 2536 :                     DoDMATransferOnDriverBuffer( pController, pRequest );

  00364	eb000000	 bl          DoDMATransferOnDriverBuffer

; 2537 :                 }
; 2538 :                 else

  00368	ea000053	 b           |$LN50@HandleEndC|
  0036c		 |$LN9@HandleEndC|

; 2539 :                 {
; 2540 :                     DoDMATransferRead( pController, pRequest );

  0036c	eb000000	 bl          DoDMATransferRead

; 2541 :                 }
; 2542 :             }
; 2543 :             else

  00370	ea000051	 b           |$LN50@HandleEndC|
  00374		 |$LN10@HandleEndC|

; 2544 :             {
; 2545 : 
; 2546 :                     // turn on RX Fifo interrupts
; 2547 :                 RX_FIFO_INTERRUPT_ON(pController);

  00374	eb000000	 bl          EnterCriticalSection
  00378	e5942004	 ldr         r2, [r4, #4]
  0037c	e2840ed5	 add         r0, r4, #0xD5, 28
  00380	e5923028	 ldr         r3, [r2, #0x28]
  00384	e3c33020	 bic         r3, r3, #0x20
  00388	e5823028	 str         r3, [r2, #0x28]
  0038c	eb000000	 bl          LeaveCriticalSection

; 2548 :                 SetCurrentState(pController, ReadDataTransfer);

  00390	e3a03008	 mov         r3, #8
  00394	e5843cec	 str         r3, [r4, #0xCEC]

; 2549 :                     // turn on the transfer done interrupt to check for timeout on reads
; 2550 :                     // the receive handler will turn this off after getting the first byte
; 2551 :                 TRANSFER_DONE_INTERRUPT_ON(pController);

  00398	e2840ed5	 add         r0, r4, #0xD5, 28
  0039c	eb000000	 bl          EnterCriticalSection
  003a0	e5942004	 ldr         r2, [r4, #4]
  003a4	e2840ed5	 add         r0, r4, #0xD5, 28
  003a8	e5923028	 ldr         r3, [r2, #0x28]
  003ac	e3c33001	 bic         r3, r3, #1
  003b0	e5823028	 str         r3, [r2, #0x28]
  003b4	eb000000	 bl          LeaveCriticalSection

; 2552 :                 PROGRAM_DATA_ERROR_INTERRUPT_ON(pController);

  003b8	e2840ed5	 add         r0, r4, #0xD5, 28
  003bc	eb000000	 bl          EnterCriticalSection
  003c0	e5942004	 ldr         r2, [r4, #4]
  003c4	e5923028	 ldr         r3, [r2, #0x28]
  003c8	e3c33c01	 bic         r3, r3, #1, 24
  003cc		 |$LN263@HandleEndC|
  003cc	e2840ed5	 add         r0, r4, #0xD5, 28
  003d0	e5823028	 str         r3, [r2, #0x28]
  003d4	eb000000	 bl          LeaveCriticalSection

; 2553 :             }
; 2554 :         } else {

  003d8	ea000037	 b           |$LN50@HandleEndC|
  003dc		 |$LN11@HandleEndC|

; 2555 :             DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("HandleEndCommandInterrupt starting WRITE TRANSFER of %d blocks of %d bytes\n"), pRequest->NumBlocks, pRequest->BlockSize ));
; 2556 :             DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("Bytes wrtn: [%S]\n"), HexDisplay( pRequest->pBlockBuffer, TRANSFER_SIZE(pRequest) )) );
; 2557 :             SetCurrentState(pController, WriteDataTransfer);
; 2558 : 
; 2559 :             if( pController->fDMATransfer )

  003dc	e3a02004	 mov         r2, #4
  003e0	e5842cec	 str         r2, [r4, #0xCEC]
  003e4	e3530000	 cmp         r3, #0
  003e8	0a000015	 beq         |$LN5@HandleEndC|

; 2560 :             {
; 2561 :                 //TX_FIFO_INTERRUPT_ON(pController);
; 2562 :                 TRANSFER_DONE_INTERRUPT_ON(pController);

  003ec	eb000000	 bl          EnterCriticalSection
  003f0	e5942004	 ldr         r2, [r4, #4]
  003f4	e2840ed5	 add         r0, r4, #0xD5, 28
  003f8	e5923028	 ldr         r3, [r2, #0x28]
  003fc	e3c33001	 bic         r3, r3, #1
  00400	e5823028	 str         r3, [r2, #0x28]
  00404	eb000000	 bl          LeaveCriticalSection

; 2563 :                 PROGRAM_DATA_ERROR_INTERRUPT_ON(pController);

  00408	e2840ed5	 add         r0, r4, #0xD5, 28
  0040c	eb000000	 bl          EnterCriticalSection
  00410	e5942004	 ldr         r2, [r4, #4]
  00414	e2840ed5	 add         r0, r4, #0xD5, 28
  00418	e5923028	 ldr         r3, [r2, #0x28]
  0041c	e3c33c01	 bic         r3, r3, #1, 24
  00420	e5823028	 str         r3, [r2, #0x28]
  00424	eb000000	 bl          LeaveCriticalSection

; 2564 :                 if( pController->fDMAUsingDriverBuffer )

  00428	e5943aac	 ldr         r3, [r4, #0xAAC]
  0042c	e3530000	 cmp         r3, #0

; 2565 :                 {
; 2566 :                     DoDMATransferOnDriverBuffer( pController, pRequest );

  00430	e1a01005	 mov         r1, r5
  00434	e1a00004	 mov         r0, r4

; 2567 :                 }
; 2568 :                 else

  00438	1affffc9	 bne         |$LN262@HandleEndC|

; 2569 :                 {
; 2570 :                     DoDMATransferWrite( pController, pRequest );

  0043c	eb000000	 bl          DoDMATransferWrite

; 2571 :                 }
; 2572 :             }
; 2573 :             else

  00440	ea00001d	 b           |$LN50@HandleEndC|
  00444		 |$LN5@HandleEndC|

; 2574 :             {
; 2575 :                     // turn on Fifo interrupts
; 2576 :                 TX_FIFO_INTERRUPT_ON(pController);

  00444	eb000000	 bl          EnterCriticalSection
  00448	e5942004	 ldr         r2, [r4, #4]
  0044c	e2840ed5	 add         r0, r4, #0xD5, 28
  00450	e5923028	 ldr         r3, [r2, #0x28]
  00454	e3c33040	 bic         r3, r3, #0x40
  00458	e5823028	 str         r3, [r2, #0x28]
  0045c	eb000000	 bl          LeaveCriticalSection

; 2577 :                     // turn on transfer interrupts
; 2578 :                 TRANSFER_DONE_INTERRUPT_ON(pController);

  00460	e2840ed5	 add         r0, r4, #0xD5, 28
  00464	eb000000	 bl          EnterCriticalSection
  00468	e5942004	 ldr         r2, [r4, #4]
  0046c	e2840ed5	 add         r0, r4, #0xD5, 28
  00470	e5923028	 ldr         r3, [r2, #0x28]
  00474	e3c33001	 bic         r3, r3, #1
  00478	e5823028	 str         r3, [r2, #0x28]
  0047c	eb000000	 bl          LeaveCriticalSection

; 2579 :                 PROGRAM_DATA_ERROR_INTERRUPT_ON(pController);

  00480	e2840ed5	 add         r0, r4, #0xD5, 28
  00484	eb000000	 bl          EnterCriticalSection
  00488	e5942004	 ldr         r2, [r4, #4]
  0048c	e2840ed5	 add         r0, r4, #0xD5, 28
  00490	e5923028	 ldr         r3, [r2, #0x28]
  00494	e3c33c01	 bic         r3, r3, #1, 24
  00498	e5823028	 str         r3, [r2, #0x28]
  0049c	eb000000	 bl          LeaveCriticalSection
  004a0		 |$LN48@HandleEndC|

; 2580 : 
; 2581 :                 __try {
; 2582 :                     SDLoadXmitFifo(pController, pRequest,pRequest->NumBlocks * pRequest->BlockSize);

  004a0	e595e040	 ldr         lr, [r5, #0x40]
  004a4	e595303c	 ldr         r3, [r5, #0x3C]
  004a8	e1a01005	 mov         r1, r5
  004ac	e1a00004	 mov         r0, r4
  004b0	e002039e	 mul         r2, lr, r3
  004b4	eb000000	 bl          SDLoadXmitFifo
  004b8		 |$LN49@HandleEndC|

; 2583 :                 }

  004b8	eaffffff	 b           |$LN50@HandleEndC|
  004bc		 |$LN45@HandleEndC|
  004bc		 |$LN50@HandleEndC|

; 2585 :                 };
; 2586 :             }
; 2587 :         }
; 2588 :     }
; 2589 : }

  004bc	e24bd018	 sub         sp, r11, #0x18
  004c0	e89d6870	 ldmia       sp, {r4 - r6, r11, sp, lr}
  004c4	e12fff1e	 bx          lr

			 ENDP  ; |HandleEndCommandInterrupt|

  004c8		 |$LN44@HandleEndC|
  004c8		 |$LN266@HandleEndC|

; 2584 :                 __except(EXCEPTION_EXECUTE_HANDLER) {

  004c8	e52de004	 str         lr, [sp, #-4]!
  004cc		 |$LN47@HandleEndC|
  004cc		 |$LN269@HandleEndC|
  004cc	e3a00001	 mov         r0, #1
  004d0		 |$LN46@HandleEndC|
  004d0	e49df004	 ldr         pc, [sp], #4
  004d4		 |$LN270@HandleEndC|
  004d4		 |$LN268@HandleEndC|
	EXPORT	|HandleSDIOInterrupt|

  00000			 AREA	 |.pdata|, PDATA
|$T47149| DCD	|$LN14@HandleSDIO|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HandleSDIOInterrupt| PROC

; 2599 : {

  00000		 |$LN14@HandleSDIO|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47146|
  00004	e1a04000	 mov         r4, r0

; 2600 :     if( IsCardPresent( pHCDevice ) && pHCDevice->DevicePresent ) 

  00008	eb000000	 bl          IsCardPresent
  0000c	e3500000	 cmp         r0, #0
  00010	0a00000e	 beq         |$LN1@HandleSDIO|
  00014	e5943d44	 ldr         r3, [r4, #0xD44]
  00018	e3530000	 cmp         r3, #0
  0001c	0a00000b	 beq         |$LN1@HandleSDIO|

; 2601 :     {
; 2602 :             // disable the SDIO interrupt
; 2603 :         SDIO_INTERRUPT_OFF(pHCDevice);

  00020	e2840ed5	 add         r0, r4, #0xD5, 28
  00024	eb000000	 bl          EnterCriticalSection
  00028	e5942004	 ldr         r2, [r4, #4]
  0002c	e2840ed5	 add         r0, r4, #0xD5, 28
  00030	e5923028	 ldr         r3, [r2, #0x28]
  00034	e3833b02	 orr         r3, r3, #2, 22
  00038	e5823028	 str         r3, [r2, #0x28]
  0003c	eb000000	 bl          LeaveCriticalSection

; 2604 :             // indicate that the card is interrupting
; 2605 :         DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("Got SDIO Interrupt\n")));
; 2606 :         SDHCDIndicateSlotStateChange(pHCDevice->pHCContext, 
; 2607 :                                         0,
; 2608 :                                         DeviceInterrupting);

  00040	e5940018	 ldr         r0, [r4, #0x18]
  00044	e3a02003	 mov         r2, #3
  00048	e3a01000	 mov         r1, #0
  0004c	eb000000	 bl          SDHCDIndicateSlotStateChange
  00050		 |$LN1@HandleSDIO|

; 2609 :     }
; 2610 : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M47147|

			 ENDP  ; |HandleSDIOInterrupt|

	EXPORT	|GetMMCInterrupts|

  00000			 AREA	 |.pdata|, PDATA
|$T47173| DCD	|$LN9@GetMMCInte|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |GetMMCInterrupts| PROC

; 2621 : {

  00000		 |$LN9@GetMMCInte|
  00000		 |$M47170|

; 2622 :     DWORD intr;
; 2623 :     DWORD interrupts;    // current interrupts
; 2624 :     DWORD interruptMask; // interrupt mask
; 2625 : #ifdef DEBUG
; 2626 :     DWORD stat;
; 2627 : #endif
; 2628 : 
; 2629 :         // get interrupts
; 2630 :     intr = READ_MMC_REGISTER_DWORD(pHCDevice, MMC_IREG) 
; 2631 :                  & MMC_IREG_INTERRUPTS;

  00000	e5903004	 ldr         r3, [r0, #4]
  00004	e3a02c1f	 mov         r2, #0x1F, 24

; 2632 : 
; 2633 :     // get the interrupt masks so we know which ones we don't care about
; 2634 :         // the handlers will turn off (mask) interrupts 
; 2635 :     interruptMask = (~(READ_MMC_REGISTER_DWORD(pHCDevice, MMC_IMASK))) 
; 2636 :                     & MMC_IREG_INTERRUPTS;
; 2637 : 
; 2638 :         // mask it
; 2639 :     interrupts = intr & interruptMask;
; 2640 : 
; 2641 : #ifdef DEBUG
; 2642 :     stat = READ_MMC_REGISTER_DWORD(pHCDevice,MMC_STAT);
; 2643 :                                      
; 2644 :     if( pHCDevice->fSDIOEnabled )
; 2645 :     {
; 2646 :         DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2647 :             (TEXT("S=%04X I=%04X M=%04X R=%04X\n"), 
; 2648 :                 stat, intr, interruptMask, interrupts));
; 2649 :     }
; 2650 : #endif
; 2651 : 
; 2652 :     return interrupts;

  00008	e38210ff	 orr         r1, r2, #0xFF
  0000c	e593202c	 ldr         r2, [r3, #0x2C]
  00010	e5933028	 ldr         r3, [r3, #0x28]
  00014	e1c23003	 bic         r3, r2, r3
  00018	e0030001	 and         r0, r3, r1

; 2653 : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M47171|

			 ENDP  ; |GetMMCInterrupts|

	EXPORT	|SDDMAIstThread|
	IMPORT	|InterruptDone|
	IMPORT	|CeSetThreadPriority|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T47191| DCD	|$LN17@SDDMAIstTh|
	DCD	0x40001e01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\sdhc\sdcontrol.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDDMAIstThread| PROC

; 2663 : {

  00000		 |$LN17@SDDMAIstTh|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47188|
  00004	e1a04000	 mov         r4, r0

; 2664 :     DWORD waitStatus;    // wait status
; 2665 : 
; 2666 :     if (!CeSetThreadPriority(GetCurrentThread(), 
; 2667 :         pHCDevice->DmaIstThreadPriority)) {

  00008	e5941a9c	 ldr         r1, [r4, #0xA9C]
  0000c	e3a00041	 mov         r0, #0x41
  00010	eb000000	 bl          CeSetThreadPriority

; 2668 :         DbgPrintZo(SDCARD_ZONE_WARN, 
; 2669 :             (TEXT("SDDMAIstThread: warning, failed to set CEThreadPriority \n")));
; 2670 :     }
; 2671 : 
; 2672 :     while(1) {
; 2673 : 
; 2674 :         waitStatus = WaitForSingleObject(pHCDevice->hDMAInterruptEvent, INFINITE);

  00014	e5940a98	 ldr         r0, [r4, #0xA98]
  00018	e3e01000	 mvn         r1, #0
  0001c	eb000000	 bl          WaitForSingleObject
  00020	e3500000	 cmp         r0, #0

; 2675 : 
; 2676 :         if (WAIT_OBJECT_0 != waitStatus) {

  00024	1a000010	 bne         |$LN12@SDDMAIstTh|
  00028	e2845c0a	 add         r5, r4, #0xA, 24
  0002c		 |$LL4@SDDMAIstTh|

; 2681 :         }
; 2682 : 
; 2683 :         if (pHCDevice->DriverShutdown) {

  0002c	e5943ad0	 ldr         r3, [r4, #0xAD0]
  00030	e3530000	 cmp         r3, #0
  00034	1a00000c	 bne         |$LN12@SDDMAIstTh|

; 2684 :             DbgPrintZo(1, (TEXT("SDDMAIstThread: Thread Exiting\n")));
; 2685 :             return 0;
; 2686 :         }
; 2687 : 
; 2688 :         DbgPrintZo(SDH_INTERRUPT_ZONE, (TEXT("SDDMAIst+++++++++++++ \n")));
; 2689 :         ACQUIRE_LOCK(pHCDevice);

  00038	e28500d4	 add         r0, r5, #0xD4
  0003c	eb000000	 bl          EnterCriticalSection

; 2690 :         HandleDMAInterrupt( pHCDevice );

  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          HandleDMAInterrupt

; 2691 :         RELEASE_LOCK(pHCDevice);

  00048	e28500d4	 add         r0, r5, #0xD4
  0004c	eb000000	 bl          LeaveCriticalSection

; 2692 :         DbgPrintZo(SDH_INTERRUPT_ZONE, (TEXT("SDDMAIst-------------- \n")));
; 2693 :         
; 2694 :         InterruptDone(pHCDevice->dwDmaSysIntr);

  00050	e5940a90	 ldr         r0, [r4, #0xA90]
  00054	eb000000	 bl          InterruptDone
  00058	e5940a98	 ldr         r0, [r4, #0xA98]
  0005c	e3e01000	 mvn         r1, #0
  00060	eb000000	 bl          WaitForSingleObject
  00064	e3500000	 cmp         r0, #0
  00068	0affffef	 beq         |$LL4@SDDMAIstTh|
  0006c		 |$LN12@SDDMAIstTh|

; 2677 :             DbgPrintZo(SDCARD_ZONE_WARN, 
; 2678 :                 (TEXT("SDDMAIstThread: Wait Failed! 0x%08X \n"), waitStatus));
; 2679 :                 // bail out
; 2680 :             return 0;

  0006c	e3a00000	 mov         r0, #0

; 2695 :     }
; 2696 : }

  00070	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00074	e12fff1e	 bx          lr
  00078		 |$M47189|

			 ENDP  ; |SDDMAIstThread|

	EXPORT	|ProcessCardInsertion|
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T47272| DCD	|$LN27@ProcessCar|
	DCD	0x40002302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ProcessCardInsertion| PROC

; 2844 : {

  00000		 |$LN27@ProcessCar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M47269|
  00008	e1a04000	 mov         r4, r0

; 2845 :     DWORD initializationClock = SD_DEFAULT_CARD_ID_CLOCK_RATE;
; 2846 : 
; 2847 :     PSDH_HARDWARE_CONTEXT pHCDevice = (PSDH_HARDWARE_CONTEXT)pContext;
; 2848 :     if (!pHCDevice->DevicePresent) {

  0000c	e5942d44	 ldr         r2, [r4, #0xD44]
  00010	e3a03b61	 mov         r3, #0x61, 22
  00014	e3833e2a	 orr         r3, r3, #0x2A, 28
  00018	e58d3000	 str         r3, [sp]
  0001c	e3520000	 cmp         r2, #0
  00020	1a000016	 bne         |$LN1@ProcessCar|

; 2849 :             // if we have stable insertion and there wasn't a device mark it
; 2850 :         DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2851 :             (TEXT("CardDetectIstThread: Device Fully Inserted ! \n"))); 
; 2852 :             // mark that the card is in the slot
; 2853 :         pHCDevice->DevicePresent = TRUE;

  00024	e3a05001	 mov         r5, #1

; 2854 :     
; 2855 :             // flag that this is the first command sent
; 2856 :         pHCDevice->SendInitClocks = TRUE;
; 2857 : 
; 2858 :             // turn the Multimedia Card power on
; 2859 :         MMCPowerControl( TRUE );

  00028	e3a00001	 mov         r0, #1
  0002c	e5845d44	 str         r5, [r4, #0xD44]
  00030	e5845ae8	 str         r5, [r4, #0xAE8]
  00034	eb000000	 bl          MMCPowerControl

; 2860 : 
; 2861 :             // reset the clock to the ID rate
; 2862 :             // shut off clock first
; 2863 :         SDClockOff(pHCDevice);

  00038	e5942004	 ldr         r2, [r4, #4]
  0003c	e5923004	 ldr         r3, [r2, #4]
  00040	e3130c01	 tst         r3, #1, 24
  00044	0a000004	 beq         |$LN18@ProcessCar|
  00048	e5825000	 str         r5, [r2]
  0004c	e5942004	 ldr         r2, [r4, #4]
  00050		 |$LL5@ProcessCar|
  00050	e5923004	 ldr         r3, [r2, #4]
  00054	e3130c01	 tst         r3, #1, 24
  00058	1afffffc	 bne         |$LL5@ProcessCar|
  0005c		 |$LN18@ProcessCar|

; 2864 :             // set rate
; 2865 :         SDSetRate(pHCDevice, &initializationClock);

  0005c	e28d1000	 add         r1, sp, #0
  00060	e1a00004	 mov         r0, r4
  00064	eb000000	 bl          SDSetRate

; 2866 : 
; 2867 :             // give the card some time for initialization
; 2868 :         Sleep(100);

  00068	e3a00064	 mov         r0, #0x64
  0006c	eb000000	 bl          Sleep

; 2869 : 
; 2870 :             // indicate the slot change
; 2871 :         SDHCDIndicateSlotStateChange(pHCDevice->pHCContext, 
; 2872 :                                         0,
; 2873 :                                         DeviceInserted);

  00070	e5940018	 ldr         r0, [r4, #0x18]
  00074	e3a02002	 mov         r2, #2
  00078	e3a01000	 mov         r1, #0
  0007c	eb000000	 bl          SDHCDIndicateSlotStateChange
  00080		 |$LN1@ProcessCar|

; 2874 :     }
; 2875 : }

  00080	e28dd004	 add         sp, sp, #4
  00084	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M47270|

			 ENDP  ; |ProcessCardInsertion|

	EXPORT	|ProcessCardRemoval|

  00000			 AREA	 |.pdata|, PDATA
|$T47405| DCD	|$LN39@ProcessCar@2|
	DCD	0x40004001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ProcessCardRemoval| PROC

; 2878 : {

  00000		 |$LN39@ProcessCar@2|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47402|
  00004	e1a04000	 mov         r4, r0

; 2879 :     PSDH_HARDWARE_CONTEXT pHCDevice = (PSDH_HARDWARE_CONTEXT)pContext;
; 2880 :     PSD_BUS_REQUEST pRequest;       // current request
; 2881 : 
; 2882 :     if( pHCDevice->DevicePresent )

  00008	e5943d44	 ldr         r3, [r4, #0xD44]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000038	 beq         |$LN5@ProcessCar@2|

; 2883 :     {
; 2884 :         DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2885 :             (TEXT("CardDetectIstThread: Card Removal Detected! \n"))); 
; 2886 :             // mark that the card has been removed
; 2887 :         pHCDevice->DevicePresent = FALSE;
; 2888 : 
; 2889 :         
; 2890 :             // indicate the slot change 
; 2891 :         SDHCDIndicateSlotStateChange(pHCDevice->pHCContext, 
; 2892 :                                         0,
; 2893 :                                         DeviceEjected); 

  00014	e5940018	 ldr         r0, [r4, #0x18]
  00018	e3a06000	 mov         r6, #0
  0001c	e3a02001	 mov         r2, #1
  00020	e3a01000	 mov         r1, #0
  00024	e5846d44	 str         r6, [r4, #0xD44]
  00028	eb000000	 bl          SDHCDIndicateSlotStateChange

; 2894 : 
; 2895 :             // shut off clock first
; 2896 :         SDClockOff(pHCDevice);

  0002c	e5942004	 ldr         r2, [r4, #4]
  00030	e3a07001	 mov         r7, #1
  00034	e5923004	 ldr         r3, [r2, #4]
  00038	e3130c01	 tst         r3, #1, 24
  0003c	0a000004	 beq         |$LN22@ProcessCar@2|
  00040	e5827000	 str         r7, [r2]
  00044	e5942004	 ldr         r2, [r4, #4]
  00048		 |$LL9@ProcessCar@2|
  00048	e5923004	 ldr         r3, [r2, #4]
  0004c	e3130c01	 tst         r3, #1, 24
  00050	1afffffc	 bne         |$LL9@ProcessCar@2|
  00054		 |$LN22@ProcessCar@2|

; 2897 : 
; 2898 :         // Complete any pending request
; 2899 :         if((pRequest = pHCDevice->pCurrentRequest) != NULL)

  00054	e594301c	 ldr         r3, [r4, #0x1C]
  00058	e1b05003	 movs        r5, r3
  0005c	0a000023	 beq         |$LN4@ProcessCar@2|

; 2900 :         {
; 2901 :             ALL_INTERRUPTS_OFF(pHCDevice);

  00060	e2840ed5	 add         r0, r4, #0xD5, 28
  00064	eb000000	 bl          EnterCriticalSection
  00068	e5941004	 ldr         r1, [r4, #4]
  0006c	e3a03c1f	 mov         r3, #0x1F, 24
  00070	e38320ff	 orr         r2, r3, #0xFF
  00074	e5913028	 ldr         r3, [r1, #0x28]
  00078	e2840ed5	 add         r0, r4, #0xD5, 28
  0007c	e1833002	 orr         r3, r3, r2
  00080	e5813028	 str         r3, [r1, #0x28]
  00084	eb000000	 bl          LeaveCriticalSection

; 2902 : 
; 2903 :             // if we were doing a DMA transfer, stop the DMA and reset the interrupt status
; 2904 :             if( pHCDevice->fDMATransfer )

  00088	e5943aa8	 ldr         r3, [r4, #0xAA8]
  0008c	e3530000	 cmp         r3, #0
  00090	0a000012	 beq         |$LN3@ProcessCar@2|

; 2905 :             {
; 2906 :                 pHCDevice->fDMATransferCancelled = TRUE;
; 2907 :                 pHCDevice->pDMARegisters->dcsr[pHCDevice->dwDmaChannel] &=  !(DCSR_RUN | DCSR_STOPIRQEN);

  00094	e5942aa4	 ldr         r2, [r4, #0xAA4]
  00098	e594300c	 ldr         r3, [r4, #0xC]
  0009c	e5847ab0	 str         r7, [r4, #0xAB0]
  000a0	e0833102	 add         r3, r3, r2, lsl #2
  000a4	e5932000	 ldr         r2, [r3]
  000a8	e5836000	 str         r6, [r3]

; 2908 : 
; 2909 :                 if( !(pHCDevice->fDMAUsingDriverBuffer) )

  000ac	e5943aac	 ldr         r3, [r4, #0xAAC]
  000b0	e3530000	 cmp         r3, #0
  000b4	1a000007	 bne         |$LN1@ProcessCar@2|

; 2910 :                 { // we use client provided DMA buffer.  Unlock the memory pages where it is located.
; 2911 :                     if( pHCDevice->pClientBuffer )

  000b8	e5943ab8	 ldr         r3, [r4, #0xAB8]
  000bc	e3530000	 cmp         r3, #0
  000c0	0a000004	 beq         |$LN1@ProcessCar@2|

; 2912 :                     {
; 2913 :                         UnlockPages( pHCDevice->pClientBuffer, pHCDevice->dwClientBufferSize );

  000c4	e5941ab4	 ldr         r1, [r4, #0xAB4]
  000c8	e1a00003	 mov         r0, r3
  000cc	eb000000	 bl          UnlockPages

; 2914 :                         pHCDevice->pClientBuffer = NULL;

  000d0	e5846ab8	 str         r6, [r4, #0xAB8]

; 2915 :                         pHCDevice->dwClientBufferSize = 0;

  000d4	e5846ab4	 str         r6, [r4, #0xAB4]
  000d8		 |$LN1@ProcessCar@2|

; 2916 :                     }
; 2917 :                 }
; 2918 : 
; 2919 :                 #ifdef DEBUG
; 2920 :                     pHCDevice->fDMATransferInProgress = FALSE;
; 2921 :                 #endif
; 2922 : 
; 2923 :                 InterruptDone(pHCDevice->dwDmaSysIntr);

  000d8	e5940a90	 ldr         r0, [r4, #0xA90]
  000dc	eb000000	 bl          InterruptDone
  000e0		 |$LN3@ProcessCar@2|

; 2924 :             }
; 2925 : 
; 2926 :             IndicateBusRequestComplete(pHCDevice->pHCContext,
; 2927 :                                             pRequest ,
; 2928 :                                             SD_API_STATUS_DEVICE_REMOVED);

  000e0	e5940018	 ldr         r0, [r4, #0x18]
  000e4	e3a02147	 mov         r2, #0x47, 2
  000e8	e1a01005	 mov         r1, r5
  000ec	eb000000	 bl          IndicateBusRequestComplete
  000f0		 |$LN4@ProcessCar@2|

; 2929 :         }
; 2930 : 
; 2931 :             // turn the Multimedia Card power off
; 2932 :         MMCPowerControl( FALSE );

  000f0	e3a00000	 mov         r0, #0
  000f4	eb000000	 bl          MMCPowerControl
  000f8		 |$LN5@ProcessCar@2|

; 2933 :     }
; 2934 : }

  000f8	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000fc	e12fff1e	 bx          lr
  00100		 |$M47403|

			 ENDP  ; |ProcessCardRemoval|

	EXPORT	|DriverShutdown|

  00000			 AREA	 |.pdata|, PDATA
|$T47415| DCD	|$LN5@DriverShut|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DriverShutdown| PROC

; 2937 : {

  00000		 |$LN5@DriverShut|
  00000		 |$M47412|

; 2938 :     PSDH_HARDWARE_CONTEXT pHCDevice = (PSDH_HARDWARE_CONTEXT)pContext;
; 2939 :     return pHCDevice->DriverShutdown;

  00000	e5900ad0	 ldr         r0, [r0, #0xAD0]

; 2940 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47413|

			 ENDP  ; |DriverShutdown|

	EXPORT	|SDControllerPowerDown|
	IMPORT	|SDHCDPowerUpDown|

  00000			 AREA	 |.pdata|, PDATA
|$T47496| DCD	|$LN27@SDControll|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDControllerPowerDown| PROC

; 2943 : {

  00000		 |$LN27@SDControll|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47493|
  00004	e1b04000	 movs        r4, r0

; 2944 :     ASSERT( pHCDevice );
; 2945 :     if( !pHCDevice )

  00008	0a000010	 beq         |$LN2@SDControll|

; 2946 :         return;
; 2947 : 
; 2948 :     // Notify the SD Bus driver of the PowerDown event
; 2949 :     SDHCDPowerUpDown(pHCDevice->pHCContext, FALSE, FALSE, 0);

  0000c	e5940018	 ldr         r0, [r4, #0x18]
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01000	 mov         r1, #0
  0001c	eb000000	 bl          SDHCDPowerUpDown

; 2950 : 
; 2951 :     // shut off clock first
; 2952 :     SDClockOff(pHCDevice);

  00020	e5942004	 ldr         r2, [r4, #4]
  00024	e5923004	 ldr         r3, [r2, #4]
  00028	e3130c01	 tst         r3, #1, 24
  0002c	0a000005	 beq         |$LN18@SDControll|
  00030	e3a03001	 mov         r3, #1
  00034	e5823000	 str         r3, [r2]
  00038	e5942004	 ldr         r2, [r4, #4]
  0003c		 |$LL5@SDControll|
  0003c	e5923004	 ldr         r3, [r2, #4]
  00040	e3130c01	 tst         r3, #1, 24
  00044	1afffffc	 bne         |$LL5@SDControll|
  00048		 |$LN18@SDControll|

; 2953 : 
; 2954 :     // turn the Multimedia Card power on
; 2955 :     MMCPowerControl( FALSE );

  00048	e3a00000	 mov         r0, #0
  0004c	eb000000	 bl          MMCPowerControl
  00050		 |$LN2@SDControll|

; 2956 : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M47494|

			 ENDP  ; |SDControllerPowerDown|

	EXPORT	|SDControllerPowerUp|
	IMPORT	|SimulateCardInsertion|

  00000			 AREA	 |.pdata|, PDATA
|$T47504| DCD	|$LN6@SDControll@2|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDControllerPowerUp| PROC

; 2959 : {

  00000		 |$LN6@SDControll@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47501|
  00004	e3500000	 cmp         r0, #0

; 2960 :     ASSERT( pHCDevice );
; 2961 :     if( !pHCDevice )

  00008	0a000005	 beq         |$LN2@SDControll@2|

; 2962 :         return;
; 2963 : 
; 2964 :     // Notify the SD Bus driver of the PowerUp event
; 2965 :     SDHCDPowerUpDown(pHCDevice->pHCContext, TRUE, FALSE, 0);

  0000c	e5900018	 ldr         r0, [r0, #0x18]
  00010	e3a03000	 mov         r3, #0
  00014	e3a02000	 mov         r2, #0
  00018	e3a01001	 mov         r1, #1
  0001c	eb000000	 bl          SDHCDPowerUpDown

; 2966 : 
; 2967 :     // simulate a card ejection/insertion
; 2968 :     SimulateCardInsertion();

  00020	eb000000	 bl          SimulateCardInsertion
  00024		 |$LN2@SDControll@2|

; 2969 : 
; 2970 : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$M47502|

			 ENDP  ; |SDControllerPowerUp|

	EXPORT	|SDBusIssueRequest|

  00000			 AREA	 |.pdata|, PDATA
|$T47769| DCD	|$LN93@SDBusIssue|
	DCD	0x40007401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDBusIssueRequest| PROC

; 936  : {

  00000		 |$LN93@SDBusIssue|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M47766|
  00004	e1a01002	 mov         r1, r2

; 937  : 
; 938  :     BOOL fExtraDelay = FALSE;
; 939  :     PSDH_HARDWARE_CONTEXT    pController;     // our controller
; 940  :     DWORD                      cmdatRegister;   // CMDAT register
; 941  : 
; 942  :         // get our extension 
; 943  :     pController = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);

  00008	e590504c	 ldr         r5, [r0, #0x4C]
  0000c	e3a06000	 mov         r6, #0

; 944  : 
; 945  :     DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("SDBusIssueRequest - pRequest = %x, CMD: 0x%02X DATA: 0x%08X, TC: %d\n"),
; 946  :             pRequest,pRequest->CommandCode, pRequest->CommandArgument, pRequest->TransferClass));
; 947  : 
; 948  : 
; 949  :         // stop the clock
; 950  :     SDClockOff(pController);

  00010	e3a09001	 mov         r9, #1
  00014	e5952004	 ldr         r2, [r5, #4]
  00018	e5923004	 ldr         r3, [r2, #4]
  0001c	e3130c01	 tst         r3, #1, 24
  00020	0a000004	 beq         |$LN33@SDBusIssue|
  00024	e5829000	 str         r9, [r2]
  00028	e5952004	 ldr         r2, [r5, #4]
  0002c		 |$LL20@SDBusIssue|
  0002c	e5923004	 ldr         r3, [r2, #4]
  00030	e3130c01	 tst         r3, #1, 24
  00034	1afffffc	 bne         |$LL20@SDBusIssue|
  00038		 |$LN33@SDBusIssue|

; 951  : 
; 952  :         // set the command
; 953  :     WRITE_MMC_REGISTER_DWORD(pController, MMC_CMD, pRequest->CommandCode);

  00038	e5d13014	 ldrb        r3, [r1, #0x14]

; 954  :         // set the argument,  high part
; 955  :     WRITE_MMC_REGISTER_DWORD(pController, MMC_ARGH, (pRequest->CommandArgument >> 16));
; 956  :         // set the argument,  high part
; 957  :     WRITE_MMC_REGISTER_DWORD(pController, MMC_ARGL, (pRequest->CommandArgument & 0x0000FFFF));

  0003c	e3a00cff	 mov         r0, #0xFF, 24
  00040	e38070ff	 orr         r7, r0, #0xFF
  00044	e5823030	 str         r3, [r2, #0x30]
  00048	e5952004	 ldr         r2, [r5, #4]
  0004c	e1d131ba	 ldrh        r3, [r1, #0x1A]
  00050	e5823034	 str         r3, [r2, #0x34]
  00054	e5913018	 ldr         r3, [r1, #0x18]
  00058	e5952004	 ldr         r2, [r5, #4]
  0005c	e0033007	 and         r3, r3, r7
  00060	e5823038	 str         r3, [r2, #0x38]

; 958  : 
; 959  : 
; 960  :     switch (pRequest->CommandResponse.ResponseType) {

  00064	e591201c	 ldr         r2, [r1, #0x1C]
  00068	e3520008	 cmp         r2, #8
  0006c	8a000054	 bhi         |$LN9@SDBusIssue|
  00070	e28f3004	 add         r3, pc, #4
  00074	e7d33002	 ldrb        r3, [r3, +r2]
  00078	e08ff003	 add         pc, pc, r3
  0007c		 |$LN81@SDBusIssue|
  0007c		 |$LN80@SDBusIssue|
  0007c		 |$LN82@SDBusIssue|
  0007c	08ed		 DCB         0x8
  0007d		 |$LN83@SDBusIssue|
  0007d	18ed		 DCB         0x18
  0007e		 |$LN84@SDBusIssue|
  0007e	10ed		 DCB         0x10
  0007f		 |$LN85@SDBusIssue|
  0007f	20ed		 DCB         0x20
  00080		 |$LN86@SDBusIssue|
  00080	28ed		 DCB         0x28
  00081		 |$LN87@SDBusIssue|
  00081	28ed		 DCB         0x28
  00082		 |$LN88@SDBusIssue|
  00082	18ed		 DCB         0x18
  00083		 |$LN89@SDBusIssue|
  00083	18ed		 DCB         0x18
  00084		 |$LN90@SDBusIssue|
  00084	18ed		 DCB         0x18
  00085		 |$LN94@SDBusIssue|

; 1089 : }

  00085	18ed		 DCB         0x18
  00086		 |$LN95@SDBusIssue|
  00086	18ed		 DCB         0x18
  00087		 |$LN96@SDBusIssue|
  00087	18ed		 DCB         0x18
  00088		 |$LN14@SDBusIssue|

; 961  : 
; 962  :         case NoResponse:
; 963  :             cmdatRegister = MMC_CMDAT_RESPONSE_NONE;

  00088	e3a04000	 mov         r4, #0

; 964  :             break;

  0008c	ea000006	 b           |$LN15@SDBusIssue|
  00090		 |$LN13@SDBusIssue|

; 965  :         case ResponseR1b:
; 966  :                 // response1 with busy signalling
; 967  :             cmdatRegister = MMC_CMDAT_RESPONSE_R1 | MMC_CMDAT_EXPECT_BUSY;

  00090	e3a04021	 mov         r4, #0x21

; 968  :             break;

  00094	ea000004	 b           |$LN15@SDBusIssue|
  00098		 |$LN12@SDBusIssue|

; 969  :         case ResponseR1:
; 970  :         case ResponseR5:
; 971  :         case ResponseR6:
; 972  :         case ResponseR7:
; 973  :                 // on an MMC controller R5 and R6 are really just an R1 response (CRC protected)
; 974  :             cmdatRegister = MMC_CMDAT_RESPONSE_R1;

  00098	e3a04001	 mov         r4, #1

; 975  :             break;

  0009c	ea000002	 b           |$LN15@SDBusIssue|
  000a0		 |$LN11@SDBusIssue|

; 976  :         case ResponseR2:    
; 977  :             cmdatRegister = MMC_CMDAT_RESPONSE_R2;

  000a0	e3a04002	 mov         r4, #2

; 978  :             break;

  000a4	ea000000	 b           |$LN15@SDBusIssue|
  000a8		 |$LN10@SDBusIssue|

; 979  :         case ResponseR3:
; 980  :         case ResponseR4:    
; 981  :                 // R4 is really same as an R3 response on an MMC controller (non-CRC)
; 982  :             cmdatRegister = MMC_CMDAT_RESPONSE_R3;

  000a8	e3a04003	 mov         r4, #3
  000ac		 |$LN15@SDBusIssue|

; 988  :     }
; 989  : 
; 990  :     pController->fDMATransfer = FALSE;

  000ac	e3a08000	 mov         r8, #0
  000b0	e5858aa8	 str         r8, [r5, #0xAA8]

; 991  :     pController->fDMATransferCancelled = FALSE;

  000b4	e5858ab0	 str         r8, [r5, #0xAB0]

; 992  : 
; 993  :         // check for Command Only
; 994  :     if ((SD_COMMAND == pRequest->TransferClass)) {

  000b8	e5913010	 ldr         r3, [r1, #0x10]
  000bc	e3530002	 cmp         r3, #2

; 995  :        
; 996  :             // set the length of the block
; 997  :         WRITE_MMC_REGISTER_DWORD(pController, MMC_BLKLEN, 0);

  000c0	05953004	 ldreq       r3, [r5, #4]
  000c4	0583801c	 streq       r8, [r3, #0x1C]

; 998  : 
; 999  :             // set the number of blocks
; 1000 :         WRITE_MMC_REGISTER_DWORD(pController, MMC_NOB, 0);

  000c8	05953004	 ldreq       r3, [r5, #4]
  000cc	05838020	 streq       r8, [r3, #0x20]
  000d0	0a00000f	 beq         |$LN5@SDBusIssue|

; 1001 : 
; 1002 :     } else {
; 1003 :             // its a command with a data phase
; 1004 :         cmdatRegister |= MMC_CMDAT_DATA_EN;
; 1005 :         
; 1006 :             // set the buffer index to the end of the buffer
; 1007 :         pRequest->HCParam = 0;      
; 1008 : 
; 1009 :             // set the length of the block
; 1010 :         WRITE_MMC_REGISTER_DWORD(pController, MMC_BLKLEN, pRequest->BlockSize);

  000d4	e5913040	 ldr         r3, [r1, #0x40]
  000d8	e5818044	 str         r8, [r1, #0x44]
  000dc	e5952004	 ldr         r2, [r5, #4]
  000e0	e3844004	 orr         r4, r4, #4

; 1011 : 
; 1012 :             // set the number of blocks
; 1013 :         WRITE_MMC_REGISTER_DWORD(pController, MMC_NOB, pRequest->NumBlocks);
; 1014 : 
; 1015 :             // check for write
; 1016 :         if (TRANSFER_IS_WRITE(pRequest)) {
; 1017 :             cmdatRegister |= MMC_CMDAT_DATA_WRITE;
; 1018 :         } 
; 1019 : 
; 1020 :         // check to see if we can use DMA for data transfer
; 1021 :         if( PrepareDmaTransfer( pController, pRequest ) )

  000e4	e1a00005	 mov         r0, r5
  000e8	e582301c	 str         r3, [r2, #0x1C]
  000ec	e5952004	 ldr         r2, [r5, #4]
  000f0	e591303c	 ldr         r3, [r1, #0x3C]
  000f4	e5823020	 str         r3, [r2, #0x20]
  000f8	e5913010	 ldr         r3, [r1, #0x10]
  000fc	e3530001	 cmp         r3, #1
  00100	03844008	 orreq       r4, r4, #8
  00104	eb000000	 bl          PrepareDmaTransfer
  00108	e3500000	 cmp         r0, #0

; 1022 :         {
; 1023 :             cmdatRegister |= MMC_CMDAT_DMA_ENABLE;

  0010c	13844080	 orrne       r4, r4, #0x80

; 1024 :             pController->fDMATransfer = TRUE;

  00110	15859aa8	 strne       r9, [r5, #0xAA8]
  00114		 |$LN5@SDBusIssue|

; 1025 :         }
; 1026 :     }
; 1027 : 
; 1028 :         // check to see if we need to append the 80 clocks (i.e. this is the first transaction)
; 1029 :     if (pController->SendInitClocks) {

  00114	e5953ae8	 ldr         r3, [r5, #0xAE8]

; 1030 :         pController->SendInitClocks = FALSE;
; 1031 :         cmdatRegister |= MMC_CMDAT_INIT;
; 1032 :         fExtraDelay = TRUE;
; 1033 :     }
; 1034 : 
; 1035 :         // check to see if we need to enable the SDIO interrupt checking
; 1036 :     if (pController->fSDIOEnabled) {
; 1037 :         cmdatRegister |= MMC_CMDAT_SDIO_INT_EN;
; 1038 :     }
; 1039 : 
; 1040 :         // check to see if we need to enable wide bus (4 bit) data transfer mode
; 1041 :     if (pController->f4BitMode) {
; 1042 :         cmdatRegister |= MMC_CMDAT_SD_4DAT;
; 1043 :     }
; 1044 : 
; 1045 :     
; 1046 : 
; 1047 :         // write the CMDAT register
; 1048 :     WRITE_MMC_REGISTER_DWORD(pController, MMC_CMDAT, cmdatRegister);
; 1049 :     DbgPrintZo(SDH_SEND_ZONE, (TEXT("SDBusIssueRequest - CMDAT Reg: 0x%08X, CMD:%d \n"),
; 1050 :                 cmdatRegister, pRequest->CommandCode));
; 1051 : 
; 1052 :         // set the the response timeout
; 1053 :     WRITE_MMC_REGISTER_DWORD(pController, MMC_RESTO, SDH_DEFAULT_RESPONSE_TIMEOUT_CLOCKS);

  00118	e3a02040	 mov         r2, #0x40

; 1054 :         // set the data receive timeout
; 1055 :     WRITE_MMC_REGISTER_DWORD(pController, MMC_RDTO, SDH_DEFAULT_DATA_TIMEOUT_CLOCKS);
; 1056 : 
; 1057 :     SetCurrentState(pController, CommandSend);
; 1058 :         // turn on the command complete and the response error interrupts
; 1059 :     END_CMD_INTERRUPT_ON(pController);

  0011c	e2850ed5	 add         r0, r5, #0xD5, 28
  00120	e3530000	 cmp         r3, #0
  00124	e5953d30	 ldr         r3, [r5, #0xD30]
  00128	15858ae8	 strne       r8, [r5, #0xAE8]
  0012c	13844040	 orrne       r4, r4, #0x40
  00130	13a06001	 movne       r6, #1
  00134	e3530000	 cmp         r3, #0
  00138	e5953d38	 ldr         r3, [r5, #0xD38]
  0013c	13844b02	 orrne       r4, r4, #2, 22
  00140	e3530000	 cmp         r3, #0
  00144	e5953004	 ldr         r3, [r5, #4]
  00148	13844c01	 orrne       r4, r4, #1, 24
  0014c	e5834010	 str         r4, [r3, #0x10]
  00150	e5953004	 ldr         r3, [r5, #4]
  00154	e5832014	 str         r2, [r3, #0x14]
  00158	e5953004	 ldr         r3, [r5, #4]
  0015c	e5837018	 str         r7, [r3, #0x18]
  00160	e5859cec	 str         r9, [r5, #0xCEC]
  00164	eb000000	 bl          EnterCriticalSection
  00168	e5952004	 ldr         r2, [r5, #4]
  0016c	e2850ed5	 add         r0, r5, #0xD5, 28
  00170	e5923028	 ldr         r3, [r2, #0x28]
  00174	e3c33004	 bic         r3, r3, #4
  00178	e5823028	 str         r3, [r2, #0x28]
  0017c	eb000000	 bl          LeaveCriticalSection

; 1060 :     PROGRAM_RESPONSE_ERROR_INTERRUPT_ON(pController);

  00180	e2850ed5	 add         r0, r5, #0xD5, 28
  00184	eb000000	 bl          EnterCriticalSection
  00188	e5952004	 ldr         r2, [r5, #4]
  0018c	e2850ed5	 add         r0, r5, #0xD5, 28
  00190	e5923028	 ldr         r3, [r2, #0x28]
  00194	e3c33c02	 bic         r3, r3, #2, 24
  00198	e5823028	 str         r3, [r2, #0x28]
  0019c	eb000000	 bl          LeaveCriticalSection

; 1061 : 
; 1062 :         // turn on the clock 
; 1063 :     SDClockOn(pController);

  001a0	e5953004	 ldr         r3, [r5, #4]

; 1064 : 
; 1065 :     if( fExtraDelay )

  001a4	e3560000	 cmp         r6, #0
  001a8	e3a02002	 mov         r2, #2

; 1066 :     {
; 1067 :         fExtraDelay = FALSE;
; 1068 :         Sleep(500);

  001ac	13a00f7d	 movne       r0, #0x7D, 30
  001b0	e5832000	 str         r2, [r3]
  001b4	1b000000	 blne        Sleep

; 1069 :     }
; 1070 :        
; 1071 : #if DEBUG
; 1072 :     {
; 1073 :         DWORD mmcStatus;
; 1074 : 
; 1075 :         mmcStatus = READ_MMC_REGISTER_DWORD(pController, MMC_STAT);
; 1076 : 
; 1077 :         if (mmcStatus & 0x0000003F) {
; 1078 :                 // these errors should be cleared
; 1079 :             DbgPrintZo(SDCARD_ZONE_ERROR, 
; 1080 :                 (TEXT("********* SDBusIssueRequest - MMC Status did not clear : 0x%08X \n"),
; 1081 :                 (mmcStatus & 0x0000003F)));
; 1082 :         }
; 1083 :     
; 1084 :     }
; 1085 : #endif 
; 1086 :     DbgPrintZo(SDH_SEND_ZONE, (TEXT("SDBusIssueRequest - Request Sent\n")));
; 1087 : 
; 1088 :     return SD_API_STATUS_PENDING;

  001b8	e3a00001	 mov         r0, #1

; 1089 : }

  001bc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$LN9@SDBusIssue|

; 983  :             break;
; 984  : 
; 985  :         default:
; 986  :             DbgPrintZo(SDH_SDBUS_INTERACTION_ZONE, (TEXT("SDBusIssueRequest failed (Invalid parameter)\n")));
; 987  :             return SD_API_STATUS_INVALID_PARAMETER;

  001c4	e3a0011f	 mov         r0, #0x1F, 2

; 1089 : }

  001c8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  001cc	e12fff1e	 bx          lr
  001d0		 |$M47767|

			 ENDP  ; |SDBusIssueRequest|

	EXPORT	|HandleXmitInterrupt|

  00000			 AREA	 |.pdata|, PDATA
|$T47918| DCD	|$LN45@HandleXmit|
	DCD	0xc0004805

  00000			 AREA	 |.pdata|, PDATA
|$T47920| DCD	|$LN11@HandleXmit|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T47916| DCD	0x1
	DCD	|$LN15@HandleXmit|
	DCD	|$LN16@HandleXmit|
	DCD	|$LN11@HandleXmit|
	DCD	|$LN12@HandleXmit|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T47916|

  00008		 |HandleXmitInterrupt| PROC

; 1762 : {

  00008		 |$LN45@HandleXmit|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0001	 stmdb       sp!, {r0}
  00010	e92d59f0	 stmdb       sp!, {r4 - r8, r11, r12, lr}
  00014	e28db020	 add         r11, sp, #0x20
  00018	e24dd010	 sub         sp, sp, #0x10
  0001c		 |$LN43@HandleXmit|
  0001c	e1a04000	 mov         r4, r0
  00020	e58b4000	 str         r4, [r11]

; 1763 :     PSD_BUS_REQUEST pRequest;       // current request
; 1764 :     DWORD maxBytes;
; 1765 :     
; 1766 :     ASSERT( pController->fDMATransfer == FALSE );
; 1767 : 
; 1768 :         // get the current request  
; 1769 :     pRequest = pController->pCurrentRequest;

  00024	e594301c	 ldr         r3, [r4, #0x1C]
  00028	e1b05003	 movs        r5, r3
  0002c	e50b502c	 str         r5, [r11, #-0x2C]

; 1770 : 
; 1771 :         // this should never happen because we mark the request as un-cancelable
; 1772 :     DEBUG_ASSERT(NULL != pRequest);
; 1773 :     if( pRequest == NULL )

  00030	1a000008	 bne         |$LN7@HandleXmit|

; 1774 :     {
; 1775 :         TX_FIFO_INTERRUPT_OFF(pController);

  00034	e2840ed5	 add         r0, r4, #0xD5, 28
  00038	eb000000	 bl          EnterCriticalSection
  0003c	e5942004	 ldr         r2, [r4, #4]
  00040	e2840ed5	 add         r0, r4, #0xD5, 28
  00044	e5923028	 ldr         r3, [r2, #0x28]
  00048	e3833040	 orr         r3, r3, #0x40
  0004c	e5823028	 str         r3, [r2, #0x28]
  00050	eb000000	 bl          LeaveCriticalSection

; 1776 :         return;

  00054	ea000030	 b           |$LN8@HandleXmit|
  00058		 |$LN7@HandleXmit|

; 1777 :     }
; 1778 : 
; 1779 :     maxBytes = pRequest->NumBlocks * pRequest->BlockSize;

  00058	e5952040	 ldr         r2, [r5, #0x40]
  0005c	e595303c	 ldr         r3, [r5, #0x3C]
  00060	e3a01c1f	 mov         r1, #0x1F, 24
  00064	e38180ff	 orr         r8, r1, #0xFF
  00068	e0060392	 mul         r6, r2, r3
  0006c	e50b6028	 str         r6, [r11, #-0x28]
  00070		 |$LL6@HandleXmit|

; 1780 :     while (pRequest->HCParam < maxBytes && IsCardPresent()) {

  00070	e5953044	 ldr         r3, [r5, #0x44]
  00074	e1530006	 cmp         r3, r6
  00078	2a00001d	 bcs         |$LN5@HandleXmit|
  0007c	eb000000	 bl          IsCardPresent
  00080	e3500000	 cmp         r0, #0
  00084	0a00001a	 beq         |$LN5@HandleXmit|

; 1781 :         DWORD dwIntr = GetMMCInterrupts(pController);

  00088	e5942004	 ldr         r2, [r4, #4]
  0008c	e592302c	 ldr         r3, [r2, #0x2C]
  00090	e5922028	 ldr         r2, [r2, #0x28]
  00094	e0031008	 and         r1, r3, r8
  00098	e1c83002	 bic         r3, r8, r2
  0009c	e0037001	 and         r7, r3, r1
  000a0	e50b7024	 str         r7, [r11, #-0x24]

; 1782 :         if (dwIntr & MMC_IREG_TXFIFO_REQ) {

  000a4	e3170040	 tst         r7, #0x40
  000a8	0a00000f	 beq         |$LN2@HandleXmit|
  000ac		 |$LN15@HandleXmit|

; 1783 :             BOOL fReturn ;
; 1784 :             __try {
; 1785 :                 fReturn = SDLoadXmitFifo(pController, pRequest, maxBytes);

  000ac	e1a02006	 mov         r2, r6
  000b0	e1a01005	 mov         r1, r5
  000b4	e1a00004	 mov         r0, r4
  000b8	eb000000	 bl          SDLoadXmitFifo
  000bc	e50b0030	 str         r0, [r11, #-0x30]
  000c0		 |$LN16@HandleXmit|

; 1786 :             }

  000c0	ea000007	 b           |$LN17@HandleXmit|
  000c4		 |$LN12@HandleXmit|

; 1788 :                 fReturn = TRUE ;

  000c4	e3a00001	 mov         r0, #1
  000c8	e50b0030	 str         r0, [r11, #-0x30]
  000cc	e59b4000	 ldr         r4, [r11]
  000d0	e51b502c	 ldr         r5, [r11, #-0x2C]
  000d4	e51b6028	 ldr         r6, [r11, #-0x28]
  000d8	e51b7024	 ldr         r7, [r11, #-0x24]
  000dc	e3a03c1f	 mov         r3, #0x1F, 24
  000e0	e38380ff	 orr         r8, r3, #0xFF
  000e4		 |$LN17@HandleXmit|

; 1789 :             }
; 1790 :             if (fReturn)

  000e4	e3500000	 cmp         r0, #0
  000e8	1a000001	 bne         |$LN5@HandleXmit|
  000ec		 |$LN2@HandleXmit|

; 1791 :                 break;                
; 1792 :         }            
; 1793 :         if (dwIntr & (MMC_IREG_END_CMD | MMC_IREG_RES_ERR))

  000ec	e3170f81	 tst         r7, #0x81, 30
  000f0	0affffde	 beq         |$LL6@HandleXmit|
  000f4		 |$LN5@HandleXmit|

; 1794 :             break;
; 1795 :     }
; 1796 :     // the request is complete  
; 1797 :     // turn off the Fifo Interrupts
; 1798 :     TX_FIFO_INTERRUPT_OFF(pController);

  000f4	e2840ed5	 add         r0, r4, #0xD5, 28
  000f8	eb000000	 bl          EnterCriticalSection
  000fc	e5942004	 ldr         r2, [r4, #4]
  00100	e2840ed5	 add         r0, r4, #0xD5, 28
  00104	e5923028	 ldr         r3, [r2, #0x28]
  00108	e3833040	 orr         r3, r3, #0x40
  0010c	e5823028	 str         r3, [r2, #0x28]
  00110	eb000000	 bl          LeaveCriticalSection

; 1799 :     SetCurrentState(pController, WriteDataTransferDone);

  00114	e3a03005	 mov         r3, #5
  00118	e5843cec	 str         r3, [r4, #0xCEC]
  0011c		 |$LN8@HandleXmit|

; 1800 : 
; 1801 :     // now we need to wait for the controller to transmit (transfer done) and the card 
; 1802 :     // to complete programming (program done)
; 1803 :     // if the transfer is done or programming is done before we go back into the interrupt wait
; 1804 :     // the interrupt bit will be set and the IST loop will handle the transfer done in this same thread     
; 1805 : 
; 1806 : }

  0011c	e24bd020	 sub         sp, r11, #0x20
  00120	e89d69f0	 ldmia       sp, {r4 - r8, r11, sp, lr}
  00124	e12fff1e	 bx          lr

			 ENDP  ; |HandleXmitInterrupt|

  00128		 |$LN11@HandleXmit|
  00128		 |$LN44@HandleXmit|

; 1787 :             __except(EXCEPTION_EXECUTE_HANDLER) {

  00128	e52de004	 str         lr, [sp, #-4]!
  0012c		 |$LN14@HandleXmit|
  0012c		 |$LN47@HandleXmit|
  0012c	e3a00001	 mov         r0, #1
  00130		 |$LN13@HandleXmit|
  00130	e49df004	 ldr         pc, [sp], #4
  00134		 |$LN48@HandleXmit|
  00134		 |$LN46@HandleXmit|
	EXPORT	|HandleReceiveInterrupt|

  00000			 AREA	 |.pdata|, PDATA
|$T48069| DCD	|$LN46@HandleRece|
	DCD	0xc0004805

  00000			 AREA	 |.pdata|, PDATA
|$T48071| DCD	|$LN12@HandleRece|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T48067| DCD	0x1
	DCD	|$LN16@HandleRece|
	DCD	|$LN17@HandleRece|
	DCD	|$LN12@HandleRece|
	DCD	|$LN13@HandleRece|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T48067|

  00008		 |HandleReceiveInterrupt| PROC

; 1816 : {

  00008		 |$LN46@HandleRece|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d0001	 stmdb       sp!, {r0}
  00010	e92d59f0	 stmdb       sp!, {r4 - r8, r11, r12, lr}
  00014	e28db020	 add         r11, sp, #0x20
  00018	e24dd00c	 sub         sp, sp, #0xC
  0001c		 |$LN44@HandleRece|
  0001c	e1a04000	 mov         r4, r0
  00020	e58b4000	 str         r4, [r11]

; 1817 :     PSD_BUS_REQUEST pRequest;       // current request
; 1818 :     DWORD           maxBytes;       // max bytes
; 1819 :     ULONG           ii = 0;         // loop variable
; 1820 : 
; 1821 :     ASSERT( pController->fDMATransfer == FALSE );
; 1822 : 
; 1823 :         // get the current request  
; 1824 :     pRequest = pController->pCurrentRequest;

  00024	e594301c	 ldr         r3, [r4, #0x1C]
  00028	e1b05003	 movs        r5, r3
  0002c	e50b502c	 str         r5, [r11, #-0x2C]

; 1825 : 
; 1826 :         // this should never happen because we mark the request as un-cancelable
; 1827 :     DEBUG_ASSERT(NULL != pRequest);
; 1828 :     if(NULL == pRequest)

  00030	1a000008	 bne         |$LN8@HandleRece|

; 1829 :     {
; 1830 :         RX_FIFO_INTERRUPT_OFF(pController);

  00034	e2840ed5	 add         r0, r4, #0xD5, 28
  00038	eb000000	 bl          EnterCriticalSection
  0003c	e5942004	 ldr         r2, [r4, #4]
  00040	e2840ed5	 add         r0, r4, #0xD5, 28
  00044	e5923028	 ldr         r3, [r2, #0x28]
  00048	e3833020	 orr         r3, r3, #0x20
  0004c	e5823028	 str         r3, [r2, #0x28]
  00050	eb000000	 bl          LeaveCriticalSection

; 1831 :         return;

  00054	ea000030	 b           |$LN1@HandleRece|
  00058		 |$LN8@HandleRece|

; 1832 :     }
; 1833 : 
; 1834 :     maxBytes = pRequest->NumBlocks * pRequest->BlockSize;

  00058	e5952040	 ldr         r2, [r5, #0x40]
  0005c	e595303c	 ldr         r3, [r5, #0x3C]
  00060	e3a01c1f	 mov         r1, #0x1F, 24
  00064	e38180ff	 orr         r8, r1, #0xFF
  00068	e0060392	 mul         r6, r2, r3
  0006c	e50b6028	 str         r6, [r11, #-0x28]
  00070		 |$LL6@HandleRece|

; 1835 :     
; 1836 :     DbgPrintZo(SDH_RECEIVE_ZONE, (TEXT("HandleReceiveInterrupt: Max: %d, Current %d \n"),
; 1837 :         maxBytes, pRequest->HCParam));
; 1838 :  
; 1839 :         // according to the spec (15.2.8.2) the RX Fifo interrupt asserts for every 32 bytes and
; 1840 :         // remains asserted until the RX fifo is empty, once it is empty 
; 1841 :         // the interrupt req resets and won't assert until 32 more bytes are received
; 1842 :         // or until the transfer is complete and their is a partial Fifo
; 1843 :     if ((maxBytes - pRequest->HCParam) >= (LONG)MMC_RXFIFO_SIZE) {
; 1844 :             // because the remaining bytes is greater than or equal to the fifo size,
; 1845 :             // the fifo better be full as per Intel spec!
; 1846 :         // DEBUG_ASSERT(RX_FIFO_FULL(pController)); @todo
; 1847 :     }
; 1848 : 
; 1849 :     // read a Fifo's worth, as per spec 
; 1850 :     while ( IsCardPresent() && pRequest->HCParam<maxBytes ) {

  00070	eb000000	 bl          IsCardPresent
  00074	e3500000	 cmp         r0, #0
  00078	0a00001a	 beq         |$LN5@HandleRece|
  0007c	e5953044	 ldr         r3, [r5, #0x44]
  00080	e1530006	 cmp         r3, r6
  00084	2a000017	 bcs         |$LN5@HandleRece|

; 1851 :         DWORD dwIntr = GetMMCInterrupts(pController);

  00088	e5942004	 ldr         r2, [r4, #4]
  0008c	e592302c	 ldr         r3, [r2, #0x2C]
  00090	e5922028	 ldr         r2, [r2, #0x28]
  00094	e0031008	 and         r1, r3, r8
  00098	e1c83002	 bic         r3, r8, r2
  0009c	e0037001	 and         r7, r3, r1
  000a0	e50b7024	 str         r7, [r11, #-0x24]

; 1852 :         if (dwIntr & MMC_IREG_RXFIFO_REQ) {

  000a4	e3170020	 tst         r7, #0x20
  000a8	0a00000c	 beq         |$LN18@HandleRece|
  000ac		 |$LN16@HandleRece|

; 1853 :             __try { 
; 1854 :                 EmptyReceiveFifo(pController, pRequest, MMC_RXFIFO_SIZE, maxBytes);

  000ac	e1a03006	 mov         r3, r6
  000b0	e3a02020	 mov         r2, #0x20
  000b4	e1a01005	 mov         r1, r5
  000b8	e1a00004	 mov         r0, r4
  000bc	eb000000	 bl          EmptyReceiveFifo
  000c0		 |$LN17@HandleRece|
  000c0	ea000006	 b           |$LN18@HandleRece|
  000c4		 |$LN13@HandleRece|

; 1856 :                 break;

  000c4	e59b4000	 ldr         r4, [r11]
  000c8	e51b502c	 ldr         r5, [r11, #-0x2C]
  000cc	e51b6028	 ldr         r6, [r11, #-0x28]
  000d0	e51b7024	 ldr         r7, [r11, #-0x24]
  000d4	e3a03c1f	 mov         r3, #0x1F, 24
  000d8	e38380ff	 orr         r8, r3, #0xFF
  000dc	ea000001	 b           |$LN5@HandleRece|
  000e0		 |$LN18@HandleRece|

; 1857 :             }
; 1858 :         }
; 1859 :         if (dwIntr & (MMC_IREG_END_CMD | MMC_IREG_RES_ERR))

  000e0	e3170f81	 tst         r7, #0x81, 30
  000e4	0affffe1	 beq         |$LL6@HandleRece|
  000e8		 |$LN5@HandleRece|

; 1860 :             break;
; 1861 :     }
; 1862 : 
; 1863 :     DbgPrintZo(SDH_RECEIVE_ZONE, (TEXT("HandleReceiveInterrupt: New Current %d  \n"),pRequest->HCParam));
; 1864 :     
; 1865 :         // see if we are done
; 1866 :     if (pRequest->HCParam >= maxBytes) {

  000e8	e5953044	 ldr         r3, [r5, #0x44]
  000ec	e1530006	 cmp         r3, r6
  000f0	3a000009	 bcc         |$LN1@HandleRece|

; 1867 :         DbgPrintZo(SDH_RECEIVE_ZONE, (TEXT("HandleReceiveInterrupt: Data Transfer Completing waiting for TRANS_DONE..\n")));    
; 1868 :             // if we are finished, turn off the RX Fifo request interrupt
; 1869 :         RX_FIFO_INTERRUPT_OFF(pController);  

  000f4	e2840ed5	 add         r0, r4, #0xD5, 28
  000f8	eb000000	 bl          EnterCriticalSection
  000fc	e5942004	 ldr         r2, [r4, #4]
  00100	e2840ed5	 add         r0, r4, #0xD5, 28
  00104	e5923028	 ldr         r3, [r2, #0x28]
  00108	e3833020	 orr         r3, r3, #0x20
  0010c	e5823028	 str         r3, [r2, #0x28]
  00110	eb000000	 bl          LeaveCriticalSection

; 1870 :         SetCurrentState(pController, ReadDataTransferDone);

  00114	e3a03009	 mov         r3, #9
  00118	e5843cec	 str         r3, [r4, #0xCEC]
  0011c		 |$LN1@HandleRece|

; 1871 :         // now we need to wait for the controller to perform the CRC check and issue trailing clocks (transfer done)
; 1872 :         // if the transfer is done, the interrupt bit will be set and the IST loop will 
; 1873 :         // handle the transfer done in this same thread      
; 1874 :     }  
; 1875 : 
; 1876 :         // we could mark the request as cancelable again...
; 1877 : }

  0011c	e24bd020	 sub         sp, r11, #0x20
  00120	e89d69f0	 ldmia       sp, {r4 - r8, r11, sp, lr}
  00124	e12fff1e	 bx          lr

			 ENDP  ; |HandleReceiveInterrupt|

  00128		 |$LN12@HandleRece|
  00128		 |$LN45@HandleRece|

; 1855 :             }__except(EXCEPTION_EXECUTE_HANDLER) {

  00128	e52de004	 str         lr, [sp, #-4]!
  0012c		 |$LN15@HandleRece|
  0012c		 |$LN48@HandleRece|
  0012c	e3a00001	 mov         r0, #1
  00130		 |$LN14@HandleRece|
  00130	e49df004	 ldr         pc, [sp], #4
  00134		 |$LN49@HandleRece|
  00134		 |$LN47@HandleRece|
	EXPORT	|SDControllerISTHandler|

  00000			 AREA	 |.pdata|, PDATA
|$T48201| DCD	|$LN44@SDControll@3|
	DCD	0x40003d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDControllerISTHandler| PROC

; 2698 : {

  00000		 |$LN44@SDControll@3|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M48198|
  00004	e3510000	 cmp         r1, #0
  00008	e1a05000	 mov         r5, r0

; 2699 :     DWORD interrupts;    // current interrupts
; 2700 :     DWORD interruptMask;
; 2701 :     BOOL  fForceTimeout;
; 2702 :     DbgPrintZo(SDH_INTERRUPT_ZONE, (TEXT("SDControllerISTHandler+++++++++++++ \n")));
; 2703 : 
; 2704 :     interrupts = GetMMCInterrupts(pHCDevice);

  0000c	e5951004	 ldr         r1, [r5, #4]
  00010	e3a03c1f	 mov         r3, #0x1F, 24
  00014	e38380ff	 orr         r8, r3, #0xFF

; 2705 : 
; 2706 :     // We have observed that sometimes, after an abrupt card removal and insert,
; 2707 :     // the controller will "stall" during the first data transfer, there will be
; 2708 :     // no hardware timeout.  If this is the case, we will simulate a hardware timeout 
; 2709 :     // interrupt.
; 2710 :     fForceTimeout = FALSE;

  00018	e591202c	 ldr         r2, [r1, #0x2C]
  0001c	e5913028	 ldr         r3, [r1, #0x28]
  00020	e3a06000	 mov         r6, #0
  00024	e1c23003	 bic         r3, r2, r3
  00028	e0034008	 and         r4, r3, r8

; 2711 :     if (fTimeOut) {

  0002c	0a000006	 beq         |$LN40@SDControll@3|

; 2712 :         // check if the MMC_IREG_DAT_ERR interrupt is enabled 
; 2713 :         interruptMask = (~(READ_MMC_REGISTER_DWORD(pHCDevice, MMC_IMASK))) 
; 2714 :                         & MMC_IREG_INTERRUPTS;

  00030	e5913028	 ldr         r3, [r1, #0x28]
  00034	e1e03003	 mvn         r3, r3

; 2715 :         if( interruptMask & MMC_IREG_DAT_ERR )

  00038	e3130c01	 tst         r3, #1, 24

; 2716 :         {
; 2717 :             DbgPrintZo(SDCARD_ZONE_WARN, 
; 2718 :                 (TEXT("SDControllerIstThread: Unexpected hardware timeout!\n")));
; 2719 :             interrupts |= MMC_IREG_DAT_ERR;
; 2720 :             fForceTimeout = TRUE;
; 2721 :         }
; 2722 :         pHCDevice->dwControllerIstTimeout = INFINITE;

  0003c	e3e03000	 mvn         r3, #0
  00040	e585303c	 str         r3, [r5, #0x3C]
  00044	13844c01	 orrne       r4, r4, #1, 24
  00048	13a06001	 movne       r6, #1
  0004c		 |$LN40@SDControll@3|

; 2723 :     }
; 2724 : 
; 2725 : 
; 2726 :         // loop until all interrupts are serviced
; 2727 :     while (interrupts) {

  0004c	e3540000	 cmp         r4, #0
  00050	0a000024	 beq         |$LN12@SDControll@3|
  00054	e3a03c01	 mov         r3, #1, 24
  00058	e3837001	 orr         r7, r3, #1
  0005c		 |$LL13@SDControll@3|

; 2728 :         DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2729 :                 (TEXT("SDControllerIstThread: Controller Interrupt: 0x%08X \n"),interrupts));
; 2730 : 
; 2731 :         if (interrupts & MMC_IREG_TINT) {
; 2732 :                 // no one should be turning this on
; 2733 :             DEBUG_ASSERT(FALSE);
; 2734 :         }
; 2735 : 
; 2736 :         if (interrupts & MMC_IREG_RD_STALLED) {
; 2737 :                 // no one should be turning this on
; 2738 :             DEBUG_ASSERT(FALSE);
; 2739 :         }
; 2740 : 
; 2741 :         if (interrupts & MMC_IREG_SDIO_SUSPEND_ACK) {
; 2742 :                 // no one should be turning this on
; 2743 :             DEBUG_ASSERT(FALSE);
; 2744 :         }
; 2745 : 
; 2746 :         if (interrupts & MMC_IREG_CLOCK_IS_OFF) {

  0005c	e3140010	 tst         r4, #0x10
  00060	0a000007	 beq         |$LN26@SDControll@3|

; 2747 :                 // no one should be turning this on
; 2748 :             DEBUG_ASSERT(FALSE);
; 2749 :                 // mask the interrupt
; 2750 :             CLOCK_OFF_INTERRUPT_OFF(pHCDevice);

  00064	e2850ed5	 add         r0, r5, #0xD5, 28
  00068	eb000000	 bl          EnterCriticalSection
  0006c	e5952004	 ldr         r2, [r5, #4]
  00070	e2850ed5	 add         r0, r5, #0xD5, 28
  00074	e5923028	 ldr         r3, [r2, #0x28]
  00078	e3833010	 orr         r3, r3, #0x10
  0007c	e5823028	 str         r3, [r2, #0x28]
  00080	eb000000	 bl          LeaveCriticalSection
  00084		 |$LN26@SDControll@3|

; 2751 :         }
; 2752 : 
; 2753 :         if (interrupts & (MMC_IREG_END_CMD | MMC_IREG_RES_ERR)) {

  00084	e3140f81	 tst         r4, #0x81, 30

; 2754 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2755 :                 (TEXT("SDControllerIstThread: MMC_IREG_END_CMD \n")));
; 2756 :             HandleEndCommandInterrupt(pHCDevice);

  00088	11a00005	 movne       r0, r5
  0008c	1b000000	 blne        HandleEndCommandInterrupt

; 2757 :         }
; 2758 : 
; 2759 :         if (interrupts & MMC_IREG_STOP_CMD) {
; 2760 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2761 :                 (TEXT("SDControllerIstThread: MMC_IREG_STOP_CMD \n")));
; 2762 :             DEBUG_ASSERT(FALSE);
; 2763 :         }
; 2764 :         
; 2765 :         if (interrupts & MMC_IREG_RXFIFO_REQ ) {

  00090	e3140020	 tst         r4, #0x20

; 2766 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2767 :                 (TEXT("SDControllerIstThread: MMC_IREG_RXFIFO_REQ \n")));
; 2768 :             HandleReceiveInterrupt(pHCDevice);

  00094	11a00005	 movne       r0, r5
  00098	1b000000	 blne        HandleReceiveInterrupt

; 2769 :         }
; 2770 :         
; 2771 :         if (interrupts & MMC_IREG_TXFIFO_REQ) {

  0009c	e3140040	 tst         r4, #0x40

; 2772 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2773 :                 (TEXT("SDControllerIstThread: MMC_IREG_TXFIFO_REQ \n")));
; 2774 :             HandleXmitInterrupt(pHCDevice);

  000a0	11a00005	 movne       r0, r5
  000a4	1b000000	 blne        HandleXmitInterrupt

; 2775 :         }
; 2776 : 
; 2777 :         if (interrupts & MMC_IREG_PROG_DONE) {

  000a8	e3140002	 tst         r4, #2

; 2778 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2779 :                 (TEXT("SDControllerIstThread: MMC_IREG_PROG_DONE \n")));
; 2780 :             HandleProgramDone(pHCDevice);

  000ac	11a00005	 movne       r0, r5
  000b0	1b000000	 blne        HandleProgramDone

; 2781 :         } 
; 2782 :             // DATA transfer done should be checked last so that the 
; 2783 :             // HandleReceive and HandleTransmit
; 2784 :             // have a chance to finish copying from the fifos
; 2785 :         if (interrupts & (MMC_IREG_DATA_TRAN_DONE|MMC_IREG_DAT_ERR)) {

  000b4	e1140007	 tst         r4, r7

; 2786 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2787 :                 (TEXT("SDControllerIstThread: MMC_IREG_DATA_TRAN_DONE \n")));
; 2788 :             HandleTransferDone(pHCDevice, fForceTimeout);

  000b8	11a01006	 movne       r1, r6
  000bc	11a00005	 movne       r0, r5
  000c0	1b000000	 blne        HandleTransferDone

; 2789 :         }
; 2790 : 
; 2791 :         if (interrupts & MMC_IREG_SDIO_INT) {

  000c4	e3140b02	 tst         r4, #2, 22

; 2792 :             DbgPrintZo(SDH_INTERRUPT_ZONE, 
; 2793 :                 (TEXT("SDControllerIstThread: MMC_IREG_SDIO_INT \n")));
; 2794 :             HandleSDIOInterrupt(pHCDevice);

  000c8	11a00005	 movne       r0, r5
  000cc	1b000000	 blne        HandleSDIOInterrupt

; 2795 :         } 
; 2796 : 
; 2797 :         interrupts = GetMMCInterrupts(pHCDevice);

  000d0	e5953004	 ldr         r3, [r5, #4]
  000d4	e593202c	 ldr         r2, [r3, #0x2C]
  000d8	e5933028	 ldr         r3, [r3, #0x28]
  000dc	e1c23003	 bic         r3, r2, r3
  000e0	e0134008	 ands        r4, r3, r8
  000e4	1affffdc	 bne         |$LL13@SDControll@3|
  000e8		 |$LN12@SDControll@3|

; 2798 :     } // while
; 2799 :     DbgPrintZo(SDH_INTERRUPT_ZONE, (TEXT("SDControllerISTHandler-------------- \n")));
; 2800 :     return TRUE;

  000e8	e3a00001	 mov         r0, #1

; 2801 : }

  000ec	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$M48199|

			 ENDP  ; |SDControllerISTHandler|

	EXPORT	|SDControllerIstThread|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T48222| DCD	|$LN19@SDControll@4|
	DCD	0x40002301
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\pxa27x_ms_v1\sdhc\sdcontrol.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDControllerIstThread| PROC

; 2810 : {

  00000		 |$LN19@SDControll@4|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M48219|
  00004	e1a04000	 mov         r4, r0

; 2811 :     DWORD waitStatus;    // wait status
; 2812 : 
; 2813 :     if (!CeSetThreadPriority(GetCurrentThread(), 
; 2814 :         pHCDevice->ControllerIstThreadPriority)) {

  00008	e5941038	 ldr         r1, [r4, #0x38]
  0000c	e3a00041	 mov         r0, #0x41
  00010	eb000000	 bl          CeSetThreadPriority

; 2815 :         DbgPrintZo(SDCARD_ZONE_WARN, 
; 2816 :             (TEXT("SDControllerIstThread: warning, failed to set CEThreadPriority \n")));
; 2817 :     }
; 2818 : 
; 2819 :     while(1) {
; 2820 :         waitStatus = WaitForSingleObject(pHCDevice->hControllerInterruptEvent, 
; 2821 :                                          pHCDevice->dwControllerIstTimeout);

  00014	e594103c	 ldr         r1, [r4, #0x3C]
  00018	e5940030	 ldr         r0, [r4, #0x30]
  0001c	eb000000	 bl          WaitForSingleObject
  00020	e1a05000	 mov         r5, r0

; 2822 : 
; 2823 :         if (WAIT_FAILED == waitStatus) {

  00024	e3750001	 cmn         r5, #1
  00028	0a000014	 beq         |$LN14@SDControll@4|
  0002c	e2846c0a	 add         r6, r4, #0xA, 24
  00030		 |$LL4@SDControll@4|

; 2828 :         }
; 2829 : 
; 2830 :         if (pHCDevice->DriverShutdown) {

  00030	e5943ad0	 ldr         r3, [r4, #0xAD0]
  00034	e3530000	 cmp         r3, #0
  00038	1a000010	 bne         |$LN14@SDControll@4|

; 2831 :             DbgPrintZo(1, (TEXT("SDControllerIstThread: Thread Exiting\n")));
; 2832 :             return 0;
; 2833 :         }
; 2834 :         ACQUIRE_LOCK(pHCDevice);

  0003c	e28600d4	 add         r0, r6, #0xD4
  00040	eb000000	 bl          EnterCriticalSection

; 2835 :         SDControllerISTHandler(pHCDevice, waitStatus != WAIT_OBJECT_0 );

  00044	e3550000	 cmp         r5, #0
  00048	13a01001	 movne       r1, #1
  0004c	03a01000	 moveq       r1, #0
  00050	e1a00004	 mov         r0, r4
  00054	eb000000	 bl          SDControllerISTHandler

; 2836 :         RELEASE_LOCK(pHCDevice);

  00058	e28600d4	 add         r0, r6, #0xD4
  0005c	eb000000	 bl          LeaveCriticalSection

; 2837 :         InterruptDone(pHCDevice->dwSysintrSDMMC);

  00060	e594002c	 ldr         r0, [r4, #0x2C]
  00064	eb000000	 bl          InterruptDone
  00068	e594103c	 ldr         r1, [r4, #0x3C]
  0006c	e5940030	 ldr         r0, [r4, #0x30]
  00070	eb000000	 bl          WaitForSingleObject
  00074	e1a05000	 mov         r5, r0
  00078	e3750001	 cmn         r5, #1
  0007c	1affffeb	 bne         |$LL4@SDControll@4|
  00080		 |$LN14@SDControll@4|

; 2824 :             DbgPrintZo(SDCARD_ZONE_WARN, 
; 2825 :                 (TEXT("SDControllerIstThread: Wait Failed! 0x%08X \n"), waitStatus));
; 2826 :                 // bail out
; 2827 :             return 0;

  00080	e3a00000	 mov         r0, #0

; 2838 :     }
; 2839 : 
; 2840 : }

  00084	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M48220|

			 ENDP  ; |SDControllerIstThread|

	EXPORT	|SDInitialize|
	IMPORT	|SetupCardDetectIST|
	IMPORT	|CreateThread|
	IMPORT	|KernelLibIoControl|
	IMPORT	|BusTransBusAddrToStatic|
	IMPORT	|LoadIntChainHandler|
	IMPORT	|HalAllocateCommonBuffer|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|BusTransBusAddrToVirtual|
	IMPORT	|InitializeHardware|
	IMPORT	|GetSystemInfo|
	IMPORT	|InitializeCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T48253| DCD	|$LN33@SDInitiali|
	DCD	0x40016002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SDInitialize| PROC

; 558  : {

  00000		 |$LN33@SDInitiali|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd060	 sub         sp, sp, #0x60
  00008		 |$M48250|
  00008	e1a07000	 mov         r7, r0

; 559  :     ULONG fInIOSpace;
; 560  :     DWORD dwSDIOIrq;
; 561  :     DWORD dwRegVal;                                 // intermediate value
; 562  :     SD_API_STATUS status = SD_API_STATUS_SUCCESS;   // intermediate status
; 563  :     DWORD         threadID;                         // thread ID
; 564  :     PSDH_HARDWARE_CONTEXT pHardwareContext;       // hardware context
; 565  :     PHYSICAL_ADDRESS Bulverde_GPIO_Base = {BULVERDE_BASE_REG_PA_GPIO};
; 566  :     PHYSICAL_ADDRESS Bulverde_SDMMC_Base = {BULVERDE_BASE_REG_PA_MMC};
; 567  :     PHYSICAL_ADDRESS Bulverde_CLKMGR_Base = {BULVERDE_BASE_REG_PA_CLKMGR};
; 568  :     PHYSICAL_ADDRESS Bulverde_DMA_Base = {BULVERDE_BASE_REG_PA_DMAC};
; 569  : 
; 570  :     pHardwareContext = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);

  0000c	e597504c	 ldr         r5, [r7, #0x4C]
  00010	e3a02101	 mov         r2, #1, 2
  00014	e3a00441	 mov         r0, #0x41, 8

; 571  : 
; 572  :     InitializeCriticalSection(&pHardwareContext->ControllerCriticalSection);

  00018	e2853c0a	 add         r3, r5, #0xA, 24
  0001c	e3a06101	 mov         r6, #1, 2
  00020	e382260e	 orr         r2, r2, #0xE, 12
  00024	e3801601	 orr         r1, r0, #1, 12
  00028	e380e603	 orr         lr, r0, #3, 12
  0002c	e3a0a000	 mov         r10, #0
  00030	e3a09000	 mov         r9, #0
  00034	e3a08000	 mov         r8, #0
  00038	e3a04000	 mov         r4, #0
  0003c	e28300d4	 add         r0, r3, #0xD4
  00040	e58d6034	 str         r6, [sp, #0x34]
  00044	e58d2020	 str         r2, [sp, #0x20]
  00048	e58d1018	 str         r1, [sp, #0x18]
  0004c	e58de02c	 str         lr, [sp, #0x2C]
  00050	e3a06000	 mov         r6, #0
  00054	e58da024	 str         r10, [sp, #0x24]
  00058	e58d901c	 str         r9, [sp, #0x1C]
  0005c	e58d8030	 str         r8, [sp, #0x30]
  00060	e58d4038	 str         r4, [sp, #0x38]
  00064	eb000000	 bl          InitializeCriticalSection

; 573  : 
; 574  :     pHardwareContext->fSDIOEnabled = FALSE;

  00068	e3a09000	 mov         r9, #0

; 575  :     pHardwareContext->pCurrentRequest = NULL ;
; 576  :     pHardwareContext->fSDIOInterruptPending = FALSE;
; 577  :     pHardwareContext->f4BitMode = FALSE;
; 578  :     pHardwareContext->DevicePresent = FALSE;
; 579  :     pHardwareContext->hDMAInterruptEvent = NULL;
; 580  :     pHardwareContext->hDMAIsrHandler = NULL;
; 581  :     pHardwareContext->DriverShutdown = FALSE;
; 582  :     pHardwareContext->hDMAInterruptEvent = NULL;
; 583  :     pHardwareContext->hDmaInterruptThread = NULL;
; 584  :     pHardwareContext->pDMABuffer = NULL;
; 585  :     pHardwareContext->pDMADescriptors = NULL;
; 586  :     pHardwareContext->dwControllerIstTimeout = INFINITE;

  0006c	e3e0a000	 mvn         r10, #0

; 587  :     InitializeCriticalSection(&pHardwareContext->intrRegCriticalSection);

  00070	e2850ed5	 add         r0, r5, #0xD5, 28
  00074	e5859d30	 str         r9, [r5, #0xD30]
  00078	e585901c	 str         r9, [r5, #0x1C]
  0007c	e5859d34	 str         r9, [r5, #0xD34]
  00080	e5859d38	 str         r9, [r5, #0xD38]
  00084	e5859d44	 str         r9, [r5, #0xD44]
  00088	e5859a94	 str         r9, [r5, #0xA94]
  0008c	e5859ad0	 str         r9, [r5, #0xAD0]
  00090	e5859a98	 str         r9, [r5, #0xA98]
  00094	e5859aa0	 str         r9, [r5, #0xAA0]
  00098	e5859068	 str         r9, [r5, #0x68]
  0009c	e5859078	 str         r9, [r5, #0x78]
  000a0	e585a03c	 str         r10, [r5, #0x3C]
  000a4	eb000000	 bl          InitializeCriticalSection

; 588  : 
; 589  : #ifdef DEBUG
; 590  :     pHardwareContext->fDMATransferInProgress = FALSE;
; 591  : #endif
; 592  :     
; 593  :     GetSystemInfo( &pHardwareContext->systemInfo );

  000a8	e2850044	 add         r0, r5, #0x44
  000ac	eb000000	 bl          GetSystemInfo

; 594  : 
; 595  :     if( !InitializeHardware( pHardwareContext->hBusAccessHandle ) )

  000b0	e5950014	 ldr         r0, [r5, #0x14]
  000b4	eb000000	 bl          InitializeHardware
  000b8	e3500000	 cmp         r0, #0
  000bc	0a000128	 beq         |$LN1@SDInitiali|

; 596  :     {
; 597  : 		DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error initializing platform specific hardware\r\n")));
; 598  :         goto exitInit;
; 599  :     }
; 600  : 
; 601  :     if( !BusTransBusAddrToVirtual( pHardwareContext->hBusAccessHandle, Internal, 0, Bulverde_GPIO_Base, sizeof(BULVERDE_GPIO_REG), &fInIOSpace, (PPVOID)&(pHardwareContext->pGPIORegisters) ) )

  000c0	e59d2024	 ldr         r2, [sp, #0x24]
  000c4	e59d3020	 ldr         r3, [sp, #0x20]
  000c8	e5950014	 ldr         r0, [r5, #0x14]
  000cc	e58d2000	 str         r2, [sp]
  000d0	e28de010	 add         lr, sp, #0x10
  000d4	e3a04f53	 mov         r4, #0x53, 30
  000d8	e3a02000	 mov         r2, #0
  000dc	e3a01000	 mov         r1, #0
  000e0	e58d500c	 str         r5, [sp, #0xC]
  000e4	e58de008	 str         lr, [sp, #8]
  000e8	e58d4004	 str         r4, [sp, #4]
  000ec	eb000000	 bl          BusTransBusAddrToVirtual
  000f0	e3500000	 cmp         r0, #0
  000f4	0a00011a	 beq         |$LN1@SDInitiali|

; 602  : 	{
; 603  : 		DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error allocating Bulverde GPIO registers\r\n")));
; 604  :         goto exitInit;
; 605  : 	}
; 606  : 
; 607  :     if( !BusTransBusAddrToVirtual( pHardwareContext->hBusAccessHandle, Internal, 0, Bulverde_SDMMC_Base, sizeof(BULVERDE_MMC_REG), &fInIOSpace, (PPVOID)&(pHardwareContext->pSDMMCRegisters) ) )

  000f8	e59d201c	 ldr         r2, [sp, #0x1C]
  000fc	e59d3018	 ldr         r3, [sp, #0x18]
  00100	e5950014	 ldr         r0, [r5, #0x14]
  00104	e58d2000	 str         r2, [sp]
  00108	e285e004	 add         lr, r5, #4
  0010c	e28d4010	 add         r4, sp, #0x10
  00110	e3a08048	 mov         r8, #0x48
  00114	e3a02000	 mov         r2, #0
  00118	e3a01000	 mov         r1, #0
  0011c	e58de00c	 str         lr, [sp, #0xC]
  00120	e58d4008	 str         r4, [sp, #8]
  00124	e58d8004	 str         r8, [sp, #4]
  00128	eb000000	 bl          BusTransBusAddrToVirtual
  0012c	e3500000	 cmp         r0, #0
  00130	0a00010b	 beq         |$LN1@SDInitiali|

; 608  : 	{
; 609  : 		DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error allocating Bulverde SD/MMC registers\r\n")));
; 610  :         goto exitInit;
; 611  : 	}
; 612  : 
; 613  :     if( !BusTransBusAddrToVirtual( pHardwareContext->hBusAccessHandle, Internal, 0, Bulverde_CLKMGR_Base, sizeof(BULVERDE_CLKMGR_REG), &fInIOSpace, (PPVOID)&(pHardwareContext->pClkMgrRegisters) ) )

  00134	e59d2030	 ldr         r2, [sp, #0x30]
  00138	e59d302c	 ldr         r3, [sp, #0x2C]
  0013c	e5950014	 ldr         r0, [r5, #0x14]
  00140	e58d2000	 str         r2, [sp]
  00144	e285e008	 add         lr, r5, #8
  00148	e28d4010	 add         r4, sp, #0x10
  0014c	e3a08010	 mov         r8, #0x10
  00150	e3a02000	 mov         r2, #0
  00154	e3a01000	 mov         r1, #0
  00158	e58de00c	 str         lr, [sp, #0xC]
  0015c	e58d4008	 str         r4, [sp, #8]
  00160	e58d8004	 str         r8, [sp, #4]
  00164	eb000000	 bl          BusTransBusAddrToVirtual
  00168	e3500000	 cmp         r0, #0
  0016c	0a0000fc	 beq         |$LN1@SDInitiali|

; 614  : 	{
; 615  : 		DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error allocating Bulverde Clock control registers\r\n")));
; 616  :         goto exitInit;
; 617  : 	}
; 618  : 
; 619  :     if( !BusTransBusAddrToVirtual( pHardwareContext->hBusAccessHandle, Internal, 0, Bulverde_DMA_Base, sizeof(BULVERDE_DMA_REG), &fInIOSpace, (PPVOID)&(pHardwareContext->pDMARegisters) ) )

  00170	e59d1038	 ldr         r1, [sp, #0x38]
  00174	e3a02c11	 mov         r2, #0x11, 24
  00178	e59d3034	 ldr         r3, [sp, #0x34]
  0017c	e5950014	 ldr         r0, [r5, #0x14]
  00180	e382202c	 orr         r2, r2, #0x2C
  00184	e58d2004	 str         r2, [sp, #4]
  00188	e58d1000	 str         r1, [sp]
  0018c	e285e00c	 add         lr, r5, #0xC
  00190	e28d4010	 add         r4, sp, #0x10
  00194	e3a02000	 mov         r2, #0
  00198	e3a01000	 mov         r1, #0
  0019c	e58de00c	 str         lr, [sp, #0xC]
  001a0	e58d4008	 str         r4, [sp, #8]
  001a4	eb000000	 bl          BusTransBusAddrToVirtual
  001a8	e3500000	 cmp         r0, #0
  001ac	0a0000ec	 beq         |$LN1@SDInitiali|

; 620  : 	{
; 621  : 		DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("InitializeHardware:: Error allocating Bulverde DMA control registers\r\n")));
; 622  :         goto exitInit;
; 623  : 	}
; 624  : 
; 625  :     // enable the MMC Unit Clock
; 626  :     dwRegVal = pHardwareContext->pClkMgrRegisters->cken;

  001b0	e5951008	 ldr         r1, [r5, #8]

; 627  :     dwRegVal |= (1 << 12);
; 628  :     pHardwareContext->pClkMgrRegisters->cken = dwRegVal;
; 629  : 
; 630  :     //////////////////////////////////////////////////////////
; 631  :     // Configure GPIO_32 as Alternate Function 2 out (MMC_CLK)
; 632  : 
; 633  :     // assume that the MMC_CLK is active-low signal driven
; 634  :     dwRegVal = pHardwareContext->pGPIORegisters->GPCR1;
; 635  :     dwRegVal |= 0x00000001;
; 636  :     pHardwareContext->pGPIORegisters->GPCR1 = dwRegVal;
; 637  :     // change the direction to OUT
; 638  :     dwRegVal = pHardwareContext->pGPIORegisters->GPDR1;
; 639  :     dwRegVal |= 0x00000001;
; 640  :     pHardwareContext->pGPIORegisters->GPDR1 = dwRegVal;
; 641  :     // change to Alternate Function 2
; 642  :     dwRegVal = pHardwareContext->pGPIORegisters->GAFR1_L;
; 643  :     dwRegVal = ( dwRegVal & 0xfffffffc ) | 0x00000002;
; 644  :     pHardwareContext->pGPIORegisters->GAFR1_L = dwRegVal;
; 645  :     
; 646  :     //////////////////////////////////////////////////////////
; 647  :     // Configure GPIO_112 as Alternate Function 1 (MMC_CMD)
; 648  : 
; 649  :     // assume that the MMC_CLK is active-high signal driven
; 650  :     dwRegVal = pHardwareContext->pGPIORegisters->GPSR3;
; 651  :     dwRegVal |= 0x00010000;
; 652  :     pHardwareContext->pGPIORegisters->GPSR3 = dwRegVal;
; 653  :     // change the direction to OUT
; 654  :     dwRegVal = pHardwareContext->pGPIORegisters->GPDR3;
; 655  :     dwRegVal |= 0x00010000;
; 656  :     pHardwareContext->pGPIORegisters->GPDR3 = dwRegVal;
; 657  :     // change to Alternate Function 1
; 658  :     dwRegVal = pHardwareContext->pGPIORegisters->GAFR3_U;
; 659  :     dwRegVal = ( dwRegVal & 0xfffffffc ) | 0x00000001;
; 660  :     pHardwareContext->pGPIORegisters->GAFR3_U = dwRegVal;
; 661  :     
; 662  :     //////////////////////////////////////////////////////////
; 663  :     // Configure GPIO_92 as Alternate Function 1 (MMC_DAT0)
; 664  :     
; 665  :     // assume that the MMC_CLK is active-high signal driven
; 666  :     dwRegVal = pHardwareContext->pGPIORegisters->GPSR2;
; 667  :     dwRegVal |= 0x10000000;
; 668  :     pHardwareContext->pGPIORegisters->GPSR2 = dwRegVal;
; 669  :     // change the direction to OUT
; 670  :     dwRegVal = pHardwareContext->pGPIORegisters->GPDR2;
; 671  :     dwRegVal |= 0x10000000;
; 672  :     pHardwareContext->pGPIORegisters->GPDR2 = dwRegVal;
; 673  :     // change to Alternate Function 1
; 674  :     dwRegVal = pHardwareContext->pGPIORegisters->GAFR2_U;
; 675  :     dwRegVal = ( dwRegVal & 0xfcffffff ) | 0x01000000;
; 676  :     pHardwareContext->pGPIORegisters->GAFR2_U = dwRegVal;
; 677  :     
; 678  :     //////////////////////////////////////////////////////////
; 679  :     // Configure GPIO_109-GPIO_111 as Alternate Function 1 (MMC_DAT1-MMC_DAT3)
; 680  : 
; 681  :     // assume that the MMC_CLK is active-high signal driven
; 682  :     dwRegVal = pHardwareContext->pGPIORegisters->GPSR3;
; 683  :     dwRegVal |= 0x0000e000;
; 684  :     pHardwareContext->pGPIORegisters->GPSR3 = dwRegVal;
; 685  :     // change the direction to OUT
; 686  :     dwRegVal = pHardwareContext->pGPIORegisters->GPDR3;
; 687  :     dwRegVal |= 0x0000e000;
; 688  :     pHardwareContext->pGPIORegisters->GPDR3 = dwRegVal;
; 689  :     // change to Alternate Function 1
; 690  :     dwRegVal = pHardwareContext->pGPIORegisters->GAFR3_L;
; 691  :     dwRegVal = ( dwRegVal & 0x03ffffff ) | 0x54000000;
; 692  :     pHardwareContext->pGPIORegisters->GAFR3_L = dwRegVal;
; 693  : 
; 694  : #ifdef DEBUG
; 695  :     DumpRegisters( pHardwareContext );
; 696  :     DumpGPIORegisters( pHardwareContext );
; 697  : #endif
; 698  : 
; 699  :     // allocate the interrupt event
; 700  :     pHardwareContext->hControllerInterruptEvent = CreateEvent(NULL, FALSE, FALSE,NULL);

  001b4	e3a03000	 mov         r3, #0
  001b8	e3a00000	 mov         r0, #0
  001bc	e5912004	 ldr         r2, [r1, #4]
  001c0	e3822a01	 orr         r2, r2, #1, 20
  001c4	e5812004	 str         r2, [r1, #4]
  001c8	e5954000	 ldr         r4, [r5]
  001cc	e3a02000	 mov         r2, #0
  001d0	e3a01000	 mov         r1, #0
  001d4	e594e028	 ldr         lr, [r4, #0x28]
  001d8	e38ee001	 orr         lr, lr, #1
  001dc	e584e028	 str         lr, [r4, #0x28]
  001e0	e5954000	 ldr         r4, [r5]
  001e4	e594e010	 ldr         lr, [r4, #0x10]
  001e8	e38ee001	 orr         lr, lr, #1
  001ec	e584e010	 str         lr, [r4, #0x10]
  001f0	e5954000	 ldr         r4, [r5]
  001f4	e594e05c	 ldr         lr, [r4, #0x5C]
  001f8	e3cee003	 bic         lr, lr, #3
  001fc	e38ee002	 orr         lr, lr, #2
  00200	e584e05c	 str         lr, [r4, #0x5C]
  00204	e5954000	 ldr         r4, [r5]
  00208	e594e118	 ldr         lr, [r4, #0x118]
  0020c	e38ee801	 orr         lr, lr, #1, 16
  00210	e584e118	 str         lr, [r4, #0x118]
  00214	e5954000	 ldr         r4, [r5]
  00218	e594e10c	 ldr         lr, [r4, #0x10C]
  0021c	e38ee801	 orr         lr, lr, #1, 16
  00220	e584e10c	 str         lr, [r4, #0x10C]
  00224	e5954000	 ldr         r4, [r5]
  00228	e594e070	 ldr         lr, [r4, #0x70]
  0022c	e3cee003	 bic         lr, lr, #3
  00230	e38ee001	 orr         lr, lr, #1
  00234	e584e070	 str         lr, [r4, #0x70]
  00238	e5954000	 ldr         r4, [r5]
  0023c	e594e020	 ldr         lr, [r4, #0x20]
  00240	e38ee201	 orr         lr, lr, #1, 4
  00244	e584e020	 str         lr, [r4, #0x20]
  00248	e5954000	 ldr         r4, [r5]
  0024c	e594e014	 ldr         lr, [r4, #0x14]
  00250	e38ee201	 orr         lr, lr, #1, 4
  00254	e584e014	 str         lr, [r4, #0x14]
  00258	e5954000	 ldr         r4, [r5]
  0025c	e594e068	 ldr         lr, [r4, #0x68]
  00260	e3cee403	 bic         lr, lr, #3, 8
  00264	e38ee401	 orr         lr, lr, #1, 8
  00268	e584e068	 str         lr, [r4, #0x68]
  0026c	e5954000	 ldr         r4, [r5]
  00270	e594e118	 ldr         lr, [r4, #0x118]
  00274	e38eea0e	 orr         lr, lr, #0xE, 20
  00278	e584e118	 str         lr, [r4, #0x118]
  0027c	e5954000	 ldr         r4, [r5]
  00280	e594e10c	 ldr         lr, [r4, #0x10C]
  00284	e38eea0e	 orr         lr, lr, #0xE, 20
  00288	e584e10c	 str         lr, [r4, #0x10C]
  0028c	e5954000	 ldr         r4, [r5]
  00290	e594e06c	 ldr         lr, [r4, #0x6C]
  00294	e3cee33f	 bic         lr, lr, #0x3F, 6
  00298	e38ee315	 orr         lr, lr, #0x15, 6
  0029c	e584e06c	 str         lr, [r4, #0x6C]
  002a0	eb000000	 bl          CreateEventW
  002a4	e3500000	 cmp         r0, #0
  002a8	e5850030	 str         r0, [r5, #0x30]

; 701  :     
; 702  :     if (NULL == pHardwareContext->hControllerInterruptEvent) {
; 703  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 704  :         goto exitInit;

  002ac	0a0000a9	 beq         |$LN29@SDInitiali|

; 705  :     }
; 706  : 
; 707  :         // convert the hardware SD/MMC controller interrupt IRQ into a logical SYSINTR value
; 708  :     dwSDIOIrq = pHardwareContext->dwSDMMCIrq;

  002b0	e5953028	 ldr         r3, [r5, #0x28]

; 709  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, &dwSDIOIrq, sizeof(DWORD), &(pHardwareContext->dwSysintrSDMMC), sizeof(DWORD), NULL))

  002b4	e59f02c0	 ldr         r0, [pc, #0x2C0]
  002b8	e3a08004	 mov         r8, #4
  002bc	e58d3014	 str         r3, [sp, #0x14]
  002c0	e285302c	 add         r3, r5, #0x2C
  002c4	e3a02004	 mov         r2, #4
  002c8	e28d1014	 add         r1, sp, #0x14
  002cc	e58d9004	 str         r9, [sp, #4]
  002d0	e58d8000	 str         r8, [sp]
  002d4	eb000000	 bl          KernelIoControl
  002d8	e3500000	 cmp         r0, #0

; 710  :     {
; 711  :         // invalid SDIO SYSINTR value!
; 712  :         DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("Error obtaining SDIO SYSINTR value!\n")));
; 713  :         pHardwareContext->dwSysintrSDMMC = SYSINTR_UNDEFINED;

  002dc	0585a02c	 streq       r10, [r5, #0x2C]
  002e0	0a00009f	 beq         |$LN1@SDInitiali|

; 714  :         goto exitInit;
; 715  :     }
; 716  : 
; 717  :         // initialize the interrupt event
; 718  :     if (!InterruptInitialize (pHardwareContext->dwSysintrSDMMC,
; 719  :                               pHardwareContext->hControllerInterruptEvent,
; 720  :                               NULL,
; 721  :                               0)) {

  002e4	e5951030	 ldr         r1, [r5, #0x30]
  002e8	e595002c	 ldr         r0, [r5, #0x2C]
  002ec	e3a03000	 mov         r3, #0
  002f0	e3a02000	 mov         r2, #0
  002f4	eb000000	 bl          InterruptInitialize
  002f8	e3500000	 cmp         r0, #0

; 722  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 723  :         goto exitInit;

  002fc	0a000095	 beq         |$LN29@SDInitiali|

; 724  :     }
; 725  : 
; 726  :     if( pHardwareContext->dwDmaChannel != 0xffffffff )

  00300	e5953aa4	 ldr         r3, [r5, #0xAA4]
  00304	e3730001	 cmn         r3, #1
  00308	0a000083	 beq         |$LN4@SDInitiali|

; 727  :     {
; 728  :         // allocate the DMA interrupt event
; 729  :         pHardwareContext->hDMAInterruptEvent = CreateEvent(NULL, FALSE, FALSE,NULL);

  0030c	e3a03000	 mov         r3, #0
  00310	e3a02000	 mov         r2, #0
  00314	e3a01000	 mov         r1, #0
  00318	e3a00000	 mov         r0, #0
  0031c	eb000000	 bl          CreateEventW

; 730  : 
; 731  :         if( pHardwareContext->dwDmaSysIntr == SYSINTR_UNDEFINED )

  00320	e5953a90	 ldr         r3, [r5, #0xA90]
  00324	e5850a98	 str         r0, [r5, #0xA98]
  00328	e3730001	 cmn         r3, #1
  0032c	1a00000b	 bne         |$LN15@SDInitiali|

; 732  :         {
; 733  :                 // convert the hardware DMA controller interrupt IRQ into a logical SYSINTR value
; 734  :             DWORD dwDMAIrq = pHardwareContext->dwDmaIRQ;

  00330	e5951a8c	 ldr         r1, [r5, #0xA8C]

; 735  :             if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, &dwDMAIrq, sizeof(DWORD), &(pHardwareContext->dwDmaSysIntr), sizeof(DWORD), NULL))

  00334	e59f0240	 ldr         r0, [pc, #0x240]
  00338	e2853ea9	 add         r3, r5, #0xA9, 28
  0033c	e58d1018	 str         r1, [sp, #0x18]
  00340	e28d1018	 add         r1, sp, #0x18
  00344	e3a02004	 mov         r2, #4
  00348	e58d9004	 str         r9, [sp, #4]
  0034c	e58d8000	 str         r8, [sp]
  00350	eb000000	 bl          KernelIoControl
  00354	e3500000	 cmp         r0, #0

; 736  :             {
; 737  :                 // invalid SDIO SYSINTR value!
; 738  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("Error obtaining DMA SYSINTR value!\n")));
; 739  :                 pHardwareContext->dwDmaSysIntr = SYSINTR_UNDEFINED;

  00358	0585aa90	 streq       r10, [r5, #0xA90]
  0035c	0a00007d	 beq         |$LN29@SDInitiali|
  00360		 |$LN15@SDInitiali|

; 740  :                 status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 741  :                 goto exitInit;
; 742  :             }
; 743  :         }
; 744  : 
; 745  :         // allocate the DMA data & descriptors buffers
; 746  :         if( pHardwareContext->dwDmaBufferSize )

  00360	e5953088	 ldr         r3, [r5, #0x88]
  00364	e1b01003	 movs        r1, r3
  00368	0a000023	 beq         |$LN10@SDInitiali|

; 747  :         {
; 748  :             DMA_ADAPTER_OBJECT dmaAdapter;
; 749  :             dmaAdapter.ObjectSize = sizeof(dmaAdapter);

  0036c	e3a0300c	 mov         r3, #0xC

; 750  :             dmaAdapter.InterfaceType = Internal;

  00370	e3a02000	 mov         r2, #0

; 751  :             dmaAdapter.BusNumber = 0;

  00374	e3a00000	 mov         r0, #0
  00378	e1cd33b4	 strh        r3, [sp, #0x34]
  0037c	e58d2038	 str         r2, [sp, #0x38]
  00380	e58d003c	 str         r0, [sp, #0x3C]

; 752  :             pHardwareContext->pDMABuffer = (PBYTE)HalAllocateCommonBuffer( &dmaAdapter, 
; 753  :                                                                            pHardwareContext->dwDmaBufferSize,
; 754  :                                                                            &pHardwareContext->pDMABufferPhys,
; 755  :                                                                            FALSE );

  00384	e3a03000	 mov         r3, #0
  00388	e2852070	 add         r2, r5, #0x70
  0038c	e28d0034	 add         r0, sp, #0x34
  00390	eb000000	 bl          HalAllocateCommonBuffer
  00394	e3500000	 cmp         r0, #0
  00398	e5850068	 str         r0, [r5, #0x68]

; 756  :             if( pHardwareContext->pDMABuffer == NULL )
; 757  :             {
; 758  :                 DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SHCDriver: - Unable to allocate memory for DMA buffers!\r\n")));
; 759  :                 pHardwareContext->dwDmaBufferSize = 0;
; 760  :             }
; 761  :             else

  0039c	0a000015	 beq         |$LN30@SDInitiali|

; 762  :             { // allocate DMA descriptors
; 763  :                 DWORD dwDescriptorsSize = pHardwareContext->dwDmaBufferSize / pHardwareContext->systemInfo.dwPageSize;

  003a0	e5951088	 ldr         r1, [r5, #0x88]
  003a4	e5950048	 ldr         r0, [r5, #0x48]
  003a8	eb000000	 bl          __rt_udiv
  003ac	e3510000	 cmp         r1, #0

; 764  :                 if( pHardwareContext->dwDmaBufferSize % pHardwareContext->systemInfo.dwPageSize )
; 765  :                 {
; 766  :                     dwDescriptorsSize++;

  003b0	12800001	 addne       r0, r0, #1

; 767  :                 }
; 768  :                 dwDescriptorsSize *= sizeof(DMADescriptorChannelType);
; 769  :                 
; 770  :                 pHardwareContext->pDMADescriptors = (volatile DMADescriptorChannelType*)HalAllocateCommonBuffer( &dmaAdapter, 
; 771  :                                                                                dwDescriptorsSize,
; 772  :                                                                                &pHardwareContext->pDMADescriptorsPhys,
; 773  :                                                                                FALSE );

  003b4	e1a01200	 mov         r1, r0, lsl #4
  003b8	e28d0034	 add         r0, sp, #0x34
  003bc	e3a03000	 mov         r3, #0
  003c0	e2852080	 add         r2, r5, #0x80
  003c4	eb000000	 bl          HalAllocateCommonBuffer
  003c8	e3500000	 cmp         r0, #0
  003cc	e5850078	 str         r0, [r5, #0x78]

; 774  :                 if( pHardwareContext->pDMADescriptors == NULL )

  003d0	1a000009	 bne         |$LN10@SDInitiali|

; 775  :                 {
; 776  :                     DEBUGMSG(SDCARD_ZONE_WARN, (TEXT("SHCDriver: - Unable to allocate memory for DMA descriptors!\r\n")));
; 777  :                     HalFreeCommonBuffer( &dmaAdapter, 
; 778  :                                            pHardwareContext->dwDmaBufferSize,
; 779  :                                            pHardwareContext->pDMABufferPhys,
; 780  :                                            pHardwareContext->pDMABuffer,
; 781  :                                            FALSE );

  003d4	e5950068	 ldr         r0, [r5, #0x68]
  003d8	e5952070	 ldr         r2, [r5, #0x70]
  003dc	e5953074	 ldr         r3, [r5, #0x74]
  003e0	e5951088	 ldr         r1, [r5, #0x88]
  003e4	e58d0000	 str         r0, [sp]
  003e8	e28d0034	 add         r0, sp, #0x34
  003ec	e58d9004	 str         r9, [sp, #4]
  003f0	eb000000	 bl          HalFreeCommonBuffer

; 782  :                     pHardwareContext->pDMABuffer = NULL;

  003f4	e5859068	 str         r9, [r5, #0x68]
  003f8		 |$LN30@SDInitiali|

; 783  :                     pHardwareContext->dwDmaBufferSize = 0;

  003f8	e5859088	 str         r9, [r5, #0x88]
  003fc		 |$LN10@SDInitiali|

; 784  :                 }
; 785  :             }
; 786  :         }
; 787  : 
; 788  :             // install the DMA ISR handler
; 789  :         if( pHardwareContext->wszDmaIsrDll[0] )

  003fc	e1d538bc	 ldrh        r3, [r5, #0x8C]
  00400	e3530000	 cmp         r3, #0
  00404	0a000032	 beq         |$LN6@SDInitiali|

; 790  :         {
; 791  :             GIISR_INFO Info;
; 792  :             PVOID PhysAddr;
; 793  :             DWORD inIoSpace = 0;    // io space
; 794  :             PHYSICAL_ADDRESS DmaRegisterAddress = {DMA_INTERRUPT_REGISTER, 0}; 
; 795  :             
; 796  :             pHardwareContext->hDMAIsrHandler = LoadIntChainHandler(pHardwareContext->wszDmaIsrDll, 
; 797  :                                                                      pHardwareContext->wszDmaIsrHandler,
; 798  :                                                                      (BYTE)pHardwareContext->dwDmaIRQ);

  00408	e5953a8c	 ldr         r3, [r5, #0xA8C]
  0040c	e2851b02	 add         r1, r5, #2, 22
  00410	e3a0e000	 mov         lr, #0
  00414	e20320ff	 and         r2, r3, #0xFF
  00418	e281108c	 add         r1, r1, #0x8C
  0041c	e285008c	 add         r0, r5, #0x8C
  00420	e3a09101	 mov         r9, #1, 2
  00424	e58de018	 str         lr, [sp, #0x18]
  00428	e3a0a000	 mov         r10, #0
  0042c	eb000000	 bl          LoadIntChainHandler
  00430	e3500000	 cmp         r0, #0
  00434	e5850a94	 str         r0, [r5, #0xA94]

; 799  :             if (pHardwareContext->hDMAIsrHandler == NULL) {
; 800  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (TEXT("LoadIntChainHandler (%s, %s, %d) failed!\r\n"),
; 801  :                                             pHardwareContext->wszDmaIsrDll, 
; 802  :                                             pHardwareContext->wszDmaIsrHandler,
; 803  :                                             (BYTE)pHardwareContext->dwDmaIRQ));
; 804  :                 status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 805  :                 goto exitInit;

  00438	0a000046	 beq         |$LN29@SDInitiali|

; 806  :             }
; 807  : 
; 808  :             if (!BusTransBusAddrToStatic(pHardwareContext->hBusAccessHandle, Internal, 0, DmaRegisterAddress, sizeof(DWORD), &inIoSpace, &PhysAddr)) {

  0043c	e5950014	 ldr         r0, [r5, #0x14]
  00440	e28de020	 add         lr, sp, #0x20
  00444	e28d4018	 add         r4, sp, #0x18
  00448	e38930f0	 orr         r3, r9, #0xF0
  0044c	e3a02000	 mov         r2, #0
  00450	e3a01000	 mov         r1, #0
  00454	e58de00c	 str         lr, [sp, #0xC]
  00458	e58d4008	 str         r4, [sp, #8]
  0045c	e58d8004	 str         r8, [sp, #4]
  00460	e58da000	 str         r10, [sp]
  00464	eb000000	 bl          BusTransBusAddrToStatic
  00468	e3500000	 cmp         r0, #0

; 809  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"SDHC: Failed TransBusAddrToStatic\r\n"));
; 810  :                 status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 811  :                 goto exitInit;

  0046c	0a000039	 beq         |$LN29@SDInitiali|

; 812  :             }
; 813  :             
; 814  :             DEBUGMSG(SDCARD_ZONE_INIT, (L"SDHC: Installed ISR handler, Dll = '%s', Handler = '%s', Irq = %d, PhysAddr = 0x%x\r\n", 
; 815  :                 pHardwareContext->wszDmaIsrDll, pHardwareContext->wszDmaIsrHandler, pHardwareContext->dwDmaIRQ, PhysAddr));
; 816  : 
; 817  :             // Set up ISR handler
; 818  :             Info.SysIntr = pHardwareContext->dwDmaSysIntr;
; 819  :             Info.CheckPort = TRUE;
; 820  :             Info.PortIsIO = FALSE;
; 821  :             Info.UseMaskReg = FALSE;
; 822  :             Info.PortAddr = (DWORD)PhysAddr;
; 823  :             Info.PortSize = sizeof(DWORD);
; 824  :             Info.Mask = 1 << pHardwareContext->dwDmaChannel;

  00470	e5953aa4	 ldr         r3, [r5, #0xAA4]
  00474	e3a02001	 mov         r2, #1
  00478	e595ea90	 ldr         lr, [r5, #0xA90]
  0047c	e59d4020	 ldr         r4, [sp, #0x20]
  00480	e1a03312	 mov         r3, r2, lsl r3

; 825  :             
; 826  :             if (!KernelLibIoControl(pHardwareContext->hDMAIsrHandler, IOCTL_GIISR_INFO, &Info, sizeof(Info), NULL, 0, NULL)) {

  00484	e5950a94	 ldr         r0, [r5, #0xA94]
  00488	e3a09000	 mov         r9, #0
  0048c	e58d9048	 str         r9, [sp, #0x48]
  00490	e58d3058	 str         r3, [sp, #0x58]
  00494	e3a08001	 mov         r8, #1
  00498	e3a0a000	 mov         r10, #0
  0049c	e3a0b004	 mov         r11, #4
  004a0	e3a09000	 mov         r9, #0
  004a4	e3a03020	 mov         r3, #0x20
  004a8	e28d2040	 add         r2, sp, #0x40
  004ac	e3a01c01	 mov         r1, #1, 24
  004b0	e58de040	 str         lr, [sp, #0x40]
  004b4	e58d8044	 str         r8, [sp, #0x44]
  004b8	e58da04c	 str         r10, [sp, #0x4C]
  004bc	e58d4050	 str         r4, [sp, #0x50]
  004c0	e58db054	 str         r11, [sp, #0x54]
  004c4	e58d9008	 str         r9, [sp, #8]
  004c8	e58d9004	 str         r9, [sp, #4]
  004cc	e58d9000	 str         r9, [sp]
  004d0	eb000000	 bl          KernelLibIoControl
  004d4		 |$LN6@SDInitiali|

; 827  :                 DEBUGMSG(SDCARD_ZONE_ERROR, (L"SDHC: KernelLibIoControl call failed.\r\n"));
; 828  :             }
; 829  :         }
; 830  : 
; 831  :             // initialize the DMA interrupt event
; 832  :         if (!InterruptInitialize (pHardwareContext->dwDmaSysIntr,
; 833  :                                   pHardwareContext->hDMAInterruptEvent,
; 834  :                                   NULL,
; 835  :                                   0)) {

  004d4	e5951a98	 ldr         r1, [r5, #0xA98]
  004d8	e5950a90	 ldr         r0, [r5, #0xA90]
  004dc	e3a03000	 mov         r3, #0
  004e0	e3a02000	 mov         r2, #0
  004e4	eb000000	 bl          InterruptInitialize
  004e8	e3500000	 cmp         r0, #0

; 836  :             status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 837  :             goto exitInit;

  004ec	0a000019	 beq         |$LN29@SDInitiali|

; 838  :         }
; 839  : 
; 840  :             // create the interrupt thread for controller interrupts
; 841  :         pHardwareContext->hDmaInterruptThread = CreateThread(NULL,
; 842  :                                                           0,
; 843  :                                                           (LPTHREAD_START_ROUTINE)SDDMAIstThread,
; 844  :                                                           pHardwareContext,
; 845  :                                                           0,
; 846  :                                                           &threadID);

  004f0	e59f2080	 ldr         r2, [pc, #0x80]
  004f4	e28de028	 add         lr, sp, #0x28
  004f8	e1a03005	 mov         r3, r5
  004fc	e3a01000	 mov         r1, #0
  00500	e3a00000	 mov         r0, #0
  00504	e58de004	 str         lr, [sp, #4]
  00508	e58d9000	 str         r9, [sp]
  0050c	eb000000	 bl          CreateThread
  00510	e3500000	 cmp         r0, #0
  00514	e5850aa0	 str         r0, [r5, #0xAA0]

; 847  : 
; 848  :         if (NULL == pHardwareContext->hDmaInterruptThread) {
; 849  :             status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 850  :             goto exitInit;

  00518	0a00000e	 beq         |$LN29@SDInitiali|
  0051c		 |$LN4@SDInitiali|

; 851  :         }
; 852  :     }
; 853  : 
; 854  :         // create the interrupt thread for controller interrupts
; 855  :     pHardwareContext->hControllerInterruptThread = CreateThread(NULL,
; 856  :                                                       0,
; 857  :                                                       (LPTHREAD_START_ROUTINE)SDControllerIstThread,
; 858  :                                                       pHardwareContext,
; 859  :                                                       0,
; 860  :                                                       &threadID);

  0051c	e59f2050	 ldr         r2, [pc, #0x50]
  00520	e28de028	 add         lr, sp, #0x28
  00524	e1a03005	 mov         r3, r5
  00528	e3a01000	 mov         r1, #0
  0052c	e3a00000	 mov         r0, #0
  00530	e58de004	 str         lr, [sp, #4]
  00534	e58d9000	 str         r9, [sp]
  00538	eb000000	 bl          CreateThread
  0053c	e3500000	 cmp         r0, #0
  00540	e5850034	 str         r0, [r5, #0x34]

; 861  : 
; 862  :     if (NULL == pHardwareContext->hControllerInterruptThread) {
; 863  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 864  :         goto exitInit;

  00544	0a000003	 beq         |$LN29@SDInitiali|

; 865  :     }
; 866  : 
; 867  :     if (!SetupCardDetectIST(pHardwareContext))

  00548	e1a00005	 mov         r0, r5
  0054c	eb000000	 bl          SetupCardDetectIST
  00550	e3500000	 cmp         r0, #0
  00554	1a000002	 bne         |$LN1@SDInitiali|
  00558		 |$LN29@SDInitiali|

; 868  :     {
; 869  :         status = SD_API_STATUS_INSUFFICIENT_RESOURCES;
; 870  :     }
; 871  : 
; 872  : exitInit:
; 873  : 
; 874  :     if (!SD_API_SUCCESS(status)) {
; 875  :             // just call the deinit handler directly to cleanup
; 876  :         SDDeinitialize(pHCContext);

  00558	e1a00007	 mov         r0, r7
  0055c	e3a0613b	 mov         r6, #0x3B, 2
  00560		 |$exitInit$43488|
  00560	eb000000	 bl          SDDeinitialize
  00564		 |$LN1@SDInitiali|

; 877  :     }
; 878  : 
; 879  :     return status;
; 880  : 
; 881  : }

  00564	e1a00006	 mov         r0, r6
  00568	e28dd060	 add         sp, sp, #0x60
  0056c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00570	e12fff1e	 bx          lr
  00574		 |$LN34@SDInitiali|
  00574		 |$LN35@SDInitiali|
  00574	00000000	 DCD         |SDControllerIstThread|
  00578		 |$LN36@SDInitiali|
  00578	00000000	 DCD         |SDDMAIstThread|
  0057c		 |$LN37@SDInitiali|
  0057c	01010098	 DCD         0x1010098
  00580		 |$M48251|

			 ENDP  ; |SDInitialize|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SDHBusRequestHandler|
	IMPORT	|InterruptMask|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T48285| DCD	|$LN21@SDHBusRequ|
	DCD	0xc0006602

  00000			 AREA	 |.xdata|, DATA
|$T48281| DCD	0xffffffe0
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T48281|

  00008		 |SDHBusRequestHandler| PROC

; 1108 : {

  00008		 |$LN21@SDHBusRequ|
  00008	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M48282|
  00010	e1a05002	 mov         r5, r2
  00014	e1a07001	 mov         r7, r1
  00018	e1a06000	 mov         r6, r0
  0001c	e59f3178	 ldr         r3, [pc, #0x178]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3000	 str         r3, [sp]

; 1109 :     SD_API_STATUS status;
; 1110 :     PSDH_HARDWARE_CONTEXT      pController;     // our controller
; 1111 :     BOOL fHandled = FALSE;
; 1112 :     const TCHAR inData[] = TEXT("SDHBusRequestHandler IN");
; 1113 :     const TCHAR OutData[] = TEXT("SDHBusRequestHandler Out");
; 1114 :     DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("+SDHBusRequestHandler pRequest=%x"),pRequest));
; 1115 :     RETAILCELOG(_CeLogEnable,CELID_RAW_WCHAR, (PVOID)inData, sizeof(inData));
; 1116 :         // get our extension 
; 1117 :     pController = GetExtensionFromHCDContext(PSDH_HARDWARE_CONTEXT, pHCContext);

  00028	e596404c	 ldr         r4, [r6, #0x4C]

; 1118 :     ACQUIRE_LOCK(pController);

  0002c	e2848c0a	 add         r8, r4, #0xA, 24
  00030	e28800d4	 add         r0, r8, #0xD4
  00034	eb000000	 bl          EnterCriticalSection

; 1119 :     if ( pController->pCurrentRequest) { // We have outstand request.

  00038	e594301c	 ldr         r3, [r4, #0x1C]
  0003c	e3a09000	 mov         r9, #0
  00040	e3530000	 cmp         r3, #0
  00044	0a000004	 beq         |$LN11@SDHBusRequ|

; 1120 :         ASSERT(FALSE);
; 1121 :         IndicateBusRequestComplete(pHCContext, pRequest, SD_API_STATUS_CANCELED);

  00048	e3a0214f	 mov         r2, #0x4F, 2
  0004c	e1a01005	 mov         r1, r5
  00050	e1a00006	 mov         r0, r6
  00054	eb000000	 bl          IndicateBusRequestComplete

; 1122 :         pController->pCurrentRequest = NULL;

  00058	e584901c	 str         r9, [r4, #0x1C]
  0005c		 |$LN11@SDHBusRequ|

; 1123 :     }
; 1124 :     pController->fCurrentRequestFastPath = FALSE;

  0005c	e5849020	 str         r9, [r4, #0x20]

; 1125 :     pController->pCurrentRequest = pRequest ;

  00060	e584501c	 str         r5, [r4, #0x1C]

; 1126 :     // if no data transfer involved, use FAST PATH
; 1127 :     if ((pRequest->SystemFlags & SD_FAST_PATH_AVAILABLE) && 
; 1128 :             !( SD_COMMAND != pRequest->TransferClass && 
; 1129 :                 pRequest->NumBlocks * pRequest->BlockSize >=  pController->dwPollingModeSize)){   // We do fast path here.

  00064	e595000c	 ldr         r0, [r5, #0xC]
  00068	e3100102	 tst         r0, #2, 2
  0006c	0a000039	 beq         |$LN10@SDHBusRequ|
  00070	e5953010	 ldr         r3, [r5, #0x10]
  00074	e3530002	 cmp         r3, #2
  00078	0a000005	 beq         |$LN9@SDHBusRequ|
  0007c	e5951040	 ldr         r1, [r5, #0x40]
  00080	e595303c	 ldr         r3, [r5, #0x3C]
  00084	e5942040	 ldr         r2, [r4, #0x40]
  00088	e0030391	 mul         r3, r1, r3
  0008c	e1530002	 cmp         r3, r2
  00090	2a000030	 bcs         |$LN10@SDHBusRequ|
  00094		 |$LN9@SDHBusRequ|

; 1130 :         pController->fCurrentRequestFastPath = TRUE;
; 1131 :         InterruptMask(pController->dwSysintrSDMMC,TRUE);

  00094	e594002c	 ldr         r0, [r4, #0x2C]
  00098	e3a03001	 mov         r3, #1
  0009c	e3a01001	 mov         r1, #1
  000a0	e5843020	 str         r3, [r4, #0x20]
  000a4	eb000000	 bl          InterruptMask

; 1132 :         InterruptMask(pController->dwDmaSysIntr,TRUE);

  000a8	e5940a90	 ldr         r0, [r4, #0xA90]
  000ac	e3a01001	 mov         r1, #1
  000b0	eb000000	 bl          InterruptMask

; 1133 :         status = SDBusIssueRequest( pHCContext, Slot, pRequest );

  000b4	e1a02005	 mov         r2, r5
  000b8	e1a01007	 mov         r1, r7
  000bc	e1a00006	 mov         r0, r6
  000c0	eb000000	 bl          SDBusIssueRequest
  000c4	e1a05000	 mov         r5, r0

; 1134 :         if( status == SD_API_STATUS_PENDING ) { // Polling for completion.

  000c8	e3550001	 cmp         r5, #1
  000cc	1a000018	 bne         |$LN4@SDHBusRequ|

; 1135 :             while (pController->pCurrentRequest && IsCardPresent()) {

  000d0	ea00000f	 b           |$LN5@SDHBusRequ|
  000d4		 |$LL7@SDHBusRequ|
  000d4	eb000000	 bl          IsCardPresent
  000d8	e3500000	 cmp         r0, #0
  000dc	0a00000f	 beq         |$LN17@SDHBusRequ|

; 1136 :                 SDControllerISTHandler(pController, !IsCardPresent());

  000e0	eb000000	 bl          IsCardPresent
  000e4	e3500000	 cmp         r0, #0
  000e8	03a01001	 moveq       r1, #1
  000ec	13a01000	 movne       r1, #0
  000f0	e1a00004	 mov         r0, r4
  000f4	eb000000	 bl          SDControllerISTHandler

; 1137 :                 if ( pController->fDMATransfer  && !pController->fDMATransferCancelled)

  000f8	e5943aa8	 ldr         r3, [r4, #0xAA8]
  000fc	e3530000	 cmp         r3, #0
  00100	0a000003	 beq         |$LN5@SDHBusRequ|
  00104	e5943ab0	 ldr         r3, [r4, #0xAB0]
  00108	e3530000	 cmp         r3, #0

; 1138 :                     HandleDMAInterrupt(pController);

  0010c	01a00004	 moveq       r0, r4
  00110	0b000000	 bleq        HandleDMAInterrupt
  00114		 |$LN5@SDHBusRequ|
  00114	e594301c	 ldr         r3, [r4, #0x1C]
  00118	e3530000	 cmp         r3, #0
  0011c	1affffec	 bne         |$LL7@SDHBusRequ|
  00120		 |$LN17@SDHBusRequ|

; 1139 :             }               
; 1140 :             status = pController->FastPathStatus;
; 1141 :             if (pController->pCurrentRequest) {

  00120	e594301c	 ldr         r3, [r4, #0x1C]
  00124	e5945024	 ldr         r5, [r4, #0x24]
  00128	e3530000	 cmp         r3, #0

; 1142 :                 ASSERT(FALSE);
; 1143 :                 status = SD_API_STATUS_DEVICE_REMOVED;

  0012c	13a05147	 movne       r5, #0x47, 2

; 1144 :                 pController->pCurrentRequest = NULL;

  00130	1584901c	 strne       r9, [r4, #0x1C]
  00134		 |$LN4@SDHBusRequ|

; 1145 :             }
; 1146 :         }
; 1147 :         if (status == SD_API_STATUS_SUCCESS) {
; 1148 :             status = SD_API_STATUS_FAST_PATH_SUCCESS;
; 1149 :         }
; 1150 :         InterruptMask(pController->dwDmaSysIntr,FALSE);

  00134	e5940a90	 ldr         r0, [r4, #0xA90]
  00138	e3550000	 cmp         r5, #0
  0013c	e3a01000	 mov         r1, #0
  00140	03a05002	 moveq       r5, #2
  00144	eb000000	 bl          InterruptMask

; 1151 :         InterruptMask(pController->dwSysintrSDMMC,FALSE);

  00148	e594002c	 ldr         r0, [r4, #0x2C]
  0014c	e3a01000	 mov         r1, #0
  00150	eb000000	 bl          InterruptMask

; 1152 :         ASSERT(pController->fCurrentRequestFastPath);
; 1153 : 
; 1154 :         fHandled = TRUE;
; 1155 :     }
; 1156 :     else {

  00154	ea000008	 b           |$LN1@SDHBusRequ|
  00158		 |$LN10@SDHBusRequ|

; 1157 :         pRequest->SystemFlags &= ~SD_FAST_PATH_AVAILABLE ;

  00158	e3c03102	 bic         r3, r0, #2, 2

; 1158 :         status = SDBusIssueRequest( pHCContext, Slot, pRequest );

  0015c	e1a00006	 mov         r0, r6
  00160	e1a02005	 mov         r2, r5
  00164	e1a01007	 mov         r1, r7
  00168	e585300c	 str         r3, [r5, #0xC]
  0016c	eb000000	 bl          SDBusIssueRequest
  00170	e1a05000	 mov         r5, r0

; 1159 :         if (status!=SD_API_STATUS_PENDING) { // This has been completed.

  00174	e3550001	 cmp         r5, #1

; 1160 :             pController->pCurrentRequest = NULL;

  00178	1584901c	 strne       r9, [r4, #0x1C]
  0017c		 |$LN1@SDHBusRequ|

; 1161 :         }
; 1162 :     }
; 1163 :     RELEASE_LOCK(pController);

  0017c	e28800d4	 add         r0, r8, #0xD4
  00180	eb000000	 bl          LeaveCriticalSection

; 1164 :     RETAILCELOG(_CeLogEnable,CELID_RAW_WCHAR, (PVOID)OutData, sizeof(OutData));
; 1165 :     DEBUGMSG(SDCARD_ZONE_FUNC,(TEXT("-SDHBusRequestHandler pRequest=%x"),pRequest));
; 1166 :     return status;

  00184	e59d0000	 ldr         r0, [sp]
  00188	eb000000	 bl          __security_check_cookie

; 1167 : }

  0018c	e1a00005	 mov         r0, r5
  00190	e28dd004	 add         sp, sp, #4
  00194	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00198	e12fff1e	 bx          lr
  0019c		 |$LN22@SDHBusRequ|
  0019c		 |$LN23@SDHBusRequ|
  0019c	00000000	 DCD         |__security_cookie|
  001a0		 |$M48283|

			 ENDP  ; |SDHBusRequestHandler|

	END
