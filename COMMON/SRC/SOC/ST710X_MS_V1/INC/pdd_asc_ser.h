//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//=======================================================================
//  COPYRIGHT (C) STMicroelectronics 2007.  ALL RIGHTS RESERVED
//
//  Use of this source code is subject to the terms of your STMicroelectronics
//  development license agreement. If you did not accept the terms of such a license,
//  you are not authorized to use this source code.
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//========================================================================
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:

Abstract:

    Serial definitions for ASC controller.

Notes:
--*/
#ifndef __PDD_ASC_SER_H_
#define __PDD_ASC_SER_H_

#include <cserpdd.h>
#include <cmthread.h>

/////////////////////////////////////////////////////////////////////////////////////////
//// General ASC defines

#define SERASC_FIFO_DEPTH                       16

/////////////////////////////////////////////////////////////////////////////////////////
// Required Registry Setting.
#define PC_REG_SERASC_IST_TIMEOUTS_VAL_NAME TEXT("ISTTimeout")
#define PC_REG_SERASC_IST_TIMEOUTS_VAL_LEN sizeof(DWORD)
/////////////////////////////////////////////////////////////////////////////////////////
//// ASC Registers

// ASC register offsets from base
#define SERASC_BAUDRATE_OFFSET                  0x00
#define SERASC_TXBUF_OFFSET                     0x04
#define SERASC_RXBUF_OFFSET                     0x08
#define SERASC_CTRL_OFFSET                      0x0C
#define SERASC_INTEN_OFFSET                     0x10
#define SERASC_INT_STATUS_OFFSET                0x14
#define SERASC_GUARDTIME_OFFSET                 0x18
#define SERASC_TIMEOUT_OFFSET                   0x1C
#define SERASC_TX_RESET_OFFSET                  0x20
#define SERASC_RX_RESET_OFFSET                  0x24
#define SERASC_RETRIES_OFFSET                   0x28

/////// ASC Baudrate register
typedef struct {
    DWORD   reloadval:16;
    DWORD   reserved:16;
} SERASC_BAUDRATE_bit;
typedef union {
    volatile SERASC_BAUDRATE_bit    bit;
    volatile DWORD                  ul;
} SERASC_BAUDRATE, *PSERASC_BAUDRATE;

/////// ASC Transmit Buffer register
// Note: This driver does not support the 9-bit data or 8-bit data with wakeup modes.
typedef struct {
    DWORD   TD0_7:8;
    DWORD   reserved:24;  // Note: The parity bit (bit 8) is automatically generated by the hardware if parity is enabled
} SERASC_TXBUF_8BITDATA_bit;
typedef struct {
    DWORD   TD0_6:7;
    DWORD   reserved:25;  // Note: The parity bit (bit 7) is automatically generated by the hardware if parity is enabled
} SERASC_TXBUF_7BITDATA_PARITY_bit;
typedef union {
    volatile SERASC_TXBUF_8BITDATA_bit          Tx8BitData;
    volatile SERASC_TXBUF_7BITDATA_PARITY_bit   Tx7BitDataWithParity;
    volatile DWORD                              ul;
} SERASC_TXBUF, *PSERASC_TXBUF;

/////// ASC Receive Buffer register
// Note: This driver does not support the 9-bit data or 8-bit data with wakeup modes.
typedef struct {
    DWORD   RD0_7:8;
    DWORD   Reserved8:1;
    DWORD   FrameError:1;
    DWORD   Reserved10_31:22;
} SERASC_RXBUF_8BITDATA_bit;
typedef struct {
    DWORD   RD0_6:7;
    DWORD   Reserved7:1;
    DWORD   ParityError:1;
    DWORD   FrameError:1;
    DWORD   Reserved10_31:22;
} SERASC_RXBUF_7BITDATA_PARITY_bit;
typedef struct {
    DWORD   RD0_7:8;
    DWORD   ParityError:1;
    DWORD   FrameError:1;
    DWORD   Reserved10_31:22;
} SERASC_RXBUF_8BITDATA_PARITY_bit;
typedef union {
    volatile SERASC_RXBUF_8BITDATA_bit          Rx8BitData;
    volatile SERASC_RXBUF_7BITDATA_PARITY_bit   Rx7BitDataWithParity;
    volatile SERASC_RXBUF_8BITDATA_PARITY_bit   Rx8BitDataWithParity;
    volatile DWORD                              ul;
} SERASC_RXBUF, *PSERASC_RXBUF;

/////// ASC Control register
typedef struct {
    DWORD   mode:3;
    DWORD   stopbits:2;
    DWORD   parity:1;
    DWORD   loopback:1;
    DWORD   run:1;
    DWORD   rxenable:1;
    DWORD   scenable:1;
    DWORD   fifoenable:1;
    DWORD   CTSenable:1;
    DWORD   baudmode:1;
    DWORD   NACKDisable:1;
    DWORD   reserved:18;
} SERASC_CTRL_bit;
typedef union {
    volatile SERASC_CTRL_bit    bit;
    volatile DWORD              ul;
} SERASC_CTRL, *PSERASC_CTRL;

// Tx/Rx mode selection
// Note: This driver does not support 9-bit data or 8-bit data with wakeup.
#define SERASC_CTRL_MODE_MASK       0x07
#define SERASC_8BITDATA             0x1
#define SERASC_7BITDATA_PARITY      0x3
#define SERASC_8BITDATA_PARITY      0x7

// Stop bits
#define SERASC_CTRL_STOPBITS_MASK   0x18
#define SERASC_CTRL_STOPBITS_SHIFT  3
#define SERASC_1_STOPBIT            (1 << SERASC_CTRL_STOPBITS_SHIFT)
#define SERASC_1_5_STOPBITS         (2 << SERASC_CTRL_STOPBITS_SHIFT)
#define SERASC_2_STOPBITS           (3 << SERASC_CTRL_STOPBITS_SHIFT)

// Parity even/odd selection
#define SERASC_CTRL_PARITY_SHIFT    5
#define SERASC_CTRL_PARITY_MASK     (1 << SERASC_CTRL_PARITY_SHIFT)
#define SERASC_CTRL_PARITY_ODD      (1 << SERASC_CTRL_PARITY_SHIFT)
#define SERASC_CTRL_PARITY_EVEN     0

// Loopback mode
#define SERASC_CTRL_LOOPBACK_SHIFT  6
#define SERASC_CTRL_LOOPBACK        (1 << SERASC_CTRL_LOOPBACK_SHIFT)

// Baudrate Generator Enable
#define SERASC_CTRL_RUN_SHIFT       7
#define SERASC_CTRL_RUN             (1 << SERASC_CTRL_RUN_SHIFT)

// Receiver enable
#define SERASC_CTRL_RXEN_SHIFT      8
#define SERASC_CTRL_RXEN            (1 << SERASC_CTRL_RXEN_SHIFT)

// Smartcard mode
#define SERASC_CTRL_SCEN_SHIFT      9
#define SERASC_CTRL_SCEN            (1 << SERASC_CTRL_SCEN_SHIFT)

// FIFO Enable
#define SERASC_CTRL_FIFOEN_SHIFT    10
#define SERASC_CTRL_FIFOEN          (1 << SERASC_CTRL_FIFOEN_SHIFT)

// CTS Enable
#define SERASC_CTRL_CTSEN_SHIFT     11
#define SERASC_CTRL_CTSEN           (1 << SERASC_CTRL_CTSEN_SHIFT)

// Baudrate generation mode
#define SERASC_CTRL_BAUDMODE_SHIFT  12
#define SERASC_CTRL_BAUDMODE_1      (1 << SERASC_CTRL_BAUDMODE_SHIFT)

// NACK Disable
#define SERASC_CTRL_NACK_SHIFT      13
#define SERASC_CTRL_NACK            (1 << SERASC_CTRL_NACK_SHIFT)

/////// ASC Interrupt Enable register
typedef struct {
    DWORD   RBE:1;      // Rx buffer empty
    DWORD   TE:1;       // Tx buffer empty
    DWORD   THE:1;      // Tx buffer half empty
    DWORD   PE:1;       // Parity error
    DWORD   FE:1;       // Framing error
    DWORD   OE:1;       // Overrun error
    DWORD   TNE:1;      // Timeout when not empty
    DWORD   TOI:1;      // Timeout when Rx FIFO is empty
    DWORD   RHF:1;      // Rx FIFO half full
    DWORD   reserved:23;
} SERASC_INTEN_bit;
typedef union {
    volatile SERASC_INTEN_bit   bit;
    volatile DWORD              ul;
} SERASC_INTEN, *PSERASC_INTEN;

// Interrupt Status/Enable bit locations
#define SERASC_INT_RXBUF_NOTEMPTY               (1 << 0)
#define SERASC_INT_TXBUF_EMPTY                  (1 << 1)
#define SERASC_INT_TXBUF_HALFEMPTY              (1 << 2)
#define SERASC_INT_PARITYERROR                  (1 << 3)
#define SERASC_INT_FRAMINGERROR                 (1 << 4)
#define SERASC_INT_OVERRUNERROR                 (1 << 5)
#define SERASC_INT_TIMEOUT_RXFIFONOTEMPTY       (1 << 6)
#define SERASC_INT_TIMEOUT_RXFIFOEMPTY          (1 << 7)
#define SERASC_INT_RXFIFO_HALFFULL              (1 << 8)

/////// ASC Interrupt Status register
typedef struct {
    DWORD   RBF:1;      // Rx FIFO not empty or buffer full
    DWORD   TE:1;       // Transmitter empty
    DWORD   THE:1;      // Tx FIFO at least half empty or buffer empty
    DWORD   PE:1;       // Parity error
    DWORD   FE:1;       // Framing error
    DWORD   OE:1;       // Overrun error
    DWORD   TNE:1;      // Timeout when Rx FIFO or buffer not empty
    DWORD   TOI:1;      // Timeout when Rx FIFO or buffer is empty
    DWORD   RHF:1;      // Rx FIFO half full
    DWORD   TF:1;       // Tx FIFO or buffer full
    DWORD   NKD:1;      // Transmission failure ack by receiver
    DWORD   reserved:21;
} SERASC_INT_STATUS_bit;
typedef union {
    volatile SERASC_INT_STATUS_bit  bit;
    volatile DWORD                  ul;
} SERASC_INT_STATUS, *PSERASC_INT_STATUS;

/////// ASC Guardtime register
typedef struct {
    DWORD   guardtime:9;
    DWORD   reserved:23;
} SERASC_GUARDTIME_bit;
typedef union {
    volatile SERASC_GUARDTIME_bit   bit;
    volatile DWORD                  ul;
} SERASC_GUARDTIME, *PSERASC_GUARDTIME;

/////// ASC Timeout register
typedef struct {
    DWORD   timeout:8;
    DWORD   reserved:24;
} SERASC_TIMEOUT_bit;
typedef union {
    volatile SERASC_TIMEOUT_bit     bit;
    volatile DWORD                  ul;
} SERASC_TIMEOUT, *PSERASC_TIMEOUT;

/////// ASC transmit FIFO reset register
// Note: Any value may be written to the Tx Reset register to reset the Tx FIFO.
//       We write 0x1 for simplicity.
#define SERASC_TX_RESET         0x1

/////// ASC receive FIFO reset register

// Note: Any value may be written to the Rx Reset register to reset the Rx FIFO.
//       We write 0x1 for simplicity.
#define SERASC_RX_RESET         0x1

/////// ASC number of retries on transmission register
typedef struct {
    DWORD   numretries:8;
    DWORD   reserved:24;
} SERASC_RETRIES_bit;
typedef union {
    volatile SERASC_RETRIES_bit bit;
    volatile DWORD              ul;
} SERASC_RETRIES, *PSERASC_RETRIES;

/////////////////////////////////////////////////////////////////////////////////////////
//// ASC Class definitions

class CRegASCSerial {
public:
    CRegASCSerial(PULONG pRegAddr);
    virtual ~CRegASCSerial() { ; };
    virtual BOOL    Init() ;
    // We do not virtual Read & Write data because of Performance Concern.
    void    Write_ASCBAUDRATE (ULONG uData) { WRITE_REGISTER_ULONG(m_pReg, uData); }
    ULONG   Read_ASCBAUDRATE() { return READ_REGISTER_ULONG(m_pReg); }
    void    Write_ASCTXBUF (ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 1, uData); }
    ULONG   Read_ASCRXBUF() { return READ_REGISTER_ULONG(m_pReg + 2); }
    void    Write_ASCCTRL(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 3, uData); }
    ULONG   Read_ASCCTRL() { return READ_REGISTER_ULONG(m_pReg + 3); }
    void    Write_ASCINTEN(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 4, uData); }
    ULONG   Read_ASCINTEN() { return READ_REGISTER_ULONG(m_pReg + 4); }
    ULONG   Read_ASCSTA() { return READ_REGISTER_ULONG(m_pReg + 5); }
    void    Write_ASCGUARDTIME(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 6, uData); }
    ULONG   Read_ASCGUARDTIME() { return READ_REGISTER_ULONG(m_pReg + 6); }
    void    Write_ASCTIMEOUT(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 7, uData); }
    ULONG   Read_ASCTIMEOUT() { return READ_REGISTER_ULONG(m_pReg + 7); }
    void    Write_ASCTXRST(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 8, uData ); }
    void    Write_ASCRXRST(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 9, uData); }
    void    Write_ASCRETRIES(ULONG uData) { WRITE_REGISTER_ULONG(m_pReg + 10, uData); }
    ULONG   Read_ASCRETRIES() { return READ_REGISTER_ULONG(m_pReg + 10); }

    PULONG  GetRegisterVirtualAddr() { return m_pReg; };
    virtual void    Backup();
    virtual void    Restore();
#ifdef DEBUG
    virtual void    DumpRegister();
#endif
protected:
    volatile PULONG const   m_pReg;
    BOOL                    m_fIsBackedUp;

private:
    ULONG   m_ASCBAUDRATEBackup;
    ULONG   m_ASCCTRLBackup;
    ULONG   m_ASCGUARDTIMEBackup;
    ULONG   m_ASCINTENBackup;
    ULONG   m_RETRIESBackup;
    ULONG   m_ASCTIMEOUTBackup;
};
class CPddASCSerial: public CSerialPDD, public CMiniThread  {
public:
    CPddASCSerial (LPTSTR lpActivePath, PVOID pMdd, PHWOBJ pHwObj);
    virtual ~CPddASCSerial();
    virtual BOOL Init();
    virtual void PostInit();
    virtual BOOL MapHardware();
    virtual BOOL CreateHardwareAccess();
//  Power Manager Required Function.
    virtual void    SerialRegisterBackup() { m_pRegASCSerial->Backup(); };
    virtual void    SerialRegisterRestore() { m_pRegASCSerial->Restore(); };

// Implement CPddSerial Function.
// Interrupt
    virtual BOOL    InitialEnableInterrupt(BOOL bEnable ) ; // Enable All the interrupt may include Xmit Interrupt.
private:
    virtual DWORD ThreadRun();   // IST
//  Tx Function.
public:
    virtual BOOL    InitXmit(BOOL bInit);
    virtual void    XmitInterruptHandler(PUCHAR pTxBuffer, ULONG *pBuffLen);
    virtual void    XmitComChar(UCHAR ComChar);
    virtual BOOL    EnableXmitInterrupt(BOOL bEnable);
    virtual BOOL    CancelXmit();
    virtual DWORD   GetWriteableSize();
protected:
    HANDLE  m_XmitFlushDone;

//
//  Rx Function.
public:
    virtual BOOL    InitReceive(BOOL bInit);
    virtual ULONG   ReceiveInterruptHandler(PUCHAR pRxBuffer,ULONG *pBufflen);
    virtual ULONG   CancelReceive();

protected:
    BOOL    m_bReceivedCanceled;
//
//  Modem
public:
    virtual BOOL    InitModem(BOOL bInit);
    virtual void    ModemInterruptHandler() { GetModemStatus();};
    virtual ULONG   GetModemStatus();
    virtual void    SetDTR(BOOL bSet);
    virtual void    SetRTS(BOOL bSet);
//
// Line Function.
    virtual BOOL    InitLine(BOOL bInit) ;
    virtual void    LineInterruptHandler() { GetLineStatus();};
    virtual void    SetBreak(BOOL bSet) ;
    virtual BOOL    SetBaudRate(ULONG BaudRate,BOOL bIrModule) ;
    virtual BOOL    SetByteSize(ULONG ByteSize);
    virtual BOOL    SetParity(ULONG Parity);
    virtual BOOL    SetStopBits(ULONG StopBits);
    BOOL            SetMode(ULONG ByteSize, ULONG Parity);

// Configuration
    virtual void    SetDefaultConfiguration();

//
// Line Internal Function
    VOID            GetLineStatus();
    virtual void    SetOutputMode(BOOL UseIR, BOOL Use9Pin) ;

protected:
    CRegASCSerial * m_pRegASCSerial;
    PVOID           m_pRegVirtualAddr;
    CRegistryEdit   m_ActiveReg;

//  Interrupt Handler
    DWORD       m_dwSysIntr;
    HANDLE      m_hISTEvent;
// Optional Parameter
    DWORD       m_dwDevIndex;
    ULONG       m_PeripheralClockFreq;
    ULONG       m_dwISTTimeout;

    // Status
    ULONG       m_ParityMode;
    ULONG       m_ByteSize;
};

#endif // __PDD_ASC_SER_H_
