; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\DSS\DSSAI\dssai.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A| [ DATA ] ; g_rgPipelineMapping
	EXPORT	|?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A| [ DATA ] ; g_rgPipelineScaling
	EXPORT	|?g_dwDestinationRefCnt@@3PAKA| [ DATA ] ; g_dwDestinationRefCnt

  00000			 AREA	 |.bss|, NOINIT
|?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A| % 0x60 ; g_rgPipelineMapping
|?g_dwDestinationRefCnt@@3PAKA| % 0x8			; g_dwDestinationRefCnt

  00000			 AREA	 |.data|, DATA
|?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A| DCD 0x1 ; g_rgPipelineScaling
	DCD	0x1
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	0x0
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T40345| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40342|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M40343|

			 ENDP  ; |SetEvent|

	EXPORT	|?GetLCDWidth@OMAPDisplayController@@QAAKXZ| ; OMAPDisplayController::GetLCDWidth
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T40355| DCD	|$LN5@GetLCDWidt|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetLCDWidth@OMAPDisplayController@@QAAKXZ| PROC ; OMAPDisplayController::GetLCDWidth

; 303  :     DWORD                   GetLCDWidth() { return m_dwLcdWidth; }

  00000		 |$LN5@GetLCDWidt|
  00000		 |$M40352|
  00000	e59004a8	 ldr         r0, [r0, #0x4A8]
  00004	e12fff1e	 bx          lr
  00008		 |$M40353|

			 ENDP  ; |?GetLCDWidth@OMAPDisplayController@@QAAKXZ|, OMAPDisplayController::GetLCDWidth

	EXPORT	|?GetLCDHeight@OMAPDisplayController@@QAAKXZ| ; OMAPDisplayController::GetLCDHeight

  00000			 AREA	 |.pdata|, PDATA
|$T40365| DCD	|$LN5@GetLCDHeig|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetLCDHeight@OMAPDisplayController@@QAAKXZ| PROC ; OMAPDisplayController::GetLCDHeight

; 304  :     DWORD                   GetLCDHeight() { return m_dwLcdHeight; }

  00000		 |$LN5@GetLCDHeig|
  00000		 |$M40362|
  00000	e59004ac	 ldr         r0, [r0, #0x4AC]
  00004	e12fff1e	 bx          lr
  00008		 |$M40363|

			 ENDP  ; |?GetLCDHeight@OMAPDisplayController@@QAAKXZ|, OMAPDisplayController::GetLCDHeight

	EXPORT	|?PixelFormat@OMAPSurface@@QAA?AW4OMAP_DSS_PIXELFORMAT@@XZ| ; OMAPSurface::PixelFormat

  00000			 AREA	 |.pdata|, PDATA
|$T40375| DCD	|$LN5@PixelForma|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PixelFormat@OMAPSurface@@QAA?AW4OMAP_DSS_PIXELFORMAT@@XZ| PROC ; OMAPSurface::PixelFormat

; 760  :     OMAP_DSS_PIXELFORMAT    PixelFormat() { return m_ePixelFormat; }

  00000		 |$LN5@PixelForma|
  00000		 |$M40372|
  00000	e5900004	 ldr         r0, [r0, #4]
  00004	e12fff1e	 bx          lr
  00008		 |$M40373|

			 ENDP  ; |?PixelFormat@OMAPSurface@@QAA?AW4OMAP_DSS_PIXELFORMAT@@XZ|, OMAPSurface::PixelFormat

	EXPORT	|?PixelSize@OMAPSurface@@QAAKXZ|	; OMAPSurface::PixelSize

  00000			 AREA	 |.pdata|, PDATA
|$T40385| DCD	|$LN5@PixelSize|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PixelSize@OMAPSurface@@QAAKXZ| PROC	; OMAPSurface::PixelSize

; 762  :     DWORD                   PixelSize() { return m_dwPixelSize; }

  00000		 |$LN5@PixelSize|
  00000		 |$M40382|
  00000	e5900008	 ldr         r0, [r0, #8]
  00004	e12fff1e	 bx          lr
  00008		 |$M40383|

			 ENDP  ; |?PixelSize@OMAPSurface@@QAAKXZ|, OMAPSurface::PixelSize

	EXPORT	|?ResizeParams@OMAPSurface@@QAAPAURSZParams_t@@XZ| ; OMAPSurface::ResizeParams

  00000			 AREA	 |.pdata|, PDATA
|$T40395| DCD	|$LN5@ResizePara|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResizeParams@OMAPSurface@@QAAPAURSZParams_t@@XZ| PROC ; OMAPSurface::ResizeParams

; 772  :     RSZParams_t *           ResizeParams() { return &m_sRSZParams; }

  00000		 |$LN5@ResizePara|
  00000		 |$M40392|
  00000	e2800038	 add         r0, r0, #0x38
  00004	e12fff1e	 bx          lr
  00008		 |$M40393|

			 ENDP  ; |?ResizeParams@OMAPSurface@@QAAPAURSZParams_t@@XZ|, OMAPSurface::ResizeParams

	EXPORT	|?OmapAssocSurface@OMAPSurface@@QAAPAV1@XZ| ; OMAPSurface::OmapAssocSurface

  00000			 AREA	 |.pdata|, PDATA
|$T40405| DCD	|$LN5@OmapAssocS|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?OmapAssocSurface@OMAPSurface@@QAAPAV1@XZ| PROC ; OMAPSurface::OmapAssocSurface

; 776  :     OMAPSurface *           OmapAssocSurface(){return m_pAssocSurface;}    

  00000		 |$LN5@OmapAssocS|
  00000		 |$M40402|
  00000	e59000a0	 ldr         r0, [r0, #0xA0]
  00004	e12fff1e	 bx          lr
  00008		 |$M40403|

			 ENDP  ; |?OmapAssocSurface@OMAPSurface@@QAAPAV1@XZ|, OMAPSurface::OmapAssocSurface

	EXPORT	|??0OMAPDisplayController@@QAA@XZ|	; OMAPDisplayController::OMAPDisplayController
	EXPORT	|??_7OMAPDisplayController@@6B@| [ DATA ] ; OMAPDisplayController::`vftable'
	IMPORT	|SOCGetDSSInfo|
	IMPORT	|LcdPdd_DVI_Enabled|
	IMPORT	|?g_dwColorSpaceCoeff_BT601_Limited@@3PAKA| ; g_dwColorSpaceCoeff_BT601_Limited
	IMPORT	|??_EOMAPDisplayController@@UAAPAXI@Z|, WEAK |??_GOMAPDisplayController@@UAAPAXI@Z| ; OMAPDisplayController::`vector deleting destructor', OMAPDisplayController::`scalar deleting destructor'
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\dssai.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T40415| DCD	|$LN7@OMAPDispla|
	DCD	0x40002b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_7OMAPDisplayController@@6B@| DCD |??_EOMAPDisplayController@@UAAPAXI@Z| ; OMAPDisplayController::`vftable'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??0OMAPDisplayController@@QAA@XZ| PROC ; OMAPDisplayController::OMAPDisplayController

; 112  : {

  00000		 |$LN7@OMAPDispla|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40412|
  00004	e1a04000	 mov         r4, r0
  00008	e59f3098	 ldr         r3, [pc, #0x98]

; 113  :     m_pDSSRegs = NULL;
; 114  :     m_pDispRegs = NULL;
; 115  :     m_pVencRegs = NULL;
; 116  :     
; 117  :     m_dwPowerLevel = D4;

  0000c	e3a02004	 mov         r2, #4
  00010	e3a05000	 mov         r5, #0
  00014	e8840028	 stmia       r4, {r3, r5}
  00018	e5845008	 str         r5, [r4, #8]
  0001c	e584500c	 str         r5, [r4, #0xC]
  00020	e5842488	 str         r2, [r4, #0x488]

; 118  :     
; 119  :     m_bTVEnable = FALSE;

  00024	e58454b4	 str         r5, [r4, #0x4B4]

; 120  :     m_bHDMIEnable = FALSE;

  00028	e58454c8	 str         r5, [r4, #0x4C8]

; 121  : 
; 122  :     if (LcdPdd_DVI_Enabled())

  0002c	eb000000	 bl          LcdPdd_DVI_Enabled

; 123  :         m_bDVIEnable = TRUE;
; 124  :     else
; 125  :         m_bDVIEnable = FALSE;
; 126  : 
; 127  :     m_bGammaEnable = TRUE;
; 128  :    	m_dwEnableWaitForVerticalBlank = FALSE;
; 129  :     m_bDssIspRszEnabled = FALSE;
; 130  :     m_lastVsyncIRQStatus = 0;
; 131  :     
; 132  :     m_dwContrastLevel = DEFAULT_CONTRAST_LEVEL;
; 133  :     m_pGammaBufVirt = NULL;
; 134  :     
; 135  :     m_bDssIntThreadExit = FALSE;
; 136  :     m_hDssIntEvent = NULL;
; 137  :     m_hDssIntThread = NULL;
; 138  :     m_dwDssSysIntr = 0;
; 139  : 
; 140  :     m_dwVsyncPeriod = 0;
; 141  :     m_hVsyncEvent = NULL;
; 142  :     m_hVsyncEventSGX = NULL;
; 143  : 
; 144  :     m_hScanLineEvent = NULL;
; 145  :     
; 146  :     m_pColorSpaceCoeffs = g_dwColorSpaceCoeff_BT601_Limited;

  00030	e59f306c	 ldr         r3, [pc, #0x6C]
  00034	e3500000	 cmp         r0, #0
  00038	e3a0e001	 mov         lr, #1

; 147  :     
; 148  :     m_bLPREnable = FALSE;
; 149  : 
; 150  :     m_hSmartReflexPolicyAdapter = NULL;
; 151  : 
; 152  :     SOCGetDSSInfo(&m_dssinfo);

  0003c	e2842c05	 add         r2, r4, #5, 24
  00040	e3a01003	 mov         r1, #3
  00044	1584e4cc	 strne       lr, [r4, #0x4CC]
  00048	e282001c	 add         r0, r2, #0x1C
  0004c	058454cc	 streq       r5, [r4, #0x4CC]
  00050	e58434a0	 str         r3, [r4, #0x4A0]
  00054	e584e4dc	 str         lr, [r4, #0x4DC]
  00058	e5845500	 str         r5, [r4, #0x500]
  0005c	e5845514	 str         r5, [r4, #0x514]
  00060	e5845538	 str         r5, [r4, #0x538]
  00064	e284ce4d	 add         r12, r4, #0x4D, 28
  00068	e88c0022	 stmia       r12, {r1, r5}
  0006c	e58454f0	 str         r5, [r4, #0x4F0]
  00070	e58454e4	 str         r5, [r4, #0x4E4]
  00074	e58454e8	 str         r5, [r4, #0x4E8]
  00078	e58454ec	 str         r5, [r4, #0x4EC]
  0007c	e58454fc	 str         r5, [r4, #0x4FC]
  00080	e58454f4	 str         r5, [r4, #0x4F4]
  00084	e58454f8	 str         r5, [r4, #0x4F8]
  00088	e5845504	 str         r5, [r4, #0x504]
  0008c	e5845510	 str         r5, [r4, #0x510]
  00090	e5845518	 str         r5, [r4, #0x518]
  00094	eb000000	 bl          SOCGetDSSInfo

; 153  : }

  00098	e1a00004	 mov         r0, r4
  0009c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN8@OMAPDispla|
  000a4		 |$LN9@OMAPDispla|
  000a4	00000000	 DCD         |?g_dwColorSpaceCoeff_BT601_Limited@@3PAKA|
  000a8		 |$LN10@OMAPDispla|
  000a8	00000000	 DCD         |??_7OMAPDisplayController@@6B@|
  000ac		 |$M40413|

			 ENDP  ; |??0OMAPDisplayController@@QAA@XZ|, OMAPDisplayController::OMAPDisplayController

	EXPORT	|?UninitInterrupts@OMAPDisplayController@@QAAXXZ| ; OMAPDisplayController::UninitInterrupts
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|
	IMPORT	|KernelIoControl|
	IMPORT	|InterruptDisable|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T40430| DCD	|$LN12@UninitInte|
	DCD	0x40003502
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\dssai.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UninitInterrupts@OMAPDisplayController@@QAAXXZ| PROC ; OMAPDisplayController::UninitInterrupts

; 490  : {

  00000		 |$LN12@UninitInte|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M40427|
  00008	e1a04000	 mov         r4, r0

; 491  :     // unregister system interrupt
; 492  :     if (m_dwDssSysIntr != 0)

  0000c	e59434ec	 ldr         r3, [r4, #0x4EC]
  00010	e3a05000	 mov         r5, #0
  00014	e3530000	 cmp         r3, #0
  00018	0a00000a	 beq         |$LN5@UninitInte|

; 493  :     {
; 494  :         InterruptDisable(m_dwDssSysIntr);

  0001c	e1a00003	 mov         r0, r3
  00020	eb000000	 bl          InterruptDisable

; 495  :         KernelIoControl(
; 496  :             IOCTL_HAL_RELEASE_SYSINTR, &m_dwDssSysIntr,
; 497  :             sizeof(m_dwDssSysIntr), NULL, 0, NULL
; 498  :             );

  00024	e59f00a4	 ldr         r0, [pc, #0xA4]
  00028	e2843b01	 add         r3, r4, #1, 22
  0002c	e28310ec	 add         r1, r3, #0xEC
  00030	e3a03000	 mov         r3, #0
  00034	e3a02004	 mov         r2, #4
  00038	e58d5004	 str         r5, [sp, #4]
  0003c	e58d5000	 str         r5, [sp]
  00040	eb000000	 bl          KernelIoControl

; 499  : 
; 500  :         // reinit
; 501  :         m_dwDssSysIntr = 0;

  00044	e58454ec	 str         r5, [r4, #0x4EC]
  00048		 |$LN5@UninitInte|

; 502  :     }
; 503  : 
; 504  :     // stop thread
; 505  :     if (m_hDssIntEvent != NULL)

  00048	e59434e4	 ldr         r3, [r4, #0x4E4]
  0004c	e1b00003	 movs        r0, r3
  00050	0a00000f	 beq         |$LN4@UninitInte|

; 506  :     {
; 507  :         if (m_hDssIntThread != NULL)

  00054	e59434e8	 ldr         r3, [r4, #0x4E8]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000009	 beq         |$LN3@UninitInte|

; 508  :         {
; 509  :             // Signal stop to thread
; 510  :             m_bDssIntThreadExit = TRUE;

  00060	e3a03001	 mov         r3, #1

; 511  : 
; 512  :             // Set event to wake it
; 513  :             SetEvent(m_hDssIntEvent);

  00064	e3a01003	 mov         r1, #3
  00068	e58434f0	 str         r3, [r4, #0x4F0]
  0006c	eb000000	 bl          EventModify

; 514  : 
; 515  :             // Wait until thread exits
; 516  :             WaitForSingleObject(m_hDssIntThread, INFINITE);

  00070	e59404e8	 ldr         r0, [r4, #0x4E8]
  00074	e3e01000	 mvn         r1, #0
  00078	eb000000	 bl          WaitForSingleObject

; 517  : 
; 518  :             // Close handle
; 519  :             CloseHandle(m_hDssIntThread);

  0007c	e59404e8	 ldr         r0, [r4, #0x4E8]
  00080	eb000000	 bl          CloseHandle

; 520  : 
; 521  :             // reinit
; 522  :             m_hDssIntThread = NULL;

  00084	e58454e8	 str         r5, [r4, #0x4E8]
  00088		 |$LN3@UninitInte|

; 523  :         }
; 524  : 
; 525  :         // close event handle
; 526  :         CloseHandle(m_hDssIntEvent);

  00088	e59404e4	 ldr         r0, [r4, #0x4E4]
  0008c	eb000000	 bl          CloseHandle

; 527  :         m_hDssIntEvent = NULL;

  00090	e58454e4	 str         r5, [r4, #0x4E4]
  00094		 |$LN4@UninitInte|

; 528  :     }
; 529  : 
; 530  :     if(m_hVsyncEvent != NULL)

  00094	e59434f4	 ldr         r3, [r4, #0x4F4]
  00098	e3530000	 cmp         r3, #0
  0009c	0a000002	 beq         |$LN2@UninitInte|

; 531  :     {
; 532  :         CloseHandle(m_hVsyncEvent);

  000a0	e1a00003	 mov         r0, r3
  000a4	eb000000	 bl          CloseHandle

; 533  :         m_hVsyncEvent = NULL;

  000a8	e58454f4	 str         r5, [r4, #0x4F4]
  000ac		 |$LN2@UninitInte|

; 534  :     }
; 535  : 
; 536  :     if(m_hScanLineEvent != NULL)

  000ac	e5943504	 ldr         r3, [r4, #0x504]
  000b0	e3530000	 cmp         r3, #0
  000b4	0a000002	 beq         |$LN1@UninitInte|

; 537  :     {
; 538  :         CloseHandle(m_hScanLineEvent);

  000b8	e1a00003	 mov         r0, r3
  000bc	eb000000	 bl          CloseHandle

; 539  :         m_hScanLineEvent = NULL;

  000c0	e5845504	 str         r5, [r4, #0x504]
  000c4		 |$LN1@UninitInte|

; 540  :     }
; 541  : 
; 542  : }

  000c4	e28dd008	 add         sp, sp, #8
  000c8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$LN13@UninitInte|
  000d0		 |$LN14@UninitInte|
  000d0	010100d8	 DCD         0x10100d8
  000d4		 |$M40428|

			 ENDP  ; |?UninitInterrupts@OMAPDisplayController@@QAAXXZ|, OMAPDisplayController::UninitInterrupts

	EXPORT	|?SetSurfaceMgr@OMAPDisplayController@@QAAHPAVOMAPSurfaceManager@@@Z| ; OMAPDisplayController::SetSurfaceMgr

  00000			 AREA	 |.pdata|, PDATA
|$T40443| DCD	|$LN5@SetSurface|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSurfaceMgr@OMAPDisplayController@@QAAHPAVOMAPSurfaceManager@@@Z| PROC ; OMAPDisplayController::SetSurfaceMgr

; 765  : {

  00000		 |$LN5@SetSurface|
  00000		 |$M40440|

; 766  :     //  Reference the given surface mamager
; 767  :     m_pSurfaceMgr = pSurfMgr;

  00000	e58014e0	 str         r1, [r0, #0x4E0]

; 768  :     
; 769  :     //  Return result
; 770  :     return TRUE;

  00004	e3a00001	 mov         r0, #1

; 771  : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M40441|

			 ENDP  ; |?SetSurfaceMgr@OMAPDisplayController@@QAAHPAVOMAPSurfaceManager@@@Z|, OMAPDisplayController::SetSurfaceMgr

	EXPORT	|?GetFIRCoef@@YAXPAXKKK@Z|		; GetFIRCoef
	IMPORT	|?g_coef_M8@@3PAY07EA|			; g_coef_M8
	IMPORT	|?g_coef_M9@@3PAY07EA|			; g_coef_M9
	IMPORT	|?g_coef_M10@@3PAY07EA|			; g_coef_M10
	IMPORT	|?g_coef_M11@@3PAY07EA|			; g_coef_M11
	IMPORT	|?g_coef_M12@@3PAY07EA|			; g_coef_M12
	IMPORT	|?g_coef_M13@@3PAY07EA|			; g_coef_M13
	IMPORT	|?g_coef_M14@@3PAY07EA|			; g_coef_M14
	IMPORT	|?g_coef_M16@@3PAY07EA|			; g_coef_M16
	IMPORT	|?g_coef_M19@@3PAY07EA|			; g_coef_M19
	IMPORT	|?g_coef_M22@@3PAY07EA|			; g_coef_M22
	IMPORT	|?g_coef_M26@@3PAY07EA|			; g_coef_M26
	IMPORT	|?g_coef_M32@@3PAY07EA|			; g_coef_M32
	IMPORT	|?g_coef3_M8@@3PAY07EA|			; g_coef3_M8
	IMPORT	|?g_coef3_M16@@3PAY07EA|		; g_coef3_M16
	IMPORT	|memcpy|

  00000			 AREA	 |.pdata|, PDATA
|$T40458| DCD	|$LN38@GetFIRCoef|
	DCD	0x40005001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetFIRCoef@@YAXPAXKKK@Z| PROC	; GetFIRCoef

; 1034 : {

  00000		 |$LN38@GetFIRCoef|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40455|

; 1035 :     if (dwTaps == 3)

  00004	e3510003	 cmp         r1, #3
  00008	1a000008	 bne         |$LN30@GetFIRCoef|

; 1036 :     {
; 1037 :         if (dwPhaseInc > (128*14))  {memcpy(pCoeffs, g_coef3_M16, sizeof(g_coef3_M16));}

  0000c	e3520c07	 cmp         r2, #7, 24
  00010	859f1124	 ldrhi       r1, [pc, #0x124]
  00014	8a000037	 bhi         |$LN34@GetFIRCoef|

; 1038 :         else if (dwFlickerFilter)   {memcpy(pCoeffs, g_coef3_M16, sizeof(g_coef3_M16));}

  00018	e3530000	 cmp         r3, #0
  0001c	159f1118	 ldrne       r1, [pc, #0x118]
  00020	e3a02028	 mov         r2, #0x28
  00024	1a000034	 bne         |$LN35@GetFIRCoef|

; 1039 :         else                        {memcpy(pCoeffs, g_coef3_M8, sizeof(g_coef3_M8));  }

  00028	e59f1108	 ldr         r1, [pc, #0x108]

; 1040 :     }
; 1041 :     else //dwTaps == 5

  0002c	ea000032	 b           |$LN35@GetFIRCoef|
  00030		 |$LN30@GetFIRCoef|

; 1042 :     {
; 1043 :         if(dwPhaseInc > (128*26))                               {memcpy(pCoeffs, g_coef_M32, sizeof(g_coef_M32));}

  00030	e3520c0d	 cmp         r2, #0xD, 24
  00034	859f10f8	 ldrhi       r1, [pc, #0xF8]
  00038	8a00002e	 bhi         |$LN34@GetFIRCoef|

; 1044 :         else if (dwPhaseInc > (128*22))                         {memcpy(pCoeffs, g_coef_M26, sizeof(g_coef_M26));}

  0003c	e3520c0b	 cmp         r2, #0xB, 24
  00040	859f10e8	 ldrhi       r1, [pc, #0xE8]
  00044	8a00002b	 bhi         |$LN34@GetFIRCoef|

; 1045 :         else if (dwPhaseInc > (128*19))                         {memcpy(pCoeffs, g_coef_M22, sizeof(g_coef_M22));}

  00048	e3520d26	 cmp         r2, #0x26, 26
  0004c	859f10d8	 ldrhi       r1, [pc, #0xD8]
  00050	8a000028	 bhi         |$LN34@GetFIRCoef|

; 1046 :         else if (dwPhaseInc > (128*16))                         {memcpy(pCoeffs, g_coef_M19, sizeof(g_coef_M19));}

  00054	e3520b02	 cmp         r2, #2, 22
  00058	859f10c8	 ldrhi       r1, [pc, #0xC8]
  0005c	8a000025	 bhi         |$LN34@GetFIRCoef|

; 1047 :         else if (dwPhaseInc > (128*14))                         {memcpy(pCoeffs, g_coef_M16, sizeof(g_coef_M16));}

  00060	e3520c07	 cmp         r2, #7, 24
  00064	9a000001	 bls         |$LN16@GetFIRCoef|
  00068		 |$LN33@GetFIRCoef|
  00068	e59f10b4	 ldr         r1, [pc, #0xB4]
  0006c	ea000021	 b           |$LN34@GetFIRCoef|
  00070		 |$LN16@GetFIRCoef|

; 1048 :         else if ((dwPhaseInc > (128*13)) && (!dwFlickerFilter)) {memcpy(pCoeffs, g_coef_M14, sizeof(g_coef_M14));}

  00070	e3520d1a	 cmp         r2, #0x1A, 26
  00074	9a000002	 bls         |$LN14@GetFIRCoef|
  00078	e3530000	 cmp         r3, #0
  0007c	059f109c	 ldreq       r1, [pc, #0x9C]
  00080	0a00001c	 beq         |$LN34@GetFIRCoef|
  00084		 |$LN14@GetFIRCoef|

; 1049 :         else if ((dwPhaseInc > (128*12)) && (!dwFlickerFilter)) {memcpy(pCoeffs, g_coef_M13, sizeof(g_coef_M13));}

  00084	e3520c06	 cmp         r2, #6, 24
  00088	9a000002	 bls         |$LN12@GetFIRCoef|
  0008c	e3530000	 cmp         r3, #0
  00090	059f1084	 ldreq       r1, [pc, #0x84]
  00094	0a000017	 beq         |$LN34@GetFIRCoef|
  00098		 |$LN12@GetFIRCoef|

; 1050 :         else if ((dwPhaseInc > (128*11)) && (!dwFlickerFilter)) {memcpy(pCoeffs, g_coef_M12, sizeof(g_coef_M12));}

  00098	e3520d16	 cmp         r2, #0x16, 26
  0009c	9a000002	 bls         |$LN10@GetFIRCoef|
  000a0	e3530000	 cmp         r3, #0
  000a4	059f106c	 ldreq       r1, [pc, #0x6C]
  000a8	0a000012	 beq         |$LN34@GetFIRCoef|
  000ac		 |$LN10@GetFIRCoef|

; 1051 :         else if ((dwPhaseInc > (128*10)) && (!dwFlickerFilter)) {memcpy(pCoeffs, g_coef_M11, sizeof(g_coef_M11));}

  000ac	e3520c05	 cmp         r2, #5, 24
  000b0	9a000002	 bls         |$LN8@GetFIRCoef|
  000b4	e3530000	 cmp         r3, #0
  000b8	059f1054	 ldreq       r1, [pc, #0x54]
  000bc	0a00000d	 beq         |$LN34@GetFIRCoef|
  000c0		 |$LN8@GetFIRCoef|

; 1052 :         else if ((dwPhaseInc > (128*9))  && (!dwFlickerFilter)) {memcpy(pCoeffs, g_coef_M10, sizeof(g_coef_M10));}

  000c0	e3520d12	 cmp         r2, #0x12, 26
  000c4	9a000002	 bls         |$LN6@GetFIRCoef|
  000c8	e3530000	 cmp         r3, #0
  000cc	059f103c	 ldreq       r1, [pc, #0x3C]
  000d0	0a000008	 beq         |$LN34@GetFIRCoef|
  000d4		 |$LN6@GetFIRCoef|

; 1053 :         else if ((dwPhaseInc > (128*8))  && (!dwFlickerFilter)) {memcpy(pCoeffs, g_coef_M9,  sizeof(g_coef_M9)); }

  000d4	e3520b01	 cmp         r2, #1, 22
  000d8	9a000003	 bls         |$LN4@GetFIRCoef|
  000dc	e3530000	 cmp         r3, #0
  000e0	1affffe0	 bne         |$LN33@GetFIRCoef|
  000e4	e59f1020	 ldr         r1, [pc, #0x20]
  000e8	ea000002	 b           |$LN34@GetFIRCoef|
  000ec		 |$LN4@GetFIRCoef|

; 1054 :         else if (dwFlickerFilter)                               {memcpy(pCoeffs, g_coef_M16, sizeof(g_coef_M16));}

  000ec	e3530000	 cmp         r3, #0
  000f0	1affffdc	 bne         |$LN33@GetFIRCoef|

; 1055 :         else                                                    {memcpy(pCoeffs, g_coef_M8,  sizeof(g_coef_M8)); }

  000f4	e59f100c	 ldr         r1, [pc, #0xC]
  000f8		 |$LN34@GetFIRCoef|
  000f8	e3a02028	 mov         r2, #0x28
  000fc		 |$LN35@GetFIRCoef|
  000fc	eb000000	 bl          memcpy

; 1056 :   }
; 1057 : }

  00100	e49de004	 ldr         lr, [sp], #4
  00104	e12fff1e	 bx          lr
  00108		 |$LN39@GetFIRCoef|
  00108		 |$LN40@GetFIRCoef|
  00108	00000000	 DCD         |?g_coef_M8@@3PAY07EA|
  0010c		 |$LN41@GetFIRCoef|
  0010c	00000000	 DCD         |?g_coef_M9@@3PAY07EA|
  00110		 |$LN42@GetFIRCoef|
  00110	00000000	 DCD         |?g_coef_M10@@3PAY07EA|
  00114		 |$LN43@GetFIRCoef|
  00114	00000000	 DCD         |?g_coef_M11@@3PAY07EA|
  00118		 |$LN44@GetFIRCoef|
  00118	00000000	 DCD         |?g_coef_M12@@3PAY07EA|
  0011c		 |$LN45@GetFIRCoef|
  0011c	00000000	 DCD         |?g_coef_M13@@3PAY07EA|
  00120		 |$LN46@GetFIRCoef|
  00120	00000000	 DCD         |?g_coef_M14@@3PAY07EA|
  00124		 |$LN47@GetFIRCoef|
  00124	00000000	 DCD         |?g_coef_M16@@3PAY07EA|
  00128		 |$LN48@GetFIRCoef|
  00128	00000000	 DCD         |?g_coef_M19@@3PAY07EA|
  0012c		 |$LN49@GetFIRCoef|
  0012c	00000000	 DCD         |?g_coef_M22@@3PAY07EA|
  00130		 |$LN50@GetFIRCoef|
  00130	00000000	 DCD         |?g_coef_M26@@3PAY07EA|
  00134		 |$LN51@GetFIRCoef|
  00134	00000000	 DCD         |?g_coef_M32@@3PAY07EA|
  00138		 |$LN52@GetFIRCoef|
  00138	00000000	 DCD         |?g_coef3_M8@@3PAY07EA|
  0013c		 |$LN53@GetFIRCoef|
  0013c	00000000	 DCD         |?g_coef3_M16@@3PAY07EA|
  00140		 |$M40456|

			 ENDP  ; |?GetFIRCoef@@YAXPAXKKK@Z|, GetFIRCoef

	EXPORT	|?NeedISPResizer@@YAHKKK@Z|		; NeedISPResizer
	IMPORT	|__utod|
	IMPORT	|__muld|
	IMPORT	|ceil|
	IMPORT	|__dtou|

  00000			 AREA	 |.pdata|, PDATA
|$T40495| DCD	|$LN14@NeedISPRes|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?NeedISPResizer@@YAHKKK@Z| PROC	; NeedISPResizer

; 1061 : {

  00000		 |$LN14@NeedISPRes|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M40492|
  00004	e1a06002	 mov         r6, r2
  00008	e1a04001	 mov         r4, r1

; 1062 :     DWORD totalScaleRequired;
; 1063 : 
; 1064 :     /* Not using ISP resizer for upsampling */    
; 1065 :     if ((dwHorzScale<1024) || (dwVertScale<1024))

  0000c	e3500b01	 cmp         r0, #1, 22
  00010	3a000022	 bcc         |$LN4@NeedISPRes|
  00014	e3540b01	 cmp         r4, #1, 22
  00018	3a000020	 bcc         |$LN4@NeedISPRes|

; 1067 :     /* no scalar needed */
; 1068 :     if ((dwHorzScale==1024) && (dwVertScale==1024))

  0001c	e3500b01	 cmp         r0, #1, 22
  00020	1a000001	 bne         |$LN3@NeedISPRes|
  00024	e3540b01	 cmp         r4, #1, 22

; 1069 :         return FALSE;

  00028	0a00001c	 beq         |$LN4@NeedISPRes|
  0002c		 |$LN3@NeedISPRes|

; 1070 : 
; 1071 :     /* all other cases involve downsampling */
; 1072 :     dwHorzScale=(DWORD)ceil((double)dwHorzScale/1024);

  0002c	eb000000	 bl          __utod
  00030	e3a075fd	 mov         r7, #0xFD, 10
  00034	e3873601	 orr         r3, r7, #1, 12
  00038	e3a02000	 mov         r2, #0
  0003c	eb000000	 bl          __muld
  00040	eb000000	 bl          ceil
  00044	eb000000	 bl          __dtou
  00048	e1a05000	 mov         r5, r0

; 1073 :     dwVertScale=(DWORD)ceil((double)dwVertScale/1024);

  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          __utod
  00054	e3a02000	 mov         r2, #0
  00058	e3873601	 orr         r3, r7, #1, 12
  0005c	eb000000	 bl          __muld
  00060	eb000000	 bl          ceil
  00064	eb000000	 bl          __dtou

; 1074 : 
; 1075 :     totalScaleRequired=((dwHorzScale==1)?0:dwHorzScale)+
; 1076 :                         ((dwVertScale==1)?0:dwVertScale);

  00068	e3550001	 cmp         r5, #1
  0006c	03a03000	 moveq       r3, #0
  00070	11a03005	 movne       r3, r5
  00074	e3500001	 cmp         r0, #1
  00078	03a02000	 moveq       r2, #0
  0007c	11a02000	 movne       r2, r0
  00080	e0823003	 add         r3, r2, r3

; 1077 :                         
; 1078 :     if ((totalScaleRequired>PCD) && (dwHorzScale<=4) && (dwVertScale<=4))

  00084	e1530006	 cmp         r3, r6
  00088	9a000004	 bls         |$LN4@NeedISPRes|
  0008c	e3550004	 cmp         r5, #4
  00090	93500004	 cmpls       r0, #4

; 1079 :     {
; 1080 :         return TRUE;

  00094	93a00001	 movls       r0, #1

; 1081 :     }
; 1082 :     else
; 1083 :     {
; 1084 :         return FALSE;
; 1085 :     }
; 1086 :         
; 1087 : }

  00098	98bd40f0	 ldmlsia     sp!, {r4 - r7, lr}
  0009c	912fff1e	 bxls        lr
  000a0		 |$LN4@NeedISPRes|

; 1066 :         return FALSE;

  000a0	e3a00000	 mov         r0, #0

; 1081 :     }
; 1082 :     else
; 1083 :     {
; 1084 :         return FALSE;
; 1085 :     }
; 1086 :         
; 1087 : }

  000a4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M40493|

			 ENDP  ; |?NeedISPResizer@@YAHKKK@Z|, NeedISPResizer

	EXPORT	|?SetContrastLevel@OMAPDisplayController@@QAAHK@Z| ; OMAPDisplayController::SetContrastLevel
	IMPORT	|?g_dwGammaTable@@3PAY0BAA@KA|		; g_dwGammaTable

  00000			 AREA	 |.pdata|, PDATA
|$T40508| DCD	|$LN7@SetContras|
	DCD	0x40001001
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetContrastLevel@OMAPDisplayController@@QAAHK@Z| PROC ; OMAPDisplayController::SetContrastLevel

; 3384 : {

  00000		 |$LN7@SetContras|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40505|
  00004	e1a0e001	 mov         lr, r1
  00008	e1a04000	 mov         r4, r0

; 3385 :     //  Set contrast level by copying in new gamma correction curve
; 3386 :     m_dwContrastLevel = (dwContrastLevel < NUM_CONTRAST_LEVELS) ? dwContrastLevel : NUM_CONTRAST_LEVELS - 1;
; 3387 : 
; 3388 :     //  Copy the selected table to the gamma physical memory location
; 3389 :     memcpy(m_pGammaBufVirt, &(g_dwGammaTable[(NUM_CONTRAST_LEVELS - 1) - m_dwContrastLevel][0]), NUM_GAMMA_VALS*sizeof(DWORD));

  0000c	e59f3028	 ldr         r3, [pc, #0x28]
  00010	e35e0007	 cmp         lr, #7
  00014	e59404d4	 ldr         r0, [r4, #0x4D4]
  00018	e2833b06	 add         r3, r3, #6, 22
  0001c	23a0e006	 movcs       lr, #6
  00020	e043150e	 sub         r1, r3, lr, lsl #10
  00024	e3a02b01	 mov         r2, #1, 22
  00028	e584e4d0	 str         lr, [r4, #0x4D0]
  0002c	eb000000	 bl          memcpy

; 3390 :     return TRUE;

  00030	e3a00001	 mov         r0, #1

; 3391 : }

  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$LN8@SetContras|
  0003c		 |$LN9@SetContras|
  0003c	00000000	 DCD         |?g_dwGammaTable@@3PAY0BAA@KA|
  00040		 |$M40506|

			 ENDP  ; |?SetContrastLevel@OMAPDisplayController@@QAAHK@Z|, OMAPDisplayController::SetContrastLevel

	EXPORT	|?SetTvOutFilterLevel@OMAPDisplayController@@QAAHK@Z| ; OMAPDisplayController::SetTvOutFilterLevel

  00000			 AREA	 |.pdata|, PDATA
|$T40521| DCD	|$LN5@SetTvOutFi|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetTvOutFilterLevel@OMAPDisplayController@@QAAHK@Z| PROC ; OMAPDisplayController::SetTvOutFilterLevel

; 4029 : {

  00000		 |$LN5@SetTvOutFi|
  00000		 |$M40518|

; 4030 :     //  Set flicker filter level
; 4031 :     m_dwTVFilterLevel = dwTVFilterLevel;

  00000	e58014b8	 str         r1, [r0, #0x4B8]

; 4032 :     return TRUE;

  00004	e3a00001	 mov         r0, #1

; 4033 : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M40519|

			 ENDP  ; |?SetTvOutFilterLevel@OMAPDisplayController@@QAAHK@Z|, OMAPDisplayController::SetTvOutFilterLevel

	EXPORT	|?DVISelect@OMAPDisplayController@@QAAHH@Z| ; OMAPDisplayController::DVISelect
	IMPORT	|LcdPdd_DVI_Select|

  00000			 AREA	 |.pdata|, PDATA
|$T40531| DCD	|$LN5@DVISelect|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DVISelect@OMAPDisplayController@@QAAHH@Z| PROC ; OMAPDisplayController::DVISelect

; 4162 : {

  00000		 |$LN5@DVISelect|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40528|

; 4163 :     LcdPdd_DVI_Select(bSelectDVI);

  00004	e1a00001	 mov         r0, r1
  00008	eb000000	 bl          LcdPdd_DVI_Select

; 4164 :     return TRUE;

  0000c	e3a00001	 mov         r0, #1

; 4165 : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M40529|

			 ENDP  ; |?DVISelect@OMAPDisplayController@@QAAHH@Z|, OMAPDisplayController::DVISelect

	EXPORT	|?EnableDVI@OMAPDisplayController@@QAAHH@Z| ; OMAPDisplayController::EnableDVI
	IMPORT	|LcdPdd_SetPowerLevel|

  00000			 AREA	 |.pdata|, PDATA
|$T40543| DCD	|$LN8@EnableDVI|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableDVI@OMAPDisplayController@@QAAHH@Z| PROC ; OMAPDisplayController::EnableDVI

; 4172 : {

  00000		 |$LN8@EnableDVI|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40540|
  00004	e3510000	 cmp         r1, #0
  00008	e1a04000	 mov         r4, r0

; 4173 :     BOOL    bResult = FALSE;
; 4174 : 
; 4175 :     //  Enable/disable DVI
; 4176 :     if ( bEnable )
; 4177 :     {
; 4178 :         //  Enable DVI        
; 4179 :         LcdPdd_SetPowerLevel(D4);

  0000c	e3a00004	 mov         r0, #4
  00010	0a000006	 beq         |$LN2@EnableDVI|
  00014	eb000000	 bl          LcdPdd_SetPowerLevel

; 4180 :         LcdPdd_DVI_Select(TRUE);

  00018	e3a00001	 mov         r0, #1
  0001c	eb000000	 bl          LcdPdd_DVI_Select

; 4181 :         LcdPdd_SetPowerLevel(D0);

  00020	e3a00000	 mov         r0, #0
  00024	eb000000	 bl          LcdPdd_SetPowerLevel

; 4182 :         m_bDVIEnable = TRUE;

  00028	e3a03001	 mov         r3, #1

; 4183 :     }
; 4184 :     else

  0002c	ea000005	 b           |$LN5@EnableDVI|
  00030		 |$LN2@EnableDVI|

; 4185 :     {
; 4186 :         //  Disable DVI        
; 4187 :         LcdPdd_SetPowerLevel(D4);

  00030	eb000000	 bl          LcdPdd_SetPowerLevel

; 4188 :         LcdPdd_DVI_Select(FALSE);

  00034	e3a00000	 mov         r0, #0
  00038	eb000000	 bl          LcdPdd_DVI_Select

; 4189 :         LcdPdd_SetPowerLevel(D0);

  0003c	e3a00000	 mov         r0, #0
  00040	eb000000	 bl          LcdPdd_SetPowerLevel

; 4190 :         m_bDVIEnable = FALSE;

  00044	e3a03000	 mov         r3, #0
  00048		 |$LN5@EnableDVI|
  00048	e58434cc	 str         r3, [r4, #0x4CC]

; 4191 :     }
; 4192 : 
; 4193 :     //  Success
; 4194 :     bResult = TRUE;
; 4195 : 
; 4196 :     //  Return result
; 4197 :     return bResult;

  0004c	e3a00001	 mov         r0, #1

; 4198 : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M40541|

			 ENDP  ; |?EnableDVI@OMAPDisplayController@@QAAHH@Z|, OMAPDisplayController::EnableDVI

	EXPORT	|?AccessRegs@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::AccessRegs
	IMPORT	|EnterCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T40554| DCD	|$LN9@AccessRegs|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AccessRegs@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::AccessRegs

; 4347 : {

  00000		 |$LN9@AccessRegs|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40551|
  00004	e1a04000	 mov         r4, r0

; 4348 :     BOOL    bResult = FALSE;
; 4349 : 
; 4350 :     //  Ensures that DSS regs can be accessed at current power level
; 4351 :     //  Locks power level at current level until ReleaseRegs called
; 4352 :     //  Returns FALSE if power level is too low to access regs
; 4353 : 
; 4354 :     //  Lock access to power level
; 4355 :     EnterCriticalSection( &m_csPowerLock );

  00008	e2843b01	 add         r3, r4, #1, 22
  0000c	e283008c	 add         r0, r3, #0x8C
  00010	e3a05000	 mov         r5, #0
  00014	eb000000	 bl          EnterCriticalSection

; 4356 :     
; 4357 :     //  Check power level
; 4358 :     switch( m_dwPowerLevel )

  00018	e5943488	 ldr         r3, [r4, #0x488]
  0001c	e3530002	 cmp         r3, #2
  00020	9a000003	 bls         |$LN2@AccessRegs|
  00024	e3530004	 cmp         r3, #4
  00028	8a000002	 bhi         |$LN3@AccessRegs|

; 4365 :             break;
; 4366 : 
; 4367 :         case D3:
; 4368 :         case D4:
; 4369 :             //  Clocks are off at this level
; 4370 :             bResult = FALSE;

  0002c	e3a05000	 mov         r5, #0

; 4371 :             break;

  00030	ea000000	 b           |$LN3@AccessRegs|
  00034		 |$LN2@AccessRegs|

; 4359 :     {
; 4360 :         case D0:
; 4361 :         case D1:
; 4362 :         case D2:
; 4363 :             //  Clocks are on at this level
; 4364 :             bResult = TRUE;

  00034	e3a05001	 mov         r5, #1
  00038		 |$LN3@AccessRegs|

; 4372 :     }
; 4373 :     
; 4374 :     //  Return result
; 4375 :     return bResult;
; 4376 : }

  00038	e1a00005	 mov         r0, r5
  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$M40552|

			 ENDP  ; |?AccessRegs@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::AccessRegs

	EXPORT	|?ReleaseRegs@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::ReleaseRegs
	IMPORT	|LeaveCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T40564| DCD	|$LN5@ReleaseReg|
	DCD	0x40000701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReleaseRegs@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::ReleaseRegs

; 4381 : {

  00000		 |$LN5@ReleaseReg|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40561|

; 4382 :     //  Releases power lock
; 4383 :     LeaveCriticalSection( &m_csPowerLock );

  00004	e2803b01	 add         r3, r0, #1, 22
  00008	e283008c	 add         r0, r3, #0x8C
  0000c	eb000000	 bl          LeaveCriticalSection

; 4384 :     return TRUE;

  00010	e3a00001	 mov         r0, #1

; 4385 : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$M40562|

			 ENDP  ; |?ReleaseRegs@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::ReleaseRegs

	EXPORT	|?FlushRegs@OMAPDisplayController@@IAAHK@Z| ; OMAPDisplayController::FlushRegs
	IMPORT	|StallExecution|

  00000			 AREA	 |.pdata|, PDATA
|$T40583| DCD	|$LN15@FlushRegs|
	DCD	0x40001901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlushRegs@OMAPDisplayController@@IAAHK@Z| PROC ; OMAPDisplayController::FlushRegs

; 4392 : {

  00000		 |$LN15@FlushRegs|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M40580|
  00004	e1a05001	 mov         r5, r1
  00008	e1a06000	 mov         r6, r0

; 4393 :     DWORD   dwTimeout = DISPLAY_TIMEOUT;
; 4394 : 
; 4395 :     //  Ensure that registers can be flushed
; 4396 :     while(((INREG32(&m_pDispRegs->DISPC_CONTROL) & dwDestGo) == dwDestGo) &&  (dwTimeout-- > 0))

  0000c	e3a0401e	 mov         r4, #0x1E
  00010	ea000004	 b           |$LN12@FlushRegs|
  00014		 |$LL3@FlushRegs|
  00014	e3540000	 cmp         r4, #0
  00018	e2444001	 sub         r4, r4, #1
  0001c	0a000006	 beq         |$LN10@FlushRegs|

; 4397 :     {
; 4398 :         // delay
; 4399 :         StallExecution(10);

  00020	e3a0000a	 mov         r0, #0xA
  00024	eb000000	 bl          StallExecution
  00028		 |$LN12@FlushRegs|
  00028	e5963008	 ldr         r3, [r6, #8]
  0002c	e5933040	 ldr         r3, [r3, #0x40]
  00030	e0033005	 and         r3, r3, r5
  00034	e1530005	 cmp         r3, r5
  00038	0afffff5	 beq         |$LL3@FlushRegs|
  0003c		 |$LN10@FlushRegs|

; 4400 :     }
; 4401 : 
; 4402 :     if( dwTimeout == 0 )
; 4403 :     {
; 4404 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::FlushRegs: "
; 4405 :              L"Failed to flush regs\r\n"
; 4406 :             ));
; 4407 :     }
; 4408 : 
; 4409 :     //  Flush the shadow registers
; 4410 :     SETREG32( &m_pDispRegs->DISPC_CONTROL, dwDestGo );

  0003c	e5962008	 ldr         r2, [r6, #8]

; 4411 : 
; 4412 : 
; 4413 :     //  Return result
; 4414 :     return (dwTimeout > 0);

  00040	e3540000	 cmp         r4, #0
  00044	13a00001	 movne       r0, #1
  00048	e5923040	 ldr         r3, [r2, #0x40]
  0004c	e1833005	 orr         r3, r3, r5
  00050	e5823040	 str         r3, [r2, #0x40]

; 4415 : }

  00054	18bd4070	 ldmneia     sp!, {r4 - r6, lr}

; 4411 : 
; 4412 : 
; 4413 :     //  Return result
; 4414 :     return (dwTimeout > 0);

  00058	03a00000	 moveq       r0, #0

; 4415 : }

  0005c	08bd4070	 ldmeqia     sp!, {r4 - r6, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$M40581|

			 ENDP  ; |?FlushRegs@OMAPDisplayController@@IAAHK@Z|, OMAPDisplayController::FlushRegs

	EXPORT	|?WaitForFlushDone@OMAPDisplayController@@IAAHK@Z| ; OMAPDisplayController::WaitForFlushDone
	IMPORT	|Sleep|

  00000			 AREA	 |.pdata|, PDATA
|$T40600| DCD	|$LN13@WaitForFlu|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForFlushDone@OMAPDisplayController@@IAAHK@Z| PROC ; OMAPDisplayController::WaitForFlushDone

; 4422 : {

  00000		 |$LN13@WaitForFlu|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M40597|
  00004	e1a05001	 mov         r5, r1
  00008	e1a06000	 mov         r6, r0

; 4423 :     DWORD dwTimeout = DISPLAY_TIMEOUT;
; 4424 :     
; 4425 :     //  Ensure that registers can be flushed
; 4426 :     while(((INREG32(&m_pDispRegs->DISPC_CONTROL) & dwDestGo) == dwDestGo) &&  (dwTimeout-- > 0))

  0000c	e5963008	 ldr         r3, [r6, #8]
  00010	e3a0401e	 mov         r4, #0x1E
  00014	e5933040	 ldr         r3, [r3, #0x40]
  00018	e0033005	 and         r3, r3, r5
  0001c	e1530005	 cmp         r3, r5
  00020	1a00000d	 bne         |$LN10@WaitForFlu|
  00024		 |$LL3@WaitForFlu|
  00024	e3540000	 cmp         r4, #0
  00028	e2444001	 sub         r4, r4, #1
  0002c	0a000006	 beq         |$LN2@WaitForFlu|

; 4427 :     {
; 4428 :         // delay = 1ms
; 4429 :         Sleep(1);

  00030	e3a00001	 mov         r0, #1
  00034	eb000000	 bl          Sleep
  00038	e5963008	 ldr         r3, [r6, #8]
  0003c	e5933040	 ldr         r3, [r3, #0x40]
  00040	e0033005	 and         r3, r3, r5
  00044	e1530005	 cmp         r3, r5
  00048	0afffff5	 beq         |$LL3@WaitForFlu|
  0004c		 |$LN2@WaitForFlu|

; 4430 :     }
; 4431 :     
; 4432 :     if( dwTimeout == 0 )
; 4433 :     {
; 4434 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::FlushRegs: "
; 4435 :              L"Failed to flush regs\r\n"
; 4436 :             ));
; 4437 :     }
; 4438 :     
; 4439 :     return (dwTimeout > 0);

  0004c	e3540000	 cmp         r4, #0
  00050	03a00000	 moveq       r0, #0

; 4440 :     
; 4441 : }    

  00054	08bd4070	 ldmeqia     sp!, {r4 - r6, lr}
  00058	012fff1e	 bxeq        lr
  0005c		 |$LN10@WaitForFlu|

; 4430 :     }
; 4431 :     
; 4432 :     if( dwTimeout == 0 )
; 4433 :     {
; 4434 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::FlushRegs: "
; 4435 :              L"Failed to flush regs\r\n"
; 4436 :             ));
; 4437 :     }
; 4438 :     
; 4439 :     return (dwTimeout > 0);

  0005c	e3a00001	 mov         r0, #1

; 4440 :     
; 4441 : }    

  00060	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M40598|

			 ENDP  ; |?WaitForFlushDone@OMAPDisplayController@@IAAHK@Z|, OMAPDisplayController::WaitForFlushDone

	EXPORT	|?RequestClock@OMAPDisplayController@@IAAHK@Z| ; OMAPDisplayController::RequestClock
	IMPORT	|EnableDeviceClocks|

  00000			 AREA	 |.pdata|, PDATA
|$T40610| DCD	|$LN5@RequestClo|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RequestClock@OMAPDisplayController@@IAAHK@Z| PROC ; OMAPDisplayController::RequestClock

; 4447 : {

  00000		 |$LN5@RequestClo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40607|
  00004	e1a00001	 mov         r0, r1

; 4448 :     return EnableDeviceClocks(dwClock, TRUE);

  00008	e3a01001	 mov         r1, #1
  0000c	eb000000	 bl          EnableDeviceClocks

; 4449 : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M40608|

			 ENDP  ; |?RequestClock@OMAPDisplayController@@IAAHK@Z|, OMAPDisplayController::RequestClock

	EXPORT	|?ReleaseClock@OMAPDisplayController@@IAAHK@Z| ; OMAPDisplayController::ReleaseClock

  00000			 AREA	 |.pdata|, PDATA
|$T40620| DCD	|$LN5@ReleaseClo|
	DCD	0x40000601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ReleaseClock@OMAPDisplayController@@IAAHK@Z| PROC ; OMAPDisplayController::ReleaseClock

; 4456 : {

  00000		 |$LN5@ReleaseClo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40617|
  00004	e1a00001	 mov         r0, r1

; 4457 :     return EnableDeviceClocks(dwClock, FALSE);

  00008	e3a01000	 mov         r1, #0
  0000c	eb000000	 bl          EnableDeviceClocks

; 4458 : }

  00010	e49de004	 ldr         lr, [sp], #4
  00014	e12fff1e	 bx          lr
  00018		 |$M40618|

			 ENDP  ; |?ReleaseClock@OMAPDisplayController@@IAAHK@Z|, OMAPDisplayController::ReleaseClock

	EXPORT	|?WaitForFrameDone@OMAPDisplayController@@IAAHK@Z| ; OMAPDisplayController::WaitForFrameDone

  00000			 AREA	 |.pdata|, PDATA
|$T40636| DCD	|$LN13@WaitForFra|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForFrameDone@OMAPDisplayController@@IAAHK@Z| PROC ; OMAPDisplayController::WaitForFrameDone

; 4465 : {

  00000		 |$LN13@WaitForFra|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M40633|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0

; 4466 :     //  Wait for VYSNC status
; 4467 :     OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_FRAMEDONE );

  0000c	e5953008	 ldr         r3, [r5, #8]
  00010	e3a06001	 mov         r6, #1
  00014	e5836018	 str         r6, [r3, #0x18]

; 4468 :     while (((INREG32(&m_pDispRegs->DISPC_IRQSTATUS) & DISPC_IRQSTATUS_FRAMEDONE) == 0) && (dwTimeout-- > 0))

  00018	ea000004	 b           |$LN10@WaitForFra|
  0001c		 |$LL3@WaitForFra|
  0001c	e3540000	 cmp         r4, #0
  00020	e2444001	 sub         r4, r4, #1
  00024	0a000005	 beq         |$LN8@WaitForFra|

; 4469 :     {
; 4470 :         // delay
; 4471 :         Sleep(1);

  00028	e3a00001	 mov         r0, #1
  0002c	eb000000	 bl          Sleep
  00030		 |$LN10@WaitForFra|
  00030	e5953008	 ldr         r3, [r5, #8]
  00034	e5933018	 ldr         r3, [r3, #0x18]
  00038	e3130001	 tst         r3, #1
  0003c	0afffff6	 beq         |$LL3@WaitForFra|
  00040		 |$LN8@WaitForFra|

; 4472 :     }
; 4473 : 
; 4474 :     if ( dwTimeout == 0 )

  00040	e3540000	 cmp         r4, #0

; 4475 :     {
; 4476 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::WaitForFrameDone: timeout\r\n"));
; 4477 :         return FALSE;

  00044	03a00000	 moveq       r0, #0

; 4484 : }

  00048	08bd4070	 ldmeqia     sp!, {r4 - r6, lr}

; 4478 :     }
; 4479 : 
; 4480 :     //  Clear the status
; 4481 :     OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_FRAMEDONE );

  0004c	15953008	 ldrne       r3, [r5, #8]

; 4482 : 
; 4483 :     return TRUE;

  00050	13a00001	 movne       r0, #1
  00054	15836018	 strne       r6, [r3, #0x18]

; 4484 : }

  00058	18bd4070	 ldmneia     sp!, {r4 - r6, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M40634|

			 ENDP  ; |?WaitForFrameDone@OMAPDisplayController@@IAAHK@Z|, OMAPDisplayController::WaitForFrameDone

	EXPORT	|?WaitForIRQ@OMAPDisplayController@@IAAHKK@Z| ; OMAPDisplayController::WaitForIRQ

  00000			 AREA	 |.pdata|, PDATA
|$T40656| DCD	|$LN17@WaitForIRQ|
	DCD	0x40001f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForIRQ@OMAPDisplayController@@IAAHKK@Z| PROC ; OMAPDisplayController::WaitForIRQ

; 4492 : {

  00000		 |$LN17@WaitForIRQ|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M40653|
  00004	e1a04002	 mov         r4, r2
  00008	e1a06001	 mov         r6, r1
  0000c	e1a05000	 mov         r5, r0

; 4493 :     if(AccessRegs() == FALSE)

  00010	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00014	e3500000	 cmp         r0, #0
  00018	0a000011	 beq         |$cleanup$39554|

; 4494 :     {
; 4495 :         goto cleanup;
; 4496 :     }
; 4497 : 
; 4498 : 
; 4499 :     //  Wait for VYSNC status
; 4500 :     SETREG32( &m_pDispRegs->DISPC_IRQSTATUS, dwIRQ );

  0001c	e595e008	 ldr         lr, [r5, #8]
  00020	e59e3018	 ldr         r3, [lr, #0x18]
  00024	e1833006	 orr         r3, r3, r6
  00028	e58e3018	 str         r3, [lr, #0x18]

; 4501 :     while(((INREG32(&m_pDispRegs->DISPC_IRQSTATUS) & dwIRQ) == 0) && (dwTimeout-- > 0))

  0002c	ea000004	 b           |$LN14@WaitForIRQ|
  00030		 |$LL3@WaitForIRQ|
  00030	e3540000	 cmp         r4, #0
  00034	e2444001	 sub         r4, r4, #1
  00038	0a000005	 beq         |$LN12@WaitForIRQ|

; 4502 :     {
; 4503 :         // delay
; 4504 :         Sleep(1);

  0003c	e3a00001	 mov         r0, #1
  00040	eb000000	 bl          Sleep
  00044		 |$LN14@WaitForIRQ|
  00044	e5953008	 ldr         r3, [r5, #8]
  00048	e5933018	 ldr         r3, [r3, #0x18]
  0004c	e1130006	 tst         r3, r6
  00050	0afffff6	 beq         |$LL3@WaitForIRQ|
  00054		 |$LN12@WaitForIRQ|

; 4505 :     }
; 4506 : 
; 4507 :     if( dwTimeout == 0 )
; 4508 :     {
; 4509 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::WaitForIRQ: "
; 4510 :              L"IRQ = 0x%X failed to happen before timeout\r\n", dwIRQ
; 4511 :             ));
; 4512 :     }
; 4513 : 
; 4514 :     //  Clear the status
; 4515 :     SETREG32( &m_pDispRegs->DISPC_IRQSTATUS, dwIRQ );

  00054	e5952008	 ldr         r2, [r5, #8]
  00058	e5923018	 ldr         r3, [r2, #0x18]
  0005c	e1833006	 orr         r3, r3, r6
  00060	e5823018	 str         r3, [r2, #0x18]
  00064		 |$cleanup$39554|

; 4516 :     
; 4517 : cleanup:
; 4518 : 
; 4519 :     ReleaseRegs();

  00064	e2853b01	 add         r3, r5, #1, 22
  00068	e283008c	 add         r0, r3, #0x8C
  0006c	eb000000	 bl          LeaveCriticalSection

; 4520 : 
; 4521 :     //  Status
; 4522 :     return TRUE;

  00070	e3a00001	 mov         r0, #1

; 4523 : }

  00074	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00078	e12fff1e	 bx          lr
  0007c		 |$M40654|

			 ENDP  ; |?WaitForIRQ@OMAPDisplayController@@IAAHKK@Z|, OMAPDisplayController::WaitForIRQ

	EXPORT	|?PixelFormatToPixelSize@OMAPDisplayController@@SAKW4OMAP_DSS_PIXELFORMAT@@@Z| ; OMAPDisplayController::PixelFormatToPixelSize

  00000			 AREA	 |.pdata|, PDATA
|$T40667| DCD	|$LN9@PixelForma@2|
	DCD	0x40001300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PixelFormatToPixelSize@OMAPDisplayController@@SAKW4OMAP_DSS_PIXELFORMAT@@@Z| PROC ; OMAPDisplayController::PixelFormatToPixelSize

; 4530 : {

  00000		 |$LN9@PixelForma@2|
  00000		 |$M40664|

; 4531 :     DWORD   dwResult = 1;

  00000	e3a03001	 mov         r3, #1

; 4532 :     
; 4533 :     //  Convert pixel format into bytes per pixel
; 4534 :     switch( ePixelFormat )

  00004	e3500005	 cmp         r0, #5
  00008	ba00000d	 blt         |$LN3@PixelForma@2|
  0000c	e3500006	 cmp         r0, #6
  00010	da00000a	 ble         |$LN2@PixelForma@2|
  00014	e3500008	 cmp         r0, #8
  00018	0a000005	 beq         |$LN1@PixelForma@2|
  0001c	e3500009	 cmp         r0, #9
  00020	da000007	 ble         |$LN3@PixelForma@2|
  00024	e350000b	 cmp         r0, #0xB
  00028	da000004	 ble         |$LN2@PixelForma@2|
  0002c	e350000d	 cmp         r0, #0xD
  00030	ca000003	 bgt         |$LN3@PixelForma@2|
  00034		 |$LN1@PixelForma@2|

; 4542 :             break;
; 4543 : 
; 4544 :         case OMAP_DSS_PIXELFORMAT_RGB32:
; 4545 :         case OMAP_DSS_PIXELFORMAT_ARGB32:
; 4546 :         case OMAP_DSS_PIXELFORMAT_RGBA32:
; 4547 :             //  4 bytes per pixel
; 4548 :             dwResult = 4;

  00034	e3a03004	 mov         r3, #4

; 4549 :             break;
; 4550 :     }
; 4551 : 
; 4552 :     //  Return result
; 4553 :     return dwResult;
; 4554 : }

  00038	e1a00003	 mov         r0, r3
  0003c	e12fff1e	 bx          lr
  00040		 |$LN2@PixelForma@2|

; 4535 :     {
; 4536 :         case OMAP_DSS_PIXELFORMAT_RGB16:
; 4537 :         case OMAP_DSS_PIXELFORMAT_ARGB16:
; 4538 :         case OMAP_DSS_PIXELFORMAT_YUV2:
; 4539 :         case OMAP_DSS_PIXELFORMAT_UYVY:
; 4540 :             //  2 bytes per pixel
; 4541 :             dwResult = 2;

  00040	e3a03002	 mov         r3, #2
  00044		 |$LN3@PixelForma@2|

; 4549 :             break;
; 4550 :     }
; 4551 : 
; 4552 :     //  Return result
; 4553 :     return dwResult;
; 4554 : }

  00044	e1a00003	 mov         r0, r3
  00048	e12fff1e	 bx          lr
  0004c		 |$M40665|

			 ENDP  ; |?PixelFormatToPixelSize@OMAPDisplayController@@SAKW4OMAP_DSS_PIXELFORMAT@@@Z|, OMAPDisplayController::PixelFormatToPixelSize

	EXPORT	|?EnableVSyncInterruptEx@OMAPDisplayController@@QAAHXZ| ; OMAPDisplayController::EnableVSyncInterruptEx

  00000			 AREA	 |.pdata|, PDATA
|$T40684| DCD	|$LN13@EnableVSyn|
	DCD	0x40002601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableVSyncInterruptEx@OMAPDisplayController@@QAAHXZ| PROC ; OMAPDisplayController::EnableVSyncInterruptEx

; 4558 : {

  00000		 |$LN13@EnableVSyn|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40681|
  00004	e1a05000	 mov         r5, r0

; 4559 :     BOOL bInterruptAlreadyEnabled = FALSE;
; 4560 :     DWORD irqEnableStatus;
; 4561 :     
; 4562 :     if (!m_dwEnableWaitForVerticalBlank)

  00008	e5953500	 ldr         r3, [r5, #0x500]
  0000c	e3a04000	 mov         r4, #0
  00010	e3530000	 cmp         r3, #0

; 4563 :         return FALSE;

  00014	03a04000	 moveq       r4, #0
  00018	0a00001b	 beq         |$LN5@EnableVSyn|

; 4564 : 
; 4565 :     if(AccessRegs() == FALSE)

  0001c	e1a00005	 mov         r0, r5
  00020	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00024	e3500000	 cmp         r0, #0
  00028	0a000014	 beq         |$cleanup$39585|

; 4566 :     {
; 4567 :         goto cleanup;
; 4568 :     }
; 4569 : 
; 4570 :     irqEnableStatus = INREG32(&m_pDispRegs->DISPC_IRQENABLE);

  0002c	e5951008	 ldr         r1, [r5, #8]
  00030	e591201c	 ldr         r2, [r1, #0x1C]

; 4571 :     bInterruptAlreadyEnabled = ((irqEnableStatus & DISPC_IRQENABLE_VSYNC) == DISPC_IRQENABLE_VSYNC) ||
; 4572 :                                 ((irqEnableStatus & DISPC_IRQSTATUS_EVSYNC_EVEN) == DISPC_IRQSTATUS_EVSYNC_EVEN) ||
; 4573 :                                 ((irqEnableStatus & DISPC_IRQSTATUS_EVSYNC_ODD) == DISPC_IRQSTATUS_EVSYNC_ODD);

  00034	e2023002	 and         r3, r2, #2
  00038	e3530002	 cmp         r3, #2
  0003c	0a000005	 beq         |$LN7@EnableVSyn|
  00040	e2023004	 and         r3, r2, #4
  00044	e3530004	 cmp         r3, #4
  00048	12023008	 andne       r3, r2, #8
  0004c	13530008	 cmpne       r3, #8
  00050	13a04000	 movne       r4, #0
  00054	1a000000	 bne         |$LN8@EnableVSyn|
  00058		 |$LN7@EnableVSyn|
  00058	e3a04001	 mov         r4, #1
  0005c		 |$LN8@EnableVSyn|

; 4574 :                         
; 4575 :                                 
; 4576 :     
; 4577 :     SETREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VSYNC);

  0005c	e591301c	 ldr         r3, [r1, #0x1C]
  00060	e3833002	 orr         r3, r3, #2
  00064	e581301c	 str         r3, [r1, #0x1C]

; 4578 :     if(m_bTVEnable == TRUE)

  00068	e59534b4	 ldr         r3, [r5, #0x4B4]
  0006c	e3530001	 cmp         r3, #1

; 4579 :     {
; 4580 :         SETREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_EVSYNC_EVEN | DISPC_IRQENABLE_EVSYNC_ODD);

  00070	05952008	 ldreq       r2, [r5, #8]
  00074	0592301c	 ldreq       r3, [r2, #0x1C]
  00078	0383300c	 orreq       r3, r3, #0xC
  0007c	0582301c	 streq       r3, [r2, #0x1C]
  00080		 |$cleanup$39585|

; 4581 :     }
; 4582 : 
; 4583 : 
; 4584 : cleanup:
; 4585 : 
; 4586 :     ReleaseRegs();

  00080	e2853b01	 add         r3, r5, #1, 22
  00084	e283008c	 add         r0, r3, #0x8C
  00088	eb000000	 bl          LeaveCriticalSection

; 4587 :     return bInterruptAlreadyEnabled;

  0008c		 |$LN5@EnableVSyn|

; 4588 : }

  0008c	e1a00004	 mov         r0, r4
  00090	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00094	e12fff1e	 bx          lr
  00098		 |$M40682|

			 ENDP  ; |?EnableVSyncInterruptEx@OMAPDisplayController@@QAAHXZ|, OMAPDisplayController::EnableVSyncInterruptEx

	EXPORT	|?EnableVSyncInterrupt@OMAPDisplayController@@QAAXXZ| ; OMAPDisplayController::EnableVSyncInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T40695| DCD	|$LN10@EnableVSyn@2|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableVSyncInterrupt@OMAPDisplayController@@QAAXXZ| PROC ; OMAPDisplayController::EnableVSyncInterrupt

; 4592 : {

  00000		 |$LN10@EnableVSyn@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40692|
  00004	e1a04000	 mov         r4, r0

; 4593 :     if(AccessRegs() == FALSE)

  00008	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  0000c	e3500000	 cmp         r0, #0
  00010	0a000009	 beq         |$cleanup$39599|

; 4594 :     {
; 4595 :         goto cleanup;
; 4596 :     }
; 4597 : 
; 4598 :     SETREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VSYNC);

  00014	e5942008	 ldr         r2, [r4, #8]
  00018	e592301c	 ldr         r3, [r2, #0x1C]
  0001c	e3833002	 orr         r3, r3, #2
  00020	e582301c	 str         r3, [r2, #0x1C]

; 4599 :     if(m_bTVEnable == TRUE)

  00024	e59434b4	 ldr         r3, [r4, #0x4B4]
  00028	e3530001	 cmp         r3, #1

; 4600 :     {
; 4601 :         SETREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_EVSYNC_EVEN | DISPC_IRQENABLE_EVSYNC_ODD);

  0002c	05942008	 ldreq       r2, [r4, #8]
  00030	0592301c	 ldreq       r3, [r2, #0x1C]
  00034	0383300c	 orreq       r3, r3, #0xC
  00038	0582301c	 streq       r3, [r2, #0x1C]
  0003c		 |$cleanup$39599|

; 4602 :     }
; 4603 : 
; 4604 : cleanup:
; 4605 : 
; 4606 :     ReleaseRegs();

  0003c	e2843b01	 add         r3, r4, #1, 22
  00040	e283008c	 add         r0, r3, #0x8C
  00044	eb000000	 bl          LeaveCriticalSection

; 4607 : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M40693|

			 ENDP  ; |?EnableVSyncInterrupt@OMAPDisplayController@@QAAXXZ|, OMAPDisplayController::EnableVSyncInterrupt

	EXPORT	|?DisableVSyncInterrupt@OMAPDisplayController@@QAAXXZ| ; OMAPDisplayController::DisableVSyncInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T40706| DCD	|$LN10@DisableVSy|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableVSyncInterrupt@OMAPDisplayController@@QAAXXZ| PROC ; OMAPDisplayController::DisableVSyncInterrupt

; 4611 : {

  00000		 |$LN10@DisableVSy|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40703|
  00004	e1a04000	 mov         r4, r0

; 4612 :     
; 4613 :     m_lastVsyncIRQStatus = 0;

  00008	e3a03000	 mov         r3, #0
  0000c	e5843538	 str         r3, [r4, #0x538]

; 4614 :     if(AccessRegs() == FALSE)

  00010	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00014	e3500000	 cmp         r0, #0
  00018	0a000009	 beq         |$cleanup$39612|

; 4615 :     {
; 4616 :         goto cleanup;
; 4617 :     }
; 4618 :         
; 4619 :     CLRREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VSYNC);

  0001c	e5942008	 ldr         r2, [r4, #8]
  00020	e592301c	 ldr         r3, [r2, #0x1C]
  00024	e3c33002	 bic         r3, r3, #2
  00028	e582301c	 str         r3, [r2, #0x1C]

; 4620 :     if(m_bTVEnable == TRUE)

  0002c	e59434b4	 ldr         r3, [r4, #0x4B4]
  00030	e3530001	 cmp         r3, #1

; 4621 :     {
; 4622 :         CLRREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_EVSYNC_EVEN | DISPC_IRQENABLE_EVSYNC_ODD);

  00034	05942008	 ldreq       r2, [r4, #8]
  00038	0592301c	 ldreq       r3, [r2, #0x1C]
  0003c	03c3300c	 biceq       r3, r3, #0xC
  00040	0582301c	 streq       r3, [r2, #0x1C]
  00044		 |$cleanup$39612|

; 4623 :     }
; 4624 : 
; 4625 : cleanup:
; 4626 : 
; 4627 :     ReleaseRegs();

  00044	e2843b01	 add         r3, r4, #1, 22
  00048	e283008c	 add         r0, r3, #0x8C
  0004c	eb000000	 bl          LeaveCriticalSection

; 4628 : }

  00050	e8bd4010	 ldmia       sp!, {r4, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M40704|

			 ENDP  ; |?DisableVSyncInterrupt@OMAPDisplayController@@QAAXXZ|, OMAPDisplayController::DisableVSyncInterrupt

	EXPORT	|?InVSync@OMAPDisplayController@@QAAHH@Z| ; OMAPDisplayController::InVSync

  00000			 AREA	 |.pdata|, PDATA
|$T40728| DCD	|$LN18@InVSync|
	DCD	0x40003701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InVSync@OMAPDisplayController@@QAAHH@Z| PROC ; OMAPDisplayController::InVSync

; 4632 : {

  00000		 |$LN18@InVSync|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M40725|
  00004	e1a07001	 mov         r7, r1
  00008	e1a05000	 mov         r5, r0

; 4633 :     BOOL bInVSync = FALSE;
; 4634 :     DWORD irqStatus = 0;
; 4635 :     BOOL  lcdVsync = FALSE;
; 4636 :     //Alwasy set to true, in case tv-out is disabled.
; 4637 :     BOOL  tvVsync = TRUE;
; 4638 : 
; 4639 :     if (!m_dwEnableWaitForVerticalBlank)

  0000c	e5953500	 ldr         r3, [r5, #0x500]
  00010	e3a04000	 mov         r4, #0
  00014	e3a06001	 mov         r6, #1
  00018	e3530000	 cmp         r3, #0

; 4640 :         return TRUE;

  0001c	03a04001	 moveq       r4, #1
  00020	0a00002a	 beq         |$LN8@InVSync|

; 4641 : 
; 4642 :     if(AccessRegs() == FALSE)

  00024	e1a00005	 mov         r0, r5
  00028	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  0002c	e3500000	 cmp         r0, #0

; 4643 :     {
; 4644 :         bInVSync = TRUE;

  00030	03a04001	 moveq       r4, #1
  00034	0a000022	 beq         |$cleanup$39631|

; 4645 :         goto cleanup;
; 4646 :     }
; 4647 : 
; 4648 :     irqStatus = INREG32(&m_pDispRegs->DISPC_IRQSTATUS);

  00038	e5950008	 ldr         r0, [r5, #8]
  0003c	e5901018	 ldr         r1, [r0, #0x18]

; 4649 :     lcdVsync = (irqStatus & DISPC_IRQSTATUS_VSYNC) == DISPC_IRQSTATUS_VSYNC;

  00040	e2013002	 and         r3, r1, #2
  00044	e3530002	 cmp         r3, #2

; 4650 :     if(m_bTVEnable == TRUE)

  00048	e59534b4	 ldr         r3, [r5, #0x4B4]
  0004c	03a02001	 moveq       r2, #1
  00050	13a02000	 movne       r2, #0
  00054	e3530001	 cmp         r3, #1
  00058	1a000005	 bne         |$LN13@InVSync|

; 4651 :     {
; 4652 :         tvVsync = ((irqStatus & DISPC_IRQSTATUS_EVSYNC_EVEN) == DISPC_IRQSTATUS_EVSYNC_EVEN) ||
; 4653 :                   ((irqStatus & DISPC_IRQSTATUS_EVSYNC_ODD) == DISPC_IRQSTATUS_EVSYNC_ODD);

  0005c	e2013004	 and         r3, r1, #4
  00060	e3530004	 cmp         r3, #4
  00064	12013008	 andne       r3, r1, #8
  00068	13530008	 cmpne       r3, #8
  0006c	13a06000	 movne       r6, #0
  00070	03a06001	 moveq       r6, #1
  00074		 |$LN13@InVSync|

; 4654 :           
; 4655 :     }
; 4656 :     //If tv-out is enabled we also need to check of it's VSYNC signal. Once both have been asserted then 
; 4657 :     //we can say that Vsync has occurred. 
; 4658 :     if( lcdVsync && tvVsync)

  00074	e3520000	 cmp         r2, #0
  00078	0a000011	 beq         |$cleanup$39631|
  0007c	e3560000	 cmp         r6, #0
  00080	0a00000f	 beq         |$cleanup$39631|

; 4659 :     {
; 4660 :         bInVSync = TRUE;

  00084	e3a04001	 mov         r4, #1

; 4661 : 
; 4662 :         if(bClearStatus)

  00088	e3570000	 cmp         r7, #0
  0008c	0a00000c	 beq         |$cleanup$39631|

; 4663 :         {
; 4664 :             SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_VSYNC);

  00090	e5903018	 ldr         r3, [r0, #0x18]
  00094	e3833002	 orr         r3, r3, #2
  00098	e5803018	 str         r3, [r0, #0x18]

; 4665 :             if(m_bTVEnable == TRUE)

  0009c	e59534b4	 ldr         r3, [r5, #0x4B4]
  000a0	e3530001	 cmp         r3, #1

; 4666 :             {
; 4667 :                 SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_EVSYNC_EVEN); 

  000a4	05952008	 ldreq       r2, [r5, #8]
  000a8	05923018	 ldreq       r3, [r2, #0x18]
  000ac	03833004	 orreq       r3, r3, #4
  000b0	05823018	 streq       r3, [r2, #0x18]

; 4668 :                 SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_EVSYNC_ODD); 

  000b4	05952008	 ldreq       r2, [r5, #8]
  000b8	05923018	 ldreq       r3, [r2, #0x18]
  000bc	03833008	 orreq       r3, r3, #8
  000c0	05823018	 streq       r3, [r2, #0x18]
  000c4		 |$cleanup$39631|

; 4669 :             }
; 4670 :         }
; 4671 :     }
; 4672 : 
; 4673 : cleanup:
; 4674 : 
; 4675 :     ReleaseRegs();

  000c4	e2853b01	 add         r3, r5, #1, 22
  000c8	e283008c	 add         r0, r3, #0x8C
  000cc	eb000000	 bl          LeaveCriticalSection

; 4676 : 
; 4677 :     return bInVSync;

  000d0		 |$LN8@InVSync|

; 4678 : }

  000d0	e1a00004	 mov         r0, r4
  000d4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000d8	e12fff1e	 bx          lr
  000dc		 |$M40726|

			 ENDP  ; |?InVSync@OMAPDisplayController@@QAAHH@Z|, OMAPDisplayController::InVSync

	EXPORT	|?WaitForVsync@OMAPDisplayController@@QAAXXZ| ; OMAPDisplayController::WaitForVsync

  00000			 AREA	 |.pdata|, PDATA
|$T40737| DCD	|$LN8@WaitForVsy|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForVsync@OMAPDisplayController@@QAAXXZ| PROC ; OMAPDisplayController::WaitForVsync

; 4682 : {

  00000		 |$LN8@WaitForVsy|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40734|
  00004	e1a05000	 mov         r5, r0

; 4683 :     BOOL bVsyncPreviouslyEnabled = FALSE;
; 4684 : 
; 4685 :     if (!m_dwEnableWaitForVerticalBlank)

  00008	e5953500	 ldr         r3, [r5, #0x500]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000c	 beq         |$LN1@WaitForVsy|

; 4686 :         return;
; 4687 : 
; 4688 :     if(!InVSync(TRUE))

  00014	e3a01001	 mov         r1, #1
  00018	eb000000	 bl          |?InVSync@OMAPDisplayController@@QAAHH@Z|
  0001c	e3500000	 cmp         r0, #0
  00020	1a000008	 bne         |$LN1@WaitForVsy|

; 4689 :     {             
; 4690 :         bVsyncPreviouslyEnabled = EnableVSyncInterruptEx();

  00024	e1a00005	 mov         r0, r5
  00028	eb000000	 bl          |?EnableVSyncInterruptEx@OMAPDisplayController@@QAAHXZ|

; 4691 :         WaitForSingleObject(m_hVsyncEvent, m_dwVsyncPeriod);

  0002c	e59514fc	 ldr         r1, [r5, #0x4FC]
  00030	e1a04000	 mov         r4, r0
  00034	e59504f4	 ldr         r0, [r5, #0x4F4]
  00038	eb000000	 bl          WaitForSingleObject

; 4692 :         //SGX may have turned on the vsync interrupt, keep it on if that's the case.
; 4693 :         if(!bVsyncPreviouslyEnabled)

  0003c	e3540000	 cmp         r4, #0

; 4694 :         {
; 4695 :             DisableVSyncInterrupt();

  00040	01a00005	 moveq       r0, r5
  00044	0b000000	 bleq        |?DisableVSyncInterrupt@OMAPDisplayController@@QAAXXZ|
  00048		 |$LN1@WaitForVsy|

; 4696 :         }
; 4697 :     }
; 4698 : }

  00048	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M40735|

			 ENDP  ; |?WaitForVsync@OMAPDisplayController@@QAAXXZ|, OMAPDisplayController::WaitForVsync

	EXPORT	|?EnableScanLineInterrupt@OMAPDisplayController@@QAAXK@Z| ; OMAPDisplayController::EnableScanLineInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T40749| DCD	|$LN11@EnableScan|
	DCD	0x40001d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableScanLineInterrupt@OMAPDisplayController@@QAAXK@Z| PROC ; OMAPDisplayController::EnableScanLineInterrupt

; 4702 : {

  00000		 |$LN11@EnableScan|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40746|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 4703 :     if (!m_dwEnableWaitForVerticalBlank)

  0000c	e5943500	 ldr         r3, [r4, #0x500]
  00010	e3530000	 cmp         r3, #0
  00014	0a000014	 beq         |$LN7@EnableScan|

; 4704 :         return;
; 4705 : 
; 4706 :     if(AccessRegs() == FALSE)

  00018	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  0001c	e3500000	 cmp         r0, #0
  00020	0a00000e	 beq         |$cleanup$39660|

; 4707 :     {
; 4708 :         goto cleanup;
; 4709 :     }
; 4710 : 
; 4711 :     //  Program line number to interrupt on
; 4712 :     if(INREG32(&m_pDispRegs->DISPC_LINE_NUMBER) != dwLineNumber)

  00024	e5942008	 ldr         r2, [r4, #8]
  00028	e5923060	 ldr         r3, [r2, #0x60]
  0002c	e1530005	 cmp         r3, r5

; 4713 :     {
; 4714 :         OUTREG32(&m_pDispRegs->DISPC_LINE_NUMBER, dwLineNumber);
; 4715 :         FlushRegs(DISPC_CONTROL_GOLCD);

  00030	13a01020	 movne       r1, #0x20
  00034	11a00004	 movne       r0, r4
  00038	15825060	 strne       r5, [r2, #0x60]
  0003c	1b000000	 blne        |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 4716 :     }
; 4717 : 
; 4718 :     //  Enable                                
; 4719 :     SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_PROGRAMMEDLINENUMBER);

  00040	e5942008	 ldr         r2, [r4, #8]
  00044	e5923018	 ldr         r3, [r2, #0x18]
  00048	e3833020	 orr         r3, r3, #0x20
  0004c	e5823018	 str         r3, [r2, #0x18]

; 4720 :     SETREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_PROGRAMMEDLINENUMBER);

  00050	e5942008	 ldr         r2, [r4, #8]
  00054	e592301c	 ldr         r3, [r2, #0x1C]
  00058	e3833020	 orr         r3, r3, #0x20
  0005c	e582301c	 str         r3, [r2, #0x1C]
  00060		 |$cleanup$39660|

; 4721 : 
; 4722 : cleanup:
; 4723 :     ReleaseRegs();

  00060	e2843b01	 add         r3, r4, #1, 22
  00064	e283008c	 add         r0, r3, #0x8C
  00068	eb000000	 bl          LeaveCriticalSection
  0006c		 |$LN7@EnableScan|

; 4724 : }

  0006c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M40747|

			 ENDP  ; |?EnableScanLineInterrupt@OMAPDisplayController@@QAAXK@Z|, OMAPDisplayController::EnableScanLineInterrupt

	EXPORT	|?DisableScanLineInterrupt@OMAPDisplayController@@QAAXXZ| ; OMAPDisplayController::DisableScanLineInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T40760| DCD	|$LN10@DisableSca|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableScanLineInterrupt@OMAPDisplayController@@QAAXXZ| PROC ; OMAPDisplayController::DisableScanLineInterrupt

; 4728 : {

  00000		 |$LN10@DisableSca|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40757|
  00004	e1a04000	 mov         r4, r0

; 4729 :     if (!m_dwEnableWaitForVerticalBlank)

  00008	e5943500	 ldr         r3, [r4, #0x500]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000c	 beq         |$LN6@DisableSca|

; 4730 :         return;
; 4731 : 
; 4732 :     if(AccessRegs() == FALSE)

  00014	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00018	e3500000	 cmp         r0, #0

; 4733 :     {
; 4734 :         goto cleanup;
; 4735 :     }
; 4736 : 
; 4737 :     //  Disable interrupt
; 4738 :     SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_PROGRAMMEDLINENUMBER);

  0001c	15942008	 ldrne       r2, [r4, #8]

; 4739 :     CLRREG32(&m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_PROGRAMMEDLINENUMBER);

  00020	15923018	 ldrne       r3, [r2, #0x18]
  00024	13833020	 orrne       r3, r3, #0x20
  00028	15823018	 strne       r3, [r2, #0x18]
  0002c	15942008	 ldrne       r2, [r4, #8]
  00030	1592301c	 ldrne       r3, [r2, #0x1C]
  00034	13c33020	 bicne       r3, r3, #0x20
  00038	1582301c	 strne       r3, [r2, #0x1C]
  0003c		 |$cleanup$39677|

; 4740 : 
; 4741 : cleanup:
; 4742 :     ReleaseRegs();

  0003c	e2843b01	 add         r3, r4, #1, 22
  00040	e283008c	 add         r0, r3, #0x8C
  00044	eb000000	 bl          LeaveCriticalSection
  00048		 |$LN6@DisableSca|

; 4743 : }

  00048	e8bd4010	 ldmia       sp!, {r4, lr}
  0004c	e12fff1e	 bx          lr
  00050		 |$M40758|

			 ENDP  ; |?DisableScanLineInterrupt@OMAPDisplayController@@QAAXXZ|, OMAPDisplayController::DisableScanLineInterrupt

	EXPORT	|?GetScanLine@OMAPDisplayController@@QAAKXZ| ; OMAPDisplayController::GetScanLine

  00000			 AREA	 |.pdata|, PDATA
|$T40774| DCD	|$LN9@GetScanLin|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetScanLine@OMAPDisplayController@@QAAKXZ| PROC ; OMAPDisplayController::GetScanLine

; 4747 : {

  00000		 |$LN9@GetScanLin|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40771|
  00004	e1a04000	 mov         r4, r0

; 4748 :     DWORD scanLine = 0;
; 4749 :     if(AccessRegs() == FALSE)

  00008	e3a05000	 mov         r5, #0
  0000c	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00010	e3500000	 cmp         r0, #0

; 4750 :     {
; 4751 :         goto cleanup;
; 4752 :     }
; 4753 : 
; 4754 :     //  Get current scanline value
; 4755 :     scanLine = INREG32(&m_pDispRegs->DISPC_LINE_STATUS);

  00014	15943008	 ldrne       r3, [r4, #8]
  00018	1593505c	 ldrne       r5, [r3, #0x5C]
  0001c		 |$cleanup$39690|

; 4756 : 
; 4757 : cleanup:
; 4758 :     ReleaseRegs();

  0001c	e2843b01	 add         r3, r4, #1, 22
  00020	e283008c	 add         r0, r3, #0x8C
  00024	eb000000	 bl          LeaveCriticalSection

; 4759 :     return scanLine;
; 4760 : }

  00028	e1a00005	 mov         r0, r5
  0002c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M40772|

			 ENDP  ; |?GetScanLine@OMAPDisplayController@@QAAKXZ|, OMAPDisplayController::GetScanLine

	EXPORT	|?WaitForScanLine@OMAPDisplayController@@QAAXK@Z| ; OMAPDisplayController::WaitForScanLine

  00000			 AREA	 |.pdata|, PDATA
|$T40783| DCD	|$LN6@WaitForSca|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?WaitForScanLine@OMAPDisplayController@@QAAXK@Z| PROC ; OMAPDisplayController::WaitForScanLine

; 4764 : {

  00000		 |$LN6@WaitForSca|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40780|
  00004	e1a04000	 mov         r4, r0

; 4765 :     if (!m_dwEnableWaitForVerticalBlank)

  00008	e5943500	 ldr         r3, [r4, #0x500]
  0000c	e3530000	 cmp         r3, #0
  00010	0a000005	 beq         |$LN2@WaitForSca|

; 4766 :         return;
; 4767 : 
; 4768 :     //  Enable the scanline interrupt for the given line number and wait
; 4769 :     EnableScanLineInterrupt(dwLineNumber);

  00014	eb000000	 bl          |?EnableScanLineInterrupt@OMAPDisplayController@@QAAXK@Z|

; 4770 :     WaitForSingleObject(m_hScanLineEvent, m_dwVsyncPeriod);

  00018	e59414fc	 ldr         r1, [r4, #0x4FC]
  0001c	e5940504	 ldr         r0, [r4, #0x504]
  00020	eb000000	 bl          WaitForSingleObject

; 4771 :     DisableScanLineInterrupt();

  00024	e1a00004	 mov         r0, r4
  00028	eb000000	 bl          |?DisableScanLineInterrupt@OMAPDisplayController@@QAAXXZ|
  0002c		 |$LN2@WaitForSca|

; 4772 : }

  0002c	e8bd4010	 ldmia       sp!, {r4, lr}
  00030	e12fff1e	 bx          lr
  00034		 |$M40781|

			 ENDP  ; |?WaitForScanLine@OMAPDisplayController@@QAAXK@Z|, OMAPDisplayController::WaitForScanLine

	EXPORT	|?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| ; OMAPSurface::SetClipping
	IMPORT	|IntersectRect|

  00000			 AREA	 |.pdata|, PDATA
|$T40799| DCD	|$LN8@SetClippin@2|
	DCD	0x40002a02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| PROC ; OMAPSurface::SetClipping

; 4776 : {

  00000		 |$LN8@SetClippin@2|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M40796|
  00008	e1b05001	 movs        r5, r1
  0000c	e1a04000	 mov         r4, r0

; 4777 :     BOOL    bResult;
; 4778 :     RECT    rcSurf;
; 4779 :     
; 4780 :     //  Set the rect of the entire surface
; 4781 :     rcSurf.left = 0;
; 4782 :     rcSurf.top = 0;
; 4783 :     rcSurf.right = m_dwWidth;

  00010	e5943010	 ldr         r3, [r4, #0x10]

; 4784 :     rcSurf.bottom = m_dwHeight;

  00014	e5942014	 ldr         r2, [r4, #0x14]
  00018	e3a01000	 mov         r1, #0
  0001c	e3a00000	 mov         r0, #0
  00020	e58d3008	 str         r3, [sp, #8]
  00024	e58d200c	 str         r2, [sp, #0xC]

; 4785 :     
; 4786 :     //  Set the clipping region of the surface
; 4787 :     if( pClipRect == NULL )
; 4788 :     {
; 4789 :         //  No clipping; use entire surface size
; 4790 :         m_rcClip = rcSurf;

  00028	05843020	 streq       r3, [r4, #0x20]
  0002c	05842024	 streq       r2, [r4, #0x24]
  00030	e58d1000	 str         r1, [sp]
  00034	e58d0004	 str         r0, [sp, #4]
  00038	05841018	 streq       r1, [r4, #0x18]
  0003c	0584001c	 streq       r0, [r4, #0x1C]

; 4791 :         bResult = TRUE;

  00040	03a06001	 moveq       r6, #1
  00044	0a000004	 beq         |$LN2@SetClippin@2|

; 4792 :     }
; 4793 :     else
; 4794 :     {
; 4795 :         //  Find intersection of surface rect and clipping rect
; 4796 :         bResult = IntersectRect( &m_rcClip, &rcSurf, pClipRect );

  00048	e1a02005	 mov         r2, r5
  0004c	e28d1000	 add         r1, sp, #0
  00050	e2840018	 add         r0, r4, #0x18
  00054	eb000000	 bl          IntersectRect
  00058	e1a06000	 mov         r6, r0
  0005c		 |$LN2@SetClippin@2|

; 4797 :     }
; 4798 :     
; 4799 :     UpdateClipping(pClipRect);

  0005c	e5943000	 ldr         r3, [r4]
  00060	e1a01005	 mov         r1, r5
  00064	e1a00004	 mov         r0, r4
  00068	e5933024	 ldr         r3, [r3, #0x24]
  0006c	e1a0e00f	 mov         lr, pc
  00070	e12fff13	 bx          r3

; 4800 : 
; 4801 :     //  Update the given clipping rect
; 4802 :     if( pClipRect )

  00074	e3550000	 cmp         r5, #0

; 4803 :         *pClipRect = m_rcClip;

  00078	15943018	 ldrne       r3, [r4, #0x18]

; 4804 : 
; 4805 :     //  Return result
; 4806 :     return bResult;
; 4807 : }

  0007c	e1a00006	 mov         r0, r6
  00080	15853000	 strne       r3, [r5]
  00084	1594301c	 ldrne       r3, [r4, #0x1C]
  00088	15853004	 strne       r3, [r5, #4]
  0008c	15943020	 ldrne       r3, [r4, #0x20]
  00090	15853008	 strne       r3, [r5, #8]
  00094	15943024	 ldrne       r3, [r4, #0x24]
  00098	1585300c	 strne       r3, [r5, #0xC]
  0009c	e28dd010	 add         sp, sp, #0x10
  000a0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M40797|

			 ENDP  ; |?SetClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|, OMAPSurface::SetClipping

	EXPORT	|?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| ; OMAPSurface::UpdateClipping

  00000			 AREA	 |.pdata|, PDATA
|$T40810| DCD	|$LN6@UpdateClip|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z| PROC ; OMAPSurface::UpdateClipping

; 4811 : {

  00000		 |$LN6@UpdateClip|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40807|
  00004	e3510000	 cmp         r1, #0

; 4812 :     BOOL bResult = FALSE;
; 4813 : 
; 4814 :     // Could change to to ensure rectangle alignment with different
; 4815 :     // scale and decimation factors...
; 4816 :     
; 4817 :     //Force the clipping rectangle to fall in a pack pixel boundary
; 4818 :     if (pClipRect != NULL)
; 4819 :     {
; 4820 :         AdjustClippingRect(&m_rcClip, 2, 2);

  00008	15901000	 ldrne       r1, [r0]
  0000c	13a03002	 movne       r3, #2
  00010	13a02002	 movne       r2, #2
  00014	1591402c	 ldrne       r4, [r1, #0x2C]
  00018	12801018	 addne       r1, r0, #0x18
  0001c	11a0e00f	 movne       lr, pc
  00020	112fff14	 bxne        r4

; 4821 :     }
; 4822 :     
; 4823 :     bResult = TRUE;
; 4824 :     return bResult;

  00024	e3a00001	 mov         r0, #1

; 4825 : }

  00028	e8bd4010	 ldmia       sp!, {r4, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M40808|

			 ENDP  ; |?UpdateClipping@OMAPSurface@@UAAHPAUtagRECT@@@Z|, OMAPSurface::UpdateClipping

	EXPORT	|?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ| ; OMAPSurface::GetClipping

  00000			 AREA	 |.pdata|, PDATA
|$T40821| DCD	|$LN5@GetClippin|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ| PROC ; OMAPSurface::GetClipping

; 4829 : {

  00000		 |$LN5@GetClippin|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M40818|

; 4830 :     return m_rcClip;

  00004	e5903018	 ldr         r3, [r0, #0x18]
  00008	e590201c	 ldr         r2, [r0, #0x1C]
  0000c	e590e020	 ldr         lr, [r0, #0x20]
  00010	e5900024	 ldr         r0, [r0, #0x24]
  00014	e5813000	 str         r3, [r1]
  00018	e5812004	 str         r2, [r1, #4]
  0001c	e581000c	 str         r0, [r1, #0xC]

; 4831 : }

  00020	e1a00001	 mov         r0, r1
  00024	e581e008	 str         lr, [r1, #8]
  00028	e49de004	 ldr         lr, [sp], #4
  0002c	e12fff1e	 bx          lr
  00030		 |$M40819|

			 ENDP  ; |?GetClipping@OMAPSurface@@UAA?AUtagRECT@@XZ|, OMAPSurface::GetClipping

	EXPORT	|?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z| ; OMAPSurface::AdjustClippingRect
	IMPORT	|__rt_sdiv|

  00000			 AREA	 |.pdata|, PDATA
|$T40834| DCD	|$LN12@AdjustClip|
	DCD	0x40002a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z| PROC ; OMAPSurface::AdjustClippingRect

; 4835 : {

  00000		 |$LN12@AdjustClip|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M40831|
  00004	e1a05003	 mov         r5, r3
  00008	e1a06002	 mov         r6, r2
  0000c	e1b04001	 movs        r4, r1

; 4836 :     BOOL bResult = FALSE;
; 4837 : 
; 4838 :     if(srcRect == NULL)
; 4839 :     {
; 4840 :         DEBUGMSG(ZONE_ERROR,
; 4841 :             (TEXT("%S: ERROR: Null rectangle passed!\r\n"), __FUNCTION__));
; 4842 :         return bResult;

  00010	03a00000	 moveq       r0, #0

; 4861 : 
; 4862 : }

  00014	08bd40f0	 ldmeqia     sp!, {r4 - r7, lr}
  00018	012fff1e	 bxeq        lr

; 4843 :     }
; 4844 :     if(vertValue > 1)

  0001c	e3550001	 cmp         r5, #1
  00020	9a00000d	 bls         |$LN4@AdjustClip|

; 4845 :     {
; 4846 :         if( ((srcRect->top)%vertValue)!= 0)

  00024	e5941004	 ldr         r1, [r4, #4]
  00028	e1a00005	 mov         r0, r5
  0002c	e1a07005	 mov         r7, r5
  00030	eb000000	 bl          __rt_sdiv
  00034	e3510000	 cmp         r1, #0

; 4847 :             CEIL_MULT(srcRect->top, vertValue);

  00038	12803001	 addne       r3, r0, #1

; 4848 :         if( ((srcRect->bottom)%vertValue)!= 0)

  0003c	e594100c	 ldr         r1, [r4, #0xC]
  00040	10020793	 mulne       r2, r3, r7
  00044	e1a00005	 mov         r0, r5
  00048	15842004	 strne       r2, [r4, #4]
  0004c	eb000000	 bl          __rt_sdiv
  00050	e3510000	 cmp         r1, #0

; 4849 :             FLOOR_MULT(srcRect->bottom, vertValue);

  00054	10030790	 mulne       r3, r0, r7
  00058	1584300c	 strne       r3, [r4, #0xC]
  0005c		 |$LN4@AdjustClip|

; 4850 :     }
; 4851 :     if(horzValue > 1)

  0005c	e3560001	 cmp         r6, #1
  00060	9a00000d	 bls         |$LN1@AdjustClip|

; 4852 :     {
; 4853 :         if( ((srcRect->left)%horzValue)!= 0)

  00064	e5941000	 ldr         r1, [r4]
  00068	e1a00006	 mov         r0, r6
  0006c	e1a05006	 mov         r5, r6
  00070	eb000000	 bl          __rt_sdiv
  00074	e3510000	 cmp         r1, #0

; 4854 :             CEIL_MULT(srcRect->left, horzValue);

  00078	12803001	 addne       r3, r0, #1

; 4855 :         if( ((srcRect->right)%horzValue)!= 0)

  0007c	e5941008	 ldr         r1, [r4, #8]
  00080	10020593	 mulne       r2, r3, r5
  00084	e1a00006	 mov         r0, r6
  00088	15842000	 strne       r2, [r4]
  0008c	eb000000	 bl          __rt_sdiv
  00090	e3510000	 cmp         r1, #0

; 4856 :             FLOOR_MULT(srcRect->right, horzValue);

  00094	10030590	 mulne       r3, r0, r5
  00098	15843008	 strne       r3, [r4, #8]
  0009c		 |$LN1@AdjustClip|

; 4857 :     }
; 4858 : 
; 4859 :     bResult = TRUE;
; 4860 :     return bResult;

  0009c	e3a00001	 mov         r0, #1

; 4861 : 
; 4862 : }

  000a0	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$M40832|

			 ENDP  ; |?AdjustClippingRect@OMAPSurface@@UAAHPAUtagRECT@@EE@Z|, OMAPSurface::AdjustClippingRect

	EXPORT	|?SetHorizontalScaling@OMAPSurface@@UAAHK@Z| ; OMAPSurface::SetHorizontalScaling

  00000			 AREA	 |.pdata|, PDATA
|$T40846| DCD	|$LN10@SetHorizon|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetHorizontalScaling@OMAPSurface@@UAAHK@Z| PROC ; OMAPSurface::SetHorizontalScaling

; 4866 : {

  00000		 |$LN10@SetHorizon|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40843|
  00004	e3510000	 cmp         r1, #0

; 4867 :     BOOL    bResult;
; 4868 : 
; 4869 :     //  Validate scaling factor
; 4870 :     switch( dwScaleFactor )

  00008	0a000008	 beq         |$LN2@SetHorizon|
  0000c	e3510002	 cmp         r1, #2
  00010	9a000003	 bls         |$LN3@SetHorizon|
  00014	e3510004	 cmp         r1, #4
  00018	0a000001	 beq         |$LN3@SetHorizon|
  0001c	e3510008	 cmp         r1, #8
  00020	1a000002	 bne         |$LN2@SetHorizon|
  00024		 |$LN3@SetHorizon|

; 4871 :     {
; 4872 :         case 1:
; 4873 :         case 2:
; 4874 :         case 4:
; 4875 :         case 8:
; 4876 :             //  Valid scaling factors
; 4877 :             m_dwHorizScale = dwScaleFactor;

  00024	e5801028	 str         r1, [r0, #0x28]

; 4878 :             bResult = TRUE;

  00028	e3a04001	 mov         r4, #1

; 4879 :             break;

  0002c	ea000000	 b           |$LN4@SetHorizon|
  00030		 |$LN2@SetHorizon|

; 4880 :                     
; 4881 :         default:
; 4882 :             //  Invalid
; 4883 :             bResult = FALSE;

  00030	e3a04000	 mov         r4, #0
  00034		 |$LN4@SetHorizon|

; 4884 :             break;
; 4885 :     }
; 4886 : 
; 4887 :     if ((m_pAssocSurface) && (m_eSurfaceType==OMAP_SURFACE_NORMAL))

  00034	e59030a0	 ldr         r3, [r0, #0xA0]
  00038	e1b02003	 movs        r2, r3
  0003c	0a000006	 beq         |$LN1@SetHorizon|
  00040	e590309c	 ldr         r3, [r0, #0x9C]
  00044	e3530000	 cmp         r3, #0

; 4888 :         m_pAssocSurface->SetHorizontalScaling(dwScaleFactor);

  00048	05923000	 ldreq       r3, [r2]
  0004c	01a00002	 moveq       r0, r2
  00050	05933030	 ldreq       r3, [r3, #0x30]
  00054	01a0e00f	 moveq       lr, pc
  00058	012fff13	 bxeq        r3
  0005c		 |$LN1@SetHorizon|

; 4889 :     
; 4890 :     //  Return result
; 4891 :     return bResult;
; 4892 : }

  0005c	e1a00004	 mov         r0, r4
  00060	e8bd4010	 ldmia       sp!, {r4, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M40844|

			 ENDP  ; |?SetHorizontalScaling@OMAPSurface@@UAAHK@Z|, OMAPSurface::SetHorizontalScaling

	EXPORT	|?SetVerticalScaling@OMAPSurface@@UAAHK@Z| ; OMAPSurface::SetVerticalScaling

  00000			 AREA	 |.pdata|, PDATA
|$T40858| DCD	|$LN10@SetVertica|
	DCD	0x40001a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetVerticalScaling@OMAPSurface@@UAAHK@Z| PROC ; OMAPSurface::SetVerticalScaling

; 4896 : {

  00000		 |$LN10@SetVertica|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M40855|
  00004	e3510000	 cmp         r1, #0

; 4897 :     BOOL    bResult;
; 4898 : 
; 4899 :     //  Validate scaling factor
; 4900 :     switch( dwScaleFactor )

  00008	0a000008	 beq         |$LN2@SetVertica|
  0000c	e3510002	 cmp         r1, #2
  00010	9a000003	 bls         |$LN3@SetVertica|
  00014	e3510004	 cmp         r1, #4
  00018	0a000001	 beq         |$LN3@SetVertica|
  0001c	e3510008	 cmp         r1, #8
  00020	1a000002	 bne         |$LN2@SetVertica|
  00024		 |$LN3@SetVertica|

; 4901 :     {
; 4902 :         case 1:
; 4903 :         case 2:
; 4904 :         case 4:
; 4905 :         case 8:
; 4906 :             //  Valid scaling factors
; 4907 :             m_dwVertScale = dwScaleFactor;

  00024	e580102c	 str         r1, [r0, #0x2C]

; 4908 :             bResult = TRUE;

  00028	e3a04001	 mov         r4, #1

; 4909 :             break;

  0002c	ea000000	 b           |$LN4@SetVertica|
  00030		 |$LN2@SetVertica|

; 4910 :                     
; 4911 :         default:
; 4912 :             //  Invalid
; 4913 :             bResult = FALSE;

  00030	e3a04000	 mov         r4, #0
  00034		 |$LN4@SetVertica|

; 4914 :             break;
; 4915 :     }
; 4916 : 
; 4917 :     if ((m_pAssocSurface) && (m_eSurfaceType==OMAP_SURFACE_NORMAL))

  00034	e59030a0	 ldr         r3, [r0, #0xA0]
  00038	e1b02003	 movs        r2, r3
  0003c	0a000006	 beq         |$LN1@SetVertica|
  00040	e590309c	 ldr         r3, [r0, #0x9C]
  00044	e3530000	 cmp         r3, #0

; 4918 :         m_pAssocSurface->SetVerticalScaling(dwScaleFactor);

  00048	05923000	 ldreq       r3, [r2]
  0004c	01a00002	 moveq       r0, r2
  00050	05933034	 ldreq       r3, [r3, #0x34]
  00054	01a0e00f	 moveq       lr, pc
  00058	012fff13	 bxeq        r3
  0005c		 |$LN1@SetVertica|

; 4919 :     
; 4920 :     //  Return result
; 4921 :     return bResult;
; 4922 : }

  0005c	e1a00004	 mov         r0, r4
  00060	e8bd4010	 ldmia       sp!, {r4, lr}
  00064	e12fff1e	 bx          lr
  00068		 |$M40856|

			 ENDP  ; |?SetVerticalScaling@OMAPSurface@@UAAHK@Z|, OMAPSurface::SetVerticalScaling

	EXPORT	|?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z| ; OMAPSurface::SetSurfaceType

  00000			 AREA	 |.pdata|, PDATA
|$T40869| DCD	|$LN5@SetSurface@2|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z| PROC ; OMAPSurface::SetSurfaceType

; 4930 : {

  00000		 |$LN5@SetSurface@2|
  00000		 |$M40866|

; 4931 :     m_eSurfaceType = eSurfaceType;

  00000	e580109c	 str         r1, [r0, #0x9C]

; 4932 :     return TRUE;

  00004	e3a00001	 mov         r0, #1

; 4933 : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M40867|

			 ENDP  ; |?SetSurfaceType@OMAPSurface@@QAAHW4OMAP_SURFACE_TYPE@@@Z|, OMAPSurface::SetSurfaceType

	EXPORT	|?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z| ; OMAPSurface::SetAssocSurface

  00000			 AREA	 |.pdata|, PDATA
|$T40880| DCD	|$LN5@SetAssocSu|
	DCD	0x40000300
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z| PROC ; OMAPSurface::SetAssocSurface

; 4940 : {

  00000		 |$LN5@SetAssocSu|
  00000		 |$M40877|

; 4941 :     m_pAssocSurface = pAssocSurface;

  00000	e58010a0	 str         r1, [r0, #0xA0]

; 4942 :     return TRUE;

  00004	e3a00001	 mov         r0, #1

; 4943 : }

  00008	e12fff1e	 bx          lr
  0000c		 |$M40878|

			 ENDP  ; |?SetAssocSurface@OMAPSurface@@QAAHPAV1@@Z|, OMAPSurface::SetAssocSurface

	EXPORT	|?UseResizer@OMAPSurface@@QAAHH@Z|	; OMAPSurface::UseResizer

  00000			 AREA	 |.pdata|, PDATA
|$T40891| DCD	|$LN7@UseResizer|
	DCD	0x40000800
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UseResizer@OMAPSurface@@QAAHH@Z| PROC ; OMAPSurface::UseResizer

; 4950 : {

  00000		 |$LN7@UseResizer|
  00000		 |$M40888|

; 4951 :     if (m_pAssocSurface)

  00000	e59030a0	 ldr         r3, [r0, #0xA0]
  00004	e3530000	 cmp         r3, #0

; 4952 :         m_bUseResizer = bUseResizer;

  00008	15801030	 strne       r1, [r0, #0x30]

; 4955 :     return m_bUseResizer;

  0000c	11a00001	 movne       r0, r1

; 4953 :     else /* force to false if Assoc Surface is not allocated */
; 4954 :         m_bUseResizer = FALSE;

  00010	03a03000	 moveq       r3, #0
  00014	05803030	 streq       r3, [r0, #0x30]

; 4955 :     return m_bUseResizer;

  00018	01a00003	 moveq       r0, r3

; 4956 : }

  0001c	e12fff1e	 bx          lr
  00020		 |$M40889|

			 ENDP  ; |?UseResizer@OMAPSurface@@QAAHH@Z|, OMAPSurface::UseResizer

	EXPORT	|?isResizerEnabled@OMAPSurface@@QAAHXZ|	; OMAPSurface::isResizerEnabled

  00000			 AREA	 |.pdata|, PDATA
|$T40901| DCD	|$LN5@isResizerE|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?isResizerEnabled@OMAPSurface@@QAAHXZ| PROC ; OMAPSurface::isResizerEnabled

; 4961 : {

  00000		 |$LN5@isResizerE|
  00000		 |$M40898|

; 4962 :     return m_bUseResizer;

  00000	e5900030	 ldr         r0, [r0, #0x30]

; 4963 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M40899|

			 ENDP  ; |?isResizerEnabled@OMAPSurface@@QAAHXZ|, OMAPSurface::isResizerEnabled

	EXPORT	|?GetRSZHandle@OMAPSurface@@QAAPAXH@Z|	; OMAPSurface::GetRSZHandle
	EXPORT	|??_C@_1M@JCBPODIL@?$AAR?$AAS?$AAZ?$AA1?$AA?3?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CreateFileW|

  00000			 AREA	 |.pdata|, PDATA
|$T40912| DCD	|$LN7@GetRSZHand|
	DCD	0x40001a02

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@JCBPODIL@?$AAR?$AAS?$AAZ?$AA1?$AA?3?$AA?$AA@| DCB "R", 0x0, "S", 0x0
	DCB	"Z", 0x0, "1", 0x0, ":", 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?GetRSZHandle@OMAPSurface@@QAAPAXH@Z| PROC ; OMAPSurface::GetRSZHandle

; 4967 : {

  00000		 |$LN7@GetRSZHand|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M40909|
  00008	e1a04000	 mov         r4, r0

; 4968 :     if ((m_hRSZHandle == NULL) && alloc)

  0000c	e5943034	 ldr         r3, [r4, #0x34]
  00010	e3530000	 cmp         r3, #0
  00014	1a00000e	 bne         |$LN1@GetRSZHand|
  00018	e3510000	 cmp         r1, #0
  0001c	0a00000c	 beq         |$LN1@GetRSZHand|

; 4969 :     {
; 4970 :         m_hRSZHandle = CreateFile( _T("RSZ1:"), 
; 4971 :                                         GENERIC_READ | GENERIC_WRITE, 0, NULL,
; 4972 :                                         OPEN_EXISTING, 0, 0 );

  00020	e59f003c	 ldr         r0, [pc, #0x3C]
  00024	e3a0e003	 mov         lr, #3
  00028	e3a05000	 mov         r5, #0
  0002c	e3a03000	 mov         r3, #0
  00030	e3a02000	 mov         r2, #0
  00034	e3a01103	 mov         r1, #3, 2
  00038	e58d5008	 str         r5, [sp, #8]
  0003c	e58d5004	 str         r5, [sp, #4]
  00040	e58de000	 str         lr, [sp]
  00044	eb000000	 bl          CreateFileW

; 4973 :         if (m_hRSZHandle == INVALID_HANDLE_VALUE)

  00048	e3700001	 cmn         r0, #1
  0004c	e5840034	 str         r0, [r4, #0x34]

; 4974 :             m_hRSZHandle = NULL;

  00050	05845034	 streq       r5, [r4, #0x34]
  00054		 |$LN1@GetRSZHand|

; 4975 : 
; 4976 :         DEBUGMSG(ZONE_WARNING, (L"GetRSZHandle: Open handle 0x%x \r\n",m_hRSZHandle));
; 4977 :         
; 4978 :     }
; 4979 :     return m_hRSZHandle;

  00054	e5940034	 ldr         r0, [r4, #0x34]

; 4980 : }

  00058	e28dd00c	 add         sp, sp, #0xC
  0005c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00060	e12fff1e	 bx          lr
  00064		 |$LN8@GetRSZHand|
  00064		 |$LN9@GetRSZHand|
  00064	00000000	 DCD         |??_C@_1M@JCBPODIL@?$AAR?$AAS?$AAZ?$AA1?$AA?3?$AA?$AA@|
  00068		 |$M40910|

			 ENDP  ; |?GetRSZHandle@OMAPSurface@@QAAPAXH@Z|, OMAPSurface::GetRSZHandle

	EXPORT	|?SetRSZHandle@OMAPSurface@@QAAXPAXH@Z|	; OMAPSurface::SetRSZHandle

  00000			 AREA	 |.pdata|, PDATA
|$T40924| DCD	|$LN6@SetRSZHand|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetRSZHandle@OMAPSurface@@QAAXPAXH@Z| PROC ; OMAPSurface::SetRSZHandle

; 4983 : {

  00000		 |$LN6@SetRSZHand|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M40921|
  00004	e1a05001	 mov         r5, r1
  00008	e1a04000	 mov         r4, r0

; 4984 :     if ((m_hRSZHandle != NULL) && freeHandle)

  0000c	e5943034	 ldr         r3, [r4, #0x34]
  00010	e3530000	 cmp         r3, #0
  00014	0a000005	 beq         |$LN1@SetRSZHand|
  00018	e3520000	 cmp         r2, #0
  0001c	0a000003	 beq         |$LN1@SetRSZHand|

; 4985 :     {        
; 4986 :         CloseHandle(m_hRSZHandle);

  00020	e1a00003	 mov         r0, r3
  00024	eb000000	 bl          CloseHandle

; 4987 :         
; 4988 :         m_hRSZHandle = NULL;

  00028	e3a03000	 mov         r3, #0
  0002c	e5843034	 str         r3, [r4, #0x34]
  00030		 |$LN1@SetRSZHand|

; 4989 :     }
; 4990 : 
; 4991 :     m_hRSZHandle = rszHandle;

  00030	e5845034	 str         r5, [r4, #0x34]

; 4992 : }

  00034	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M40922|

			 ENDP  ; |?SetRSZHandle@OMAPSurface@@QAAXPAXH@Z|, OMAPSurface::SetRSZHandle

	EXPORT	|?ConfigResizerParams@OMAPSurface@@QAAHPAUtagRECT@@0W4OMAP_DSS_ROTATION@@@Z| ; OMAPSurface::ConfigResizerParams
	IMPORT	|DeviceIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T40937| DCD	|$LN10@ConfigResi|
	DCD	0x40004e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ConfigResizerParams@OMAPSurface@@QAAHPAUtagRECT@@0W4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPSurface::ConfigResizerParams

; 4996 : {	

  00000		 |$LN10@ConfigResi|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M40934|
  00008	e1a06003	 mov         r6, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a07001	 mov         r7, r1
  00014	e1a09000	 mov         r9, r0

; 4997 :     BOOL retCode = FALSE;
; 4998 :      
; 4999 :     //m_sRSZParams.ulReadAddr;
; 5000 :     m_sRSZParams.ulReadOffset = Stride(eRotation); /* input width * 2 */

  00018	e599e000	 ldr         lr, [r9]
  0001c	e1a01006	 mov         r1, r6
  00020	e59e4010	 ldr         r4, [lr, #0x10]
  00024	e1a0e00f	 mov         lr, pc
  00028	e12fff14	 bx          r4

; 5001 :     m_sRSZParams.ulReadAddrOffset = 0;
; 5002 :     m_sRSZParams.ulOutOffset = Stride(eRotation);     

  0002c	e599e000	 ldr         lr, [r9]
  00030	e1a04000	 mov         r4, r0
  00034	e3a0a000	 mov         r10, #0
  00038	e59e5010	 ldr         r5, [lr, #0x10]
  0003c	e1a01006	 mov         r1, r6
  00040	e1a00009	 mov         r0, r9
  00044	e289c03c	 add         r12, r9, #0x3C
  00048	e88c0410	 stmia       r12, {r4, r10}
  0004c	e1a0e00f	 mov         lr, pc
  00050	e12fff15	 bx          r5

; 5003 :     //m_sRSZParams.ulWriteAddr;
; 5004 : 
; 5005 :     m_sRSZParams.ulInputImageWidth = pSrcRect->right - pSrcRect->left;
; 5006 :     m_sRSZParams.ulInputImageHeight = pSrcRect->bottom - pSrcRect->top;
; 5007 : 
; 5008 :     m_sRSZParams.ulOutputImageWidth = pDestRect->right - pDestRect->left;
; 5009 :     m_sRSZParams.ulOutputImageHeight = pDestRect->bottom - pDestRect->top;
; 5010 :     m_sRSZParams.h_startphase = RSZ_DEFAULTSTPHASE;
; 5011 :     m_sRSZParams.v_startphase = RSZ_DEFAULTSTPHASE;
; 5012 :     //m_sRSZParams.h_resz;
; 5013 :     //m_sRSZParams.v_resz;
; 5014 :     //m_sRSZParams.algo;
; 5015 :     m_sRSZParams.width = m_sRSZParams.ulInputImageWidth;
; 5016 :     m_sRSZParams.height = m_sRSZParams.ulInputImageHeight;
; 5017 :     m_sRSZParams.cropTop = 0;
; 5018 :     m_sRSZParams.cropLeft = 0;     
; 5019 :     m_sRSZParams.cropWidth = m_sRSZParams.ulOutputImageWidth;
; 5020 :     m_sRSZParams.cropHeight = m_sRSZParams.ulOutputImageHeight;
; 5021 :     m_sRSZParams.bReadFromMemory = TRUE;
; 5022 :     m_sRSZParams.enableZoom = FALSE;
; 5023 :     m_sRSZParams.ulZoomFactor = 0;
; 5024 :     if (m_ePixelFormat == OMAP_DSS_PIXELFORMAT_UYVY)

  00054	e3a05001	 mov         r5, #1
  00058	e5890090	 str         r0, [r9, #0x90]
  0005c	e597e008	 ldr         lr, [r7, #8]
  00060	e5973000	 ldr         r3, [r7]
  00064	e5994004	 ldr         r4, [r9, #4]
  00068	e04e3003	 sub         r3, lr, r3
  0006c	e5893048	 str         r3, [r9, #0x48]
  00070	e597200c	 ldr         r2, [r7, #0xC]
  00074	e5973004	 ldr         r3, [r7, #4]
  00078	e599e048	 ldr         lr, [r9, #0x48]
  0007c	e354000b	 cmp         r4, #0xB
  00080	e0423003	 sub         r3, r2, r3
  00084	e589304c	 str         r3, [r9, #0x4C]
  00088	e5982008	 ldr         r2, [r8, #8]
  0008c	e5983000	 ldr         r3, [r8]
  00090	e599004c	 ldr         r0, [r9, #0x4C]
  00094	e0423003	 sub         r3, r2, r3
  00098	e5893050	 str         r3, [r9, #0x50]
  0009c	e598200c	 ldr         r2, [r8, #0xC]
  000a0	e5983004	 ldr         r3, [r8, #4]
  000a4	e5991050	 ldr         r1, [r9, #0x50]
  000a8	e589505c	 str         r5, [r9, #0x5C]
  000ac	e0423003	 sub         r3, r2, r3
  000b0	e289c054	 add         r12, r9, #0x54
  000b4	e88c0028	 stmia       r12, {r3, r5}
  000b8	e5993054	 ldr         r3, [r9, #0x54]
  000bc	e589e06c	 str         lr, [r9, #0x6C]
  000c0	e289c070	 add         r12, r9, #0x70
  000c4	e88c0401	 stmia       r12, {r0, r10}
  000c8	e589307c	 str         r3, [r9, #0x7C]
  000cc	e589a078	 str         r10, [r9, #0x78]
  000d0	e289c080	 add         r12, r9, #0x80
  000d4	e88c0422	 stmia       r12, {r1, r5, r10}
  000d8	e589a08c	 str         r10, [r9, #0x8C]

; 5025 :     {
; 5026 :         m_sRSZParams.ulInpType = RSZ_INTYPE_YCBCR422_16BIT; 

  000dc	0589a098	 streq       r10, [r9, #0x98]

; 5027 :         m_sRSZParams.ulPixFmt = RSZ_PIX_FMT_UYVY; 

  000e0	0589a094	 streq       r10, [r9, #0x94]
  000e4	0a000003	 beq         |$LN2@ConfigResi|

; 5028 :     }
; 5029 :     else if (m_ePixelFormat == OMAP_DSS_PIXELFORMAT_YUV2)        

  000e8	e354000a	 cmp         r4, #0xA
  000ec	1a00000d	 bne         |$LN3@ConfigResi|

; 5030 :     {
; 5031 :         m_sRSZParams.ulInpType = RSZ_INTYPE_YCBCR422_16BIT; 
; 5032 :         m_sRSZParams.ulPixFmt = RSZ_PIX_FMT_YUYV; 

  000f0	e289c094	 add         r12, r9, #0x94
  000f4	e88c0420	 stmia       r12, {r5, r10}
  000f8		 |$LN2@ConfigResi|

; 5038 :     }
; 5039 :     
; 5040 :     retCode = DeviceIoControl (  m_hRSZHandle,
; 5041 :                                  RSZ_IOCTL_SET_PARAMS,
; 5042 :                                  (LPVOID)&m_sRSZParams, 
; 5043 :                                  sizeof (RSZParams_t), 
; 5044 :                                  (LPVOID)&m_sRSZParams, 
; 5045 :                                  sizeof (RSZParams_t), NULL, NULL);

  000f8	e5990034	 ldr         r0, [r9, #0x34]
  000fc	e289e038	 add         lr, r9, #0x38
  00100	e3a04064	 mov         r4, #0x64
  00104	e1a0200e	 mov         r2, lr
  00108	e3a03064	 mov         r3, #0x64
  0010c	e3a01002	 mov         r1, #2
  00110	e58da00c	 str         r10, [sp, #0xC]
  00114	e58da008	 str         r10, [sp, #8]
  00118	e58d4004	 str         r4, [sp, #4]
  0011c	e58de000	 str         lr, [sp]
  00120	eb000000	 bl          DeviceIoControl

; 5046 : 
; 5047 :     if (!retCode)     
; 5048 :         DEBUGMSG(ZONE_WARNING, (L"ConfigResizerParams: handle 0x%x returned retCode %d \r\n",m_hRSZHandle,retCode));
; 5049 : 
; 5050 : 
; 5051 :      return retCode;

  00124	ea000000	 b           |$LN6@ConfigResi|
  00128		 |$LN3@ConfigResi|

; 5033 :     }
; 5034 :     else
; 5035 :     {
; 5036 :         DEBUGMSG(ZONE_WARNING, (L"ConfigResizerParams: Unsupported pixel type %d \r\n",m_ePixelFormat));
; 5037 :         return FALSE;

  00128	e3a00000	 mov         r0, #0
  0012c		 |$LN6@ConfigResi|

; 5052 :      
; 5053 : }

  0012c	e28dd010	 add         sp, sp, #0x10
  00130	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$M40935|

			 ENDP  ; |?ConfigResizerParams@OMAPSurface@@QAAHPAUtagRECT@@0W4OMAP_DSS_ROTATION@@@Z|, OMAPSurface::ConfigResizerParams

	EXPORT	|?StartResizer@OMAPSurface@@QAAHKK@Z|	; OMAPSurface::StartResizer

  00000			 AREA	 |.pdata|, PDATA
|$T40950| DCD	|$LN8@StartResiz|
	DCD	0x40001d02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StartResizer@OMAPSurface@@QAAHKK@Z| PROC ; OMAPSurface::StartResizer

; 5056 : {

  00000		 |$LN8@StartResiz|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M40947|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a05000	 mov         r5, r0

; 5057 :     BOOL retCode = FALSE;   
; 5058 :     DWORD dwInAddrOffset = 0;

  00014	e3a0e000	 mov         lr, #0

; 5059 :     if (dwInAddr%32!=0)

  00018	e214101f	 ands        r1, r4, #0x1F
  0001c	0a000004	 beq         |$LN2@StartResiz|

; 5060 :     {
; 5061 :         dwInAddrOffset=dwInAddr&0x1F;
; 5062 :         dwInAddr=(dwInAddr>>5)<<5;
; 5063 :         if (m_sRSZParams.ulInpType == RSZ_INTYPE_YCBCR422_16BIT)

  00020	e5953098	 ldr         r3, [r5, #0x98]
  00024	e1a0e001	 mov         lr, r1
  00028	e3c4401f	 bic         r4, r4, #0x1F
  0002c	e3530000	 cmp         r3, #0

; 5064 :             dwInAddrOffset/=2;

  00030	01a0e0a1	 moveq       lr, r1, lsr #1
  00034		 |$LN2@StartResiz|

; 5065 :     }
; 5066 :     m_sRSZParams.ulReadAddr = dwInAddr;
; 5067 :     m_sRSZParams.ulWriteAddr = dwOutAddr;
; 5068 :     m_sRSZParams.cropLeft = dwInAddrOffset;
; 5069 :     retCode = DeviceIoControl ( m_hRSZHandle,
; 5070 :                                  RSZ_IOCTL_START_RESIZER,
; 5071 :                                  (LPVOID)&m_sRSZParams, 
; 5072 :                                  sizeof (RSZParams_t), 
; 5073 :                                  NULL, 0, NULL, NULL);

  00034	e5950034	 ldr         r0, [r5, #0x34]
  00038	e3a07000	 mov         r7, #0
  0003c	e3a03064	 mov         r3, #0x64
  00040	e2852038	 add         r2, r5, #0x38
  00044	e3a01004	 mov         r1, #4
  00048	e5854038	 str         r4, [r5, #0x38]
  0004c	e5856044	 str         r6, [r5, #0x44]
  00050	e585e078	 str         lr, [r5, #0x78]
  00054	e58d700c	 str         r7, [sp, #0xC]
  00058	e58d7008	 str         r7, [sp, #8]
  0005c	e58d7004	 str         r7, [sp, #4]
  00060	e58d7000	 str         r7, [sp]
  00064	eb000000	 bl          DeviceIoControl

; 5074 :     if (!retCode)     
; 5075 :         DEBUGMSG(ZONE_WARNING, (L"StartResizer: handle 0x%x inAddr 0x%x outAddr 0x%x cropLeft %d returned retCode %d",
; 5076 :                         m_hRSZHandle,dwInAddr,dwOutAddr,dwInAddrOffset,retCode));
; 5077 : 
; 5078 :     return retCode;
; 5079 : }

  00068	e28dd010	 add         sp, sp, #0x10
  0006c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00070	e12fff1e	 bx          lr
  00074		 |$M40948|

			 ENDP  ; |?StartResizer@OMAPSurface@@QAAHKK@Z|, OMAPSurface::StartResizer

	EXPORT	|?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z| ; OMAPDisplayController::EnableOverlayOptimization
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\inc\dssai.h

  00000			 AREA	 |.pdata|, PDATA
|$T40976| DCD	|$LN18@EnableOver|
	DCD	0x40004501
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\dss\dssai\dssai.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z| PROC ; OMAPDisplayController::EnableOverlayOptimization

; 5144 : {

  00000		 |$LN18@EnableOver|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M40973|
  00004	e3510000	 cmp         r1, #0

; 5145 :     DWORD dwWindowSkip = 0;  

  00008	e3a02000	 mov         r2, #0

; 5146 : 
; 5147 :     //Enable Overlay optimization if no colorkeying, no alpha blending and only VID1 layer is visible
; 5148 :     //going to LCD destination
; 5149 :     if( bEnable &&
; 5150 :         g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].pSurface != NULL &&           
; 5151 :         g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled == TRUE &&
; 5152 :         g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].eDestination == OMAP_DSS_DESTINATION_LCD &&
; 5153 :         g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled == TRUE &&
; 5154 :         g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled == FALSE && 
; 5155 :         (INREG32(&m_pDispRegs->DISPC_CONFIG) & DISPC_CONFIG_TCKLCDENABLE) == 0 &&
; 5156 :         (INREG32( &m_pDispRegs->DISPC_CONFIG) & DISPC_CONFIG_LCDALPHABLENDERENABLE) == 0)

  0000c	0a000035	 beq         |$LN3@EnableOver|
  00010	e59f10f8	 ldr         r1, [pc, #0xF8]
  00014	e5915008	 ldr         r5, [r1, #8]
  00018	e3550000	 cmp         r5, #0
  0001c	0a000031	 beq         |$LN3@EnableOver|
  00020	e5913000	 ldr         r3, [r1]
  00024	e3530001	 cmp         r3, #1
  00028	1a00002e	 bne         |$LN3@EnableOver|
  0002c	e5913024	 ldr         r3, [r1, #0x24]
  00030	e3530000	 cmp         r3, #0
  00034	1a00002b	 bne         |$LN3@EnableOver|
  00038	e5913020	 ldr         r3, [r1, #0x20]
  0003c	e3530001	 cmp         r3, #1
  00040	1a000028	 bne         |$LN3@EnableOver|
  00044	e5913040	 ldr         r3, [r1, #0x40]
  00048	e3530000	 cmp         r3, #0
  0004c	1a000025	 bne         |$LN3@EnableOver|
  00050	e590e008	 ldr         lr, [r0, #8]
  00054	e59e3044	 ldr         r3, [lr, #0x44]
  00058	e3130b01	 tst         r3, #1, 22
  0005c	1a000021	 bne         |$LN3@EnableOver|
  00060	e59e3044	 ldr         r3, [lr, #0x44]
  00064	e3130701	 tst         r3, #1, 14
  00068	1a00001e	 bne         |$LN3@EnableOver|

; 5157 :     {
; 5158 :          //Assume overlay destination is always contained within the GFX window inclusive  
; 5159 :         OMAPSurface *pGFXSurface = g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].pSurface;             
; 5160 :         DWORD dwGFXWidth = g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].dwDestWidth;
; 5161 :         DWORD dwGFXHeight = g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].dwDestHeight;
; 5162 :         DWORD dwDestWidth = g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].dwDestWidth;
; 5163 :         DWORD dwDestHeight = g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].dwDestHeight;
; 5164 :         DWORD dwPosX =  INREG32(&m_pDispRegs->tDISPC_VID1.POSITION) & 0xFFFF;

  0006c	e59e20c4	 ldr         r2, [lr, #0xC4]
  00070	e5919014	 ldr         r9, [r1, #0x14]
  00074	e5914034	 ldr         r4, [r1, #0x34]
  00078	e3a03cff	 mov         r3, #0xFF, 24

; 5165 :         DWORD dwGFXPixInc = INREG32(&m_pDispRegs->DISPC_GFX_PIXEL_INC);
; 5166 :         DWORD dwGFXRowInc = INREG32(&m_pDispRegs->DISPC_GFX_ROW_INC);

  0007c	e59e60b0	 ldr         r6, [lr, #0xB0]
  00080	e38330ff	 orr         r3, r3, #0xFF
  00084	e5918038	 ldr         r8, [r1, #0x38]
  00088	e59ee0ac	 ldr         lr, [lr, #0xAC]
  0008c	e0027003	 and         r7, r2, r3

; 5167 :                
; 5168 :         //Simulate how the DMA controller would skip bytes
; 5169 :         //1.after every pixel read DMA controller index = index + BPP-1
; 5170 :         //2.After every pixel read, index = index+PIXEL_INC, unless it's the last pixel in the row
; 5171 :         //3.At the end of each row, index = index+ROW_INC       
; 5172 :         if( (dwDestWidth == dwGFXWidth) && (dwDestHeight == dwGFXHeight) )

  00090	e1540009	 cmp         r4, r9
  00094	1a00000b	 bne         |$LN5@EnableOver|
  00098	e5913018	 ldr         r3, [r1, #0x18]
  0009c	e1580003	 cmp         r8, r3

; 5173 :         {
; 5174 :             //  Whole video layer covers GFX
; 5175 :             dwWindowSkip = 0;

  000a0	03a02000	 moveq       r2, #0
  000a4	0a00000f	 beq         |$LN3@EnableOver|

; 5176 :         }
; 5177 :         else if(dwDestWidth == dwGFXWidth)
; 5178 :         {               
; 5179 :             DWORD dwPixIncPerRow = dwGFXPixInc*(dwDestWidth-1);
; 5180 :             DWORD dwByteReadsPerRow = dwDestWidth*(pGFXSurface->PixelSize()-1);

  000a8	e5953008	 ldr         r3, [r5, #8]
  000ac	e2441001	 sub         r1, r4, #1
  000b0	e2433001	 sub         r3, r3, #1
  000b4	e0020493	 mul         r2, r3, r4
  000b8	e0232691	 mla         r3, r1, r6, r2

; 5181 :             dwWindowSkip = dwDestHeight*(dwPixIncPerRow+dwByteReadsPerRow+dwGFXRowInc);         

  000bc	e083300e	 add         r3, r3, lr
  000c0	e0020893	 mul         r2, r3, r8

; 5182 :         }        
; 5183 :         else  

  000c4	ea000007	 b           |$LN3@EnableOver|
  000c8		 |$LN5@EnableOver|

; 5184 :         {              
; 5185 :             dwWindowSkip = dwDestWidth*(dwGFXPixInc+(pGFXSurface->PixelSize()-1));  

  000c8	e5953008	 ldr         r3, [r5, #8]

; 5186 :             if(dwPosX != 0 && (dwPosX+dwDestWidth) != dwGFXWidth)

  000cc	e3570000	 cmp         r7, #0
  000d0	e0833006	 add         r3, r3, r6
  000d4	e2433001	 sub         r3, r3, #1
  000d8	e0020493	 mul         r2, r3, r4
  000dc	10873004	 addne       r3, r7, r4
  000e0	11530009	 cmpne       r3, r9

; 5187 :             {
; 5188 :                 //additional pixel increment needed
; 5189 :                 dwWindowSkip +=dwGFXPixInc;  

  000e4	10822006	 addne       r2, r2, r6
  000e8		 |$LN3@EnableOver|

; 5190 :             }
; 5191 :         }                        
; 5192 :     }
; 5193 : 
; 5194 : 
; 5195 :     //  Set window skip value
; 5196 :     OUTREG32(&m_pDispRegs->DISPC_GFX_WINDOW_SKIP, dwWindowSkip);

  000e8	e5903008	 ldr         r3, [r0, #8]

; 5197 : 
; 5198 :     //  Enable/disable window skip
; 5199 :     if( dwWindowSkip != 0 )

  000ec	e3520000	 cmp         r2, #0
  000f0	e58320b4	 str         r2, [r3, #0xB4]

; 5200 :         SETREG32(&m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_OVERLAY_OPTIMIZATION);        

  000f4	e5902008	 ldr         r2, [r0, #8]
  000f8	e5923040	 ldr         r3, [r2, #0x40]
  000fc	13833a01	 orrne       r3, r3, #1, 20

; 5201 :     else
; 5202 :         CLRREG32(&m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_OVERLAY_OPTIMIZATION);        

  00100	03c33a01	 biceq       r3, r3, #1, 20
  00104	e5823040	 str         r3, [r2, #0x40]

; 5203 : }

  00108	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  0010c	e12fff1e	 bx          lr
  00110		 |$LN19@EnableOver|
  00110		 |$LN20@EnableOver|
  00110	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00114		 |$M40974|

			 ENDP  ; |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z|, OMAPDisplayController::EnableOverlayOptimization

	EXPORT	|?SetDssFclk@OMAPDisplayController@@IAAHW4OMAP_DSS_FCLK@@W4OMAP_DSS_FCLKVALUE@@@Z| ; OMAPDisplayController::SetDssFclk

  00000			 AREA	 |.pdata|, PDATA
|$T40987| DCD	|$LN5@SetDssFclk|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetDssFclk@OMAPDisplayController@@IAAHW4OMAP_DSS_FCLK@@W4OMAP_DSS_FCLKVALUE@@@Z| PROC ; OMAPDisplayController::SetDssFclk

; 5211 : {

  00000		 |$LN5@SetDssFclk|
  00000		 |$M40984|

; 5212 :     BOOL bRet = TRUE;
; 5213 :     
; 5214 :     UNREFERENCED_PARAMETER(eDssFclkValue);
; 5215 :     UNREFERENCED_PARAMETER(eDssFclkSource);
; 5216 : 
; 5217 :     return bRet;

  00000	e3a00001	 mov         r0, #1

; 5218 : }

  00004	e12fff1e	 bx          lr
  00008		 |$M40985|

			 ENDP  ; |?SetDssFclk@OMAPDisplayController@@IAAHW4OMAP_DSS_FCLK@@W4OMAP_DSS_FCLKVALUE@@@Z|, OMAPDisplayController::SetDssFclk

	EXPORT	|?InitDsiPll@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::InitDsiPll
	EXPORT	|??_C@_1CI@BKOMHDDL@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DO@OPIOMKJF@?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAt?$AAu?$AAr?$AAn?$AA?5?$AAo?$AAn?$AA?5?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GA@HEOPJPGD@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAi?$AAt?$AAD?$AAS?$AAI?$AAP?$AAL?$AAL?$AA?3?$AA?3?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAs@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T41019| DCD	|$LN33@InitDsiPll|
	DCD	0x40004c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@BKOMHDDL@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "D"
	DCB	0x0, "S", 0x0, "I", 0x0, " ", 0x0, "P", 0x0, "L", 0x0, "L"
	DCB	0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "r"
	DCB	0x0, "e", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@OPIOMKJF@?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAt?$AAu?$AAr?$AAn?$AA?5?$AAo?$AAn?$AA?5?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "U"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "t", 0x0, "u", 0x0, "r"
	DCB	0x0, "n", 0x0, " ", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "D"
	DCB	0x0, "S", 0x0, "I", 0x0, " ", 0x0, "P", 0x0, "L", 0x0, "L"
	DCB	0x0, " ", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GA@HEOPJPGD@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAi?$AAt?$AAD?$AAS?$AAI?$AAP?$AAL?$AAL?$AA?3?$AA?3?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAs@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "D", 0x0, "S"
	DCB	0x0, "I", 0x0, "P", 0x0, "L", 0x0, "L", 0x0, ":", 0x0, ":"
	DCB	0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e"
	DCB	0x0, "s", 0x0, "e", 0x0, "t", 0x0, " ", 0x0, "D", 0x0, "S"
	DCB	0x0, "I", 0x0, " ", 0x0, "M", 0x0, "o", 0x0, "d", 0x0, "u"
	DCB	0x0, "l", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitDsiPll@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::InitDsiPll

; 5223 : {

  00000		 |$LN33@InitDsiPll|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M41016|
  00004	e1a07000	 mov         r7, r0

; 5224 :     BOOL  bRet = TRUE;
; 5225 :     ULONG count = 100;                  //count for timed status check
; 5226 :     ULONG value;
; 5227 :     
; 5228 :     // PCLKFREE should be set for DSI
; 5229 :     value  = INREG32( &m_pDispRegs->DISPC_CONTROL);

  00008	e5972008	 ldr         r2, [r7, #8]
  0000c	e3a06001	 mov         r6, #1
  00010	e3a04064	 mov         r4, #0x64
  00014	e5923040	 ldr         r3, [r2, #0x40]

; 5230 :     value |= DISPC_CONTROL_PCKFREEENABLE_ENABLED;

  00018	e3833302	 orr         r3, r3, #2, 6

; 5231 :     OUTREG32( &m_pDispRegs->DISPC_CONTROL, value);

  0001c	e5823040	 str         r3, [r2, #0x40]

; 5232 : 
; 5233 :     // Reset the DSI protocol engine
; 5234 :     SETREG32( &m_pDSIRegs->DSI_SYSCONFIG, SYSCONFIG_SOFTRESET);

  00020	e5972010	 ldr         r2, [r7, #0x10]
  00024	e5923010	 ldr         r3, [r2, #0x10]
  00028	e3833002	 orr         r3, r3, #2
  0002c	e5823010	 str         r3, [r2, #0x10]

; 5235 : 
; 5236 :     // Wait for reset to complete
; 5237 :     while (((INREG32(&m_pDSIRegs->DSI_SYSSTATUS)) != SYSSTATUS_RESETDONE) && (--count))

  00030	ea000003	 b           |$LN30@InitDsiPll|
  00034		 |$LL15@InitDsiPll|
  00034	e2544001	 subs        r4, r4, #1
  00038	0a000025	 beq         |$LN28@InitDsiPll|

; 5238 :     {
; 5239 :         StallExecution(1000);

  0003c	e3a00ffa	 mov         r0, #0xFA, 30
  00040	eb000000	 bl          StallExecution
  00044		 |$LN30@InitDsiPll|
  00044	e5973010	 ldr         r3, [r7, #0x10]
  00048	e5933014	 ldr         r3, [r3, #0x14]
  0004c	e3530001	 cmp         r3, #1
  00050	1afffff7	 bne         |$LL15@InitDsiPll|

; 5247 :         goto Clean;
; 5248 :     }
; 5249 : 
; 5250 :     //  Configure for idle during inactivity
; 5251 :     OUTREG32( &m_pDSIRegs->DSI_SYSCONFIG,  
; 5252 :                 SYSCONFIG_AUTOIDLE  |
; 5253 :                 SYSCONFIG_ENAWAKEUP |
; 5254 :                 SYSCONFIG_SMARTIDLE
; 5255 :                 );

  00054	e5973010	 ldr         r3, [r7, #0x10]
  00058	e3a02015	 mov         r2, #0x15
  0005c	e3e01103	 mvn         r1, #3, 2
  00060	e5832010	 str         r2, [r3, #0x10]

; 5256 : 
; 5257 :     // Clear the DSI IRQ status
; 5258 :     value = INREG32( &m_pDSIRegs->DSI_IRQSTATUS);

  00064	e5972010	 ldr         r2, [r7, #0x10]

; 5259 :     OUTREG32( &m_pDSIRegs->DSI_IRQSTATUS, value);
; 5260 : 
; 5261 :     // Enable the Pwr to the DSI sub modules
; 5262 :     value  = INREG32( &m_pDSIRegs->DSI_CLK_CTRL);
; 5263 :     // clear the current pwr cmd value
; 5264 :     value  = (value & ~(DSI_CLK_CTRL_PLL_PWR_CMD_MASK));

  00068	e2210a02	 eor         r0, r1, #2, 20
  0006c	e3a01102	 mov         r1, #2, 2
  00070	e5923018	 ldr         r3, [r2, #0x18]

; 5265 :     // set the pwr cmd for enabling pwr to PLL and HS DIVIDER
; 5266 :     value |= (DSI_CLK_CTRL_PLL_PWR_CMD_ON_PLLANDHS)|(1 << 13);

  00074	e3811a02	 orr         r1, r1, #2, 20

; 5267 :     OUTREG32( &m_pDSIRegs->DSI_CLK_CTRL, value);
; 5268 : 
; 5269 :     // Check whether the power status is changed
; 5270 :     count = 1000;

  00078	e3a05ffa	 mov         r5, #0xFA, 30
  0007c	e5823018	 str         r3, [r2, #0x18]
  00080	e5972010	 ldr         r2, [r7, #0x10]
  00084	e5923054	 ldr         r3, [r2, #0x54]
  00088	e0033000	 and         r3, r3, r0
  0008c	e1833001	 orr         r3, r3, r1
  00090	e5823054	 str         r3, [r2, #0x54]
  00094		 |$LL11@InitDsiPll|

; 5271 :     do
; 5272 :     {
; 5273 :         value = INREG32( &m_pDSIRegs->DSI_CLK_CTRL);

  00094	e5973010	 ldr         r3, [r7, #0x10]

; 5274 :         value = (value & DSI_CLK_CTRL_PLL_PWR_STATUS_ON_PLLANDHS);
; 5275 :         StallExecution(1000);

  00098	e3a00ffa	 mov         r0, #0xFA, 30
  0009c	e5934054	 ldr         r4, [r3, #0x54]
  000a0	eb000000	 bl          StallExecution

; 5276 :     }
; 5277 :     while ((value == 0) && (--count));

  000a4	e3140202	 tst         r4, #2, 4
  000a8	1a000001	 bne         |$LN8@InitDsiPll|
  000ac	e2555001	 subs        r5, r5, #1
  000b0	1afffff7	 bne         |$LL11@InitDsiPll|
  000b4		 |$LN8@InitDsiPll|

; 5278 : 
; 5279 :     if (count == 0)

  000b4	e3550000	 cmp         r5, #0
  000b8	1a000009	 bne         |$LN7@InitDsiPll|

; 5280 :     {
; 5281 :         bRet = FALSE;
; 5282 :         RETAILMSG(1,(L"Unable to turn on DSI PLL %x\r\n",
; 5283 :             INREG32(&m_pDSIRegs->DSI_CLK_CTRL)\
; 5284 :             ));

  000bc	e5973010	 ldr         r3, [r7, #0x10]
  000c0	e59f0064	 ldr         r0, [pc, #0x64]
  000c4	e3a06000	 mov         r6, #0
  000c8	e5931054	 ldr         r1, [r3, #0x54]
  000cc	eb000000	 bl          NKDbgPrintfW

; 5302 :     }
; 5303 : 
; 5304 : Clean:

  000d0	ea000010	 b           |$Clean$39896|
  000d4		 |$LN28@InitDsiPll|

; 5240 :     }
; 5241 : 
; 5242 :     if (count == 0)
; 5243 :     {
; 5244 :         RETAILMSG(1,(L"ERROR: InitDSIPLL::"
; 5245 :                      L"Failed to reset DSI Module\r\n"));

  000d4	e59f004c	 ldr         r0, [pc, #0x4C]
  000d8	eb000000	 bl          NKDbgPrintfW

; 5246 :         bRet = FALSE;

  000dc	e3a06000	 mov         r6, #0
  000e0	ea00000c	 b           |$Clean$39896|
  000e4		 |$LN7@InitDsiPll|

; 5285 :         goto Clean;
; 5286 :     }
; 5287 : 
; 5288 :     // Check for the PLL reset complete status
; 5289 :     count = 100;

  000e4	e3a05064	 mov         r5, #0x64
  000e8		 |$LL5@InitDsiPll|

; 5290 :     do
; 5291 :     {
; 5292 :         value = INREG32( &m_pDSIPLLRegs->DSI_PLL_STATUS);

  000e8	e5973014	 ldr         r3, [r7, #0x14]

; 5293 :         value = (value & DSI_PLLCTRL_RESET_DONE_STATUS);
; 5294 :         StallExecution(1000);

  000ec	e3a00ffa	 mov         r0, #0xFA, 30
  000f0	e5934004	 ldr         r4, [r3, #4]
  000f4	eb000000	 bl          StallExecution

; 5295 :     }
; 5296 :     while ((value == 0) && (--count));

  000f8	e3140001	 tst         r4, #1
  000fc	1a000001	 bne         |$LN2@InitDsiPll|
  00100	e2555001	 subs        r5, r5, #1
  00104	1afffff7	 bne         |$LL5@InitDsiPll|
  00108		 |$LN2@InitDsiPll|

; 5297 : 
; 5298 :     if (count == 0)

  00108	e3550000	 cmp         r5, #0

; 5299 :     {
; 5300 :         bRet = FALSE;
; 5301 :         RETAILMSG(1,(L"DSI PLL not reset\r\n"));

  0010c	059f0010	 ldreq       r0, [pc, #0x10]
  00110	03a06000	 moveq       r6, #0
  00114	0b000000	 bleq        NKDbgPrintfW
  00118		 |$Clean$39896|

; 5305 :     return bRet;
; 5306 : }

  00118	e1a00006	 mov         r0, r6
  0011c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN34@InitDsiPll|
  00124		 |$LN35@InitDsiPll|
  00124	00000000	 DCD         |??_C@_1CI@BKOMHDDL@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAr?$AAe?$AAs?$AAe?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  00128		 |$LN36@InitDsiPll|
  00128	00000000	 DCD         |??_C@_1GA@HEOPJPGD@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAI?$AAn?$AAi?$AAt?$AAD?$AAS?$AAI?$AAP?$AAL?$AAL?$AA?3?$AA?3?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAs@|
  0012c		 |$LN37@InitDsiPll|
  0012c	00000000	 DCD         |??_C@_1DO@OPIOMKJF@?$AAU?$AAn?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAt?$AAo?$AA?5?$AAt?$AAu?$AAr?$AAn?$AA?5?$AAo?$AAn?$AA?5?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  00130		 |$M41017|

			 ENDP  ; |?InitDsiPll@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::InitDsiPll

	EXPORT	|?DeInitDsiPll@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::DeInitDsiPll

  00000			 AREA	 |.pdata|, PDATA
|$T41038| DCD	|$LN5@DeInitDsiP|
	DCD	0x40001b00
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DeInitDsiPll@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::DeInitDsiPll

; 5311 : {

  00000		 |$LN5@DeInitDsiP|
  00000		 |$M41035|
  00000	e1a01000	 mov         r1, r0

; 5312 :     BOOL bRet = TRUE;
; 5313 :     DWORD dwRegValue = 0;
; 5314 :     
; 5315 :     // clear the DSI IRQ status
; 5316 :     dwRegValue = INREG32( &m_pDSIRegs->DSI_IRQSTATUS);

  00004	e5912010	 ldr         r2, [r1, #0x10]

; 5317 :     OUTREG32( &m_pDSIRegs->DSI_IRQSTATUS, dwRegValue);
; 5318 :     
; 5319 :     // configure the DSI PLL for bypass mode before updating PLL
; 5320 :     SETREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, DSI_PLL_IDLE);
; 5321 : 
; 5322 :     // select the manual mode of PLL update
; 5323 :     dwRegValue = INREG32( &m_pDSIPLLRegs->DSI_PLL_CONTROL);
; 5324 :     dwRegValue = dwRegValue & ~(DSI_PLL_AUTOMODE);
; 5325 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONTROL, dwRegValue);
; 5326 : 
; 5327 :     // disable DSIPHY clock and set HSDIV in bypass mode
; 5328 :     dwRegValue = INREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2);
; 5329 :     dwRegValue = dwRegValue & ~(DSIPHY_CLKINEN);
; 5330 :     dwRegValue = dwRegValue | DSI_HSDIVBYPASS;
; 5331 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, dwRegValue);
; 5332 :     
; 5333 :     // PCLKFREE should be set for DSI
; 5334 :     dwRegValue = INREG32( &m_pDispRegs->DISPC_CONTROL);
; 5335 :     dwRegValue = dwRegValue | DISPC_CONTROL_PCKFREEENABLE_ENABLED;
; 5336 :     OUTREG32( &m_pDispRegs->DISPC_CONTROL, dwRegValue);
; 5337 :     
; 5338 :     // issue Power off cmd to DSI
; 5339 :     dwRegValue = INREG32( &m_pDSIRegs->DSI_CLK_CTRL);
; 5340 :     dwRegValue = (dwRegValue & ~(DSI_CLK_CTRL_PLL_PWR_CMD_MASK));
; 5341 :     dwRegValue = dwRegValue | DSI_CLK_CTRL_PLL_PWR_CMD_OFF;
; 5342 :     OUTREG32( &m_pDSIRegs->DSI_CLK_CTRL, dwRegValue);
; 5343 : 
; 5344 :     return bRet;

  00008	e3a00001	 mov         r0, #1
  0000c	e5923018	 ldr         r3, [r2, #0x18]
  00010	e5823018	 str         r3, [r2, #0x18]
  00014	e5912014	 ldr         r2, [r1, #0x14]
  00018	e5923010	 ldr         r3, [r2, #0x10]
  0001c	e3833001	 orr         r3, r3, #1
  00020	e5823010	 str         r3, [r2, #0x10]
  00024	e5912014	 ldr         r2, [r1, #0x14]
  00028	e5923000	 ldr         r3, [r2]
  0002c	e3c33001	 bic         r3, r3, #1
  00030	e5823000	 str         r3, [r2]
  00034	e5912014	 ldr         r2, [r1, #0x14]
  00038	e5923010	 ldr         r3, [r2, #0x10]
  0003c	e3c33901	 bic         r3, r3, #1, 18
  00040	e3833601	 orr         r3, r3, #1, 12
  00044	e5823010	 str         r3, [r2, #0x10]
  00048	e5912008	 ldr         r2, [r1, #8]
  0004c	e5923040	 ldr         r3, [r2, #0x40]
  00050	e3833302	 orr         r3, r3, #2, 6
  00054	e5823040	 str         r3, [r2, #0x40]
  00058	e5912010	 ldr         r2, [r1, #0x10]
  0005c	e5923054	 ldr         r3, [r2, #0x54]
  00060	e3c33103	 bic         r3, r3, #3, 2
  00064	e5823054	 str         r3, [r2, #0x54]

; 5345 : }

  00068	e12fff1e	 bx          lr
  0006c		 |$M41036|

			 ENDP  ; |?DeInitDsiPll@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::DeInitDsiPll

	EXPORT	|?ConfigureDsiPll@OMAPDisplayController@@QAAHK@Z| ; OMAPDisplayController::ConfigureDsiPll
	EXPORT	|??_C@_1DC@EGPANNCF@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAL?$AAo?$AAc?$AAk?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAd?$AA?5?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CK@PPIENFCI@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAG?$AAo?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HE@BACIAFEL@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAD?$AAs?$AAi?$AAP?$AAl?$AAl?$AA?3?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe@| [ DATA ] ; `string'
	IMPORT	|GetSystemClockFrequency|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T41083| DCD	|$LN36@ConfigureD|
	DCD	0x40007401

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@EGPANNCF@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAL?$AAo?$AAc?$AAk?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAd?$AA?5?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "D"
	DCB	0x0, "S", 0x0, "I", 0x0, " ", 0x0, "P", 0x0, "L", 0x0, "L"
	DCB	0x0, " ", 0x0, "L", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, " "
	DCB	0x0, "t", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@PPIENFCI@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAG?$AAo?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "D"
	DCB	0x0, "S", 0x0, "I", 0x0, " ", 0x0, "P", 0x0, "L", 0x0, "L"
	DCB	0x0, " ", 0x0, "G", 0x0, "o", 0x0, " ", 0x0, "n", 0x0, "o"
	DCB	0x0, "t", 0x0, " ", 0x0, "s", 0x0, "e", 0x0, "t", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HE@BACIAFEL@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAD?$AAs?$AAi?$AAP?$AAl?$AAl?$AA?3?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe@| DCB "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "f", 0x0, "i", 0x0, "g", 0x0, "u"
	DCB	0x0, "r", 0x0, "e", 0x0, "D", 0x0, "s", 0x0, "i", 0x0, "P"
	DCB	0x0, "l", 0x0, "l", 0x0, ":", 0x0, "C", 0x0, "a", 0x0, "n"
	DCB	0x0, "n", 0x0, "o", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o"
	DCB	0x0, "n", 0x0, "f", 0x0, "i", 0x0, "g", 0x0, "u", 0x0, "r"
	DCB	0x0, "e", 0x0, " ", 0x0, "D", 0x0, "S", 0x0, "I", 0x0, " "
	DCB	0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "g", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "n", 0x0, " ", 0x0, "f", 0x0, "r"
	DCB	0x0, "e", 0x0, "q", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "d"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ConfigureDsiPll@OMAPDisplayController@@QAAHK@Z| PROC ; OMAPDisplayController::ConfigureDsiPll

; 5350 : {

  00000		 |$LN36@ConfigureD|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M41080|
  00004	e1a08001	 mov         r8, r1
  00008	e1a06000	 mov         r6, r0

; 5351 : 
; 5352 :     BOOL  bRet = TRUE;

  0000c	e3a07001	 mov         r7, #1

; 5353 :     ULONG count = 100;                  //count for timed status check
; 5354 :     ULONG m,n,m3,m4;                    //variables for PLL freq configuration
; 5355 :     ULONG fint    = DSI_PLL_FREQINT;    //internal ref frequency for PLL
; 5356 :     ULONG sysClk  = GetSystemClockFrequency();

  00010	eb000000	 bl          GetSystemClockFrequency
  00014	e3a0397a	 mov         r3, #0x7A, 18

; 5357 :     ULONG value;
; 5358 :     ULONG dsiPhyClock;
; 5359 :     ULONG highFreqDiv = 0;
; 5360 :     ULONG pllConfig1,pllConfig2; // variables for PLLConfig1 & 2
; 5361 : 
; 5362 : 
; 5363 :     //  Check clock bounds
; 5364 :     if (clockFreq < fint ) // || clockFreq > DSS_FCLK_MAX)

  00018	e3833d12	 orr         r3, r3, #0x12, 26
  0001c	e1580003	 cmp         r8, r3
  00020	e1a0e000	 mov         lr, r0
  00024	e3a09000	 mov         r9, #0
  00028	2a000004	 bcs         |$LN14@ConfigureD|

; 5365 :     {
; 5366 :         bRet = FALSE;
; 5367 :         RETAILMSG(1,(L"ConfigureDsiPll:"
; 5368 :                      L"Cannot configure DSI for given freq: %d\r\n",
; 5369 :                      clockFreq));

  0002c	e59f0198	 ldr         r0, [pc, #0x198]
  00030	e1a01008	 mov         r1, r8
  00034	e3a07000	 mov         r7, #0
  00038	eb000000	 bl          NKDbgPrintfW

; 5370 :         goto Clean;

  0003c	ea00005c	 b           |$Clean$39964|
  00040		 |$LN14@ConfigureD|

; 5371 :     }
; 5372 : 
; 5373 :     // Calculate the dsiPhyClock
; 5374 :     // Number of Lanes for DSI = 2
; 5375 :     // DSI PHY clock = 2 * data rate * NumberOfLanes
; 5376 :     dsiPhyClock = clockFreq * 2 * 2;
; 5377 : 
; 5378 :     // The steps for m and n calculation are to ensure the DSI PLL generates
; 5379 :     // DSI1_PLL_FCLK.
; 5380 : 
; 5381 :     // Use the formula for deriving m, m3 and m4 values
; 5382 :     //                             2xRegM       SYSCLK
; 5383 :     //             dsiPhyClock =  -------- x -------------
; 5384 :     //                            REGN + 1   HIGHFREQDIV+1
; 5385 : 
; 5386 :     // Set the highfreq divider if the input clock is > 32Mhz
; 5387 :     if (sysClk > DSI_HIGHFREQ_MAX)
; 5388 :         highFreqDiv = 1;
; 5389 : 
; 5390 :     n  = (sysClk/fint/(highFreqDiv+1)) - 1;

  00040	e59f5180	 ldr         r5, [pc, #0x180]
  00044	e3a0377a	 mov         r3, #0x7A, 14
  00048	e3833b12	 orr         r3, r3, #0x12, 22
  0004c	e15e0003	 cmp         lr, r3
  00050	e083259e	 umull       r2, r3, lr, r5
  00054	83a09001	 movhi       r9, #1
  00058	e2894001	 add         r4, r9, #1
  0005c	e1a019a3	 mov         r1, r3, lsr #19
  00060	e1a00004	 mov         r0, r4
  00064	e1a0a108	 mov         r10, r8, lsl #2
  00068	eb000000	 bl          __rt_udiv

; 5391 : 
; 5392 :     m = (dsiPhyClock*(highFreqDiv+1))/(2*fint);

  0006c	e00e0a94	 mul         lr, r4, r10
  00070	e1a04000	 mov         r4, r0
  00074	e082359e	 umull       r3, r2, lr, r5

; 5393 : 
; 5394 :     // calculate m3 value DSI1_PLL_FCLK (m3)
; 5395 :     m3 = (dsiPhyClock/clockFreq) - 1;

  00078	e1a00008	 mov         r0, r8
  0007c	e1a0100a	 mov         r1, r10
  00080	e1a05a22	 mov         r5, r2, lsr #20
  00084	e2448001	 sub         r8, r4, #1
  00088	eb000000	 bl          __rt_udiv
  0008c	e2404001	 sub         r4, r0, #1

; 5396 : 
; 5397 :     // m4 value is actually used by DSI module and we can set it
; 5398 :     // as the same value of m3.
; 5399 :     m4 = m3;
; 5400 : 
; 5401 :     DEBUGMSG(1,(L"N:%d M:%d M3:%d M4:%d\r\n",
; 5402 :                    n,m,m3,m4
; 5403 :                    ));
; 5404 : 
; 5405 :     // Enable the Pwr to the DSI sub modules
; 5406 :     value  = INREG32( &m_pDSIRegs->DSI_CLK_CTRL);

  00090	e5963010	 ldr         r3, [r6, #0x10]
  00094	e5933054	 ldr         r3, [r3, #0x54]

; 5407 :     if ((value & DSI_CLK_CTRL_PLL_PWR_STATUS_ON_PLLANDHS) != 0)

  00098	e3130202	 tst         r3, #2, 4

; 5408 :     {
; 5409 :         InitDsiPll();

  0009c	11a00006	 movne       r0, r6
  000a0	1b000000	 blne        |?InitDsiPll@OMAPDisplayController@@IAAHXZ|

; 5410 :     }
; 5411 :     
; 5412 :     // Configure the DSI PLL for bypass mode before updating PLL
; 5413 :     SETREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, DSI_PLL_IDLE);

  000a4	e5962014	 ldr         r2, [r6, #0x14]

; 5414 : 
; 5415 :     // Select the manual mode of PLL update
; 5416 :     value = INREG32( &m_pDSIPLLRegs->DSI_PLL_CONTROL);
; 5417 :     value = value & ~(DSI_PLL_AUTOMODE);
; 5418 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONTROL, value);
; 5419 : 
; 5420 :     // DSIPHY clock is disabled and HSDIV in bypass mode
; 5421 :     pllConfig2  = INREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2);
; 5422 :     pllConfig2  = pllConfig2 & ~(DSIPHY_CLKINEN);
; 5423 :     pllConfig2  = pllConfig2 | DSI_HSDIVBYPASS;
; 5424 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, pllConfig2);
; 5425 : 
; 5426 :     // Input clock to PLL is SYSCLK
; 5427 :     pllConfig2  = pllConfig2 & ~(DSI_PLL_CLKSEL_PCLKFREE);
; 5428 : 
; 5429 :     // Program high freq divider
; 5430 :     if (highFreqDiv != 0)

  000a8	e3590000	 cmp         r9, #0
  000ac	e5923010	 ldr         r3, [r2, #0x10]
  000b0	e3833001	 orr         r3, r3, #1
  000b4	e5823010	 str         r3, [r2, #0x10]
  000b8	e5962014	 ldr         r2, [r6, #0x14]
  000bc	e5923000	 ldr         r3, [r2]
  000c0	e3c33001	 bic         r3, r3, #1
  000c4	e5823000	 str         r3, [r2]
  000c8	e5962014	 ldr         r2, [r6, #0x14]
  000cc	e5923010	 ldr         r3, [r2, #0x10]
  000d0	e3c33901	 bic         r3, r3, #1, 18
  000d4	e3833601	 orr         r3, r3, #1, 12
  000d8	e5823010	 str         r3, [r2, #0x10]
  000dc	e3c33b02	 bic         r3, r3, #2, 22

; 5431 :     {
; 5432 :         pllConfig2 |= DSI_PLL_HIGHFREQ_PIXELCLKBY2;

  000e0	13831a01	 orrne       r1, r3, #1, 20

; 5433 :     }
; 5434 :     else
; 5435 :     {
; 5436 :         pllConfig2 &= ~(DSI_PLL_HIGHFREQ_PIXELCLKBY2);

  000e4	03c31a01	 biceq       r1, r3, #1, 20

; 5437 :     }
; 5438 : 
; 5439 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, pllConfig2);

  000e8	e5962014	 ldr         r2, [r6, #0x14]

; 5440 : 
; 5441 :     // Configure the divisor values
; 5442 :     pllConfig1 =  DSI_PLL_REGN(n)
; 5443 :                  |DSI_PLL_REGM(m)
; 5444 :                  |DSS_CLOCK_DIV(m3)
; 5445 :                  |DSIPROTO_CLOCK_DIV(m4)
; 5446 :                  |DSI_PLL_STOPMODE  
; 5447 :                  ;
; 5448 : 
; 5449 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION1, pllConfig1);

  000ec	e1843204	 orr         r3, r4, r4, lsl #4
  000f0	e1853583	 orr         r3, r5, r3, lsl #11
  000f4	e1883383	 orr         r3, r8, r3, lsl #7
  000f8	e5821010	 str         r1, [r2, #0x10]
  000fc	e5962014	 ldr         r2, [r6, #0x14]
  00100	e1a03083	 mov         r3, r3, lsl #1
  00104	e3833001	 orr         r3, r3, #1
  00108	e582300c	 str         r3, [r2, #0xC]

; 5450 : 
; 5451 :     // Enable the DSS clock divider from HSDIV
; 5452 :     pllConfig2 |=  DSS_CLOCK_EN
; 5453 :                   |DSI_PROTO_CLOCK_EN
; 5454 :                   |DSI_PLL_FREQSEL(DSI_PLL_FREQSELVAL)
; 5455 :                   |DSI_PLL_REFEN
; 5456 :                   ;
; 5457 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, pllConfig2);

  0010c	e3a03a52	 mov         r3, #0x52, 20
  00110	e5962014	 ldr         r2, [r6, #0x14]
  00114	e383300e	 orr         r3, r3, #0xE
  00118	e1813003	 orr         r3, r1, r3
  0011c	e5823010	 str         r3, [r2, #0x10]

; 5458 : 
; 5459 :     // Set HSDIV and CLK from DSI PLL
; 5460 :     pllConfig2 &= ~(DSI_HSDIVBYPASS);
; 5461 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, pllConfig2);

  00120	e5962014	 ldr         r2, [r6, #0x14]
  00124	e3c33601	 bic         r3, r3, #1, 12

; 5462 : 
; 5463 :     // Let the Pll go out of idle
; 5464 :     CLRREG32( &m_pDSIPLLRegs->DSI_PLL_CONFIGURATION2, DSI_PLL_IDLE);
; 5465 :     
; 5466 :     // Start the PLL locking by setting PLL GO
; 5467 :     OUTREG32( &m_pDSIPLLRegs->DSI_PLL_GO, DSI_PLL_GO_CMD);

  00128	e3a01001	 mov         r1, #1
  0012c	e5823010	 str         r3, [r2, #0x10]
  00130	e5962014	 ldr         r2, [r6, #0x14]

; 5468 : 
; 5469 :     count = 100;

  00134	e3a04064	 mov         r4, #0x64
  00138	e5923010	 ldr         r3, [r2, #0x10]
  0013c	e3c33001	 bic         r3, r3, #1
  00140	e5823010	 str         r3, [r2, #0x10]
  00144	e5963014	 ldr         r3, [r6, #0x14]
  00148	e5831008	 str         r1, [r3, #8]

; 5470 :     // Waiting for the lock request to be issued to PLL
; 5471 :     while ((INREG32( &m_pDSIPLLRegs->DSI_PLL_GO) != 0) && (--count))

  0014c	ea000003	 b           |$LN30@ConfigureD|
  00150		 |$LL8@ConfigureD|
  00150	e2544001	 subs        r4, r4, #1
  00154	0a000007	 beq         |$LN28@ConfigureD|

; 5472 :     {
; 5473 :         StallExecution(1000);

  00158	e3a00ffa	 mov         r0, #0xFA, 30
  0015c	eb000000	 bl          StallExecution
  00160		 |$LN30@ConfigureD|
  00160	e5963014	 ldr         r3, [r6, #0x14]
  00164	e5933008	 ldr         r3, [r3, #8]
  00168	e3530000	 cmp         r3, #0
  0016c	1afffff7	 bne         |$LL8@ConfigureD|

; 5481 :         goto Clean;
; 5482 :     }
; 5483 : 
; 5484 :     // Wait for the PLL to be locked
; 5485 :     count = 1000;
; 5486 :     while (((INREG32( &m_pDSIPLLRegs->DSI_PLL_STATUS) & DSI_PLL_LOCK_STATUS) != 
; 5487 :               DSI_PLL_LOCK_STATUS) && (--count))

  00170	e3a04ffa	 mov         r4, #0xFA, 30
  00174	ea000005	 b           |$LN33@ConfigureD|
  00178		 |$LN28@ConfigureD|

; 5474 :     }
; 5475 : 
; 5476 :     if (count == 0)
; 5477 :     {
; 5478 :         /* lock request timed out */
; 5479 :         bRet = FALSE;
; 5480 :         RETAILMSG(1,(L"DSI PLL Go not set\r\n"));

  00178	e59f0044	 ldr         r0, [pc, #0x44]

; 5497 :         goto Clean;
; 5498 :     }
; 5499 :     
; 5500 :     
; 5501 :     
; 5502 : Clean:

  0017c	ea00000a	 b           |$LN31@ConfigureD|
  00180		 |$LL4@ConfigureD|

; 5481 :         goto Clean;
; 5482 :     }
; 5483 : 
; 5484 :     // Wait for the PLL to be locked
; 5485 :     count = 1000;
; 5486 :     while (((INREG32( &m_pDSIPLLRegs->DSI_PLL_STATUS) & DSI_PLL_LOCK_STATUS) != 
; 5487 :               DSI_PLL_LOCK_STATUS) && (--count))

  00180	e2544001	 subs        r4, r4, #1
  00184	0a000007	 beq         |$LN27@ConfigureD|

; 5488 :     {
; 5489 :         StallExecution(1000);

  00188	e3a00ffa	 mov         r0, #0xFA, 30
  0018c	eb000000	 bl          StallExecution
  00190		 |$LN33@ConfigureD|
  00190	e5963014	 ldr         r3, [r6, #0x14]
  00194	e5933004	 ldr         r3, [r3, #4]
  00198	e2033002	 and         r3, r3, #2
  0019c	e3530002	 cmp         r3, #2
  001a0	1afffff6	 bne         |$LL4@ConfigureD|

; 5490 :     }
; 5491 : 
; 5492 :     // check the PLL lock status for timeout
; 5493 :     if (count == 0)

  001a4	ea000002	 b           |$Clean$39964|
  001a8		 |$LN27@ConfigureD|

; 5494 :     {
; 5495 :         bRet = FALSE;
; 5496 :         RETAILMSG(1,(L"DSI PLL Lock timed out\r\n"));

  001a8	e59f0010	 ldr         r0, [pc, #0x10]
  001ac		 |$LN31@ConfigureD|
  001ac	e3a07000	 mov         r7, #0
  001b0	eb000000	 bl          NKDbgPrintfW
  001b4		 |$Clean$39964|

; 5503 : 
; 5504 :   return bRet;
; 5505 : }

  001b4	e1a00007	 mov         r0, r7
  001b8	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001bc	e12fff1e	 bx          lr
  001c0		 |$LN37@ConfigureD|
  001c0		 |$LN38@ConfigureD|
  001c0	00000000	 DCD         |??_C@_1DC@EGPANNCF@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAL?$AAo?$AAc?$AAk?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAd?$AA?5?$AAo?$AAu?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  001c4		 |$LN39@ConfigureD|
  001c4	00000000	 DCD         |??_C@_1CK@PPIENFCI@?$AAD?$AAS?$AAI?$AA?5?$AAP?$AAL?$AAL?$AA?5?$AAG?$AAo?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  001c8		 |$LN40@ConfigureD|
  001c8	431bde83	 DCD         0x431bde83
  001cc		 |$LN41@ConfigureD|
  001cc	00000000	 DCD         |??_C@_1HE@BACIAFEL@?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe?$AAD?$AAs?$AAi?$AAP?$AAl?$AAl?$AA?3?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg?$AAu?$AAr?$AAe@|
  001d0		 |$M41081|

			 ENDP  ; |?ConfigureDsiPll@OMAPDisplayController@@QAAHK@Z|, OMAPDisplayController::ConfigureDsiPll

	EXPORT	|?SwitchDssFclk@OMAPDisplayController@@IAAHW4OMAP_DSS_FCLK@@W4OMAP_DSS_FCLKVALUE@@@Z| ; OMAPDisplayController::SwitchDssFclk

  00000			 AREA	 |.pdata|, PDATA
|$T41109| DCD	|$LN15@SwitchDssF|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SwitchDssFclk@OMAPDisplayController@@IAAHW4OMAP_DSS_FCLK@@W4OMAP_DSS_FCLKVALUE@@@Z| PROC ; OMAPDisplayController::SwitchDssFclk

; 5514 : {

  00000		 |$LN15@SwitchDssF|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M41106|
  00004	e1a0e002	 mov         lr, r2
  00008	e3510000	 cmp         r1, #0
  0000c	e1a04000	 mov         r4, r0

; 5515 :     DWORD dssStatusBit = 1;
; 5516 :     DWORD count     = 100;
; 5517 :     DWORD bitMask   = 1;
; 5518 :     DWORD sdiStatus = 0;
; 5519 :     DWORD reg,
; 5520 :           lcd = 1,
; 5521 :           pcd = 1;
; 5522 :           
; 5523 :     if ( eFclkSrc == OMAP_DSS_FCLK_DSS1ALWON )
; 5524 :     {
; 5525 :         // Change the source clock to DSS
; 5526 :         CLRREG32( &m_pDSSRegs->DSS_CONTROL, 
; 5527 :                     DSS_CONTROL_DISPC_CLK_SWITCH_DSI1_PLL
; 5528 :                     );

  00010	05941004	 ldreq       r1, [r4, #4]
  00014	e3a05001	 mov         r5, #1
  00018	e3a06064	 mov         r6, #0x64

; 5529 :         dssStatusBit = 1;

  0001c	05913040	 ldreq       r3, [r1, #0x40]
  00020	03a05001	 moveq       r5, #1
  00024	03c33001	 biceq       r3, r3, #1
  00028	05813040	 streq       r3, [r1, #0x40]
  0002c	0a000005	 beq         |$LN3@SwitchDssF|

; 5530 :     }
; 5531 :     else if ( eFclkSrc == OMAP_DSS_FCLK_DSS2ALWON )

  00030	e3510001	 cmp         r1, #1

; 5532 :     {
; 5533 :         // Change the source clock DSI1_PLL
; 5534 :         SETREG32( &m_pDSSRegs->DSS_CONTROL, 
; 5535 :                     DSS_CONTROL_DISPC_CLK_SWITCH_DSI1_PLL
; 5536 :                     );

  00034	05942004	 ldreq       r2, [r4, #4]

; 5537 :         dssStatusBit = 0;

  00038	03a05000	 moveq       r5, #0
  0003c	05923040	 ldreq       r3, [r2, #0x40]
  00040	03833001	 orreq       r3, r3, #1
  00044	05823040	 streq       r3, [r2, #0x40]
  00048		 |$LN3@SwitchDssF|

; 5538 :     }
; 5539 : 
; 5540 :     pcd = eFclkValue / m_dwPixelClock ;

  00048	e59404b0	 ldr         r0, [r4, #0x4B0]
  0004c	e1a0100e	 mov         r1, lr
  00050	eb000000	 bl          __rt_udiv

; 5541 :     reg = DISPC_DIVISOR_LCD(lcd) | DISPC_DIVISOR_PCD(pcd);
; 5542 :     OUTREG32( &m_pDispRegs->DISPC_DIVISOR, reg );    

  00054	e5942008	 ldr         r2, [r4, #8]
  00058	e3803801	 orr         r3, r0, #1, 16

; 5543 :     // Update the shadow register contents into main
; 5544 :     FlushRegs( DISPC_CONTROL_GOLCD );

  0005c	e3a01020	 mov         r1, #0x20
  00060	e1a00004	 mov         r0, r4
  00064	e5823070	 str         r3, [r2, #0x70]
  00068	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 5545 : 
; 5546 :     // check for the clock switch by reading SDI_STATUS register
; 5547 :     sdiStatus = INREG32(&m_pDSSRegs->DSS_SDI_STATUS);
; 5548 :     while (((sdiStatus & bitMask) != dssStatusBit) && (--count))

  0006c	ea000003	 b           |$LN12@SwitchDssF|
  00070		 |$LL2@SwitchDssF|
  00070	e2566001	 subs        r6, r6, #1
  00074	0a000006	 beq         |$LN10@SwitchDssF|

; 5549 :     {
; 5550 :         StallExecution(1000);

  00078	e3a00ffa	 mov         r0, #0xFA, 30
  0007c	eb000000	 bl          StallExecution
  00080		 |$LN12@SwitchDssF|

; 5551 :         sdiStatus = INREG32( &m_pDSSRegs->DSS_SDI_STATUS);

  00080	e5943004	 ldr         r3, [r4, #4]
  00084	e593305c	 ldr         r3, [r3, #0x5C]
  00088	e2033001	 and         r3, r3, #1
  0008c	e1530005	 cmp         r3, r5
  00090	1afffff6	 bne         |$LL2@SwitchDssF|
  00094		 |$LN10@SwitchDssF|

; 5552 :     }
; 5553 : 
; 5554 :     return TRUE;

  00094	e3a00001	 mov         r0, #1

; 5555 : }

  00098	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M41107|

			 ENDP  ; |?SwitchDssFclk@OMAPDisplayController@@IAAHW4OMAP_DSS_FCLK@@W4OMAP_DSS_FCLKVALUE@@@Z|, OMAPDisplayController::SwitchDssFclk

	EXPORT	|LcdStall|

  00000			 AREA	 |.pdata|, PDATA
|$T41117| DCD	|$LN5@LcdStall|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LcdStall| PROC

; 5559 : {

  00000		 |$LN5@LcdStall|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41114|

; 5560 :     StallExecution(dwMicroseconds);

  00004	eb000000	 bl          StallExecution

; 5561 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M41115|

			 ENDP  ; |LcdStall|

	EXPORT	|LcdSleep|

  00000			 AREA	 |.pdata|, PDATA
|$T41125| DCD	|$LN5@LcdSleep|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |LcdSleep| PROC

; 5564 : {

  00000		 |$LN5@LcdSleep|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M41122|

; 5565 :     Sleep(dwMilliseconds);

  00004	eb000000	 bl          Sleep

; 5566 : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M41123|

			 ENDP  ; |LcdSleep|

	EXPORT	|??1OMAPDisplayController@@UAA@XZ|	; OMAPDisplayController::~OMAPDisplayController
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|FreePhysMem|
	IMPORT	|PmxClosePolicy|
	IMPORT	|DeleteCriticalSection|

  00000			 AREA	 |.pdata|, PDATA
|$T41133| DCD	|$LN12@OMAPDispla@2|
	DCD	0x40003201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??1OMAPDisplayController@@UAA@XZ| PROC ; OMAPDisplayController::~OMAPDisplayController

; 157  : {

  00000		 |$LN12@OMAPDispla@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M41130|
  00004	e1a04000	 mov         r4, r0
  00008	e59f30b4	 ldr         r3, [pc, #0xB4]

; 158  :     UninitInterrupts();

  0000c	e5843000	 str         r3, [r4]
  00010	eb000000	 bl          |?UninitInterrupts@OMAPDisplayController@@QAAXXZ|

; 159  : 
; 160  :     //  Release all clocks
; 161  :     EnableDeviceClocks( m_dssinfo.DSSDevice, FALSE );

  00014	e594051c	 ldr         r0, [r4, #0x51C]
  00018	e3a01000	 mov         r1, #0
  0001c	eb000000	 bl          EnableDeviceClocks

; 162  :     EnableDeviceClocks( m_dssinfo.TVEncoderDevice, FALSE );         

  00020	e5940520	 ldr         r0, [r4, #0x520]
  00024	e3a01000	 mov         r1, #0
  00028	eb000000	 bl          EnableDeviceClocks

; 163  : 
; 164  :     //  Delete power lock critical section
; 165  :     DeleteCriticalSection( &m_csPowerLock );

  0002c	e2843b01	 add         r3, r4, #1, 22
  00030	e283008c	 add         r0, r3, #0x8C
  00034	eb000000	 bl          DeleteCriticalSection

; 166  : 
; 167  :     // Close SmartReflex policy adapter
; 168  :     if (m_hSmartReflexPolicyAdapter != NULL)

  00038	e5943518	 ldr         r3, [r4, #0x518]
  0003c	e3530000	 cmp         r3, #0

; 169  :         PmxClosePolicy(m_hSmartReflexPolicyAdapter);

  00040	11a00003	 movne       r0, r3
  00044	1b000000	 blne        PmxClosePolicy

; 170  :     
; 171  :     //  Free allocated memory
; 172  :     if( m_pGammaBufVirt != NULL )

  00048	e59434d4	 ldr         r3, [r4, #0x4D4]
  0004c	e3530000	 cmp         r3, #0

; 173  :         FreePhysMem( m_pGammaBufVirt );

  00050	11a00003	 movne       r0, r3
  00054	1b000000	 blne        FreePhysMem

; 174  :         
; 175  :     //  Unmap registers
; 176  :     if (m_pDSSRegs != NULL) 

  00058	e5943004	 ldr         r3, [r4, #4]
  0005c	e3530000	 cmp         r3, #0

; 177  :         MmUnmapIoSpace((VOID*)m_pDSSRegs, DSS_REGS_SIZE);

  00060	13a01b01	 movne       r1, #1, 22
  00064	11a00003	 movne       r0, r3
  00068	1b000000	 blne        MmUnmapIoSpace

; 178  : 
; 179  :     if (m_pDispRegs != NULL) 

  0006c	e5943008	 ldr         r3, [r4, #8]
  00070	e3530000	 cmp         r3, #0

; 180  :         MmUnmapIoSpace((VOID*)m_pDispRegs, DSS_REGS_SIZE);

  00074	13a01b01	 movne       r1, #1, 22
  00078	11a00003	 movne       r0, r3
  0007c	1b000000	 blne        MmUnmapIoSpace

; 181  : 
; 182  :     if (m_pVencRegs != NULL) 

  00080	e594300c	 ldr         r3, [r4, #0xC]
  00084	e3530000	 cmp         r3, #0

; 183  :         MmUnmapIoSpace((VOID*)m_pVencRegs, DSS_REGS_SIZE);

  00088	13a01b01	 movne       r1, #1, 22
  0008c	11a00003	 movne       r0, r3
  00090	1b000000	 blne        MmUnmapIoSpace

; 184  :         
; 185  :     if (m_pDSIRegs != NULL)

  00094	e5943010	 ldr         r3, [r4, #0x10]
  00098	e3530000	 cmp         r3, #0

; 186  :         MmUnmapIoSpace((VOID*)m_pDSIRegs,  sizeof(OMAP_DSI_REGS));

  0009c	13a010c0	 movne       r1, #0xC0
  000a0	11a00003	 movne       r0, r3
  000a4	1b000000	 blne        MmUnmapIoSpace

; 187  : 
; 188  :     if (m_pDSIPLLRegs != NULL)

  000a8	e5943014	 ldr         r3, [r4, #0x14]
  000ac	e3530000	 cmp         r3, #0

; 189  :         MmUnmapIoSpace((VOID*)m_pDSIPLLRegs, sizeof(OMAP_DSI_PLL_REGS));

  000b0	13a01014	 movne       r1, #0x14
  000b4	11a00003	 movne       r0, r3
  000b8	1b000000	 blne        MmUnmapIoSpace

; 190  : 
; 191  : }

  000bc	e8bd4010	 ldmia       sp!, {r4, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$LN13@OMAPDispla@2|
  000c4		 |$LN14@OMAPDispla@2|
  000c4	00000000	 DCD         |??_7OMAPDisplayController@@6B@|
  000c8		 |$M41131|

			 ENDP  ; |??1OMAPDisplayController@@UAA@XZ|, OMAPDisplayController::~OMAPDisplayController

	EXPORT	|?SetPipelineAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@W4OMAP_DSS_DESTINATION@@PAVOMAPSurface@@KK@Z| ; OMAPDisplayController::SetPipelineAttribs

  00000			 AREA	 |.pdata|, PDATA
|$T41205| DCD	|$LN58@SetPipelin|
	DCD	0x4001c402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPipelineAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@W4OMAP_DSS_DESTINATION@@PAVOMAPSurface@@KK@Z| PROC ; OMAPDisplayController::SetPipelineAttribs

; 782  : {

  00000		 |$LN58@SetPipelin|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M41202|
  00008	e1a05002	 mov         r5, r2
  0000c	e58d500c	 str         r5, [sp, #0xC]
  00010	e1a06003	 mov         r6, r3
  00014	e1a0b001	 mov         r11, r1
  00018	e1a07000	 mov         r7, r0

; 783  :     BOOL    bResult = FALSE;
; 784  :     OMAP_DSS_ROTATION   eRotation;
; 785  :     BOOL                bMirror;
; 786  :     DWORD               dwVidRotation = 0;
; 787  :     DWORD               dwX, dwY;
; 788  : 
; 789  : 
; 790  :     //  Access the regs
; 791  :     if( AccessRegs() == FALSE )

  0001c	e3a04000	 mov         r4, #0
  00020	e3a09000	 mov         r9, #0
  00024	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00028	e3500000	 cmp         r0, #0
  0002c	0a0001ae	 beq         |$cleanUp$38033|

; 792  :         goto cleanUp;
; 793  : 
; 794  : 
; 795  :     //  Get rotation and mirror settings for pipeline output
; 796  :     eRotation = g_rgPipelineMapping[ePipeline].eRotation;

  00030	e59f06d4	 ldr         r0, [pc, #0x6D4]

; 797  :     bMirror   = g_rgPipelineMapping[ePipeline].bMirror;
; 798  : 
; 799  : 
; 800  :     //  Set rotation attributes for video pipelines if pixel format is YUV
; 801  :     if( pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_YUV2 ||    
; 802  :         pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_UYVY )  

  00034	e3a03c01	 mov         r3, #1, 24
  00038	e5962004	 ldr         r2, [r6, #4]
  0003c	e080a28b	 add         r10, r0, r11, lsl #5
  00040	e383100e	 orr         r1, r3, #0xE
  00044	e59a3010	 ldr         r3, [r10, #0x10]
  00048	e59a800c	 ldr         r8, [r10, #0xC]
  0004c	e352000a	 cmp         r2, #0xA
  00050	e58d3008	 str         r3, [sp, #8]
  00054	0a000001	 beq         |$LN18@SetPipelin|
  00058	e352000b	 cmp         r2, #0xB
  0005c	1a00000c	 bne         |$LN25@SetPipelin|
  00060		 |$LN18@SetPipelin|

; 803  :     {
; 804  :         //  Depending on rotation and mirror settings, change the VID rotation attributes
; 805  :         switch( eRotation )

  00060	e3580000	 cmp         r8, #0
  00064	0a000023	 beq         |$LN15@SetPipelin|
  00068	e358005a	 cmp         r8, #0x5A
  0006c	0a00001f	 beq         |$LN14@SetPipelin|
  00070	e35800b4	 cmp         r8, #0xB4
  00074	0a000003	 beq         |$LN13@SetPipelin|
  00078	e1580001	 cmp         r8, r1
  0007c	1a000004	 bne         |$LN25@SetPipelin|

; 821  :                 break;
; 822  : 
; 823  :             case OMAP_DSS_ROTATION_270:
; 824  :                 //  Settings for rotation angle 270 (90 for DSS setting)
; 825  :                 dwVidRotation = DISPC_VID_ATTR_VIDROTATION_90 | DISPC_VID_ATTR_VIDROWREPEATENABLE;

  00080	e3a09a41	 mov         r9, #0x41, 20

; 826  :                 //dwVidRotation |= DISPC_VID_ATTR_VIDDMAOPTIMIZATION;
; 827  :                 break;

  00084	ea000002	 b           |$LN25@SetPipelin|
  00088		 |$LN13@SetPipelin|

; 817  : 
; 818  :             case OMAP_DSS_ROTATION_180:
; 819  :                 //  Settings for rotation angle 180
; 820  :                 dwVidRotation = (bMirror) ? DISPC_VID_ATTR_VIDROTATION_0 : DISPC_VID_ATTR_VIDROTATION_180;

  00088	e3530000	 cmp         r3, #0
  0008c	0a00001b	 beq         |$LN54@SetPipelin|
  00090		 |$LN24@SetPipelin|

; 806  :         {
; 807  :             case OMAP_DSS_ROTATION_0:
; 808  :                 //  Settings for rotation angle 0
; 809  :                 dwVidRotation = (bMirror) ? DISPC_VID_ATTR_VIDROTATION_180 : DISPC_VID_ATTR_VIDROTATION_0;

  00090	e3a09000	 mov         r9, #0
  00094		 |$LN25@SetPipelin|

; 828  :         }
; 829  :     }
; 830  : 
; 831  : 
; 832  :     //  Compute new origin and swap width/height based on GFX pipeline rotation angle
; 833  :     switch( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].eRotation )

  00094	e590300c	 ldr         r3, [r0, #0xC]
  00098	e3530000	 cmp         r3, #0
  0009c	0a00003d	 beq         |$LN9@SetPipelin|
  000a0	e353005a	 cmp         r3, #0x5A
  000a4	0a00002e	 beq         |$LN8@SetPipelin|
  000a8	e35300b4	 cmp         r3, #0xB4
  000ac	0a000015	 beq         |$LN7@SetPipelin|
  000b0	e1530001	 cmp         r3, r1
  000b4	1a00018c	 bne         |$cleanUp$38033|

; 849  :             
; 850  :         case OMAP_DSS_ROTATION_270:
; 851  :             dwX = GetLCDWidth() - pSurface->Height() - dwPosY;

  000b8	e5963000	 ldr         r3, [r6]
  000bc	e59744a8	 ldr         r4, [r7, #0x4A8]
  000c0	e3a01000	 mov         r1, #0
  000c4	e593300c	 ldr         r3, [r3, #0xC]
  000c8	e1a00006	 mov         r0, r6
  000cc	e1a0e00f	 mov         lr, pc
  000d0	e12fff13	 bx          r3
  000d4	e59d2038	 ldr         r2, [sp, #0x38]

; 852  :             dwY = dwPosX;

  000d8	e59d1034	 ldr         r1, [sp, #0x34]
  000dc	e0443000	 sub         r3, r4, r0
  000e0	e0432002	 sub         r2, r3, r2
  000e4	e58d2004	 str         r2, [sp, #4]
  000e8	e58d1000	 str         r1, [sp]

; 853  :             break;

  000ec	ea00002d	 b           |$LN10@SetPipelin|
  000f0		 |$LN14@SetPipelin|

; 810  :                 break;
; 811  : 
; 812  :             case OMAP_DSS_ROTATION_90:
; 813  :                 //  Settings for rotation angle 90 (270 for DSS setting)
; 814  :                 dwVidRotation = DISPC_VID_ATTR_VIDROTATION_270 | DISPC_VID_ATTR_VIDROWREPEATENABLE;

  000f0	e3a09a43	 mov         r9, #0x43, 20

; 815  :                 //dwVidRotation |= DISPC_VID_ATTR_VIDDMAOPTIMIZATION;
; 816  :                 break;

  000f4	eaffffe6	 b           |$LN25@SetPipelin|
  000f8		 |$LN15@SetPipelin|

; 806  :         {
; 807  :             case OMAP_DSS_ROTATION_0:
; 808  :                 //  Settings for rotation angle 0
; 809  :                 dwVidRotation = (bMirror) ? DISPC_VID_ATTR_VIDROTATION_180 : DISPC_VID_ATTR_VIDROTATION_0;

  000f8	e3530000	 cmp         r3, #0
  000fc	0affffe3	 beq         |$LN24@SetPipelin|
  00100		 |$LN54@SetPipelin|
  00100	e3a09a02	 mov         r9, #2, 20
  00104	eaffffe2	 b           |$LN25@SetPipelin|
  00108		 |$LN7@SetPipelin|

; 844  :             
; 845  :         case OMAP_DSS_ROTATION_180:
; 846  :             dwX = GetLCDWidth() - pSurface->Width() - dwPosX;

  00108	e5963000	 ldr         r3, [r6]
  0010c	e59744a8	 ldr         r4, [r7, #0x4A8]
  00110	e3a01000	 mov         r1, #0
  00114	e5933008	 ldr         r3, [r3, #8]
  00118	e1a00006	 mov         r0, r6
  0011c	e1a0e00f	 mov         lr, pc
  00120	e12fff13	 bx          r3

; 847  :             dwY = GetLCDHeight() - pSurface->Height() - dwPosY;

  00124	e5963000	 ldr         r3, [r6]
  00128	e59d5034	 ldr         r5, [sp, #0x34]
  0012c	e3a01000	 mov         r1, #0
  00130	e593200c	 ldr         r2, [r3, #0xC]
  00134	e0443000	 sub         r3, r4, r0
  00138	e0433005	 sub         r3, r3, r5
  0013c	e59744ac	 ldr         r4, [r7, #0x4AC]
  00140	e58d3004	 str         r3, [sp, #4]
  00144	e1a00006	 mov         r0, r6
  00148	e1a0e00f	 mov         lr, pc
  0014c	e12fff12	 bx          r2
  00150	e59d2038	 ldr         r2, [sp, #0x38]
  00154	e0443000	 sub         r3, r4, r0

; 848  :             break;

  00158	e59d500c	 ldr         r5, [sp, #0xC]
  0015c	e0433002	 sub         r3, r3, r2
  00160	ea00000f	 b           |$LN55@SetPipelin|
  00164		 |$LN8@SetPipelin|

; 838  :             break;
; 839  :             
; 840  :         case OMAP_DSS_ROTATION_90:
; 841  :             dwX = dwPosY;
; 842  :             dwY = GetLCDHeight() - pSurface->Width() - dwPosX;

  00164	e5963000	 ldr         r3, [r6]
  00168	e59d2038	 ldr         r2, [sp, #0x38]
  0016c	e59744ac	 ldr         r4, [r7, #0x4AC]
  00170	e5933008	 ldr         r3, [r3, #8]
  00174	e58d2004	 str         r2, [sp, #4]
  00178	e3a01000	 mov         r1, #0
  0017c	e1a00006	 mov         r0, r6
  00180	e1a0e00f	 mov         lr, pc
  00184	e12fff13	 bx          r3
  00188	e59d2034	 ldr         r2, [sp, #0x34]
  0018c	e0443000	 sub         r3, r4, r0
  00190	e0433002	 sub         r3, r3, r2

; 843  :             break;

  00194	ea000002	 b           |$LN55@SetPipelin|
  00198		 |$LN9@SetPipelin|

; 834  :     {
; 835  :         case OMAP_DSS_ROTATION_0:
; 836  :             dwX = dwPosX;

  00198	e59d3034	 ldr         r3, [sp, #0x34]
  0019c	e58d3004	 str         r3, [sp, #4]

; 837  :             dwY = dwPosY;

  001a0	e59d3038	 ldr         r3, [sp, #0x38]
  001a4		 |$LN55@SetPipelin|
  001a4	e58d3000	 str         r3, [sp]
  001a8		 |$LN10@SetPipelin|

; 854  :             
; 855  :         default:
; 856  :             ASSERT(0);
; 857  :             goto cleanUp;
; 858  :     }
; 859  : 
; 860  : 
; 861  :     //  Configure the attributes of the selected pipeline
; 862  : 
; 863  :     
; 864  :     //  GFX pipeline
; 865  :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  001a8	e35b0000	 cmp         r11, #0
  001ac	1a00004d	 bne         |$LN3@SetPipelin|

; 866  :     {
; 867  :         //  Set attributes of pipeline
; 868  :         OUTREG32( &m_pDispRegs->DISPC_GFX_ATTRIBUTES,
; 869  :                     ((eDestination == OMAP_DSS_DESTINATION_TVOUT) ? DISPC_GFX_ATTR_GFXCHANNELOUT : 0) |
; 870  :                     DISPC_GFX_ATTR_GFXBURSTSIZE_16x32 |
; 871  :                     DISPC_GFX_ATTR_GFXREPLICATIONENABLE |
; 872  :                     DISPC_GFX_ATTR_GFXFORMAT(pSurface->PixelFormat())
; 873  :                     );

  001b0	e5963004	 ldr         r3, [r6, #4]
  001b4	e3550001	 cmp         r5, #1
  001b8	e5972008	 ldr         r2, [r7, #8]
  001bc	03a00c01	 moveq       r0, #1, 24

; 874  : 
; 875  :         //  Size of window
; 876  :         OUTREG32( &m_pDispRegs->DISPC_GFX_SIZE,
; 877  :                     DISPC_GFX_SIZE_GFXSIZEX(pSurface->Width(eRotation)) |
; 878  :                     DISPC_GFX_SIZE_GFXSIZEY(pSurface->Height(eRotation))
; 879  :                     );

  001c0	e3833050	 orr         r3, r3, #0x50
  001c4	13a00000	 movne       r0, #0
  001c8	e1803083	 orr         r3, r0, r3, lsl #1
  001cc	e58230a0	 str         r3, [r2, #0xA0]
  001d0	e5963000	 ldr         r3, [r6]
  001d4	e1a01008	 mov         r1, r8
  001d8	e1a00006	 mov         r0, r6
  001dc	e5933008	 ldr         r3, [r3, #8]
  001e0	e1a0e00f	 mov         lr, pc
  001e4	e12fff13	 bx          r3
  001e8	e5963000	 ldr         r3, [r6]
  001ec	e1a04000	 mov         r4, r0
  001f0	e1a01008	 mov         r1, r8
  001f4	e593300c	 ldr         r3, [r3, #0xC]
  001f8	e1a00006	 mov         r0, r6
  001fc	e1a0e00f	 mov         lr, pc
  00200	e12fff13	 bx          r3
  00204	e5971008	 ldr         r1, [r7, #8]
  00208	e2402001	 sub         r2, r0, #1
  0020c	e2443001	 sub         r3, r4, #1
  00210	e1833802	 orr         r3, r3, r2, lsl #16

; 880  : 
; 881  :         //  Position of window
; 882  :         OUTREG32( &m_pDispRegs->DISPC_GFX_POSITION,
; 883  :                     DISPC_GFX_POS_GFXPOSX(dwX) |
; 884  :                     DISPC_GFX_POS_GFXPOSY(dwY)
; 885  :                     );

  00214	e59d2004	 ldr         r2, [sp, #4]
  00218	e581308c	 str         r3, [r1, #0x8C]
  0021c	e59d3000	 ldr         r3, [sp]
  00220	e5971008	 ldr         r1, [r7, #8]

; 886  :                     
; 887  :         //  Pipeline FIFO and DMA settings
; 888  :         OUTREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD,
; 889  :                     DISPC_GFX_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 890  :                     DISPC_GFX_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 891  :                     );
; 892  : 
; 893  :         OUTREG32( &m_pDispRegs->DISPC_GFX_PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00224	e3e0533f	 mvn         r5, #0x3F, 6
  00228	e1823803	 orr         r3, r2, r3, lsl #16
  0022c	e5813088	 str         r3, [r1, #0x88]
  00230	e5973008	 ldr         r3, [r7, #8]
  00234	e225ecfe	 eor         lr, r5, #0xFE, 24
  00238	e59d4008	 ldr         r4, [sp, #8]
  0023c	e583e0a4	 str         lr, [r3, #0xA4]
  00240	e5963000	 ldr         r3, [r6]
  00244	e1a02004	 mov         r2, r4
  00248	e1a01008	 mov         r1, r8
  0024c	e5933018	 ldr         r3, [r3, #0x18]
  00250	e1a00006	 mov         r0, r6
  00254	e1a0e00f	 mov         lr, pc
  00258	e12fff13	 bx          r3
  0025c	e5973008	 ldr         r3, [r7, #8]

; 894  :         OUTREG32( &m_pDispRegs->DISPC_GFX_ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  00260	e1a02004	 mov         r2, r4
  00264	e1a01008	 mov         r1, r8
  00268	e58300b0	 str         r0, [r3, #0xB0]
  0026c	e5963000	 ldr         r3, [r6]
  00270	e1a00006	 mov         r0, r6
  00274	e593301c	 ldr         r3, [r3, #0x1C]
  00278	e1a0e00f	 mov         lr, pc
  0027c	e12fff13	 bx          r3
  00280	e5972008	 ldr         r2, [r7, #8]

; 895  :         OUTREG32( &m_pDispRegs->DISPC_GFX_WINDOW_SKIP, 0 );
; 896  : 
; 897  :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA0, pSurface->PhysicalAddr(eRotation, bMirror) );

  00284	e3a0e000	 mov         lr, #0
  00288	e3a03000	 mov         r3, #0
  0028c	e58200ac	 str         r0, [r2, #0xAC]
  00290	e5970008	 ldr         r0, [r7, #8]
  00294	e1a02004	 mov         r2, r4
  00298	e1a01008	 mov         r1, r8
  0029c	e580e0b4	 str         lr, [r0, #0xB4]
  002a0	e5964000	 ldr         r4, [r6]
  002a4	e1a00006	 mov         r0, r6
  002a8	e5944014	 ldr         r4, [r4, #0x14]
  002ac	e1a0e00f	 mov         lr, pc
  002b0	e12fff14	 bx          r4
  002b4	e5972008	 ldr         r2, [r7, #8]

; 898  :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  002b8	e3a03000	 mov         r3, #0
  002bc	e1a01008	 mov         r1, r8
  002c0	e5820080	 str         r0, [r2, #0x80]
  002c4	e5960000	 ldr         r0, [r6]
  002c8	e59d2008	 ldr         r2, [sp, #8]
  002cc	e5904014	 ldr         r4, [r0, #0x14]
  002d0	e1a00006	 mov         r0, r6
  002d4	e1a0e00f	 mov         lr, pc
  002d8	e12fff14	 bx          r4
  002dc	e5973008	 ldr         r3, [r7, #8]
  002e0	e59d500c	 ldr         r5, [sp, #0xC]
  002e4	e5830084	 str         r0, [r3, #0x84]
  002e8		 |$LN3@SetPipelin|

; 899  : 
; 900  :     }    
; 901  : 
; 902  : 
; 903  :     //  VIDEO1 pipeline
; 904  :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  002e8	e35b0001	 cmp         r11, #1
  002ec	1a000071	 bne         |$LN2@SetPipelin|

; 905  :     {
; 906  :         //  Set attributes of pipeline
; 907  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES,
; 908  :                     ((eDestination == OMAP_DSS_DESTINATION_TVOUT) ? DISPC_VID_ATTR_VIDCHANNELOUT : 0) |
; 909  :                     dwVidRotation |
; 910  :                     DISPC_VID_ATTR_VIDBURSTSIZE_16x32 |
; 911  :                     DISPC_VID_ATTR_VIDCOLORCONVENABLE |
; 912  :                     DISPC_VID_ATTR_VIDRESIZE_NONE |
; 913  :                     DISPC_VID_ATTR_VIDFORMAT(pSurface->PixelFormat())
; 914  :                     );

  002f0	e5963004	 ldr         r3, [r6, #4]
  002f4	e3550001	 cmp         r5, #1
  002f8	03a00801	 moveq       r0, #1, 16

; 915  : 
; 916  :         //  Size of window; picture size is the same for no scaling
; 917  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.SIZE,
; 918  :                     DISPC_VID_SIZE_VIDSIZEX(pSurface->Width(eRotation)) |
; 919  :                     DISPC_VID_SIZE_VIDSIZEY(pSurface->Height(eRotation))
; 920  :                     );

  002fc	e3833c41	 orr         r3, r3, #0x41, 24
  00300	13a00000	 movne       r0, #0
  00304	e5972008	 ldr         r2, [r7, #8]
  00308	e1803083	 orr         r3, r0, r3, lsl #1
  0030c	e1833009	 orr         r3, r3, r9
  00310	e58230cc	 str         r3, [r2, #0xCC]
  00314	e5963000	 ldr         r3, [r6]
  00318	e1a01008	 mov         r1, r8
  0031c	e1a00006	 mov         r0, r6
  00320	e5933008	 ldr         r3, [r3, #8]
  00324	e1a0e00f	 mov         lr, pc
  00328	e12fff13	 bx          r3
  0032c	e5963000	 ldr         r3, [r6]
  00330	e1a04000	 mov         r4, r0
  00334	e1a01008	 mov         r1, r8
  00338	e593300c	 ldr         r3, [r3, #0xC]
  0033c	e1a00006	 mov         r0, r6
  00340	e1a0e00f	 mov         lr, pc
  00344	e12fff13	 bx          r3
  00348	e5971008	 ldr         r1, [r7, #8]
  0034c	e2402001	 sub         r2, r0, #1
  00350	e2443001	 sub         r3, r4, #1
  00354	e1833802	 orr         r3, r3, r2, lsl #16
  00358	e58130c8	 str         r3, [r1, #0xC8]

; 921  : 
; 922  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PICTURE_SIZE,
; 923  :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEX(pSurface->Width(eRotation)) |
; 924  :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEY(pSurface->Height(eRotation))
; 925  :                     );

  0035c	e5963000	 ldr         r3, [r6]
  00360	e1a01008	 mov         r1, r8
  00364	e1a00006	 mov         r0, r6
  00368	e5933008	 ldr         r3, [r3, #8]
  0036c	e1a0e00f	 mov         lr, pc
  00370	e12fff13	 bx          r3
  00374	e5963000	 ldr         r3, [r6]
  00378	e1a04000	 mov         r4, r0
  0037c	e1a01008	 mov         r1, r8
  00380	e593300c	 ldr         r3, [r3, #0xC]
  00384	e1a00006	 mov         r0, r6
  00388	e1a0e00f	 mov         lr, pc
  0038c	e12fff13	 bx          r3
  00390	e5971008	 ldr         r1, [r7, #8]
  00394	e2402001	 sub         r2, r0, #1
  00398	e2443001	 sub         r3, r4, #1
  0039c	e1833802	 orr         r3, r3, r2, lsl #16

; 926  : 
; 927  :         //  Position of window
; 928  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.POSITION,
; 929  :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 930  :                     DISPC_VID_POS_VIDPOSY(dwY)
; 931  :                     );

  003a0	e59d2004	 ldr         r2, [sp, #4]
  003a4	e58130e4	 str         r3, [r1, #0xE4]
  003a8	e59d3000	 ldr         r3, [sp]
  003ac	e5971008	 ldr         r1, [r7, #8]

; 932  :                     
; 933  :         //  Pipeline FIFO and DMA settings
; 934  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD,
; 935  :                     DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 936  :                     DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 937  :                     );
; 938  : 
; 939  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  003b0	e3e0533f	 mvn         r5, #0x3F, 6
  003b4	e1823803	 orr         r3, r2, r3, lsl #16
  003b8	e58130c4	 str         r3, [r1, #0xC4]
  003bc	e5973008	 ldr         r3, [r7, #8]
  003c0	e225ecfe	 eor         lr, r5, #0xFE, 24
  003c4	e59d4008	 ldr         r4, [sp, #8]
  003c8	e583e0d0	 str         lr, [r3, #0xD0]
  003cc	e5963000	 ldr         r3, [r6]
  003d0	e1a02004	 mov         r2, r4
  003d4	e1a01008	 mov         r1, r8
  003d8	e5933018	 ldr         r3, [r3, #0x18]
  003dc	e1a00006	 mov         r0, r6
  003e0	e1a0e00f	 mov         lr, pc
  003e4	e12fff13	 bx          r3
  003e8	e5973008	 ldr         r3, [r7, #8]

; 940  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  003ec	e1a02004	 mov         r2, r4
  003f0	e1a01008	 mov         r1, r8
  003f4	e58300dc	 str         r0, [r3, #0xDC]
  003f8	e5963000	 ldr         r3, [r6]
  003fc	e1a00006	 mov         r0, r6
  00400	e593301c	 ldr         r3, [r3, #0x1C]
  00404	e1a0e00f	 mov         lr, pc
  00408	e12fff13	 bx          r3
  0040c	e5972008	 ldr         r2, [r7, #8]

; 941  :         
; 942  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA0, pSurface->PhysicalAddr(eRotation, bMirror) );

  00410	e3a03000	 mov         r3, #0
  00414	e1a01008	 mov         r1, r8
  00418	e58200d8	 str         r0, [r2, #0xD8]
  0041c	e596e000	 ldr         lr, [r6]
  00420	e1a02004	 mov         r2, r4
  00424	e1a00006	 mov         r0, r6
  00428	e59e4014	 ldr         r4, [lr, #0x14]
  0042c	e1a0e00f	 mov         lr, pc
  00430	e12fff14	 bx          r4
  00434	e5972008	 ldr         r2, [r7, #8]

; 943  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  00438	e3a03000	 mov         r3, #0
  0043c	e1a01008	 mov         r1, r8
  00440	e58200bc	 str         r0, [r2, #0xBC]
  00444	e5960000	 ldr         r0, [r6]
  00448	e59d2008	 ldr         r2, [sp, #8]
  0044c	e5904014	 ldr         r4, [r0, #0x14]
  00450	e1a00006	 mov         r0, r6
  00454	e1a0e00f	 mov         lr, pc
  00458	e12fff14	 bx          r4
  0045c	e5973008	 ldr         r3, [r7, #8]
  00460	e59d500c	 ldr         r5, [sp, #0xC]
  00464	e58300c0	 str         r0, [r3, #0xC0]

; 944  : 
; 945  :         
; 946  :         //  Color conversion coefficients
; 947  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF0, m_pColorSpaceCoeffs[0] );

  00468	e59734a0	 ldr         r3, [r7, #0x4A0]
  0046c	e5972008	 ldr         r2, [r7, #8]
  00470	e5933000	 ldr         r3, [r3]
  00474	e5823130	 str         r3, [r2, #0x130]

; 948  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF1, m_pColorSpaceCoeffs[1] );

  00478	e59734a0	 ldr         r3, [r7, #0x4A0]
  0047c	e5972008	 ldr         r2, [r7, #8]
  00480	e5933004	 ldr         r3, [r3, #4]
  00484	e5823134	 str         r3, [r2, #0x134]

; 949  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF2, m_pColorSpaceCoeffs[2] );

  00488	e59734a0	 ldr         r3, [r7, #0x4A0]
  0048c	e5972008	 ldr         r2, [r7, #8]
  00490	e5933008	 ldr         r3, [r3, #8]
  00494	e5823138	 str         r3, [r2, #0x138]

; 950  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF3, m_pColorSpaceCoeffs[3] );

  00498	e59734a0	 ldr         r3, [r7, #0x4A0]
  0049c	e5972008	 ldr         r2, [r7, #8]
  004a0	e593300c	 ldr         r3, [r3, #0xC]
  004a4	e582313c	 str         r3, [r2, #0x13C]

; 951  :         OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF4, m_pColorSpaceCoeffs[4] );

  004a8	e59734a0	 ldr         r3, [r7, #0x4A0]
  004ac	e5972008	 ldr         r2, [r7, #8]
  004b0	e5933010	 ldr         r3, [r3, #0x10]
  004b4	e5823140	 str         r3, [r2, #0x140]
  004b8		 |$LN2@SetPipelin|

; 952  :     }    
; 953  : 
; 954  : 
; 955  :     //  VIDEO2 pipeline
; 956  :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  004b8	e35b0002	 cmp         r11, #2
  004bc	1a000070	 bne         |$LN1@SetPipelin|

; 957  :     {
; 958  :         //  Set attributes of pipeline
; 959  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES,
; 960  :                     ((eDestination == OMAP_DSS_DESTINATION_TVOUT) ? DISPC_VID_ATTR_VIDCHANNELOUT : 0) |
; 961  :                     dwVidRotation |
; 962  :                     DISPC_VID_ATTR_VIDBURSTSIZE_16x32 |
; 963  :                     DISPC_VID_ATTR_VIDCOLORCONVENABLE |
; 964  :                     DISPC_VID_ATTR_VIDRESIZE_NONE |
; 965  :                     DISPC_VID_ATTR_VIDFORMAT(pSurface->PixelFormat())
; 966  :                     );

  004c0	e5963004	 ldr         r3, [r6, #4]
  004c4	e3550001	 cmp         r5, #1
  004c8	03a00801	 moveq       r0, #1, 16

; 967  : 
; 968  :         //  Size of window; picture size is the same for no scaling
; 969  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.SIZE,
; 970  :                     DISPC_VID_SIZE_VIDSIZEX(pSurface->Width(eRotation)) |
; 971  :                     DISPC_VID_SIZE_VIDSIZEY(pSurface->Height(eRotation))
; 972  :                     );

  004cc	e3833c41	 orr         r3, r3, #0x41, 24
  004d0	13a00000	 movne       r0, #0
  004d4	e5972008	 ldr         r2, [r7, #8]
  004d8	e1803083	 orr         r3, r0, r3, lsl #1
  004dc	e1833009	 orr         r3, r3, r9
  004e0	e582315c	 str         r3, [r2, #0x15C]
  004e4	e5963000	 ldr         r3, [r6]
  004e8	e1a01008	 mov         r1, r8
  004ec	e1a00006	 mov         r0, r6
  004f0	e5933008	 ldr         r3, [r3, #8]
  004f4	e1a0e00f	 mov         lr, pc
  004f8	e12fff13	 bx          r3
  004fc	e5963000	 ldr         r3, [r6]
  00500	e1a04000	 mov         r4, r0
  00504	e1a01008	 mov         r1, r8
  00508	e593300c	 ldr         r3, [r3, #0xC]
  0050c	e1a00006	 mov         r0, r6
  00510	e1a0e00f	 mov         lr, pc
  00514	e12fff13	 bx          r3
  00518	e5971008	 ldr         r1, [r7, #8]
  0051c	e2402001	 sub         r2, r0, #1
  00520	e2443001	 sub         r3, r4, #1
  00524	e1833802	 orr         r3, r3, r2, lsl #16
  00528	e5813158	 str         r3, [r1, #0x158]

; 973  : 
; 974  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.PICTURE_SIZE,
; 975  :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEX(pSurface->Width(eRotation)) |
; 976  :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEY(pSurface->Height(eRotation))
; 977  :                     );

  0052c	e5963000	 ldr         r3, [r6]
  00530	e1a01008	 mov         r1, r8
  00534	e1a00006	 mov         r0, r6
  00538	e5933008	 ldr         r3, [r3, #8]
  0053c	e1a0e00f	 mov         lr, pc
  00540	e12fff13	 bx          r3
  00544	e5963000	 ldr         r3, [r6]
  00548	e1a04000	 mov         r4, r0
  0054c	e1a01008	 mov         r1, r8
  00550	e593300c	 ldr         r3, [r3, #0xC]
  00554	e1a00006	 mov         r0, r6
  00558	e1a0e00f	 mov         lr, pc
  0055c	e12fff13	 bx          r3
  00560	e5971008	 ldr         r1, [r7, #8]
  00564	e2402001	 sub         r2, r0, #1
  00568	e2443001	 sub         r3, r4, #1
  0056c	e1833802	 orr         r3, r3, r2, lsl #16

; 978  : 
; 979  :         //  Position of window
; 980  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.POSITION,
; 981  :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 982  :                     DISPC_VID_POS_VIDPOSY(dwY)
; 983  :                     );

  00570	e59d2004	 ldr         r2, [sp, #4]
  00574	e5813174	 str         r3, [r1, #0x174]
  00578	e59d3000	 ldr         r3, [sp]
  0057c	e5971008	 ldr         r1, [r7, #8]

; 984  :                     
; 985  :         //  Pipeline FIFO and DMA settings
; 986  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD,
; 987  :                     DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 988  :                     DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 989  :                     );
; 990  : 
; 991  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00580	e3e0433f	 mvn         r4, #0x3F, 6
  00584	e1823803	 orr         r3, r2, r3, lsl #16
  00588	e5813154	 str         r3, [r1, #0x154]
  0058c	e5973008	 ldr         r3, [r7, #8]
  00590	e224ecfe	 eor         lr, r4, #0xFE, 24
  00594	e59d9008	 ldr         r9, [sp, #8]
  00598	e583e160	 str         lr, [r3, #0x160]
  0059c	e5963000	 ldr         r3, [r6]
  005a0	e1a02009	 mov         r2, r9
  005a4	e1a01008	 mov         r1, r8
  005a8	e5933018	 ldr         r3, [r3, #0x18]
  005ac	e1a00006	 mov         r0, r6
  005b0	e1a0e00f	 mov         lr, pc
  005b4	e12fff13	 bx          r3
  005b8	e5973008	 ldr         r3, [r7, #8]

; 992  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  005bc	e1a02009	 mov         r2, r9
  005c0	e1a01008	 mov         r1, r8
  005c4	e583016c	 str         r0, [r3, #0x16C]
  005c8	e5963000	 ldr         r3, [r6]
  005cc	e1a00006	 mov         r0, r6
  005d0	e593301c	 ldr         r3, [r3, #0x1C]
  005d4	e1a0e00f	 mov         lr, pc
  005d8	e12fff13	 bx          r3
  005dc	e5971008	 ldr         r1, [r7, #8]

; 993  : 
; 994  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA0, pSurface->PhysicalAddr(eRotation, bMirror) );

  005e0	e3a03000	 mov         r3, #0
  005e4	e1a02009	 mov         r2, r9
  005e8	e5810168	 str         r0, [r1, #0x168]
  005ec	e596e000	 ldr         lr, [r6]
  005f0	e1a01008	 mov         r1, r8
  005f4	e1a00006	 mov         r0, r6
  005f8	e59e4014	 ldr         r4, [lr, #0x14]
  005fc	e1a0e00f	 mov         lr, pc
  00600	e12fff14	 bx          r4
  00604	e5971008	 ldr         r1, [r7, #8]

; 995  :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  00608	e3a03000	 mov         r3, #0
  0060c	e1a02009	 mov         r2, r9
  00610	e581014c	 str         r0, [r1, #0x14C]
  00614	e5960000	 ldr         r0, [r6]
  00618	e1a01008	 mov         r1, r8
  0061c	e5904014	 ldr         r4, [r0, #0x14]
  00620	e1a00006	 mov         r0, r6
  00624	e1a0e00f	 mov         lr, pc
  00628	e12fff14	 bx          r4
  0062c	e5973008	 ldr         r3, [r7, #8]
  00630	e5830150	 str         r0, [r3, #0x150]

; 996  : 
; 997  : 
; 998  : 
; 999  :         //  Color conversion coefficients
; 1000 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF0, m_pColorSpaceCoeffs[0] );

  00634	e59734a0	 ldr         r3, [r7, #0x4A0]
  00638	e5972008	 ldr         r2, [r7, #8]
  0063c	e5933000	 ldr         r3, [r3]
  00640	e58231c0	 str         r3, [r2, #0x1C0]

; 1001 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF1, m_pColorSpaceCoeffs[1] );

  00644	e59734a0	 ldr         r3, [r7, #0x4A0]
  00648	e5972008	 ldr         r2, [r7, #8]
  0064c	e5933004	 ldr         r3, [r3, #4]
  00650	e58231c4	 str         r3, [r2, #0x1C4]

; 1002 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF2, m_pColorSpaceCoeffs[2] );

  00654	e59734a0	 ldr         r3, [r7, #0x4A0]
  00658	e5972008	 ldr         r2, [r7, #8]
  0065c	e5933008	 ldr         r3, [r3, #8]
  00660	e58231c8	 str         r3, [r2, #0x1C8]

; 1003 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF3, m_pColorSpaceCoeffs[3] );

  00664	e59734a0	 ldr         r3, [r7, #0x4A0]
  00668	e5972008	 ldr         r2, [r7, #8]
  0066c	e593300c	 ldr         r3, [r3, #0xC]
  00670	e58231cc	 str         r3, [r2, #0x1CC]

; 1004 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF4, m_pColorSpaceCoeffs[4] );

  00674	e59734a0	 ldr         r3, [r7, #0x4A0]
  00678	e5972008	 ldr         r2, [r7, #8]
  0067c	e5933010	 ldr         r3, [r3, #0x10]
  00680	e58231d0	 str         r3, [r2, #0x1D0]
  00684		 |$LN1@SetPipelin|

; 1005 :     }    
; 1006 : 
; 1007 : 
; 1008 : 
; 1009 :     //  Set mapping of pipeline to destination and surface
; 1010 :     g_rgPipelineMapping[ePipeline].eDestination = eDestination;

  00684	e58a5004	 str         r5, [r10, #4]

; 1011 :     g_rgPipelineMapping[ePipeline].pSurface     = pSurface;

  00688	e58a6008	 str         r6, [r10, #8]

; 1012 :     g_rgPipelineMapping[ePipeline].dwDestWidth  = pSurface->Width(eRotation);

  0068c	e5963000	 ldr         r3, [r6]
  00690	e1a01008	 mov         r1, r8
  00694	e1a00006	 mov         r0, r6
  00698	e5933008	 ldr         r3, [r3, #8]
  0069c	e1a0e00f	 mov         lr, pc
  006a0	e12fff13	 bx          r3
  006a4	e58a0014	 str         r0, [r10, #0x14]

; 1013 :     g_rgPipelineMapping[ePipeline].dwDestHeight = pSurface->Height(eRotation);

  006a8	e5963000	 ldr         r3, [r6]
  006ac	e1a01008	 mov         r1, r8
  006b0	e1a00006	 mov         r0, r6
  006b4	e593300c	 ldr         r3, [r3, #0xC]
  006b8	e1a0e00f	 mov         lr, pc
  006bc	e12fff13	 bx          r3

; 1014 :     g_rgPipelineMapping[ePipeline].pOldSurface  = pSurface;
; 1015 : 
; 1016 :     //  Reset the scaling factors to 100% and no interlacing
; 1017 :     g_rgPipelineScaling[ePipeline].dwHorzScaling = 1;

  006c0	e59f1040	 ldr         r1, [pc, #0x40]
  006c4	e08b208b	 add         r2, r11, r11, lsl #1

; 1018 :     g_rgPipelineScaling[ePipeline].dwVertScaling = 1;
; 1019 :     g_rgPipelineScaling[ePipeline].dwInterlace   = 0;

  006c8	e3a04000	 mov         r4, #0
  006cc	e0813102	 add         r3, r1, r2, lsl #2
  006d0	e3a0e001	 mov         lr, #1
  006d4	e5834008	 str         r4, [r3, #8]

; 1020 :     
; 1021 :     //  Result
; 1022 :     bResult = TRUE;         

  006d8	e3a04001	 mov         r4, #1
  006dc	e583e004	 str         lr, [r3, #4]
  006e0	e58a0018	 str         r0, [r10, #0x18]
  006e4	e58a601c	 str         r6, [r10, #0x1C]
  006e8	e781e102	 str         lr, [r1, +r2, lsl #2]
  006ec		 |$cleanUp$38033|

; 1023 : 
; 1024 : cleanUp:    
; 1025 :     //  Release regs
; 1026 :     ReleaseRegs();

  006ec	e2873b01	 add         r3, r7, #1, 22
  006f0	e283008c	 add         r0, r3, #0x8C
  006f4	eb000000	 bl          LeaveCriticalSection

; 1027 :     
; 1028 :     //  Return result
; 1029 :     return bResult;
; 1030 : }

  006f8	e1a00004	 mov         r0, r4
  006fc	e28dd010	 add         sp, sp, #0x10
  00700	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00704	e12fff1e	 bx          lr
  00708		 |$LN59@SetPipelin|
  00708		 |$LN60@SetPipelin|
  00708	00000000	 DCD         |?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A|
  0070c		 |$LN61@SetPipelin|
  0070c	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00710		 |$M41203|

			 ENDP  ; |?SetPipelineAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@W4OMAP_DSS_DESTINATION@@PAVOMAPSurface@@KK@Z|, OMAPDisplayController::SetPipelineAttribs

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z| ; OMAPDisplayController::SetScalingAttribs
	EXPORT	|??_C@_1JI@NGBENMPF@?$AAS?$AAe?$AAt?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AAA?$AAt?$AAt?$AAr?$AAi?$AAb?$AAs?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg@| [ DATA ] ; `string'
	IMPORT	|LcdPdd_Get_PixClkDiv|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|?g_dwScalingCoeff_Vert_Down_3_Taps@@3PAKA| ; g_dwScalingCoeff_Vert_Down_3_Taps
	IMPORT	|?g_dwScalingCoeff_Vert_Up_3_Taps@@3PAKA| ; g_dwScalingCoeff_Vert_Up_3_Taps
	IMPORT	|?g_dwScalingCoeff_Vert_Down_5_Taps@@3PAKA| ; g_dwScalingCoeff_Vert_Down_5_Taps
	IMPORT	|?g_dwScalingCoeff_Horiz_Up@@3PAKA|	; g_dwScalingCoeff_Horiz_Up
	IMPORT	|?g_dwScalingCoeff_Horiz_Down@@3PAKA|	; g_dwScalingCoeff_Horiz_Down
	IMPORT	|__security_cookie|
	IMPORT	|memset|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T41459| DCD	|$LN229@SetScaling|
	DCD	0xc0043c02

  00000			 AREA	 |.xdata|, DATA
|$T41455| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1JI@NGBENMPF@?$AAS?$AAe?$AAt?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AAA?$AAt?$AAt?$AAr?$AAi?$AAb?$AAs?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg@| DCB "S"
	DCB	0x0, "e", 0x0, "t", 0x0, "S", 0x0, "c", 0x0, "a", 0x0, "l"
	DCB	0x0, "i", 0x0, "n", 0x0, "g", 0x0, "A", 0x0, "t", 0x0, "t"
	DCB	0x0, "r", 0x0, "i", 0x0, "b", 0x0, "s", 0x0, ":", 0x0, " "
	DCB	0x0, "C", 0x0, "a", 0x0, "n", 0x0, "n", 0x0, "o", 0x0, "t"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "f", 0x0, "i"
	DCB	0x0, "g", 0x0, "u", 0x0, "r", 0x0, "e", 0x0, "/", 0x0, "s"
	DCB	0x0, "t", 0x0, "a", 0x0, "r", 0x0, "t", 0x0, " ", 0x0, "I"
	DCB	0x0, "S", 0x0, "P", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "s"
	DCB	0x0, "i", 0x0, "z", 0x0, "e", 0x0, "r", 0x0, ";", 0x0, " "
	DCB	0x0, "C", 0x0, "r", 0x0, "o", 0x0, "p", 0x0, "p", 0x0, "i"
	DCB	0x0, "n", 0x0, "g", 0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e"
	DCB	0x0, " ", 0x0, "i", 0x0, "m", 0x0, "a", 0x0, "g", 0x0, "e"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T41455|

  00008		 |?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z| PROC ; OMAPDisplayController::SetScalingAttribs

; 1128 : {

  00008		 |$LN229@SetScaling|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddf59	 sub         sp, sp, #0x59, 30
  00010		 |$M41456|
  00010	e1a09003	 mov         r9, r3
  00014	e1a0a002	 mov         r10, r2
  00018	e1a06001	 mov         r6, r1
  0001c	e58d905c	 str         r9, [sp, #0x5C]
  00020	e58da050	 str         r10, [sp, #0x50]
  00024	e58d6024	 str         r6, [sp, #0x24]
  00028	e58d0004	 str         r0, [sp, #4]
  0002c	e59f0084	 ldr         r0, [pc, #0x84]
  00030	e5900000	 ldr         r0, [r0]
  00034	e58d0160	 str         r0, [sp, #0x160]

; 1129 :     BOOL                bResult = FALSE;
; 1130 :     OMAPSurface*        pSurface;
; 1131 :     OMAP_DSS_ROTATION   eRotation;
; 1132 :     BOOL                bMirror;
; 1133 :     DWORD   dwSrcWidth,
; 1134 :             dwSrcHeight,
; 1135 :             dwDestWidth,
; 1136 :             dwDestHeight;
; 1137 :     DWORD   dwHorzScale,
; 1138 :             dwVertScale;
; 1139 :     DWORD   dwX, dwY;
; 1140 :     DWORD   dwCurrAttribs;
; 1141 :     DWORD   dwScaleEnable = 0;
; 1142 :     DWORD               dwAccum0 = 0;
; 1143 :     DWORD               dwAccum1 = 0;
; 1144 :     DWORD               dwHorzDecimation = 1;
; 1145 :     DWORD               dwVertDecimation = 1;
; 1146 :     DWORD               dwInterlace = 0;
; 1147 :     DWORD*  pHorizCoeffs = NULL;
; 1148 :     DWORD*  pVertCoeffs = NULL;
; 1149 :     DWORD               dwPixelsPerLine;
; 1150 :     DWORD   i;
; 1151 :     BOOL                bYUVRotated = FALSE;
; 1152 :     DWORD               dwInterlaceCorrection;
; 1153 :     DWORD               dwData1, dwData2;
; 1154 :     DWORD               dwVTaps;
; 1155 :     DWORD               dwFlickerFilter = 0;
; 1156 :     BYTE                Coefficients[5][8];
; 1157 : 
; 1158 :     // Temp array to hold calculated Scaling Coeffs
; 1159 :     DWORD               dwHorizCoeffs[NUM_SCALING_COEFFS];
; 1160 :     DWORD               dwVertCoeffs[NUM_SCALING_COEFFS];
; 1161 :     RECT                privSrcRect = *pSrcRect;
; 1162 :     BOOL                bUseResizer = FALSE;
; 1163 :     
; 1164 :     
; 1165 :     //  Access the regs
; 1166 :     if( AccessRegs() == FALSE )

  00038	e3a03000	 mov         r3, #0
  0003c	e58d3010	 str         r3, [sp, #0x10]
  00040	e3a03000	 mov         r3, #0
  00044	e58d3054	 str         r3, [sp, #0x54]
  00048	e3a03001	 mov         r3, #1
  0004c	e58d3028	 str         r3, [sp, #0x28]
  00050	e59a500c	 ldr         r5, [r10, #0xC]
  00054	e3a03001	 mov         r3, #1
  00058	e58d3014	 str         r3, [sp, #0x14]
  0005c	e3a03000	 mov         r3, #0
  00060	e59a0000	 ldr         r0, [r10]
  00064	e58d3058	 str         r3, [sp, #0x58]
  00068	e59ae004	 ldr         lr, [r10, #4]
  0006c	e59a4008	 ldr         r4, [r10, #8]
  00070	e58d5040	 str         r5, [sp, #0x40]
  00074	e59d5004	 ldr         r5, [sp, #4]
  00078	e3a03000	 mov         r3, #0
  0007c	e58d3048	 str         r3, [sp, #0x48]
  00080	e3a03000	 mov         r3, #0
  00084	e58d0034	 str         r0, [sp, #0x34]
  00088	e3a08000	 mov         r8, #0
  0008c	e1a00005	 mov         r0, r5
  00090	e58d301c	 str         r3, [sp, #0x1C]
  00094	e58de038	 str         lr, [sp, #0x38]
  00098	e58d403c	 str         r4, [sp, #0x3C]
  0009c	e58d8060	 str         r8, [sp, #0x60]
  000a0	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  000a4	e3500000	 cmp         r0, #0
  000a8	0a000400	 beq         |$cleanUp$38236|

; 1167 :         goto cleanUp;
; 1168 : 
; 1169 : 
; 1170 :     //  Get rotation and mirror settings for pipeline output
; 1171 :     pSurface  = g_rgPipelineMapping[ePipeline].pSurface;

  000ac	e59f3000	 ldr         r3, [pc]
  000b0	ea000001	 b           |$LN240@SetScaling|
  000b4		 |$LN241@SetScaling|
  000b4		 |$LN242@SetScaling|
  000b4	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  000b8		 |$LN243@SetScaling|
  000b8	00000000	 DCD         |__security_cookie|
  000bc		 |$LN240@SetScaling|

; 1172 :     eRotation = g_rgPipelineMapping[ePipeline].eRotation;
; 1173 :     bMirror   = g_rgPipelineMapping[ePipeline].bMirror;
; 1174 : 
; 1175 : 
; 1176 :     //  Compute horizontal and vertical scaling factors
; 1177 :     dwSrcWidth  = pSrcRect->right - pSrcRect->left;
; 1178 :     dwSrcHeight = pSrcRect->bottom - pSrcRect->top;
; 1179 : 
; 1180 :     dwDestWidth  = pDestRect->right - pDestRect->left;
; 1181 :     dwDestHeight = pDestRect->bottom - pDestRect->top;
; 1182 : 
; 1183 :     
; 1184 :     //  Check for odd destination RECT values only for YUV pixel formats
; 1185 :     if( (pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_YUV2) ||
; 1186 :         (pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_UYVY) )

  000bc	e599b008	 ldr         r11, [r9, #8]
  000c0	e5992000	 ldr         r2, [r9]
  000c4	e0837286	 add         r7, r3, r6, lsl #5
  000c8	e5976008	 ldr         r6, [r7, #8]
  000cc	e59a4008	 ldr         r4, [r10, #8]
  000d0	e59ae000	 ldr         lr, [r10]
  000d4	e5965004	 ldr         r5, [r6, #4]
  000d8	e59a000c	 ldr         r0, [r10, #0xC]
  000dc	e59a1004	 ldr         r1, [r10, #4]
  000e0	e355000a	 cmp         r5, #0xA
  000e4	e597500c	 ldr         r5, [r7, #0xC]
  000e8	e5993004	 ldr         r3, [r9, #4]
  000ec	e58d6074	 str         r6, [sp, #0x74]
  000f0	e58d5030	 str         r5, [sp, #0x30]
  000f4	e5975010	 ldr         r5, [r7, #0x10]
  000f8	e04b7002	 sub         r7, r11, r2
  000fc	e599200c	 ldr         r2, [r9, #0xC]
  00100	e58d5044	 str         r5, [sp, #0x44]
  00104	e044500e	 sub         r5, r4, lr
  00108	e0404001	 sub         r4, r0, r1
  0010c	e58d400c	 str         r4, [sp, #0xC]
  00110	e042b003	 sub         r11, r2, r3
  00114	0a000002	 beq         |$LN100@SetScaling|
  00118	e5963004	 ldr         r3, [r6, #4]
  0011c	e353000b	 cmp         r3, #0xB
  00120	1a000017	 bne         |$LN96@SetScaling|
  00124		 |$LN100@SetScaling|

; 1187 :     {
; 1188 :         //  Check for odd destination RECT values
; 1189 :         if( (dwDestWidth % 2) == 1 )

  00124	e2073001	 and         r3, r7, #1
  00128	e3530001	 cmp         r3, #1

; 1190 :         {
; 1191 :             pDestRect->right -= 1;

  0012c	05993008	 ldreq       r3, [r9, #8]

; 1192 :             dwDestWidth -= 1;

  00130	02477001	 subeq       r7, r7, #1
  00134	02433001	 subeq       r3, r3, #1
  00138	05893008	 streq       r3, [r9, #8]

; 1193 :         }
; 1194 : 
; 1195 :         if( (dwDestHeight % 2) == 1 )

  0013c	e20b3001	 and         r3, r11, #1
  00140	e3530001	 cmp         r3, #1

; 1196 :         {
; 1197 :             pDestRect->bottom -= 1;

  00144	02423001	 subeq       r3, r2, #1
  00148	0589300c	 streq       r3, [r9, #0xC]

; 1198 :             dwDestHeight -= 1;
; 1199 :         }
; 1200 :         if( (dwSrcWidth % 2) == 1 )

  0014c	e2053001	 and         r3, r5, #1
  00150	024bb001	 subeq       r11, r11, #1
  00154	e3530001	 cmp         r3, #1

; 1201 :         {
; 1202 :             pSrcRect->right -= 1;

  00158	059a3008	 ldreq       r3, [r10, #8]

; 1203 :             dwSrcWidth -= 1;

  0015c	02455001	 subeq       r5, r5, #1
  00160	02433001	 subeq       r3, r3, #1
  00164	058a3008	 streq       r3, [r10, #8]

; 1204 :         }
; 1205 : 
; 1206 :         if( (dwSrcHeight % 2) == 1 )

  00168	e2043001	 and         r3, r4, #1
  0016c	e3530001	 cmp         r3, #1

; 1207 :         {
; 1208 :             pSrcRect->bottom -= 1;

  00170	059a300c	 ldreq       r3, [r10, #0xC]

; 1209 :             dwSrcHeight -= 1;

  00174	02444001	 subeq       r4, r4, #1
  00178	058d400c	 streq       r4, [sp, #0xC]
  0017c	02433001	 subeq       r3, r3, #1
  00180	058a300c	 streq       r3, [r10, #0xC]
  00184		 |$LN96@SetScaling|

; 1210 :         }
; 1211 :     }
; 1212 : 
; 1213 :     //  Compute scaling factors
; 1214 :     dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;

  00184	e1a00007	 mov         r0, r7
  00188	e1a01505	 mov         r1, r5, lsl #10
  0018c	eb000000	 bl          __rt_udiv
  00190	e58d0000	 str         r0, [sp]

; 1215 :     dwVertScale = 1024 * dwSrcHeight / dwDestHeight;

  00194	e1a0000b	 mov         r0, r11
  00198	e1a01504	 mov         r1, r4, lsl #10
  0019c	eb000000	 bl          __rt_udiv

; 1216 : 
; 1217 :     privSrcRect = *pSrcRect;

  001a0	e59ae00c	 ldr         lr, [r10, #0xC]
  001a4	e59a3000	 ldr         r3, [r10]
  001a8	e59a2004	 ldr         r2, [r10, #4]
  001ac	e59a1008	 ldr         r1, [r10, #8]

; 1218 : 
; 1219 : 	if (( g_rgPipelineMapping[ePipeline].eDestination == OMAP_DSS_DESTINATION_LCD ) &&
; 1220 :         (ePipeline != OMAP_DSS_PIPELINE_GFX ))

  001b0	e59faf20	 ldr         r10, [pc, #0xF20]
  001b4	e59d9024	 ldr         r9, [sp, #0x24]
  001b8	e58d3034	 str         r3, [sp, #0x34]
  001bc	e1a03000	 mov         r3, r0
  001c0	e08a4289	 add         r4, r10, r9, lsl #5
  001c4	e5944004	 ldr         r4, [r4, #4]
  001c8	e59d905c	 ldr         r9, [sp, #0x5C]
  001cc	e59da050	 ldr         r10, [sp, #0x50]
  001d0	e58de040	 str         lr, [sp, #0x40]
  001d4	e3540000	 cmp         r4, #0
  001d8	e58d2038	 str         r2, [sp, #0x38]
  001dc	e58d103c	 str         r1, [sp, #0x3C]
  001e0	e58d3018	 str         r3, [sp, #0x18]
  001e4	e3a0e000	 mov         lr, #0
  001e8	1a000042	 bne         |$LN95@SetScaling|
  001ec	e59d3024	 ldr         r3, [sp, #0x24]
  001f0	e3530000	 cmp         r3, #0
  001f4	0a00003f	 beq         |$LN95@SetScaling|

; 1221 :     {
; 1222 : 		if ( m_bDssIspRszEnabled && // is globally enabled
; 1223 :              ((NeedISPResizer(dwHorzScale,dwVertScale,LcdPdd_Get_PixClkDiv()))==TRUE) && // do we need it
; 1224 :              (pSurface->GetRSZHandle(TRUE) != NULL) &&  // can we use it
; 1225 :              (pSurface->UseResizer(TRUE) == TRUE)) // do we have the buffers

  001f8	e59d4004	 ldr         r4, [sp, #4]
  001fc	e5943514	 ldr         r3, [r4, #0x514]
  00200	e3530000	 cmp         r3, #0
  00204	0a000029	 beq         |$LN94@SetScaling|
  00208	eb000000	 bl          LcdPdd_Get_PixClkDiv
  0020c	e59d1018	 ldr         r1, [sp, #0x18]
  00210	e1a02000	 mov         r2, r0
  00214	e59d0000	 ldr         r0, [sp]
  00218	eb000000	 bl          |?NeedISPResizer@@YAHKKK@Z|
  0021c	e3500001	 cmp         r0, #1
  00220	1a000021	 bne         |$LN220@SetScaling|
  00224	e3a01001	 mov         r1, #1
  00228	e1a00006	 mov         r0, r6
  0022c	eb000000	 bl          |?GetRSZHandle@OMAPSurface@@QAAPAXH@Z|
  00230	e3500000	 cmp         r0, #0
  00234	0a00001c	 beq         |$LN220@SetScaling|
  00238	e59630a0	 ldr         r3, [r6, #0xA0]
  0023c	e3530000	 cmp         r3, #0
  00240	0a000016	 beq         |$LN125@SetScaling|
  00244	e3a03001	 mov         r3, #1
  00248	e5863030	 str         r3, [r6, #0x30]

; 1226 : 		{		    
; 1227 : 		    //all check passed
; 1228 :             bUseResizer = TRUE;
; 1229 :             /* Since ISP Resizer would be providing the src image to 
; 1230 :             DSS, make the SRC RECT for DSS same as DEST RECT */
; 1231 :             privSrcRect.left=0;

  0024c	e3a03000	 mov         r3, #0
  00250	e58d3020	 str         r3, [sp, #0x20]

; 1232 :             privSrcRect.right = dwDestWidth;
; 1233 :             privSrcRect.top=0;
; 1234 : 			privSrcRect.bottom = dwDestHeight;			
; 1235 : 			
; 1236 : 			dwSrcWidth  = privSrcRect.right - privSrcRect.left;
; 1237 :             dwSrcHeight = privSrcRect.bottom - privSrcRect.top;
; 1238 :             dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;

  00254	e58d3034	 str         r3, [sp, #0x34]
  00258	e3a03001	 mov         r3, #1
  0025c	e3a02000	 mov         r2, #0
  00260	e1a00007	 mov         r0, r7
  00264	e1a01507	 mov         r1, r7, lsl #10
  00268	e58d301c	 str         r3, [sp, #0x1C]
  0026c	e58d2008	 str         r2, [sp, #8]
  00270	e58d2038	 str         r2, [sp, #0x38]
  00274	e58d703c	 str         r7, [sp, #0x3C]
  00278	e58db040	 str         r11, [sp, #0x40]
  0027c	e1a05007	 mov         r5, r7
  00280	e58db00c	 str         r11, [sp, #0xC]
  00284	eb000000	 bl          __rt_udiv
  00288	e58d0000	 str         r0, [sp]

; 1239 : 			dwVertScale = 1024 * dwSrcHeight / dwDestHeight;            

  0028c	e1a0000b	 mov         r0, r11
  00290	e1a0150b	 mov         r1, r11, lsl #10
  00294	eb000000	 bl          __rt_udiv
  00298	e58d0018	 str         r0, [sp, #0x18]

; 1240 :         } 
; 1241 :         else

  0029c	ea000027	 b           |$LN92@SetScaling|

; 1221 :     {
; 1222 : 		if ( m_bDssIspRszEnabled && // is globally enabled
; 1223 :              ((NeedISPResizer(dwHorzScale,dwVertScale,LcdPdd_Get_PixClkDiv()))==TRUE) && // do we need it
; 1224 :              (pSurface->GetRSZHandle(TRUE) != NULL) &&  // can we use it
; 1225 :              (pSurface->UseResizer(TRUE) == TRUE)) // do we have the buffers

  002a0		 |$LN125@SetScaling|
  002a0	e3a0e000	 mov         lr, #0
  002a4	e586e030	 str         lr, [r6, #0x30]
  002a8	ea000000	 b           |$LN94@SetScaling|
  002ac		 |$LN220@SetScaling|
  002ac	e3a0e000	 mov         lr, #0
  002b0		 |$LN94@SetScaling|

; 1242 :         {
; 1243 :             /* some check did not pass - disable ISP resizer */
; 1244 :             pSurface->SetRSZHandle(NULL,TRUE);

  002b0	e5963034	 ldr         r3, [r6, #0x34]
  002b4	e3530000	 cmp         r3, #0
  002b8	0a000003	 beq         |$LN128@SetScaling|
  002bc	e1a00003	 mov         r0, r3
  002c0	eb000000	 bl          CloseHandle
  002c4	e3a0e000	 mov         lr, #0
  002c8	e586e034	 str         lr, [r6, #0x34]
  002cc		 |$LN128@SetScaling|

; 1245 :             pSurface->UseResizer(FALSE);
; 1246 :             memset(pSurface->ResizeParams(),0,sizeof(RSZParams_t));

  002cc	e3a02064	 mov         r2, #0x64
  002d0	e3a01000	 mov         r1, #0
  002d4	e2860038	 add         r0, r6, #0x38
  002d8	e586e034	 str         lr, [r6, #0x34]
  002dc	e586e030	 str         lr, [r6, #0x30]
  002e0	eb000000	 bl          memset

; 1247 :         }        
; 1248 :     }
; 1249 :     else /* for cases where surfaces are re-assigned to different pipelines */

  002e4	e59d1038	 ldr         r1, [sp, #0x38]
  002e8	e59d2034	 ldr         r2, [sp, #0x34]
  002ec	e58d1008	 str         r1, [sp, #8]
  002f0	e58d2020	 str         r2, [sp, #0x20]
  002f4	ea000011	 b           |$LN92@SetScaling|
  002f8		 |$LN95@SetScaling|

; 1250 :     {
; 1251 :         /* some check did not pass - disable ISP resizer */
; 1252 :         pSurface->SetRSZHandle(NULL,TRUE);

  002f8	e5963034	 ldr         r3, [r6, #0x34]
  002fc	e3530000	 cmp         r3, #0
  00300	0a000003	 beq         |$LN137@SetScaling|
  00304	e1a00003	 mov         r0, r3
  00308	eb000000	 bl          CloseHandle
  0030c	e3a0e000	 mov         lr, #0
  00310	e586e034	 str         lr, [r6, #0x34]
  00314		 |$LN137@SetScaling|

; 1253 :         pSurface->UseResizer(FALSE);
; 1254 :         memset(pSurface->ResizeParams(),0,sizeof(RSZParams_t));

  00314	e3a02064	 mov         r2, #0x64
  00318	e3a01000	 mov         r1, #0
  0031c	e2860038	 add         r0, r6, #0x38
  00320	e586e034	 str         lr, [r6, #0x34]
  00324	e586e030	 str         lr, [r6, #0x30]
  00328	eb000000	 bl          memset
  0032c	e59d3038	 ldr         r3, [sp, #0x38]
  00330	e59d4004	 ldr         r4, [sp, #4]
  00334	e58d3008	 str         r3, [sp, #8]
  00338	e59d3034	 ldr         r3, [sp, #0x34]
  0033c	e58d3020	 str         r3, [sp, #0x20]
  00340		 |$LN92@SetScaling|

; 1255 :     }    
; 1256 :     
; 1257 :     
; 1258 :     if ((eRotation == OMAP_DSS_ROTATION_0)||(eRotation == OMAP_DSS_ROTATION_180))

  00340	e59d3030	 ldr         r3, [sp, #0x30]

; 1259 :         dwPixelsPerLine = GetLCDWidth();
; 1260 :     else
; 1261 :         dwPixelsPerLine = GetLCDHeight();
; 1262 : 
; 1263 :     // Limit the scaling to 1/3rd of the original size
; 1264 :     if ((dwHorzScale > 3072) && (dwSrcWidth > dwPixelsPerLine))

  00344	e3a02c01	 mov         r2, #1, 24
  00348	e382000e	 orr         r0, r2, #0xE
  0034c	e3530000	 cmp         r3, #0
  00350	e59d2000	 ldr         r2, [sp]
  00354	135300b4	 cmpne       r3, #0xB4
  00358	159414ac	 ldrne       r1, [r4, #0x4AC]
  0035c	059414a8	 ldreq       r1, [r4, #0x4A8]
  00360	e3520b03	 cmp         r2, #3, 22
  00364	e58d004c	 str         r0, [sp, #0x4C]
  00368	9a000015	 bls         |$LN88@SetScaling|
  0036c	e1550001	 cmp         r5, r1
  00370	9a000013	 bls         |$LN88@SetScaling|

; 1265 :     {
; 1266 :         // Max scale factor feasible is 1/3rd
; 1267 :         // Based on 1/3rd scale factor, increase the dest rect size
; 1268 :         DWORD dstWidthOffset = 0;
; 1269 :         DWORD newDstWidth    = 0;
; 1270 :         newDstWidth    = dwSrcWidth/3;

  00374	e59f3d78	 ldr         r3, [pc, #0xD78]

; 1271 : 
; 1272 :         // Make sure to set the dst width >= 1/3 x srcwidth
; 1273 :         if (dwSrcWidth%3 != 0)
; 1274 :             newDstWidth += 1;
; 1275 :             
; 1276 :         // Check the size of the new dst width calculated.
; 1277 :         newDstWidth    = (newDstWidth > GetLCDWidth())? GetLCDWidth() : newDstWidth ;
; 1278 : 
; 1279 :         // Divide it equally to the left and right side of the dst window
; 1280 :         dstWidthOffset = (newDstWidth-dwDestWidth)/2;
; 1281 :           
; 1282 :         // adjust the Dest rect based on the new scale factor
; 1283 :         if ((DWORD)pDestRect->left > dstWidthOffset)

  00378	e5990000	 ldr         r0, [r9]
  0037c	e0832395	 umull       r2, r3, r5, r3
  00380	e1a010a3	 mov         r1, r3, lsr #1
  00384	e0813081	 add         r3, r1, r1, lsl #1
  00388	e0553003	 subs        r3, r5, r3
  0038c	e59d5004	 ldr         r5, [sp, #4]
  00390	12811001	 addne       r1, r1, #1
  00394	e59534a8	 ldr         r3, [r5, #0x4A8]
  00398	e1510003	 cmp         r1, r3
  0039c	81a01003	 movhi       r1, r3
  003a0	e0413007	 sub         r3, r1, r7
  003a4	e1a020a3	 mov         r2, r3, lsr #1
  003a8	e1500002	 cmp         r0, r2

; 1284 :             pDestRect->left  -= dstWidthOffset;

  003ac	80403002	 subhi       r3, r0, r2
  003b0	85893000	 strhi       r3, [r9]

; 1285 : 
; 1286 :         pDestRect->right += dstWidthOffset;

  003b4	e5993008	 ldr         r3, [r9, #8]
  003b8	e0833002	 add         r3, r3, r2
  003bc	e5893008	 str         r3, [r9, #8]

; 1287 :     }
; 1288 :     else

  003c0	ea000031	 b           |$LN79@SetScaling|
  003c4		 |$LN88@SetScaling|

; 1289 :     {
; 1290 :         //  If playback is rotated and scaled and color converted, adjust clipping to avoid sync lost
; 1291 :         if( (eRotation == OMAP_DSS_ROTATION_90)||(eRotation == OMAP_DSS_ROTATION_270) )

  003c4	e353005a	 cmp         r3, #0x5A
  003c8	0a000001	 beq         |$LN83@SetScaling|
  003cc	e1530000	 cmp         r3, r0
  003d0	1a00002c	 bne         |$LN215@SetScaling|
  003d4		 |$LN83@SetScaling|

; 1292 :         {
; 1293 :             if( (pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_YUV2) ||
; 1294 :                 (pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_UYVY) )

  003d4	e5963004	 ldr         r3, [r6, #4]
  003d8	e353000a	 cmp         r3, #0xA
  003dc	0a000001	 beq         |$LN81@SetScaling|
  003e0	e353000b	 cmp         r3, #0xB
  003e4	1a000027	 bne         |$LN215@SetScaling|
  003e8		 |$LN81@SetScaling|

; 1295 :             {
; 1296 :                 //  Flag special case of YUV rotated
; 1297 :                 bYUVRotated = TRUE;
; 1298 :                 
; 1299 :                 //  Rotated scaling with color conversion in these bounds has issues
; 1300 :                 if( dwHorzScale > 1536 && dwHorzScale < 2048 )            

  003e8	e3a03c06	 mov         r3, #6, 24
  003ec	e3834001	 orr         r4, r3, #1
  003f0	e3a01c01	 mov         r1, #1, 24
  003f4	e0423004	 sub         r3, r2, r4
  003f8	e38110fe	 orr         r1, r1, #0xFE
  003fc	e1530001	 cmp         r3, r1
  00400	e3a03001	 mov         r3, #1
  00404	e58d3048	 str         r3, [sp, #0x48]
  00408	e58d1000	 str         r1, [sp]
  0040c	8a00000c	 bhi         |$LN80@SetScaling|

; 1301 :                 {
; 1302 :                     DWORD   dwOldSrcWidth = dwSrcWidth;
; 1303 :                     
; 1304 :                     //  Clip src width  
; 1305 :                     dwSrcWidth = dwSrcWidth * 1536 / dwHorzScale;

  00410	e0853085	 add         r3, r5, r5, lsl #1
  00414	e1a01483	 mov         r1, r3, lsl #9
  00418	e1a00002	 mov         r0, r2
  0041c	eb000000	 bl          __rt_udiv

; 1306 :                     dwSrcWidth = ((dwSrcWidth % 2) == 0) ? dwSrcWidth : dwSrcWidth - 1;

  00420	e3100001	 tst         r0, #1

; 1307 :                     privSrcRect.left  = privSrcRect.left + (dwOldSrcWidth - dwSrcWidth)/2;

  00424	e59d2020	 ldr         r2, [sp, #0x20]
  00428	12400001	 subne       r0, r0, #1
  0042c	e0453000	 sub         r3, r5, r0
  00430	e08230a3	 add         r3, r2, r3, lsr #1
  00434	e58d3034	 str         r3, [sp, #0x34]

; 1308 :                     privSrcRect.right = privSrcRect.left + dwSrcWidth;

  00438	e0833000	 add         r3, r3, r0
  0043c	e59d1000	 ldr         r1, [sp]
  00440	e58d303c	 str         r3, [sp, #0x3C]
  00444		 |$LN80@SetScaling|

; 1309 :                 }
; 1310 :             
; 1311 :                 //  Rotated scaling with color conversion in these bounds has issues
; 1312 :                 if( dwVertScale > 1536 && dwVertScale < 2048 )            

  00444	e59d2018	 ldr         r2, [sp, #0x18]
  00448	e0423004	 sub         r3, r2, r4
  0044c	e1530001	 cmp         r3, r1
  00450	8a00000c	 bhi         |$LN215@SetScaling|

; 1313 :                 {
; 1314 :                     DWORD   dwOldSrcHeight = dwSrcHeight;
; 1315 :                     
; 1316 :                     //  Clip src height  
; 1317 :                     dwSrcHeight = dwSrcHeight * 1536 / dwVertScale;

  00454	e59d400c	 ldr         r4, [sp, #0xC]
  00458	e1a00002	 mov         r0, r2
  0045c	e0843084	 add         r3, r4, r4, lsl #1
  00460	e1a01483	 mov         r1, r3, lsl #9
  00464	eb000000	 bl          __rt_udiv

; 1318 :                     dwSrcHeight = ((dwSrcHeight % 2) == 0) ? dwSrcHeight : dwSrcHeight - 1;

  00468	e3100001	 tst         r0, #1

; 1319 :                     privSrcRect.top    = privSrcRect.top + (dwOldSrcHeight - dwSrcHeight)/2;

  0046c	e59d2008	 ldr         r2, [sp, #8]
  00470	12400001	 subne       r0, r0, #1
  00474	e0443000	 sub         r3, r4, r0
  00478	e08230a3	 add         r3, r2, r3, lsr #1
  0047c	e58d3038	 str         r3, [sp, #0x38]

; 1320 :                     privSrcRect.bottom = privSrcRect.top + dwSrcHeight;

  00480	e0833000	 add         r3, r3, r0
  00484	e58d3040	 str         r3, [sp, #0x40]
  00488		 |$LN215@SetScaling|

; 1847 :         }
; 1848 :         else
; 1849 :         {
; 1850 :             //No scale
; 1851 :         }
; 1852 : 
; 1853 :         //  Accum0/1 controls the scaler phase for the even/odd fields
; 1854 :         if (m_dwTVFilterLevel == OMAP_TV_FILTER_LEVEL_OFF)

  00488	e59d5004	 ldr         r5, [sp, #4]

; 1320 :                     privSrcRect.bottom = privSrcRect.top + dwSrcHeight;

  0048c		 |$LN79@SetScaling|

; 1321 :                 }
; 1322 :             }
; 1323 :         }
; 1324 :     }
; 1325 : 
; 1326 :     if (!bUseResizer)

  0048c	e59d301c	 ldr         r3, [sp, #0x1C]

; 1327 :         //  Set the clipping region for the surface
; 1328 :         g_rgPipelineMapping[ePipeline].pSurface->SetClipping( &privSrcRect);

  00490	e59d2024	 ldr         r2, [sp, #0x24]
  00494	e3530000	 cmp         r3, #0
  00498	e59f3c38	 ldr         r3, [pc, #0xC38]
  0049c	e0834282	 add         r4, r3, r2, lsl #5
  004a0	e5940008	 ldr         r0, [r4, #8]
  004a4	1a000005	 bne         |$LN78@SetScaling|
  004a8	e5903000	 ldr         r3, [r0]
  004ac	e28d1034	 add         r1, sp, #0x34
  004b0	e5933020	 ldr         r3, [r3, #0x20]
  004b4	e1a0e00f	 mov         lr, pc
  004b8	e12fff13	 bx          r3

; 1329 :     else

  004bc	ea000011	 b           |$LN77@SetScaling|
  004c0		 |$LN78@SetScaling|

; 1330 :     {
; 1331 :         RECT rszRect;
; 1332 :         rszRect.top = 0;
; 1333 :         rszRect.left = 0;
; 1334 :         rszRect.bottom = rszRect.top + dwDestHeight;
; 1335 :         rszRect.right = rszRect.left + dwDestWidth;        
; 1336 :         g_rgPipelineMapping[ePipeline].pSurface->SetClipping( pSrcRect);

  004c0	e3a03000	 mov         r3, #0
  004c4	e3a02000	 mov         r2, #0
  004c8	e58d3068	 str         r3, [sp, #0x68]
  004cc	e58d2064	 str         r2, [sp, #0x64]
  004d0	e58db070	 str         r11, [sp, #0x70]
  004d4	e58d706c	 str         r7, [sp, #0x6C]
  004d8	e5903000	 ldr         r3, [r0]
  004dc	e1a0100a	 mov         r1, r10
  004e0	e5933020	 ldr         r3, [r3, #0x20]
  004e4	e1a0e00f	 mov         lr, pc
  004e8	e12fff13	 bx          r3

; 1337 :         g_rgPipelineMapping[ePipeline].pSurface->OmapAssocSurface()->SetClipping( &rszRect );

  004ec	e5943008	 ldr         r3, [r4, #8]
  004f0	e28d1064	 add         r1, sp, #0x64
  004f4	e59300a0	 ldr         r0, [r3, #0xA0]
  004f8	e5903000	 ldr         r3, [r0]
  004fc	e5933020	 ldr         r3, [r3, #0x20]
  00500	e1a0e00f	 mov         lr, pc
  00504	e12fff13	 bx          r3
  00508		 |$LN77@SetScaling|

; 1338 :     }
; 1339 : 
; 1340 :     //  Compute src and dest width/height
; 1341 :     dwSrcWidth  = privSrcRect.right - privSrcRect.left;
; 1342 :     dwSrcHeight = privSrcRect.bottom - privSrcRect.top;
; 1343 : 
; 1344 :     dwDestWidth  = pDestRect->right - pDestRect->left;
; 1345 :     dwDestHeight = pDestRect->bottom - pDestRect->top;
; 1346 : 
; 1347 :     //  Swap src width/height based on pipeline rotation angle
; 1348 :     switch( g_rgPipelineMapping[ePipeline].eRotation )

  00508	e594400c	 ldr         r4, [r4, #0xC]
  0050c	e59d0038	 ldr         r0, [sp, #0x38]
  00510	e59d1034	 ldr         r1, [sp, #0x34]
  00514	e58d4000	 str         r4, [sp]
  00518	e59d4040	 ldr         r4, [sp, #0x40]
  0051c	e59d703c	 ldr         r7, [sp, #0x3C]
  00520	e599e004	 ldr         lr, [r9, #4]
  00524	e599300c	 ldr         r3, [r9, #0xC]
  00528	e5992008	 ldr         r2, [r9, #8]
  0052c	e0444000	 sub         r4, r4, r0
  00530	e5990000	 ldr         r0, [r9]
  00534	e047b001	 sub         r11, r7, r1
  00538	e043700e	 sub         r7, r3, lr
  0053c	e59d3000	 ldr         r3, [sp]
  00540	e0421000	 sub         r1, r2, r0
  00544	e59d204c	 ldr         r2, [sp, #0x4C]
  00548	e58d100c	 str         r1, [sp, #0xC]
  0054c	e58de02c	 str         lr, [sp, #0x2C]
  00550	e58d401c	 str         r4, [sp, #0x1C]
  00554	e58d7018	 str         r7, [sp, #0x18]
  00558	e353005a	 cmp         r3, #0x5A
  0055c	0a000001	 beq         |$LN74@SetScaling|
  00560	e1530002	 cmp         r3, r2
  00564	1a000003	 bne         |$LN75@SetScaling|
  00568		 |$LN74@SetScaling|

; 1349 :     {
; 1350 :         case OMAP_DSS_ROTATION_90:
; 1351 :             //  Settings for rotation angle 90
; 1352 :             i = dwSrcWidth;

  00568	e1a0300b	 mov         r3, r11

; 1353 :             dwSrcWidth = dwSrcHeight;

  0056c	e1a0b004	 mov         r11, r4

; 1354 :             dwSrcHeight = i;

  00570	e1a04003	 mov         r4, r3
  00574	e58d401c	 str         r4, [sp, #0x1C]
  00578		 |$LN75@SetScaling|

; 1355 :             break;
; 1356 : 
; 1357 :         case OMAP_DSS_ROTATION_270:
; 1358 :             //  Settings for rotation angle 270
; 1359 :             i = dwSrcWidth;
; 1360 :             dwSrcWidth = dwSrcHeight;
; 1361 :             dwSrcHeight = i;
; 1362 :             break;
; 1363 :     }
; 1364 : 
; 1365 :     //  Default origin
; 1366 :     dwX = pDestRect->left;
; 1367 :     dwY = pDestRect->top;
; 1368 : 
; 1369 : 
; 1370 :     //------------------------------------------------------------------------------
; 1371 :     //  Configure the scaling of the pipeline for LCD display
; 1372 :     //
; 1373 :     if( g_rgPipelineMapping[ePipeline].eDestination == OMAP_DSS_DESTINATION_LCD )

  00578	e59fab58	 ldr         r10, [pc, #0xB58]
  0057c	e59d9024	 ldr         r9, [sp, #0x24]
  00580	e58d0020	 str         r0, [sp, #0x20]
  00584	e08a3289	 add         r3, r10, r9, lsl #5
  00588	e5933004	 ldr         r3, [r3, #4]
  0058c	e59d905c	 ldr         r9, [sp, #0x5C]
  00590	e59da050	 ldr         r10, [sp, #0x50]
  00594	e3530000	 cmp         r3, #0
  00598	1a0000ea	 bne         |$LN72@SetScaling|

; 1374 :     {
; 1375 :         //  Compute new origin and swap destination width/height based on GFX pipeline rotation angle
; 1376 :         switch( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].eRotation )

  0059c	e59f3b34	 ldr         r3, [pc, #0xB34]
  005a0	e593300c	 ldr         r3, [r3, #0xC]
  005a4	e3530000	 cmp         r3, #0
  005a8	0a000022	 beq         |$LN69@SetScaling|
  005ac	e353005a	 cmp         r3, #0x5A
  005b0	0a000015	 beq         |$LN68@SetScaling|
  005b4	e35300b4	 cmp         r3, #0xB4
  005b8	0a00000b	 beq         |$LN67@SetScaling|
  005bc	e1530002	 cmp         r3, r2
  005c0	1a00001f	 bne         |$LN70@SetScaling|

; 1399 : 
; 1400 :             case OMAP_DSS_ROTATION_270:
; 1401 :                 //  Settings for rotation angle 270
; 1402 :                 dwX = GetLCDWidth() - dwDestHeight - pDestRect->top;

  005c4	e59534a8	 ldr         r3, [r5, #0x4A8]

; 1403 :                 dwY = pDestRect->left;
; 1404 : 
; 1405 :                 i = dwDestWidth;

  005c8	e1a02001	 mov         r2, r1

; 1406 :                 dwDestWidth = dwDestHeight;

  005cc	e1a01007	 mov         r1, r7
  005d0	e043300e	 sub         r3, r3, lr
  005d4	e0433007	 sub         r3, r3, r7

; 1407 :                 dwDestHeight = i;

  005d8	e1a07002	 mov         r7, r2
  005dc	e58d7018	 str         r7, [sp, #0x18]
  005e0	e58d100c	 str         r1, [sp, #0xC]
  005e4	e58d002c	 str         r0, [sp, #0x2C]

; 1408 :                 break;

  005e8	ea000014	 b           |$LN221@SetScaling|
  005ec		 |$LN67@SetScaling|

; 1393 : 
; 1394 :             case OMAP_DSS_ROTATION_180:
; 1395 :                 //  Settings for rotation angle 180
; 1396 :                 dwX = GetLCDWidth() - dwDestWidth - pDestRect->left;
; 1397 :                 dwY = GetLCDHeight() - dwDestHeight - pDestRect->top;

  005ec	e59524ac	 ldr         r2, [r5, #0x4AC]
  005f0	e59534a8	 ldr         r3, [r5, #0x4A8]
  005f4	e042200e	 sub         r2, r2, lr
  005f8	e0428007	 sub         r8, r2, r7
  005fc	e0433000	 sub         r3, r3, r0
  00600	e58d802c	 str         r8, [sp, #0x2C]
  00604	e0433001	 sub         r3, r3, r1

; 1398 :                 break;

  00608	ea00000c	 b           |$LN221@SetScaling|
  0060c		 |$LN68@SetScaling|

; 1382 :                 break;
; 1383 : 
; 1384 :             case OMAP_DSS_ROTATION_90:
; 1385 :                 //  Settings for rotation angle 90
; 1386 :                 dwX = pDestRect->top;
; 1387 :                 dwY = GetLCDHeight() - dwDestWidth - pDestRect->left;

  0060c	e59534ac	 ldr         r3, [r5, #0x4AC]

; 1388 : 
; 1389 :                 i = dwDestWidth;

  00610	e1a02001	 mov         r2, r1
  00614	e58de020	 str         lr, [sp, #0x20]
  00618	e0433000	 sub         r3, r3, r0
  0061c	e0433001	 sub         r3, r3, r1

; 1390 :                 dwDestWidth = dwDestHeight;

  00620	e1a01007	 mov         r1, r7

; 1391 :                 dwDestHeight = i;

  00624	e1a07002	 mov         r7, r2
  00628	e58d7018	 str         r7, [sp, #0x18]
  0062c	e58d302c	 str         r3, [sp, #0x2C]
  00630	e58d100c	 str         r1, [sp, #0xC]

; 1392 :                 break;

  00634	ea000002	 b           |$LN70@SetScaling|
  00638		 |$LN69@SetScaling|

; 1377 :         {
; 1378 :             case OMAP_DSS_ROTATION_0:
; 1379 :                 //  Settings for rotation angle 0
; 1380 :                 dwX = pDestRect->left;

  00638	e1a03000	 mov         r3, r0

; 1381 :                 dwY = pDestRect->top;

  0063c	e58de02c	 str         lr, [sp, #0x2C]
  00640		 |$LN221@SetScaling|

; 1377 :         {
; 1378 :             case OMAP_DSS_ROTATION_0:
; 1379 :                 //  Settings for rotation angle 0
; 1380 :                 dwX = pDestRect->left;

  00640	e58d3020	 str         r3, [sp, #0x20]

; 1381 :                 dwY = pDestRect->top;

  00644		 |$LN70@SetScaling|

; 1409 :         }
; 1410 :     
; 1411 : 
; 1412 :         //  Compute horizontal and vertical scaling factors
; 1413 :         dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;

  00644	e1a00001	 mov         r0, r1
  00648	e1a0150b	 mov         r1, r11, lsl #10
  0064c	eb000000	 bl          __rt_udiv
  00650	e1a08000	 mov         r8, r0

; 1414 :         dwVertScale = 1024 * dwSrcHeight / dwDestHeight;

  00654	e1a00007	 mov         r0, r7
  00658	e1a01504	 mov         r1, r4, lsl #10
  0065c	eb000000	 bl          __rt_udiv

; 1415 : 
; 1416 :         //  Determine if scaling is within HW scaling capabilities
; 1417 :         //  If not, use surface scaling factor to decimate the source surface
; 1418 :         //  by 2, 4 or 8
; 1419 :         if( bYUVRotated )

  00660	e59d3048	 ldr         r3, [sp, #0x48]
  00664	e3530000	 cmp         r3, #0
  00668	0a000012	 beq         |$LN65@SetScaling|

; 1420 :         {
; 1421 :             if( dwHorzScale >= 2048 )

  0066c	e3580b02	 cmp         r8, #2, 22

; 1422 :                 dwHorzDecimation = 2;

  00670	23a02002	 movcs       r2, #2
  00674	258d2028	 strcs       r2, [sp, #0x28]

; 1443 :                 dwHorzDecimation = 2;

  00678	33a02001	 movcc       r2, #1
  0067c	e3580a01	 cmp         r8, #1, 20
  00680	23a02004	 movcs       r2, #4
  00684	258d2028	 strcs       r2, [sp, #0x28]
  00688	e3580a02	 cmp         r8, #2, 20
  0068c	23a02008	 movcs       r2, #8
  00690	258d2028	 strcs       r2, [sp, #0x28]
  00694	e3500b02	 cmp         r0, #2, 22
  00698	23a03002	 movcs       r3, #2
  0069c	258d3014	 strcs       r3, [sp, #0x14]
  006a0	e3500a01	 cmp         r0, #1, 20
  006a4	23a03004	 movcs       r3, #4
  006a8	258d3014	 strcs       r3, [sp, #0x14]
  006ac	e3500a02	 cmp         r0, #2, 20
  006b0	3a000011	 bcc         |$LN53@SetScaling|

; 1423 : 
; 1424 :             if( dwHorzScale >= 4096 )
; 1425 :                 dwHorzDecimation = 4;
; 1426 : 
; 1427 :             if( dwHorzScale >= 8192 )
; 1428 :                 dwHorzDecimation = 8;
; 1429 : 
; 1430 : 
; 1431 :             if( dwVertScale >= 2048 )
; 1432 :                 dwVertDecimation = 2;
; 1433 : 
; 1434 :             if( dwVertScale >= 4096 )
; 1435 :                 dwVertDecimation = 4;
; 1436 : 
; 1437 :             if( dwVertScale >= 8192 )
; 1438 :                 dwVertDecimation = 8;
; 1439 :         }
; 1440 :         else

  006b4	ea00000e	 b           |$LN222@SetScaling|
  006b8		 |$LN65@SetScaling|

; 1441 :         {
; 1442 :             if( dwHorzScale > 4096 )

  006b8	e3580a01	 cmp         r8, #1, 20

; 1443 :                 dwHorzDecimation = 2;

  006bc	83a02002	 movhi       r2, #2
  006c0	858d2028	 strhi       r2, [sp, #0x28]

; 1444 : 
; 1445 :             if( dwHorzScale > 8192 )
; 1446 :                 dwHorzDecimation = 4;

  006c4	93a02001	 movls       r2, #1
  006c8	e3580a02	 cmp         r8, #2, 20
  006cc	83a02004	 movhi       r2, #4
  006d0	858d2028	 strhi       r2, [sp, #0x28]

; 1447 : 
; 1448 : 
; 1449 :             if( dwVertScale > 2048 )

  006d4	e3500b02	 cmp         r0, #2, 22

; 1450 :                 dwVertDecimation = 2;

  006d8	83a03002	 movhi       r3, #2
  006dc	858d3014	 strhi       r3, [sp, #0x14]

; 1451 : 
; 1452 :             if( dwVertScale > 4096 )

  006e0	e3500a01	 cmp         r0, #1, 20

; 1453 :                 dwVertDecimation = 4;

  006e4	83a03004	 movhi       r3, #4
  006e8	858d3014	 strhi       r3, [sp, #0x14]

; 1454 : 
; 1455 :             if( dwVertScale > 8192 )

  006ec	e3500a02	 cmp         r0, #2, 20
  006f0	9a000001	 bls         |$LN53@SetScaling|
  006f4		 |$LN222@SetScaling|

; 1456 :                 dwVertDecimation = 8;

  006f4	e3a03008	 mov         r3, #8
  006f8	e58d3014	 str         r3, [sp, #0x14]
  006fc		 |$LN53@SetScaling|

; 1457 :         }
; 1458 : 
; 1459 :             
; 1460 :         //  Adjust the HW scaling factors by the decimation factor      
; 1461 :         dwHorzScale = 1024 * (dwSrcWidth/dwHorzDecimation) / dwDestWidth;    

  006fc	e1a00002	 mov         r0, r2
  00700	e1a0100b	 mov         r1, r11
  00704	eb000000	 bl          __rt_udiv
  00708	e59d800c	 ldr         r8, [sp, #0xC]
  0070c	e1a0b000	 mov         r11, r0
  00710	e1a0150b	 mov         r1, r11, lsl #10
  00714	e1a00008	 mov         r0, r8
  00718	eb000000	 bl          __rt_udiv
  0071c	e58d0008	 str         r0, [sp, #8]

; 1462 :         dwVertScale = 1024 * (dwSrcHeight/dwVertDecimation) / dwDestHeight;    

  00720	e59d0014	 ldr         r0, [sp, #0x14]
  00724	e1a01004	 mov         r1, r4
  00728	eb000000	 bl          __rt_udiv
  0072c	e1a04000	 mov         r4, r0
  00730	e1a01504	 mov         r1, r4, lsl #10
  00734	e1a00007	 mov         r0, r7
  00738	e58d401c	 str         r4, [sp, #0x1C]
  0073c	eb000000	 bl          __rt_udiv

; 1463 :         
; 1464 :         
; 1465 :         //  Set the decimation factors for the surface 
; 1466 :         switch( eRotation )

  00740	e59d3030	 ldr         r3, [sp, #0x30]
  00744	e1a02000	 mov         r2, r0
  00748	e58d2010	 str         r2, [sp, #0x10]
  0074c	e3530000	 cmp         r3, #0
  00750	0a000013	 beq         |$LN50@SetScaling|
  00754	e353005a	 cmp         r3, #0x5A
  00758	0a000004	 beq         |$LN49@SetScaling|
  0075c	e35300b4	 cmp         r3, #0xB4
  00760	0a00000f	 beq         |$LN50@SetScaling|
  00764	e59d104c	 ldr         r1, [sp, #0x4C]
  00768	e1530001	 cmp         r3, r1
  0076c	1a000019	 bne         |$LN218@SetScaling|
  00770		 |$LN49@SetScaling|

; 1473 :                 break;
; 1474 : 
; 1475 :             case OMAP_DSS_ROTATION_90:
; 1476 :             case OMAP_DSS_ROTATION_270:            
; 1477 :                 //  Rotated orientation
; 1478 :                 pSurface->SetHorizontalScaling( dwVertDecimation );

  00770	e5963000	 ldr         r3, [r6]
  00774	e59d1014	 ldr         r1, [sp, #0x14]
  00778	e1a00006	 mov         r0, r6
  0077c	e5933030	 ldr         r3, [r3, #0x30]
  00780	e1a0e00f	 mov         lr, pc
  00784	e12fff13	 bx          r3

; 1479 :                 pSurface->SetVerticalScaling( dwHorzDecimation );

  00788	e5963000	 ldr         r3, [r6]
  0078c	e59d1028	 ldr         r1, [sp, #0x28]
  00790	e1a00006	 mov         r0, r6
  00794	e5933034	 ldr         r3, [r3, #0x34]
  00798	e1a0e00f	 mov         lr, pc
  0079c	e12fff13	 bx          r3

; 1480 :                 break;

  007a0	ea00000b	 b           |$LN226@SetScaling|
  007a4		 |$LN50@SetScaling|

; 1467 :         {
; 1468 :             case OMAP_DSS_ROTATION_0:
; 1469 :             case OMAP_DSS_ROTATION_180:            
; 1470 :                 //  Standard orientation
; 1471 :                 pSurface->SetHorizontalScaling( dwHorzDecimation );

  007a4	e5963000	 ldr         r3, [r6]
  007a8	e59d1028	 ldr         r1, [sp, #0x28]
  007ac	e1a00006	 mov         r0, r6
  007b0	e5933030	 ldr         r3, [r3, #0x30]
  007b4	e1a0e00f	 mov         lr, pc
  007b8	e12fff13	 bx          r3

; 1472 :                 pSurface->SetVerticalScaling( dwVertDecimation );

  007bc	e5963000	 ldr         r3, [r6]
  007c0	e59d1014	 ldr         r1, [sp, #0x14]
  007c4	e1a00006	 mov         r0, r6
  007c8	e5933034	 ldr         r3, [r3, #0x34]
  007cc	e1a0e00f	 mov         lr, pc
  007d0	e12fff13	 bx          r3
  007d4		 |$LN226@SetScaling|

; 1521 :             dwVertScale = 1024 * dwSrcHeight / dwDestHeight;

  007d4	e59d2010	 ldr         r2, [sp, #0x10]
  007d8		 |$LN218@SetScaling|

; 1481 :         }
; 1482 :         
; 1483 :         //  Adjust the source width and height by the decimation factor
; 1484 :         dwSrcWidth  = dwSrcWidth / dwHorzDecimation;
; 1485 :         dwSrcHeight = dwSrcHeight / dwVertDecimation;
; 1486 : 
; 1487 : 
; 1488 :         //  If YUV rotated, check for any odd width or height values due to decimation
; 1489 :         if( bYUVRotated )

  007d8	e59d3048	 ldr         r3, [sp, #0x48]
  007dc	e59d1040	 ldr         r1, [sp, #0x40]
  007e0	e59d003c	 ldr         r0, [sp, #0x3C]
  007e4	e3530000	 cmp         r3, #0
  007e8	0a000037	 beq         |$LN48@SetScaling|

; 1490 :         {
; 1491 :             if( (dwSrcWidth % 2) == 1 )

  007ec	e20b3001	 and         r3, r11, #1
  007f0	e3530001	 cmp         r3, #1

; 1492 :             {
; 1493 :                 dwSrcWidth -= 1;
; 1494 :                 
; 1495 :                 //  Adjust clipping; note rotation means adjust clipping height here
; 1496 :                 privSrcRect.bottom -= dwHorzDecimation;

  007f4	059d3028	 ldreq       r3, [sp, #0x28]
  007f8	024bb001	 subeq       r11, r11, #1

; 1497 :             }
; 1498 : 
; 1499 :             if( (dwSrcHeight % 2) == 1 )
; 1500 :             {
; 1501 :                 dwSrcHeight -= 1;
; 1502 : 
; 1503 :                 //  Adjust clipping; note rotation means adjust clipping width here
; 1504 :                 privSrcRect.right -= dwVertDecimation;
; 1505 :             }
; 1506 : 
; 1507 :             //  Set the clipping region for the surface
; 1508 :             g_rgPipelineMapping[ePipeline].pSurface->SetClipping( &privSrcRect );

  007fc	e59f28d4	 ldr         r2, [pc, #0x8D4]
  00800	00413003	 subeq       r3, r1, r3
  00804	058d3040	 streq       r3, [sp, #0x40]
  00808	e2043001	 and         r3, r4, #1
  0080c	e3530001	 cmp         r3, #1
  00810	059d3014	 ldreq       r3, [sp, #0x14]
  00814	e59d1024	 ldr         r1, [sp, #0x24]
  00818	02444001	 subeq       r4, r4, #1
  0081c	00403003	 subeq       r3, r0, r3
  00820	058d303c	 streq       r3, [sp, #0x3C]
  00824	e0823281	 add         r3, r2, r1, lsl #5
  00828	e5930008	 ldr         r0, [r3, #8]
  0082c	058d401c	 streq       r4, [sp, #0x1C]
  00830	e28d1034	 add         r1, sp, #0x34
  00834	e5903000	 ldr         r3, [r0]
  00838	e5933020	 ldr         r3, [r3, #0x20]
  0083c	e1a0e00f	 mov         lr, pc
  00840	e12fff13	 bx          r3

; 1509 :             if (g_rgPipelineMapping[ePipeline].pSurface->OmapAssocSurface())

  00844	e59f288c	 ldr         r2, [pc, #0x88C]
  00848	e59d1024	 ldr         r1, [sp, #0x24]
  0084c	e0823281	 add         r3, r2, r1, lsl #5
  00850	e593e008	 ldr         lr, [r3, #8]
  00854	e59e30a0	 ldr         r3, [lr, #0xA0]
  00858	e3530000	 cmp         r3, #0
  0085c	0a000011	 beq         |$LN45@SetScaling|

; 1510 :             {
; 1511 :                 RECT rszRect;
; 1512 :                 rszRect.top = 0;
; 1513 :                 rszRect.left = 0;
; 1514 :                 rszRect.bottom = rszRect.top + (pDestRect->bottom - pDestRect->top);

  00860	e599100c	 ldr         r1, [r9, #0xC]
  00864	e5993004	 ldr         r3, [r9, #4]

; 1515 :                 rszRect.right = rszRect.left + (pDestRect->right - pDestRect->left);                            

  00868	e5990008	 ldr         r0, [r9, #8]
  0086c	e5992000	 ldr         r2, [r9]
  00870	e0411003	 sub         r1, r1, r3
  00874	e58d1070	 str         r1, [sp, #0x70]
  00878	e0403002	 sub         r3, r0, r2
  0087c	e58d306c	 str         r3, [sp, #0x6C]
  00880	e3a03000	 mov         r3, #0
  00884	e3a02000	 mov         r2, #0
  00888	e58d3068	 str         r3, [sp, #0x68]
  0088c	e58d2064	 str         r2, [sp, #0x64]

; 1516 :                 g_rgPipelineMapping[ePipeline].pSurface->OmapAssocSurface()->SetClipping( &rszRect );

  00890	e59e00a0	 ldr         r0, [lr, #0xA0]
  00894	e28d1064	 add         r1, sp, #0x64
  00898	e5903000	 ldr         r3, [r0]
  0089c	e5933020	 ldr         r3, [r3, #0x20]
  008a0	e1a0e00f	 mov         lr, pc
  008a4	e12fff13	 bx          r3
  008a8		 |$LN45@SetScaling|

; 1517 :             }                
; 1518 : 
; 1519 :             //  Recalculate the scale factors to account for adjustments made
; 1520 :             dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;

  008a8	e1a00008	 mov         r0, r8
  008ac	e1a0150b	 mov         r1, r11, lsl #10
  008b0	eb000000	 bl          __rt_udiv
  008b4	e58d0008	 str         r0, [sp, #8]

; 1521 :             dwVertScale = 1024 * dwSrcHeight / dwDestHeight;

  008b8	e1a00007	 mov         r0, r7
  008bc	e1a01504	 mov         r1, r4, lsl #10
  008c0	eb000000	 bl          __rt_udiv
  008c4	e1a02000	 mov         r2, r0
  008c8	e58d2010	 str         r2, [sp, #0x10]
  008cc		 |$LN48@SetScaling|

; 1522 :         } 
; 1523 : 
; 1524 : 
; 1525 :         //  Based on scaling factor, determine which coeffs to use and if to enable scaling
; 1526 :         dwScaleEnable |= (dwHorzScale == 1024) ? 0 : DISPC_VID_ATTR_VIDRESIZE_HORIZONTAL;

  008cc	e59d4008	 ldr         r4, [sp, #8]
  008d0	e3540b01	 cmp         r4, #1, 22
  008d4	03a01000	 moveq       r1, #0
  008d8	13a01020	 movne       r1, #0x20

; 1527 :         dwScaleEnable |= (dwVertScale == 1024) ? 0 : DISPC_VID_ATTR_VIDRESIZE_VERTICAL;

  008dc	e3520b01	 cmp         r2, #1, 22
  008e0	03a03000	 moveq       r3, #0
  008e4	13a03040	 movne       r3, #0x40

; 1528 : 
; 1529 : 
; 1530 :         //  Horizontal scaling
; 1531 :         if( dwHorzScale > 1024 )

  008e8	e3540b01	 cmp         r4, #1, 22
  008ec	e1838001	 orr         r8, r3, r1

; 1532 :         {
; 1533 :             //  Use down-sampling horizontal coeffs
; 1534 :             dwScaleEnable |= DISPC_VID_ATTR_VIDHRESIZE_CONF_DOWN;
; 1535 :             pHorizCoeffs = g_dwScalingCoeff_Horiz_Down;

  008f0	859f37f8	 ldrhi       r3, [pc, #0x7F8]

; 1536 :         }
; 1537 :         else
; 1538 :         {
; 1539 :             //  Use up-sampling horizontal coeffs
; 1540 :             dwScaleEnable |= DISPC_VID_ATTR_VIDHRESIZE_CONF_UP;
; 1541 :             pHorizCoeffs = g_dwScalingCoeff_Horiz_Up;

  008f4	959f37f0	 ldrls       r3, [pc, #0x7F0]
  008f8	83888080	 orrhi       r8, r8, #0x80

; 1542 :         }
; 1543 : 
; 1544 : 
; 1545 :         //  Vertical scaling
; 1546 :         if( dwVertScale > 1024 )

  008fc	e3520b01	 cmp         r2, #1, 22
  00900	e58d3000	 str         r3, [sp]

; 1547 :         {
; 1548 :             //  Use 5 tap down-sampling vertical coeffs for scaling between 50% and 25%
; 1549 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_DOWN;
; 1550 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_5;
; 1551 :             dwScaleEnable |= DISPC_VID_ATTR_VIDLINEBUFFERSPLIT;
; 1552 :             pVertCoeffs = g_dwScalingCoeff_Vert_Down_5_Taps;
; 1553 :         } 
; 1554 :         //else if( dwVertScale > 1024 )
; 1555 :         //{
; 1556 :         //    //  Use 3 tap down-sampling vertical coeffs for scaling between 100% and 50%
; 1557 :         //    dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_DOWN;
; 1558 :         //    dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1559 :         //    pVertCoeffs = g_dwScalingCoeff_Vert_Down_3_Taps;
; 1560 :         //}
; 1561 :         else
; 1562 :         {
; 1563 :             //  Use up-sampling vertical coeffs
; 1564 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_UP;
; 1565 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1566 :             pVertCoeffs = g_dwScalingCoeff_Vert_Up_3_Taps;
; 1567 :         }
; 1568 : 
; 1569 :         // For Portrait mode, the Vertical down scale coeff has to be 5 tap to
; 1570 :         // prevent SYNCLOST. so ignore the scale factor and force the 5-tap.
; 1571 :         if ((( eRotation == OMAP_DSS_ROTATION_90 )|| 
; 1572 :             ( eRotation == OMAP_DSS_ROTATION_270 )) && 
; 1573 :             ( pVertCoeffs == g_dwScalingCoeff_Vert_Down_3_Taps ))

  00904	e59d2030	 ldr         r2, [sp, #0x30]
  00908	83a03606	 movhi       r3, #6, 12
  0090c	859f77cc	 ldrhi       r7, [pc, #0x7CC]
  00910	83833c01	 orrhi       r3, r3, #1, 24
  00914	959f77cc	 ldrls       r7, [pc, #0x7CC]
  00918	81888003	 orrhi       r8, r8, r3
  0091c	e352005a	 cmp         r2, #0x5A
  00920	0a000002	 beq         |$LN39@SetScaling|
  00924	e59d304c	 ldr         r3, [sp, #0x4C]
  00928	e1520003	 cmp         r2, r3
  0092c	1a000084	 bne         |$LN17@SetScaling|
  00930		 |$LN39@SetScaling|
  00930	e59f37ac	 ldr         r3, [pc, #0x7AC]
  00934	e1570003	 cmp         r7, r3
  00938	1a000081	 bne         |$LN17@SetScaling|

; 1574 :         {
; 1575 :             //clear existing scale option
; 1576 :             dwScaleEnable &= ~DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1577 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_5;
; 1578 :             dwScaleEnable |= DISPC_VID_ATTR_VIDLINEBUFFERSPLIT;
; 1579 :             pVertCoeffs = g_dwScalingCoeff_Vert_Down_5_Taps;

  0093c	e59f779c	 ldr         r7, [pc, #0x79C]
  00940	e3888606	 orr         r8, r8, #6, 12

; 1580 :         }
; 1581 :     }

  00944	ea00007e	 b           |$LN17@SetScaling|
  00948		 |$LN72@SetScaling|

; 1582 : 
; 1583 : 
; 1584 :     //------------------------------------------------------------------------------
; 1585 :     //  Configure the scaling of the pipeline for TV display
; 1586 :     //
; 1587 :     else if( g_rgPipelineMapping[ePipeline].eDestination == OMAP_DSS_DESTINATION_TVOUT )

  00948	e3530001	 cmp         r3, #1
  0094c	1a0001d7	 bne         |$cleanUp$38236|

; 1588 :     {
; 1589 :         dwInterlaceCorrection = 2;
; 1590 : 
; 1591 :         //  Half the dest height to enable filtering for TV interlace
; 1592 :         dwDestHeight /= dwInterlaceCorrection;
; 1593 : 
; 1594 : #if 0
; 1595 :         //  Compute horizontal and vertical scaling factors
; 1596 :         dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;
; 1597 :         dwVertScale = 1024 * dwSrcHeight / dwDestHeight;
; 1598 :         
; 1599 :         //  Determine if scaling is within HW scaling capabilities
; 1600 :         //  If not, use surface scaling factor to decimate the source surface
; 1601 :         //  by 2, 4 or 8
; 1602 :         if( dwHorzScale > 4096 )
; 1603 :             dwHorzDecimation = 2;
; 1604 : 
; 1605 :         if( dwHorzScale > 8192 )
; 1606 :             dwHorzDecimation = 4;
; 1607 : 
; 1608 : 
; 1609 :         if( dwVertScale > 2048 )
; 1610 :             dwVertDecimation = 2;
; 1611 : 
; 1612 :         if( dwVertScale > 4096 )
; 1613 :             dwVertDecimation = 4;
; 1614 : 
; 1615 :         if( dwVertScale > 8192 )
; 1616 :             dwVertDecimation = 8;
; 1617 : 
; 1618 :             
; 1619 :         //  Adjust the HW scaling factors by the decimation factor      
; 1620 :         dwHorzScale = 1024 * (dwSrcWidth/dwHorzDecimation) / dwDestWidth;    
; 1621 :         dwVertScale = 1024 * (dwSrcHeight/dwVertDecimation) / dwDestHeight;    
; 1622 :         
; 1623 :         
; 1624 :         //  Set the decimation factors for the surface (always standard orientation for TV out)
; 1625 :         pSurface->SetHorizontalScaling( dwHorzDecimation );
; 1626 :         pSurface->SetVerticalScaling( dwVertDecimation );
; 1627 :         
; 1628 :         //  Adjust the source width and height by the decimation factor
; 1629 :         dwSrcWidth  = dwSrcWidth / dwHorzDecimation;
; 1630 :         dwSrcHeight = dwSrcHeight / dwVertDecimation;
; 1631 : 
; 1632 : 
; 1633 :         //  Based on scaling factor, determine which coeffs to use and if to enable scaling
; 1634 :         dwScaleEnable |= (dwHorzScale == 1024) ? 0 : DISPC_VID_ATTR_VIDRESIZE_HORIZONTAL;
; 1635 :         dwScaleEnable |= (dwVertScale == 1024) ? 0 : DISPC_VID_ATTR_VIDRESIZE_VERTICAL;
; 1636 : 
; 1637 : 
; 1638 :         //  Accum0/1 controls the scaler phase for the even/odd fields
; 1639 :         //  This is affected by the field polarity - bit 17 of VENC_GEN_CTRL_VAL register -
; 1640 :         //  If active low, the ratio is VIDFIRVINC/2, otherwise it's 1024 * dwDestHeight / dwSrcHeight
; 1641 :         dwAccum1 = (1024 * dwDestHeight / dwSrcHeight) << 16; 
; 1642 :     
; 1643 : 
; 1644 :         //  Horizontal scaling
; 1645 :         if( dwHorzScale > 1024 )
; 1646 :         {
; 1647 :             //  Use down-sampling horizontal coeffs
; 1648 :             dwScaleEnable |= DISPC_VID_ATTR_VIDHRESIZE_CONF_DOWN;
; 1649 :             pHorizCoeffs = g_dwScalingCoeff_Horiz_Down;
; 1650 :         }
; 1651 :         else
; 1652 :         {
; 1653 :             //  Use up-sampling horizontal coeffs
; 1654 :             dwScaleEnable |= DISPC_VID_ATTR_VIDHRESIZE_CONF_UP;
; 1655 :             pHorizCoeffs = g_dwScalingCoeff_Horiz_Up;
; 1656 :         }
; 1657 : 
; 1658 : 
; 1659 :         //  Vertical scaling (based on flicker filter setting instead of scaling value)
; 1660 :         if( m_dwTVFilterLevel >= OMAP_TV_FILTER_LEVEL_HIGH )
; 1661 :         {
; 1662 :             //  Use 5 tap down-sampling vertical coeffs for HIGH flicker filtering
; 1663 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_DOWN;
; 1664 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_5;
; 1665 :             dwScaleEnable |= DISPC_VID_ATTR_VIDLINEBUFFERSPLIT;
; 1666 :             pVertCoeffs = g_dwScalingCoeff_Vert_Down_5_Taps;
; 1667 :         }
; 1668 :         else if( m_dwTVFilterLevel == OMAP_TV_FILTER_LEVEL_MEDIUM )
; 1669 :         {
; 1670 :             //  Use 3 tap down-sampling vertical coeffs for MEDIUM flicker filtering
; 1671 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_DOWN;
; 1672 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1673 :             pVertCoeffs = g_dwScalingCoeff_Vert_Down_3_Taps;
; 1674 :         }
; 1675 :         else if( m_dwTVFilterLevel == OMAP_TV_FILTER_LEVEL_LOW )
; 1676 :         {
; 1677 :             //  Use 3 tap up-sampling vertical coeffs for LOW flicker filtering
; 1678 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_UP;
; 1679 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1680 :             pVertCoeffs = g_dwScalingCoeff_Vert_Up_3_Taps;
; 1681 :         }
; 1682 :         else if( m_dwTVFilterLevel == OMAP_TV_FILTER_LEVEL_OFF )
; 1683 :         {
; 1684 :             //  No flicker filtering but only if the destination height can be decimated to fit the TV height
; 1685 :             //  (account for the /2 of destHeight above)
; 1686 :             if( (dwSrcHeight == dwDestHeight) && (dwDestHeight <= GetTVHeight()/2) )
; 1687 :             {
; 1688 :                 DEBUGMSG(ZONE_WARNING, (L"----- Using No interlace mode for TV out --------\r\n"));
; 1689 : 
; 1690 :                 //  Can fit the surface on TV without interlacing
; 1691 :                 dwInterlace = 0;
; 1692 :                 
; 1693 :                 //  No scaling
; 1694 :                 dwScaleEnable &= ~DISPC_VID_ATTR_VIDRESIZE_VERTICAL;
; 1695 :                 dwVertScale = 1024;
; 1696 :                 
; 1697 :                 //  No FIR accumulator values
; 1698 :                 dwAccum0 = dwAccum1 = 0;
; 1699 :             }
; 1700 :             else if( (dwSrcHeight == 2*dwDestHeight) && (dwDestHeight <= GetTVHeight()) )
; 1701 :             {
; 1702 :                 DEBUGMSG(ZONE_WARNING, (L"----- Using Interlace mode for TV out --------\r\n"));
; 1703 :             
; 1704 :                 //  Need to decimate the height by 2 to fit on the TV via interlacing
; 1705 :                 dwVertDecimation = 2;
; 1706 :                 pSurface->SetVerticalScaling( dwVertDecimation );
; 1707 :         
; 1708 :                 dwSrcHeight = dwSrcHeight / dwVertDecimation;
; 1709 :             
; 1710 :                 //  No scaling
; 1711 :                 dwScaleEnable &= ~DISPC_VID_ATTR_VIDRESIZE_VERTICAL;
; 1712 :                 dwVertScale = 1024;
; 1713 : 
; 1714 :                 //  Need to use the surface stride to output via interlacing
; 1715 :                 dwInterlace = pSurface->Stride();
; 1716 : 
; 1717 :                 //  No FIR accumulator values
; 1718 :                 dwAccum0 = dwAccum1 = 0;
; 1719 :             }
; 1720 :             else
; 1721 :             {
; 1722 :                 DEBUGMSG(ZONE_WARNING, (L"----- Using Scaling mode for TV out --------\r\n"));
; 1723 : 
; 1724 :                 //  Have to scale the output to TV because it just won't fit otherwise
; 1725 :                 //  Use 3 tap up-sampling vertical coeffs for LOW flicker filtering
; 1726 :                 dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_UP;
; 1727 :                 dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1728 :             }
; 1729 :                         
; 1730 :             //  Always need to point to some set of vertical coeffs
; 1731 :             pVertCoeffs = g_dwScalingCoeff_Vert_Down_3_Taps;
; 1732 :         }
; 1733 :         else
; 1734 :         {
; 1735 :             //  Use 3 tap down-sampling vertical coeffs for MEDIUM flicker filtering as the default setting
; 1736 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_DOWN;
; 1737 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_3;
; 1738 :             pVertCoeffs = g_dwScalingCoeff_Vert_Down_3_Taps;
; 1739 :         }
; 1740 : #else
; 1741 :         //  Compute horizontal and vertical scaling factors
; 1742 :         dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;

  00950	e1a00001	 mov         r0, r1
  00954	e1a070a7	 mov         r7, r7, lsr #1
  00958	e1a0150b	 mov         r1, r11, lsl #10
  0095c	e58d7018	 str         r7, [sp, #0x18]
  00960	eb000000	 bl          __rt_udiv
  00964	e58d0008	 str         r0, [sp, #8]

; 1743 :         dwVertScale = 1024 * dwSrcHeight / dwDestHeight;

  00968	e1a00007	 mov         r0, r7
  0096c	e1a01504	 mov         r1, r4, lsl #10
  00970	eb000000	 bl          __rt_udiv

; 1744 : 
; 1745 :         //  Determine if scaling is within HW scaling capabilities
; 1746 :         //  If not, use surface scaling factor to decimate the source surface
; 1747 :         //  by 2, 4 or 8
; 1748 : //        if( dwHorzScale > 4096 )
; 1749 : //            dwHorzDecimation = 2;
; 1750 : 
; 1751 : //        if( dwHorzScale > 8192 )
; 1752 : //            dwHorzDecimation = 4;
; 1753 : 
; 1754 : 
; 1755 : //        if( dwVertScale > 2048 )
; 1756 : //            dwVertDecimation = 2;
; 1757 : 
; 1758 : //        if( dwVertScale > 4096 )
; 1759 : //            dwVertDecimation = 4;
; 1760 : 
; 1761 : //        if( dwVertScale > 8192 )
; 1762 : //            dwVertDecimation = 8;
; 1763 : 
; 1764 :         //  Adjust the source width and height by the decimation factor
; 1765 : //        dwSrcWidth  = dwSrcWidth / dwHorzDecimation;
; 1766 : //        dwSrcHeight = dwSrcHeight / dwVertDecimation;
; 1767 : 
; 1768 :         //  Adjust the HW scaling factors by the decimation factor      
; 1769 : //        dwHorzScale = 1024 * dwSrcWidth / dwDestWidth;
; 1770 : //        dwVertScale = 1024 * dwSrcHeight / dwDestHeight;
; 1771 : 
; 1772 :         if (m_dwTVFilterLevel)
; 1773 :         {
; 1774 :             // Flicker filter not supported currently (If flickerFilter is used, scaling cannot be done)
; 1775 :             // dwFlickerFilter = 1;
; 1776 :         }
; 1777 : 
; 1778 :         //  Set the decimation factors for the surface (always standard orientation for TV out)
; 1779 :         pSurface->SetHorizontalScaling( dwHorzDecimation );

  00974	e5963000	 ldr         r3, [r6]
  00978	e1a07000	 mov         r7, r0
  0097c	e58d7010	 str         r7, [sp, #0x10]
  00980	e5933030	 ldr         r3, [r3, #0x30]
  00984	e3a01001	 mov         r1, #1
  00988	e1a00006	 mov         r0, r6
  0098c	e1a0e00f	 mov         lr, pc
  00990	e12fff13	 bx          r3

; 1780 :         pSurface->SetVerticalScaling( dwVertDecimation );

  00994	e5963000	 ldr         r3, [r6]
  00998	e3a01001	 mov         r1, #1
  0099c	e1a00006	 mov         r0, r6
  009a0	e5933034	 ldr         r3, [r3, #0x34]
  009a4	e1a0e00f	 mov         lr, pc
  009a8	e12fff13	 bx          r3

; 1781 : 
; 1782 :          //Get vertical scaler coefficients
; 1783 :         if (dwSrcWidth > 1280)

  009ac	e35b0c05	 cmp         r11, #5, 24

; 1784 :         {
; 1785 :             dwVTaps = 3;

  009b0	83a01003	 movhi       r1, #3

; 1786 :         }
; 1787 :         else
; 1788 :         {
; 1789 :             dwVTaps = 5;
; 1790 :             dwScaleEnable |= DISPC_VID_ATTR_VIDLINEBUFFERSPLIT;
; 1791 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVERTICALTAPS_5;

  009b4	93a08606	 movls       r8, #6, 12
  009b8	93a01005	 movls       r1, #5

; 1792 :         }
; 1793 : 
; 1794 :         GetFIRCoef((void*)Coefficients, dwVTaps, dwVertScale, dwFlickerFilter);

  009bc	e3a03000	 mov         r3, #0
  009c0	e1a02007	 mov         r2, r7
  009c4	e28d0f4e	 add         r0, sp, #0x4E, 30
  009c8	958d8060	 strls       r8, [sp, #0x60]
  009cc	eb000000	 bl          |?GetFIRCoef@@YAXPAXKKK@Z|

; 1795 :         for (i = 0; i < 8; i++)

  009d0	e3a04000	 mov         r4, #0
  009d4	e28d7078	 add         r7, sp, #0x78
  009d8	e28d9f4e	 add         r9, sp, #0x4E, 30
  009dc	e3a08000	 mov         r8, #0
  009e0		 |$LL33@SetScaling|

; 1796 :         {
; 1797 :             dwData1 = (Coefficients[0][i]) | ((Coefficients[4][i]) << 8);
; 1798 :             dwData2 = ((Coefficients[1][i]) << 8) |((Coefficients[2][i]) << 16) | ((Coefficients[3][i]) << 24);

  009e0	e084e009	 add         lr, r4, r9

; 1799 : 
; 1800 :             /* Make up coefficients in the format needed further down */
; 1801 :             dwVertCoeffs[i*3]   = 0;
; 1802 :             dwVertCoeffs[i*3+1] = dwData2;

  009e4	e5de2018	 ldrb        r2, [lr, #0x18]
  009e8	e5de3010	 ldrb        r3, [lr, #0x10]
  009ec	e5de1008	 ldrb        r1, [lr, #8]

; 1803 :             dwVertCoeffs[i*3+2] = dwData1;

  009f0	e5de0020	 ldrb        r0, [lr, #0x20]
  009f4	e1833402	 orr         r3, r3, r2, lsl #8
  009f8	e5de2000	 ldrb        r2, [lr]
  009fc	e1813403	 orr         r3, r1, r3, lsl #8
  00a00	e1a03403	 mov         r3, r3, lsl #8
  00a04	e1822400	 orr         r2, r2, r0, lsl #8
  00a08	e2844001	 add         r4, r4, #1
  00a0c	e5872008	 str         r2, [r7, #8]
  00a10	e5873004	 str         r3, [r7, #4]
  00a14	e5878000	 str         r8, [r7]
  00a18	e287700c	 add         r7, r7, #0xC
  00a1c	e3540008	 cmp         r4, #8
  00a20	3affffee	 bcc         |$LL33@SetScaling|

; 1804 :         }
; 1805 :         pVertCoeffs = dwVertCoeffs;
; 1806 : 
; 1807 :         //Now get horizontal scaler coefficients
; 1808 :         GetFIRCoef((void*)Coefficients, 5, dwHorzScale, 0);

  00a24	e59d2008	 ldr         r2, [sp, #8]
  00a28	e28d7078	 add         r7, sp, #0x78
  00a2c	e3a03000	 mov         r3, #0
  00a30	e3a01005	 mov         r1, #5
  00a34	e28d0f4e	 add         r0, sp, #0x4E, 30
  00a38	e58d7048	 str         r7, [sp, #0x48]
  00a3c	eb000000	 bl          |?GetFIRCoef@@YAXPAXKKK@Z|
  00a40	e59d8060	 ldr         r8, [sp, #0x60]
  00a44	e59d905c	 ldr         r9, [sp, #0x5C]
  00a48	e59d401c	 ldr         r4, [sp, #0x1C]

; 1809 :         for (i = 0; i < 8; i++)

  00a4c	e3a0a000	 mov         r10, #0
  00a50	e28d50d8	 add         r5, sp, #0xD8
  00a54	e28d7f4e	 add         r7, sp, #0x4E, 30
  00a58	e3a06000	 mov         r6, #0
  00a5c		 |$LL30@SetScaling|

; 1810 :         {
; 1811 :             dwData1 = (Coefficients[0][i] | (Coefficients[1][i]) << 8) |((Coefficients[2][i]) << 16) | ((Coefficients[3][i]) << 24);

  00a5c	e08ae007	 add         lr, r10, r7

; 1812 :             dwData2 = (Coefficients[4][i]);
; 1813 : 
; 1814 :             /* Make up coefficients in the format needed further down */
; 1815 :             dwHorizCoeffs[i*3]   = dwData1;

  00a60	e5de1018	 ldrb        r1, [lr, #0x18]
  00a64	e5de3010	 ldrb        r3, [lr, #0x10]
  00a68	e5de2008	 ldrb        r2, [lr, #8]
  00a6c	e5de0000	 ldrb        r0, [lr]
  00a70	e1833401	 orr         r3, r3, r1, lsl #8
  00a74	e1823403	 orr         r3, r2, r3, lsl #8

; 1816 :             dwHorizCoeffs[i*3+1] = dwData2;

  00a78	e5de2020	 ldrb        r2, [lr, #0x20]
  00a7c	e1803403	 orr         r3, r0, r3, lsl #8
  00a80	e28aa001	 add         r10, r10, #1
  00a84	e5852004	 str         r2, [r5, #4]
  00a88	e5853000	 str         r3, [r5]

; 1817 :             dwHorizCoeffs[i*3+2] = 0;

  00a8c	e5856008	 str         r6, [r5, #8]
  00a90	e285500c	 add         r5, r5, #0xC
  00a94	e35a0008	 cmp         r10, #8
  00a98	3affffef	 bcc         |$LL30@SetScaling|

; 1818 :         }
; 1819 :         pHorizCoeffs = dwHorizCoeffs;
; 1820 : 
; 1821 :         if (dwSrcHeight > (dwDestHeight * dwInterlaceCorrection))

  00a9c	e59d3018	 ldr         r3, [sp, #0x18]
  00aa0	e1a02083	 mov         r2, r3, lsl #1
  00aa4	e1540002	 cmp         r4, r2
  00aa8	e28d30d8	 add         r3, sp, #0xD8

; 1822 :         {
; 1823 :             //Down scale
; 1824 :             dwScaleEnable |= DISPC_VID_ATTR_VIDRESIZE_VERTICAL;
; 1825 :             dwScaleEnable |= DISPC_VID_ATTR_VIDVRESIZE_CONF_DOWN;

  00aac	83888d05	 orrhi       r8, r8, #5, 26
  00ab0	e58d3000	 str         r3, [sp]
  00ab4	8a000000	 bhi         |$LN25@SetScaling|

; 1826 :         }
; 1827 :         else if (dwSrcHeight < (dwDestHeight * dwInterlaceCorrection))
; 1828 :         {
; 1829 :             //Up scale
; 1830 :             dwScaleEnable |= DISPC_VID_ATTR_VIDRESIZE_VERTICAL;

  00ab8	33888040	 orrcc       r8, r8, #0x40
  00abc		 |$LN25@SetScaling|

; 1831 :         }
; 1832 :         else
; 1833 :         {
; 1834 :             //No scale
; 1835 :         }
; 1836 : 
; 1837 :         if (dwSrcWidth > dwDestWidth)

  00abc	e59d300c	 ldr         r3, [sp, #0xC]
  00ac0	e15b0003	 cmp         r11, r3

; 1838 :         {
; 1839 :             //Down scale
; 1840 :             dwScaleEnable |= DISPC_VID_ATTR_VIDRESIZE_HORIZONTAL;
; 1841 :             dwScaleEnable |= DISPC_VID_ATTR_VIDHRESIZE_CONF_DOWN;

  00ac4	838880a0	 orrhi       r8, r8, #0xA0
  00ac8	8a000000	 bhi         |$LN21@SetScaling|

; 1842 :         }
; 1843 :         else if (dwSrcWidth < dwDestWidth)
; 1844 :         {
; 1845 :             //Up scale
; 1846 :             dwScaleEnable |= DISPC_VID_ATTR_VIDRESIZE_HORIZONTAL;

  00acc	33888020	 orrcc       r8, r8, #0x20
  00ad0		 |$LN21@SetScaling|

; 1847 :         }
; 1848 :         else
; 1849 :         {
; 1850 :             //No scale
; 1851 :         }
; 1852 : 
; 1853 :         //  Accum0/1 controls the scaler phase for the even/odd fields
; 1854 :         if (m_dwTVFilterLevel == OMAP_TV_FILTER_LEVEL_OFF)

  00ad0	e59d5004	 ldr         r5, [sp, #4]

; 1855 :         {
; 1856 :             dwAccum0 = (((dwVertScale/dwInterlaceCorrection) % 1024) << 16);
; 1857 :             dwAccum1 = 0;
; 1858 :         }
; 1859 :         else
; 1860 :         {
; 1861 :             /* This case is not supported/tested */
; 1862 :             dwHorzScale = 1024;
; 1863 :             dwVertScale = 1024;
; 1864 :             dwAccum0 = 0;
; 1865 :             dwAccum1 = 0;
; 1866 :         }
; 1867 : 
; 1868 :         //  Need to use the surface stride to output via interlacing
; 1869 :         dwInterlace = pSurface->Stride();

  00ad4	e59d6074	 ldr         r6, [sp, #0x74]
  00ad8	e3a01000	 mov         r1, #0
  00adc	e59534b8	 ldr         r3, [r5, #0x4B8]
  00ae0	e1a00006	 mov         r0, r6
  00ae4	e3530000	 cmp         r3, #0
  00ae8	059d2010	 ldreq       r2, [sp, #0x10]
  00aec	03a03c07	 moveq       r3, #7, 24
  00af0	038330fe	 orreq       r3, r3, #0xFE
  00af4	00023003	 andeq       r3, r2, r3
  00af8	01a04783	 moveq       r4, r3, lsl #15
  00afc	13a03b01	 movne       r3, #1, 22
  00b00	158d3008	 strne       r3, [sp, #8]
  00b04	13a03b01	 movne       r3, #1, 22
  00b08	158d3010	 strne       r3, [sp, #0x10]
  00b0c	13a03000	 movne       r3, #0
  00b10	058d4054	 streq       r4, [sp, #0x54]
  00b14	158d3054	 strne       r3, [sp, #0x54]
  00b18	e5963000	 ldr         r3, [r6]
  00b1c	e5933010	 ldr         r3, [r3, #0x10]
  00b20	e1a0e00f	 mov         lr, pc
  00b24	e12fff13	 bx          r3

; 1870 : 
; 1871 :         // Account for interlacing for Y offset (this is the line offset in each field).
; 1872 :         dwY /= dwInterlaceCorrection; 

  00b28	e59d302c	 ldr         r3, [sp, #0x2C]
  00b2c	e59d7048	 ldr         r7, [sp, #0x48]
  00b30	e59da050	 ldr         r10, [sp, #0x50]
  00b34	e1a030a3	 mov         r3, r3, lsr #1

; 1947 :         
; 1948 :         //  Position of window
; 1949 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.POSITION,
; 1950 :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 1951 :                     DISPC_VID_POS_VIDPOSY(dwY)
; 1952 :                     );
; 1953 : 
; 1954 :         //  DMA properties
; 1955 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00b38	e59d2030	 ldr         r2, [sp, #0x30]
  00b3c	e58d302c	 str         r3, [sp, #0x2C]
  00b40	e58d0058	 str         r0, [sp, #0x58]
  00b44		 |$LN17@SetScaling|
  00b44	e59d4024	 ldr         r4, [sp, #0x24]
  00b48	e3540001	 cmp         r4, #1
  00b4c	1a00009f	 bne         |$LN8@SetScaling|
  00b50	e5963030	 ldr         r3, [r6, #0x30]
  00b54	e3530000	 cmp         r3, #0
  00b58	0a000033	 beq         |$LN11@SetScaling|
  00b5c	e1a03002	 mov         r3, r2
  00b60	e1a02009	 mov         r2, r9
  00b64	e1a0100a	 mov         r1, r10
  00b68	e1a00006	 mov         r0, r6
  00b6c	eb000000	 bl          |?ConfigResizerParams@OMAPSurface@@QAAHPAUtagRECT@@0W4OMAP_DSS_ROTATION@@@Z|
  00b70	e3500000	 cmp         r0, #0
  00b74	0a000016	 beq         |$LN209@SetScaling|
  00b78	e59600a0	 ldr         r0, [r6, #0xA0]
  00b7c	e59d2044	 ldr         r2, [sp, #0x44]
  00b80	e3a03001	 mov         r3, #1
  00b84	e590e000	 ldr         lr, [r0]
  00b88	e3a01000	 mov         r1, #0
  00b8c	e59e4014	 ldr         r4, [lr, #0x14]
  00b90	e1a0e00f	 mov         lr, pc
  00b94	e12fff14	 bx          r4
  00b98	e5962000	 ldr         r2, [r6]
  00b9c	e1a05000	 mov         r5, r0
  00ba0	e3a03001	 mov         r3, #1
  00ba4	e5924014	 ldr         r4, [r2, #0x14]
  00ba8	e59d2044	 ldr         r2, [sp, #0x44]
  00bac	e3a01000	 mov         r1, #0
  00bb0	e1a00006	 mov         r0, r6
  00bb4	e1a0e00f	 mov         lr, pc
  00bb8	e12fff14	 bx          r4
  00bbc	e1a01000	 mov         r1, r0
  00bc0	e1a00006	 mov         r0, r6
  00bc4	e1a02005	 mov         r2, r5
  00bc8	eb000000	 bl          |?StartResizer@OMAPSurface@@QAAHKK@Z|
  00bcc	e3500000	 cmp         r0, #0
  00bd0	1a000014	 bne         |$LN212@SetScaling|
  00bd4		 |$LN209@SetScaling|

; 1873 : #endif
; 1874 :     }
; 1875 :     else
; 1876 :     {
; 1877 :         ASSERT(0);
; 1878 :         goto cleanUp;
; 1879 :     }
; 1880 : 
; 1881 :     DEBUGMSG(ZONE_WARNING, (L"INFO: OMAPDisplayController::SetScalingAttribs: "));
; 1882 :     DEBUGMSG(ZONE_WARNING, (L"  Src  RECT (%d,%d) (%d,%d)\r\n", privSrcRect.left, privSrcRect.top, privSrcRect.right, privSrcRect.bottom));
; 1883 :     DEBUGMSG(ZONE_WARNING, (L"  Dest RECT (%d,%d) (%d,%d)\r\n", pDestRect->left, pDestRect->top, pDestRect->right, pDestRect->bottom));
; 1884 :     DEBUGMSG(ZONE_WARNING, (L"  Computed Origin (%d,%d) for rotation angle %d\r\n", dwX, dwY, g_rgPipelineMapping[ePipeline].eRotation));
; 1885 :     DEBUGMSG(ZONE_WARNING, (L"  dwScaleEnable = 0x%08X  dwHorzScale = %d  dwVertScale = %d\r\n", dwScaleEnable, dwHorzScale, dwVertScale));
; 1886 :     DEBUGMSG(ZONE_WARNING, (L"  dwSrcWidth  = %d  dwSrcHeight  = %d\r\n", dwSrcWidth, dwSrcHeight));
; 1887 :     DEBUGMSG(ZONE_WARNING, (L"  dwDestWidth = %d  dwDestHeight = %d\r\n", dwDestWidth, dwDestHeight));
; 1888 :     DEBUGMSG(ZONE_WARNING, (L"  dwHorzDecimation = %d  dwVertDecimation = %d\r\n", dwHorzDecimation, dwVertDecimation));
; 1889 :     DEBUGMSG(ZONE_WARNING, (L"  ePipeline = %d\r\n", ePipeline));
; 1890 :     DEBUGMSG(ZONE_WARNING, (L"  pSurface = 0x%x Stride = %d Row_Inc = %d\r\n", pSurface,pSurface->Stride(eRotation),pSurface->RowIncr(eRotation, bMirror)));
; 1891 :    
; 1892 : 
; 1893 :     //  GFX pipeline
; 1894 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )
; 1895 :     {
; 1896 :         //  Scaling is not supported on the GFX plane
; 1897 :     }
; 1898 : 
; 1899 : 
; 1900 :     //  VIDEO1 pipeline
; 1901 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )
; 1902 :     {   
; 1903 :         DEBUGMSG(ZONE_WARNING, (L"\t Resizer Enabled %d \r\n",bUseResizer));
; 1904 : 
; 1905 :         if (pSurface->isResizerEnabled())
; 1906 :         {   
; 1907 :             DWORD rszStatus = FALSE;
; 1908 :             /* set Resizer */
; 1909 :             rszStatus = pSurface->ConfigResizerParams(pSrcRect, pDestRect,eRotation);
; 1910 :             /* Start resizer */
; 1911 :             if (rszStatus)
; 1912 :                 rszStatus = pSurface->StartResizer(pSurface->PhysicalAddr(OMAP_DSS_ROTATION_0, bMirror,OMAP_ASSOC_SURF_FORCE_OFF), //input
; 1913 :                                                    pSurface->OmapAssocSurface()->PhysicalAddr(OMAP_DSS_ROTATION_0, bMirror,OMAP_ASSOC_SURF_FORCE_OFF));               
; 1914 :             if (!(rszStatus))
; 1915 :             {
; 1916 :                 RETAILMSG(TRUE,(L"SetScalingAttribs: Cannot configure/start ISP resizer; Cropping the image\r\n"));

  00bd4	e59f0500	 ldr         r0, [pc, #0x500]
  00bd8	eb000000	 bl          NKDbgPrintfW

; 1917 :                 bUseResizer = FALSE;
; 1918 :                 pSurface->UseResizer(FALSE);
; 1919 :                 pSurface->SetRSZHandle(NULL, TRUE);

  00bdc	e5963034	 ldr         r3, [r6, #0x34]
  00be0	e3a04000	 mov         r4, #0
  00be4	e5864030	 str         r4, [r6, #0x30]
  00be8	e3530000	 cmp         r3, #0
  00bec	0a000002	 beq         |$LN180@SetScaling|
  00bf0	e1a00003	 mov         r0, r3
  00bf4	eb000000	 bl          CloseHandle
  00bf8	e5864034	 str         r4, [r6, #0x34]
  00bfc		 |$LN180@SetScaling|

; 1920 :                 memset(pSurface->ResizeParams(),0,sizeof(RSZParams_t));  

  00bfc	e3a02064	 mov         r2, #0x64
  00c00	e3a01000	 mov         r1, #0
  00c04	e2860038	 add         r0, r6, #0x38
  00c08	e5864034	 str         r4, [r6, #0x34]
  00c0c	eb000000	 bl          memset

; 1921 :                 pSurface->SetClipping( &privSrcRect);

  00c10	e5963000	 ldr         r3, [r6]
  00c14	e28d1034	 add         r1, sp, #0x34
  00c18	e1a00006	 mov         r0, r6
  00c1c	e5933020	 ldr         r3, [r3, #0x20]
  00c20	e1a0e00f	 mov         lr, pc
  00c24	e12fff13	 bx          r3
  00c28		 |$LN212@SetScaling|

; 1847 :         }
; 1848 :         else
; 1849 :         {
; 1850 :             //No scale
; 1851 :         }
; 1852 : 
; 1853 :         //  Accum0/1 controls the scaler phase for the even/odd fields
; 1854 :         if (m_dwTVFilterLevel == OMAP_TV_FILTER_LEVEL_OFF)

  00c28	e59d5004	 ldr         r5, [sp, #4]

; 1921 :                 pSurface->SetClipping( &privSrcRect);

  00c2c		 |$LN11@SetScaling|

; 1922 :             }            
; 1923 :         }
; 1924 :         
; 1925 :         //  Get the current attribute settings
; 1926 :         dwCurrAttribs = INREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES );
; 1927 : 
; 1928 :         //  Mask off the scaling bits
; 1929 :         dwCurrAttribs &= ~(DISPC_VID_ATTR_VIDRESIZE_MASK|DISPC_VID_ATTR_VIDLINEBUFFERSPLIT|DISPC_VID_ATTR_VIDVERTICALTAPS_5);
; 1930 :         
; 1931 :         //  Enable video resizing by or'ing with scale enable attribs
; 1932 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES,
; 1933 :                     dwCurrAttribs | dwScaleEnable
; 1934 :                     );
; 1935 : 
; 1936 :         
; 1937 :         //  Size of resized output window and original picture size
; 1938 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.SIZE,
; 1939 :                     DISPC_VID_SIZE_VIDSIZEX(dwDestWidth) |
; 1940 :                     DISPC_VID_SIZE_VIDSIZEY(dwDestHeight)
; 1941 :                     );

  00c2c	e59d3018	 ldr         r3, [sp, #0x18]
  00c30	e5950008	 ldr         r0, [r5, #8]

; 1942 : 
; 1943 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PICTURE_SIZE,
; 1944 :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEX(dwSrcWidth) |
; 1945 :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEY(dwSrcHeight)
; 1946 :                     );

  00c34	e3e04606	 mvn         r4, #6, 12
  00c38	e2431001	 sub         r1, r3, #1
  00c3c	e59d300c	 ldr         r3, [sp, #0xC]
  00c40	e59020cc	 ldr         r2, [r0, #0xCC]

; 1947 :         
; 1948 :         //  Position of window
; 1949 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.POSITION,
; 1950 :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 1951 :                     DISPC_VID_POS_VIDPOSY(dwY)
; 1952 :                     );
; 1953 : 
; 1954 :         //  DMA properties
; 1955 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00c44	e59da044	 ldr         r10, [sp, #0x44]
  00c48	e2433001	 sub         r3, r3, #1
  00c4c	e183e801	 orr         lr, r3, r1, lsl #16
  00c50	e59d301c	 ldr         r3, [sp, #0x1C]
  00c54	e2431001	 sub         r1, r3, #1
  00c58	e2243e1e	 eor         r3, r4, #0x1E, 28
  00c5c	e0023003	 and         r3, r2, r3
  00c60	e1833008	 orr         r3, r3, r8
  00c64	e58030cc	 str         r3, [r0, #0xCC]
  00c68	e5952008	 ldr         r2, [r5, #8]
  00c6c	e24b3001	 sub         r3, r11, #1
  00c70	e1831801	 orr         r1, r3, r1, lsl #16
  00c74	e582e0c8	 str         lr, [r2, #0xC8]
  00c78	e5953008	 ldr         r3, [r5, #8]
  00c7c	e59d202c	 ldr         r2, [sp, #0x2C]
  00c80	e59d0020	 ldr         r0, [sp, #0x20]
  00c84	e58310e4	 str         r1, [r3, #0xE4]
  00c88	e5953008	 ldr         r3, [r5, #8]
  00c8c	e180e802	 orr         lr, r0, r2, lsl #16
  00c90	e59d4030	 ldr         r4, [sp, #0x30]
  00c94	e583e0c4	 str         lr, [r3, #0xC4]
  00c98	e5963000	 ldr         r3, [r6]
  00c9c	e1a0200a	 mov         r2, r10
  00ca0	e1a01004	 mov         r1, r4
  00ca4	e5933018	 ldr         r3, [r3, #0x18]
  00ca8	e1a00006	 mov         r0, r6
  00cac	e1a0e00f	 mov         lr, pc
  00cb0	e12fff13	 bx          r3
  00cb4	e5953008	 ldr         r3, [r5, #8]

; 1956 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ROW_INC, (pSurface->RowIncr(eRotation, bMirror)) );

  00cb8	e1a0200a	 mov         r2, r10
  00cbc	e1a01004	 mov         r1, r4
  00cc0	e58300dc	 str         r0, [r3, #0xDC]
  00cc4	e5963000	 ldr         r3, [r6]
  00cc8	e1a00006	 mov         r0, r6
  00ccc	e593301c	 ldr         r3, [r3, #0x1C]
  00cd0	e1a0e00f	 mov         lr, pc
  00cd4	e12fff13	 bx          r3
  00cd8	e5952008	 ldr         r2, [r5, #8]

; 1957 : 
; 1958 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  00cdc	e1a01004	 mov         r1, r4
  00ce0	e3a03000	 mov         r3, #0
  00ce4	e58200d8	 str         r0, [r2, #0xD8]
  00ce8	e5960000	 ldr         r0, [r6]
  00cec	e1a0200a	 mov         r2, r10
  00cf0	e5904014	 ldr         r4, [r0, #0x14]
  00cf4	e1a00006	 mov         r0, r6
  00cf8	e1a0e00f	 mov         lr, pc
  00cfc	e12fff14	 bx          r4
  00d00	e59d3058	 ldr         r3, [sp, #0x58]
  00d04	e5952008	 ldr         r2, [r5, #8]
  00d08	e0803003	 add         r3, r0, r3
  00d0c	e58230bc	 str         r3, [r2, #0xBC]

; 1959 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  00d10	e5961000	 ldr         r1, [r6]
  00d14	e3a03000	 mov         r3, #0
  00d18	e1a0200a	 mov         r2, r10
  00d1c	e5914014	 ldr         r4, [r1, #0x14]
  00d20	e59d1030	 ldr         r1, [sp, #0x30]
  00d24	e1a00006	 mov         r0, r6
  00d28	e1a0e00f	 mov         lr, pc
  00d2c	e12fff14	 bx          r4
  00d30	e5953008	 ldr         r3, [r5, #8]

; 1960 : 
; 1961 :         //  Initialize FIR accumulators
; 1962 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ACCU0,
; 1963 :                     dwAccum0
; 1964 :                     );
; 1965 : 
; 1966 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ACCU1,
; 1967 :                     dwAccum1
; 1968 :                     );
; 1969 : 
; 1970 :         //  Set FIR increment value and coeffs
; 1971 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.FIR,
; 1972 :                     DISPC_VID_FIR_VIDFIRHINC(dwHorzScale) |
; 1973 :                     DISPC_VID_FIR_VIDFIRVINC(dwVertScale)
; 1974 :                     );

  00d34	e59d2010	 ldr         r2, [sp, #0x10]
  00d38	e59d1008	 ldr         r1, [sp, #8]
  00d3c	e58300c0	 str         r0, [r3, #0xC0]
  00d40	e5953008	 ldr         r3, [r5, #8]
  00d44	e1812802	 orr         r2, r1, r2, lsl #16
  00d48	e59d1054	 ldr         r1, [sp, #0x54]

; 1986 : 
; 1987 :             OUTREG32( &m_pDispRegs->DISPC_VID1_FIR_COEF_V[i],
; 1988 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 1989 :                         );

  00d4c	e59d4000	 ldr         r4, [sp]
  00d50	e3a0e000	 mov         lr, #0
  00d54	e58310e8	 str         r1, [r3, #0xE8]
  00d58	e5953008	 ldr         r3, [r5, #8]
  00d5c	e3a01000	 mov         r1, #0
  00d60	e3a0ae1e	 mov         r10, #0x1E, 28
  00d64	e58310ec	 str         r1, [r3, #0xEC]
  00d68	e5953008	 ldr         r3, [r5, #8]
  00d6c	e58320e0	 str         r2, [r3, #0xE0]
  00d70		 |$LL10@SetScaling|

; 1975 : 
; 1976 :         for( i = 0; i < NUM_SCALING_PHASES; i++ )
; 1977 :         {
; 1978 :             //  OR the horiz and vert coeff values b/c some registers span both H and V coeffs
; 1979 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.aFIR_COEF[i].ulH,
; 1980 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 1981 :                         );

  00d70	e5953008	 ldr         r3, [r5, #8]
  00d74	e4970004	 ldr         r0, [r7], #4
  00d78	e4942004	 ldr         r2, [r4], #4
  00d7c	e083100e	 add         r1, r3, lr
  00d80	e1803002	 orr         r3, r0, r2
  00d84	e58130f0	 str         r3, [r1, #0xF0]

; 1982 : 
; 1983 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.aFIR_COEF[i].ulHV,
; 1984 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 1985 :                         );

  00d88	e5953008	 ldr         r3, [r5, #8]
  00d8c	e4970004	 ldr         r0, [r7], #4
  00d90	e4942004	 ldr         r2, [r4], #4
  00d94	e083100e	 add         r1, r3, lr
  00d98	e28ee008	 add         lr, lr, #8

; 1986 : 
; 1987 :             OUTREG32( &m_pDispRegs->DISPC_VID1_FIR_COEF_V[i],
; 1988 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 1989 :                         );

  00d9c	e35e0040	 cmp         lr, #0x40
  00da0	e1803002	 orr         r3, r0, r2
  00da4	e58130f4	 str         r3, [r1, #0xF4]
  00da8	e4972004	 ldr         r2, [r7], #4
  00dac	e4943004	 ldr         r3, [r4], #4
  00db0	e5951008	 ldr         r1, [r5, #8]
  00db4	e1823003	 orr         r3, r2, r3
  00db8	e781300a	 str         r3, [r1, +r10]
  00dbc	e28aa004	 add         r10, r10, #4
  00dc0	3affffea	 bcc         |$LL10@SetScaling|
  00dc4	e59da050	 ldr         r10, [sp, #0x50]
  00dc8	e58d4000	 str         r4, [sp]
  00dcc	e59d4024	 ldr         r4, [sp, #0x24]
  00dd0		 |$LN8@SetScaling|

; 1990 :         }
; 1991 : 
; 1992 :         Dump_DISPC_VID( &m_pDispRegs->tDISPC_VID1, (UINT32*) &m_pDispRegs->DISPC_VID1_FIR_COEF_V[0], 1 );
; 1993 :     }
; 1994 : 
; 1995 : 
; 1996 :     //  VIDEO2 pipeline
; 1997 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  00dd0	e3540002	 cmp         r4, #2
  00dd4	1a000098	 bne         |$LN1@SetScaling|

; 1998 :     {
; 1999 :         DEBUGMSG(ZONE_WARNING, (L"\t Resizer Enabled %d \r\n",bUseResizer));
; 2000 :         /* If using resizer */        
; 2001 :         if (pSurface->isResizerEnabled())

  00dd8	e5963030	 ldr         r3, [r6, #0x30]
  00ddc	e3530000	 cmp         r3, #0
  00de0	0a00002e	 beq         |$LN4@SetScaling|

; 2002 :         {   
; 2003 :             DWORD rszStatus = FALSE;
; 2004 :             /* set Resizer */
; 2005 :             rszStatus = pSurface->ConfigResizerParams(pSrcRect, pDestRect,eRotation);

  00de4	e59d3030	 ldr         r3, [sp, #0x30]
  00de8	e1a02009	 mov         r2, r9
  00dec	e1a0100a	 mov         r1, r10
  00df0	e1a00006	 mov         r0, r6
  00df4	eb000000	 bl          |?ConfigResizerParams@OMAPSurface@@QAAHPAUtagRECT@@0W4OMAP_DSS_ROTATION@@@Z|
  00df8	e3500000	 cmp         r0, #0

; 2006 :             /* Start resizer */
; 2007 :             if (rszStatus)

  00dfc	0a000018	 beq         |$LN208@SetScaling|

; 2008 :                 rszStatus = pSurface->StartResizer(pSurface->PhysicalAddr(OMAP_DSS_ROTATION_0, bMirror,OMAP_ASSOC_SURF_FORCE_OFF), //input
; 2009 :                                                    pSurface->OmapAssocSurface()->PhysicalAddr(OMAP_DSS_ROTATION_0, bMirror, OMAP_ASSOC_SURF_FORCE_OFF));               

  00e00	e59600a0	 ldr         r0, [r6, #0xA0]
  00e04	e59d9044	 ldr         r9, [sp, #0x44]
  00e08	e3a03001	 mov         r3, #1
  00e0c	e590e000	 ldr         lr, [r0]
  00e10	e1a02009	 mov         r2, r9
  00e14	e3a01000	 mov         r1, #0
  00e18	e59e4014	 ldr         r4, [lr, #0x14]
  00e1c	e1a0e00f	 mov         lr, pc
  00e20	e12fff14	 bx          r4
  00e24	e5962000	 ldr         r2, [r6]
  00e28	e1a05000	 mov         r5, r0
  00e2c	e3a03001	 mov         r3, #1
  00e30	e5924014	 ldr         r4, [r2, #0x14]
  00e34	e1a02009	 mov         r2, r9
  00e38	e3a01000	 mov         r1, #0
  00e3c	e1a00006	 mov         r0, r6
  00e40	e1a0e00f	 mov         lr, pc
  00e44	e12fff14	 bx          r4
  00e48	e1a01000	 mov         r1, r0
  00e4c	e1a00006	 mov         r0, r6
  00e50	e1a02005	 mov         r2, r5
  00e54	eb000000	 bl          |?StartResizer@OMAPSurface@@QAAHKK@Z|
  00e58	e59d5004	 ldr         r5, [sp, #4]
  00e5c	e3500000	 cmp         r0, #0

; 2010 :             if (!(rszStatus))

  00e60	1a00000e	 bne         |$LN4@SetScaling|
  00e64		 |$LN208@SetScaling|

; 2011 :             {
; 2012 :                 RETAILMSG(TRUE,(L"SetScalingAttribs: Cannot configure/start ISP resizer; Cropping the image\r\n"));

  00e64	e59f0270	 ldr         r0, [pc, #0x270]
  00e68	eb000000	 bl          NKDbgPrintfW

; 2013 :                 bUseResizer = FALSE;
; 2014 :                 pSurface->UseResizer(FALSE);
; 2015 :                 pSurface->SetRSZHandle(NULL, TRUE);

  00e6c	e5963034	 ldr         r3, [r6, #0x34]
  00e70	e3a04000	 mov         r4, #0
  00e74	e5864030	 str         r4, [r6, #0x30]
  00e78	e3530000	 cmp         r3, #0
  00e7c	0a000002	 beq         |$LN193@SetScaling|
  00e80	e1a00003	 mov         r0, r3
  00e84	eb000000	 bl          CloseHandle
  00e88	e5864034	 str         r4, [r6, #0x34]
  00e8c		 |$LN193@SetScaling|

; 2016 :                 memset(pSurface->ResizeParams(),0,sizeof(RSZParams_t));                

  00e8c	e3a02064	 mov         r2, #0x64
  00e90	e3a01000	 mov         r1, #0
  00e94	e2860038	 add         r0, r6, #0x38
  00e98	e5864034	 str         r4, [r6, #0x34]
  00e9c	eb000000	 bl          memset
  00ea0		 |$LN4@SetScaling|

; 2017 :             }            
; 2018 :         }
; 2019 :         
; 2020 :         
; 2021 :         //  Get the current attribute settings
; 2022 :         dwCurrAttribs = INREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES );
; 2023 : 
; 2024 :         //  Mask off the scaling bits
; 2025 :         dwCurrAttribs &= ~(DISPC_VID_ATTR_VIDRESIZE_MASK|DISPC_VID_ATTR_VIDLINEBUFFERSPLIT|DISPC_VID_ATTR_VIDVERTICALTAPS_5);
; 2026 :         
; 2027 :         //  Enable video resizing by or'ing with scale enable attribs
; 2028 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES,
; 2029 :                     dwCurrAttribs | dwScaleEnable
; 2030 :                     );
; 2031 : 
; 2032 :         //  Size of resized output window; picture size was set by in SetPipelineAttribs()
; 2033 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.SIZE,
; 2034 :                     DISPC_VID_SIZE_VIDSIZEX(dwDestWidth) |
; 2035 :                     DISPC_VID_SIZE_VIDSIZEY(dwDestHeight)
; 2036 :                     );

  00ea0	e59d3018	 ldr         r3, [sp, #0x18]
  00ea4	e5950008	 ldr         r0, [r5, #8]

; 2037 : 
; 2038 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.PICTURE_SIZE,
; 2039 :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEX(dwSrcWidth) |
; 2040 :                     DISPC_VID_PICTURE_SIZE_VIDORGSIZEY(dwSrcHeight)
; 2041 :                     );

  00ea8	e3e04606	 mvn         r4, #6, 12
  00eac	e2431001	 sub         r1, r3, #1
  00eb0	e59d300c	 ldr         r3, [sp, #0xC]
  00eb4	e590215c	 ldr         r2, [r0, #0x15C]

; 2042 : 
; 2043 :         //  Position of window
; 2044 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.POSITION,
; 2045 :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 2046 :                     DISPC_VID_POS_VIDPOSY(dwY)
; 2047 :                     );
; 2048 : 
; 2049 :         //  DMA properties
; 2050 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00eb8	e59d9044	 ldr         r9, [sp, #0x44]
  00ebc	e2433001	 sub         r3, r3, #1
  00ec0	e183e801	 orr         lr, r3, r1, lsl #16
  00ec4	e59d301c	 ldr         r3, [sp, #0x1C]
  00ec8	e2431001	 sub         r1, r3, #1
  00ecc	e2243e1e	 eor         r3, r4, #0x1E, 28
  00ed0	e0023003	 and         r3, r2, r3
  00ed4	e1833008	 orr         r3, r3, r8
  00ed8	e580315c	 str         r3, [r0, #0x15C]
  00edc	e5952008	 ldr         r2, [r5, #8]
  00ee0	e24b3001	 sub         r3, r11, #1
  00ee4	e1831801	 orr         r1, r3, r1, lsl #16
  00ee8	e582e158	 str         lr, [r2, #0x158]
  00eec	e5953008	 ldr         r3, [r5, #8]
  00ef0	e59d202c	 ldr         r2, [sp, #0x2C]
  00ef4	e59d0020	 ldr         r0, [sp, #0x20]
  00ef8	e5831174	 str         r1, [r3, #0x174]
  00efc	e5953008	 ldr         r3, [r5, #8]
  00f00	e180e802	 orr         lr, r0, r2, lsl #16
  00f04	e59d8030	 ldr         r8, [sp, #0x30]
  00f08	e583e154	 str         lr, [r3, #0x154]
  00f0c	e5963000	 ldr         r3, [r6]
  00f10	e1a02009	 mov         r2, r9
  00f14	e1a01008	 mov         r1, r8
  00f18	e5933018	 ldr         r3, [r3, #0x18]
  00f1c	e1a00006	 mov         r0, r6
  00f20	e1a0e00f	 mov         lr, pc
  00f24	e12fff13	 bx          r3
  00f28	e5953008	 ldr         r3, [r5, #8]

; 2051 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  00f2c	e1a02009	 mov         r2, r9
  00f30	e1a01008	 mov         r1, r8
  00f34	e583016c	 str         r0, [r3, #0x16C]
  00f38	e5963000	 ldr         r3, [r6]
  00f3c	e1a00006	 mov         r0, r6
  00f40	e593301c	 ldr         r3, [r3, #0x1C]
  00f44	e1a0e00f	 mov         lr, pc
  00f48	e12fff13	 bx          r3
  00f4c	e595e008	 ldr         lr, [r5, #8]

; 2052 : 
; 2053 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  00f50	e3a03000	 mov         r3, #0
  00f54	e1a02009	 mov         r2, r9
  00f58	e58e0168	 str         r0, [lr, #0x168]
  00f5c	e5960000	 ldr         r0, [r6]
  00f60	e1a01008	 mov         r1, r8
  00f64	e5904014	 ldr         r4, [r0, #0x14]
  00f68	e1a00006	 mov         r0, r6
  00f6c	e1a0e00f	 mov         lr, pc
  00f70	e12fff14	 bx          r4
  00f74	e59d3058	 ldr         r3, [sp, #0x58]
  00f78	e595e008	 ldr         lr, [r5, #8]

; 2054 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  00f7c	e1a02009	 mov         r2, r9
  00f80	e0803003	 add         r3, r0, r3
  00f84	e58e314c	 str         r3, [lr, #0x14C]
  00f88	e5960000	 ldr         r0, [r6]
  00f8c	e3a03000	 mov         r3, #0
  00f90	e1a01008	 mov         r1, r8
  00f94	e5904014	 ldr         r4, [r0, #0x14]
  00f98	e1a00006	 mov         r0, r6
  00f9c	e1a0e00f	 mov         lr, pc
  00fa0	e12fff14	 bx          r4
  00fa4	e5953008	 ldr         r3, [r5, #8]

; 2055 : 
; 2056 :         //  Initialize FIR accumulators
; 2057 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ACCU0,
; 2058 :                     dwAccum0
; 2059 :                     );
; 2060 : 
; 2061 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ACCU1,
; 2062 :                     dwAccum1
; 2063 :                     );
; 2064 : 
; 2065 :         //  Set FIR increment value and coeffs
; 2066 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.FIR,
; 2067 :                     DISPC_VID_FIR_VIDFIRHINC(dwHorzScale) |
; 2068 :                     DISPC_VID_FIR_VIDFIRVINC(dwVertScale)
; 2069 :                     );

  00fa8	e59d2010	 ldr         r2, [sp, #0x10]
  00fac	e59d1008	 ldr         r1, [sp, #8]
  00fb0	e5830150	 str         r0, [r3, #0x150]
  00fb4	e5953008	 ldr         r3, [r5, #8]
  00fb8	e1812802	 orr         r2, r1, r2, lsl #16
  00fbc	e59d1054	 ldr         r1, [sp, #0x54]
  00fc0	e59de000	 ldr         lr, [sp]
  00fc4	e3a04000	 mov         r4, #0
  00fc8	e5831178	 str         r1, [r3, #0x178]
  00fcc	e5953008	 ldr         r3, [r5, #8]
  00fd0	e3a01000	 mov         r1, #0
  00fd4	e3a08c02	 mov         r8, #2, 24
  00fd8	e583117c	 str         r1, [r3, #0x17C]
  00fdc	e5953008	 ldr         r3, [r5, #8]
  00fe0	e5832170	 str         r2, [r3, #0x170]
  00fe4		 |$LL3@SetScaling|

; 2070 : 
; 2071 :         for( i = 0; i < NUM_SCALING_PHASES; i++ )
; 2072 :         {
; 2073 :             //  OR the horiz and vert coeff values b/c some registers span both H and V coeffs
; 2074 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.aFIR_COEF[i].ulH,
; 2075 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 2076 :                         );

  00fe4	e5953008	 ldr         r3, [r5, #8]
  00fe8	e4970004	 ldr         r0, [r7], #4
  00fec	e49e2004	 ldr         r2, [lr], #4
  00ff0	e0831004	 add         r1, r3, r4
  00ff4	e1803002	 orr         r3, r0, r2
  00ff8	e5813180	 str         r3, [r1, #0x180]

; 2077 : 
; 2078 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.aFIR_COEF[i].ulHV,
; 2079 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 2080 :                         );

  00ffc	e5953008	 ldr         r3, [r5, #8]
  01000	e4970004	 ldr         r0, [r7], #4
  01004	e49e2004	 ldr         r2, [lr], #4
  01008	e0831004	 add         r1, r3, r4
  0100c	e2844008	 add         r4, r4, #8

; 2081 : 
; 2082 :             OUTREG32( &m_pDispRegs->DISPC_VID2_FIR_COEF_V[i],
; 2083 :                         *pHorizCoeffs++ | *pVertCoeffs++
; 2084 :                         );

  01010	e3540040	 cmp         r4, #0x40
  01014	e1803002	 orr         r3, r0, r2
  01018	e5813184	 str         r3, [r1, #0x184]
  0101c	e4972004	 ldr         r2, [r7], #4
  01020	e49e3004	 ldr         r3, [lr], #4
  01024	e5951008	 ldr         r1, [r5, #8]
  01028	e1823003	 orr         r3, r2, r3
  0102c	e7813008	 str         r3, [r1, +r8]
  01030	e2888004	 add         r8, r8, #4
  01034	3affffea	 bcc         |$LL3@SetScaling|

; 1128 : {

  01038	e59d4024	 ldr         r4, [sp, #0x24]
  0103c		 |$LN1@SetScaling|

; 2085 :         }
; 2086 : 
; 2087 :         Dump_DISPC_VID( &m_pDispRegs->tDISPC_VID2, (UINT32*) &m_pDispRegs->DISPC_VID2_FIR_COEF_V[0], 2 );
; 2088 :     }
; 2089 : 
; 2090 : 
; 2091 :     //  Update output width and height
; 2092 :     g_rgPipelineMapping[ePipeline].dwDestWidth  = dwDestWidth;
; 2093 :     g_rgPipelineMapping[ePipeline].dwDestHeight = dwDestHeight;
; 2094 : 
; 2095 :     //  Cache the decimation factors applied to the source surface
; 2096 :     g_rgPipelineScaling[ePipeline].dwHorzScaling = dwHorzDecimation;

  0103c	e59fe094	 ldr         lr, [pc, #0x94]
  01040	e59d300c	 ldr         r3, [sp, #0xC]
  01044	e59f1088	 ldr         r1, [pc, #0x88]
  01048	e08e0284	 add         r0, lr, r4, lsl #5

; 2097 :     g_rgPipelineScaling[ePipeline].dwVertScaling = dwVertDecimation;

  0104c	e59de014	 ldr         lr, [sp, #0x14]
  01050	e0842084	 add         r2, r4, r4, lsl #1
  01054	e5803014	 str         r3, [r0, #0x14]
  01058	e0813102	 add         r3, r1, r2, lsl #2
  0105c	e583e004	 str         lr, [r3, #4]

; 2098 :     g_rgPipelineScaling[ePipeline].dwInterlace   = dwInterlace;

  01060	e59de058	 ldr         lr, [sp, #0x58]
  01064	e583e008	 str         lr, [r3, #8]
  01068	e59d3018	 ldr         r3, [sp, #0x18]
  0106c	e5803018	 str         r3, [r0, #0x18]
  01070	e59d3028	 ldr         r3, [sp, #0x28]

; 2099 : 
; 2100 :     //  Set the decimation factors for the surface back to normal
; 2101 :     pSurface->SetHorizontalScaling( 1 );

  01074	e1a00006	 mov         r0, r6
  01078	e7813102	 str         r3, [r1, +r2, lsl #2]
  0107c	e5963000	 ldr         r3, [r6]
  01080	e3a01001	 mov         r1, #1
  01084	e5933030	 ldr         r3, [r3, #0x30]
  01088	e1a0e00f	 mov         lr, pc
  0108c	e12fff13	 bx          r3

; 2102 :     pSurface->SetVerticalScaling( 1 );

  01090	e5963000	 ldr         r3, [r6]
  01094	e3a01001	 mov         r1, #1
  01098	e1a00006	 mov         r0, r6
  0109c	e5933034	 ldr         r3, [r3, #0x34]
  010a0	e1a0e00f	 mov         lr, pc
  010a4	e12fff13	 bx          r3

; 2103 : 
; 2104 : 
; 2105 :     //  Result
; 2106 :     bResult = TRUE;

  010a8	e3a03001	 mov         r3, #1
  010ac	e58d3010	 str         r3, [sp, #0x10]
  010b0		 |$cleanUp$38236|

; 2107 : 
; 2108 : cleanUp:
; 2109 :     //  Release regs
; 2110 :     ReleaseRegs();

  010b0	e2853b01	 add         r3, r5, #1, 22
  010b4	e283008c	 add         r0, r3, #0x8C
  010b8	eb000000	 bl          LeaveCriticalSection

; 2111 : 
; 2112 :     //  Return result
; 2113 :     return bResult;

  010bc	e59d0160	 ldr         r0, [sp, #0x160]
  010c0	eb000000	 bl          __security_check_cookie

; 2114 : }

  010c4	e59d0010	 ldr         r0, [sp, #0x10]
  010c8	e28ddf59	 add         sp, sp, #0x59, 30
  010cc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  010d0	e12fff1e	 bx          lr
  010d4		 |$LN230@SetScaling|
  010d4		 |$LN231@SetScaling|
  010d4	00000000	 DCD         |?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A|
  010d8		 |$LN232@SetScaling|
  010d8	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  010dc		 |$LN233@SetScaling|
  010dc	00000000	 DCD         |??_C@_1JI@NGBENMPF@?$AAS?$AAe?$AAt?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AAA?$AAt?$AAt?$AAr?$AAi?$AAb?$AAs?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAc?$AAo?$AAn?$AAf?$AAi?$AAg@|
  010e0		 |$LN234@SetScaling|
  010e0	00000000	 DCD         |?g_dwScalingCoeff_Vert_Down_5_Taps@@3PAKA|
  010e4		 |$LN235@SetScaling|
  010e4	00000000	 DCD         |?g_dwScalingCoeff_Vert_Down_3_Taps@@3PAKA|
  010e8		 |$LN236@SetScaling|
  010e8	00000000	 DCD         |?g_dwScalingCoeff_Vert_Up_3_Taps@@3PAKA|
  010ec		 |$LN237@SetScaling|
  010ec	00000000	 DCD         |?g_dwScalingCoeff_Horiz_Up@@3PAKA|
  010f0		 |$LN238@SetScaling|
  010f0	00000000	 DCD         |?g_dwScalingCoeff_Horiz_Down@@3PAKA|
  010f4		 |$LN239@SetScaling|
  010f4	aaaaaaab	 DCD         0xaaaaaaab
  010f8		 |$M41457|

			 ENDP  ; |?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z|, OMAPDisplayController::SetScalingAttribs

	EXPORT	|?FlipPipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAVOMAPSurface@@@Z| ; OMAPDisplayController::FlipPipeline

  00000			 AREA	 |.pdata|, PDATA
|$T41512| DCD	|$LN29@FlipPipeli|
	DCD	0x4000c402
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?FlipPipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAVOMAPSurface@@@Z| PROC ; OMAPDisplayController::FlipPipeline

; 2522 : {

  00000		 |$LN29@FlipPipeli|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd018	 sub         sp, sp, #0x18
  00008		 |$M41509|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e1a07000	 mov         r7, r0

; 2523 :     BOOL    bResult = FALSE;
; 2524 :     DWORD   dwDestGo;
; 2525 :     OMAP_DSS_ROTATION   eRotation;
; 2526 :     BOOL                bMirror;
; 2527 :     DWORD               dwInterlace;
; 2528 : 
; 2529 : 
; 2530 :     //  Check if pipeline is already enabled; if not, no reason to flip
; 2531 :     if( g_rgPipelineMapping[ePipeline].bEnabled == FALSE )

  00014	e59f42f0	 ldr         r4, [pc, #0x2F0]
  00018	e3a0a000	 mov         r10, #0
  0001c	e7943288	 ldr         r3, [r4, +r8, lsl #5]
  00020	e3530000	 cmp         r3, #0

; 2532 :         return FALSE;

  00024	03a0a000	 moveq       r10, #0
  00028	0a0000b2	 beq         |$LN15@FlipPipeli|

; 2533 : 
; 2534 :     //  Access the regs
; 2535 :     if( AccessRegs() == FALSE )

  0002c	e1a00007	 mov         r0, r7
  00030	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00034	e3500000	 cmp         r0, #0
  00038	0a0000ab	 beq         |$cleanUp$38627|

; 2536 :         goto cleanUp;
; 2537 : 
; 2538 :         
; 2539 :     //  Get rotation and mirror settings for pipeline output
; 2540 :     eRotation = g_rgPipelineMapping[ePipeline].eRotation;
; 2541 :     bMirror   = g_rgPipelineMapping[ePipeline].bMirror;
; 2542 :     dwInterlace = g_rgPipelineScaling[ePipeline].dwInterlace;
; 2543 : 
; 2544 :     //Update clipping rectangle
; 2545 : #pragma warning(push)
; 2546 : #pragma warning(disable:4238)
; 2547 :     pSurface->SetClipping(&(g_rgPipelineMapping[ePipeline].pSurface->GetClipping()));    

  0003c	e59f22c4	 ldr         r2, [pc, #0x2C4]
  00040	e0849288	 add         r9, r4, r8, lsl #5
  00044	e5990008	 ldr         r0, [r9, #8]
  00048	e0883088	 add         r3, r8, r8, lsl #1
  0004c	e0822103	 add         r2, r2, r3, lsl #2
  00050	e590e000	 ldr         lr, [r0]
  00054	e5922008	 ldr         r2, [r2, #8]
  00058	e599500c	 ldr         r5, [r9, #0xC]
  0005c	e59e3028	 ldr         r3, [lr, #0x28]
  00060	e599b010	 ldr         r11, [r9, #0x10]
  00064	e58d2000	 str         r2, [sp]
  00068	e28d1008	 add         r1, sp, #8
  0006c	e58d5004	 str         r5, [sp, #4]
  00070	e1a0e00f	 mov         lr, pc
  00074	e12fff13	 bx          r3
  00078	e5963000	 ldr         r3, [r6]
  0007c	e1a01000	 mov         r1, r0
  00080	e1a00006	 mov         r0, r6
  00084	e5933020	 ldr         r3, [r3, #0x20]
  00088	e1a0e00f	 mov         lr, pc
  0008c	e12fff13	 bx          r3

; 2548 : 
; 2549 :     /* check for resizer */
; 2550 :     if (pSurface->isResizerEnabled())

  00090	e5963030	 ldr         r3, [r6, #0x30]
  00094	e3530000	 cmp         r3, #0
  00098	0a000023	 beq         |$LN11@FlipPipeli|

; 2551 :     {
; 2552 :         pSurface->OmapAssocSurface()->SetClipping(
; 2553 :             &(g_rgPipelineMapping[ePipeline].pSurface->OmapAssocSurface()->GetClipping()));

  0009c	e5993008	 ldr         r3, [r9, #8]
  000a0	e28d1008	 add         r1, sp, #8
  000a4	e59300a0	 ldr         r0, [r3, #0xA0]
  000a8	e5903000	 ldr         r3, [r0]
  000ac	e5933028	 ldr         r3, [r3, #0x28]
  000b0	e1a0e00f	 mov         lr, pc
  000b4	e12fff13	 bx          r3
  000b8	e59620a0	 ldr         r2, [r6, #0xA0]
  000bc	e1a01000	 mov         r1, r0
  000c0	e5923000	 ldr         r3, [r2]
  000c4	e1a00002	 mov         r0, r2
  000c8	e5933020	 ldr         r3, [r3, #0x20]
  000cc	e1a0e00f	 mov         lr, pc
  000d0	e12fff13	 bx          r3

; 2554 :         pSurface->StartResizer(pSurface->PhysicalAddr(OMAP_DSS_ROTATION_0, bMirror,OMAP_ASSOC_SURF_FORCE_OFF), //input
; 2555 :                                pSurface->OmapAssocSurface()->PhysicalAddr(OMAP_DSS_ROTATION_0, bMirror,OMAP_ASSOC_SURF_FORCE_OFF));            

  000d4	e59600a0	 ldr         r0, [r6, #0xA0]
  000d8	e3a03001	 mov         r3, #1
  000dc	e1a0200b	 mov         r2, r11
  000e0	e590e000	 ldr         lr, [r0]
  000e4	e3a01000	 mov         r1, #0
  000e8	e59e4014	 ldr         r4, [lr, #0x14]
  000ec	e1a0e00f	 mov         lr, pc
  000f0	e12fff14	 bx          r4
  000f4	e5962000	 ldr         r2, [r6]
  000f8	e1a05000	 mov         r5, r0
  000fc	e3a03001	 mov         r3, #1
  00100	e5924014	 ldr         r4, [r2, #0x14]
  00104	e1a0200b	 mov         r2, r11
  00108	e3a01000	 mov         r1, #0
  0010c	e1a00006	 mov         r0, r6
  00110	e1a0e00f	 mov         lr, pc
  00114	e12fff14	 bx          r4
  00118	e1a01000	 mov         r1, r0
  0011c	e1a00006	 mov         r0, r6
  00120	e1a02005	 mov         r2, r5
  00124	eb000000	 bl          |?StartResizer@OMAPSurface@@QAAHKK@Z|
  00128	e59d5004	 ldr         r5, [sp, #4]
  0012c		 |$LN11@FlipPipeli|

; 2556 :     }
; 2557 : #pragma warning(pop)    
; 2558 : 
; 2559 :     //  Update GFX pipeline display base address
; 2560 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  0012c	e3580000	 cmp         r8, #0
  00130	1a000015	 bne         |$LN10@FlipPipeli|

; 2561 :     {
; 2562 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA0, pSurface->PhysicalAddr(eRotation, bMirror) );

  00134	e5961000	 ldr         r1, [r6]
  00138	e3a03000	 mov         r3, #0
  0013c	e1a0200b	 mov         r2, r11
  00140	e5914014	 ldr         r4, [r1, #0x14]
  00144	e1a01005	 mov         r1, r5
  00148	e1a00006	 mov         r0, r6
  0014c	e1a0e00f	 mov         lr, pc
  00150	e12fff14	 bx          r4
  00154	e5972008	 ldr         r2, [r7, #8]

; 2563 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA1, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  00158	e3a03000	 mov         r3, #0
  0015c	e1a01005	 mov         r1, r5
  00160	e5820080	 str         r0, [r2, #0x80]
  00164	e5960000	 ldr         r0, [r6]
  00168	e1a0200b	 mov         r2, r11
  0016c	e5904014	 ldr         r4, [r0, #0x14]
  00170	e1a00006	 mov         r0, r6
  00174	e1a0e00f	 mov         lr, pc
  00178	e12fff14	 bx          r4
  0017c	e59d3000	 ldr         r3, [sp]
  00180	e5972008	 ldr         r2, [r7, #8]
  00184	e0803003	 add         r3, r0, r3
  00188	e5823084	 str         r3, [r2, #0x84]
  0018c		 |$LN10@FlipPipeli|

; 2564 :     }    
; 2565 : 
; 2566 :     //  Update VID1 pipeline display base address
; 2567 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  0018c	e3580001	 cmp         r8, #1
  00190	1a000015	 bne         |$LN9@FlipPipeli|

; 2568 :     {
; 2569 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA0, pSurface->PhysicalAddr(eRotation, bMirror)+ dwInterlace );

  00194	e5961000	 ldr         r1, [r6]
  00198	e3a03000	 mov         r3, #0
  0019c	e1a0200b	 mov         r2, r11
  001a0	e5914014	 ldr         r4, [r1, #0x14]
  001a4	e1a01005	 mov         r1, r5
  001a8	e1a00006	 mov         r0, r6
  001ac	e1a0e00f	 mov         lr, pc
  001b0	e12fff14	 bx          r4
  001b4	e59d3000	 ldr         r3, [sp]
  001b8	e5972008	 ldr         r2, [r7, #8]
  001bc	e0803003	 add         r3, r0, r3
  001c0	e58230bc	 str         r3, [r2, #0xBC]

; 2570 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );        

  001c4	e5961000	 ldr         r1, [r6]
  001c8	e3a03000	 mov         r3, #0
  001cc	e1a0200b	 mov         r2, r11
  001d0	e5914014	 ldr         r4, [r1, #0x14]
  001d4	e1a01005	 mov         r1, r5
  001d8	e1a00006	 mov         r0, r6
  001dc	e1a0e00f	 mov         lr, pc
  001e0	e12fff14	 bx          r4
  001e4	e5973008	 ldr         r3, [r7, #8]
  001e8	e58300c0	 str         r0, [r3, #0xC0]
  001ec		 |$LN9@FlipPipeli|

; 2571 :     }    
; 2572 : 
; 2573 :     //  Update VID2 pipeline display base address
; 2574 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  001ec	e3580002	 cmp         r8, #2
  001f0	1a000015	 bne         |$LN8@FlipPipeli|

; 2575 :     {
; 2576 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  001f4	e5960000	 ldr         r0, [r6]
  001f8	e3a03000	 mov         r3, #0
  001fc	e1a0200b	 mov         r2, r11
  00200	e5904014	 ldr         r4, [r0, #0x14]
  00204	e1a00006	 mov         r0, r6
  00208	e1a01005	 mov         r1, r5
  0020c	e1a0e00f	 mov         lr, pc
  00210	e12fff14	 bx          r4
  00214	e59d3000	 ldr         r3, [sp]
  00218	e597e008	 ldr         lr, [r7, #8]

; 2577 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  0021c	e1a0200b	 mov         r2, r11
  00220	e0803003	 add         r3, r0, r3
  00224	e58e314c	 str         r3, [lr, #0x14C]
  00228	e5960000	 ldr         r0, [r6]
  0022c	e3a03000	 mov         r3, #0
  00230	e1a01005	 mov         r1, r5
  00234	e5904014	 ldr         r4, [r0, #0x14]
  00238	e1a00006	 mov         r0, r6
  0023c	e1a0e00f	 mov         lr, pc
  00240	e12fff14	 bx          r4
  00244	e5973008	 ldr         r3, [r7, #8]
  00248	e5830150	 str         r0, [r3, #0x150]
  0024c		 |$LN8@FlipPipeli|

; 2578 :     }    
; 2579 : 
; 2580 :         
; 2581 :     //  Get the destination for the pipeline
; 2582 :     switch( g_rgPipelineMapping[ePipeline].eDestination )

  0024c	e5993004	 ldr         r3, [r9, #4]
  00250	e3530000	 cmp         r3, #0
  00254	0a000003	 beq         |$LN5@FlipPipeli|
  00258	e3530001	 cmp         r3, #1
  0025c	1a000022	 bne         |$cleanUp$38627|

; 2587 :             break;
; 2588 : 
; 2589 :         case OMAP_DSS_DESTINATION_TVOUT:
; 2590 :             //  Set go bit for TV Out
; 2591 :             dwDestGo  = DISPC_CONTROL_GODIGITAL;

  00260	e3a01040	 mov         r1, #0x40

; 2592 :             break;

  00264	ea000000	 b           |$LN6@FlipPipeli|
  00268		 |$LN5@FlipPipeli|

; 2583 :     {
; 2584 :         case OMAP_DSS_DESTINATION_LCD:
; 2585 :             //  Set go bit for LCD
; 2586 :             dwDestGo  = DISPC_CONTROL_GOLCD;

  00268	e3a01020	 mov         r1, #0x20
  0026c		 |$LN6@FlipPipeli|

; 2593 : 
; 2594 :         default:
; 2595 :             ASSERT(0);
; 2596 :             goto cleanUp;
; 2597 :     }
; 2598 : 
; 2599 :     //Clear Vysnc since we are about to flip (to avoid false signaling Vsync event)
; 2600 :     SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_VSYNC);

  0026c	e5972008	 ldr         r2, [r7, #8]

; 2601 :     if(m_bTVEnable == TRUE)
; 2602 :     {
; 2603 :         SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_EVSYNC_EVEN);
; 2604 :         SETREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_EVSYNC_ODD);        
; 2605 :     }
; 2606 :     //  Flush the shadow registers
; 2607 :     FlushRegs( dwDestGo );

  00270	e1a00007	 mov         r0, r7
  00274	e5923018	 ldr         r3, [r2, #0x18]
  00278	e3833002	 orr         r3, r3, #2
  0027c	e5823018	 str         r3, [r2, #0x18]
  00280	e59734b4	 ldr         r3, [r7, #0x4B4]
  00284	e3530001	 cmp         r3, #1
  00288	05972008	 ldreq       r2, [r7, #8]
  0028c	05923018	 ldreq       r3, [r2, #0x18]
  00290	03833004	 orreq       r3, r3, #4
  00294	05823018	 streq       r3, [r2, #0x18]
  00298	05972008	 ldreq       r2, [r7, #8]
  0029c	05923018	 ldreq       r3, [r2, #0x18]
  002a0	03833008	 orreq       r3, r3, #8
  002a4	05823018	 streq       r3, [r2, #0x18]
  002a8	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 2608 :     
; 2609 :     //  Update mapping of pipeline surface    
; 2610 :     g_rgPipelineMapping[ePipeline].pOldSurface = g_rgPipelineMapping[ePipeline].pSurface;

  002ac	e5993008	 ldr         r3, [r9, #8]

; 2611 :     g_rgPipelineMapping[ePipeline].pSurface  = pSurface;

  002b0	e5896008	 str         r6, [r9, #8]

; 2612 :     
; 2613 :     //  Set the decimation factors for the surface back to normal
; 2614 :     //  Leave the clipping setting as is
; 2615 :     pSurface->SetHorizontalScaling( 1 );

  002b4	e3a01001	 mov         r1, #1
  002b8	e589301c	 str         r3, [r9, #0x1C]
  002bc	e5963000	 ldr         r3, [r6]
  002c0	e1a00006	 mov         r0, r6
  002c4	e5933030	 ldr         r3, [r3, #0x30]
  002c8	e1a0e00f	 mov         lr, pc
  002cc	e12fff13	 bx          r3

; 2616 :     pSurface->SetVerticalScaling( 1 );

  002d0	e5963000	 ldr         r3, [r6]
  002d4	e3a01001	 mov         r1, #1
  002d8	e1a00006	 mov         r0, r6
  002dc	e5933034	 ldr         r3, [r3, #0x34]
  002e0	e1a0e00f	 mov         lr, pc
  002e4	e12fff13	 bx          r3

; 2617 : 
; 2618 : 
; 2619 :     //  Result
; 2620 :     bResult = TRUE;         

  002e8	e3a0a001	 mov         r10, #1
  002ec		 |$cleanUp$38627|

; 2621 : 
; 2622 : cleanUp:    
; 2623 :     //  Release regs
; 2624 :     ReleaseRegs();

  002ec	e2873b01	 add         r3, r7, #1, 22
  002f0	e283008c	 add         r0, r3, #0x8C
  002f4	eb000000	 bl          LeaveCriticalSection

; 2625 :     
; 2626 :     //  Return result
; 2627 :     return bResult;

  002f8		 |$LN15@FlipPipeli|

; 2628 : }

  002f8	e1a0000a	 mov         r0, r10
  002fc	e28dd018	 add         sp, sp, #0x18
  00300	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00304	e12fff1e	 bx          lr
  00308		 |$LN30@FlipPipeli|
  00308		 |$LN31@FlipPipeli|
  00308	00000000	 DCD         |?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A|
  0030c		 |$LN32@FlipPipeli|
  0030c	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00310		 |$M41510|

			 ENDP  ; |?FlipPipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAVOMAPSurface@@@Z|, OMAPDisplayController::FlipPipeline

	EXPORT	|?IsPipelineFlipping@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAVOMAPSurface@@H@Z| ; OMAPDisplayController::IsPipelineFlipping

  00000			 AREA	 |.pdata|, PDATA
|$T41546| DCD	|$LN30@IsPipeline|
	DCD	0x40004f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?IsPipelineFlipping@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAVOMAPSurface@@H@Z| PROC ; OMAPDisplayController::IsPipelineFlipping

; 2637 : {

  00000		 |$LN30@IsPipeline|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M41543|
  00004	e1a09003	 mov         r9, r3
  00008	e1a0b002	 mov         r11, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a07000	 mov         r7, r0

; 2638 :     BOOL                bResult = FALSE;
; 2639 :     OMAP_DSS_ROTATION   eRotation;
; 2640 :     BOOL                bMirror;
; 2641 :     DWORD               dwDestGo = DISPC_CONTROL_GOLCD;
; 2642 :     
; 2643 :     BOOL                bDestGoStatus = FALSE;
; 2644 : 
; 2645 :      //  Check if pipeline is already enabled; if not, no reason to query flip status
; 2646 :     if( g_rgPipelineMapping[ePipeline].bEnabled == FALSE )

  00014	e59f811c	 ldr         r8, [pc, #0x11C]
  00018	e3a04000	 mov         r4, #0
  0001c	e3a06020	 mov         r6, #0x20
  00020	e798e285	 ldr         lr, [r8, +r5, lsl #5]
  00024	e35e0000	 cmp         lr, #0

; 2647 :         return FALSE;

  00028	03a04000	 moveq       r4, #0
  0002c	0a00003e	 beq         |$LN14@IsPipeline|

; 2648 : 
; 2649 :     //  Access the regs
; 2650 :     if( AccessRegs() == FALSE )

  00030	e1a00007	 mov         r0, r7
  00034	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00038	e3500000	 cmp         r0, #0
  0003c	0a000037	 beq         |$cleanUp$38679|

; 2651 :         goto cleanUp;
; 2652 : 
; 2653 :     //  Get rotation and mirror settings for pipeline output
; 2654 :     eRotation   = g_rgPipelineMapping[ePipeline].eRotation;

  00040	e0883285	 add         r3, r8, r5, lsl #5

; 2655 :     bMirror     = g_rgPipelineMapping[ePipeline].bMirror;
; 2656 : 
; 2657 :     //  Get the destination for the pipeline
; 2658 :     switch( g_rgPipelineMapping[ePipeline].eDestination )

  00044	e5932004	 ldr         r2, [r3, #4]
  00048	e593800c	 ldr         r8, [r3, #0xC]
  0004c	e593a010	 ldr         r10, [r3, #0x10]
  00050	e3520000	 cmp         r2, #0
  00054	0a000003	 beq         |$LN8@IsPipeline|
  00058	e3520001	 cmp         r2, #1
  0005c	1a000002	 bne         |$LN9@IsPipeline|

; 2663 :             break;
; 2664 : 
; 2665 :         case OMAP_DSS_DESTINATION_TVOUT:
; 2666 :             //  Set go bit for TV Out
; 2667 :             dwDestGo  = DISPC_CONTROL_GODIGITAL;

  00060	e3a06040	 mov         r6, #0x40

; 2668 :             break;

  00064	ea000000	 b           |$LN9@IsPipeline|
  00068		 |$LN8@IsPipeline|

; 2659 :     {
; 2660 :         case OMAP_DSS_DESTINATION_LCD:
; 2661 :             //  Set go bit for LCD
; 2662 :             dwDestGo  = DISPC_CONTROL_GOLCD;

  00068	e3a06020	 mov         r6, #0x20
  0006c		 |$LN9@IsPipeline|

; 2669 :     }
; 2670 : 
; 2671 :     //Test if we have already flipped (destGo has been cleared)
; 2672 :     bDestGoStatus = ((INREG32(&m_pDispRegs->DISPC_CONTROL) & dwDestGo) == dwDestGo);

  0006c	e5973008	 ldr         r3, [r7, #8]
  00070	e5933040	 ldr         r3, [r3, #0x40]
  00074	e0033006	 and         r3, r3, r6
  00078	e1530006	 cmp         r3, r6
  0007c	03a04001	 moveq       r4, #1
  00080	13a04000	 movne       r4, #0

; 2673 :     
; 2674 :     if (!matchExactSurface)

  00084	e3590000	 cmp         r9, #0

; 2710 : 
; 2711 : cleanUp:

  00088	0a000024	 beq         |$cleanUp$38679|

; 2675 :     {
; 2676 :         /* return value based on Go bit only */
; 2677 :         bResult=bDestGoStatus;
; 2678 :         goto cleanUp;
; 2679 :     }
; 2680 : 
; 2681 :     /* else check for BA0 and pOldSurface */
; 2682 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  0008c	e3550000	 cmp         r5, #0
  00090	1a000009	 bne         |$LN18@IsPipeline|

; 2683 :     {
; 2684 :         bResult = (INREG32(&m_pDispRegs->DISPC_GFX_BA0) == pSurface->PhysicalAddr(eRotation, bMirror));            

  00094	e59b1000	 ldr         r1, [r11]
  00098	e3a03000	 mov         r3, #0
  0009c	e1a0200a	 mov         r2, r10
  000a0	e5914014	 ldr         r4, [r1, #0x14]
  000a4	e1a01008	 mov         r1, r8
  000a8	e1a0000b	 mov         r0, r11
  000ac	e1a0e00f	 mov         lr, pc
  000b0	e12fff14	 bx          r4
  000b4	e5973008	 ldr         r3, [r7, #8]
  000b8	e5933080	 ldr         r3, [r3, #0x80]
  000bc		 |$LN18@IsPipeline|

; 2685 :     }
; 2686 : 
; 2687 :     //  check VID1 pipeline display base address
; 2688 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  000bc	e3550001	 cmp         r5, #1
  000c0	1a000009	 bne         |$LN20@IsPipeline|

; 2689 :     {
; 2690 :         bResult = INREG32(&m_pDispRegs->tDISPC_VID1.BA1) == pSurface->PhysicalAddr(eRotation, bMirror);

  000c4	e59b0000	 ldr         r0, [r11]
  000c8	e3a03000	 mov         r3, #0
  000cc	e1a0200a	 mov         r2, r10
  000d0	e5904014	 ldr         r4, [r0, #0x14]
  000d4	e1a0000b	 mov         r0, r11
  000d8	e1a01008	 mov         r1, r8
  000dc	e1a0e00f	 mov         lr, pc
  000e0	e12fff14	 bx          r4
  000e4	e5973008	 ldr         r3, [r7, #8]
  000e8	e59330c0	 ldr         r3, [r3, #0xC0]
  000ec		 |$LN20@IsPipeline|

; 2691 :     }
; 2692 : 
; 2693 :     //  check VID2 pipeline display base address
; 2694 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  000ec	e3550002	 cmp         r5, #2
  000f0	1a000009	 bne         |$LN22@IsPipeline|

; 2695 :     {
; 2696 :         bResult = INREG32(&m_pDispRegs->tDISPC_VID2.BA1) == pSurface->PhysicalAddr(eRotation, bMirror);

  000f4	e59b0000	 ldr         r0, [r11]
  000f8	e3a03000	 mov         r3, #0
  000fc	e1a0200a	 mov         r2, r10
  00100	e5904014	 ldr         r4, [r0, #0x14]
  00104	e1a0000b	 mov         r0, r11
  00108	e1a01008	 mov         r1, r8
  0010c	e1a0e00f	 mov         lr, pc
  00110	e12fff14	 bx          r4
  00114	e5973008	 ldr         r3, [r7, #8]
  00118	e5933150	 ldr         r3, [r3, #0x150]
  0011c		 |$LN22@IsPipeline|

; 2697 :     }
; 2698 :     
; 2699 :     //Test if we have are flipping (destGo has not been cleared)
; 2700 :     if(bDestGoStatus)
; 2701 :     {       
; 2702 :         /* Since destGo is pending the shadow register is different than actual BA0 being DMA'ed out.
; 2703 :            So compare the surfaces. The g_rgPipelineMapping.pOldSurface stores the actual surface being DMA'ed out if the GO Bit is not cleared*/        
; 2704 :         bResult |= (g_rgPipelineMapping[ePipeline].pOldSurface == pSurface);
; 2705 :     }       
; 2706 :     
; 2707 : 
; 2708 :     //  Result
; 2709 :     bResult = TRUE;

  0011c	e3a04001	 mov         r4, #1
  00120		 |$cleanUp$38679|

; 2712 :     //  Release regs
; 2713 :     ReleaseRegs();

  00120	e2873b01	 add         r3, r7, #1, 22
  00124	e283008c	 add         r0, r3, #0x8C
  00128	eb000000	 bl          LeaveCriticalSection

; 2714 : 
; 2715 :     //  Return result
; 2716 :     return bResult;

  0012c		 |$LN14@IsPipeline|

; 2717 : 
; 2718 : }

  0012c	e1a00004	 mov         r0, r4
  00130	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN31@IsPipeline|
  00138		 |$LN32@IsPipeline|
  00138	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  0013c		 |$M41544|

			 ENDP  ; |?IsPipelineFlipping@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAVOMAPSurface@@H@Z|, OMAPDisplayController::IsPipelineFlipping

	EXPORT	|?MovePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@JJ@Z| ; OMAPDisplayController::MovePipeline

  00000			 AREA	 |.pdata|, PDATA
|$T41584| DCD	|$LN33@MovePipeli|
	DCD	0x40005401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MovePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@JJ@Z| PROC ; OMAPDisplayController::MovePipeline

; 2726 : {

  00000		 |$LN33@MovePipeli|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M41581|
  00004	e1a09003	 mov         r9, r3
  00008	e1a05002	 mov         r5, r2
  0000c	e1a07001	 mov         r7, r1
  00010	e1a04000	 mov         r4, r0

; 2727 :     BOOL    bResult = FALSE;
; 2728 :     DWORD   dwDestGo = DISPC_CONTROL_GOLCD;
; 2729 :     DWORD   dwX, dwY;
; 2730 :     
; 2731 : 
; 2732 :     //  Check if pipeline is enabled; ignore operation if not
; 2733 :     if( g_rgPipelineMapping[ePipeline].bEnabled == FALSE )

  00014	e59fa130	 ldr         r10, [pc, #0x130]
  00018	e3a06000	 mov         r6, #0
  0001c	e3a08020	 mov         r8, #0x20
  00020	e79ae287	 ldr         lr, [r10, +r7, lsl #5]
  00024	e35e0000	 cmp         lr, #0

; 2734 :         return FALSE;

  00028	03a06000	 moveq       r6, #0
  0002c	0a000043	 beq         |$LN19@MovePipeli|

; 2735 : 
; 2736 :     //  Access the regs
; 2737 :     if( AccessRegs() == FALSE )

  00030	e1a00004	 mov         r0, r4
  00034	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00038	e3500000	 cmp         r0, #0
  0003c	0a00003c	 beq         |$cleanUp$38709|

; 2738 :         goto cleanUp;
; 2739 : 
; 2740 :     //  Compute new origin based on pipeline rotation angle
; 2741 :     switch( g_rgPipelineMapping[ePipeline].eRotation )

  00040	e08ae287	 add         lr, r10, r7, lsl #5
  00044	e59e300c	 ldr         r3, [lr, #0xC]
  00048	e1b02003	 movs        r2, r3
  0004c	0a00001b	 beq         |$LN13@MovePipeli|
  00050	e352005a	 cmp         r2, #0x5A
  00054	0a000013	 beq         |$LN12@MovePipeli|
  00058	e35200b4	 cmp         r2, #0xB4
  0005c	0a000008	 beq         |$LN11@MovePipeli|
  00060	e3a03c01	 mov         r3, #1, 24
  00064	e383300e	 orr         r3, r3, #0xE
  00068	e1520003	 cmp         r2, r3
  0006c	1a000030	 bne         |$cleanUp$38709|

; 2757 :             
; 2758 :         case OMAP_DSS_ROTATION_270:
; 2759 :             dwX = GetLCDWidth() - g_rgPipelineMapping[ePipeline].dwDestWidth - lYPos;

  00070	e59424a8	 ldr         r2, [r4, #0x4A8]
  00074	e59e3014	 ldr         r3, [lr, #0x14]

; 2760 :             dwY = lXPos;

  00078	e0423003	 sub         r3, r2, r3
  0007c	e0431009	 sub         r1, r3, r9

; 2761 :             break;

  00080	ea000010	 b           |$LN14@MovePipeli|
  00084		 |$LN11@MovePipeli|

; 2752 :             
; 2753 :         case OMAP_DSS_ROTATION_180:
; 2754 :             dwX = GetLCDWidth() - g_rgPipelineMapping[ePipeline].dwDestWidth - lXPos;

  00084	e59414a8	 ldr         r1, [r4, #0x4A8]
  00088	e59e3014	 ldr         r3, [lr, #0x14]

; 2755 :             dwY = GetLCDHeight() - g_rgPipelineMapping[ePipeline].dwDestHeight - lYPos;

  0008c	e59404ac	 ldr         r0, [r4, #0x4AC]
  00090	e59e2018	 ldr         r2, [lr, #0x18]
  00094	e0413003	 sub         r3, r1, r3
  00098	e0431005	 sub         r1, r3, r5
  0009c	e0403002	 sub         r3, r0, r2
  000a0	e0435009	 sub         r5, r3, r9

; 2756 :             break;

  000a4	ea000007	 b           |$LN14@MovePipeli|
  000a8		 |$LN12@MovePipeli|

; 2746 :             break;
; 2747 :             
; 2748 :         case OMAP_DSS_ROTATION_90:
; 2749 :             dwX = lYPos;
; 2750 :             dwY = GetLCDHeight() - g_rgPipelineMapping[ePipeline].dwDestHeight - lXPos;

  000a8	e59424ac	 ldr         r2, [r4, #0x4AC]
  000ac	e59e3018	 ldr         r3, [lr, #0x18]
  000b0	e1a01009	 mov         r1, r9
  000b4	e0423003	 sub         r3, r2, r3
  000b8	e0435005	 sub         r5, r3, r5

; 2751 :             break;

  000bc	ea000001	 b           |$LN14@MovePipeli|
  000c0		 |$LN13@MovePipeli|

; 2742 :     {
; 2743 :         case OMAP_DSS_ROTATION_0:
; 2744 :             dwX = lXPos;

  000c0	e1a01005	 mov         r1, r5

; 2745 :             dwY = lYPos;

  000c4	e1a05009	 mov         r5, r9
  000c8		 |$LN14@MovePipeli|

; 2762 : 
; 2763 :         default:
; 2764 :             ASSERT(0);
; 2765 :             goto cleanUp;
; 2766 :     }
; 2767 : 
; 2768 : 
; 2769 :     //  Update GFX pipeline display position
; 2770 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  000c8	e3570000	 cmp         r7, #0

; 2771 :     {
; 2772 :         OUTREG32( &m_pDispRegs->DISPC_GFX_POSITION,
; 2773 :                     DISPC_GFX_POS_GFXPOSX(dwX) |
; 2774 :                     DISPC_GFX_POS_GFXPOSY(dwY)
; 2775 :                     );

  000cc	05942008	 ldreq       r2, [r4, #8]
  000d0	01813805	 orreq       r3, r1, r5, lsl #16
  000d4	05823088	 streq       r3, [r2, #0x88]

; 2776 :     }
; 2777 : 
; 2778 :     //  Update VID1 pipeline display position
; 2779 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  000d8	e3570001	 cmp         r7, #1

; 2780 :     {
; 2781 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.POSITION,
; 2782 :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 2783 :                     DISPC_VID_POS_VIDPOSY(dwY)
; 2784 :                     );

  000dc	05942008	 ldreq       r2, [r4, #8]
  000e0	01813805	 orreq       r3, r1, r5, lsl #16
  000e4	058230c4	 streq       r3, [r2, #0xC4]

; 2785 :     }
; 2786 : 
; 2787 :     //  Update VID2 pipeline display position
; 2788 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  000e8	e3570002	 cmp         r7, #2

; 2789 :     {
; 2790 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.POSITION,
; 2791 :                     DISPC_VID_POS_VIDPOSX(dwX) |
; 2792 :                     DISPC_VID_POS_VIDPOSY(dwY)
; 2793 :                     );

  000ec	05942008	 ldreq       r2, [r4, #8]
  000f0	01813805	 orreq       r3, r1, r5, lsl #16
  000f4	05823154	 streq       r3, [r2, #0x154]

; 2794 :     }
; 2795 : 
; 2796 : 
; 2797 :     //  Get the destination for the pipeline
; 2798 :     switch( g_rgPipelineMapping[ePipeline].eDestination )

  000f8	e59e3004	 ldr         r3, [lr, #4]
  000fc	e3530000	 cmp         r3, #0
  00100	0a000003	 beq         |$LN2@MovePipeli|
  00104	e3530001	 cmp         r3, #1
  00108	1a000002	 bne         |$LN3@MovePipeli|

; 2803 :             break;
; 2804 : 
; 2805 :         case OMAP_DSS_DESTINATION_TVOUT:
; 2806 :             //  Set go bit for TV Out
; 2807 :             dwDestGo  = DISPC_CONTROL_GODIGITAL;

  0010c	e3a08040	 mov         r8, #0x40

; 2808 :             break;

  00110	ea000000	 b           |$LN3@MovePipeli|
  00114		 |$LN2@MovePipeli|

; 2799 :     {
; 2800 :         case OMAP_DSS_DESTINATION_LCD:
; 2801 :             //  Set go bit for LCD
; 2802 :             dwDestGo  = DISPC_CONTROL_GOLCD;

  00114	e3a08020	 mov         r8, #0x20
  00118		 |$LN3@MovePipeli|

; 2809 :     }
; 2810 : 
; 2811 : 
; 2812 :     //  Enable/update overlay optimization
; 2813 :     EnableOverlayOptimization( TRUE );

  00118	e3a01001	 mov         r1, #1
  0011c	e1a00004	 mov         r0, r4
  00120	eb000000	 bl          |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z|

; 2814 : 
; 2815 :     //  Flush the shadow registers
; 2816 :     FlushRegs( dwDestGo );

  00124	e1a01008	 mov         r1, r8
  00128	e1a00004	 mov         r0, r4
  0012c	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 2817 : 
; 2818 : 
; 2819 :     //  Result
; 2820 :     bResult = TRUE;

  00130	e3a06001	 mov         r6, #1
  00134		 |$cleanUp$38709|

; 2821 : 
; 2822 : cleanUp:
; 2823 :     //  Release regs
; 2824 :     ReleaseRegs();

  00134	e2843b01	 add         r3, r4, #1, 22
  00138	e283008c	 add         r0, r3, #0x8C
  0013c	eb000000	 bl          LeaveCriticalSection

; 2825 : 
; 2826 :     //  Return result
; 2827 :     return bResult;

  00140		 |$LN19@MovePipeli|

; 2828 : }

  00140	e1a00006	 mov         r0, r6
  00144	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00148	e12fff1e	 bx          lr
  0014c		 |$LN34@MovePipeli|
  0014c		 |$LN35@MovePipeli|
  0014c	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00150		 |$M41582|

			 ENDP  ; |?MovePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@JJ@Z|, OMAPDisplayController::MovePipeline

	EXPORT	|?RotatePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@W4OMAP_DSS_ROTATION@@@Z| ; OMAPDisplayController::RotatePipeline

  00000			 AREA	 |.pdata|, PDATA
|$T41622| DCD	|$LN33@RotatePipe|
	DCD	0x40011102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RotatePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@W4OMAP_DSS_ROTATION@@@Z| PROC ; OMAPDisplayController::RotatePipeline

; 2836 : {

  00000		 |$LN33@RotatePipe|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M41619|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a08001	 mov         r8, r1
  00010	e58d0008	 str         r0, [sp, #8]

; 2837 :     BOOL    bResult = FALSE;
; 2838 :     OMAPSurface*        pSurface;
; 2839 :     BOOL                bMirror = FALSE;
; 2840 :     DWORD               dwVidRotation = 0;
; 2841 :     DWORD               dwHorzDecimation = 1;
; 2842 :     DWORD               dwVertDecimation = 1;
; 2843 :     DWORD               dwInterlace = 0;
; 2844 :     
; 2845 :     
; 2846 :     //  If no change in the rotation, do nothing
; 2847 :     if( g_rgPipelineMapping[ePipeline].eRotation == eRotation )

  00014	e59f3424	 ldr         r3, [pc, #0x424]
  00018	e3a04000	 mov         r4, #0
  0001c	e3a07000	 mov         r7, #0
  00020	e0839288	 add         r9, r3, r8, lsl #5
  00024	e599300c	 ldr         r3, [r9, #0xC]
  00028	e1530006	 cmp         r3, r6

; 2848 :         return TRUE;

  0002c	03a04001	 moveq       r4, #1
  00030	0a0000fd	 beq         |$LN17@RotatePipe|

; 2849 : 
; 2850 :     //  If no associated pipeline, just set the default rotation of the pipeline
; 2851 :     if( g_rgPipelineMapping[ePipeline].pSurface == NULL )

  00034	e5993008	 ldr         r3, [r9, #8]
  00038	e1b05003	 movs        r5, r3

; 2852 :     {
; 2853 :         g_rgPipelineMapping[ePipeline].eRotation = eRotation;

  0003c	0589600c	 streq       r6, [r9, #0xC]
  00040	03a04001	 moveq       r4, #1
  00044	0a0000f8	 beq         |$LN17@RotatePipe|

; 2854 :         return TRUE;
; 2855 :     }
; 2856 : 
; 2857 : 
; 2858 :     //  Get the surface being output
; 2859 :     pSurface = g_rgPipelineMapping[ePipeline].pSurface;
; 2860 :     bMirror = g_rgPipelineMapping[ePipeline].bMirror;
; 2861 : 
; 2862 :     //  Get the decimation settings for the surface
; 2863 :     dwHorzDecimation = g_rgPipelineScaling[ePipeline].dwHorzScaling;

  00048	e59f13ec	 ldr         r1, [pc, #0x3EC]

; 2864 :     dwVertDecimation = g_rgPipelineScaling[ePipeline].dwVertScaling;
; 2865 :     dwInterlace      = g_rgPipelineScaling[ePipeline].dwInterlace;
; 2866 : 
; 2867 : 
; 2868 :     //  Set rotation attributes for video pipelines if pixel format is YUV
; 2869 :     if( pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_YUV2 ||    
; 2870 :         pSurface->PixelFormat() == OMAP_DSS_PIXELFORMAT_UYVY )  

  0004c	e0882088	 add         r2, r8, r8, lsl #1
  00050	e5950004	 ldr         r0, [r5, #4]
  00054	e0813102	 add         r3, r1, r2, lsl #2
  00058	e593a004	 ldr         r10, [r3, #4]
  0005c	e5933008	 ldr         r3, [r3, #8]
  00060	e791b102	 ldr         r11, [r1, +r2, lsl #2]
  00064	e350000a	 cmp         r0, #0xA
  00068	e58d3000	 str         r3, [sp]
  0006c	e5993010	 ldr         r3, [r9, #0x10]
  00070	e58d3004	 str         r3, [sp, #4]
  00074	0a000001	 beq         |$LN13@RotatePipe|
  00078	e350000b	 cmp         r0, #0xB
  0007c	1a000045	 bne         |$LN11@RotatePipe|
  00080		 |$LN13@RotatePipe|

; 2871 :     {
; 2872 :         //  Depending on rotation and mirror settings, change the VID rotation attributes
; 2873 :         switch( eRotation )

  00080	e3560000	 cmp         r6, #0
  00084	0a000034	 beq         |$LN10@RotatePipe|
  00088	e356005a	 cmp         r6, #0x5A
  0008c	0a000024	 beq         |$LN9@RotatePipe|
  00090	e35600b4	 cmp         r6, #0xB4
  00094	0a000012	 beq         |$LN8@RotatePipe|
  00098	e3a03c01	 mov         r3, #1, 24
  0009c	e383300e	 orr         r3, r3, #0xE
  000a0	e1560003	 cmp         r6, r3

; 2901 : 
; 2902 :             case OMAP_DSS_ROTATION_270:
; 2903 :                 //  Settings for rotation angle 270 (90 for DSS setting)
; 2904 :                 dwVidRotation = DISPC_VID_ATTR_VIDROTATION_90 | DISPC_VID_ATTR_VIDROWREPEATENABLE;
; 2905 : 
; 2906 :                 //  Set the decimation for the surface
; 2907 :                 pSurface->SetHorizontalScaling( dwVertDecimation );
; 2908 :                 pSurface->SetVerticalScaling( dwHorzDecimation );
; 2909 :                 break;
; 2910 : 
; 2911 :             default:
; 2912 :                 ASSERT(0);
; 2913 :                 return FALSE;

  000a4	13a04000	 movne       r4, #0
  000a8	1a0000df	 bne         |$LN17@RotatePipe|
  000ac	e5953000	 ldr         r3, [r5]
  000b0	e1a0100a	 mov         r1, r10
  000b4	e1a00005	 mov         r0, r5
  000b8	e5933030	 ldr         r3, [r3, #0x30]
  000bc	e3a07a41	 mov         r7, #0x41, 20
  000c0	e1a0e00f	 mov         lr, pc
  000c4	e12fff13	 bx          r3
  000c8	e5953000	 ldr         r3, [r5]
  000cc	e1a0100b	 mov         r1, r11
  000d0	e1a00005	 mov         r0, r5
  000d4	e5933034	 ldr         r3, [r3, #0x34]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3
  000e0	ea00002c	 b           |$LN11@RotatePipe|
  000e4		 |$LN8@RotatePipe|

; 2892 : 
; 2893 :             case OMAP_DSS_ROTATION_180:
; 2894 :                 //  Settings for rotation angle 180
; 2895 :                 dwVidRotation = (bMirror) ? DISPC_VID_ATTR_VIDROTATION_0 : DISPC_VID_ATTR_VIDROTATION_180;

  000e4	e3530000	 cmp         r3, #0

; 2896 : 
; 2897 :                 //  Set the decimation for the surface
; 2898 :                 pSurface->SetHorizontalScaling( dwHorzDecimation );

  000e8	e5953000	 ldr         r3, [r5]
  000ec	13a07000	 movne       r7, #0
  000f0	03a07a02	 moveq       r7, #2, 20
  000f4	e5933030	 ldr         r3, [r3, #0x30]
  000f8	e1a0100b	 mov         r1, r11
  000fc	e1a00005	 mov         r0, r5
  00100	e1a0e00f	 mov         lr, pc
  00104	e12fff13	 bx          r3

; 2899 :                 pSurface->SetVerticalScaling( dwVertDecimation );

  00108	e5953000	 ldr         r3, [r5]
  0010c	e1a0100a	 mov         r1, r10
  00110	e1a00005	 mov         r0, r5
  00114	e5933034	 ldr         r3, [r3, #0x34]
  00118	e1a0e00f	 mov         lr, pc
  0011c	e12fff13	 bx          r3

; 2900 :                 break;

  00120	ea00001c	 b           |$LN11@RotatePipe|
  00124		 |$LN9@RotatePipe|

; 2882 :                 break;
; 2883 : 
; 2884 :             case OMAP_DSS_ROTATION_90:
; 2885 :                 //  Settings for rotation angle 90 (270 for DSS setting)
; 2886 :                 dwVidRotation = DISPC_VID_ATTR_VIDROTATION_270 | DISPC_VID_ATTR_VIDROWREPEATENABLE;
; 2887 : 
; 2888 :                 //  Set the decimation for the surface
; 2889 :                 pSurface->SetHorizontalScaling( dwVertDecimation );

  00124	e5953000	 ldr         r3, [r5]
  00128	e1a0100a	 mov         r1, r10
  0012c	e1a00005	 mov         r0, r5
  00130	e5933030	 ldr         r3, [r3, #0x30]
  00134	e3a07a43	 mov         r7, #0x43, 20
  00138	e1a0e00f	 mov         lr, pc
  0013c	e12fff13	 bx          r3

; 2890 :                 pSurface->SetVerticalScaling( dwHorzDecimation );

  00140	e5953000	 ldr         r3, [r5]
  00144	e1a0100b	 mov         r1, r11
  00148	e1a00005	 mov         r0, r5
  0014c	e5933034	 ldr         r3, [r3, #0x34]
  00150	e1a0e00f	 mov         lr, pc
  00154	e12fff13	 bx          r3

; 2891 :                 break;

  00158	ea00000e	 b           |$LN11@RotatePipe|
  0015c		 |$LN10@RotatePipe|

; 2874 :         {
; 2875 :             case OMAP_DSS_ROTATION_0:
; 2876 :                 //  Settings for rotation angle 0
; 2877 :                 dwVidRotation = (bMirror) ? DISPC_VID_ATTR_VIDROTATION_180 : DISPC_VID_ATTR_VIDROTATION_0;

  0015c	e3530000	 cmp         r3, #0

; 2878 : 
; 2879 :                 //  Set the decimation for the surface
; 2880 :                 pSurface->SetHorizontalScaling( dwHorzDecimation );

  00160	e5953000	 ldr         r3, [r5]
  00164	13a07a02	 movne       r7, #2, 20
  00168	03a07000	 moveq       r7, #0
  0016c	e5933030	 ldr         r3, [r3, #0x30]
  00170	e1a0100b	 mov         r1, r11
  00174	e1a00005	 mov         r0, r5
  00178	e1a0e00f	 mov         lr, pc
  0017c	e12fff13	 bx          r3

; 2881 :                 pSurface->SetVerticalScaling( dwVertDecimation );

  00180	e5953000	 ldr         r3, [r5]
  00184	e1a0100a	 mov         r1, r10
  00188	e1a00005	 mov         r0, r5
  0018c	e5933034	 ldr         r3, [r3, #0x34]
  00190	e1a0e00f	 mov         lr, pc
  00194	e12fff13	 bx          r3
  00198		 |$LN11@RotatePipe|

; 2914 :         }
; 2915 :     }
; 2916 : 
; 2917 : 
; 2918 :     //  Access the regs
; 2919 :     if( AccessRegs() == FALSE )

  00198	e59da008	 ldr         r10, [sp, #8]
  0019c	e1a0000a	 mov         r0, r10
  001a0	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  001a4	e3500000	 cmp         r0, #0
  001a8	0a00009c	 beq         |$cleanUp$38764|

; 2920 :         goto cleanUp;
; 2921 : 
; 2922 : 
; 2923 :     //  Update GFX pipeline display base address
; 2924 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )
; 2925 :     {
; 2926 :         OUTREG32( &m_pDispRegs->DISPC_GFX_PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  001ac	e59db004	 ldr         r11, [sp, #4]
  001b0	e3580000	 cmp         r8, #0
  001b4	1a000027	 bne         |$LN3@RotatePipe|
  001b8	e5953000	 ldr         r3, [r5]
  001bc	e1a0200b	 mov         r2, r11
  001c0	e1a01006	 mov         r1, r6
  001c4	e5933018	 ldr         r3, [r3, #0x18]
  001c8	e1a00005	 mov         r0, r5
  001cc	e1a0e00f	 mov         lr, pc
  001d0	e12fff13	 bx          r3
  001d4	e59a3008	 ldr         r3, [r10, #8]

; 2927 :         OUTREG32( &m_pDispRegs->DISPC_GFX_ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  001d8	e1a0200b	 mov         r2, r11
  001dc	e1a01006	 mov         r1, r6
  001e0	e58300b0	 str         r0, [r3, #0xB0]
  001e4	e5953000	 ldr         r3, [r5]
  001e8	e1a00005	 mov         r0, r5
  001ec	e593301c	 ldr         r3, [r3, #0x1C]
  001f0	e1a0e00f	 mov         lr, pc
  001f4	e12fff13	 bx          r3
  001f8	e59a2008	 ldr         r2, [r10, #8]

; 2928 : 
; 2929 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA0, pSurface->PhysicalAddr(eRotation, bMirror) );

  001fc	e3a03000	 mov         r3, #0
  00200	e1a01006	 mov         r1, r6
  00204	e58200ac	 str         r0, [r2, #0xAC]
  00208	e5950000	 ldr         r0, [r5]
  0020c	e1a0200b	 mov         r2, r11
  00210	e5904014	 ldr         r4, [r0, #0x14]
  00214	e1a00005	 mov         r0, r5
  00218	e1a0e00f	 mov         lr, pc
  0021c	e12fff14	 bx          r4
  00220	e59a2008	 ldr         r2, [r10, #8]

; 2930 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA1, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  00224	e3a03000	 mov         r3, #0
  00228	e1a01006	 mov         r1, r6
  0022c	e5820080	 str         r0, [r2, #0x80]
  00230	e5950000	 ldr         r0, [r5]
  00234	e1a0200b	 mov         r2, r11
  00238	e5904014	 ldr         r4, [r0, #0x14]
  0023c	e1a00005	 mov         r0, r5
  00240	e1a0e00f	 mov         lr, pc
  00244	e12fff14	 bx          r4
  00248	e59d3000	 ldr         r3, [sp]
  0024c	e59a2008	 ldr         r2, [r10, #8]
  00250	e0803003	 add         r3, r0, r3
  00254	e5823084	 str         r3, [r2, #0x84]
  00258		 |$LN3@RotatePipe|

; 2931 :     }
; 2932 : 
; 2933 :     //  Update VID1 pipeline display base address and attributes for rotation
; 2934 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  00258	e3580001	 cmp         r8, #1
  0025c	1a00002f	 bne         |$LN2@RotatePipe|

; 2935 :     {
; 2936 :         CLRREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES, DISPC_VID_ATTR_VIDROTATION_MASK|DISPC_VID_ATTR_VIDROWREPEATENABLE );

  00260	e59a4008	 ldr         r4, [r10, #8]

; 2937 :         SETREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES, dwVidRotation );
; 2938 :         
; 2939 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00264	e1a0200b	 mov         r2, r11
  00268	e1a01006	 mov         r1, r6
  0026c	e59430cc	 ldr         r3, [r4, #0xCC]
  00270	e1a00005	 mov         r0, r5
  00274	e3c33a43	 bic         r3, r3, #0x43, 20
  00278	e58430cc	 str         r3, [r4, #0xCC]
  0027c	e59a4008	 ldr         r4, [r10, #8]
  00280	e59430cc	 ldr         r3, [r4, #0xCC]
  00284	e1833007	 orr         r3, r3, r7
  00288	e58430cc	 str         r3, [r4, #0xCC]
  0028c	e5953000	 ldr         r3, [r5]
  00290	e5933018	 ldr         r3, [r3, #0x18]
  00294	e1a0e00f	 mov         lr, pc
  00298	e12fff13	 bx          r3
  0029c	e59a3008	 ldr         r3, [r10, #8]

; 2940 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  002a0	e1a0200b	 mov         r2, r11
  002a4	e1a01006	 mov         r1, r6
  002a8	e58300dc	 str         r0, [r3, #0xDC]
  002ac	e5953000	 ldr         r3, [r5]
  002b0	e1a00005	 mov         r0, r5
  002b4	e593301c	 ldr         r3, [r3, #0x1C]
  002b8	e1a0e00f	 mov         lr, pc
  002bc	e12fff13	 bx          r3
  002c0	e59a2008	 ldr         r2, [r10, #8]

; 2941 : 
; 2942 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  002c4	e3a03000	 mov         r3, #0
  002c8	e1a01006	 mov         r1, r6
  002cc	e58200d8	 str         r0, [r2, #0xD8]
  002d0	e5950000	 ldr         r0, [r5]
  002d4	e1a0200b	 mov         r2, r11
  002d8	e5904014	 ldr         r4, [r0, #0x14]
  002dc	e1a00005	 mov         r0, r5
  002e0	e1a0e00f	 mov         lr, pc
  002e4	e12fff14	 bx          r4
  002e8	e59d3000	 ldr         r3, [sp]
  002ec	e59a2008	 ldr         r2, [r10, #8]
  002f0	e0803003	 add         r3, r0, r3
  002f4	e58230bc	 str         r3, [r2, #0xBC]

; 2943 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  002f8	e5951000	 ldr         r1, [r5]
  002fc	e3a03000	 mov         r3, #0
  00300	e1a0200b	 mov         r2, r11
  00304	e5914014	 ldr         r4, [r1, #0x14]
  00308	e1a01006	 mov         r1, r6
  0030c	e1a00005	 mov         r0, r5
  00310	e1a0e00f	 mov         lr, pc
  00314	e12fff14	 bx          r4
  00318	e59a3008	 ldr         r3, [r10, #8]
  0031c	e58300c0	 str         r0, [r3, #0xC0]
  00320		 |$LN2@RotatePipe|

; 2944 :        
; 2945 :     }
; 2946 : 
; 2947 :     //  Update VID2 pipeline display base address and attributes for rotation
; 2948 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  00320	e3580002	 cmp         r8, #2
  00324	1a00002f	 bne         |$LN1@RotatePipe|

; 2949 :     {
; 2950 :         CLRREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES, DISPC_VID_ATTR_VIDROTATION_MASK|DISPC_VID_ATTR_VIDROWREPEATENABLE );

  00328	e59a4008	 ldr         r4, [r10, #8]

; 2951 :         SETREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES, dwVidRotation );
; 2952 :         
; 2953 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  0032c	e1a0200b	 mov         r2, r11
  00330	e1a01006	 mov         r1, r6
  00334	e594315c	 ldr         r3, [r4, #0x15C]
  00338	e1a00005	 mov         r0, r5
  0033c	e3c33a43	 bic         r3, r3, #0x43, 20
  00340	e584315c	 str         r3, [r4, #0x15C]
  00344	e59a4008	 ldr         r4, [r10, #8]
  00348	e594315c	 ldr         r3, [r4, #0x15C]
  0034c	e1833007	 orr         r3, r3, r7
  00350	e584315c	 str         r3, [r4, #0x15C]
  00354	e5953000	 ldr         r3, [r5]
  00358	e5933018	 ldr         r3, [r3, #0x18]
  0035c	e1a0e00f	 mov         lr, pc
  00360	e12fff13	 bx          r3
  00364	e59a3008	 ldr         r3, [r10, #8]

; 2954 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  00368	e1a0200b	 mov         r2, r11
  0036c	e1a01006	 mov         r1, r6
  00370	e583016c	 str         r0, [r3, #0x16C]
  00374	e5953000	 ldr         r3, [r5]
  00378	e1a00005	 mov         r0, r5
  0037c	e593301c	 ldr         r3, [r3, #0x1C]
  00380	e1a0e00f	 mov         lr, pc
  00384	e12fff13	 bx          r3
  00388	e59a1008	 ldr         r1, [r10, #8]

; 2955 : 
; 2956 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  0038c	e3a03000	 mov         r3, #0
  00390	e1a0200b	 mov         r2, r11
  00394	e5810168	 str         r0, [r1, #0x168]
  00398	e5950000	 ldr         r0, [r5]
  0039c	e1a01006	 mov         r1, r6
  003a0	e5904014	 ldr         r4, [r0, #0x14]
  003a4	e1a00005	 mov         r0, r5
  003a8	e1a0e00f	 mov         lr, pc
  003ac	e12fff14	 bx          r4
  003b0	e59d3000	 ldr         r3, [sp]
  003b4	e59a1008	 ldr         r1, [r10, #8]

; 2957 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  003b8	e1a0200b	 mov         r2, r11
  003bc	e0803003	 add         r3, r0, r3
  003c0	e581314c	 str         r3, [r1, #0x14C]
  003c4	e5951000	 ldr         r1, [r5]
  003c8	e3a03000	 mov         r3, #0
  003cc	e1a00005	 mov         r0, r5
  003d0	e5914014	 ldr         r4, [r1, #0x14]
  003d4	e1a01006	 mov         r1, r6
  003d8	e1a0e00f	 mov         lr, pc
  003dc	e12fff14	 bx          r4
  003e0	e59a3008	 ldr         r3, [r10, #8]
  003e4	e5830150	 str         r0, [r3, #0x150]
  003e8		 |$LN1@RotatePipe|

; 2958 :     }
; 2959 : 
; 2960 : 
; 2961 :     //  Update pipeline output rotation
; 2962 :     g_rgPipelineMapping[ePipeline].eRotation = eRotation;

  003e8	e589600c	 str         r6, [r9, #0xC]

; 2963 : 
; 2964 :     //  Set the decimation factors for the surface back to normal
; 2965 :     pSurface->SetHorizontalScaling( 1 );

  003ec	e5953000	 ldr         r3, [r5]
  003f0	e3a01001	 mov         r1, #1
  003f4	e1a00005	 mov         r0, r5
  003f8	e5933030	 ldr         r3, [r3, #0x30]
  003fc	e1a0e00f	 mov         lr, pc
  00400	e12fff13	 bx          r3

; 2966 :     pSurface->SetVerticalScaling( 1 );

  00404	e5953000	 ldr         r3, [r5]
  00408	e3a01001	 mov         r1, #1
  0040c	e1a00005	 mov         r0, r5
  00410	e5933034	 ldr         r3, [r3, #0x34]
  00414	e1a0e00f	 mov         lr, pc
  00418	e12fff13	 bx          r3

; 2967 : 
; 2968 : 
; 2969 :     //  Result
; 2970 :     bResult = TRUE;

  0041c	e3a04001	 mov         r4, #1
  00420		 |$cleanUp$38764|

; 2971 : 
; 2972 : cleanUp:
; 2973 :     //  Release regs
; 2974 :     ReleaseRegs();

  00420	e28a3b01	 add         r3, r10, #1, 22
  00424	e283008c	 add         r0, r3, #0x8C
  00428	eb000000	 bl          LeaveCriticalSection

; 2975 : 
; 2976 :     //  Return result
; 2977 :     return bResult;

  0042c		 |$LN17@RotatePipe|

; 2978 : }

  0042c	e1a00004	 mov         r0, r4
  00430	e28dd00c	 add         sp, sp, #0xC
  00434	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00438	e12fff1e	 bx          lr
  0043c		 |$LN34@RotatePipe|
  0043c		 |$LN35@RotatePipe|
  0043c	00000000	 DCD         |?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A|
  00440		 |$LN36@RotatePipe|
  00440	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00444		 |$M41620|

			 ENDP  ; |?RotatePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@W4OMAP_DSS_ROTATION@@@Z|, OMAPDisplayController::RotatePipeline

	EXPORT	|?MirrorPipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@H@Z| ; OMAPDisplayController::MirrorPipeline

  00000			 AREA	 |.pdata|, PDATA
|$T41648| DCD	|$LN21@MirrorPipe|
	DCD	0x4000d702
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?MirrorPipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@H@Z| PROC ; OMAPDisplayController::MirrorPipeline

; 2986 : {

  00000		 |$LN21@MirrorPipe|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M41645|
  00008	e1a08002	 mov         r8, r2
  0000c	e1a06001	 mov         r6, r1
  00010	e1a0a000	 mov         r10, r0

; 2987 :     BOOL    bResult = FALSE;
; 2988 :     OMAPSurface*        pSurface;
; 2989 :     OMAP_DSS_ROTATION   eRotation;
; 2990 :     DWORD               dwHorzDecimation = 1;
; 2991 :     DWORD               dwVertDecimation = 1;
; 2992 :     DWORD               dwInterlace = 0;
; 2993 :     
; 2994 :     
; 2995 :     //  If no change in the mirror setting, do nothing
; 2996 :     if( g_rgPipelineMapping[ePipeline].bMirror == bMirror )

  00014	e59f333c	 ldr         r3, [pc, #0x33C]
  00018	e3a04000	 mov         r4, #0
  0001c	e0837286	 add         r7, r3, r6, lsl #5
  00020	e5973010	 ldr         r3, [r7, #0x10]
  00024	e1530008	 cmp         r3, r8

; 2997 :         return TRUE;

  00028	03a04001	 moveq       r4, #1
  0002c	0a0000c4	 beq         |$LN13@MirrorPipe|

; 2998 : 
; 2999 :     //  If no associated pipeline, just set the default mirror setting of the pipeline
; 3000 :     if( g_rgPipelineMapping[ePipeline].pSurface == NULL )

  00030	e5973008	 ldr         r3, [r7, #8]
  00034	e1b05003	 movs        r5, r3

; 3001 :     {
; 3002 :         g_rgPipelineMapping[ePipeline].bMirror = bMirror;

  00038	05878010	 streq       r8, [r7, #0x10]
  0003c	03a04001	 moveq       r4, #1
  00040	0a0000bf	 beq         |$LN13@MirrorPipe|

; 3003 :         return TRUE;
; 3004 :     }
; 3005 : 
; 3006 :     //  Get the surface being output
; 3007 :     pSurface = g_rgPipelineMapping[ePipeline].pSurface;
; 3008 :     eRotation = g_rgPipelineMapping[ePipeline].eRotation;
; 3009 : 
; 3010 :     //  Get the decimation settings for the surface
; 3011 :     dwHorzDecimation = g_rgPipelineScaling[ePipeline].dwHorzScaling;

  00044	e59f1308	 ldr         r1, [pc, #0x308]
  00048	e0862086	 add         r2, r6, r6, lsl #1
  0004c	e597000c	 ldr         r0, [r7, #0xC]

; 3012 :     dwVertDecimation = g_rgPipelineScaling[ePipeline].dwVertScaling;

  00050	e0813102	 add         r3, r1, r2, lsl #2
  00054	e593b004	 ldr         r11, [r3, #4]

; 3013 :     dwInterlace      = g_rgPipelineScaling[ePipeline].dwInterlace;

  00058	e5933008	 ldr         r3, [r3, #8]
  0005c	e7912102	 ldr         r2, [r1, +r2, lsl #2]
  00060	e1b09000	 movs        r9, r0
  00064	e58d3000	 str         r3, [sp]
  00068	e58d2004	 str         r2, [sp, #4]

; 3014 : 
; 3015 : 
; 3016 :     //  Depending on rotation settings, change the surface scaling attributes
; 3017 :     switch( eRotation )

  0006c	0a000015	 beq         |$LN8@MirrorPipe|
  00070	e359005a	 cmp         r9, #0x5A
  00074	0a000006	 beq         |$LN7@MirrorPipe|
  00078	e35900b4	 cmp         r9, #0xB4
  0007c	0a000011	 beq         |$LN8@MirrorPipe|
  00080	e3a03c01	 mov         r3, #1, 24
  00084	e383300e	 orr         r3, r3, #0xE
  00088	e1590003	 cmp         r9, r3

; 3032 : 
; 3033 :         default:
; 3034 :             ASSERT(0);
; 3035 :             return FALSE;

  0008c	13a04000	 movne       r4, #0
  00090	1a0000ab	 bne         |$LN13@MirrorPipe|
  00094		 |$LN7@MirrorPipe|

; 3024 :             break;
; 3025 : 
; 3026 :         case OMAP_DSS_ROTATION_90:
; 3027 :         case OMAP_DSS_ROTATION_270:
; 3028 :             //  Set the decimation for the surface
; 3029 :             pSurface->SetHorizontalScaling( dwVertDecimation );

  00094	e5953000	 ldr         r3, [r5]
  00098	e1a0100b	 mov         r1, r11
  0009c	e1a00005	 mov         r0, r5
  000a0	e5933030	 ldr         r3, [r3, #0x30]
  000a4	e1a0e00f	 mov         lr, pc
  000a8	e12fff13	 bx          r3

; 3030 :             pSurface->SetVerticalScaling( dwHorzDecimation );

  000ac	e5953000	 ldr         r3, [r5]
  000b0	e59d1004	 ldr         r1, [sp, #4]
  000b4	e1a00005	 mov         r0, r5
  000b8	e5933034	 ldr         r3, [r3, #0x34]
  000bc	e1a0e00f	 mov         lr, pc
  000c0	e12fff13	 bx          r3

; 3031 :             break;

  000c4	ea00000b	 b           |$LN9@MirrorPipe|
  000c8		 |$LN8@MirrorPipe|

; 3018 :     {
; 3019 :         case OMAP_DSS_ROTATION_0:
; 3020 :         case OMAP_DSS_ROTATION_180:
; 3021 :             //  Set the decimation for the surface
; 3022 :             pSurface->SetHorizontalScaling( dwHorzDecimation );

  000c8	e5953000	 ldr         r3, [r5]
  000cc	e1a01002	 mov         r1, r2
  000d0	e1a00005	 mov         r0, r5
  000d4	e5933030	 ldr         r3, [r3, #0x30]
  000d8	e1a0e00f	 mov         lr, pc
  000dc	e12fff13	 bx          r3

; 3023 :             pSurface->SetVerticalScaling( dwVertDecimation );

  000e0	e5953000	 ldr         r3, [r5]
  000e4	e1a0100b	 mov         r1, r11
  000e8	e1a00005	 mov         r0, r5
  000ec	e5933034	 ldr         r3, [r3, #0x34]
  000f0	e1a0e00f	 mov         lr, pc
  000f4	e12fff13	 bx          r3
  000f8		 |$LN9@MirrorPipe|

; 3036 :     }
; 3037 : 
; 3038 :     //  Access the regs
; 3039 :     if( AccessRegs() == FALSE )

  000f8	e1a0000a	 mov         r0, r10
  000fc	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00100	e3500000	 cmp         r0, #0
  00104	0a00008b	 beq         |$cleanUp$38827|

; 3040 :         goto cleanUp;
; 3041 : 
; 3042 : 
; 3043 :     //  Update GFX pipeline for mirror setting
; 3044 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  00108	e3560000	 cmp         r6, #0
  0010c	1a000028	 bne         |$LN17@MirrorPipe|

; 3045 :     {
; 3046 :         OUTREG32( &m_pDispRegs->DISPC_GFX_PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00110	e5953000	 ldr         r3, [r5]
  00114	e1a02008	 mov         r2, r8
  00118	e1a01009	 mov         r1, r9
  0011c	e5933018	 ldr         r3, [r3, #0x18]
  00120	e1a00005	 mov         r0, r5
  00124	e1a0e00f	 mov         lr, pc
  00128	e12fff13	 bx          r3
  0012c	e59a3008	 ldr         r3, [r10, #8]

; 3047 :         OUTREG32( &m_pDispRegs->DISPC_GFX_ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  00130	e1a02008	 mov         r2, r8
  00134	e1a01009	 mov         r1, r9
  00138	e58300b0	 str         r0, [r3, #0xB0]
  0013c	e5953000	 ldr         r3, [r5]
  00140	e1a00005	 mov         r0, r5
  00144	e593301c	 ldr         r3, [r3, #0x1C]
  00148	e1a0e00f	 mov         lr, pc
  0014c	e12fff13	 bx          r3
  00150	e59a2008	 ldr         r2, [r10, #8]

; 3048 : 
; 3049 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA0, pSurface->PhysicalAddr(eRotation, bMirror) );

  00154	e3a03000	 mov         r3, #0
  00158	e1a01009	 mov         r1, r9
  0015c	e58200ac	 str         r0, [r2, #0xAC]
  00160	e5950000	 ldr         r0, [r5]
  00164	e1a02008	 mov         r2, r8
  00168	e5904014	 ldr         r4, [r0, #0x14]
  0016c	e1a00005	 mov         r0, r5
  00170	e1a0e00f	 mov         lr, pc
  00174	e12fff14	 bx          r4
  00178	e59a2008	 ldr         r2, [r10, #8]

; 3050 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA1, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  0017c	e3a03000	 mov         r3, #0
  00180	e1a01009	 mov         r1, r9
  00184	e5820080	 str         r0, [r2, #0x80]
  00188	e5950000	 ldr         r0, [r5]
  0018c	e1a02008	 mov         r2, r8
  00190	e5904014	 ldr         r4, [r0, #0x14]
  00194	e1a00005	 mov         r0, r5
  00198	e1a0e00f	 mov         lr, pc
  0019c	e12fff14	 bx          r4
  001a0	e59db000	 ldr         r11, [sp]
  001a4	e59a2008	 ldr         r2, [r10, #8]
  001a8	e080300b	 add         r3, r0, r11
  001ac	e5823084	 str         r3, [r2, #0x84]
  001b0	ea000000	 b           |$LN3@MirrorPipe|
  001b4		 |$LN17@MirrorPipe|

; 3013 :     dwInterlace      = g_rgPipelineScaling[ePipeline].dwInterlace;

  001b4	e59db000	 ldr         r11, [sp]

; 3050 :         OUTREG32( &m_pDispRegs->DISPC_GFX_BA1, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  001b8		 |$LN3@MirrorPipe|

; 3051 :     }
; 3052 : 
; 3053 :     //  Update VID1 pipeline for mirror setting
; 3054 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  001b8	e3560001	 cmp         r6, #1
  001bc	1a000026	 bne         |$LN2@MirrorPipe|

; 3055 :     {
; 3056 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  001c0	e5953000	 ldr         r3, [r5]
  001c4	e1a02008	 mov         r2, r8
  001c8	e1a01009	 mov         r1, r9
  001cc	e5933018	 ldr         r3, [r3, #0x18]
  001d0	e1a00005	 mov         r0, r5
  001d4	e1a0e00f	 mov         lr, pc
  001d8	e12fff13	 bx          r3
  001dc	e59a3008	 ldr         r3, [r10, #8]

; 3057 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  001e0	e1a02008	 mov         r2, r8
  001e4	e1a01009	 mov         r1, r9
  001e8	e58300dc	 str         r0, [r3, #0xDC]
  001ec	e5953000	 ldr         r3, [r5]
  001f0	e1a00005	 mov         r0, r5
  001f4	e593301c	 ldr         r3, [r3, #0x1C]
  001f8	e1a0e00f	 mov         lr, pc
  001fc	e12fff13	 bx          r3
  00200	e59a2008	 ldr         r2, [r10, #8]

; 3058 : 
; 3059 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  00204	e3a03000	 mov         r3, #0
  00208	e1a01009	 mov         r1, r9
  0020c	e58200d8	 str         r0, [r2, #0xD8]
  00210	e5950000	 ldr         r0, [r5]
  00214	e1a02008	 mov         r2, r8
  00218	e5904014	 ldr         r4, [r0, #0x14]
  0021c	e1a00005	 mov         r0, r5
  00220	e1a0e00f	 mov         lr, pc
  00224	e12fff14	 bx          r4
  00228	e59a2008	 ldr         r2, [r10, #8]
  0022c	e080300b	 add         r3, r0, r11

; 3060 :         OUTREG32( &m_pDispRegs->tDISPC_VID1.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  00230	e1a00005	 mov         r0, r5
  00234	e58230bc	 str         r3, [r2, #0xBC]
  00238	e5951000	 ldr         r1, [r5]
  0023c	e3a03000	 mov         r3, #0
  00240	e1a02008	 mov         r2, r8
  00244	e5914014	 ldr         r4, [r1, #0x14]
  00248	e1a01009	 mov         r1, r9
  0024c	e1a0e00f	 mov         lr, pc
  00250	e12fff14	 bx          r4
  00254	e59a3008	 ldr         r3, [r10, #8]
  00258	e58300c0	 str         r0, [r3, #0xC0]
  0025c		 |$LN2@MirrorPipe|

; 3061 : 
; 3062 :     }
; 3063 : 
; 3064 :     //  Update VID2 pipeline for mirror setting
; 3065 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  0025c	e3560002	 cmp         r6, #2
  00260	1a000026	 bne         |$LN1@MirrorPipe|

; 3066 :     {
; 3067 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.PIXEL_INC, pSurface->PixelIncr(eRotation, bMirror) );

  00264	e5953000	 ldr         r3, [r5]
  00268	e1a02008	 mov         r2, r8
  0026c	e1a01009	 mov         r1, r9
  00270	e5933018	 ldr         r3, [r3, #0x18]
  00274	e1a00005	 mov         r0, r5
  00278	e1a0e00f	 mov         lr, pc
  0027c	e12fff13	 bx          r3
  00280	e59a3008	 ldr         r3, [r10, #8]

; 3068 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.ROW_INC, pSurface->RowIncr(eRotation, bMirror) );

  00284	e1a02008	 mov         r2, r8
  00288	e1a01009	 mov         r1, r9
  0028c	e583016c	 str         r0, [r3, #0x16C]
  00290	e5953000	 ldr         r3, [r5]
  00294	e1a00005	 mov         r0, r5
  00298	e593301c	 ldr         r3, [r3, #0x1C]
  0029c	e1a0e00f	 mov         lr, pc
  002a0	e12fff13	 bx          r3
  002a4	e59a2008	 ldr         r2, [r10, #8]

; 3069 : 
; 3070 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA0, pSurface->PhysicalAddr(eRotation, bMirror) + dwInterlace );

  002a8	e3a03000	 mov         r3, #0
  002ac	e1a01009	 mov         r1, r9
  002b0	e5820168	 str         r0, [r2, #0x168]
  002b4	e5950000	 ldr         r0, [r5]
  002b8	e1a02008	 mov         r2, r8
  002bc	e5904014	 ldr         r4, [r0, #0x14]
  002c0	e1a00005	 mov         r0, r5
  002c4	e1a0e00f	 mov         lr, pc
  002c8	e12fff14	 bx          r4
  002cc	e59a2008	 ldr         r2, [r10, #8]
  002d0	e080300b	 add         r3, r0, r11

; 3071 :         OUTREG32( &m_pDispRegs->tDISPC_VID2.BA1, pSurface->PhysicalAddr(eRotation, bMirror) );

  002d4	e1a01009	 mov         r1, r9
  002d8	e582314c	 str         r3, [r2, #0x14C]
  002dc	e595e000	 ldr         lr, [r5]
  002e0	e3a03000	 mov         r3, #0
  002e4	e1a02008	 mov         r2, r8
  002e8	e59e4014	 ldr         r4, [lr, #0x14]
  002ec	e1a00005	 mov         r0, r5
  002f0	e1a0e00f	 mov         lr, pc
  002f4	e12fff14	 bx          r4
  002f8	e59a3008	 ldr         r3, [r10, #8]
  002fc	e5830150	 str         r0, [r3, #0x150]
  00300		 |$LN1@MirrorPipe|

; 3072 :     }
; 3073 : 
; 3074 : 
; 3075 :     //  Update pipeline output mirror setting
; 3076 :     g_rgPipelineMapping[ePipeline].bMirror = bMirror;

  00300	e5878010	 str         r8, [r7, #0x10]

; 3077 : 
; 3078 :     //  Set the decimation factors for the surface back to normal
; 3079 :     pSurface->SetHorizontalScaling( 1 );

  00304	e5953000	 ldr         r3, [r5]
  00308	e3a01001	 mov         r1, #1
  0030c	e1a00005	 mov         r0, r5
  00310	e5933030	 ldr         r3, [r3, #0x30]
  00314	e1a0e00f	 mov         lr, pc
  00318	e12fff13	 bx          r3

; 3080 :     pSurface->SetVerticalScaling( 1 );

  0031c	e5953000	 ldr         r3, [r5]
  00320	e3a01001	 mov         r1, #1
  00324	e1a00005	 mov         r0, r5
  00328	e5933034	 ldr         r3, [r3, #0x34]
  0032c	e1a0e00f	 mov         lr, pc
  00330	e12fff13	 bx          r3

; 3081 : 
; 3082 : 
; 3083 :     //  Result
; 3084 :     bResult = TRUE;

  00334	e3a04001	 mov         r4, #1
  00338		 |$cleanUp$38827|

; 3085 : 
; 3086 : cleanUp:
; 3087 :     //  Release regs
; 3088 :     ReleaseRegs();

  00338	e28a3b01	 add         r3, r10, #1, 22
  0033c	e283008c	 add         r0, r3, #0x8C
  00340	eb000000	 bl          LeaveCriticalSection

; 3089 : 
; 3090 :     //  Return result
; 3091 :     return bResult;

  00344		 |$LN13@MirrorPipe|

; 3092 : }

  00344	e1a00004	 mov         r0, r4
  00348	e28dd008	 add         sp, sp, #8
  0034c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00350	e12fff1e	 bx          lr
  00354		 |$LN22@MirrorPipe|
  00354		 |$LN23@MirrorPipe|
  00354	00000000	 DCD         |?g_rgPipelineScaling@@3PAUOMAPPipelineScaling@@A|
  00358		 |$LN24@MirrorPipe|
  00358	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  0035c		 |$M41646|

			 ENDP  ; |?MirrorPipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@H@Z|, OMAPDisplayController::MirrorPipeline

	EXPORT	|?UpdateScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z| ; OMAPDisplayController::UpdateScalingAttribs

  00000			 AREA	 |.pdata|, PDATA
|$T41669| DCD	|$LN17@UpdateScal|
	DCD	0x40002c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?UpdateScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z| PROC ; OMAPDisplayController::UpdateScalingAttribs

; 3101 : {

  00000		 |$LN17@UpdateScal|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M41666|
  00004	e1a08003	 mov         r8, r3
  00008	e1a09002	 mov         r9, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a05000	 mov         r5, r0

; 3102 :     BOOL    bResult = FALSE;
; 3103 : 
; 3104 : 
; 3105 :     //  Check if pipeline is enabled; ignore operation if not
; 3106 :     if( g_rgPipelineMapping[ePipeline].bEnabled == FALSE )

  00014	e59f7090	 ldr         r7, [pc, #0x90]
  00018	e3a06000	 mov         r6, #0
  0001c	e797e284	 ldr         lr, [r7, +r4, lsl #5]
  00020	e35e0000	 cmp         lr, #0

; 3107 :         return FALSE;

  00024	03a06000	 moveq       r6, #0
  00028	0a00001c	 beq         |$LN11@UpdateScal|

; 3108 : 
; 3109 :     //  Access the regs
; 3110 :     if( AccessRegs() == FALSE )

  0002c	e1a00005	 mov         r0, r5
  00030	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00034	e3500000	 cmp         r0, #0
  00038	0a000015	 beq         |$cleanUp$38865|

; 3111 :         goto cleanUp;
; 3112 : 
; 3113 :     
; 3114 :     //  Update the scaling attributes
; 3115 :     bResult = SetScalingAttribs( ePipeline, pSrcRect, pDestRect );

  0003c	e1a03008	 mov         r3, r8
  00040	e1a02009	 mov         r2, r9
  00044	e1a01004	 mov         r1, r4
  00048	e1a00005	 mov         r0, r5
  0004c	eb000000	 bl          |?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z|
  00050	e1b06000	 movs        r6, r0

; 3116 :     if( bResult )

  00054	0a00000e	 beq         |$cleanUp$38865|

; 3117 :     {
; 3118 :         DWORD dwDestGo = 0;
; 3119 :     
; 3120 :         //  Get the destination for the pipeline
; 3121 :         switch( g_rgPipelineMapping[ePipeline].eDestination )

  00058	e0873284	 add         r3, r7, r4, lsl #5
  0005c	e5933004	 ldr         r3, [r3, #4]
  00060	e3530000	 cmp         r3, #0
  00064	0a000003	 beq         |$LN4@UpdateScal|
  00068	e3530001	 cmp         r3, #1
  0006c	1a000008	 bne         |$cleanUp$38865|

; 3126 :                 break;
; 3127 : 
; 3128 :             case OMAP_DSS_DESTINATION_TVOUT:
; 3129 :                 //  Set go bit for TV Out
; 3130 :                 dwDestGo  = DISPC_CONTROL_GODIGITAL;

  00070	e3a04040	 mov         r4, #0x40

; 3131 :                 break;

  00074	ea000000	 b           |$LN5@UpdateScal|
  00078		 |$LN4@UpdateScal|

; 3122 :         {
; 3123 :             case OMAP_DSS_DESTINATION_LCD:
; 3124 :                 //  Set go bit for LCD
; 3125 :                 dwDestGo  = DISPC_CONTROL_GOLCD;

  00078	e3a04020	 mov         r4, #0x20
  0007c		 |$LN5@UpdateScal|

; 3132 : 
; 3133 :             default:
; 3134 :                 ASSERT(0);
; 3135 :                 goto cleanUp;
; 3136 :         }
; 3137 : 
; 3138 :         //  Enable/update overlay optimization
; 3139 :         EnableOverlayOptimization( TRUE );

  0007c	e3a01001	 mov         r1, #1
  00080	e1a00005	 mov         r0, r5
  00084	eb000000	 bl          |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z|

; 3140 : 
; 3141 :         //  Flush the shadow registers
; 3142 :         FlushRegs( dwDestGo );

  00088	e1a01004	 mov         r1, r4
  0008c	e1a00005	 mov         r0, r5
  00090	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|
  00094		 |$cleanUp$38865|

; 3143 :     }    
; 3144 : 
; 3145 : 
; 3146 : cleanUp:
; 3147 :     //  Release regs
; 3148 :     ReleaseRegs();

  00094	e2853b01	 add         r3, r5, #1, 22
  00098	e283008c	 add         r0, r3, #0x8C
  0009c	eb000000	 bl          LeaveCriticalSection

; 3149 : 
; 3150 :     //  Return result
; 3151 :     return bResult;

  000a0		 |$LN11@UpdateScal|

; 3152 : }

  000a0	e1a00006	 mov         r0, r6
  000a4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN18@UpdateScal|
  000ac		 |$LN19@UpdateScal|
  000ac	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  000b0		 |$M41667|

			 ENDP  ; |?UpdateScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z|, OMAPDisplayController::UpdateScalingAttribs

	EXPORT	|?EnableColorKey@OMAPDisplayController@@QAAHW4OMAP_DSS_COLORKEY@@W4OMAP_DSS_DESTINATION@@K@Z| ; OMAPDisplayController::EnableColorKey

  00000			 AREA	 |.pdata|, PDATA
|$T41695| DCD	|$LN33@EnableColo|
	DCD	0x40006601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableColorKey@OMAPDisplayController@@QAAHW4OMAP_DSS_COLORKEY@@W4OMAP_DSS_DESTINATION@@K@Z| PROC ; OMAPDisplayController::EnableColorKey

; 3161 : {

  00000		 |$LN33@EnableColo|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004		 |$M41692|
  00004	e1a07003	 mov         r7, r3
  00008	e1a08002	 mov         r8, r2
  0000c	e1a05001	 mov         r5, r1
  00010	e1a04000	 mov         r4, r0

; 3162 :     BOOL    bResult = FALSE;
; 3163 :     DWORD   dwCurrentColor = 0;
; 3164 :     DWORD   dwDestGo = 0;
; 3165 : 
; 3166 : 
; 3167 :     //  Access the regs
; 3168 :     if( AccessRegs() == FALSE )

  00014	e3a09000	 mov         r9, #0
  00018	e3a06000	 mov         r6, #0
  0001c	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00020	e3500000	 cmp         r0, #0
  00024	0a000055	 beq         |$cleanUp$38888|

; 3169 :         goto cleanUp;
; 3170 : 
; 3171 :     
; 3172 :     //  Enable color key for the LCD
; 3173 :     if( eDestination == OMAP_DSS_DESTINATION_LCD )

  00028	e3580000	 cmp         r8, #0
  0002c	1a000028	 bne         |$LN22@EnableColo|

; 3174 :     {
; 3175 :         //  Set color key for LCD
; 3176 :         switch( eColorKey )

  00030	e3550000	 cmp         r5, #0
  00034	4a000051	 bmi         |$cleanUp$38888|
  00038	e3550001	 cmp         r5, #1
  0003c	da000013	 ble         |$LN19@EnableColo|
  00040	e3550003	 cmp         r5, #3
  00044	ca00004d	 bgt         |$cleanUp$38888|

; 3191 :                 
; 3192 :                 break;
; 3193 : 
; 3194 :                 
; 3195 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_GFX:
; 3196 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_VIDEO2:
; 3197 :                 //  Get current color (both LCD and VID2 are in this single register)
; 3198 :                 dwCurrentColor = INREG32( &m_pDispRegs->DISPC_GLOBAL_ALPHA );

  00048	e5941008	 ldr         r1, [r4, #8]

; 3199 :                 
; 3200 :                 //  Set global alpha color for LCD
; 3201 :                 if( eColorKey == OMAP_DSS_COLORKEY_GLOBAL_ALPHA_GFX )

  0004c	e3550002	 cmp         r5, #2
  00050	03e03cff	 mvneq       r3, #0xFF, 24
  00054	e5912074	 ldr         r2, [r1, #0x74]

; 3202 :                     dwColor = (dwCurrentColor & 0xFFFF0000) | DISPC_GLOBAL_ALPHA_GFX(dwColor);

  00058	022330ff	 eoreq       r3, r3, #0xFF
  0005c	00022003	 andeq       r2, r2, r3
  00060	020730ff	 andeq       r3, r7, #0xFF
  00064	01833002	 orreq       r3, r3, r2

; 3203 :                 else

  00068	13a03cff	 movne       r3, #0xFF, 24

; 3204 :                     dwColor = (dwCurrentColor & 0x0000FFFF) | DISPC_GLOBAL_ALPHA_VID2(dwColor);

  0006c	138330ff	 orrne       r3, r3, #0xFF
  00070	10022003	 andne       r2, r2, r3
  00074	120730ff	 andne       r3, r7, #0xFF
  00078	11823803	 orrne       r3, r2, r3, lsl #16

; 3205 : 
; 3206 :                 OUTREG32( &m_pDispRegs->DISPC_GLOBAL_ALPHA, dwColor );

  0007c	e5813074	 str         r3, [r1, #0x74]

; 3207 :                 
; 3208 :                 //  Enable LCD alpha blender
; 3209 :                 SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_LCDALPHABLENDERENABLE );

  00080	e5942008	 ldr         r2, [r4, #8]
  00084	e5923044	 ldr         r3, [r2, #0x44]
  00088	e3833701	 orr         r3, r3, #1, 14

; 3210 :                 break;

  0008c	ea00000a	 b           |$LN29@EnableColo|
  00090		 |$LN19@EnableColo|

; 3177 :         {
; 3178 :             case OMAP_DSS_COLORKEY_TRANS_SOURCE:
; 3179 :             case OMAP_DSS_COLORKEY_TRANS_DEST:
; 3180 :                 //  Set transparent color for LCD
; 3181 :                 OUTREG32( &m_pDispRegs->DISPC_TRANS_COLOR0, dwColor );

  00090	e5943008	 ldr         r3, [r4, #8]

; 3182 :                 
; 3183 :                 //  Enable LCD transparent color blender
; 3184 :                 SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE );
; 3185 : 
; 3186 :                 //  Select source or destination transparency
; 3187 :                 if( eColorKey == OMAP_DSS_COLORKEY_TRANS_SOURCE )

  00094	e3550000	 cmp         r5, #0
  00098	e5837054	 str         r7, [r3, #0x54]
  0009c	e5942008	 ldr         r2, [r4, #8]
  000a0	e5923044	 ldr         r3, [r2, #0x44]
  000a4	e3833b01	 orr         r3, r3, #1, 22
  000a8	e5823044	 str         r3, [r2, #0x44]

; 3188 :                     SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKLCDSELECTION );

  000ac	e5942008	 ldr         r2, [r4, #8]
  000b0	e5923044	 ldr         r3, [r2, #0x44]
  000b4	03833b02	 orreq       r3, r3, #2, 22

; 3189 :                 else
; 3190 :                     CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKLCDSELECTION );

  000b8	13c33b02	 bicne       r3, r3, #2, 22
  000bc		 |$LN29@EnableColo|

; 3211 : 
; 3212 :             default:
; 3213 :                 ASSERT(0);
; 3214 :                 goto cleanUp;
; 3215 :         }
; 3216 : 
; 3217 :         //  Display overlay optimization
; 3218 :         EnableOverlayOptimization( FALSE );

  000bc	e3a01000	 mov         r1, #0
  000c0	e1a00004	 mov         r0, r4
  000c4	e5823044	 str         r3, [r2, #0x44]
  000c8	eb000000	 bl          |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z|

; 3219 : 
; 3220 :         //  Set dest GO
; 3221 :         dwDestGo = DISPC_CONTROL_GOLCD;

  000cc	e3a06020	 mov         r6, #0x20
  000d0	ea000026	 b           |$LN11@EnableColo|
  000d4		 |$LN22@EnableColo|

; 3222 :     }
; 3223 : 
; 3224 : 
; 3225 :     //  Enable color key for TV out
; 3226 :     if( eDestination == OMAP_DSS_DESTINATION_TVOUT )

  000d4	e3580001	 cmp         r8, #1
  000d8	1a000024	 bne         |$LN11@EnableColo|

; 3227 :     {
; 3228 :         //  Set color key for TV out
; 3229 :         switch( eColorKey )

  000dc	e3550000	 cmp         r5, #0
  000e0	4a000026	 bmi         |$cleanUp$38888|
  000e4	e3550001	 cmp         r5, #1
  000e8	da000013	 ble         |$LN8@EnableColo|
  000ec	e3550003	 cmp         r5, #3
  000f0	ca000022	 bgt         |$cleanUp$38888|

; 3244 :                 
; 3245 :                 break;
; 3246 : 
; 3247 :                 
; 3248 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_GFX:
; 3249 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_VIDEO2:
; 3250 :                 //  Get current color (both LCD and VID2 are in this single register)
; 3251 :                 dwCurrentColor = INREG32( &m_pDispRegs->DISPC_GLOBAL_ALPHA );

  000f4	e5941008	 ldr         r1, [r4, #8]

; 3252 :                 
; 3253 :                 //  Set global alpha color
; 3254 :                 if( eColorKey == OMAP_DSS_COLORKEY_GLOBAL_ALPHA_GFX )

  000f8	e3550002	 cmp         r5, #2
  000fc	03e03cff	 mvneq       r3, #0xFF, 24
  00100	e5912074	 ldr         r2, [r1, #0x74]

; 3255 :                     dwColor = (dwCurrentColor & 0xFFFF0000) | DISPC_GLOBAL_ALPHA_GFX(dwColor);

  00104	022330ff	 eoreq       r3, r3, #0xFF
  00108	00022003	 andeq       r2, r2, r3
  0010c	020730ff	 andeq       r3, r7, #0xFF
  00110	01833002	 orreq       r3, r3, r2

; 3256 :                 else

  00114	13a03cff	 movne       r3, #0xFF, 24

; 3257 :                     dwColor = (dwCurrentColor & 0x0000FFFF) | DISPC_GLOBAL_ALPHA_VID2(dwColor);

  00118	138330ff	 orrne       r3, r3, #0xFF
  0011c	10022003	 andne       r2, r2, r3
  00120	120730ff	 andne       r3, r7, #0xFF
  00124	11823803	 orrne       r3, r2, r3, lsl #16

; 3258 : 
; 3259 :                 OUTREG32( &m_pDispRegs->DISPC_GLOBAL_ALPHA, dwColor );

  00128	e5813074	 str         r3, [r1, #0x74]

; 3260 :                 
; 3261 :                 //  Enable DIG alpha blender
; 3262 :                 SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_DIGALPHABLENDERENABLE );

  0012c	e5942008	 ldr         r2, [r4, #8]
  00130	e5923044	 ldr         r3, [r2, #0x44]
  00134	e3833702	 orr         r3, r3, #2, 14

; 3263 :                 break;

  00138	ea00000a	 b           |$LN30@EnableColo|
  0013c		 |$LN8@EnableColo|

; 3230 :         {
; 3231 :             case OMAP_DSS_COLORKEY_TRANS_SOURCE:
; 3232 :             case OMAP_DSS_COLORKEY_TRANS_DEST:
; 3233 :                 //  Set transparent color for DIG
; 3234 :                 OUTREG32( &m_pDispRegs->DISPC_TRANS_COLOR1, dwColor );

  0013c	e5943008	 ldr         r3, [r4, #8]

; 3235 :                 
; 3236 :                 //  Enable DIG transparent color blender
; 3237 :                 SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKDIGENABLE );
; 3238 : 
; 3239 :                 //  Select source or destination transparency
; 3240 :                 if( eColorKey == OMAP_DSS_COLORKEY_TRANS_SOURCE )

  00140	e3550000	 cmp         r5, #0
  00144	e5837058	 str         r7, [r3, #0x58]
  00148	e5942008	 ldr         r2, [r4, #8]
  0014c	e5923044	 ldr         r3, [r2, #0x44]
  00150	e3833a01	 orr         r3, r3, #1, 20
  00154	e5823044	 str         r3, [r2, #0x44]

; 3241 :                     SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKDIGSELECTION );

  00158	e5942008	 ldr         r2, [r4, #8]
  0015c	e5923044	 ldr         r3, [r2, #0x44]
  00160	03833a02	 orreq       r3, r3, #2, 20

; 3242 :                 else
; 3243 :                     CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKDIGSELECTION );

  00164	13c33a02	 bicne       r3, r3, #2, 20
  00168		 |$LN30@EnableColo|
  00168	e5823044	 str         r3, [r2, #0x44]

; 3264 : 
; 3265 :             default:
; 3266 :                 ASSERT(0);
; 3267 :                 goto cleanUp;
; 3268 :         }
; 3269 : 
; 3270 :         //  Set dest GO
; 3271 :         dwDestGo = DISPC_CONTROL_GODIGITAL;

  0016c	e3a06040	 mov         r6, #0x40
  00170		 |$LN11@EnableColo|

; 3272 :     }
; 3273 : 
; 3274 :     
; 3275 :     //  Flush the shadow registers
; 3276 :     FlushRegs( dwDestGo );

  00170	e1a01006	 mov         r1, r6
  00174	e1a00004	 mov         r0, r4
  00178	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 3277 : 
; 3278 :     
; 3279 :     //  Result
; 3280 :     bResult = TRUE;         

  0017c	e3a09001	 mov         r9, #1
  00180		 |$cleanUp$38888|

; 3281 : 
; 3282 : cleanUp:    
; 3283 :     //  Release regs
; 3284 :     ReleaseRegs();

  00180	e2843b01	 add         r3, r4, #1, 22
  00184	e283008c	 add         r0, r3, #0x8C
  00188	eb000000	 bl          LeaveCriticalSection

; 3285 :     
; 3286 :     //  Return result
; 3287 :     return bResult;
; 3288 : }

  0018c	e1a00009	 mov         r0, r9
  00190	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  00194	e12fff1e	 bx          lr
  00198		 |$M41693|

			 ENDP  ; |?EnableColorKey@OMAPDisplayController@@QAAHW4OMAP_DSS_COLORKEY@@W4OMAP_DSS_DESTINATION@@K@Z|, OMAPDisplayController::EnableColorKey

	EXPORT	|?DisableColorKey@OMAPDisplayController@@QAAHW4OMAP_DSS_COLORKEY@@W4OMAP_DSS_DESTINATION@@@Z| ; OMAPDisplayController::DisableColorKey

  00000			 AREA	 |.pdata|, PDATA
|$T41715| DCD	|$LN26@DisableCol|
	DCD	0x40003601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisableColorKey@OMAPDisplayController@@QAAHW4OMAP_DSS_COLORKEY@@W4OMAP_DSS_DESTINATION@@@Z| PROC ; OMAPDisplayController::DisableColorKey

; 3296 : {

  00000		 |$LN26@DisableCol|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M41712|
  00004	e1a07002	 mov         r7, r2
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 3297 :     BOOL    bResult = FALSE;
; 3298 :     DWORD   dwDestGo = 0;
; 3299 : 
; 3300 : 
; 3301 :     //  Access the regs
; 3302 :     if( AccessRegs() == FALSE )

  00010	e3a08000	 mov         r8, #0
  00014	e3a06000	 mov         r6, #0
  00018	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  0001c	e3500000	 cmp         r0, #0
  00020	0a000026	 beq         |$cleanUp$38960|

; 3303 :         goto cleanUp;
; 3304 : 
; 3305 :     
; 3306 :     //  Enable color key for the LCD
; 3307 :     if( eDestination == OMAP_DSS_DESTINATION_LCD )

  00024	e3570000	 cmp         r7, #0
  00028	1a00000f	 bne         |$LN14@DisableCol|

; 3308 :     {
; 3309 :         //  Set color key for LCD
; 3310 :         switch( eColorKey )

  0002c	e3540000	 cmp         r4, #0
  00030	4a000022	 bmi         |$cleanUp$38960|
  00034	e3540001	 cmp         r4, #1
  00038	da000006	 ble         |$LN11@DisableCol|
  0003c	e3540003	 cmp         r4, #3
  00040	ca00001e	 bgt         |$cleanUp$38960|

; 3316 :                 break;
; 3317 : 
; 3318 :                 
; 3319 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_GFX:
; 3320 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_VIDEO2:
; 3321 :                 //  Disable LCD alpha blender
; 3322 :                 CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_LCDALPHABLENDERENABLE );

  00044	e5952008	 ldr         r2, [r5, #8]

; 3323 :                 break;
; 3324 : 
; 3325 :             default:
; 3326 :                 ASSERT(0);
; 3327 :                 goto cleanUp;
; 3328 :         }
; 3329 :         
; 3330 :         //  Set dest GO
; 3331 :         dwDestGo = DISPC_CONTROL_GOLCD;

  00048	e3a06020	 mov         r6, #0x20
  0004c	e5923044	 ldr         r3, [r2, #0x44]
  00050	e3c33701	 bic         r3, r3, #1, 14
  00054	ea000014	 b           |$LN23@DisableCol|
  00058		 |$LN11@DisableCol|

; 3311 :         {
; 3312 :             case OMAP_DSS_COLORKEY_TRANS_SOURCE:
; 3313 :             case OMAP_DSS_COLORKEY_TRANS_DEST:
; 3314 :                 //  Disable LCD transparent color blender
; 3315 :                 CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKLCDENABLE );

  00058	e5952008	 ldr         r2, [r5, #8]

; 3323 :                 break;
; 3324 : 
; 3325 :             default:
; 3326 :                 ASSERT(0);
; 3327 :                 goto cleanUp;
; 3328 :         }
; 3329 :         
; 3330 :         //  Set dest GO
; 3331 :         dwDestGo = DISPC_CONTROL_GOLCD;

  0005c	e3a06020	 mov         r6, #0x20
  00060	e5923044	 ldr         r3, [r2, #0x44]
  00064	e3c33b01	 bic         r3, r3, #1, 22
  00068	ea00000f	 b           |$LN23@DisableCol|
  0006c		 |$LN14@DisableCol|

; 3332 :     }
; 3333 : 
; 3334 : 
; 3335 :     //  Enable color key for TV out
; 3336 :     if( eDestination == OMAP_DSS_DESTINATION_TVOUT )

  0006c	e3570001	 cmp         r7, #1
  00070	1a00000e	 bne         |$LN7@DisableCol|

; 3337 :     {
; 3338 :         //  Set color key for TV out
; 3339 :         switch( eColorKey )

  00074	e3540000	 cmp         r4, #0
  00078	4a000010	 bmi         |$cleanUp$38960|
  0007c	e3540001	 cmp         r4, #1
  00080	da000005	 ble         |$LN4@DisableCol|
  00084	e3540003	 cmp         r4, #3
  00088	ca00000c	 bgt         |$cleanUp$38960|

; 3345 :                 break;
; 3346 : 
; 3347 :                 
; 3348 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_GFX:
; 3349 :             case OMAP_DSS_COLORKEY_GLOBAL_ALPHA_VIDEO2:
; 3350 :                 //  Disable DIG alpha blender
; 3351 :                 CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_DIGALPHABLENDERENABLE );

  0008c	e5952008	 ldr         r2, [r5, #8]
  00090	e5923044	 ldr         r3, [r2, #0x44]
  00094	e3c33702	 bic         r3, r3, #2, 14

; 3352 :                 break;

  00098	ea000002	 b           |$LN22@DisableCol|
  0009c		 |$LN4@DisableCol|

; 3340 :         {
; 3341 :             case OMAP_DSS_COLORKEY_TRANS_SOURCE:
; 3342 :             case OMAP_DSS_COLORKEY_TRANS_DEST:
; 3343 :                 //  Disable DIG transparent color blender
; 3344 :                 CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKDIGENABLE );

  0009c	e5952008	 ldr         r2, [r5, #8]
  000a0	e5923044	 ldr         r3, [r2, #0x44]
  000a4	e3c33a01	 bic         r3, r3, #1, 20
  000a8		 |$LN22@DisableCol|

; 3353 : 
; 3354 :             default:
; 3355 :                 ASSERT(0);
; 3356 :                 goto cleanUp;
; 3357 :         }
; 3358 : 
; 3359 :         //  Set dest GO
; 3360 :         dwDestGo = DISPC_CONTROL_GODIGITAL;

  000a8	e3a06040	 mov         r6, #0x40
  000ac		 |$LN23@DisableCol|

; 3340 :         {
; 3341 :             case OMAP_DSS_COLORKEY_TRANS_SOURCE:
; 3342 :             case OMAP_DSS_COLORKEY_TRANS_DEST:
; 3343 :                 //  Disable DIG transparent color blender
; 3344 :                 CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_TCKDIGENABLE );

  000ac	e5823044	 str         r3, [r2, #0x44]
  000b0		 |$LN7@DisableCol|

; 3361 :     }
; 3362 : 
; 3363 :     
; 3364 :     //  Flush the shadow registers
; 3365 :     FlushRegs( dwDestGo );

  000b0	e1a01006	 mov         r1, r6
  000b4	e1a00005	 mov         r0, r5
  000b8	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 3366 : 
; 3367 :     
; 3368 :     //  Result
; 3369 :     bResult = TRUE;         

  000bc	e3a08001	 mov         r8, #1
  000c0		 |$cleanUp$38960|

; 3370 : 
; 3371 : cleanUp:    
; 3372 :     //  Release regs
; 3373 :     ReleaseRegs();

  000c0	e2853b01	 add         r3, r5, #1, 22
  000c4	e283008c	 add         r0, r3, #0x8C
  000c8	eb000000	 bl          LeaveCriticalSection

; 3374 :     
; 3375 :     //  Return result
; 3376 :     return bResult;
; 3377 : }

  000cc	e1a00008	 mov         r0, r8
  000d0	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000d4	e12fff1e	 bx          lr
  000d8		 |$M41713|

			 ENDP  ; |?DisableColorKey@OMAPDisplayController@@QAAHW4OMAP_DSS_COLORKEY@@W4OMAP_DSS_DESTINATION@@@Z|, OMAPDisplayController::DisableColorKey

	EXPORT	|?SaveRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z| ; OMAPDisplayController::SaveRegisters

  00000			 AREA	 |.pdata|, PDATA
|$T41735| DCD	|$LN27@SaveRegist|
	DCD	0x4000c301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SaveRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z| PROC ; OMAPDisplayController::SaveRegisters

; 3399 : {

  00000		 |$LN27@SaveRegist|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M41732|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 3400 :     BOOL    bResult = FALSE;
; 3401 :     DWORD   i;
; 3402 :     OMAP_DISPC_REGS   *pDisplaySaveRestore = 0;
; 3403 :     
; 3404 :     //  Access the regs
; 3405 :     if( AccessRegs() == FALSE )

  0000c	e3a05000	 mov         r5, #0
  00010	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00014	e3500000	 cmp         r0, #0
  00018	0a0000b4	 beq         |$cleanUp$39007|

; 3406 :         goto cleanUp;
; 3407 : 
; 3408 :     // Choose the last active LCD context ( internal LCD/external LCD)
; 3409 :     if (!m_bHDMIEnable)

  0001c	e59434c8	 ldr         r3, [r4, #0x4C8]
  00020	e3530000	 cmp         r3, #0

; 3410 :         pDisplaySaveRestore = &g_rgDisplaySaveRestore;

  00024	0284e018	 addeq       lr, r4, #0x18

; 3411 :     else
; 3412 :         pDisplaySaveRestore = &g_rgDisplaySaveRestore_eLcd;

  00028	1284ee25	 addne       lr, r4, #0x25, 28

; 3413 : 
; 3414 :     if (pDisplaySaveRestore == NULL)

  0002c	e35e0000	 cmp         lr, #0
  00030	0a0000ae	 beq         |$cleanUp$39007|

; 3415 :         goto cleanUp;
; 3416 : 
; 3417 :     // Save the DISPC common register contents 
; 3418 :     pDisplaySaveRestore->DISPC_CONFIG = INREG32 ( &m_pDispRegs->DISPC_CONFIG );

  00034	e5943008	 ldr         r3, [r4, #8]

; 3419 :     pDisplaySaveRestore->DISPC_GLOBAL_ALPHA = INREG32 (&m_pDispRegs->DISPC_GLOBAL_ALPHA );
; 3420 :     pDisplaySaveRestore->DISPC_IRQENABLE = INREG32( &m_pDispRegs->DISPC_IRQENABLE );
; 3421 :     pDisplaySaveRestore->DISPC_TRANS_COLOR0 = INREG32( &m_pDispRegs->DISPC_TRANS_COLOR0 );
; 3422 :     pDisplaySaveRestore->DISPC_TRANS_COLOR1 = INREG32( &m_pDispRegs->DISPC_TRANS_COLOR1 );
; 3423 : 
; 3424 :     //  Save the DSS and LCD registers
; 3425 :     if( eDestination == OMAP_DSS_DESTINATION_LCD )

  00038	e3560000	 cmp         r6, #0
  0003c	e5933044	 ldr         r3, [r3, #0x44]
  00040	e58e3044	 str         r3, [lr, #0x44]
  00044	e5943008	 ldr         r3, [r4, #8]
  00048	e5933074	 ldr         r3, [r3, #0x74]
  0004c	e58e3074	 str         r3, [lr, #0x74]
  00050	e5943008	 ldr         r3, [r4, #8]
  00054	e593301c	 ldr         r3, [r3, #0x1C]
  00058	e58e301c	 str         r3, [lr, #0x1C]
  0005c	e5943008	 ldr         r3, [r4, #8]
  00060	e5933054	 ldr         r3, [r3, #0x54]
  00064	e58e3054	 str         r3, [lr, #0x54]
  00068	e5943008	 ldr         r3, [r4, #8]
  0006c	e5933058	 ldr         r3, [r3, #0x58]
  00070	e58e3058	 str         r3, [lr, #0x58]
  00074	1a00009c	 bne         |$LN1@SaveRegist|

; 3426 :     {
; 3427 :         //  Save off GFX plane registers if enabled
; 3428 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled )

  00078	e59f5288	 ldr         r5, [pc, #0x288]
  0007c	e5953000	 ldr         r3, [r5]
  00080	e3530000	 cmp         r3, #0
  00084	0a00001a	 beq         |$LN9@SaveRegist|

; 3429 :         {
; 3430 :             pDisplaySaveRestore->DISPC_GFX_BA0 = INREG32( &m_pDispRegs->DISPC_GFX_BA0 );

  00088	e5943008	 ldr         r3, [r4, #8]

; 3431 :             pDisplaySaveRestore->DISPC_GFX_BA1 = INREG32( &m_pDispRegs->DISPC_GFX_BA1 );

  0008c	e5933080	 ldr         r3, [r3, #0x80]

; 3432 :             pDisplaySaveRestore->DISPC_GFX_POSITION = INREG32( &m_pDispRegs->DISPC_GFX_POSITION );
; 3433 :             pDisplaySaveRestore->DISPC_GFX_SIZE = INREG32( &m_pDispRegs->DISPC_GFX_SIZE );

  00090	e58e3080	 str         r3, [lr, #0x80]
  00094	e5943008	 ldr         r3, [r4, #8]

; 3434 :             pDisplaySaveRestore->DISPC_GFX_ATTRIBUTES = INREG32( &m_pDispRegs->DISPC_GFX_ATTRIBUTES );
; 3435 :             pDisplaySaveRestore->DISPC_GFX_FIFO_THRESHOLD = INREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD );

  00098	e5933084	 ldr         r3, [r3, #0x84]

; 3436 :             pDisplaySaveRestore->DISPC_GFX_ROW_INC = INREG32( &m_pDispRegs->DISPC_GFX_ROW_INC );
; 3437 :             pDisplaySaveRestore->DISPC_GFX_PIXEL_INC = INREG32( &m_pDispRegs->DISPC_GFX_PIXEL_INC );

  0009c	e58e3084	 str         r3, [lr, #0x84]
  000a0	e5943008	 ldr         r3, [r4, #8]

; 3438 :             pDisplaySaveRestore->DISPC_GFX_WINDOW_SKIP = INREG32( &m_pDispRegs->DISPC_GFX_WINDOW_SKIP );

  000a4	e5933088	 ldr         r3, [r3, #0x88]
  000a8	e58e3088	 str         r3, [lr, #0x88]
  000ac	e5943008	 ldr         r3, [r4, #8]
  000b0	e593308c	 ldr         r3, [r3, #0x8C]
  000b4	e58e308c	 str         r3, [lr, #0x8C]
  000b8	e5943008	 ldr         r3, [r4, #8]
  000bc	e59330a0	 ldr         r3, [r3, #0xA0]
  000c0	e58e30a0	 str         r3, [lr, #0xA0]
  000c4	e5943008	 ldr         r3, [r4, #8]
  000c8	e59330a4	 ldr         r3, [r3, #0xA4]
  000cc	e58e30a4	 str         r3, [lr, #0xA4]
  000d0	e5943008	 ldr         r3, [r4, #8]
  000d4	e59330ac	 ldr         r3, [r3, #0xAC]
  000d8	e58e30ac	 str         r3, [lr, #0xAC]
  000dc	e5943008	 ldr         r3, [r4, #8]
  000e0	e59330b0	 ldr         r3, [r3, #0xB0]
  000e4	e58e30b0	 str         r3, [lr, #0xB0]
  000e8	e5943008	 ldr         r3, [r4, #8]
  000ec	e59330b4	 ldr         r3, [r3, #0xB4]
  000f0	e58e30b4	 str         r3, [lr, #0xB4]
  000f4		 |$LN9@SaveRegist|

; 3439 :         }
; 3440 : 
; 3441 :         //  Save off VID1 plane registers if enabled
; 3442 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled )

  000f4	e5953020	 ldr         r3, [r5, #0x20]
  000f8	e3530000	 cmp         r3, #0
  000fc	0a00003b	 beq         |$LN5@SaveRegist|

; 3443 :         {
; 3444 :             pDisplaySaveRestore->tDISPC_VID1.BA0 = INREG32( &m_pDispRegs->tDISPC_VID1.BA0 );

  00100	e5943008	 ldr         r3, [r4, #8]

; 3445 :             pDisplaySaveRestore->tDISPC_VID1.BA1 = INREG32( &m_pDispRegs->tDISPC_VID1.BA1 );
; 3446 :             pDisplaySaveRestore->tDISPC_VID1.POSITION = INREG32( &m_pDispRegs->tDISPC_VID1.POSITION );
; 3447 :             pDisplaySaveRestore->tDISPC_VID1.SIZE = INREG32( &m_pDispRegs->tDISPC_VID1.SIZE );
; 3448 :             pDisplaySaveRestore->tDISPC_VID1.ATTRIBUTES = INREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES );
; 3449 :             pDisplaySaveRestore->tDISPC_VID1.FIFO_THRESHOLD = INREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD );
; 3450 :             pDisplaySaveRestore->tDISPC_VID1.ROW_INC = INREG32( &m_pDispRegs->tDISPC_VID1.ROW_INC );
; 3451 :             pDisplaySaveRestore->tDISPC_VID1.PIXEL_INC = INREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC );
; 3452 :             pDisplaySaveRestore->tDISPC_VID1.FIR = INREG32( &m_pDispRegs->tDISPC_VID1.FIR );
; 3453 :             pDisplaySaveRestore->tDISPC_VID1.PICTURE_SIZE = INREG32( &m_pDispRegs->tDISPC_VID1.PICTURE_SIZE );
; 3454 :             pDisplaySaveRestore->tDISPC_VID1.ACCU0 = INREG32( &m_pDispRegs->tDISPC_VID1.ACCU0 );
; 3455 :             pDisplaySaveRestore->tDISPC_VID1.ACCU1 = INREG32( &m_pDispRegs->tDISPC_VID1.ACCU1 );

  00104	e3e020ef	 mvn         r2, #0xEF
  00108	e3a07e1e	 mov         r7, #0x1E, 28
  0010c	e59330bc	 ldr         r3, [r3, #0xBC]
  00110	e3a080f0	 mov         r8, #0xF0
  00114	e28e60f0	 add         r6, lr, #0xF0
  00118	e58e30bc	 str         r3, [lr, #0xBC]
  0011c	e5943008	 ldr         r3, [r4, #8]
  00120	e06ea002	 rsb         r10, lr, r2
  00124	e3a09008	 mov         r9, #8
  00128	e59330c0	 ldr         r3, [r3, #0xC0]
  0012c	e58e30c0	 str         r3, [lr, #0xC0]
  00130	e5943008	 ldr         r3, [r4, #8]
  00134	e59330c4	 ldr         r3, [r3, #0xC4]
  00138	e58e30c4	 str         r3, [lr, #0xC4]
  0013c	e5943008	 ldr         r3, [r4, #8]
  00140	e59330c8	 ldr         r3, [r3, #0xC8]
  00144	e58e30c8	 str         r3, [lr, #0xC8]
  00148	e5943008	 ldr         r3, [r4, #8]
  0014c	e59330cc	 ldr         r3, [r3, #0xCC]
  00150	e58e30cc	 str         r3, [lr, #0xCC]
  00154	e5943008	 ldr         r3, [r4, #8]
  00158	e59330d0	 ldr         r3, [r3, #0xD0]
  0015c	e58e30d0	 str         r3, [lr, #0xD0]
  00160	e5943008	 ldr         r3, [r4, #8]
  00164	e59330d8	 ldr         r3, [r3, #0xD8]
  00168	e58e30d8	 str         r3, [lr, #0xD8]
  0016c	e5943008	 ldr         r3, [r4, #8]
  00170	e59330dc	 ldr         r3, [r3, #0xDC]
  00174	e58e30dc	 str         r3, [lr, #0xDC]
  00178	e5943008	 ldr         r3, [r4, #8]
  0017c	e59330e0	 ldr         r3, [r3, #0xE0]
  00180	e58e30e0	 str         r3, [lr, #0xE0]
  00184	e5943008	 ldr         r3, [r4, #8]
  00188	e59330e4	 ldr         r3, [r3, #0xE4]
  0018c	e58e30e4	 str         r3, [lr, #0xE4]
  00190	e5943008	 ldr         r3, [r4, #8]
  00194	e59330e8	 ldr         r3, [r3, #0xE8]
  00198	e58e30e8	 str         r3, [lr, #0xE8]
  0019c	e5943008	 ldr         r3, [r4, #8]
  001a0	e59330ec	 ldr         r3, [r3, #0xEC]
  001a4	e58e30ec	 str         r3, [lr, #0xEC]
  001a8		 |$LL7@SaveRegist|

; 3456 : 
; 3457 :             //  Scaling coefficients
; 3458 :             for( i = 0; i < NUM_SCALING_PHASES; i++ )
; 3459 :             {
; 3460 :                 pDisplaySaveRestore->tDISPC_VID1.aFIR_COEF[i].ulH = INREG32( &m_pDispRegs->tDISPC_VID1.aFIR_COEF[i].ulH );

  001a8	e5943008	 ldr         r3, [r4, #8]

; 3461 :                 pDisplaySaveRestore->tDISPC_VID1.aFIR_COEF[i].ulHV = INREG32( &m_pDispRegs->tDISPC_VID1.aFIR_COEF[i].ulHV );

  001ac	e08a2006	 add         r2, r10, r6
  001b0	e2861004	 add         r1, r6, #4
  001b4	e7983003	 ldr         r3, [r8, +r3]

; 3462 :                 pDisplaySaveRestore->DISPC_VID1_FIR_COEF_V[i] = INREG32( &m_pDispRegs->DISPC_VID1_FIR_COEF_V[i] );

  001b8	e087000e	 add         r0, r7, lr
  001bc	e2888008	 add         r8, r8, #8
  001c0	e5863000	 str         r3, [r6]
  001c4	e5943008	 ldr         r3, [r4, #8]
  001c8	e2866008	 add         r6, r6, #8
  001cc	e2599001	 subs        r9, r9, #1
  001d0	e0823003	 add         r3, r2, r3
  001d4	e59330f4	 ldr         r3, [r3, #0xF4]
  001d8	e5813000	 str         r3, [r1]
  001dc	e5943008	 ldr         r3, [r4, #8]
  001e0	e7973003	 ldr         r3, [r7, +r3]
  001e4	e2877004	 add         r7, r7, #4
  001e8	e5803000	 str         r3, [r0]
  001ec	1affffed	 bne         |$LL7@SaveRegist|
  001f0		 |$LN5@SaveRegist|

; 3463 :             }
; 3464 :         }
; 3465 :         
; 3466 :         //  Save off VID2 plane registers if enabled
; 3467 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled )

  001f0	e5953040	 ldr         r3, [r5, #0x40]
  001f4	e3530000	 cmp         r3, #0
  001f8	0a00003b	 beq         |$LN1@SaveRegist|

; 3468 :         {
; 3469 :             pDisplaySaveRestore->tDISPC_VID2.BA0 = INREG32( &m_pDispRegs->tDISPC_VID2.BA0 );

  001fc	e5943008	 ldr         r3, [r4, #8]

; 3470 :             pDisplaySaveRestore->tDISPC_VID2.BA1 = INREG32( &m_pDispRegs->tDISPC_VID2.BA1 );
; 3471 :             pDisplaySaveRestore->tDISPC_VID2.POSITION = INREG32( &m_pDispRegs->tDISPC_VID2.POSITION );
; 3472 :             pDisplaySaveRestore->tDISPC_VID2.SIZE = INREG32( &m_pDispRegs->tDISPC_VID2.SIZE );
; 3473 :             pDisplaySaveRestore->tDISPC_VID2.ATTRIBUTES = INREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES );
; 3474 :             pDisplaySaveRestore->tDISPC_VID2.FIFO_THRESHOLD = INREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD );
; 3475 :             pDisplaySaveRestore->tDISPC_VID2.ROW_INC = INREG32( &m_pDispRegs->tDISPC_VID2.ROW_INC );
; 3476 :             pDisplaySaveRestore->tDISPC_VID2.PIXEL_INC = INREG32( &m_pDispRegs->tDISPC_VID2.PIXEL_INC );
; 3477 :             pDisplaySaveRestore->tDISPC_VID2.FIR = INREG32( &m_pDispRegs->tDISPC_VID2.FIR );
; 3478 :             pDisplaySaveRestore->tDISPC_VID2.PICTURE_SIZE = INREG32( &m_pDispRegs->tDISPC_VID2.PICTURE_SIZE );
; 3479 :             pDisplaySaveRestore->tDISPC_VID2.ACCU0 = INREG32( &m_pDispRegs->tDISPC_VID2.ACCU0 );

  00200	e3e020bf	 mvn         r2, #0xBF

; 3480 :             pDisplaySaveRestore->tDISPC_VID2.ACCU1 = INREG32( &m_pDispRegs->tDISPC_VID2.ACCU1 );

  00204	e3a06c02	 mov         r6, #2, 24
  00208	e593314c	 ldr         r3, [r3, #0x14C]
  0020c	e3a07d06	 mov         r7, #6, 26
  00210	e28e5d06	 add         r5, lr, #6, 26
  00214	e58e314c	 str         r3, [lr, #0x14C]
  00218	e5943008	 ldr         r3, [r4, #8]
  0021c	e06e9082	 rsb         r9, lr, r2, lsl #1
  00220	e3a08008	 mov         r8, #8
  00224	e5933150	 ldr         r3, [r3, #0x150]
  00228	e58e3150	 str         r3, [lr, #0x150]
  0022c	e5943008	 ldr         r3, [r4, #8]
  00230	e5933154	 ldr         r3, [r3, #0x154]
  00234	e58e3154	 str         r3, [lr, #0x154]
  00238	e5943008	 ldr         r3, [r4, #8]
  0023c	e5933158	 ldr         r3, [r3, #0x158]
  00240	e58e3158	 str         r3, [lr, #0x158]
  00244	e5943008	 ldr         r3, [r4, #8]
  00248	e593315c	 ldr         r3, [r3, #0x15C]
  0024c	e58e315c	 str         r3, [lr, #0x15C]
  00250	e5943008	 ldr         r3, [r4, #8]
  00254	e5933160	 ldr         r3, [r3, #0x160]
  00258	e58e3160	 str         r3, [lr, #0x160]
  0025c	e5943008	 ldr         r3, [r4, #8]
  00260	e5933168	 ldr         r3, [r3, #0x168]
  00264	e58e3168	 str         r3, [lr, #0x168]
  00268	e5943008	 ldr         r3, [r4, #8]
  0026c	e593316c	 ldr         r3, [r3, #0x16C]
  00270	e58e316c	 str         r3, [lr, #0x16C]
  00274	e5943008	 ldr         r3, [r4, #8]
  00278	e5933170	 ldr         r3, [r3, #0x170]
  0027c	e58e3170	 str         r3, [lr, #0x170]
  00280	e5943008	 ldr         r3, [r4, #8]
  00284	e5933174	 ldr         r3, [r3, #0x174]
  00288	e58e3174	 str         r3, [lr, #0x174]
  0028c	e5943008	 ldr         r3, [r4, #8]
  00290	e5933178	 ldr         r3, [r3, #0x178]
  00294	e58e3178	 str         r3, [lr, #0x178]
  00298	e5943008	 ldr         r3, [r4, #8]
  0029c	e593317c	 ldr         r3, [r3, #0x17C]
  002a0	e58e317c	 str         r3, [lr, #0x17C]
  002a4		 |$LL3@SaveRegist|

; 3481 : 
; 3482 :             //  Scaling coefficients
; 3483 :             for( i = 0; i < NUM_SCALING_PHASES; i++ )
; 3484 :             {
; 3485 :                 pDisplaySaveRestore->tDISPC_VID2.aFIR_COEF[i].ulH = INREG32( &m_pDispRegs->tDISPC_VID2.aFIR_COEF[i].ulH );

  002a4	e5943008	 ldr         r3, [r4, #8]

; 3486 :                 pDisplaySaveRestore->tDISPC_VID2.aFIR_COEF[i].ulHV = INREG32( &m_pDispRegs->tDISPC_VID2.aFIR_COEF[i].ulHV );

  002a8	e0892005	 add         r2, r9, r5
  002ac	e2851004	 add         r1, r5, #4
  002b0	e7973003	 ldr         r3, [r7, +r3]

; 3487 :                 pDisplaySaveRestore->DISPC_VID2_FIR_COEF_V[i] = INREG32( &m_pDispRegs->DISPC_VID2_FIR_COEF_V[i] );

  002b4	e086000e	 add         r0, r6, lr
  002b8	e2877008	 add         r7, r7, #8
  002bc	e5853000	 str         r3, [r5]
  002c0	e5943008	 ldr         r3, [r4, #8]
  002c4	e2855008	 add         r5, r5, #8
  002c8	e2588001	 subs        r8, r8, #1
  002cc	e0823003	 add         r3, r2, r3
  002d0	e5933184	 ldr         r3, [r3, #0x184]
  002d4	e5813000	 str         r3, [r1]
  002d8	e5943008	 ldr         r3, [r4, #8]
  002dc	e7963003	 ldr         r3, [r6, +r3]
  002e0	e2866004	 add         r6, r6, #4
  002e4	e5803000	 str         r3, [r0]
  002e8	1affffed	 bne         |$LL3@SaveRegist|
  002ec		 |$LN1@SaveRegist|

; 3488 :             }
; 3489 :         }
; 3490 :     }
; 3491 :     
; 3492 :     
; 3493 :     //  Success
; 3494 :     bResult = TRUE;

  002ec	e3a05001	 mov         r5, #1
  002f0		 |$cleanUp$39007|

; 3495 : 
; 3496 : cleanUp:
; 3497 :     //  Release regs
; 3498 :     ReleaseRegs();

  002f0	e2843b01	 add         r3, r4, #1, 22
  002f4	e283008c	 add         r0, r3, #0x8C
  002f8	eb000000	 bl          LeaveCriticalSection

; 3499 : 
; 3500 :     //  Return result
; 3501 :     return bResult;
; 3502 : }

  002fc	e1a00005	 mov         r0, r5
  00300	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00304	e12fff1e	 bx          lr
  00308		 |$LN28@SaveRegist|
  00308		 |$LN29@SaveRegist|
  00308	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  0030c		 |$M41733|

			 ENDP  ; |?SaveRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|, OMAPDisplayController::SaveRegisters

	EXPORT	|?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z| ; OMAPDisplayController::RestoreRegisters
	IMPORT	|LcdPdd_TV_GetMode|
	IMPORT	|LcdPdd_TV_Initialize|
	IMPORT	|LcdPdd_LCD_Initialize|
	IMPORT	|?g_dwVencValues_NTSC@@3PAKA|		; g_dwVencValues_NTSC
	IMPORT	|?g_dwVencValues_PAL@@3PAKA|		; g_dwVencValues_PAL

  00000			 AREA	 |.pdata|, PDATA
|$T41765| DCD	|$LN39@RestoreReg|
	DCD	0x40019b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z| PROC ; OMAPDisplayController::RestoreRegisters

; 3509 : {

  00000		 |$LN39@RestoreReg|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M41762|
  00004	e1a08001	 mov         r8, r1
  00008	e1a04000	 mov         r4, r0

; 3510 :     BOOL    bResult = FALSE;
; 3511 :     DWORD   i;
; 3512 :     OMAP_DISPC_REGS   *pDisplaySaveRestore = 0;
; 3513 :     
; 3514 :     //  Access the regs
; 3515 :     if( AccessRegs() == FALSE )

  0000c	e3a06000	 mov         r6, #0
  00010	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00014	e3500000	 cmp         r0, #0
  00018	0a00018a	 beq         |$cleanUp$39075|

; 3516 :         goto cleanUp;
; 3517 : 
; 3518 :     // Choose the last active LCD context ( internal LCD/external LCD)
; 3519 :     if (!m_bHDMIEnable)

  0001c	e59434c8	 ldr         r3, [r4, #0x4C8]
  00020	e3530000	 cmp         r3, #0

; 3520 :         pDisplaySaveRestore = &g_rgDisplaySaveRestore;

  00024	02845018	 addeq       r5, r4, #0x18

; 3521 :     else
; 3522 :         pDisplaySaveRestore = &g_rgDisplaySaveRestore_eLcd;

  00028	12845e25	 addne       r5, r4, #0x25, 28

; 3523 : 
; 3524 :     if (pDisplaySaveRestore == NULL)

  0002c	e3550000	 cmp         r5, #0
  00030	0a000184	 beq         |$cleanUp$39075|

; 3525 :         goto cleanUp;
; 3526 : 
; 3527 :         
; 3528 :     //  Restore the DSS and LCD registers
; 3529 :     if( eDestination == OMAP_DSS_DESTINATION_LCD )

  00034	e3580000	 cmp         r8, #0
  00038	1a0000e5	 bne         |$LN7@RestoreReg|

; 3530 :     {
; 3531 :         //  Configure interconnect parameters
; 3532 :         OUTREG32( &m_pDSSRegs->DSS_SYSCONFIG, DISPC_SYSCONFIG_AUTOIDLE );

  0003c	e5943004	 ldr         r3, [r4, #4]
  00040	e3a02001	 mov         r2, #1
  00044	e3a01a01	 mov         r1, #1, 20
  00048	e5832010	 str         r2, [r3, #0x10]

; 3533 :         OUTREG32( &m_pDispRegs->DISPC_SYSCONFIG, DISPC_SYSCONFIG_AUTOIDLE|SYSCONFIG_NOIDLE|SYSCONFIG_NOSTANDBY );

  0004c	e5942008	 ldr         r2, [r4, #8]
  00050	e3813009	 orr         r3, r1, #9

; 3534 : 
; 3535 :         //  Not enabling any interrupts
; 3536 :         OUTREG32( &m_pDispRegs->DISPC_IRQENABLE , pDisplaySaveRestore->DISPC_IRQENABLE);

  00054	e5823010	 str         r3, [r2, #0x10]
  00058	e5941008	 ldr         r1, [r4, #8]
  0005c	e595301c	 ldr         r3, [r5, #0x1C]

; 3537 : 
; 3538 :         //  Initialize the LCD by calling PDD
; 3539 :         LcdPdd_LCD_Initialize(
; 3540 :             m_pDSSRegs,
; 3541 :             m_pDispRegs,
; 3542 :             NULL,
; 3543 :             m_pVencRegs);

  00060	e3a02000	 mov         r2, #0
  00064	e581301c	 str         r3, [r1, #0x1C]
  00068	e594300c	 ldr         r3, [r4, #0xC]
  0006c	e5941008	 ldr         r1, [r4, #8]
  00070	e5940004	 ldr         r0, [r4, #4]
  00074	eb000000	 bl          LcdPdd_LCD_Initialize

; 3544 : 
; 3545 :         OUTREG32( &m_pDispRegs->DISPC_CONFIG, pDisplaySaveRestore->DISPC_CONFIG );

  00078	e5942008	 ldr         r2, [r4, #8]
  0007c	e5953044	 ldr         r3, [r5, #0x44]

; 3546 : 
; 3547 :         //Enable/Disable Gamma correction
; 3548 :         if(m_bGammaEnable)
; 3549 :             SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_PALETTEGAMMATABLE );
; 3550 :         else
; 3551 :             CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_PALETTEGAMMATABLE );
; 3552 : 
; 3553 :         // Load Gamma Table
; 3554 :         OUTREG32( &m_pDispRegs->DISPC_GFX_TABLE_BA, m_dwGammaBufPhys);
; 3555 : 
; 3556 :         //  Restore global alpha value
; 3557 :         OUTREG32( &m_pDispRegs->DISPC_GLOBAL_ALPHA, pDisplaySaveRestore->DISPC_GLOBAL_ALPHA );
; 3558 : 
; 3559 :         // Restore transparency value
; 3560 :         OUTREG32( &m_pDispRegs->DISPC_TRANS_COLOR0, pDisplaySaveRestore->DISPC_TRANS_COLOR0 );
; 3561 :         OUTREG32( &m_pDispRegs->DISPC_TRANS_COLOR1, pDisplaySaveRestore->DISPC_TRANS_COLOR1 );
; 3562 : 
; 3563 :         //  Restore GFX plane registers if enabled
; 3564 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled )

  00080	e59f65e0	 ldr         r6, [pc, #0x5E0]
  00084	e5823044	 str         r3, [r2, #0x44]
  00088	e59434dc	 ldr         r3, [r4, #0x4DC]
  0008c	e5942008	 ldr         r2, [r4, #8]
  00090	e3530000	 cmp         r3, #0
  00094	e5923044	 ldr         r3, [r2, #0x44]
  00098	13833008	 orrne       r3, r3, #8
  0009c	03c33008	 biceq       r3, r3, #8
  000a0	e5823044	 str         r3, [r2, #0x44]
  000a4	e5942008	 ldr         r2, [r4, #8]
  000a8	e59434d8	 ldr         r3, [r4, #0x4D8]
  000ac	e58230b8	 str         r3, [r2, #0xB8]
  000b0	e5942008	 ldr         r2, [r4, #8]
  000b4	e5953074	 ldr         r3, [r5, #0x74]
  000b8	e5823074	 str         r3, [r2, #0x74]
  000bc	e5942008	 ldr         r2, [r4, #8]
  000c0	e5953054	 ldr         r3, [r5, #0x54]
  000c4	e5823054	 str         r3, [r2, #0x54]
  000c8	e5942008	 ldr         r2, [r4, #8]
  000cc	e5953058	 ldr         r3, [r5, #0x58]
  000d0	e5823058	 str         r3, [r2, #0x58]
  000d4	e5963000	 ldr         r3, [r6]
  000d8	e3530000	 cmp         r3, #0
  000dc	0a00001a	 beq         |$LN12@RestoreReg|

; 3565 :         {
; 3566 :             OUTREG32( &m_pDispRegs->DISPC_GFX_BA0, pDisplaySaveRestore->DISPC_GFX_BA0 );

  000e0	e5942008	 ldr         r2, [r4, #8]
  000e4	e5953080	 ldr         r3, [r5, #0x80]

; 3567 :             OUTREG32( &m_pDispRegs->DISPC_GFX_BA1, pDisplaySaveRestore->DISPC_GFX_BA1 );

  000e8	e5823080	 str         r3, [r2, #0x80]
  000ec	e5942008	 ldr         r2, [r4, #8]
  000f0	e5953084	 ldr         r3, [r5, #0x84]

; 3568 :             OUTREG32( &m_pDispRegs->DISPC_GFX_POSITION, pDisplaySaveRestore->DISPC_GFX_POSITION );

  000f4	e5823084	 str         r3, [r2, #0x84]
  000f8	e5942008	 ldr         r2, [r4, #8]
  000fc	e5953088	 ldr         r3, [r5, #0x88]

; 3569 :             OUTREG32( &m_pDispRegs->DISPC_GFX_SIZE, pDisplaySaveRestore->DISPC_GFX_SIZE );

  00100	e5823088	 str         r3, [r2, #0x88]
  00104	e5942008	 ldr         r2, [r4, #8]
  00108	e595308c	 ldr         r3, [r5, #0x8C]

; 3570 :             OUTREG32( &m_pDispRegs->DISPC_GFX_ATTRIBUTES, pDisplaySaveRestore->DISPC_GFX_ATTRIBUTES );

  0010c	e582308c	 str         r3, [r2, #0x8C]
  00110	e5942008	 ldr         r2, [r4, #8]
  00114	e59530a0	 ldr         r3, [r5, #0xA0]

; 3571 :             OUTREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD, pDisplaySaveRestore->DISPC_GFX_FIFO_THRESHOLD );

  00118	e58230a0	 str         r3, [r2, #0xA0]
  0011c	e5942008	 ldr         r2, [r4, #8]
  00120	e59530a4	 ldr         r3, [r5, #0xA4]

; 3572 :             OUTREG32( &m_pDispRegs->DISPC_GFX_ROW_INC, pDisplaySaveRestore->DISPC_GFX_ROW_INC );

  00124	e58230a4	 str         r3, [r2, #0xA4]
  00128	e5942008	 ldr         r2, [r4, #8]
  0012c	e59530ac	 ldr         r3, [r5, #0xAC]

; 3573 :             OUTREG32( &m_pDispRegs->DISPC_GFX_PIXEL_INC, pDisplaySaveRestore->DISPC_GFX_PIXEL_INC );

  00130	e58230ac	 str         r3, [r2, #0xAC]
  00134	e5942008	 ldr         r2, [r4, #8]
  00138	e59530b0	 ldr         r3, [r5, #0xB0]

; 3574 :             OUTREG32( &m_pDispRegs->DISPC_GFX_WINDOW_SKIP, pDisplaySaveRestore->DISPC_GFX_WINDOW_SKIP );

  0013c	e58230b0	 str         r3, [r2, #0xB0]
  00140	e5942008	 ldr         r2, [r4, #8]
  00144	e59530b4	 ldr         r3, [r5, #0xB4]
  00148	e58230b4	 str         r3, [r2, #0xB4]
  0014c		 |$LN12@RestoreReg|

; 3575 :         }
; 3576 : 
; 3577 : 
; 3578 :         //  Restore VID1 plane registers if enabled
; 3579 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled )

  0014c	e5963020	 ldr         r3, [r6, #0x20]
  00150	e3530000	 cmp         r3, #0
  00154	0a00004d	 beq         |$LN11@RestoreReg|

; 3580 :         {
; 3581 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.BA0, pDisplaySaveRestore->tDISPC_VID1.BA0 );

  00158	e5942008	 ldr         r2, [r4, #8]
  0015c	e59530bc	 ldr         r3, [r5, #0xBC]

; 3582 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.BA1, pDisplaySaveRestore->tDISPC_VID1.BA1 );
; 3583 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.POSITION, pDisplaySaveRestore->tDISPC_VID1.POSITION );
; 3584 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.SIZE, pDisplaySaveRestore->tDISPC_VID1.SIZE );
; 3585 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES, pDisplaySaveRestore->tDISPC_VID1.ATTRIBUTES );
; 3586 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD, pDisplaySaveRestore->tDISPC_VID1.FIFO_THRESHOLD );
; 3587 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.ROW_INC, pDisplaySaveRestore->tDISPC_VID1.ROW_INC );
; 3588 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.PIXEL_INC, pDisplaySaveRestore->tDISPC_VID1.PIXEL_INC );
; 3589 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.FIR, pDisplaySaveRestore->tDISPC_VID1.FIR );
; 3590 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.PICTURE_SIZE, pDisplaySaveRestore->tDISPC_VID1.PICTURE_SIZE );
; 3591 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.ACCU0, pDisplaySaveRestore->tDISPC_VID1.ACCU0 );
; 3592 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.ACCU1, pDisplaySaveRestore->tDISPC_VID1.ACCU1 );

  00160	e3e010ef	 mvn         r1, #0xEF
  00164	e3a0ee1e	 mov         lr, #0x1E, 28
  00168	e58230bc	 str         r3, [r2, #0xBC]
  0016c	e5942008	 ldr         r2, [r4, #8]
  00170	e59530c0	 ldr         r3, [r5, #0xC0]
  00174	e3a070f0	 mov         r7, #0xF0
  00178	e28500f0	 add         r0, r5, #0xF0
  0017c	e58230c0	 str         r3, [r2, #0xC0]
  00180	e5942008	 ldr         r2, [r4, #8]
  00184	e59530c4	 ldr         r3, [r5, #0xC4]
  00188	e065a001	 rsb         r10, r5, r1
  0018c	e3a09008	 mov         r9, #8
  00190	e58230c4	 str         r3, [r2, #0xC4]
  00194	e5942008	 ldr         r2, [r4, #8]
  00198	e59530c8	 ldr         r3, [r5, #0xC8]
  0019c	e58230c8	 str         r3, [r2, #0xC8]
  001a0	e5942008	 ldr         r2, [r4, #8]
  001a4	e59530cc	 ldr         r3, [r5, #0xCC]
  001a8	e58230cc	 str         r3, [r2, #0xCC]
  001ac	e5942008	 ldr         r2, [r4, #8]
  001b0	e59530d0	 ldr         r3, [r5, #0xD0]
  001b4	e58230d0	 str         r3, [r2, #0xD0]
  001b8	e5942008	 ldr         r2, [r4, #8]
  001bc	e59530d8	 ldr         r3, [r5, #0xD8]
  001c0	e58230d8	 str         r3, [r2, #0xD8]
  001c4	e5942008	 ldr         r2, [r4, #8]
  001c8	e59530dc	 ldr         r3, [r5, #0xDC]
  001cc	e58230dc	 str         r3, [r2, #0xDC]
  001d0	e5942008	 ldr         r2, [r4, #8]
  001d4	e59530e0	 ldr         r3, [r5, #0xE0]
  001d8	e58230e0	 str         r3, [r2, #0xE0]
  001dc	e5942008	 ldr         r2, [r4, #8]
  001e0	e59530e4	 ldr         r3, [r5, #0xE4]
  001e4	e58230e4	 str         r3, [r2, #0xE4]
  001e8	e5942008	 ldr         r2, [r4, #8]
  001ec	e59530e8	 ldr         r3, [r5, #0xE8]
  001f0	e58230e8	 str         r3, [r2, #0xE8]
  001f4	e5942008	 ldr         r2, [r4, #8]
  001f8	e59530ec	 ldr         r3, [r5, #0xEC]
  001fc	e58230ec	 str         r3, [r2, #0xEC]
  00200		 |$LL10@RestoreReg|

; 3593 : 
; 3594 :             //  Scaling coefficients
; 3595 :             for( i = 0; i < NUM_SCALING_PHASES; i++ )
; 3596 :             {
; 3597 :                 OUTREG32( &m_pDispRegs->tDISPC_VID1.aFIR_COEF[i].ulH, pDisplaySaveRestore->tDISPC_VID1.aFIR_COEF[i].ulH );

  00200	e5942008	 ldr         r2, [r4, #8]
  00204	e5903000	 ldr         r3, [r0]

; 3598 :                 OUTREG32( &m_pDispRegs->tDISPC_VID1.aFIR_COEF[i].ulHV, pDisplaySaveRestore->tDISPC_VID1.aFIR_COEF[i].ulHV );

  00208	e08a1000	 add         r1, r10, r0

; 3599 :                 OUTREG32( &m_pDispRegs->DISPC_VID1_FIR_COEF_V[i], pDisplaySaveRestore->DISPC_VID1_FIR_COEF_V[i] );

  0020c	e2599001	 subs        r9, r9, #1
  00210	e7873002	 str         r3, [r7, +r2]
  00214	e5943008	 ldr         r3, [r4, #8]
  00218	e5902004	 ldr         r2, [r0, #4]
  0021c	e2877008	 add         r7, r7, #8
  00220	e0813003	 add         r3, r1, r3
  00224	e58320f4	 str         r2, [r3, #0xF4]
  00228	e5942008	 ldr         r2, [r4, #8]
  0022c	e79e3005	 ldr         r3, [lr, +r5]
  00230	e2800008	 add         r0, r0, #8
  00234	e78e3002	 str         r3, [lr, +r2]
  00238	e28ee004	 add         lr, lr, #4
  0023c	1affffef	 bne         |$LL10@RestoreReg|

; 3600 :             }
; 3601 : 
; 3602 :             //  Color conversion coefficients
; 3603 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF0, m_pColorSpaceCoeffs[0] );

  00240	e59434a0	 ldr         r3, [r4, #0x4A0]
  00244	e5942008	 ldr         r2, [r4, #8]
  00248	e5933000	 ldr         r3, [r3]
  0024c	e5823130	 str         r3, [r2, #0x130]

; 3604 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF1, m_pColorSpaceCoeffs[1] );

  00250	e59434a0	 ldr         r3, [r4, #0x4A0]
  00254	e5942008	 ldr         r2, [r4, #8]
  00258	e5933004	 ldr         r3, [r3, #4]
  0025c	e5823134	 str         r3, [r2, #0x134]

; 3605 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF2, m_pColorSpaceCoeffs[2] );

  00260	e59434a0	 ldr         r3, [r4, #0x4A0]
  00264	e5942008	 ldr         r2, [r4, #8]
  00268	e5933008	 ldr         r3, [r3, #8]
  0026c	e5823138	 str         r3, [r2, #0x138]

; 3606 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF3, m_pColorSpaceCoeffs[3] );

  00270	e59434a0	 ldr         r3, [r4, #0x4A0]
  00274	e5942008	 ldr         r2, [r4, #8]
  00278	e593300c	 ldr         r3, [r3, #0xC]
  0027c	e582313c	 str         r3, [r2, #0x13C]

; 3607 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.CONV_COEF4, m_pColorSpaceCoeffs[4] );

  00280	e59434a0	 ldr         r3, [r4, #0x4A0]
  00284	e5942008	 ldr         r2, [r4, #8]
  00288	e5933010	 ldr         r3, [r3, #0x10]
  0028c	e5823140	 str         r3, [r2, #0x140]
  00290		 |$LN11@RestoreReg|

; 3608 :         }
; 3609 : 
; 3610 :         //  Restore VID2 plane registers if enabled
; 3611 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled )

  00290	e5963040	 ldr         r3, [r6, #0x40]
  00294	e3530000	 cmp         r3, #0
  00298	0a0000e9	 beq         |$LN3@RestoreReg|

; 3612 :         {
; 3613 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.BA0, pDisplaySaveRestore->tDISPC_VID2.BA0 );

  0029c	e5942008	 ldr         r2, [r4, #8]
  002a0	e595314c	 ldr         r3, [r5, #0x14C]

; 3614 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.BA1, pDisplaySaveRestore->tDISPC_VID2.BA1 );
; 3615 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.POSITION, pDisplaySaveRestore->tDISPC_VID2.POSITION );
; 3616 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.SIZE, pDisplaySaveRestore->tDISPC_VID2.SIZE );
; 3617 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES, pDisplaySaveRestore->tDISPC_VID2.ATTRIBUTES );
; 3618 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD, pDisplaySaveRestore->tDISPC_VID2.FIFO_THRESHOLD );
; 3619 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.ROW_INC, pDisplaySaveRestore->tDISPC_VID2.ROW_INC );
; 3620 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.PIXEL_INC, pDisplaySaveRestore->tDISPC_VID2.PIXEL_INC );
; 3621 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.FIR, pDisplaySaveRestore->tDISPC_VID2.FIR );
; 3622 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.PICTURE_SIZE, pDisplaySaveRestore->tDISPC_VID2.PICTURE_SIZE );
; 3623 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.ACCU0, pDisplaySaveRestore->tDISPC_VID2.ACCU0 );
; 3624 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.ACCU1, pDisplaySaveRestore->tDISPC_VID2.ACCU1 );

  002a4	e3e010bf	 mvn         r1, #0xBF
  002a8	e3a0ec02	 mov         lr, #2, 24
  002ac	e582314c	 str         r3, [r2, #0x14C]
  002b0	e5942008	 ldr         r2, [r4, #8]
  002b4	e5953150	 ldr         r3, [r5, #0x150]
  002b8	e3a06d06	 mov         r6, #6, 26
  002bc	e2850d06	 add         r0, r5, #6, 26
  002c0	e5823150	 str         r3, [r2, #0x150]
  002c4	e5942008	 ldr         r2, [r4, #8]
  002c8	e5953154	 ldr         r3, [r5, #0x154]
  002cc	e0659081	 rsb         r9, r5, r1, lsl #1
  002d0	e3a07008	 mov         r7, #8
  002d4	e5823154	 str         r3, [r2, #0x154]
  002d8	e5942008	 ldr         r2, [r4, #8]
  002dc	e5953158	 ldr         r3, [r5, #0x158]
  002e0	e5823158	 str         r3, [r2, #0x158]
  002e4	e5942008	 ldr         r2, [r4, #8]
  002e8	e595315c	 ldr         r3, [r5, #0x15C]
  002ec	e582315c	 str         r3, [r2, #0x15C]
  002f0	e5942008	 ldr         r2, [r4, #8]
  002f4	e5953160	 ldr         r3, [r5, #0x160]
  002f8	e5823160	 str         r3, [r2, #0x160]
  002fc	e5942008	 ldr         r2, [r4, #8]
  00300	e5953168	 ldr         r3, [r5, #0x168]
  00304	e5823168	 str         r3, [r2, #0x168]
  00308	e5942008	 ldr         r2, [r4, #8]
  0030c	e595316c	 ldr         r3, [r5, #0x16C]
  00310	e582316c	 str         r3, [r2, #0x16C]
  00314	e5942008	 ldr         r2, [r4, #8]
  00318	e5953170	 ldr         r3, [r5, #0x170]
  0031c	e5823170	 str         r3, [r2, #0x170]
  00320	e5942008	 ldr         r2, [r4, #8]
  00324	e5953174	 ldr         r3, [r5, #0x174]
  00328	e5823174	 str         r3, [r2, #0x174]
  0032c	e5942008	 ldr         r2, [r4, #8]
  00330	e5953178	 ldr         r3, [r5, #0x178]
  00334	e5823178	 str         r3, [r2, #0x178]
  00338	e5942008	 ldr         r2, [r4, #8]
  0033c	e595317c	 ldr         r3, [r5, #0x17C]
  00340	e582317c	 str         r3, [r2, #0x17C]
  00344		 |$LL6@RestoreReg|

; 3625 : 
; 3626 :             //  Scaling coefficients
; 3627 :             for( i = 0; i < NUM_SCALING_PHASES; i++ )
; 3628 :             {
; 3629 :                 OUTREG32( &m_pDispRegs->tDISPC_VID2.aFIR_COEF[i].ulH, pDisplaySaveRestore->tDISPC_VID2.aFIR_COEF[i].ulH );

  00344	e5942008	 ldr         r2, [r4, #8]
  00348	e5903000	 ldr         r3, [r0]

; 3630 :                 OUTREG32( &m_pDispRegs->tDISPC_VID2.aFIR_COEF[i].ulHV, pDisplaySaveRestore->tDISPC_VID2.aFIR_COEF[i].ulHV );

  0034c	e0891000	 add         r1, r9, r0

; 3631 :                 OUTREG32( &m_pDispRegs->DISPC_VID2_FIR_COEF_V[i], pDisplaySaveRestore->DISPC_VID2_FIR_COEF_V[i] );

  00350	e2577001	 subs        r7, r7, #1
  00354	e7863002	 str         r3, [r6, +r2]
  00358	e5943008	 ldr         r3, [r4, #8]
  0035c	e5902004	 ldr         r2, [r0, #4]
  00360	e2866008	 add         r6, r6, #8
  00364	e0813003	 add         r3, r1, r3
  00368	e5832184	 str         r2, [r3, #0x184]
  0036c	e5942008	 ldr         r2, [r4, #8]
  00370	e79e3005	 ldr         r3, [lr, +r5]
  00374	e2800008	 add         r0, r0, #8
  00378	e78e3002	 str         r3, [lr, +r2]
  0037c	e28ee004	 add         lr, lr, #4
  00380	1affffef	 bne         |$LL6@RestoreReg|

; 3632 :             }
; 3633 : 
; 3634 :             //  Color conversion coefficients
; 3635 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF0, m_pColorSpaceCoeffs[0] );

  00384	e59434a0	 ldr         r3, [r4, #0x4A0]
  00388	e5942008	 ldr         r2, [r4, #8]
  0038c	e5933000	 ldr         r3, [r3]
  00390	e58231c0	 str         r3, [r2, #0x1C0]

; 3636 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF1, m_pColorSpaceCoeffs[1] );

  00394	e59434a0	 ldr         r3, [r4, #0x4A0]
  00398	e5942008	 ldr         r2, [r4, #8]
  0039c	e5933004	 ldr         r3, [r3, #4]
  003a0	e58231c4	 str         r3, [r2, #0x1C4]

; 3637 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF2, m_pColorSpaceCoeffs[2] );

  003a4	e59434a0	 ldr         r3, [r4, #0x4A0]
  003a8	e5942008	 ldr         r2, [r4, #8]
  003ac	e5933008	 ldr         r3, [r3, #8]
  003b0	e58231c8	 str         r3, [r2, #0x1C8]

; 3638 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF3, m_pColorSpaceCoeffs[3] );

  003b4	e59434a0	 ldr         r3, [r4, #0x4A0]
  003b8	e5942008	 ldr         r2, [r4, #8]
  003bc	e593300c	 ldr         r3, [r3, #0xC]
  003c0	e58231cc	 str         r3, [r2, #0x1CC]

; 3639 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.CONV_COEF4, m_pColorSpaceCoeffs[4] );

  003c4	e59434a0	 ldr         r3, [r4, #0x4A0]
  003c8	e5942008	 ldr         r2, [r4, #8]
  003cc	e5933010	 ldr         r3, [r3, #0x10]
  003d0	e58231d0	 str         r3, [r2, #0x1D0]
  003d4		 |$LN7@RestoreReg|

; 3640 :         }
; 3641 : 
; 3642 :     }
; 3643 : 
; 3644 :     //  Restore the TV out registers
; 3645 :     //  TV regs are not saved off b/c most are set to defaults
; 3646 :     if( eDestination == OMAP_DSS_DESTINATION_TVOUT )

  003d4	e3580001	 cmp         r8, #1
  003d8	1a000099	 bne         |$LN3@RestoreReg|

; 3647 :     {
; 3648 :         DWORD*  pVencPtr = NULL;
; 3649 : 
; 3650 :         //  Initialize the TV by calling PDD
; 3651 :         bResult = LcdPdd_TV_Initialize(
; 3652 :                         m_pDSSRegs,
; 3653 :                         m_pDispRegs,
; 3654 :                         NULL,
; 3655 :                         m_pVencRegs );

  003dc	e594300c	 ldr         r3, [r4, #0xC]
  003e0	e5941008	 ldr         r1, [r4, #8]
  003e4	e5940004	 ldr         r0, [r4, #4]
  003e8	e3a02000	 mov         r2, #0
  003ec	eb000000	 bl          LcdPdd_TV_Initialize

; 3656 : 
; 3657 :         //  Get TV parameters
; 3658 :         LcdPdd_TV_GetMode(
; 3659 :                         &m_dwTVWidth,
; 3660 :                         &m_dwTVHeight,
; 3661 :                         &m_dwTVMode );

  003f0	e2841b01	 add         r1, r4, #1, 22
  003f4	e2843b01	 add         r3, r4, #1, 22
  003f8	e28100bc	 add         r0, r1, #0xBC
  003fc	e2841d13	 add         r1, r4, #0x13, 26
  00400	e28320c4	 add         r2, r3, #0xC4
  00404	eb000000	 bl          LcdPdd_TV_GetMode

; 3662 : 
; 3663 : 
; 3664 :         //  Initialize Video Encoder registers for NTSC or PAL based on size of mode
; 3665 :         //  Default to NTSC
; 3666 :         if( m_dwTVWidth == PAL_WIDTH && m_dwTVHeight == PAL_HEIGHT )

  00408	e59434bc	 ldr         r3, [r4, #0x4BC]

; 3667 :         {
; 3668 :             //  Set for PAL
; 3669 :             pVencPtr = g_dwVencValues_PAL;
; 3670 :             m_dwTVMode = (m_dwTVMode == 0) ?  g_dwVencValues_PAL[VENC_OUTPUT_CONTROL] : m_dwTVMode;
; 3671 :         }
; 3672 :         else
; 3673 :         {
; 3674 :             //  Set for NTSC
; 3675 :             pVencPtr = g_dwVencValues_NTSC;
; 3676 :             m_dwTVMode = (m_dwTVMode == 0) ?  g_dwVencValues_NTSC[VENC_OUTPUT_CONTROL] : m_dwTVMode;
; 3677 :         }
; 3678 : 
; 3679 :         OUTREG32( &m_pVencRegs->VENC_F_CONTROL, pVencPtr[VENC_F_CONTROL] );

  0040c	e594200c	 ldr         r2, [r4, #0xC]
  00410	e3530e2d	 cmp         r3, #0x2D, 28
  00414	059434c0	 ldreq       r3, [r4, #0x4C0]
  00418	03530d09	 cmpeq       r3, #9, 26
  0041c	059fe240	 ldreq       lr, [pc, #0x240]
  00420	e59434c4	 ldr         r3, [r4, #0x4C4]
  00424	159fe234	 ldrne       lr, [pc, #0x234]
  00428	e3530000	 cmp         r3, #0
  0042c	059e309c	 ldreq       r3, [lr, #0x9C]
  00430	e58434c4	 str         r3, [r4, #0x4C4]
  00434	e59e3000	 ldr         r3, [lr]
  00438	e5823008	 str         r3, [r2, #8]

; 3680 :         OUTREG32( &m_pVencRegs->VENC_SYNC_CTRL, (pVencPtr[VENC_SYNC_CTRL] | 0x00000040) );     

  0043c	e59e3008	 ldr         r3, [lr, #8]
  00440	e594200c	 ldr         r2, [r4, #0xC]
  00444	e3833040	 orr         r3, r3, #0x40
  00448	e5823014	 str         r3, [r2, #0x14]

; 3681 :         //  Initialize encoder
; 3682 :         OUTREG32( &m_pVencRegs->VENC_VIDOUT_CTRL, pVencPtr[VENC_VIDOUT_CTRL] );

  0044c	e594200c	 ldr         r2, [r4, #0xC]
  00450	e59e3004	 ldr         r3, [lr, #4]
  00454	e5823010	 str         r3, [r2, #0x10]

; 3683 :         OUTREG32( &m_pVencRegs->VENC_LLEN, pVencPtr[VENC_LLEN] );

  00458	e594200c	 ldr         r2, [r4, #0xC]
  0045c	e59e300c	 ldr         r3, [lr, #0xC]
  00460	e582301c	 str         r3, [r2, #0x1C]

; 3684 :         OUTREG32( &m_pVencRegs->VENC_FLENS, pVencPtr[VENC_FLENS] );

  00464	e594200c	 ldr         r2, [r4, #0xC]
  00468	e59e3010	 ldr         r3, [lr, #0x10]
  0046c	e5823020	 str         r3, [r2, #0x20]

; 3685 :         OUTREG32( &m_pVencRegs->VENC_HFLTR_CTRL, pVencPtr[VENC_HFLTR_CTRL] );

  00470	e594200c	 ldr         r2, [r4, #0xC]
  00474	e59e3014	 ldr         r3, [lr, #0x14]
  00478	e5823024	 str         r3, [r2, #0x24]

; 3686 :         OUTREG32( &m_pVencRegs->VENC_CC_CARR_WSS_CARR, pVencPtr[VENC_CC_CARR_WSS_CARR] );

  0047c	e594200c	 ldr         r2, [r4, #0xC]
  00480	e59e3018	 ldr         r3, [lr, #0x18]
  00484	e5823028	 str         r3, [r2, #0x28]

; 3687 :         OUTREG32( &m_pVencRegs->VENC_C_PHASE, pVencPtr[VENC_C_PHASE] );

  00488	e594200c	 ldr         r2, [r4, #0xC]
  0048c	e59e301c	 ldr         r3, [lr, #0x1C]
  00490	e582302c	 str         r3, [r2, #0x2C]

; 3688 :         OUTREG32( &m_pVencRegs->VENC_GAIN_U, pVencPtr[VENC_GAIN_U] );

  00494	e594200c	 ldr         r2, [r4, #0xC]
  00498	e59e3020	 ldr         r3, [lr, #0x20]
  0049c	e5823030	 str         r3, [r2, #0x30]

; 3689 :         OUTREG32( &m_pVencRegs->VENC_GAIN_V, pVencPtr[VENC_GAIN_V] );

  004a0	e594200c	 ldr         r2, [r4, #0xC]
  004a4	e59e3024	 ldr         r3, [lr, #0x24]
  004a8	e5823034	 str         r3, [r2, #0x34]

; 3690 :         OUTREG32( &m_pVencRegs->VENC_GAIN_Y, pVencPtr[VENC_GAIN_Y] );

  004ac	e594200c	 ldr         r2, [r4, #0xC]
  004b0	e59e3028	 ldr         r3, [lr, #0x28]
  004b4	e5823038	 str         r3, [r2, #0x38]

; 3691 :         OUTREG32( &m_pVencRegs->VENC_BLACK_LEVEL, pVencPtr[VENC_BLACK_LEVEL] );

  004b8	e594200c	 ldr         r2, [r4, #0xC]
  004bc	e59e302c	 ldr         r3, [lr, #0x2C]
  004c0	e582303c	 str         r3, [r2, #0x3C]

; 3692 :         OUTREG32( &m_pVencRegs->VENC_BLANK_LEVEL, pVencPtr[VENC_BLANK_LEVEL] );

  004c4	e594200c	 ldr         r2, [r4, #0xC]
  004c8	e59e3030	 ldr         r3, [lr, #0x30]
  004cc	e5823040	 str         r3, [r2, #0x40]

; 3693 :         OUTREG32( &m_pVencRegs->VENC_X_COLOR, pVencPtr[VENC_X_COLOR] );

  004d0	e594200c	 ldr         r2, [r4, #0xC]
  004d4	e59e3034	 ldr         r3, [lr, #0x34]
  004d8	e5823044	 str         r3, [r2, #0x44]

; 3694 :         OUTREG32( &m_pVencRegs->VENC_M_CONTROL, pVencPtr[VENC_M_CONTROL] );

  004dc	e594200c	 ldr         r2, [r4, #0xC]
  004e0	e59e3038	 ldr         r3, [lr, #0x38]
  004e4	e5823048	 str         r3, [r2, #0x48]

; 3695 :         OUTREG32( &m_pVencRegs->VENC_BSTAMP_WSS_DATA, pVencPtr[VENC_BSTAMP_WSS_DATA] );

  004e8	e594200c	 ldr         r2, [r4, #0xC]
  004ec	e59e303c	 ldr         r3, [lr, #0x3C]
  004f0	e582304c	 str         r3, [r2, #0x4C]

; 3696 :         OUTREG32( &m_pVencRegs->VENC_S_CARR, pVencPtr[VENC_S_CARR] );

  004f4	e594200c	 ldr         r2, [r4, #0xC]
  004f8	e59e3040	 ldr         r3, [lr, #0x40]
  004fc	e5823050	 str         r3, [r2, #0x50]

; 3697 :         OUTREG32( &m_pVencRegs->VENC_LINE21, pVencPtr[VENC_LINE21] );

  00500	e594200c	 ldr         r2, [r4, #0xC]
  00504	e59e3044	 ldr         r3, [lr, #0x44]
  00508	e5823054	 str         r3, [r2, #0x54]

; 3698 :         OUTREG32( &m_pVencRegs->VENC_LN_SEL, pVencPtr[VENC_LN_SEL] );

  0050c	e594200c	 ldr         r2, [r4, #0xC]
  00510	e59e3048	 ldr         r3, [lr, #0x48]
  00514	e5823058	 str         r3, [r2, #0x58]

; 3699 :         OUTREG32( &m_pVencRegs->VENC_L21__WC_CTL, pVencPtr[VENC_L21__WC_CTL] );

  00518	e594200c	 ldr         r2, [r4, #0xC]
  0051c	e59e304c	 ldr         r3, [lr, #0x4C]
  00520	e582305c	 str         r3, [r2, #0x5C]

; 3700 :         OUTREG32( &m_pVencRegs->VENC_HTRIGGER_VTRIGGER, pVencPtr[VENC_HTRIGGER_VTRIGGER] );

  00524	e594200c	 ldr         r2, [r4, #0xC]
  00528	e59e3050	 ldr         r3, [lr, #0x50]

; 3701 :         OUTREG32( &m_pVencRegs->VENC_SAVID_EAVID, pVencPtr[VENC_SAVID_EAVID] );
; 3702 :         OUTREG32( &m_pVencRegs->VENC_FLEN_FAL, pVencPtr[VENC_FLEN_FAL] );
; 3703 :         OUTREG32( &m_pVencRegs->VENC_LAL_PHASE_RESET, pVencPtr[VENC_LAL_PHASE_RESET] );
; 3704 :         OUTREG32( &m_pVencRegs->VENC_HS_INT_START_STOP_X, pVencPtr[VENC_HS_INT_START_STOP_X] );
; 3705 :         OUTREG32( &m_pVencRegs->VENC_HS_EXT_START_STOP_X, pVencPtr[VENC_HS_EXT_START_STOP_X] );
; 3706 :         OUTREG32( &m_pVencRegs->VENC_VS_INT_START_X, pVencPtr[VENC_VS_INT_START_X] );
; 3707 :         OUTREG32( &m_pVencRegs->VENC_VS_INT_STOP_X__VS_INT_START_Y, pVencPtr[VENC_VS_INT_STOP_X__VS_INT_START_Y] );
; 3708 :         OUTREG32( &m_pVencRegs->VENC_VS_INT_STOP_Y__VS_EXT_START_X, pVencPtr[VENC_VS_INT_STOP_Y__VS_EXT_START_X] );
; 3709 :         OUTREG32( &m_pVencRegs->VENC_VS_EXT_STOP_X__VS_EXT_START_Y, pVencPtr[VENC_VS_EXT_STOP_X__VS_EXT_START_Y] );
; 3710 :         OUTREG32( &m_pVencRegs->VENC_VS_EXT_STOP_Y, pVencPtr[VENC_VS_EXT_STOP_Y] );
; 3711 :         OUTREG32( &m_pVencRegs->VENC_AVID_START_STOP_X, pVencPtr[VENC_AVID_START_STOP_X] );
; 3712 :         OUTREG32( &m_pVencRegs->VENC_AVID_START_STOP_Y, pVencPtr[VENC_AVID_START_STOP_Y] );
; 3713 :         OUTREG32( &m_pVencRegs->VENC_FID_INT_START_X__FID_INT_START_Y, pVencPtr[VENC_FID_INT_START_X__FID_INT_START_Y] );
; 3714 :         OUTREG32( &m_pVencRegs->VENC_FID_INT_OFFSET_Y__FID_EXT_START_X, pVencPtr[VENC_FID_INT_OFFSET_Y__FID_EXT_START_X] );
; 3715 :         OUTREG32( &m_pVencRegs->VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y, pVencPtr[VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y] );
; 3716 :         OUTREG32( &m_pVencRegs->VENC_TVDETGP_INT_START_STOP_X, pVencPtr[VENC_TVDETGP_INT_START_STOP_X] );
; 3717 :         OUTREG32( &m_pVencRegs->VENC_TVDETGP_INT_START_STOP_Y, pVencPtr[VENC_TVDETGP_INT_START_STOP_Y] );
; 3718 :         OUTREG32( &m_pVencRegs->VENC_GEN_CTRL, pVencPtr[VENC_GEN_CTRL] );
; 3719 :         OUTREG32( &m_pVencRegs->VENC_OUTPUT_CONTROL, m_dwTVMode );
; 3720 :         OUTREG32( &m_pVencRegs->VENC_OUTPUT_TEST, pVencPtr[VENC_OUTPUT_TEST] );
; 3721 : 
; 3722 :         OUTREG32( &m_pVencRegs->VENC_F_CONTROL, pVencPtr[VENC_F_CONTROL] );     // TRM mentions that these regs need to be
; 3723 :         OUTREG32( &m_pVencRegs->VENC_SYNC_CTRL, pVencPtr[VENC_SYNC_CTRL] );     // programmed last
; 3724 : 
; 3725 :         //  Flush shadow registers
; 3726 :         FlushRegs( DISPC_CONTROL_GODIGITAL );

  0052c	e3a01040	 mov         r1, #0x40
  00530	e1a00004	 mov         r0, r4
  00534	e5823060	 str         r3, [r2, #0x60]
  00538	e594200c	 ldr         r2, [r4, #0xC]
  0053c	e59e3054	 ldr         r3, [lr, #0x54]
  00540	e5823064	 str         r3, [r2, #0x64]
  00544	e594200c	 ldr         r2, [r4, #0xC]
  00548	e59e3058	 ldr         r3, [lr, #0x58]
  0054c	e5823068	 str         r3, [r2, #0x68]
  00550	e594200c	 ldr         r2, [r4, #0xC]
  00554	e59e305c	 ldr         r3, [lr, #0x5C]
  00558	e582306c	 str         r3, [r2, #0x6C]
  0055c	e594200c	 ldr         r2, [r4, #0xC]
  00560	e59e3060	 ldr         r3, [lr, #0x60]
  00564	e5823070	 str         r3, [r2, #0x70]
  00568	e594200c	 ldr         r2, [r4, #0xC]
  0056c	e59e3064	 ldr         r3, [lr, #0x64]
  00570	e5823074	 str         r3, [r2, #0x74]
  00574	e594200c	 ldr         r2, [r4, #0xC]
  00578	e59e3068	 ldr         r3, [lr, #0x68]
  0057c	e5823078	 str         r3, [r2, #0x78]
  00580	e594200c	 ldr         r2, [r4, #0xC]
  00584	e59e306c	 ldr         r3, [lr, #0x6C]
  00588	e582307c	 str         r3, [r2, #0x7C]
  0058c	e594200c	 ldr         r2, [r4, #0xC]
  00590	e59e3070	 ldr         r3, [lr, #0x70]
  00594	e5823080	 str         r3, [r2, #0x80]
  00598	e594200c	 ldr         r2, [r4, #0xC]
  0059c	e59e3074	 ldr         r3, [lr, #0x74]
  005a0	e5823084	 str         r3, [r2, #0x84]
  005a4	e594200c	 ldr         r2, [r4, #0xC]
  005a8	e59e3078	 ldr         r3, [lr, #0x78]
  005ac	e5823088	 str         r3, [r2, #0x88]
  005b0	e594200c	 ldr         r2, [r4, #0xC]
  005b4	e59e307c	 ldr         r3, [lr, #0x7C]
  005b8	e5823090	 str         r3, [r2, #0x90]
  005bc	e594200c	 ldr         r2, [r4, #0xC]
  005c0	e59e3080	 ldr         r3, [lr, #0x80]
  005c4	e5823094	 str         r3, [r2, #0x94]
  005c8	e594200c	 ldr         r2, [r4, #0xC]
  005cc	e59e3084	 ldr         r3, [lr, #0x84]
  005d0	e58230a0	 str         r3, [r2, #0xA0]
  005d4	e594200c	 ldr         r2, [r4, #0xC]
  005d8	e59e3088	 ldr         r3, [lr, #0x88]
  005dc	e58230a4	 str         r3, [r2, #0xA4]
  005e0	e594200c	 ldr         r2, [r4, #0xC]
  005e4	e59e308c	 ldr         r3, [lr, #0x8C]
  005e8	e58230a8	 str         r3, [r2, #0xA8]
  005ec	e594200c	 ldr         r2, [r4, #0xC]
  005f0	e59e3090	 ldr         r3, [lr, #0x90]
  005f4	e58230b0	 str         r3, [r2, #0xB0]
  005f8	e594200c	 ldr         r2, [r4, #0xC]
  005fc	e59e3094	 ldr         r3, [lr, #0x94]
  00600	e58230b4	 str         r3, [r2, #0xB4]
  00604	e594200c	 ldr         r2, [r4, #0xC]
  00608	e59e3098	 ldr         r3, [lr, #0x98]
  0060c	e58230b8	 str         r3, [r2, #0xB8]
  00610	e594200c	 ldr         r2, [r4, #0xC]
  00614	e59434c4	 ldr         r3, [r4, #0x4C4]
  00618	e58230c4	 str         r3, [r2, #0xC4]
  0061c	e59e20a0	 ldr         r2, [lr, #0xA0]
  00620	e594300c	 ldr         r3, [r4, #0xC]
  00624	e58320c8	 str         r2, [r3, #0xC8]
  00628	e594200c	 ldr         r2, [r4, #0xC]
  0062c	e59e3000	 ldr         r3, [lr]
  00630	e5823008	 str         r3, [r2, #8]
  00634	e594200c	 ldr         r2, [r4, #0xC]
  00638	e59e3008	 ldr         r3, [lr, #8]
  0063c	e5823014	 str         r3, [r2, #0x14]
  00640	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|
  00644		 |$LN3@RestoreReg|

; 3727 :     }
; 3728 : 
; 3729 :     //  Success
; 3730 :     bResult = TRUE;

  00644	e3a06001	 mov         r6, #1
  00648		 |$cleanUp$39075|

; 3731 : 
; 3732 : cleanUp:
; 3733 :     //  Release regs
; 3734 :     ReleaseRegs();

  00648	e2843b01	 add         r3, r4, #1, 22
  0064c	e283008c	 add         r0, r3, #0x8C
  00650	eb000000	 bl          LeaveCriticalSection

; 3735 : 
; 3736 :     //  Return result
; 3737 :     return bResult;
; 3738 : }

  00654	e1a00006	 mov         r0, r6
  00658	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  0065c	e12fff1e	 bx          lr
  00660		 |$LN40@RestoreReg|
  00660		 |$LN41@RestoreReg|
  00660	00000000	 DCD         |?g_dwVencValues_NTSC@@3PAKA|
  00664		 |$LN42@RestoreReg|
  00664	00000000	 DCD         |?g_dwVencValues_PAL@@3PAKA|
  00668		 |$LN43@RestoreReg|
  00668	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  0066c		 |$M41763|

			 ENDP  ; |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|, OMAPDisplayController::RestoreRegisters

	EXPORT	|?ResetDSS@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::ResetDSS

  00000			 AREA	 |.pdata|, PDATA
|$T41804| DCD	|$LN24@ResetDSS|
	DCD	0x40002b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetDSS@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::ResetDSS

; 4204 : {

  00000		 |$LN24@ResetDSS|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41801|
  00004	e1a05000	 mov         r5, r0

; 4205 :     DWORD   dwTimeout;
; 4206 :     DWORD   dwVal;
; 4207 : 
; 4208 :     //  Need to enable DSS1, DSS2 and TVOUT to reset controller
; 4209 :     RequestClock( m_dssinfo.DSSDevice );         

  00008	e595051c	 ldr         r0, [r5, #0x51C]
  0000c	e3a01001	 mov         r1, #1
  00010	eb000000	 bl          EnableDeviceClocks

; 4210 :     RequestClock( m_dssinfo.TVEncoderDevice );

  00014	e5950520	 ldr         r0, [r5, #0x520]
  00018	e3a01001	 mov         r1, #1
  0001c	eb000000	 bl          EnableDeviceClocks

; 4211 : 
; 4212 :     // check if digital output or the lcd output are enabled
; 4213 :     dwVal = INREG32(&m_pDispRegs->DISPC_CONTROL);

  00020	e5952008	 ldr         r2, [r5, #8]
  00024	e5923040	 ldr         r3, [r2, #0x40]

; 4214 : 
; 4215 :     if(dwVal & (DISPC_CONTROL_DIGITALENABLE | DISPC_CONTROL_LCDENABLE))

  00028	e3130003	 tst         r3, #3

; 4216 :     {
; 4217 :         // disable the lcd output and digital output
; 4218 :         dwVal &= ~(DISPC_CONTROL_DIGITALENABLE | DISPC_CONTROL_LCDENABLE);

  0002c	13c33003	 bicne       r3, r3, #3

; 4219 :         OUTREG32(&m_pDispRegs->DISPC_CONTROL, dwVal);
; 4220 : 
; 4221 :         // wait until frame is done
; 4222 :         WaitForFrameDone(DISPLAY_TIMEOUT);

  00030	13a0101e	 movne       r1, #0x1E
  00034	11a00005	 movne       r0, r5
  00038	15823040	 strne       r3, [r2, #0x40]
  0003c	1b000000	 blne        |?WaitForFrameDone@OMAPDisplayController@@IAAHK@Z|

; 4223 :     }
; 4224 : 
; 4225 : 
; 4226 :     //  Reset the whole display subsystem    
; 4227 :     SETREG32( &m_pDSSRegs->DSS_SYSCONFIG, DSS_SYSCONFIG_SOFTRESET );

  00040	e5952004	 ldr         r2, [r5, #4]

; 4228 :     
; 4229 :     //  Wait until reset completes OR timeout occurs
; 4230 :     dwTimeout=DISPLAY_TIMEOUT;

  00044	e3a0401e	 mov         r4, #0x1E
  00048	e5923010	 ldr         r3, [r2, #0x10]
  0004c	e3833002	 orr         r3, r3, #2
  00050	e5823010	 str         r3, [r2, #0x10]

; 4231 :     while(((INREG32(&m_pDSSRegs->DSS_SYSSTATUS) & DSS_SYSSTATUS_RESETDONE) == 0) && (dwTimeout-- > 0))

  00054	ea000004	 b           |$LN21@ResetDSS|
  00058		 |$LL3@ResetDSS|
  00058	e3540000	 cmp         r4, #0
  0005c	e2444001	 sub         r4, r4, #1
  00060	0a000005	 beq         |$LN19@ResetDSS|

; 4232 :     {
; 4233 :         // delay
; 4234 :         Sleep(1);

  00064	e3a00001	 mov         r0, #1
  00068	eb000000	 bl          Sleep
  0006c		 |$LN21@ResetDSS|
  0006c	e5953004	 ldr         r3, [r5, #4]
  00070	e5933014	 ldr         r3, [r3, #0x14]
  00074	e3130001	 tst         r3, #1
  00078	0afffff6	 beq         |$LL3@ResetDSS|
  0007c		 |$LN19@ResetDSS|

; 4235 :     }
; 4236 : 
; 4237 :     if( dwTimeout == 0 )
; 4238 :     {
; 4239 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::ResetDSS: "
; 4240 :              L"Failed reset DSS\r\n"
; 4241 :             ));
; 4242 :     }
; 4243 : 
; 4244 :     //  Release clocks
; 4245 :     ReleaseClock( m_dssinfo.TVEncoderDevice );

  0007c	e5950520	 ldr         r0, [r5, #0x520]
  00080	e3a01000	 mov         r1, #0
  00084	eb000000	 bl          EnableDeviceClocks

; 4246 :     ReleaseClock( m_dssinfo.DSSDevice );         

  00088	e595051c	 ldr         r0, [r5, #0x51C]
  0008c	e3a01000	 mov         r1, #0
  00090	eb000000	 bl          EnableDeviceClocks

; 4247 :         
; 4248 :     //  Return result
; 4249 :     return (dwTimeout > 0);

  00094	e3540000	 cmp         r4, #0
  00098	13a00001	 movne       r0, #1

; 4250 : }

  0009c	18bd4030	 ldmneia     sp!, {r4, r5, lr}

; 4247 :         
; 4248 :     //  Return result
; 4249 :     return (dwTimeout > 0);

  000a0	03a00000	 moveq       r0, #0

; 4250 : }

  000a4	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$M41802|

			 ENDP  ; |?ResetDSS@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::ResetDSS

	EXPORT	|?ResetDISPC@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::ResetDISPC

  00000			 AREA	 |.pdata|, PDATA
|$T41831| DCD	|$LN20@ResetDISPC|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetDISPC@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::ResetDISPC

; 4255 : {

  00000		 |$LN20@ResetDISPC|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41828|
  00004	e1a05000	 mov         r5, r0

; 4256 :     DWORD   dwVal;
; 4257 :     DWORD   dwTimeout;
; 4258 : 
; 4259 : 
; 4260 :     //  Need to enable DSS1, DSS2 and TVOUT to reset controller
; 4261 :     RequestClock( m_dssinfo.DSSDevice );         

  00008	e595051c	 ldr         r0, [r5, #0x51C]
  0000c	e3a01001	 mov         r1, #1
  00010	eb000000	 bl          EnableDeviceClocks

; 4262 : 
; 4263 :     // check if digital output or the lcd output are enabled
; 4264 :     dwVal = INREG32(&m_pDispRegs->DISPC_CONTROL);

  00014	e5952008	 ldr         r2, [r5, #8]
  00018	e5923040	 ldr         r3, [r2, #0x40]

; 4265 : 
; 4266 :     if(dwVal & (DISPC_CONTROL_DIGITALENABLE | DISPC_CONTROL_LCDENABLE))

  0001c	e3130003	 tst         r3, #3

; 4267 :     {
; 4268 :         // disable the lcd output and digital output
; 4269 :         dwVal &= ~(DISPC_CONTROL_DIGITALENABLE | DISPC_CONTROL_LCDENABLE);

  00020	13c33003	 bicne       r3, r3, #3

; 4270 :         OUTREG32(&m_pDispRegs->DISPC_CONTROL, dwVal);
; 4271 : 
; 4272 :         // wait until frame is done
; 4273 :         WaitForFrameDone(DISPLAY_TIMEOUT);

  00024	13a0101e	 movne       r1, #0x1E
  00028	11a00005	 movne       r0, r5
  0002c	15823040	 strne       r3, [r2, #0x40]
  00030	1b000000	 blne        |?WaitForFrameDone@OMAPDisplayController@@IAAHK@Z|

; 4274 :     }
; 4275 : 
; 4276 : 
; 4277 :     //  Reset the controller    
; 4278 :     SETREG32( &m_pDispRegs->DISPC_SYSCONFIG, DISPC_SYSCONFIG_SOFTRESET );

  00034	e5952008	 ldr         r2, [r5, #8]

; 4279 :     
; 4280 :     //  Wait until reset completes OR timeout occurs
; 4281 :     dwTimeout=DISPLAY_TIMEOUT;

  00038	e3a0401e	 mov         r4, #0x1E
  0003c	e5923010	 ldr         r3, [r2, #0x10]
  00040	e3833002	 orr         r3, r3, #2
  00044	e5823010	 str         r3, [r2, #0x10]

; 4282 :     while(((INREG32(&m_pDispRegs->DISPC_SYSSTATUS) & DISPC_SYSSTATUS_RESETDONE) == 0) && (dwTimeout-- > 0))

  00048	ea000004	 b           |$LN17@ResetDISPC|
  0004c		 |$LL3@ResetDISPC|
  0004c	e3540000	 cmp         r4, #0
  00050	e2444001	 sub         r4, r4, #1
  00054	0a000005	 beq         |$LN15@ResetDISPC|

; 4283 :     {
; 4284 :         // delay
; 4285 :         Sleep(1);

  00058	e3a00001	 mov         r0, #1
  0005c	eb000000	 bl          Sleep
  00060		 |$LN17@ResetDISPC|
  00060	e5953008	 ldr         r3, [r5, #8]
  00064	e5933014	 ldr         r3, [r3, #0x14]
  00068	e3130001	 tst         r3, #1
  0006c	0afffff6	 beq         |$LL3@ResetDISPC|
  00070		 |$LN15@ResetDISPC|

; 4286 :     }
; 4287 : 
; 4288 :     if( dwTimeout == 0 )
; 4289 :     {
; 4290 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::ResetDISPC: "
; 4291 :              L"Failed reset DISPC\r\n"
; 4292 :             ));
; 4293 :     }
; 4294 : 
; 4295 :     //  Release clocks
; 4296 :     ReleaseClock( m_dssinfo.DSSDevice );         

  00070	e595051c	 ldr         r0, [r5, #0x51C]
  00074	e3a01000	 mov         r1, #0
  00078	eb000000	 bl          EnableDeviceClocks

; 4297 :         
; 4298 :     //  Return result
; 4299 :     return (dwTimeout > 0);

  0007c	e3540000	 cmp         r4, #0
  00080	13a00001	 movne       r0, #1

; 4300 : }

  00084	18bd4030	 ldmneia     sp!, {r4, r5, lr}

; 4297 :         
; 4298 :     //  Return result
; 4299 :     return (dwTimeout > 0);

  00088	03a00000	 moveq       r0, #0

; 4300 : }

  0008c	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M41829|

			 ENDP  ; |?ResetDISPC@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::ResetDISPC

	EXPORT	|?ResetVENC@OMAPDisplayController@@IAAHXZ| ; OMAPDisplayController::ResetVENC

  00000			 AREA	 |.pdata|, PDATA
|$T41857| DCD	|$LN19@ResetVENC|
	DCD	0x40002201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?ResetVENC@OMAPDisplayController@@IAAHXZ| PROC ; OMAPDisplayController::ResetVENC

; 4305 : {

  00000		 |$LN19@ResetVENC|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41854|
  00004	e1a05000	 mov         r5, r0

; 4306 :     DWORD   dwTimeout;
; 4307 : 
; 4308 : 
; 4309 :     //  Need to enable DSS1, DSS2 and TVOUT to reset video encoder
; 4310 :     RequestClock( m_dssinfo.TVEncoderDevice );         

  00008	e5950520	 ldr         r0, [r5, #0x520]
  0000c	e3a01001	 mov         r1, #1
  00010	eb000000	 bl          EnableDeviceClocks

; 4311 : 
; 4312 :     
; 4313 :     //  Reset the video encoder   
; 4314 :     SETREG32( &m_pVencRegs->VENC_F_CONTROL, VENC_F_CONTROL_RESET );

  00014	e595200c	 ldr         r2, [r5, #0xC]

; 4315 :     
; 4316 :     //  Wait until reset completes OR timeout occurs
; 4317 :     dwTimeout=DISPLAY_TIMEOUT;

  00018	e3a0401e	 mov         r4, #0x1E
  0001c	e5923008	 ldr         r3, [r2, #8]
  00020	e3833c01	 orr         r3, r3, #1, 24
  00024	e5823008	 str         r3, [r2, #8]

; 4318 :     while(((INREG32(&m_pVencRegs->VENC_F_CONTROL) & VENC_F_CONTROL_RESET) == 0) && (dwTimeout-- > 0))

  00028	ea000004	 b           |$LN16@ResetVENC|
  0002c		 |$LL3@ResetVENC|
  0002c	e3540000	 cmp         r4, #0
  00030	e2444001	 sub         r4, r4, #1
  00034	0a000005	 beq         |$LN14@ResetVENC|

; 4319 :     {
; 4320 :         // delay
; 4321 :         Sleep(1);

  00038	e3a00001	 mov         r0, #1
  0003c	eb000000	 bl          Sleep
  00040		 |$LN16@ResetVENC|
  00040	e595300c	 ldr         r3, [r5, #0xC]
  00044	e5933008	 ldr         r3, [r3, #8]
  00048	e3130c01	 tst         r3, #1, 24
  0004c	0afffff6	 beq         |$LL3@ResetVENC|
  00050		 |$LN14@ResetVENC|

; 4322 :     }
; 4323 : 
; 4324 :     if( dwTimeout == 0 )
; 4325 :     {
; 4326 :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::ResetVENC: "
; 4327 :              L"Failed reset DSS\r\n"
; 4328 :             ));
; 4329 :     }
; 4330 : 
; 4331 : 
; 4332 :     //  Clear video encoder F-control and SYNC Control regsiters
; 4333 :     OUTREG32( &m_pVencRegs->VENC_F_CONTROL, 0 );

  00050	e595300c	 ldr         r3, [r5, #0xC]
  00054	e3a02000	 mov         r2, #0

; 4334 :     OUTREG32( &m_pVencRegs->VENC_SYNC_CTRL, 0 );
; 4335 : 
; 4336 : 
; 4337 :     //  Release clocks
; 4338 :     ReleaseClock( m_dssinfo.TVEncoderDevice );         

  00058	e3a01000	 mov         r1, #0
  0005c	e5832008	 str         r2, [r3, #8]
  00060	e595300c	 ldr         r3, [r5, #0xC]
  00064	e5832014	 str         r2, [r3, #0x14]
  00068	e5950520	 ldr         r0, [r5, #0x520]
  0006c	eb000000	 bl          EnableDeviceClocks

; 4339 :         
; 4340 :     //  Return result
; 4341 :     return (dwTimeout > 0);

  00070	e3540000	 cmp         r4, #0
  00074	13a00001	 movne       r0, #1

; 4342 : }

  00078	18bd4030	 ldmneia     sp!, {r4, r5, lr}

; 4339 :         
; 4340 :     //  Return result
; 4341 :     return (dwTimeout > 0);

  0007c	03a00000	 moveq       r0, #0

; 4342 : }

  00080	08bd4030	 ldmeqia     sp!, {r4, r5, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$M41855|

			 ENDP  ; |?ResetVENC@OMAPDisplayController@@IAAHXZ|, OMAPDisplayController::ResetVENC

	EXPORT	|?EnableLPR@OMAPDisplayController@@QAAXHH@Z| ; OMAPDisplayController::EnableLPR
	IMPORT	|PmxNotifyPolicy|

  00000			 AREA	 |.pdata|, PDATA
|$T41879| DCD	|$LN18@EnableLPR|
	DCD	0x40002d03
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableLPR@OMAPDisplayController@@QAAXHH@Z| PROC ; OMAPDisplayController::EnableLPR

; 5085 : {

  00000		 |$LN18@EnableLPR|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5010	 stmdb       sp!, {r4, r12, lr}
  0000c		 |$M41876|
  0000c	e58d1010	 str         r1, [sp, #0x10]
  00010	e1a04000	 mov         r4, r0

; 5086 :     OMAP_DSS_FCLKVALUE eFclkValue = m_eDssFclkValue;
; 5087 : 
; 5088 :     if (m_hSmartReflexPolicyAdapter == NULL)

  00014	e5943518	 ldr         r3, [r4, #0x518]
  00018	e1b00003	 movs        r0, r3
  0001c	0a000022	 beq         |$LN6@EnableLPR|

; 5089 : 	    return;
; 5090 : 
; 5091 :     if (m_bDVIEnable)

  00020	e59434cc	 ldr         r3, [r4, #0x4CC]
  00024	e3530000	 cmp         r3, #0
  00028	1a00001f	 bne         |$LN6@EnableLPR|

; 5092 :         return;
; 5093 : 
; 5094 :     if ((bEnable == m_bLPREnable) && (bHdmiEnable == FALSE))

  0002c	e5943510	 ldr         r3, [r4, #0x510]
  00030	e1510003	 cmp         r1, r3
  00034	1a000001	 bne         |$LN3@EnableLPR|
  00038	e3520000	 cmp         r2, #0
  0003c	0a00001a	 beq         |$LN6@EnableLPR|
  00040		 |$LN3@EnableLPR|

; 5095 :     {
; 5096 :         return;
; 5097 :     }
; 5098 :     
; 5099 :     // For HDMI Panel, the FCLK specific to HDMI panel should be used
; 5100 :     eFclkValue = ( bHdmiEnable ) ? OMAP_DSS_FCLKVALUE_HDMI : eFclkValue ;

  00040	e3520000	 cmp         r2, #0

; 5101 :     // LPR is disabled when HDMI panel is active
; 5102 :     bEnable    = ( bHdmiEnable ) ? FALSE : bEnable;

  00044	13a01000	 movne       r1, #0
  00048	158d1010	 strne       r1, [sp, #0x10]

; 5103 :  
; 5104 :     if (bEnable)

  0004c	e3510000	 cmp         r1, #0
  00050	0a000009	 beq         |$LN2@EnableLPR|
  00054	e3a03106	 mov         r3, #6, 2

; 5105 :         {
; 5106 : 
; 5107 :         //Send LPR status to SmartReflex policy adapter
; 5108 :         PmxNotifyPolicy(m_hSmartReflexPolicyAdapter,SMARTREFLEX_LPR_MODE,&bEnable,sizeof(BOOL));

  00058	e3831801	 orr         r1, r3, #1, 16
  0005c	e3a03004	 mov         r3, #4
  00060	e28d2010	 add         r2, sp, #0x10
  00064	eb000000	 bl          PmxNotifyPolicy

; 5109 :         
; 5110 :         // Set the FCLK corresponding to LPR mode
; 5111 :         SetDssFclk ( m_eDssFclkSource, OMAP_DSS_FCLKVALUE_LPR );
; 5112 :      
; 5113 :         // Enable LPR
; 5114 :         OUTREG32( &m_pDispRegs->DISPC_SYSCONFIG,
; 5115 :                     DISPC_SYSCONFIG_AUTOIDLE|
; 5116 :                     SYSCONFIG_SMARTIDLE|
; 5117 :                     SYSCONFIG_ENAWAKEUP|
; 5118 :                     SYSCONFIG_CLOCKACTIVITY_I_ON|
; 5119 :                     SYSCONFIG_SMARTSTANDBY
; 5120 :                     );

  00068	e5942008	 ldr         r2, [r4, #8]
  0006c	e3a03c22	 mov         r3, #0x22, 24
  00070	e3833015	 orr         r3, r3, #0x15
  00074	e5823010	 str         r3, [r2, #0x10]

; 5121 :                   
; 5122 :         }
; 5123 :     else

  00078	ea000009	 b           |$LN1@EnableLPR|
  0007c		 |$LN2@EnableLPR|

; 5124 :         {
; 5125 :         // Disable LPR
; 5126 :         OUTREG32( &m_pDispRegs->DISPC_SYSCONFIG,
; 5127 :                     DISPC_SYSCONFIG_AUTOIDLE|
; 5128 :                     SYSCONFIG_NOIDLE|
; 5129 :                     SYSCONFIG_NOSTANDBY
; 5130 :                     );

  0007c	e5942008	 ldr         r2, [r4, #8]
  00080	e3a03a01	 mov         r3, #1, 20
  00084	e3833009	 orr         r3, r3, #9
  00088	e5823010	 str         r3, [r2, #0x10]

; 5131 :                   
; 5132 :         // Set the FCLK corresponding to LPR mode
; 5133 :         SetDssFclk ( m_eDssFclkSource, eFclkValue );  
; 5134 : 
; 5135 :         //Send LPR status to SmartReflex policy adapter
; 5136 :         PmxNotifyPolicy(m_hSmartReflexPolicyAdapter,SMARTREFLEX_LPR_MODE,&bEnable,sizeof(BOOL));

  0008c	e5940518	 ldr         r0, [r4, #0x518]
  00090	e3a01106	 mov         r1, #6, 2
  00094	e3a03004	 mov         r3, #4
  00098	e28d2010	 add         r2, sp, #0x10
  0009c	e3811801	 orr         r1, r1, #1, 16
  000a0	eb000000	 bl          PmxNotifyPolicy
  000a4		 |$LN1@EnableLPR|

; 5137 :         }
; 5138 :     m_bLPREnable = bEnable; 

  000a4	e59d3010	 ldr         r3, [sp, #0x10]
  000a8	e5843510	 str         r3, [r4, #0x510]
  000ac		 |$LN6@EnableLPR|

; 5139 : }

  000ac	e89d6010	 ldmia       sp, {r4, sp, lr}
  000b0	e12fff1e	 bx          lr
  000b4		 |$M41877|

			 ENDP  ; |?EnableLPR@OMAPDisplayController@@QAAXHH@Z|, OMAPDisplayController::EnableLPR

	IMPORT	|??3@YAXPAX@Z|				; operator delete

  00000			 AREA	 |.pdata|, PDATA
|$T41890| DCD	|$LN6@scalar|
	DCD	0x40000a01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |??_GOMAPDisplayController@@UAAPAXI@Z| PROC ; OMAPDisplayController::`scalar deleting destructor'
  00000		 |$LN6@scalar|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M41887|
  00004	e1a04001	 mov         r4, r1
  00008	e1a05000	 mov         r5, r0
  0000c	eb000000	 bl          |??1OMAPDisplayController@@UAA@XZ|
  00010	e3140001	 tst         r4, #1
  00014	11a00005	 movne       r0, r5
  00018	1b000000	 blne        |??3@YAXPAX@Z|
  0001c	e1a00005	 mov         r0, r5
  00020	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M41888|

			 ENDP  ; |??_GOMAPDisplayController@@UAAPAXI@Z|, OMAPDisplayController::`scalar deleting destructor'

	EXPORT	|?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@KKKK@Z| ; OMAPDisplayController::SetScalingAttribs

  00000			 AREA	 |.pdata|, PDATA
|$T41905| DCD	|$LN6@SetScaling@2|
	DCD	0x40003102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@KKKK@Z| PROC ; OMAPDisplayController::SetScalingAttribs

; 1098 : {

  00000		 |$LN6@SetScaling@2|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd020	 sub         sp, sp, #0x20
  00008		 |$M41902|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a08002	 mov         r8, r2
  00010	e1a06001	 mov         r6, r1
  00014	e1a09000	 mov         r9, r0

; 1099 :     RECT    srcRect,
; 1100 :             destRect;
; 1101 : 
; 1102 :     //  Check for surface
; 1103 :     if( g_rgPipelineMapping[ePipeline].pSurface == NULL )

  00018	e59fe0a0	 ldr         lr, [pc, #0xA0]
  0001c	e08e4286	 add         r4, lr, r6, lsl #5
  00020	e594e008	 ldr         lr, [r4, #8]
  00024	e35e0000	 cmp         lr, #0

; 1104 :         return FALSE;

  00028	03a00000	 moveq       r0, #0
  0002c	0a000020	 beq         |$LN2@SetScaling@2|

; 1105 :         
; 1106 :     //  Create src and dest RECTs for this scaling setup
; 1107 :     srcRect.left = 0;

  00030	e3a03000	 mov         r3, #0

; 1108 :     srcRect.top = 0;

  00034	e3a02000	 mov         r2, #0
  00038	e58d3000	 str         r3, [sp]
  0003c	e58d2004	 str         r2, [sp, #4]

; 1109 :     srcRect.right = g_rgPipelineMapping[ePipeline].pSurface->Width();

  00040	e59e3000	 ldr         r3, [lr]
  00044	e3a01000	 mov         r1, #0
  00048	e1a0000e	 mov         r0, lr
  0004c	e5933008	 ldr         r3, [r3, #8]
  00050	e1a0e00f	 mov         lr, pc
  00054	e12fff13	 bx          r3

; 1110 :     srcRect.bottom = g_rgPipelineMapping[ePipeline].pSurface->Height();

  00058	e5942008	 ldr         r2, [r4, #8]
  0005c	e58d0008	 str         r0, [sp, #8]
  00060	e3a01000	 mov         r1, #0
  00064	e5923000	 ldr         r3, [r2]
  00068	e1a00002	 mov         r0, r2
  0006c	e593300c	 ldr         r3, [r3, #0xC]
  00070	e1a0e00f	 mov         lr, pc
  00074	e12fff13	 bx          r3

; 1111 : 
; 1112 :     destRect.left = dwPosX;

  00078	e59d503c	 ldr         r5, [sp, #0x3C]

; 1113 :     destRect.top = dwPosY;

  0007c	e59d4040	 ldr         r4, [sp, #0x40]
  00080	e1a0e000	 mov         lr, r0

; 1114 :     destRect.right = dwPosX + dwWidth;

  00084	e0883005	 add         r3, r8, r5

; 1115 :     destRect.bottom = dwPosY + dwHeight;

  00088	e0872004	 add         r2, r7, r4
  0008c	e58d3018	 str         r3, [sp, #0x18]
  00090	e58d201c	 str         r2, [sp, #0x1C]

; 1116 : 
; 1117 :     //  Call the RECT based scaling method
; 1118 :     return SetScalingAttribs( ePipeline, &srcRect, &destRect );

  00094	e28d3010	 add         r3, sp, #0x10
  00098	e28d2000	 add         r2, sp, #0
  0009c	e1a01006	 mov         r1, r6
  000a0	e1a00009	 mov         r0, r9
  000a4	e58de00c	 str         lr, [sp, #0xC]
  000a8	e58d5010	 str         r5, [sp, #0x10]
  000ac	e58d4014	 str         r4, [sp, #0x14]
  000b0	eb000000	 bl          |?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@PAUtagRECT@@1@Z|
  000b4		 |$LN2@SetScaling@2|

; 1119 : }

  000b4	e28dd020	 add         sp, sp, #0x20
  000b8	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000bc	e12fff1e	 bx          lr
  000c0		 |$LN7@SetScaling@2|
  000c0		 |$LN8@SetScaling@2|
  000c0	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  000c4		 |$M41903|

			 ENDP  ; |?SetScalingAttribs@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@KKKK@Z|, OMAPDisplayController::SetScalingAttribs

	EXPORT	|?EnablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z| ; OMAPDisplayController::EnablePipeline

  00000			 AREA	 |.pdata|, PDATA
|$T41979| DCD	|$LN61@EnablePipe|
	DCD	0x4000c002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z| PROC ; OMAPDisplayController::EnablePipeline

; 2121 : {

  00000		 |$LN61@EnablePipe|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M41976|
  00008	e1a04001	 mov         r4, r1
  0000c	e1a05000	 mov         r5, r0

; 2122 :     BOOL                    bResult = FALSE;
; 2123 :     OMAP_DSS_DESTINATION    eDest;
; 2124 :     DWORD                   dwNumPipelinesOn = 0;
; 2125 :     DWORD                   dwDestEnable,
; 2126 :                             dwDestGo;
; 2127 : 
; 2128 :     //  Check if pipeline is already enabled
; 2129 :     if( g_rgPipelineMapping[ePipeline].bEnabled == TRUE )

  00010	e59f62e4	 ldr         r6, [pc, #0x2E4]
  00014	e3a08000	 mov         r8, #0
  00018	e7963284	 ldr         r3, [r6, +r4, lsl #5]
  0001c	e3530001	 cmp         r3, #1

; 2130 :         return TRUE;

  00020	03a08001	 moveq       r8, #1
  00024	0a0000b0	 beq         |$LN24@EnablePipe|

; 2131 :         
; 2132 :     //  Access the regs
; 2133 :     if( AccessRegs() == FALSE )

  00028	e1a00005	 mov         r0, r5
  0002c	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00030	e3500000	 cmp         r0, #0
  00034	0a0000a9	 beq         |$cleanUp$38445|

; 2134 :         goto cleanUp;
; 2135 : 
; 2136 : 
; 2137 :     //  Enable GFX pipeline
; 2138 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  00038	e3540000	 cmp         r4, #0
  0003c	1a000009	 bne         |$LN53@EnablePipe|

; 2139 :     {
; 2140 :         //  Enable the interrupt for reporting the GFX under flow error
; 2141 :         SETREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_GFXFIFOUNDERFLOW);

  00040	e5952008	 ldr         r2, [r5, #8]

; 2142 : 
; 2143 :         //  Enable the pipeline
; 2144 :         SETREG32( &m_pDispRegs->DISPC_GFX_ATTRIBUTES, DISPC_GFX_ATTR_GFXENABLE );        
; 2145 :         g_rgPipelineMapping[ePipeline].bEnabled = TRUE;

  00044	e3a01001	 mov         r1, #1
  00048	e592301c	 ldr         r3, [r2, #0x1C]
  0004c	e3833040	 orr         r3, r3, #0x40
  00050	e582301c	 str         r3, [r2, #0x1C]
  00054	e5952008	 ldr         r2, [r5, #8]
  00058	e59230a0	 ldr         r3, [r2, #0xA0]
  0005c	e3833001	 orr         r3, r3, #1
  00060	e58230a0	 str         r3, [r2, #0xA0]
  00064	e5861000	 str         r1, [r6]
  00068		 |$LN53@EnablePipe|

; 2146 :     }    
; 2147 : 
; 2148 :     //  Enable VID1 pipeline
; 2149 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  00068	e3540001	 cmp         r4, #1
  0006c	1a000009	 bne         |$LN54@EnablePipe|

; 2150 :     {
; 2151 :         // Enable the interrupt for reporting the VID1 under flow error
; 2152 :         SETREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VID1FIFOUNDERFLOW);

  00070	e5952008	 ldr         r2, [r5, #8]

; 2153 : 
; 2154 :         //  Enable the pipeline
; 2155 :         SETREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES, DISPC_VID_ATTR_VIDENABLE );
; 2156 :         g_rgPipelineMapping[ePipeline].bEnabled = TRUE;

  00074	e3a01001	 mov         r1, #1
  00078	e592301c	 ldr         r3, [r2, #0x1C]
  0007c	e3833b01	 orr         r3, r3, #1, 22
  00080	e582301c	 str         r3, [r2, #0x1C]
  00084	e5952008	 ldr         r2, [r5, #8]
  00088	e59230cc	 ldr         r3, [r2, #0xCC]
  0008c	e3833001	 orr         r3, r3, #1
  00090	e58230cc	 str         r3, [r2, #0xCC]
  00094	e5861020	 str         r1, [r6, #0x20]
  00098		 |$LN54@EnablePipe|

; 2157 :     }    
; 2158 : 
; 2159 :     //  Enable VID2 pipeline
; 2160 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  00098	e3540002	 cmp         r4, #2
  0009c	1a00000a	 bne         |$LN55@EnablePipe|

; 2161 :     {
; 2162 :         // Enable the interrupt for reporting the VID2 under flow error
; 2163 :         SETREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VID2FIFOUNDERFLOW);

  000a0	e5952008	 ldr         r2, [r5, #8]

; 2164 : 
; 2165 :         //  Enable the pipeline
; 2166 :         SETREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES, DISPC_VID_ATTR_VIDENABLE );
; 2167 :         g_rgPipelineMapping[ePipeline].bEnabled = TRUE;

  000a4	e3a01001	 mov         r1, #1
  000a8	e592301c	 ldr         r3, [r2, #0x1C]
  000ac	e3833a01	 orr         r3, r3, #1, 20
  000b0	e582301c	 str         r3, [r2, #0x1C]
  000b4	e5952008	 ldr         r2, [r5, #8]
  000b8	e592315c	 ldr         r3, [r2, #0x15C]
  000bc	e3833001	 orr         r3, r3, #1
  000c0	e582315c	 str         r3, [r2, #0x15C]
  000c4	e5861040	 str         r1, [r6, #0x40]
  000c8	ea000000	 b           |$LN18@EnablePipe|
  000cc		 |$LN55@EnablePipe|
  000cc	e5961040	 ldr         r1, [r6, #0x40]
  000d0		 |$LN18@EnablePipe|

; 2142 : 
; 2143 :         //  Enable the pipeline
; 2144 :         SETREG32( &m_pDispRegs->DISPC_GFX_ATTRIBUTES, DISPC_GFX_ATTR_GFXENABLE );        
; 2145 :         g_rgPipelineMapping[ePipeline].bEnabled = TRUE;

  000d0	e5963000	 ldr         r3, [r6]

; 2168 :     }    
; 2169 : 
; 2170 : 
; 2171 :     //  Count the number of pipelines that will be on
; 2172 :     dwNumPipelinesOn += (g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled) ? 1 : 0;

  000d4	e3530000	 cmp         r3, #0
  000d8	e5963020	 ldr         r3, [r6, #0x20]
  000dc	13a02001	 movne       r2, #1
  000e0	03a02000	 moveq       r2, #0

; 2173 :     dwNumPipelinesOn += (g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled) ? 1 : 0;

  000e4	e3530000	 cmp         r3, #0
  000e8	13a03001	 movne       r3, #1
  000ec	03a03000	 moveq       r3, #0

; 2174 :     dwNumPipelinesOn += (g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled) ? 1 : 0;

  000f0	e3510000	 cmp         r1, #0
  000f4	e0822003	 add         r2, r2, r3
  000f8	13a03001	 movne       r3, #1
  000fc	03a03000	 moveq       r3, #0
  00100	e0829003	 add         r9, r2, r3

; 2175 : 
; 2176 : 
; 2177 :     //  If there is only one pipeline enabled, use FIFO merge to make 1 large FIFO
; 2178 :     //  for better power management
; 2179 :     if( dwNumPipelinesOn == 1 )
; 2180 :     {
; 2181 :         //  Enable FIFO merge
; 2182 :         SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_FIFOMERGE );

  00104	e5952008	 ldr         r2, [r5, #8]
  00108	e3590001	 cmp         r9, #1

; 2183 : 
; 2184 :         //  Adjust the FIFO high and low thresholds for all the enabled pipelines
; 2185 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled )

  0010c	03e0333d	 mvneq       r3, #0x3D, 6
  00110	02231cfa	 eoreq       r1, r3, #0xFA, 24
  00114	05923044	 ldreq       r3, [r2, #0x44]
  00118	03833901	 orreq       r3, r3, #1, 18

; 2186 :         {
; 2187 :             OUTREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD,
; 2188 :                         DISPC_GFX_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32)) |
; 2189 :                         DISPC_GFX_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED)
; 2190 :                         );
; 2191 :         }
; 2192 : 
; 2193 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled )
; 2194 :         {
; 2195 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD,
; 2196 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32)) |
; 2197 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED)
; 2198 :                         );
; 2199 :         }
; 2200 : 
; 2201 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled )
; 2202 :         {
; 2203 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD,
; 2204 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32)) |
; 2205 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED)
; 2206 :                         );
; 2207 :         }
; 2208 :     }
; 2209 :     else
; 2210 :     {
; 2211 :         //  Disable FIFO merge
; 2212 :         CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_FIFOMERGE );
; 2213 : 
; 2214 :         //  Adjust the FIFO high and low thresholds for all the enabled pipelines
; 2215 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled )

  0011c	13e0333f	 mvnne       r3, #0x3F, 6
  00120	12231cfe	 eorne       r1, r3, #0xFE, 24
  00124	15923044	 ldrne       r3, [r2, #0x44]
  00128	13c33901	 bicne       r3, r3, #1, 18
  0012c	e5823044	 str         r3, [r2, #0x44]
  00130	e5963000	 ldr         r3, [r6]
  00134	e3530000	 cmp         r3, #0

; 2216 :         {
; 2217 :             OUTREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD,
; 2218 :                         DISPC_GFX_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 2219 :                         DISPC_GFX_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 2220 :                         );

  00138	15953008	 ldrne       r3, [r5, #8]
  0013c	158310a4	 strne       r1, [r3, #0xA4]

; 2221 :         }
; 2222 : 
; 2223 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled )

  00140	e5963020	 ldr         r3, [r6, #0x20]
  00144	e3530000	 cmp         r3, #0

; 2224 :         {
; 2225 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD,
; 2226 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 2227 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 2228 :                         );

  00148	15953008	 ldrne       r3, [r5, #8]
  0014c	158310d0	 strne       r1, [r3, #0xD0]

; 2229 :         }
; 2230 : 
; 2231 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled )

  00150	e5963040	 ldr         r3, [r6, #0x40]
  00154	e3530000	 cmp         r3, #0

; 2232 :         {
; 2233 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD,
; 2234 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 2235 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 2236 :                         );

  00158	15953008	 ldrne       r3, [r5, #8]
  0015c	15831160	 strne       r1, [r3, #0x160]

; 2237 :         }
; 2238 :     }
; 2239 : 
; 2240 : 
; 2241 :     //  Get the destination for the pipeline
; 2242 :     eDest = g_rgPipelineMapping[ePipeline].eDestination;

  00160	e0863284	 add         r3, r6, r4, lsl #5
  00164	e5933004	 ldr         r3, [r3, #4]
  00168	e1b07003	 movs        r7, r3

; 2243 :     switch( eDest )

  0016c	0a000009	 beq         |$LN7@EnablePipe|
  00170	e3570001	 cmp         r7, #1
  00174	1a000059	 bne         |$cleanUp$38445|

; 2249 :             break;
; 2250 : 
; 2251 :         case OMAP_DSS_DESTINATION_TVOUT:
; 2252 :             //  Set enable and go bits for TV Out
; 2253 :             dwDestEnable = (m_bTVEnable) ? DISPC_CONTROL_DIGITALENABLE : 0;

  00178	e59534b4	 ldr         r3, [r5, #0x4B4]
  0017c	e3530000	 cmp         r3, #0
  00180	13a04002	 movne       r4, #2

; 2254 :             dwDestGo     = DISPC_CONTROL_GODIGITAL;

  00184	13a08040	 movne       r8, #0x40
  00188	1a000004	 bne         |$LN8@EnablePipe|
  0018c	e3a04000	 mov         r4, #0
  00190	e3a08040	 mov         r8, #0x40

; 2255 :             break;

  00194	ea000001	 b           |$LN8@EnablePipe|
  00198		 |$LN7@EnablePipe|

; 2244 :     {
; 2245 :         case OMAP_DSS_DESTINATION_LCD:
; 2246 :             //  Set enable and go bits for LCD
; 2247 :             dwDestEnable = DISPC_CONTROL_LCDENABLE;

  00198	e3a04001	 mov         r4, #1

; 2248 :             dwDestGo     = DISPC_CONTROL_GOLCD;

  0019c	e3a08020	 mov         r8, #0x20
  001a0		 |$LN8@EnablePipe|

; 2256 : 
; 2257 :         default:
; 2258 :             ASSERT(0);
; 2259 :             goto cleanUp;
; 2260 :     }
; 2261 :         
; 2262 :     //  Try enabling overlay optimization
; 2263 :     EnableOverlayOptimization( TRUE );

  001a0	e3a01001	 mov         r1, #1
  001a4	e1a00005	 mov         r0, r5
  001a8	eb000000	 bl          |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z|

; 2264 : 
; 2265 :     //  Flush the shadow registers
; 2266 :     FlushRegs( dwDestGo );

  001ac	e1a01008	 mov         r1, r8
  001b0	e1a00005	 mov         r0, r5
  001b4	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 2267 : 
; 2268 : 
; 2269 :     //  If the destination for pipeline is not enabled, enable it
; 2270 :     if( g_dwDestinationRefCnt[eDest]++ == 0 )

  001b8	e2862060	 add         r2, r6, #0x60
  001bc	e7b23107	 ldr         r3, [r2, +r7, lsl #2]!
  001c0	e3530000	 cmp         r3, #0
  001c4	e2833001	 add         r3, r3, #1
  001c8	e5823000	 str         r3, [r2]
  001cc	1a000019	 bne         |$LN1@EnablePipe|

; 2271 :     {
; 2272 :         if (eDest == OMAP_DSS_DESTINATION_LCD)

  001d0	e3570000	 cmp         r7, #0

; 2273 :         {
; 2274 :             SETREG32( &m_pDispRegs->DISPC_CONTROL, dwDestEnable );

  001d4	05952008	 ldreq       r2, [r5, #8]
  001d8	05923040	 ldreq       r3, [r2, #0x40]
  001dc	01833004	 orreq       r3, r3, r4
  001e0	05823040	 streq       r3, [r2, #0x40]
  001e4	0a000013	 beq         |$LN1@EnablePipe|

; 2275 :         }
; 2276 :         else
; 2277 :         {
; 2278 :             // For TVOUT enable, the SYNCLOST_DIGITAL interrupt
; 2279 :             // has to be cleared at the 1st EVSYNC after DIGITALENABLE
; 2280 : 
; 2281 :             DWORD irqStatus, irqEnable;
; 2282 : 
; 2283 :             irqEnable = INREG32( &m_pDispRegs->DISPC_IRQENABLE );

  001e8	e5953008	 ldr         r3, [r5, #8]

; 2284 :             // Disable all the DSS interrupts
; 2285 :             OUTREG32( &m_pDispRegs->DISPC_IRQENABLE , 0 );

  001ec	e3a02000	 mov         r2, #0

; 2286 :             // Clear the Existing IRQ status
; 2287 :             OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, 0xFFFFFFFF );

  001f0	e3e00000	 mvn         r0, #0
  001f4	e593401c	 ldr         r4, [r3, #0x1C]
  001f8	e583201c	 str         r2, [r3, #0x1C]
  001fc	e5953008	 ldr         r3, [r5, #8]

; 2288 : 
; 2289 :             // Enable the DIGITAL Path
; 2290 :             SETREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE );
; 2291 : 
; 2292 :             // Wait for E-VSYNC
; 2293 :             WaitForIRQ( DISPC_IRQSTATUS_EVSYNC_EVEN|DISPC_IRQSTATUS_EVSYNC_ODD );

  00200	e3a0201e	 mov         r2, #0x1E
  00204	e3a0100c	 mov         r1, #0xC
  00208	e5830018	 str         r0, [r3, #0x18]
  0020c	e595e008	 ldr         lr, [r5, #8]
  00210	e1a00005	 mov         r0, r5
  00214	e59e3040	 ldr         r3, [lr, #0x40]
  00218	e3833002	 orr         r3, r3, #2
  0021c	e58e3040	 str         r3, [lr, #0x40]
  00220	eb000000	 bl          |?WaitForIRQ@OMAPDisplayController@@IAAHKK@Z|

; 2294 :             
; 2295 :             // Clear the pending interrupt status
; 2296 :             irqStatus = INREG32( &m_pDispRegs->DISPC_IRQSTATUS );

  00224	e5952008	 ldr         r2, [r5, #8]
  00228	e5923018	 ldr         r3, [r2, #0x18]

; 2297 :             OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS,  irqStatus );

  0022c	e5823018	 str         r3, [r2, #0x18]

; 2298 : 
; 2299 :             // Re-enable the DSS interrupts
; 2300 :             OUTREG32( &m_pDispRegs->DISPC_IRQENABLE , irqEnable );

  00230	e5953008	 ldr         r3, [r5, #8]
  00234	e583401c	 str         r4, [r3, #0x1C]
  00238		 |$LN1@EnablePipe|

; 2301 :         }
; 2302 :     }
; 2303 : 
; 2304 :     // Configure the LPR mode based on active Pipeline(s)
; 2305 :     BOOL bEnable = ((dwNumPipelinesOn == 1) && 
; 2306 :                    (g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled)) ?
; 2307 :                    TRUE : FALSE; 

  00238	e3590001	 cmp         r9, #1
  0023c	1a000003	 bne         |$LN34@EnablePipe|
  00240	e5963000	 ldr         r3, [r6]
  00244	e3530000	 cmp         r3, #0
  00248	13a02001	 movne       r2, #1
  0024c	1a000000	 bne         |$LN35@EnablePipe|
  00250		 |$LN34@EnablePipe|
  00250	e3a02000	 mov         r2, #0
  00254		 |$LN35@EnablePipe|

; 2308 :     EnableLPR( bEnable );

  00254	e5953518	 ldr         r3, [r5, #0x518]
  00258	e58d2000	 str         r2, [sp]
  0025c	e1b00003	 movs        r0, r3
  00260	0a00001d	 beq         |$LN41@EnablePipe|
  00264	e59534cc	 ldr         r3, [r5, #0x4CC]
  00268	e3530000	 cmp         r3, #0
  0026c	1a00001a	 bne         |$LN41@EnablePipe|
  00270	e5953510	 ldr         r3, [r5, #0x510]
  00274	e1520003	 cmp         r2, r3
  00278	0a000017	 beq         |$LN41@EnablePipe|
  0027c	e3520000	 cmp         r2, #0
  00280	0a000009	 beq         |$LN37@EnablePipe|
  00284	e3a03106	 mov         r3, #6, 2
  00288	e3831801	 orr         r1, r3, #1, 16
  0028c	e3a03004	 mov         r3, #4
  00290	e28d2000	 add         r2, sp, #0
  00294	eb000000	 bl          PmxNotifyPolicy
  00298	e5952008	 ldr         r2, [r5, #8]
  0029c	e3a03c22	 mov         r3, #0x22, 24
  002a0	e3833015	 orr         r3, r3, #0x15
  002a4	e5823010	 str         r3, [r2, #0x10]
  002a8	ea000009	 b           |$LN36@EnablePipe|
  002ac		 |$LN37@EnablePipe|
  002ac	e5952008	 ldr         r2, [r5, #8]
  002b0	e3a03a01	 mov         r3, #1, 20
  002b4	e3833009	 orr         r3, r3, #9
  002b8	e5823010	 str         r3, [r2, #0x10]
  002bc	e5950518	 ldr         r0, [r5, #0x518]
  002c0	e3a01106	 mov         r1, #6, 2
  002c4	e3a03004	 mov         r3, #4
  002c8	e28d2000	 add         r2, sp, #0
  002cc	e3811801	 orr         r1, r1, #1, 16
  002d0	eb000000	 bl          PmxNotifyPolicy
  002d4		 |$LN36@EnablePipe|
  002d4	e59d3000	 ldr         r3, [sp]
  002d8	e5853510	 str         r3, [r5, #0x510]
  002dc		 |$LN41@EnablePipe|

; 2309 : 
; 2310 :     //  Result
; 2311 :     bResult = TRUE;         

  002dc	e3a08001	 mov         r8, #1
  002e0		 |$cleanUp$38445|

; 2312 : 
; 2313 : cleanUp:    
; 2314 :     //  Release regs
; 2315 :     ReleaseRegs();

  002e0	e2853b01	 add         r3, r5, #1, 22
  002e4	e283008c	 add         r0, r3, #0x8C
  002e8	eb000000	 bl          LeaveCriticalSection

; 2316 :     
; 2317 :     //  Return result
; 2318 :     return bResult;

  002ec		 |$LN24@EnablePipe|

; 2319 : }

  002ec	e1a00008	 mov         r0, r8
  002f0	e28dd004	 add         sp, sp, #4
  002f4	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  002f8	e12fff1e	 bx          lr
  002fc		 |$LN62@EnablePipe|
  002fc		 |$LN63@EnablePipe|
  002fc	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00300		 |$M41977|

			 ENDP  ; |?EnablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z|, OMAPDisplayController::EnablePipeline

	EXPORT	|?DisablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z| ; OMAPDisplayController::DisablePipeline

  00000			 AREA	 |.pdata|, PDATA
|$T42049| DCD	|$LN59@DisablePip|
	DCD	0x4000c602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DisablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z| PROC ; OMAPDisplayController::DisablePipeline

; 2326 : {

  00000		 |$LN59@DisablePip|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42046|
  00008	e1a06001	 mov         r6, r1
  0000c	e1a04000	 mov         r4, r0

; 2327 :     BOOL                    bResult = FALSE;    
; 2328 :     OMAP_DSS_DESTINATION    eDest;
; 2329 :     DWORD                   dwNumPipelinesOn = 0;
; 2330 :     DWORD                   dwIntrStatus;
; 2331 :     DWORD                   dwDestEnable,
; 2332 :                             dwDestGo;
; 2333 :     BOOL                    bLPRState = FALSE;    
; 2334 : 
; 2335 :     //  Check if pipeline is already disabled
; 2336 :     if( g_rgPipelineMapping[ePipeline].bEnabled == FALSE )

  00010	e59f52fc	 ldr         r5, [pc, #0x2FC]
  00014	e3a07000	 mov         r7, #0
  00018	e3a08000	 mov         r8, #0
  0001c	e7953286	 ldr         r3, [r5, +r6, lsl #5]
  00020	e3530000	 cmp         r3, #0

; 2337 :         return TRUE;

  00024	03a07001	 moveq       r7, #1
  00028	0a0000b5	 beq         |$LN25@DisablePip|

; 2338 :         
; 2339 :     //  Access the regs
; 2340 :     if( AccessRegs() == FALSE )

  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00034	e3500000	 cmp         r0, #0
  00038	0a0000ae	 beq         |$cleanUp$38538|

; 2341 :         goto cleanUp;
; 2342 : 
; 2343 :      // Clear GO_XXX bit if it current enabled. The attributes register for 
; 2344 :     // the pipeline is currently modified and so it is required to turn off
; 2345 :     // the GOLCD/GODIGITAL bit during the configuration.
; 2346 :     if ((INREG32( &m_pDispRegs->DISPC_CONTROL) & DISPC_CONTROL_GOLCD ) != 0)

  0003c	e5942008	 ldr         r2, [r4, #8]
  00040	e5923040	 ldr         r3, [r2, #0x40]
  00044	e3130020	 tst         r3, #0x20

; 2347 :         CLRREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_GOLCD );

  00048	15923040	 ldrne       r3, [r2, #0x40]
  0004c	13c33020	 bicne       r3, r3, #0x20
  00050	15823040	 strne       r3, [r2, #0x40]

; 2348 : 
; 2349 :     if ((INREG32( &m_pDispRegs->DISPC_CONTROL) & DISPC_CONTROL_GODIGITAL ) != 0)

  00054	e5942008	 ldr         r2, [r4, #8]
  00058	e5923040	 ldr         r3, [r2, #0x40]
  0005c	e3130040	 tst         r3, #0x40

; 2350 :         CLRREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_GODIGITAL );

  00060	15923040	 ldrne       r3, [r2, #0x40]
  00064	13c33040	 bicne       r3, r3, #0x40
  00068	15823040	 strne       r3, [r2, #0x40]

; 2351 : 
; 2352 :     //  Disable GFX pipeline
; 2353 :     if( ePipeline == OMAP_DSS_PIPELINE_GFX )

  0006c	e3560000	 cmp         r6, #0
  00070	1a00000b	 bne         |$LN52@DisablePip|

; 2354 :     {
; 2355 :         //  Disable the pipeline
; 2356 :         CLRREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_GFXFIFOUNDERFLOW);

  00074	e5942008	 ldr         r2, [r4, #8]

; 2357 :         CLRREG32( &m_pDispRegs->DISPC_GFX_ATTRIBUTES, DISPC_GFX_ATTR_GFXENABLE );        
; 2358 :         g_rgPipelineMapping[ePipeline].bEnabled = FALSE;

  00078	e3a01000	 mov         r1, #0

; 2359 :         g_rgPipelineMapping[ePipeline].bMirror = FALSE;

  0007c	e3a00000	 mov         r0, #0
  00080	e592301c	 ldr         r3, [r2, #0x1C]
  00084	e3c33040	 bic         r3, r3, #0x40
  00088	e582301c	 str         r3, [r2, #0x1C]
  0008c	e5942008	 ldr         r2, [r4, #8]
  00090	e59230a0	 ldr         r3, [r2, #0xA0]
  00094	e3c33001	 bic         r3, r3, #1
  00098	e58230a0	 str         r3, [r2, #0xA0]
  0009c	e5851000	 str         r1, [r5]
  000a0	e5850010	 str         r0, [r5, #0x10]
  000a4		 |$LN52@DisablePip|

; 2360 :     }    
; 2361 : 
; 2362 :     //  Disable VID1 pipeline
; 2363 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO1 )

  000a4	e3560001	 cmp         r6, #1
  000a8	1a00000b	 bne         |$LN53@DisablePip|

; 2364 :     {
; 2365 :         //  Disable the pipeline
; 2366 :         CLRREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VID1FIFOUNDERFLOW);

  000ac	e5942008	 ldr         r2, [r4, #8]

; 2367 :         CLRREG32( &m_pDispRegs->tDISPC_VID1.ATTRIBUTES, DISPC_VID_ATTR_VIDENABLE );
; 2368 :         g_rgPipelineMapping[ePipeline].bEnabled = FALSE;

  000b0	e3a00000	 mov         r0, #0

; 2369 :         g_rgPipelineMapping[ePipeline].bMirror = FALSE;

  000b4	e3a01000	 mov         r1, #0
  000b8	e592301c	 ldr         r3, [r2, #0x1C]
  000bc	e3c33b01	 bic         r3, r3, #1, 22
  000c0	e582301c	 str         r3, [r2, #0x1C]
  000c4	e5942008	 ldr         r2, [r4, #8]
  000c8	e59230cc	 ldr         r3, [r2, #0xCC]
  000cc	e3c33001	 bic         r3, r3, #1
  000d0	e58230cc	 str         r3, [r2, #0xCC]
  000d4	e5850020	 str         r0, [r5, #0x20]
  000d8	e5851030	 str         r1, [r5, #0x30]
  000dc		 |$LN53@DisablePip|

; 2370 :     }    
; 2371 : 
; 2372 :     //  Disable VID2 pipeline
; 2373 :     if( ePipeline == OMAP_DSS_PIPELINE_VIDEO2 )

  000dc	e3560002	 cmp         r6, #2
  000e0	1a00000c	 bne         |$LN54@DisablePip|

; 2374 :     {
; 2375 :         //  Disable the pipeline
; 2376 :         CLRREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_VID2FIFOUNDERFLOW);

  000e4	e5942008	 ldr         r2, [r4, #8]

; 2377 :         CLRREG32( &m_pDispRegs->tDISPC_VID2.ATTRIBUTES, DISPC_VID_ATTR_VIDENABLE );
; 2378 :         g_rgPipelineMapping[ePipeline].bEnabled = FALSE;

  000e8	e3a01000	 mov         r1, #0

; 2379 :         g_rgPipelineMapping[ePipeline].bMirror = FALSE;

  000ec	e3a00000	 mov         r0, #0
  000f0	e592301c	 ldr         r3, [r2, #0x1C]
  000f4	e3c33a01	 bic         r3, r3, #1, 20
  000f8	e582301c	 str         r3, [r2, #0x1C]
  000fc	e5942008	 ldr         r2, [r4, #8]
  00100	e592315c	 ldr         r3, [r2, #0x15C]
  00104	e3c33001	 bic         r3, r3, #1
  00108	e582315c	 str         r3, [r2, #0x15C]
  0010c	e5851040	 str         r1, [r5, #0x40]
  00110	e5850050	 str         r0, [r5, #0x50]
  00114	ea000000	 b           |$LN17@DisablePip|
  00118		 |$LN54@DisablePip|
  00118	e5951040	 ldr         r1, [r5, #0x40]
  0011c		 |$LN17@DisablePip|

; 2359 :         g_rgPipelineMapping[ePipeline].bMirror = FALSE;

  0011c	e5953000	 ldr         r3, [r5]

; 2380 :     }    
; 2381 : 
; 2382 :     //  Count the number of pipelines that will be on
; 2383 :     dwNumPipelinesOn += (g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled) ? 1 : 0;

  00120	e3530000	 cmp         r3, #0
  00124	e5953020	 ldr         r3, [r5, #0x20]
  00128	13a02001	 movne       r2, #1
  0012c	03a02000	 moveq       r2, #0

; 2384 :     dwNumPipelinesOn += (g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled) ? 1 : 0;

  00130	e3530000	 cmp         r3, #0
  00134	13a03001	 movne       r3, #1
  00138	03a03000	 moveq       r3, #0

; 2385 :     dwNumPipelinesOn += (g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled) ? 1 : 0;

  0013c	e3510000	 cmp         r1, #0
  00140	e0822003	 add         r2, r2, r3
  00144	13a03001	 movne       r3, #1
  00148	03a03000	 moveq       r3, #0
  0014c	e082a003	 add         r10, r2, r3

; 2386 : 
; 2387 : 
; 2388 :     //  If there is only one pipeline enabled, use FIFO merge to make 1 large FIFO
; 2389 :     //  for better power management
; 2390 :     if( dwNumPipelinesOn == 1 )
; 2391 :     {
; 2392 :         //  Enable FIFO merge
; 2393 :         SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_FIFOMERGE );

  00150	e5942008	 ldr         r2, [r4, #8]
  00154	e35a0001	 cmp         r10, #1
  00158	1a000009	 bne         |$LN16@DisablePip|

; 2394 : 
; 2395 :         //  Adjust the FIFO high and low thresholds for all the enabled pipelines
; 2396 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled )

  0015c	e3e0333d	 mvn         r3, #0x3D, 6
  00160	e2231cfa	 eor         r1, r3, #0xFA, 24
  00164	e5923044	 ldr         r3, [r2, #0x44]
  00168	e3833901	 orr         r3, r3, #1, 18
  0016c	e5823044	 str         r3, [r2, #0x44]
  00170	e5953000	 ldr         r3, [r5]
  00174	e3530000	 cmp         r3, #0
  00178	0a00000b	 beq         |$LN11@DisablePip|

; 2397 :         {
; 2398 :             OUTREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD,
; 2399 :                         DISPC_GFX_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32)) |
; 2400 :                         DISPC_GFX_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED)
; 2401 :                         );
; 2402 :             bLPRState = TRUE;

  0017c	e3a08001	 mov         r8, #1

; 2403 :         }
; 2404 : 
; 2405 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled )
; 2406 :         {
; 2407 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD,
; 2408 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32)) |
; 2409 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED)
; 2410 :                         );
; 2411 :         }
; 2412 : 
; 2413 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled )
; 2414 :         {
; 2415 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD,
; 2416 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32)) |
; 2417 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED)
; 2418 :                         );
; 2419 :         }
; 2420 : 
; 2421 : 
; 2422 :     }
; 2423 :     else

  00180	ea000007	 b           |$LN56@DisablePip|
  00184		 |$LN16@DisablePip|

; 2424 :     {
; 2425 : 
; 2426 :         //  Disable FIFO merge
; 2427 :         CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_FIFOMERGE );
; 2428 : 
; 2429 :         //  Adjust the FIFO high and low thresholds for all the enabled pipelines
; 2430 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled )

  00184	e3e0333f	 mvn         r3, #0x3F, 6
  00188	e2231cfe	 eor         r1, r3, #0xFE, 24
  0018c	e5923044	 ldr         r3, [r2, #0x44]
  00190	e3c33901	 bic         r3, r3, #1, 18
  00194	e5823044	 str         r3, [r2, #0x44]
  00198	e5953000	 ldr         r3, [r5]
  0019c	e3530000	 cmp         r3, #0
  001a0	0a000001	 beq         |$LN11@DisablePip|
  001a4		 |$LN56@DisablePip|

; 2431 :         {
; 2432 :             OUTREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD,
; 2433 :                         DISPC_GFX_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 2434 :                         DISPC_GFX_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 2435 :                         );

  001a4	e5943008	 ldr         r3, [r4, #8]
  001a8	e58310a4	 str         r1, [r3, #0xA4]
  001ac		 |$LN11@DisablePip|

; 2436 :         }
; 2437 : 
; 2438 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled )

  001ac	e5953020	 ldr         r3, [r5, #0x20]
  001b0	e3530000	 cmp         r3, #0

; 2439 :         {
; 2440 :             OUTREG32( &m_pDispRegs->tDISPC_VID1.FIFO_THRESHOLD,
; 2441 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 2442 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 2443 :                         );

  001b4	15943008	 ldrne       r3, [r4, #8]
  001b8	158310d0	 strne       r1, [r3, #0xD0]

; 2444 :         }
; 2445 : 
; 2446 :         if( g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled )

  001bc	e5953040	 ldr         r3, [r5, #0x40]
  001c0	e3530000	 cmp         r3, #0

; 2447 :         {
; 2448 :             OUTREG32( &m_pDispRegs->tDISPC_VID2.FIFO_THRESHOLD,
; 2449 :                         DISPC_VID_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_NORMAL(FIFO_BURSTSIZE_16x32)) |
; 2450 :                         DISPC_VID_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_NORMAL)
; 2451 :                         );

  001c4	15943008	 ldrne       r3, [r4, #8]
  001c8	15831160	 strne       r1, [r3, #0x160]

; 2452 :         }
; 2453 : 
; 2454 :     }
; 2455 : 
; 2456 :     //  Get the destination for the pipeline
; 2457 :     eDest = g_rgPipelineMapping[ePipeline].eDestination;

  001cc	e0853286	 add         r3, r5, r6, lsl #5
  001d0	e5933004	 ldr         r3, [r3, #4]
  001d4	e1b09003	 movs        r9, r3

; 2458 :     switch( eDest )

  001d8	0a000004	 beq         |$LN6@DisablePip|
  001dc	e3590001	 cmp         r9, #1
  001e0	1a000044	 bne         |$cleanUp$38538|

; 2464 :             break;
; 2465 : 
; 2466 :         case OMAP_DSS_DESTINATION_TVOUT:
; 2467 :             //  Set enable and go bits for TV Out
; 2468 :             dwDestEnable = DISPC_CONTROL_DIGITALENABLE;

  001e4	e3a07002	 mov         r7, #2

; 2469 :             dwDestGo     = DISPC_CONTROL_GODIGITAL;

  001e8	e3a06040	 mov         r6, #0x40

; 2470 :             break;

  001ec	ea000001	 b           |$LN7@DisablePip|
  001f0		 |$LN6@DisablePip|

; 2459 :     {
; 2460 :         case OMAP_DSS_DESTINATION_LCD:
; 2461 :             //  Set enable and go bits for LCD
; 2462 :             dwDestEnable = DISPC_CONTROL_LCDENABLE;

  001f0	e3a07001	 mov         r7, #1

; 2463 :             dwDestGo     = DISPC_CONTROL_GOLCD;

  001f4	e3a06020	 mov         r6, #0x20
  001f8		 |$LN7@DisablePip|

; 2471 : 
; 2472 :         default:
; 2473 :             ASSERT(0);
; 2474 :             goto cleanUp;
; 2475 :     }
; 2476 :     
; 2477 :     //  Try enabling overlay optimization
; 2478 :     EnableOverlayOptimization( TRUE );

  001f8	e3a01001	 mov         r1, #1
  001fc	e1a00004	 mov         r0, r4
  00200	eb000000	 bl          |?EnableOverlayOptimization@OMAPDisplayController@@QAAXH@Z|

; 2479 : 
; 2480 :     // First turn on the GO bit corresponding to the pipeline
; 2481 :     // that has to be disabled and wait for GO bit to clear.
; 2482 :     FlushRegs( dwDestGo );     

  00204	e1a01006	 mov         r1, r6
  00208	e1a00004	 mov         r0, r4
  0020c	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 2483 :     WaitForFlushDone( dwDestGo );

  00210	e1a01006	 mov         r1, r6
  00214	e1a00004	 mov         r0, r4
  00218	eb000000	 bl          |?WaitForFlushDone@OMAPDisplayController@@IAAHK@Z|

; 2484 : 
; 2485 :     // Additional flush required, when pipeline that is disabled in this
; 2486 :     // function was connected to DIGITALPATH. There could be another pipeline 
; 2487 :     // driving the LCD path and so the LCD path has to be flushed as well
; 2488 :     if ( (dwDestGo != DISPC_CONTROL_GOLCD) && (dwNumPipelinesOn > 0) )

  0021c	e3560020	 cmp         r6, #0x20
  00220	135a0000	 cmpne       r10, #0

; 2489 :         FlushRegs( DISPC_CONTROL_GOLCD );

  00224	13a01020	 movne       r1, #0x20
  00228	11a00004	 movne       r0, r4
  0022c	1b000000	 blne        |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 2490 :     
; 2491 :     //  Update ref count on destination
; 2492 :     //  If ref count on destination is 0, disable output
; 2493 :     if( --g_dwDestinationRefCnt[eDest] == 0 )

  00230	e2852060	 add         r2, r5, #0x60
  00234	e7b23109	 ldr         r3, [r2, +r9, lsl #2]!
  00238	e2533001	 subs        r3, r3, #1
  0023c	e5823000	 str         r3, [r2]

; 2494 :         CLRREG32( &m_pDispRegs->DISPC_CONTROL, dwDestEnable );

  00240	05942008	 ldreq       r2, [r4, #8]
  00244	05923040	 ldreq       r3, [r2, #0x40]
  00248	01c33007	 biceq       r3, r3, r7
  0024c	05823040	 streq       r3, [r2, #0x40]

; 2495 : 
; 2496 :     // clear any pending interrupts
; 2497 :     dwIntrStatus = INREG32 ( &m_pDispRegs->DISPC_IRQSTATUS );

  00250	e5941008	 ldr         r1, [r4, #8]

; 2498 :     SETREG32( &m_pDispRegs->DISPC_IRQSTATUS, dwIntrStatus );
; 2499 : 
; 2500 :     // Configure the LPR mode based on active Pipeline(s)
; 2501 :     // If the pipeline count is 0, then LPR should be ON
; 2502 :     bLPRState = (dwNumPipelinesOn == 0) ? TRUE : bLPRState;

  00254	e35a0000	 cmp         r10, #0
  00258	03a08001	 moveq       r8, #1
  0025c	e5912018	 ldr         r2, [r1, #0x18]
  00260	e5913018	 ldr         r3, [r1, #0x18]

; 2503 :     EnableLPR( bLPRState );

  00264	e58d8000	 str         r8, [sp]
  00268	e1833002	 orr         r3, r3, r2
  0026c	e5813018	 str         r3, [r1, #0x18]
  00270	e5943518	 ldr         r3, [r4, #0x518]
  00274	e1b00003	 movs        r0, r3
  00278	0a00001d	 beq         |$LN40@DisablePip|
  0027c	e59434cc	 ldr         r3, [r4, #0x4CC]
  00280	e3530000	 cmp         r3, #0
  00284	1a00001a	 bne         |$LN40@DisablePip|
  00288	e5943510	 ldr         r3, [r4, #0x510]
  0028c	e1580003	 cmp         r8, r3
  00290	0a000017	 beq         |$LN40@DisablePip|
  00294	e3580000	 cmp         r8, #0
  00298	0a000009	 beq         |$LN36@DisablePip|
  0029c	e3a03106	 mov         r3, #6, 2
  002a0	e3831801	 orr         r1, r3, #1, 16
  002a4	e3a03004	 mov         r3, #4
  002a8	e28d2000	 add         r2, sp, #0
  002ac	eb000000	 bl          PmxNotifyPolicy
  002b0	e5942008	 ldr         r2, [r4, #8]
  002b4	e3a03c22	 mov         r3, #0x22, 24
  002b8	e3833015	 orr         r3, r3, #0x15
  002bc	e5823010	 str         r3, [r2, #0x10]
  002c0	ea000009	 b           |$LN35@DisablePip|
  002c4		 |$LN36@DisablePip|
  002c4	e5942008	 ldr         r2, [r4, #8]
  002c8	e3a03a01	 mov         r3, #1, 20
  002cc	e3833009	 orr         r3, r3, #9
  002d0	e5823010	 str         r3, [r2, #0x10]
  002d4	e5940518	 ldr         r0, [r4, #0x518]
  002d8	e3a01106	 mov         r1, #6, 2
  002dc	e3a03004	 mov         r3, #4
  002e0	e28d2000	 add         r2, sp, #0
  002e4	e3811801	 orr         r1, r1, #1, 16
  002e8	eb000000	 bl          PmxNotifyPolicy
  002ec		 |$LN35@DisablePip|
  002ec	e59d3000	 ldr         r3, [sp]
  002f0	e5843510	 str         r3, [r4, #0x510]
  002f4		 |$LN40@DisablePip|

; 2504 :     
; 2505 :     //  Result
; 2506 :     bResult = TRUE;         

  002f4	e3a07001	 mov         r7, #1
  002f8		 |$cleanUp$38538|

; 2507 : 
; 2508 : cleanUp:    
; 2509 :     //  Release regs
; 2510 :     ReleaseRegs();

  002f8	e2843b01	 add         r3, r4, #1, 22
  002fc	e283008c	 add         r0, r3, #0x8C
  00300	eb000000	 bl          LeaveCriticalSection

; 2511 :     
; 2512 :     //  Return result
; 2513 :     return bResult;

  00304		 |$LN25@DisablePip|

; 2514 : }

  00304	e1a00007	 mov         r0, r7
  00308	e28dd004	 add         sp, sp, #4
  0030c	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00310	e12fff1e	 bx          lr
  00314		 |$LN60@DisablePip|
  00314		 |$LN61@DisablePip|
  00314	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  00318		 |$M42047|

			 ENDP  ; |?DisablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z|, OMAPDisplayController::DisablePipeline

	EXPORT	|?EnableTvOut@OMAPDisplayController@@QAAHH@Z| ; OMAPDisplayController::EnableTvOut

  00000			 AREA	 |.pdata|, PDATA
|$T42075| DCD	|$LN18@EnableTvOu|
	DCD	0x40002e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableTvOut@OMAPDisplayController@@QAAHH@Z| PROC ; OMAPDisplayController::EnableTvOut

; 3972 : {

  00000		 |$LN18@EnableTvOu|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42072|
  00004	e1a06001	 mov         r6, r1
  00008	e1a04000	 mov         r4, r0

; 3973 :     BOOL    bResult = FALSE;
; 3974 : 
; 3975 :     //  Access the regs
; 3976 :     if( AccessRegs() == FALSE )

  0000c	e3a05000	 mov         r5, #0
  00010	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00014	e3500000	 cmp         r0, #0
  00018	0a000020	 beq         |$cleanUp$39376|

; 3977 :         goto cleanUp;
; 3978 : 
; 3979 :     if (bEnable == m_bTVEnable)

  0001c	e59434b4	 ldr         r3, [r4, #0x4B4]
  00020	e1560003	 cmp         r6, r3
  00024	0a00001d	 beq         |$cleanUp$39376|

; 3980 :         goto cleanUp;
; 3981 : 
; 3982 :     //  Enable/disable TV out
; 3983 :     if( bEnable )

  00028	e3560000	 cmp         r6, #0
  0002c	0a000007	 beq         |$LN2@EnableTvOu|

; 3984 :     {
; 3985 :         //  Enable TV out clock
; 3986 :         RequestClock( m_dssinfo.TVEncoderDevice );

  00030	e5940520	 ldr         r0, [r4, #0x520]
  00034	e3a01001	 mov         r1, #1
  00038	eb000000	 bl          EnableDeviceClocks

; 3987 : 
; 3988 :         //  Restore the TV out registers
; 3989 :         RestoreRegisters( OMAP_DSS_DESTINATION_TVOUT );

  0003c	e3a01001	 mov         r1, #1
  00040	e1a00004	 mov         r0, r4
  00044	eb000000	 bl          |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 3990 :             
; 3991 :         m_bTVEnable = TRUE;         

  00048	e3a03001	 mov         r3, #1

; 3992 :     }
; 3993 :     else

  0004c	ea000011	 b           |$LN15@EnableTvOu|
  00050		 |$LN2@EnableTvOu|

; 3994 :     {
; 3995 :         //  Disable TV out
; 3996 :         CLRREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE );

  00050	e5942008	 ldr         r2, [r4, #8]

; 3997 :         
; 3998 :         // Stop the VENC
; 3999 :         ResetVENC();

  00054	e1a00004	 mov         r0, r4
  00058	e5923040	 ldr         r3, [r2, #0x40]
  0005c	e3c33002	 bic         r3, r3, #2
  00060	e5823040	 str         r3, [r2, #0x40]
  00064	eb000000	 bl          |?ResetVENC@OMAPDisplayController@@IAAHXZ|

; 4000 :  
; 4001 :         // Wait for the EVSYNC
; 4002 :         WaitForIRQ(DISPC_IRQSTATUS_EVSYNC_EVEN|DISPC_IRQSTATUS_EVSYNC_ODD);

  00068	e3a0201e	 mov         r2, #0x1E
  0006c	e3a0100c	 mov         r1, #0xC
  00070	e1a00004	 mov         r0, r4
  00074	eb000000	 bl          |?WaitForIRQ@OMAPDisplayController@@IAAHKK@Z|

; 4003 : 
; 4004 :         // clear all the pending interrupts
; 4005 :         SETREG32( &m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_EVSYNC_EVEN|DISPC_IRQSTATUS_EVSYNC_ODD);

  00078	e5942008	 ldr         r2, [r4, #8]

; 4006 :         
; 4007 :         //  Disable TV out clock
; 4008 :         ReleaseClock( m_dssinfo.TVEncoderDevice );

  0007c	e3a01000	 mov         r1, #0
  00080	e5923018	 ldr         r3, [r2, #0x18]
  00084	e383300c	 orr         r3, r3, #0xC
  00088	e5823018	 str         r3, [r2, #0x18]
  0008c	e5940520	 ldr         r0, [r4, #0x520]
  00090	eb000000	 bl          EnableDeviceClocks

; 4009 : 
; 4010 :         m_bTVEnable = FALSE;       

  00094	e3a03000	 mov         r3, #0
  00098		 |$LN15@EnableTvOu|
  00098	e58434b4	 str         r3, [r4, #0x4B4]

; 4011 :     }
; 4012 : 
; 4013 :     //  Success
; 4014 :     bResult = TRUE;

  0009c	e3a05001	 mov         r5, #1
  000a0		 |$cleanUp$39376|

; 4015 : 
; 4016 : cleanUp:
; 4017 :     //  Release regs
; 4018 :     ReleaseRegs();

  000a0	e2843b01	 add         r3, r4, #1, 22
  000a4	e283008c	 add         r0, r3, #0x8C
  000a8	eb000000	 bl          LeaveCriticalSection

; 4019 : 
; 4020 :     //  Return result
; 4021 :     return bResult;
; 4022 : }

  000ac	e1a00005	 mov         r0, r5
  000b0	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000b4	e12fff1e	 bx          lr
  000b8		 |$M42073|

			 ENDP  ; |?EnableTvOut@OMAPDisplayController@@QAAHH@Z|, OMAPDisplayController::EnableTvOut

	EXPORT	|?EnableHdmi@OMAPDisplayController@@QAAHH@Z| ; OMAPDisplayController::EnableHdmi
	IMPORT	|LcdPdd_LCD_GetMode|

  00000			 AREA	 |.pdata|, PDATA
|$T42125| DCD	|$LN28@EnableHdmi|
	DCD	0x40007802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?EnableHdmi@OMAPDisplayController@@QAAHH@Z| PROC ; OMAPDisplayController::EnableHdmi

; 4040 : {

  00000		 |$LN28@EnableHdmi|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42122|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a06000	 mov         r6, r0

; 4041 :     BOOL    bResult = FALSE;
; 4042 : 
; 4043 :     BOOL    bLPRState   = TRUE;
; 4044 :     
; 4045 :     //  Access the regs
; 4046 :     if( AccessRegs() == FALSE )

  00010	e3a04000	 mov         r4, #0
  00014	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00018	e3500000	 cmp         r0, #0
  0001c	0a000064	 beq         |$cleanUp$39399|

; 4047 :         goto cleanUp;
; 4048 : 
; 4049 :     //  Enable or disable HDMI output
; 4050 :     if( bEnable )

  00020	e3550000	 cmp         r5, #0
  00024	0a000026	 beq         |$LN4@EnableHdmi|

; 4051 :     {
; 4052 :         DWORD   dwX = (1280 - m_dwLcdWidth)/2,

  00028	e59634a8	 ldr         r3, [r6, #0x4A8]

; 4053 :                 dwY = (720 - m_dwLcdHeight)/2;

  0002c	e59624ac	 ldr         r2, [r6, #0x4AC]

; 4054 : 
; 4055 :         m_dwPixelClock = OMAP_DSS_FCLKVALUE_HDMI/2;

  00030	e59fe1a4	 ldr         lr, [pc, #0x1A4]
  00034	e2633c05	 rsb         r3, r3, #5, 24
  00038	e2622e2d	 rsb         r2, r2, #0x2D, 28

; 4056 :         
; 4057 :         //Save the configuration of internal LCD
; 4058 :         SaveRegisters( OMAP_DSS_DESTINATION_LCD );

  0003c	e3a01000	 mov         r1, #0
  00040	e1a00006	 mov         r0, r6
  00044	e1a050a3	 mov         r5, r3, lsr #1
  00048	e1a040a2	 mov         r4, r2, lsr #1
  0004c	e586e4b0	 str         lr, [r6, #0x4B0]
  00050	eb000000	 bl          |?SaveRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 4059 : 
; 4060 :         // Issue Power Down command to Internal LCD Panel
; 4061 :         LcdPdd_SetPowerLevel(D4);

  00054	e3a00004	 mov         r0, #4
  00058	eb000000	 bl          LcdPdd_SetPowerLevel

; 4062 :         
; 4063 :         // Disable LPR and configure DSI for HDMI clk
; 4064 :         bLPRState = FALSE;
; 4065 :         EnableLPR( bLPRState, TRUE );

  0005c	e3a02001	 mov         r2, #1
  00060	e3a01000	 mov         r1, #0
  00064	e1a00006	 mov         r0, r6
  00068	eb000000	 bl          |?EnableLPR@OMAPDisplayController@@QAAXHH@Z|

; 4066 : 
; 4067 : 		//
; 4068 :         //  Configure the HDMI timing parameters
; 4069 :         //
; 4070 : 
; 4071 :         // Timing logic for HSYNC signal
; 4072 :         OUTREG32( &m_pDispRegs->DISPC_TIMING_H,
; 4073 :                     DISPC_TIMING_H_HSW(40) |
; 4074 :                     DISPC_TIMING_H_HFP(110) |
; 4075 :                     DISPC_TIMING_H_HBP(220)
; 4076 :                     );

  0006c	e5962008	 ldr         r2, [r6, #8]
  00070	e59f3160	 ldr         r3, [pc, #0x160]

; 4077 : 
; 4078 :         // Timing logic for VSYNC signal
; 4079 :         OUTREG32( &m_pDispRegs->DISPC_TIMING_V,
; 4080 :                     DISPC_TIMING_V_VSW(5) |
; 4081 :                     DISPC_TIMING_V_VFP(5) |
; 4082 :                     DISPC_TIMING_V_VBP(20)
; 4083 :                     );

  00074	e59f1158	 ldr         r1, [pc, #0x158]

; 4084 : 
; 4085 :         // Signal configuration
; 4086 :         OUTREG32( &m_pDispRegs->DISPC_POL_FREQ,
; 4087 :                     0
; 4088 :                     );

  00078	e3a0e000	 mov         lr, #0
  0007c	e5823064	 str         r3, [r2, #0x64]
  00080	e5963008	 ldr         r3, [r6, #8]
  00084	e3a02801	 mov         r2, #1, 16

; 4089 : 
; 4090 :         // Configures the divisor
; 4091 :         OUTREG32( &m_pDispRegs->DISPC_DIVISOR,
; 4092 :                     DISPC_DIVISOR_PCD(2) |
; 4093 :                     DISPC_DIVISOR_LCD(1)
; 4094 :                     );

  00088	e3822002	 orr         r2, r2, #2
  0008c	e5831068	 str         r1, [r3, #0x68]
  00090	e5963008	 ldr         r3, [r6, #8]

; 4095 : 
; 4096 : 
; 4097 :         // Configures the panel size
; 4098 :         OUTREG32( &m_pDispRegs->DISPC_SIZE_LCD,
; 4099 :                     DISPC_SIZE_LCD_LPP(720) |
; 4100 :                     DISPC_SIZE_LCD_PPL(1280)
; 4101 :                     );

  00094	e59f0134	 ldr         r0, [pc, #0x134]

; 4102 : 
; 4103 : 
; 4104 :         //  Center the output
; 4105 :         OUTREG32( &m_pDispRegs->DISPC_GFX_POSITION,
; 4106 :                     DISPC_GFX_POS_GFXPOSX(dwX) |
; 4107 :                     DISPC_GFX_POS_GFXPOSY(dwY)
; 4108 :                     );

  00098	e1851804	 orr         r1, r5, r4, lsl #16
  0009c	e583e06c	 str         lr, [r3, #0x6C]
  000a0	e5963008	 ldr         r3, [r6, #8]

; 4109 : 
; 4110 :         m_bHDMIEnable = TRUE;

  000a4	e3a0e001	 mov         lr, #1
  000a8	e5832070	 str         r2, [r3, #0x70]
  000ac	e5963008	 ldr         r3, [r6, #8]
  000b0	e583007c	 str         r0, [r3, #0x7C]
  000b4	e5963008	 ldr         r3, [r6, #8]
  000b8	e5831088	 str         r1, [r3, #0x88]
  000bc	e586e4c8	 str         lr, [r6, #0x4C8]

; 4111 :     }
; 4112 :     else

  000c0	ea000033	 b           |$LN14@EnableHdmi|
  000c4		 |$LN4@EnableHdmi|

; 4113 :     {
; 4114 :         // Get the int LCD params
; 4115 :         LcdPdd_LCD_GetMode( (DWORD*) &m_eLcdPixelFormat,
; 4116 :                               &m_dwLcdWidth,
; 4117 :                               &m_dwLcdHeight,
; 4118 :                               &m_dwPixelClock
; 4119 :                               );

  000c4	e2863b01	 add         r3, r6, #1, 22
  000c8	e2861b01	 add         r1, r6, #1, 22
  000cc	e2860b01	 add         r0, r6, #1, 22
  000d0	e28320ac	 add         r2, r3, #0xAC
  000d4	e2863e4b	 add         r3, r6, #0x4B, 28
  000d8	e28110a8	 add         r1, r1, #0xA8
  000dc	e28000a4	 add         r0, r0, #0xA4
  000e0	eb000000	 bl          LcdPdd_LCD_GetMode

; 4120 :         
; 4121 :         // Clear the HDMI at the beginning.
; 4122 :         // Required for restoring IntLCD context
; 4123 :         m_bHDMIEnable = FALSE;

  000e4	e3a03000	 mov         r3, #0

; 4124 : 
; 4125 :         // Change the power state to LCD panel
; 4126 :         LcdPdd_SetPowerLevel(D0);

  000e8	e3a00000	 mov         r0, #0
  000ec	e58634c8	 str         r3, [r6, #0x4C8]
  000f0	eb000000	 bl          LcdPdd_SetPowerLevel

; 4127 : 
; 4128 :         // Restore internal LCD configurations
; 4129 :         RestoreRegisters(OMAP_DSS_DESTINATION_LCD);

  000f4	e3a01000	 mov         r1, #0
  000f8	e1a00006	 mov         r0, r6
  000fc	eb000000	 bl          |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 4130 : 
; 4131 :         // Enable the LPR if the FIFO's are merged.
; 4132 :         if ( (INREG32( &m_pDispRegs->DISPC_CONFIG) & DISPC_CONFIG_FIFOMERGE ) )

  00100	e5961008	 ldr         r1, [r6, #8]
  00104	e5913044	 ldr         r3, [r1, #0x44]
  00108	e3130901	 tst         r3, #1, 18

; 4133 :             bLPRState = TRUE;
; 4134 :         else
; 4135 :             bLPRState = FALSE;
; 4136 : 
; 4137 :         // Restore LPR if enabled and configure DSI to IntLCD FCLK
; 4138 :         EnableLPR( bLPRState, FALSE );

  0010c	e5963518	 ldr         r3, [r6, #0x518]
  00110	13a02001	 movne       r2, #1
  00114	03a02000	 moveq       r2, #0
  00118	e58d2000	 str         r2, [sp]
  0011c	e1b00003	 movs        r0, r3
  00120	0a00001b	 beq         |$LN14@EnableHdmi|
  00124	e59634cc	 ldr         r3, [r6, #0x4CC]
  00128	e3530000	 cmp         r3, #0
  0012c	1a000018	 bne         |$LN14@EnableHdmi|
  00130	e5963510	 ldr         r3, [r6, #0x510]
  00134	e1520003	 cmp         r2, r3
  00138	0a000015	 beq         |$LN14@EnableHdmi|
  0013c	e3520000	 cmp         r2, #0
  00140	e28d2000	 add         r2, sp, #0
  00144	0a000008	 beq         |$LN10@EnableHdmi|
  00148	e3a03106	 mov         r3, #6, 2
  0014c	e3831801	 orr         r1, r3, #1, 16
  00150	e3a03004	 mov         r3, #4
  00154	eb000000	 bl          PmxNotifyPolicy
  00158	e5962008	 ldr         r2, [r6, #8]
  0015c	e3a03c22	 mov         r3, #0x22, 24
  00160	e3833015	 orr         r3, r3, #0x15
  00164	e5823010	 str         r3, [r2, #0x10]
  00168	ea000007	 b           |$LN9@EnableHdmi|
  0016c		 |$LN10@EnableHdmi|
  0016c	e3a03a01	 mov         r3, #1, 20
  00170	e3833009	 orr         r3, r3, #9
  00174	e5813010	 str         r3, [r1, #0x10]
  00178	e5960518	 ldr         r0, [r6, #0x518]
  0017c	e3a01106	 mov         r1, #6, 2
  00180	e3811801	 orr         r1, r1, #1, 16
  00184	e3a03004	 mov         r3, #4
  00188	eb000000	 bl          PmxNotifyPolicy
  0018c		 |$LN9@EnableHdmi|
  0018c	e59d3000	 ldr         r3, [sp]
  00190	e5863510	 str         r3, [r6, #0x510]
  00194		 |$LN14@EnableHdmi|

; 4139 :     }
; 4140 :     
; 4141 :     //  Flush shadow registers
; 4142 :     FlushRegs( DISPC_CONTROL_GOLCD );

  00194	e3a01020	 mov         r1, #0x20
  00198	e1a00006	 mov         r0, r6
  0019c	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 4143 : 
; 4144 :     //  Enable the LCD
; 4145 :     SETREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_LCDENABLE );

  001a0	e5962008	 ldr         r2, [r6, #8]

; 4146 : 
; 4147 :     //  Success
; 4148 :     bResult = TRUE;

  001a4	e3a04001	 mov         r4, #1
  001a8	e5923040	 ldr         r3, [r2, #0x40]
  001ac	e3833001	 orr         r3, r3, #1
  001b0	e5823040	 str         r3, [r2, #0x40]
  001b4		 |$cleanUp$39399|

; 4149 : 
; 4150 : cleanUp:
; 4151 :     //  Release regs
; 4152 :     ReleaseRegs();

  001b4	e2863b01	 add         r3, r6, #1, 22
  001b8	e283008c	 add         r0, r3, #0x8C
  001bc	eb000000	 bl          LeaveCriticalSection

; 4153 : 
; 4154 :     //  Return result
; 4155 :     return bResult;
; 4156 : }

  001c0	e1a00004	 mov         r0, r4
  001c4	e28dd004	 add         sp, sp, #4
  001c8	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  001cc	e12fff1e	 bx          lr
  001d0		 |$LN29@EnableHdmi|
  001d0		 |$LN30@EnableHdmi|
  001d0	02cf04ff	 DCD         0x2cf04ff
  001d4		 |$LN31@EnableHdmi|
  001d4	01400505	 DCD         0x1400505
  001d8		 |$LN32@EnableHdmi|
  001d8	0dc06e28	 DCD         0xdc06e28
  001dc		 |$LN33@EnableHdmi|
  001dc	046cf710	 DCD         0x46cf710
  001e0		 |$M42123|

			 ENDP  ; |?EnableHdmi@OMAPDisplayController@@QAAHH@Z|, OMAPDisplayController::EnableHdmi

	EXPORT	|?SetPowerLevel@OMAPDisplayController@@QAAHK@Z| ; OMAPDisplayController::SetPowerLevel

  00000			 AREA	 |.pdata|, PDATA
|$T42200| DCD	|$LN59@SetPowerLe|
	DCD	0x4000d102
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?SetPowerLevel@OMAPDisplayController@@QAAHK@Z| PROC ; OMAPDisplayController::SetPowerLevel

; 3745 : {

  00000		 |$LN59@SetPowerLe|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42197|
  00008	e1a05001	 mov         r5, r1
  0000c	e1a04000	 mov         r4, r0

; 3746 :     BOOL            bResult = TRUE;
; 3747 :     DWORD   dwTimeout;
; 3748 :     
; 3749 :     //  Lock access to power level
; 3750 :     EnterCriticalSection( &m_csPowerLock );

  00010	e2848b01	 add         r8, r4, #1, 22
  00014	e288008c	 add         r0, r8, #0x8C
  00018	eb000000	 bl          EnterCriticalSection

; 3751 :     
; 3752 :     //  Check if there is a change in the power level
; 3753 :     if( m_dwPowerLevel == dwPowerLevel )

  0001c	e5943488	 ldr         r3, [r4, #0x488]
  00020	e1530005	 cmp         r3, r5
  00024	0a0000bf	 beq         |$cleanUp$39310|

; 3754 :         goto cleanUp;
; 3755 : 
; 3756 :     //  Enable/disable devices based on power level
; 3757 :     switch( dwPowerLevel )

  00028	e3550002	 cmp         r5, #2
  0002c	9a000037	 bls         |$LN19@SetPowerLe|
  00030	e3550004	 cmp         r5, #4
  00034	8a0000bb	 bhi         |$cleanUp$39310|

; 3883 :             }
; 3884 : 
; 3885 :         break;
; 3886 :         
; 3887 :         case D3:
; 3888 :         case D4:
; 3889 :             //  Check against current level
; 3890 :             if( m_dwPowerLevel == D0 || m_dwPowerLevel == D1 || m_dwPowerLevel == D2)

  00038	e3530000	 cmp         r3, #0
  0003c	0a000003	 beq         |$LN3@SetPowerLe|
  00040	e3530001	 cmp         r3, #1
  00044	0a000001	 beq         |$LN3@SetPowerLe|
  00048	e3530002	 cmp         r3, #2
  0004c	1a00003b	 bne         |$LN49@SetPowerLe|
  00050		 |$LN3@SetPowerLe|

; 3891 :             {
; 3892 : 
; 3893 :                 //  Disable TV out
; 3894 :                 if( g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_TVOUT] > 0 )

  00050	e59f62e8	 ldr         r6, [pc, #0x2E8]
  00054	e5963004	 ldr         r3, [r6, #4]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000013	 beq         |$LN47@SetPowerLe|

; 3895 :                 {
; 3896 :                     //  Disable TV out control
; 3897 :                     CLRREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE );        

  00060	e594e008	 ldr         lr, [r4, #8]

; 3898 : 
; 3899 :                     //  Wait for EVSYNC
; 3900 :                     WaitForIRQ(DISPC_IRQSTATUS_EVSYNC_EVEN|DISPC_IRQSTATUS_EVSYNC_ODD);

  00064	e3a0201e	 mov         r2, #0x1E
  00068	e3a0100c	 mov         r1, #0xC
  0006c	e59e3040	 ldr         r3, [lr, #0x40]
  00070	e1a00004	 mov         r0, r4
  00074	e3c33002	 bic         r3, r3, #2
  00078	e58e3040	 str         r3, [lr, #0x40]
  0007c	eb000000	 bl          |?WaitForIRQ@OMAPDisplayController@@IAAHKK@Z|

; 3901 : 
; 3902 :                     // clear all the pending interrupts
; 3903 :                     SETREG32( &m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_EVSYNC_EVEN|DISPC_IRQSTATUS_EVSYNC_ODD);

  00080	e5942008	 ldr         r2, [r4, #8]

; 3904 : 
; 3905 :                     //  Save TV out settings
; 3906 :                     SaveRegisters(OMAP_DSS_DESTINATION_TVOUT);

  00084	e3a01001	 mov         r1, #1
  00088	e1a00004	 mov         r0, r4
  0008c	e5923018	 ldr         r3, [r2, #0x18]
  00090	e383300c	 orr         r3, r3, #0xC
  00094	e5823018	 str         r3, [r2, #0x18]
  00098	eb000000	 bl          |?SaveRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 3907 : 
; 3908 :                     //  Reset the video encoder
; 3909 :                     ResetVENC();                           

  0009c	e1a00004	 mov         r0, r4
  000a0	eb000000	 bl          |?ResetVENC@OMAPDisplayController@@IAAHXZ|

; 3910 : 
; 3911 :                     //  Release the clock
; 3912 :                     ReleaseClock( m_dssinfo.TVEncoderDevice );

  000a4	e5940520	 ldr         r0, [r4, #0x520]
  000a8	e3a01000	 mov         r1, #0
  000ac	eb000000	 bl          EnableDeviceClocks
  000b0		 |$LN47@SetPowerLe|

; 3913 :                 }
; 3914 : 
; 3915 :                 //  Disable LCD
; 3916 :                 if( g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_LCD] > 0 )

  000b0	e5963000	 ldr         r3, [r6]
  000b4	e3530000	 cmp         r3, #0
  000b8	0a000007	 beq         |$LN1@SetPowerLe|

; 3917 :                 {
; 3918 :                     //  Save LCD settings
; 3919 :                     SaveRegisters(OMAP_DSS_DESTINATION_LCD);

  000bc	e3a01000	 mov         r1, #0
  000c0	e1a00004	 mov         r0, r4
  000c4	eb000000	 bl          |?SaveRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 3920 : 
; 3921 :                     //  Disable LCD
; 3922 :                     LcdPdd_SetPowerLevel( dwPowerLevel );

  000c8	e1a00005	 mov         r0, r5
  000cc	eb000000	 bl          LcdPdd_SetPowerLevel

; 3923 :                     
; 3924 :                     //  Wait for the frame to complete
; 3925 :                     WaitForFrameDone();

  000d0	e3a0101e	 mov         r1, #0x1E
  000d4	e1a00004	 mov         r0, r4
  000d8	eb000000	 bl          |?WaitForFrameDone@OMAPDisplayController@@IAAHK@Z|
  000dc		 |$LN1@SetPowerLe|

; 3926 :                 }
; 3927 : 
; 3928 :                 //  Call PDD layer (again in case LCD was not enabled)
; 3929 :                 LcdPdd_SetPowerLevel( dwPowerLevel );

  000dc	e1a00005	 mov         r0, r5
  000e0	eb000000	 bl          LcdPdd_SetPowerLevel

; 3930 : 
; 3931 :                 //  Clear all DSS interrupts
; 3932 :                 OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, 0xFFFFFFFF );

  000e4	e5943008	 ldr         r3, [r4, #8]
  000e8	e3e02000	 mvn         r2, #0

; 3933 :                 
; 3934 :                 //  Change interconnect parameters to disable controller
; 3935 :                 OUTREG32( &m_pDispRegs->DISPC_SYSCONFIG, DISPC_SYSCONFIG_AUTOIDLE|SYSCONFIG_FORCEIDLE|SYSCONFIG_FORCESTANDBY );

  000ec	e3a00001	 mov         r0, #1
  000f0	e5832018	 str         r2, [r3, #0x18]
  000f4	e5943008	 ldr         r3, [r4, #8]

; 3936 : 
; 3937 : #if 0
; 3938 : 				if ( m_eDssFclkSource == OMAP_DSS_FCLK_DSS2ALWON )
; 3939 :                 {
; 3940 :                     // De-init the DSI Pll and Power Down the DSI PLL
; 3941 :                     DeInitDsiPll();
; 3942 :                     // Set clock to DSS1
; 3943 :                     ULONG count = 1;
; 3944 :                     ULONG clockSrc = kDSS1_ALWON_FCLK;
; 3945 :                     SelectDSSSourceClocks( count, &clockSrc);
; 3946 :                 }
; 3947 : #endif
; 3948 : 
; 3949 : 				//  Disable device clocks 
; 3950 :                 ReleaseClock( m_dssinfo.DSSDevice );         

  000f8	e3a01000	 mov         r1, #0
  000fc	e5830010	 str         r0, [r3, #0x10]
  00100	e594051c	 ldr         r0, [r4, #0x51C]
  00104	eb000000	 bl          EnableDeviceClocks
  00108	e5845488	 str         r5, [r4, #0x488]
  0010c	ea000085	 b           |$cleanUp$39310|
  00110		 |$LN19@SetPowerLe|

; 3758 :     {
; 3759 :         case D0:
; 3760 :         case D1: 
; 3761 :         case D2:
; 3762 :             //  Check against current level
; 3763 :             if( m_dwPowerLevel == D3 || m_dwPowerLevel == D4)

  00110	e3530003	 cmp         r3, #3
  00114	0a00000b	 beq         |$LN17@SetPowerLe|
  00118	e3530004	 cmp         r3, #4
  0011c	0a000009	 beq         |$LN17@SetPowerLe|

; 3874 :             }
; 3875 : 			else    
; 3876 :             {         
; 3877 :                 LcdPdd_SetPowerLevel(dwPowerLevel);

  00120	e1a00005	 mov         r0, r5
  00124	eb000000	 bl          LcdPdd_SetPowerLevel

; 3878 :                 if (dwPowerLevel == D2)
; 3879 :                     CLRREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE );

  00128	e5942008	 ldr         r2, [r4, #8]
  0012c	e3550002	 cmp         r5, #2
  00130	e5923040	 ldr         r3, [r2, #0x40]
  00134	03c33002	 biceq       r3, r3, #2

; 3880 :                 else
; 3881 :                     SETREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE );

  00138	13833002	 orrne       r3, r3, #2
  0013c	e5823040	 str         r3, [r2, #0x40]

; 3936 : 
; 3937 : #if 0
; 3938 : 				if ( m_eDssFclkSource == OMAP_DSS_FCLK_DSS2ALWON )
; 3939 :                 {
; 3940 :                     // De-init the DSI Pll and Power Down the DSI PLL
; 3941 :                     DeInitDsiPll();
; 3942 :                     // Set clock to DSS1
; 3943 :                     ULONG count = 1;
; 3944 :                     ULONG clockSrc = kDSS1_ALWON_FCLK;
; 3945 :                     SelectDSSSourceClocks( count, &clockSrc);
; 3946 :                 }
; 3947 : #endif
; 3948 : 
; 3949 : 				//  Disable device clocks 
; 3950 :                 ReleaseClock( m_dssinfo.DSSDevice );         

  00140		 |$LN49@SetPowerLe|

; 3882 : 			    m_dwPowerLevel = dwPowerLevel;

  00140	e5845488	 str         r5, [r4, #0x488]
  00144	ea000077	 b           |$cleanUp$39310|
  00148		 |$LN17@SetPowerLe|

; 3764 :             {
; 3765 :                 //  Set the new power level
; 3766 :                 m_dwPowerLevel = dwPowerLevel;
; 3767 :             
; 3768 :                 //  Enable device clocks
; 3769 :                 RequestClock( m_dssinfo.DSSDevice );         

  00148	e594051c	 ldr         r0, [r4, #0x51C]
  0014c	e3a01001	 mov         r1, #1
  00150	e5845488	 str         r5, [r4, #0x488]
  00154	eb000000	 bl          EnableDeviceClocks

; 3770 : 
; 3771 :                 //  Call PDD layer
; 3772 :                 LcdPdd_SetPowerLevel( dwPowerLevel );

  00158	e1a00005	 mov         r0, r5
  0015c	eb000000	 bl          LcdPdd_SetPowerLevel

; 3773 : 
; 3774 :                 //  Re-enable LCD outputs
; 3775 :                 if( g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_LCD] > 0 )

  00160	e59f61d8	 ldr         r6, [pc, #0x1D8]
  00164	e5963000	 ldr         r3, [r6]
  00168	e3530000	 cmp         r3, #0
  0016c	0a00004d	 beq         |$LN13@SetPowerLe|

; 3776 :                 {
; 3777 :                     // The HDMI uses DSI clock. At init time, DSS is turned
; 3778 :                     // ON and so HDMI cannot be configured at init time.
; 3779 :                     // The HDMI config seq is given below
; 3780 :                     // init -> InternalLCD(DSS) -> HDMI(DSI)
; 3781 :                     
; 3782 :                     // Store the current HDMI state
; 3783 :                     BOOL bHdmiEnable = m_bHDMIEnable;
; 3784 :                     // Force HDMI to inactive state during init
; 3785 :                     m_bHDMIEnable = FALSE;

  00170	e59474c8	 ldr         r7, [r4, #0x4C8]
  00174	e3a03000	 mov         r3, #0

; 3786 : 
; 3787 : #if 0
; 3788 : 					// Turn on the DSS2_ALWON_FCLK if the FCLK source is DSI clock
; 3789 :                     if ( m_eDssFclkSource == OMAP_DSS_FCLK_DSS2ALWON )
; 3790 :                     {
; 3791 :                         ULONG count = 2;
; 3792 :                         ULONG clockSrc[2] = {kDSS1_ALWON_FCLK, kDSS2_ALWON_FCLK};
; 3793 :                         SelectDSSSourceClocks( count, clockSrc);
; 3794 :                         InitDsiPll();
; 3795 :                     }
; 3796 : #endif
; 3797 :                     
; 3798 :                     //  Restore LCD settings
; 3799 :                     RestoreRegisters(OMAP_DSS_DESTINATION_LCD);

  00178	e3a01000	 mov         r1, #0
  0017c	e1a00004	 mov         r0, r4
  00180	e58434c8	 str         r3, [r4, #0x4C8]
  00184	eb000000	 bl          |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 3800 : 
; 3801 :                     // enable interrupt for reporting SYNCLOST errors
; 3802 :                     SETREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_SYNCLOST);

  00188	e5942008	 ldr         r2, [r4, #8]

; 3803 : 
; 3804 :                     LcdPdd_SetPowerLevel( dwPowerLevel );

  0018c	e1a00005	 mov         r0, r5
  00190	e592301c	 ldr         r3, [r2, #0x1C]
  00194	e3833901	 orr         r3, r3, #1, 18
  00198	e582301c	 str         r3, [r2, #0x1C]
  0019c	eb000000	 bl          LcdPdd_SetPowerLevel

; 3805 : 
; 3806 :                     // Check the FIFO threshold level and decide if LPR is required
; 3807 :                     DWORD dwFIFOThreshold = 
; 3808 :                         (DISPC_GFX_FIFO_THRESHOLD_LOW(FIFO_LOWTHRESHOLD_MERGED(FIFO_BURSTSIZE_16x32))|
; 3809 :                          DISPC_GFX_FIFO_THRESHOLD_HIGH(FIFO_HIGHTHRESHOLD_MERGED));
; 3810 :                     
; 3811 :                     BOOL bLPREnable = FALSE;
; 3812 :                         
; 3813 :                     // Enable the LPR if the FIFO's are merged.
; 3814 :                     if ( INREG32( &m_pDispRegs->DISPC_GFX_FIFO_THRESHOLD) == dwFIFOThreshold )

  001a0	e5940008	 ldr         r0, [r4, #8]
  001a4	e3e0333d	 mvn         r3, #0x3D, 6
  001a8	e2232cfa	 eor         r2, r3, #0xFA, 24
  001ac	e59030a4	 ldr         r3, [r0, #0xA4]
  001b0	e3a01000	 mov         r1, #0
  001b4	e1530002	 cmp         r3, r2
  001b8	1a000004	 bne         |$LN14@SetPowerLe|

; 3815 :                     {
; 3816 :                         SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_FIFOMERGE);

  001bc	e5903044	 ldr         r3, [r0, #0x44]

; 3817 :                         
; 3818 :                         // Make sure the LPR is disabled when HDMI is enabled
; 3819 :                         if (bHdmiEnable == FALSE)

  001c0	e3570000	 cmp         r7, #0

; 3820 :                         {
; 3821 :                             // LPR should be turned ON
; 3822 :                             bLPREnable = TRUE;

  001c4	03a01001	 moveq       r1, #1
  001c8	e3833901	 orr         r3, r3, #1, 18
  001cc	e5803044	 str         r3, [r0, #0x44]
  001d0		 |$LN14@SetPowerLe|

; 3823 :                         }
; 3824 :                     }
; 3825 : 
; 3826 :                     // Toggle the LPR state
; 3827 :                     m_bLPREnable = ( m_bLPREnable == TRUE ) ? FALSE : TRUE;

  001d0	e5943510	 ldr         r3, [r4, #0x510]

; 3828 :                     // Turn on LPR and also switch to DSI clock (if clksource == DSI)
; 3829 :                     EnableLPR( bLPREnable );

  001d4	e58d1000	 str         r1, [sp]
  001d8	e3530001	 cmp         r3, #1
  001dc	e5943518	 ldr         r3, [r4, #0x518]
  001e0	03a02000	 moveq       r2, #0
  001e4	13a02001	 movne       r2, #1
  001e8	e5842510	 str         r2, [r4, #0x510]
  001ec	e1b00003	 movs        r0, r3
  001f0	0a00001c	 beq         |$LN35@SetPowerLe|
  001f4	e59434cc	 ldr         r3, [r4, #0x4CC]
  001f8	e3530000	 cmp         r3, #0
  001fc	1a000019	 bne         |$LN35@SetPowerLe|
  00200	e1510002	 cmp         r1, r2
  00204	0a000017	 beq         |$LN35@SetPowerLe|
  00208	e3510000	 cmp         r1, #0
  0020c	0a000009	 beq         |$LN31@SetPowerLe|
  00210	e3a03106	 mov         r3, #6, 2
  00214	e3831801	 orr         r1, r3, #1, 16
  00218	e3a03004	 mov         r3, #4
  0021c	e28d2000	 add         r2, sp, #0
  00220	eb000000	 bl          PmxNotifyPolicy
  00224	e5942008	 ldr         r2, [r4, #8]
  00228	e3a03c22	 mov         r3, #0x22, 24
  0022c	e3833015	 orr         r3, r3, #0x15
  00230	e5823010	 str         r3, [r2, #0x10]
  00234	ea000009	 b           |$LN30@SetPowerLe|
  00238		 |$LN31@SetPowerLe|
  00238	e5942008	 ldr         r2, [r4, #8]
  0023c	e3a03a01	 mov         r3, #1, 20
  00240	e3833009	 orr         r3, r3, #9
  00244	e5823010	 str         r3, [r2, #0x10]
  00248	e5940518	 ldr         r0, [r4, #0x518]
  0024c	e3a01106	 mov         r1, #6, 2
  00250	e3a03004	 mov         r3, #4
  00254	e28d2000	 add         r2, sp, #0
  00258	e3811801	 orr         r1, r1, #1, 16
  0025c	eb000000	 bl          PmxNotifyPolicy
  00260		 |$LN30@SetPowerLe|
  00260	e59d3000	 ldr         r3, [sp]
  00264	e5843510	 str         r3, [r4, #0x510]
  00268		 |$LN35@SetPowerLe|

; 3830 :                     
; 3831 :                     //  Flush shadow registers
; 3832 :                     FlushRegs( DISPC_CONTROL_GOLCD );

  00268	e3a01020	 mov         r1, #0x20
  0026c	e1a00004	 mov         r0, r4
  00270	eb000000	 bl          |?FlushRegs@OMAPDisplayController@@IAAHK@Z|

; 3833 :                     
; 3834 :                     if (bHdmiEnable)

  00274	e3570000	 cmp         r7, #0
  00278	0a00000a	 beq         |$LN13@SetPowerLe|

; 3835 :                     {
; 3836 :                         WaitForFlushDone( DISPC_CONTROL_GOLCD );

  0027c	e3a01020	 mov         r1, #0x20
  00280	e1a00004	 mov         r0, r4
  00284	eb000000	 bl          |?WaitForFlushDone@OMAPDisplayController@@IAAHK@Z|

; 3837 :                         // Restore the HDMI specific context
; 3838 :                         m_bHDMIEnable = TRUE;

  00288	e3a03001	 mov         r3, #1

; 3839 :                         RestoreRegisters( OMAP_DSS_DESTINATION_LCD );

  0028c	e3a01000	 mov         r1, #0
  00290	e1a00004	 mov         r0, r4
  00294	e58434c8	 str         r3, [r4, #0x4C8]
  00298	eb000000	 bl          |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 3840 :                         // Configure and enable the Hdmi Panel 
; 3841 :                         EnableHdmi( TRUE );

  0029c	e3a01001	 mov         r1, #1
  002a0	e1a00004	 mov         r0, r4
  002a4	eb000000	 bl          |?EnableHdmi@OMAPDisplayController@@QAAHH@Z|
  002a8		 |$LN13@SetPowerLe|

; 3842 :                     }
; 3843 :                 }
; 3844 :                 
; 3845 :                 //  Re-enable TV out if it was enabled prior to display power change
; 3846 :                 if( m_bTVEnable )

  002a8	e59434b4	 ldr         r3, [r4, #0x4B4]
  002ac	e3530000	 cmp         r3, #0
  002b0	0a00000b	 beq         |$LN11@SetPowerLe|

; 3847 :                 {
; 3848 :                     //  Enable the video encoder clock
; 3849 :                     RequestClock( m_dssinfo.TVEncoderDevice );

  002b4	e5940520	 ldr         r0, [r4, #0x520]
  002b8	e3a01001	 mov         r1, #1
  002bc	eb000000	 bl          EnableDeviceClocks

; 3850 : 
; 3851 :                     //  Restore the TV out registers
; 3852 :                     RestoreRegisters( OMAP_DSS_DESTINATION_TVOUT );

  002c0	e3a01001	 mov         r1, #1
  002c4	e1a00004	 mov         r0, r4
  002c8	eb000000	 bl          |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 3853 : 
; 3854 :                     //  Enable TV out if there is something to show
; 3855 :                 if( g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_TVOUT] > 0 )

  002cc	e5963004	 ldr         r3, [r6, #4]
  002d0	e3530000	 cmp         r3, #0

; 3856 :                         {
; 3857 :                       // enable interrupt for reporting SYNCLOST errors
; 3858 :                         //SETREG32( &m_pDispRegs->DISPC_IRQENABLE, DISPC_IRQENABLE_SYNCLOSTDIGITAL);
; 3859 :                         // enable the tvout path
; 3860 :                         SETREG32( &m_pDispRegs->DISPC_CONTROL, DISPC_CONTROL_DIGITALENABLE );

  002d4	15942008	 ldrne       r2, [r4, #8]
  002d8	15923040	 ldrne       r3, [r2, #0x40]
  002dc	13833002	 orrne       r3, r3, #2
  002e0	15823040	 strne       r3, [r2, #0x40]
  002e4		 |$LN11@SetPowerLe|

; 3861 :                 }
; 3862 :                     }
; 3863 :                 
; 3864 :                 //  Wait for VSYNC
; 3865 :                 dwTimeout = DISPLAY_TIMEOUT;
; 3866 :                 OUTREG32(&m_pDispRegs->DISPC_IRQSTATUS, DISPC_IRQSTATUS_VSYNC);

  002e4	e5943008	 ldr         r3, [r4, #8]
  002e8	e3a02002	 mov         r2, #2
  002ec	e3a0501e	 mov         r5, #0x1E
  002f0	e5832018	 str         r2, [r3, #0x18]

; 3867 :                 while (((INREG32(&m_pDispRegs->DISPC_IRQSTATUS) & DISPC_IRQSTATUS_VSYNC) == 0) && (dwTimeout-- > 0))

  002f4	ea000004	 b           |$LN56@SetPowerLe|
  002f8		 |$LL10@SetPowerLe|
  002f8	e3550000	 cmp         r5, #0
  002fc	e2455001	 sub         r5, r5, #1
  00300	0a000005	 beq         |$LN53@SetPowerLe|

; 3868 :                 {
; 3869 :                     Sleep(1);

  00304	e3a00001	 mov         r0, #1
  00308	eb000000	 bl          Sleep
  0030c		 |$LN56@SetPowerLe|
  0030c	e5943008	 ldr         r3, [r4, #8]
  00310	e5933018	 ldr         r3, [r3, #0x18]
  00314	e3130002	 tst         r3, #2
  00318	0afffff6	 beq         |$LL10@SetPowerLe|
  0031c		 |$LN53@SetPowerLe|

; 3870 :                 }
; 3871 : 
; 3872 :                 //  Clear all DSS interrupts
; 3873 :                 OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, 0xFFFFFFFF );

  0031c	e5943008	 ldr         r3, [r4, #8]
  00320	e3e02000	 mvn         r2, #0
  00324	e5832018	 str         r2, [r3, #0x18]
  00328		 |$cleanUp$39310|

; 3951 : 			}	
; 3952 :             
; 3953 :             //  Set the new power level
; 3954 :             m_dwPowerLevel = dwPowerLevel;
; 3955 : 
; 3956 :             break;            
; 3957 :     }
; 3958 : 
; 3959 : cleanUp:    
; 3960 :     //  Unlock access to power level
; 3961 :     LeaveCriticalSection( &m_csPowerLock );

  00328	e288008c	 add         r0, r8, #0x8C
  0032c	eb000000	 bl          LeaveCriticalSection

; 3962 :                 
; 3963 :     //  Return result
; 3964 :     return bResult;

  00330	e3a00001	 mov         r0, #1

; 3965 : }

  00334	e28dd004	 add         sp, sp, #4
  00338	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0033c	e12fff1e	 bx          lr
  00340		 |$LN60@SetPowerLe|
  00340		 |$LN61@SetPowerLe|
  00340	00000000	 DCD         |?g_dwDestinationRefCnt@@3PAKA|
  00344		 |$M42198|

			 ENDP  ; |?SetPowerLevel@OMAPDisplayController@@QAAHK@Z|, OMAPDisplayController::SetPowerLevel

	EXPORT	|?InitController@OMAPDisplayController@@QAAHHHH@Z| ; OMAPDisplayController::InitController
	EXPORT	|??_C@_1BI@GKABGADH@?$AAS?$AAM?$AAA?$AAR?$AAT?$AAR?$AAE?$AAF?$AAL?$AAE?$AAX?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1KC@HIABDGPO@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IO@PPJICGNB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAM?$AAA?$AAP?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?3?$AAI?$AAn@| [ DATA ] ; `string'
	IMPORT	|PmxOpenPolicy|
	IMPORT	|RequestDevicePads|
	IMPORT	|InitializeCriticalSection|
	IMPORT	|AllocPhysMem|
	IMPORT	|MmMapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T42228| DCD	|$LN24@InitContro|
	DCD	0x40007702

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@GKABGADH@?$AAS?$AAM?$AAA?$AAR?$AAT?$AAR?$AAE?$AAF?$AAL?$AAE?$AAX?$AA?$AA@| DCB "S"
	DCB	0x0, "M", 0x0, "A", 0x0, "R", 0x0, "T", 0x0, "R", 0x0, "E"
	DCB	0x0, "F", 0x0, "L", 0x0, "E", 0x0, "X", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KC@HIABDGPO@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "D", 0x0, "S"
	DCB	0x0, "S", 0x0, "\\", 0x0, "D", 0x0, "S", 0x0, "S", 0x0, "A"
	DCB	0x0, "I", 0x0, "\\", 0x0, ".", 0x0, "\\", 0x0, "d", 0x0, "s"
	DCB	0x0, "s", 0x0, "a", 0x0, "i", 0x0, ".", 0x0, "c", 0x0, "p"
	DCB	0x0, "p", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IO@PPJICGNB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAM?$AAA?$AAP?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?3?$AAI?$AAn@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "M", 0x0, "A", 0x0, "P", 0x0, "D", 0x0, "i"
	DCB	0x0, "s", 0x0, "p", 0x0, "l", 0x0, "a", 0x0, "y", 0x0, "C"
	DCB	0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o", 0x0, "l"
	DCB	0x0, "l", 0x0, "e", 0x0, "r", 0x0, ":", 0x0, ":", 0x0, "I"
	DCB	0x0, "n", 0x0, "i", 0x0, "t", 0x0, "C", 0x0, "o", 0x0, "n"
	DCB	0x0, "t", 0x0, "r", 0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e"
	DCB	0x0, "r", 0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q", 0x0, "u", 0x0, "e"
	DCB	0x0, "s", 0x0, "t", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "d"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitController@OMAPDisplayController@@QAAHHHH@Z| PROC ; OMAPDisplayController::InitController

; 196  : {

  00000		 |$LN24@InitContro|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M42225|
  00008	e1a07003	 mov         r7, r3
  0000c	e1a06002	 mov         r6, r2
  00010	e1a05001	 mov         r5, r1
  00014	e1a04000	 mov         r4, r0

; 197  :     BOOL    bResult = FALSE;
; 198  :     PHYSICAL_ADDRESS pa;
; 199  :     DWORD size;
; 200  : 
; 201  :     //
; 202  :     //  Map display controller registers
; 203  :     //
; 204  :     pa.QuadPart = m_dssinfo.DSS1_REGS_PA;

  00018	e5940524	 ldr         r0, [r4, #0x524]
  0001c	e3a01000	 mov         r1, #0

; 205  :     size = DSS_REGS_SIZE;
; 206  :     m_pDSSRegs = (OMAP_DSS_REGS*)MmMapIoSpace(pa, size, FALSE);

  00020	e3a03000	 mov         r3, #0
  00024	e3a02b01	 mov         r2, #1, 22
  00028	e3a08000	 mov         r8, #0
  0002c	eb000000	 bl          MmMapIoSpace
  00030	e3500000	 cmp         r0, #0
  00034	e5840004	 str         r0, [r4, #4]

; 207  :     if (m_pDSSRegs == NULL)

  00038	0a00005f	 beq         |$cleanUp$37840|

; 208  :         {
; 209  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::InitController: "
; 210  :              L"Failed map DSS control registers\r\n"
; 211  :             ));
; 212  :         goto cleanUp;
; 213  :         }
; 214  : 
; 215  :     pa.QuadPart = m_dssinfo.DISC1_REGS_PA;

  0003c	e5940528	 ldr         r0, [r4, #0x528]
  00040	e3a01000	 mov         r1, #0

; 216  :     size = DSS_REGS_SIZE;
; 217  :     m_pDispRegs = (OMAP_DISPC_REGS*)MmMapIoSpace(pa, size, FALSE);

  00044	e3a03000	 mov         r3, #0
  00048	e3a02b01	 mov         r2, #1, 22
  0004c	eb000000	 bl          MmMapIoSpace
  00050	e3500000	 cmp         r0, #0
  00054	e5840008	 str         r0, [r4, #8]

; 218  :     if (m_pDispRegs == NULL)

  00058	0a000057	 beq         |$cleanUp$37840|

; 219  :         {
; 220  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::InitController: "
; 221  :              L"Failed map DISPC control registers\r\n"
; 222  :             ));
; 223  :         goto cleanUp;
; 224  :         }
; 225  : 
; 226  :     pa.QuadPart = m_dssinfo.VENC1_REGS_PA;

  0005c	e594052c	 ldr         r0, [r4, #0x52C]
  00060	e3a01000	 mov         r1, #0

; 227  :     size = DSS_REGS_SIZE;
; 228  :     m_pVencRegs = (OMAP_VENC_REGS*)MmMapIoSpace(pa, size, FALSE);

  00064	e3a03000	 mov         r3, #0
  00068	e3a02b01	 mov         r2, #1, 22
  0006c	eb000000	 bl          MmMapIoSpace
  00070	e3500000	 cmp         r0, #0
  00074	e584000c	 str         r0, [r4, #0xC]

; 229  :     if (m_pVencRegs == NULL)

  00078	0a00004f	 beq         |$cleanUp$37840|

; 230  :         {
; 231  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::InitController: "
; 232  :              L"Failed map VENC control registers\r\n"
; 233  :             ));
; 234  :         goto cleanUp;
; 235  :         }
; 236  : 
; 237  :     // Disable gamma correction based on registry
; 238  :     if(!bEnableGammaCorr)

  0007c	e3a0a000	 mov         r10, #0
  00080	e3550000	 cmp         r5, #0

; 239  :         m_bGammaEnable = FALSE;

  00084	0584a4dc	 streq       r10, [r4, #0x4DC]

; 240  : 
; 241  :     // Enable VSYNC code based on registry
; 242  :     if (bEnableWaitForVerticalBlank)
; 243  :     	m_dwEnableWaitForVerticalBlank = TRUE;
; 244  : 
; 245  :     //enable ISP resizer based on registry
; 246  :     if (bEnableISPResizer)
; 247  :         m_bDssIspRszEnabled = TRUE;
; 248  :     
; 249  : 
; 250  :     //  Allocate physical memory for gamma table buffer
; 251  :     m_pGammaBufVirt = (DWORD*)AllocPhysMem(NUM_GAMMA_VALS*sizeof(DWORD), PAGE_READWRITE | PAGE_NOCACHE, 0, 0,&m_dwGammaBufPhys);

  00088	e2843b01	 add         r3, r4, #1, 22
  0008c	e3560000	 cmp         r6, #0
  00090	e3a09001	 mov         r9, #1
  00094	e28330d8	 add         r3, r3, #0xD8
  00098	15849500	 strne       r9, [r4, #0x500]
  0009c	e3570000	 cmp         r7, #0
  000a0	e58d3000	 str         r3, [sp]
  000a4	e3a03000	 mov         r3, #0
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01f81	 mov         r1, #0x81, 30
  000b0	e3a00b01	 mov         r0, #1, 22
  000b4	15849514	 strne       r9, [r4, #0x514]
  000b8	eb000000	 bl          AllocPhysMem
  000bc	e3500000	 cmp         r0, #0
  000c0	e58404d4	 str         r0, [r4, #0x4D4]

; 252  :     if( m_pGammaBufVirt == NULL)

  000c4	0a00003c	 beq         |$cleanUp$37840|

; 253  :         {
; 254  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: COMAPDisplayController::InitController: "
; 255  :             L"Failed allocate Gamma phys buffer\r\n"
; 256  :             ));
; 257  :         goto cleanUp;
; 258  :         }
; 259  : 
; 260  :     // map DSI regs
; 261  :     pa.QuadPart = m_dssinfo.DSI_REGS_PA;

  000c8	e5940530	 ldr         r0, [r4, #0x530]
  000cc	e3a01000	 mov         r1, #0

; 262  :     size = sizeof(OMAP_DSI_REGS);
; 263  :     m_pDSIRegs = (OMAP_DSI_REGS*)MmMapIoSpace(pa, size, FALSE);

  000d0	e3a03000	 mov         r3, #0
  000d4	e3a020c0	 mov         r2, #0xC0
  000d8	eb000000	 bl          MmMapIoSpace
  000dc	e3500000	 cmp         r0, #0
  000e0	e5840010	 str         r0, [r4, #0x10]

; 264  :     if (m_pDSIRegs == NULL)

  000e4	0a000034	 beq         |$cleanUp$37840|

; 265  :         {
; 266  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::InitController: "
; 267  :                  L"Failed map DSI control registers\r\n"
; 268  :                 ));
; 269  :         goto cleanUp;
; 270  :         }
; 271  : 
; 272  :     // map DSI Pll regs
; 273  :     pa.QuadPart = m_dssinfo.DSI_PLL_REGS_PA;

  000e8	e5940534	 ldr         r0, [r4, #0x534]
  000ec	e3a01000	 mov         r1, #0

; 274  :     size = sizeof(OMAP_DSI_PLL_REGS);
; 275  :     m_pDSIPLLRegs = (OMAP_DSI_PLL_REGS*)MmMapIoSpace(pa, size, FALSE);

  000f0	e3a03000	 mov         r3, #0
  000f4	e3a02014	 mov         r2, #0x14
  000f8	eb000000	 bl          MmMapIoSpace
  000fc	e3500000	 cmp         r0, #0
  00100	e5840014	 str         r0, [r4, #0x14]

; 276  :     if (m_pDSIPLLRegs == NULL)

  00104	0a00002c	 beq         |$cleanUp$37840|

; 277  :         {
; 278  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OMAPDisplayController::InitController: "
; 279  :                      L"Failed map DSIPLL control registers\r\n"
; 280  :                     ));
; 281  :         goto cleanUp;
; 282  :         }
; 283  : 
; 284  :     //  Initialize power lock critical section
; 285  :     InitializeCriticalSection( &m_csPowerLock );

  00108	e2845b01	 add         r5, r4, #1, 22
  0010c	e285008c	 add         r0, r5, #0x8C
  00110	eb000000	 bl          InitializeCriticalSection

; 286  : 
; 287  :     //  Lock access to power level
; 288  :     EnterCriticalSection( &m_csPowerLock );

  00114	e285008c	 add         r0, r5, #0x8C
  00118	eb000000	 bl          EnterCriticalSection

; 289  : 
; 290  :     // Configure the DssFclk source and value
; 291  :     m_eDssFclkSource = OMAP_DSS_FCLK_DSS2ALWON;
; 292  :     m_eDssFclkValue  = OMAP_DSS_FCLKVALUE_NORMAL;
; 293  : 
; 294  : 	// Request Pads for LCD
; 295  : 	if (!RequestDevicePads(m_dssinfo.DSSDevice))

  0011c	e594051c	 ldr         r0, [r4, #0x51C]
  00120	e3a03529	 mov         r3, #0x29, 10
  00124	e3833c83	 orr         r3, r3, #0x83, 24
  00128	e584350c	 str         r3, [r4, #0x50C]
  0012c	e5849508	 str         r9, [r4, #0x508]
  00130	eb000000	 bl          RequestDevicePads
  00134	e3500000	 cmp         r0, #0
  00138	1a000007	 bne         |$LN2@InitContro|

; 296  : 	{
; 297  :         ERRORMSG(TRUE, (L"ERROR: OMAPDisplayController::InitController: "
; 298  :                      L"Failed to request pads\r\n"
; 299  :                     ));

  0013c	e59f1094	 ldr         r1, [pc, #0x94]
  00140	e59f008c	 ldr         r0, [pc, #0x8C]
  00144	e3a03c01	 mov         r3, #1, 24
  00148	e383202b	 orr         r2, r3, #0x2B
  0014c	eb000000	 bl          NKDbgPrintfW
  00150	e59f0078	 ldr         r0, [pc, #0x78]
  00154	eb000000	 bl          NKDbgPrintfW

; 338  : 
; 339  : cleanUp:    

  00158	ea000017	 b           |$cleanUp$37840|
  0015c		 |$LN2@InitContro|

; 300  :         goto cleanUp;
; 301  : 	}
; 302  : 
; 303  :     //  Reset the DSS controller
; 304  :     ResetDSS();

  0015c	e1a00004	 mov         r0, r4
  00160	eb000000	 bl          |?ResetDSS@OMAPDisplayController@@IAAHXZ|

; 305  : 
; 306  :     //  Enable controller power
; 307  :     SetPowerLevel( D0 );

  00164	e3a01000	 mov         r1, #0
  00168	e1a00004	 mov         r0, r4
  0016c	eb000000	 bl          |?SetPowerLevel@OMAPDisplayController@@QAAHK@Z|

; 308  : 
; 309  :     //  Configure the clock source
; 310  :     //
; 311  :     //  DSS1_ALWON = 172MHz
; 312  :     //  DSI1_PLL   = 148.5MHz
; 313  :     //
; 314  :     OUTREG32( &m_pDSSRegs->DSS_CONTROL, 
; 315  :                 DSS_CONTROL_DISPC_CLK_SWITCH_DSS1_ALWON |
; 316  :                 DSS_CONTROL_DSI_CLK_SWITCH_DSS1_ALWON
; 317  :                 );

  00170	e5943004	 ldr         r3, [r4, #4]
  00174	e3a02a01	 mov         r2, #1, 20

; 318  : 
; 319  :                 
; 320  :     //  Configure interconnect parameters
; 321  :     OUTREG32( &m_pDSSRegs->DSS_SYSCONFIG, DISPC_SYSCONFIG_AUTOIDLE );
; 322  :     OUTREG32( &m_pDispRegs->DISPC_SYSCONFIG, DISPC_SYSCONFIG_AUTOIDLE|SYSCONFIG_NOIDLE|SYSCONFIG_NOSTANDBY );

  00178	e3822009	 orr         r2, r2, #9
  0017c	e583a040	 str         r10, [r3, #0x40]
  00180	e5943004	 ldr         r3, [r4, #4]

; 323  : 
; 324  : 
; 325  :     //  Enable DSS fault notification interrupts
; 326  :     g_rgDisplaySaveRestore.DISPC_IRQENABLE = DISPC_IRQENABLE_OCPERROR|
; 327  :                                              DISPC_IRQENABLE_SYNCLOST;

  00184	e3a01c42	 mov         r1, #0x42, 24

; 328  :     OUTREG32( &m_pDispRegs->DISPC_IRQENABLE , g_rgDisplaySaveRestore.DISPC_IRQENABLE);
; 329  : 
; 330  :     //  Unlock access to power level
; 331  :     LeaveCriticalSection( &m_csPowerLock );

  00188	e285008c	 add         r0, r5, #0x8C
  0018c	e5839010	 str         r9, [r3, #0x10]
  00190	e5943008	 ldr         r3, [r4, #8]
  00194	e5832010	 str         r2, [r3, #0x10]
  00198	e5942008	 ldr         r2, [r4, #8]
  0019c	e5841034	 str         r1, [r4, #0x34]
  001a0	e5943034	 ldr         r3, [r4, #0x34]
  001a4	e582301c	 str         r3, [r2, #0x1C]
  001a8	eb000000	 bl          LeaveCriticalSection

; 332  :         
; 333  :     // Open a handle to SmartReflex policy adapter
; 334  :     m_hSmartReflexPolicyAdapter = PmxOpenPolicy(SMARTREFLEX_POLICY_NAME);

  001ac	e59f0018	 ldr         r0, [pc, #0x18]
  001b0	eb000000	 bl          PmxOpenPolicy
  001b4	e5840518	 str         r0, [r4, #0x518]

; 335  :         
; 336  :     //  Success
; 337  :     bResult = TRUE;

  001b8	e3a08001	 mov         r8, #1
  001bc		 |$cleanUp$37840|

; 340  :     //  Return result
; 341  :     return bResult;
; 342  : }

  001bc	e1a00008	 mov         r0, r8
  001c0	e28dd004	 add         sp, sp, #4
  001c4	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  001c8	e12fff1e	 bx          lr
  001cc		 |$LN25@InitContro|
  001cc		 |$LN26@InitContro|
  001cc	00000000	 DCD         |??_C@_1BI@GKABGADH@?$AAS?$AAM?$AAA?$AAR?$AAT?$AAR?$AAE?$AAF?$AAL?$AAE?$AAX?$AA?$AA@|
  001d0		 |$LN27@InitContro|
  001d0	00000000	 DCD         |??_C@_1IO@PPJICGNB@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAM?$AAA?$AAP?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?3?$AAI?$AAn@|
  001d4		 |$LN28@InitContro|
  001d4	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  001d8		 |$LN29@InitContro|
  001d8	00000000	 DCD         |??_C@_1KC@HIABDGPO@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  001dc		 |$M42226|

			 ENDP  ; |?InitController@OMAPDisplayController@@QAAHHHH@Z|, OMAPDisplayController::InitController

	EXPORT	|?InitLCD@OMAPDisplayController@@QAAHXZ| ; OMAPDisplayController::InitLCD

  00000			 AREA	 |.pdata|, PDATA
|$T42245| DCD	|$LN8@InitLCD|
	DCD	0x40003b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitLCD@OMAPDisplayController@@QAAHXZ| PROC ; OMAPDisplayController::InitLCD

; 347  : {

  00000		 |$LN8@InitLCD|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M42242|
  00004	e1a04000	 mov         r4, r0

; 348  :     BOOL    bResult;
; 349  : 
; 350  :     //  Lock access to power level
; 351  :     EnterCriticalSection( &m_csPowerLock );

  00008	e2845b01	 add         r5, r4, #1, 22
  0000c	e285008c	 add         r0, r5, #0x8C
  00010	eb000000	 bl          EnterCriticalSection

; 352  : 
; 353  :     //  Enable controller power
; 354  :     SetPowerLevel( D0 );

  00014	e3a01000	 mov         r1, #0
  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          |?SetPowerLevel@OMAPDisplayController@@QAAHK@Z|

; 355  : 
; 356  :     //  Initialize the LCD by calling PDD
; 357  :     bResult = LcdPdd_LCD_Initialize(
; 358  :                     m_pDSSRegs,
; 359  :                     m_pDispRegs,
; 360  :                     NULL,
; 361  :                     m_pVencRegs);

  00020	e594300c	 ldr         r3, [r4, #0xC]
  00024	e5941008	 ldr         r1, [r4, #8]
  00028	e5940004	 ldr         r0, [r4, #4]
  0002c	e3a02000	 mov         r2, #0
  00030	eb000000	 bl          LcdPdd_LCD_Initialize

; 362  :     
; 363  :     //  Get LCD parameters
; 364  :     LcdPdd_LCD_GetMode(
; 365  :                     (DWORD*) &m_eLcdPixelFormat,
; 366  :                     &m_dwLcdWidth,
; 367  :                     &m_dwLcdHeight,
; 368  :                     &m_dwPixelClock
; 369  :                     );

  00034	e2843b01	 add         r3, r4, #1, 22
  00038	e284eb01	 add         lr, r4, #1, 22
  0003c	e2841b01	 add         r1, r4, #1, 22
  00040	e28320ac	 add         r2, r3, #0xAC
  00044	e1a06000	 mov         r6, r0
  00048	e28e00a4	 add         r0, lr, #0xA4
  0004c	e2843e4b	 add         r3, r4, #0x4B, 28
  00050	e28110a8	 add         r1, r1, #0xA8
  00054	eb000000	 bl          LcdPdd_LCD_GetMode

; 370  : 
; 371  :     //  Set up gamma correction to support contrast control
; 372  :     SetContrastLevel( m_dwContrastLevel );

  00058	e59414d0	 ldr         r1, [r4, #0x4D0]
  0005c	e1a00004	 mov         r0, r4
  00060	eb000000	 bl          |?SetContrastLevel@OMAPDisplayController@@QAAHK@Z|

; 373  :     
; 374  :     // Enable/Disable Gamma correction
; 375  :     if(m_bGammaEnable)

  00064	e59434dc	 ldr         r3, [r4, #0x4DC]

; 376  :     {
; 377  :         SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_PALETTEGAMMATABLE );

  00068	e5942008	 ldr         r2, [r4, #8]

; 378  :         SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_LOADMODE(0) );
; 379  :     }
; 380  :     else
; 381  :     {
; 382  :         CLRREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_PALETTEGAMMATABLE );
; 383  :         SETREG32( &m_pDispRegs->DISPC_CONFIG, DISPC_CONFIG_LOADMODE(2) );
; 384  :     }
; 385  : 
; 386  :     // Load Gamma Table
; 387  :     OUTREG32( &m_pDispRegs->DISPC_GFX_TABLE_BA, m_dwGammaBufPhys);

  0006c	e3a018ff	 mov         r1, #0xFF, 16
  00070	e3530000	 cmp         r3, #0
  00074	e5923044	 ldr         r3, [r2, #0x44]

; 388  :     
; 389  : 
; 390  :     //  Set default global alpha values to be opaque
; 391  :     OUTREG32( &m_pDispRegs->DISPC_GLOBAL_ALPHA, DISPC_GLOBAL_ALPHA_GFX(0xFF)|DISPC_GLOBAL_ALPHA_VID2(0xFF) );
; 392  :     
; 393  :     // Could calculate actual period...
; 394  :     m_dwVsyncPeriod = 1000/60 + 2;//Add delta 2 ms since frameRate is not exactly 60fps
; 395  : 
; 396  :     // Initialize the DSI PLL
; 397  :     InitDsiPll();

  00078	e1a00004	 mov         r0, r4
  0007c	13833008	 orrne       r3, r3, #8
  00080	15823044	 strne       r3, [r2, #0x44]
  00084	15942008	 ldrne       r2, [r4, #8]
  00088	15923044	 ldrne       r3, [r2, #0x44]
  0008c	03c33008	 biceq       r3, r3, #8
  00090	05823044	 streq       r3, [r2, #0x44]
  00094	05942008	 ldreq       r2, [r4, #8]
  00098	05923044	 ldreq       r3, [r2, #0x44]
  0009c	03833004	 orreq       r3, r3, #4
  000a0	e5823044	 str         r3, [r2, #0x44]
  000a4	e5942008	 ldr         r2, [r4, #8]
  000a8	e59434d8	 ldr         r3, [r4, #0x4D8]
  000ac	e58230b8	 str         r3, [r2, #0xB8]
  000b0	e5942008	 ldr         r2, [r4, #8]
  000b4	e38130ff	 orr         r3, r1, #0xFF
  000b8	e3a01012	 mov         r1, #0x12
  000bc	e5823074	 str         r3, [r2, #0x74]
  000c0	e58414fc	 str         r1, [r4, #0x4FC]
  000c4	eb000000	 bl          |?InitDsiPll@OMAPDisplayController@@IAAHXZ|
  000c8	e3a03529	 mov         r3, #0x29, 10

; 398  : 
; 399  :     // Configure the DSI PLL with the FCLK value reqd
; 400  :     ConfigureDsiPll( OMAP_DSS_FCLKVALUE_NORMAL );

  000cc	e3831c83	 orr         r1, r3, #0x83, 24
  000d0	e1a00004	 mov         r0, r4
  000d4	eb000000	 bl          |?ConfigureDsiPll@OMAPDisplayController@@QAAHK@Z|

; 401  :     
; 402  :     //  Unlock access to power level
; 403  :     LeaveCriticalSection( &m_csPowerLock );

  000d8	e285008c	 add         r0, r5, #0x8C
  000dc	eb000000	 bl          LeaveCriticalSection

; 404  : 
; 405  :     //  Return result
; 406  :     return bResult;
; 407  : }

  000e0	e1a00006	 mov         r0, r6
  000e4	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000e8	e12fff1e	 bx          lr
  000ec		 |$M42243|

			 ENDP  ; |?InitLCD@OMAPDisplayController@@QAAHXZ|, OMAPDisplayController::InitLCD

	EXPORT	|?DssProcessInterrupt@OMAPDisplayController@@QAAXXZ| ; OMAPDisplayController::DssProcessInterrupt

  00000			 AREA	 |.pdata|, PDATA
|$T42286| DCD	|$LN46@DssProcess|
	DCD	0x40008f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?DssProcessInterrupt@OMAPDisplayController@@QAAXXZ| PROC ; OMAPDisplayController::DssProcessInterrupt

; 574  : {

  00000		 |$LN46@DssProcess|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M42283|
  00004	e1a04000	 mov         r4, r0

; 575  :     DWORD irqStatus = 0;
; 576  :     DWORD dwTimeout = DISPLAY_TIMEOUT;
; 577  :     OMAP_DSS_PIPELINE pipelineID = OMAP_DSS_PIPELINE_GFX;
; 578  :     BOOL  lcdVsync = FALSE;
; 579  :     //Alwasy set to true, in case tv-out is disabled.
; 580  :     BOOL  tvVsync = TRUE;
; 581  :     DWORD irqEnableMask = 0;
; 582  : 
; 583  :     // Access the regs
; 584  :     if( AccessRegs() == FALSE )

  00008	e3a0601e	 mov         r6, #0x1E
  0000c	e3a07001	 mov         r7, #1
  00010	eb000000	 bl          |?AccessRegs@OMAPDisplayController@@IAAHXZ|
  00014	e3500000	 cmp         r0, #0
  00018	0a000081	 beq         |$cleanUp$37967|

; 585  :     {
; 586  :         // failure will cause lockup because the interrupt will still be pending...
; 587  :         DEBUGMSG(ZONE_ERROR,(L"AccessRegs failed in DssProcessInterrupt\r\n"));
; 588  :         ASSERT(0);
; 589  :         goto cleanUp;
; 590  :     }
; 591  :     irqEnableMask = INREG32(&m_pDispRegs->DISPC_IRQENABLE);

  0001c	e5940008	 ldr         r0, [r4, #8]

; 592  :     irqStatus = (INREG32(&m_pDispRegs->DISPC_IRQSTATUS) & irqEnableMask);
; 593  :     /* Check if we should worry about Vsync or not */
; 594  :     m_lastVsyncIRQStatus &= irqEnableMask;

  00020	e5942538	 ldr         r2, [r4, #0x538]
  00024	e590101c	 ldr         r1, [r0, #0x1C]
  00028	e5903018	 ldr         r3, [r0, #0x18]
  0002c	e0022001	 and         r2, r2, r1
  00030	e0035001	 and         r5, r3, r1

; 595  :     
; 596  :     //  Enabling Interrupt for SYNCLOSTDIGITAL causes tvout to not recover 
; 597  :     //  from a suspend/resume cycle. Hence disabled. SYNCLOSTDIGITAL is not
; 598  :     //  causing any issue with functionality of tvout.
; 599  :     
; 600  : /*    if (irqStatus & (DISPC_IRQSTATUS_SYNCLOST|
; 601  :                      DISPC_IRQSTATUS_SYNCLOSTDIGITAL))*/
; 602  :     if (irqStatus & (DISPC_IRQSTATUS_SYNCLOST))                         

  00034	e3150901	 tst         r5, #1, 18
  00038	e5842538	 str         r2, [r4, #0x538]
  0003c	0a00004e	 beq         |$LN19@DssProcess|

; 603  :     {
; 604  :         DEBUGMSG(ZONE_ERROR,(L"SYNCLOST DSSIRQ:%x\r\n",irqStatus));
; 605  : 
; 606  :         // SYNCLOST recovery process
; 607  : 
; 608  :         // clear existing Frame done interrupt
; 609  :         OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS,DISPC_IRQSTATUS_FRAMEDONE );

  00040	e3a03001	 mov         r3, #1
  00044	e5803018	 str         r3, [r0, #0x18]

; 610  : 
; 611  :         // disable scanning
; 612  :         CLRREG32( &m_pDispRegs->DISPC_CONTROL,
; 613  :                   DISPC_CONTROL_DIGITALENABLE |
; 614  :                   DISPC_CONTROL_LCDENABLE
; 615  :                   );

  00048	e5942008	 ldr         r2, [r4, #8]
  0004c	e5923040	 ldr         r3, [r2, #0x40]
  00050	e3c33003	 bic         r3, r3, #3
  00054	e5823040	 str         r3, [r2, #0x40]

; 616  : 
; 617  :         // Wait for the frame done
; 618  :         while (((INREG32(&m_pDispRegs->DISPC_IRQSTATUS) &
; 619  :                  DISPC_IRQSTATUS_FRAMEDONE) == 0) &&
; 620  :                  (dwTimeout-- > 0)
; 621  :                  )

  00058	ea000004	 b           |$LN42@DssProcess|
  0005c		 |$LL18@DssProcess|
  0005c	e3560000	 cmp         r6, #0
  00060	e2466001	 sub         r6, r6, #1
  00064	0a000005	 beq         |$LN40@DssProcess|

; 622  :         {
; 623  :             Sleep(1);

  00068	e3a00001	 mov         r0, #1
  0006c	eb000000	 bl          Sleep
  00070		 |$LN42@DssProcess|
  00070	e5943008	 ldr         r3, [r4, #8]
  00074	e5933018	 ldr         r3, [r3, #0x18]
  00078	e3130001	 tst         r3, #1
  0007c	0afffff6	 beq         |$LL18@DssProcess|
  00080		 |$LN40@DssProcess|

; 624  :         }
; 625  : 
; 626  :         //  Clear all DSS interrupts
; 627  :         OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, 0xFFFFFFFF );

  00080	e5943008	 ldr         r3, [r4, #8]
  00084	e3e06000	 mvn         r6, #0

; 628  : 
; 629  :         // Set the power level to D4(OFF)
; 630  :         SetPowerLevel(D4);

  00088	e3a01004	 mov         r1, #4
  0008c	e1a00004	 mov         r0, r4
  00090	e5836018	 str         r6, [r3, #0x18]
  00094	eb000000	 bl          |?SetPowerLevel@OMAPDisplayController@@QAAHK@Z|

; 631  : 
; 632  :         // Issue a reset cmd to DSS to recover from failure
; 633  :         ResetDSS();

  00098	e1a00004	 mov         r0, r4
  0009c	eb000000	 bl          |?ResetDSS@OMAPDisplayController@@IAAHXZ|

; 634  : 
; 635  :         //  Enable controller power
; 636  :         SetPowerLevel( D0 );

  000a0	e3a01000	 mov         r1, #0
  000a4	e1a00004	 mov         r0, r4
  000a8	eb000000	 bl          |?SetPowerLevel@OMAPDisplayController@@QAAHK@Z|

; 637  : 
; 638  :         // Initialize the LCD panel related parameters
; 639  :         InitLCD();

  000ac	e1a00004	 mov         r0, r4
  000b0	eb000000	 bl          |?InitLCD@OMAPDisplayController@@QAAHXZ|

; 640  : 
; 641  :         // Clear all the interrupts status
; 642  :         OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, 0xFFFFFFFF );

  000b4	e5943008	 ldr         r3, [r4, #8]

; 643  : 
; 644  :         // Could change to reset the pipeline status to inactive state...
; 645  :         if (g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_LCD] > 0)

  000b8	e59f5178	 ldr         r5, [pc, #0x178]
  000bc	e5836018	 str         r6, [r3, #0x18]
  000c0	e5953060	 ldr         r3, [r5, #0x60]
  000c4	e3530000	 cmp         r3, #0

; 646  :         {
; 647  :             RestoreRegisters(OMAP_DSS_DESTINATION_LCD);

  000c8	13a01000	 movne       r1, #0
  000cc	11a00004	 movne       r0, r4
  000d0	1b000000	 blne        |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 648  :         }
; 649  : 
; 650  :         if (m_bTVEnable)

  000d4	e59434b4	 ldr         r3, [r4, #0x4B4]
  000d8	e3530000	 cmp         r3, #0

; 651  :         {
; 652  :             RestoreRegisters(OMAP_DSS_DESTINATION_TVOUT);

  000dc	13a01001	 movne       r1, #1
  000e0	11a00004	 movne       r0, r4
  000e4	1b000000	 blne        |?RestoreRegisters@OMAPDisplayController@@QAAHW4OMAP_DSS_DESTINATION@@@Z|

; 653  :         }
; 654  : 
; 655  :         //  Clear refcounts on pipelines
; 656  :         g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_LCD] = 0;
; 657  :         g_dwDestinationRefCnt[OMAP_DSS_DESTINATION_TVOUT] = 0;
; 658  :         
; 659  :         //EnablePipeline function to turn the active pipelines
; 660  :         if ((g_rgPipelineMapping[OMAP_DSS_PIPELINE_GFX].bEnabled)||
; 661  :             (g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO1].bEnabled) ||
; 662  :             (g_rgPipelineMapping[OMAP_DSS_PIPELINE_VIDEO2].bEnabled)
; 663  :             )

  000e8	e5953000	 ldr         r3, [r5]
  000ec	e3a02000	 mov         r2, #0
  000f0	e3a01000	 mov         r1, #0
  000f4	e5852060	 str         r2, [r5, #0x60]
  000f8	e3530000	 cmp         r3, #0
  000fc	e5851064	 str         r1, [r5, #0x64]
  00100	1a000005	 bne         |$LN13@DssProcess|
  00104	e5953020	 ldr         r3, [r5, #0x20]
  00108	e3530000	 cmp         r3, #0
  0010c	1a000002	 bne         |$LN13@DssProcess|
  00110	e5953040	 ldr         r3, [r5, #0x40]
  00114	e3530000	 cmp         r3, #0
  00118	0a000041	 beq         |$cleanUp$37967|
  0011c		 |$LN13@DssProcess|

; 664  :         {
; 665  : 
; 666  :             for ( DWORD i = 0;

  0011c	e3a06000	 mov         r6, #0
  00120	e3a07000	 mov         r7, #0
  00124		 |$LL12@DssProcess|

; 667  :                   i < OMAP_DSS_PIPELINE_MAX;
; 668  :                   i++)
; 669  :             {
; 670  :                 pipelineID = (OMAP_DSS_PIPELINE)i;
; 671  :                 if (g_rgPipelineMapping[pipelineID].bEnabled == TRUE)

  00124	e5953000	 ldr         r3, [r5]
  00128	e3530001	 cmp         r3, #1

; 672  :                     {
; 673  :                     g_rgPipelineMapping[pipelineID].bEnabled = FALSE;
; 674  :                     EnablePipeline(pipelineID);

  0012c	01a01006	 moveq       r1, r6
  00130	01a00004	 moveq       r0, r4
  00134	05857000	 streq       r7, [r5]
  00138	0b000000	 bleq        |?EnablePipeline@OMAPDisplayController@@QAAHW4OMAP_DSS_PIPELINE@@@Z|
  0013c	e2866001	 add         r6, r6, #1
  00140	e3560003	 cmp         r6, #3
  00144	e2855020	 add         r5, r5, #0x20
  00148	3afffff5	 bcc         |$LL12@DssProcess|

; 675  :                     }
; 676  :             }
; 677  : 
; 678  :             // Enable the LCD control bit
; 679  :             SETREG32( &m_pDispRegs->DISPC_CONTROL,
; 680  :                        DISPC_CONTROL_LCDENABLE );

  0014c	e5942008	 ldr         r2, [r4, #8]
  00150	e5923040	 ldr         r3, [r2, #0x40]
  00154	e3833001	 orr         r3, r3, #1
  00158	e5823040	 str         r3, [r2, #0x40]

; 681  : 
; 682  :             // Enable the TVOut control bit
; 683  :             if (m_bTVEnable)

  0015c	e59434b4	 ldr         r3, [r4, #0x4B4]
  00160	e3530000	 cmp         r3, #0
  00164	0a00002e	 beq         |$cleanUp$37967|

; 684  :             {
; 685  :                 SETREG32( &m_pDispRegs->DISPC_CONTROL,
; 686  :                            DISPC_CONTROL_DIGITALENABLE);

  00168	e5942008	 ldr         r2, [r4, #8]
  0016c	e5923040	 ldr         r3, [r2, #0x40]
  00170	e3833002	 orr         r3, r3, #2
  00174	e5823040	 str         r3, [r2, #0x40]

; 754  : 
; 755  : cleanUp:

  00178	ea000029	 b           |$cleanUp$37967|
  0017c		 |$LN19@DssProcess|

; 687  :             }
; 688  : 
; 689  :         }
; 690  : 
; 691  :         goto cleanUp;
; 692  :     }
; 693  : 
; 694  :     if (irqStatus & (DISPC_IRQSTATUS_GFXFIFOUNDERFLOW  |
; 695  :                      DISPC_IRQSTATUS_VID1FIFOUNDERFLOW |
; 696  :                      DISPC_IRQSTATUS_VID2FIFOUNDERFLOW
; 697  :                      ))
; 698  :     {
; 699  :          DEBUGMSG(ZONE_ERROR,(L"DSS pipeline underflow error.Intrstatus:%x\r\n",irqStatus));
; 700  :     }
; 701  : 
; 702  :     //Vsync event has to be asserted when both LCD and TV have actually vsync'ed (if tv-out is enabled).
; 703  :     //There's 3 scenarios:
; 704  :     //1. LCD v-sync occurs before TV v-sync.
; 705  :     //2. TV-out v-sync occurs before LCD v-sync. 
; 706  :     //3. Both occurred
; 707  :     //For case 3 then the check below will signal the v-sync event
; 708  :     //For case 1, the status bit's are saved. The next interrupt 
; 709  :     //occuring due to tv-out (or lcd for case 2) will happen and the check below will signal the vsync event.
; 710  :     //
; 711  :     //If tv-out is disabled, since tvVysnc is always true, then only the state of lcdVsync matters.
; 712  : 
; 713  :     
; 714  :     lcdVsync = ((irqStatus & DISPC_IRQSTATUS_VSYNC) == DISPC_IRQSTATUS_VSYNC) ||
; 715  :                    ((m_lastVsyncIRQStatus & DISPC_IRQSTATUS_VSYNC) == DISPC_IRQSTATUS_VSYNC);

  0017c	e2053002	 and         r3, r5, #2
  00180	e3530002	 cmp         r3, #2
  00184	12023002	 andne       r3, r2, #2
  00188	13530002	 cmpne       r3, #2

; 716  :        
; 717  :     if(m_bTVEnable == TRUE)

  0018c	e59434b4	 ldr         r3, [r4, #0x4B4]
  00190	13a01000	 movne       r1, #0
  00194	03a01001	 moveq       r1, #1
  00198	e3530001	 cmp         r3, #1
  0019c	1a00000c	 bne         |$LN27@DssProcess|

; 718  :     {
; 719  :        tvVsync = ((irqStatus & DISPC_IRQSTATUS_EVSYNC_EVEN) == DISPC_IRQSTATUS_EVSYNC_EVEN) ||
; 720  :                  ((irqStatus & DISPC_IRQSTATUS_EVSYNC_ODD) == DISPC_IRQSTATUS_EVSYNC_ODD) ||
; 721  :                  ((m_lastVsyncIRQStatus & DISPC_IRQSTATUS_EVSYNC_EVEN) == DISPC_IRQSTATUS_EVSYNC_EVEN) ||
; 722  :                  ((m_lastVsyncIRQStatus & DISPC_IRQSTATUS_EVSYNC_ODD) == DISPC_IRQSTATUS_EVSYNC_ODD);

  001a0	e2053004	 and         r3, r5, #4
  001a4	e3530004	 cmp         r3, #4
  001a8	0a000008	 beq         |$LN26@DssProcess|
  001ac	e2053008	 and         r3, r5, #8
  001b0	e3530008	 cmp         r3, #8
  001b4	0a000005	 beq         |$LN26@DssProcess|
  001b8	e2023004	 and         r3, r2, #4
  001bc	e3530004	 cmp         r3, #4
  001c0	12023008	 andne       r3, r2, #8
  001c4	13530008	 cmpne       r3, #8
  001c8	13a07000	 movne       r7, #0
  001cc	1a000000	 bne         |$LN27@DssProcess|
  001d0		 |$LN26@DssProcess|
  001d0	e3a07001	 mov         r7, #1
  001d4		 |$LN27@DssProcess|

; 723  :          
; 724  :     }
; 725  : 
; 726  :     if(lcdVsync && tvVsync) 

  001d4	e3510000	 cmp         r1, #0
  001d8	0a000009	 beq         |$LN4@DssProcess|
  001dc	e3570000	 cmp         r7, #0
  001e0	0a000007	 beq         |$LN4@DssProcess|

; 727  :     {        
; 728  :         SetEvent(m_hVsyncEvent);

  001e4	e59404f4	 ldr         r0, [r4, #0x4F4]
  001e8	e3a01003	 mov         r1, #3
  001ec	eb000000	 bl          EventModify

; 729  :         SetEvent(m_hVsyncEventSGX);    

  001f0	e59404f8	 ldr         r0, [r4, #0x4F8]
  001f4	e3a01003	 mov         r1, #3
  001f8	eb000000	 bl          EventModify

; 730  :         m_lastVsyncIRQStatus = 0;

  001fc	e3a03000	 mov         r3, #0

; 731  :     }
; 732  :     else

  00200	ea000000	 b           |$LN43@DssProcess|
  00204		 |$LN4@DssProcess|

; 733  :     {
; 734  :        //Save the status of the Vsync IRQ's if we didn't signal the Vsync event.         
; 735  :        // Note that if the interrupt status is not cleared we will be right back...        
; 736  :        m_lastVsyncIRQStatus = irqStatus & (DISPC_IRQENABLE_EVSYNC_EVEN|DISPC_IRQSTATUS_EVSYNC_ODD|DISPC_IRQSTATUS_VSYNC);

  00204	e205300e	 and         r3, r5, #0xE
  00208		 |$LN43@DssProcess|

; 737  :     }
; 738  :     
; 739  : 
; 740  :     if(irqStatus & DISPC_IRQSTATUS_PROGRAMMEDLINENUMBER)

  00208	e3150020	 tst         r5, #0x20

; 741  :     {
; 742  :         SetEvent(m_hScanLineEvent);

  0020c	15940504	 ldrne       r0, [r4, #0x504]
  00210	13a01003	 movne       r1, #3
  00214	e5843538	 str         r3, [r4, #0x538]
  00218	1b000000	 blne        EventModify

; 743  :     }
; 744  : 
; 745  :     if (irqStatus & DISPC_IRQSTATUS_OCPERROR)
; 746  :     {
; 747  :         DEBUGMSG(ZONE_ERROR,(L"OCP_ERROR FATAL!!\r\n"));
; 748  :     }
; 749  : 
; 750  :     // Clear all interrupts
; 751  :     // Note that SETREG32 does read, OR of argument and write, the IRQSTATUS is write '1' to clear,
; 752  :     // this will clear all interrupt bits, not just the ones in the argument.
; 753  :     OUTREG32( &m_pDispRegs->DISPC_IRQSTATUS, irqStatus);

  0021c	e5943008	 ldr         r3, [r4, #8]
  00220	e5835018	 str         r5, [r3, #0x18]
  00224		 |$cleanUp$37967|

; 756  : 
; 757  :     ReleaseRegs();

  00224	e2843b01	 add         r3, r4, #1, 22
  00228	e283008c	 add         r0, r3, #0x8C
  0022c	eb000000	 bl          LeaveCriticalSection

; 758  : }

  00230	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00234	e12fff1e	 bx          lr
  00238		 |$LN47@DssProcess|
  00238		 |$LN48@DssProcess|
  00238	00000000	 DCD         |?g_rgPipelineMapping@@3PAUOMAPPipelineConfig@@A|
  0023c		 |$M42284|

			 ENDP  ; |?DssProcessInterrupt@OMAPDisplayController@@QAAXXZ|, OMAPDisplayController::DssProcessInterrupt

	EXPORT	|?DssInterruptHandler@OMAPDisplayController@@SAKPAX@Z| ; OMAPDisplayController::DssInterruptHandler
	IMPORT	|InterruptDone|
	IMPORT	|__C_specific_handler|

  00000			 AREA	 |.pdata|, PDATA
|$T42314| DCD	|$LN21@DssInterru|
	DCD	0xc0001d04

  00000			 AREA	 |.pdata|, PDATA
|$T42316| DCD	|$LN8@DssInterru|
	DCD	0x40000301

  00000			 AREA	 |.xdata|, DATA
|$T42312| DCD	0x1
	DCD	|$LN12@DssInterru|
	DCD	|$LN13@DssInterru|
	DCD	|$LN8@DssInterru|
	DCD	|$LN9@DssInterru|
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T42312|

  00008		 |?DssInterruptHandler@OMAPDisplayController@@SAKPAX@Z| PROC ; OMAPDisplayController::DssInterruptHandler

; 547  : {

  00008		 |$LN21@DssInterru|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d5830	 stmdb       sp!, {r4, r5, r11, r12, lr}
  00010	e28db014	 add         r11, sp, #0x14
  00014	e24dd008	 sub         sp, sp, #8
  00018		 |$LN19@DssInterru|
  00018	e1a04000	 mov         r4, r0

; 548  :     OMAPDisplayController *pController = (OMAPDisplayController *)pData;
; 549  :     DWORD sysIntr = pController->m_dwDssSysIntr;

  0001c	e59454ec	 ldr         r5, [r4, #0x4EC]
  00020	e50b401c	 str         r4, [r11, #-0x1C]
  00024	e50b5018	 str         r5, [r11, #-0x18]
  00028		 |$LL4@DssInterru|
  00028		 |$LN12@DssInterru|

; 550  :     for(;;)
; 551  :     {
; 552  :         __try
; 553  :         {
; 554  :             // wait for interrupt
; 555  :             WaitForSingleObject(pController->m_hDssIntEvent, INFINITE);

  00028	e59404e4	 ldr         r0, [r4, #0x4E4]
  0002c	e3e01000	 mvn         r1, #0
  00030	eb000000	 bl          WaitForSingleObject

; 556  :             if (pController->m_bDssIntThreadExit == TRUE) break;

  00034	e59434f0	 ldr         r3, [r4, #0x4F0]
  00038	e3530001	 cmp         r3, #1
  0003c	1a000000	 bne         |$LN1@DssInterru|
  00040	ea000007	 b           |$LN3@DssInterru|
  00044		 |$LN1@DssInterru|

; 557  : 
; 558  :             // process interrupt
; 559  :             pController->DssProcessInterrupt();

  00044	e1a00004	 mov         r0, r4
  00048	eb000000	 bl          |?DssProcessInterrupt@OMAPDisplayController@@QAAXXZ|
  0004c		 |$LN13@DssInterru|

; 560  :         }

  0004c	ea000001	 b           |$LN14@DssInterru|
  00050		 |$LN9@DssInterru|

; 561  :         __except (EXCEPTION_EXECUTE_HANDLER)

  00050	e51b401c	 ldr         r4, [r11, #-0x1C]
  00054	e51b5018	 ldr         r5, [r11, #-0x18]
  00058		 |$LN14@DssInterru|

; 562  :         {
; 563  :             DEBUGMSG(ZONE_ERROR,
; 564  :                 (TEXT("%S: exception in interrupt handler!\r\n"), __FUNCTION__));
; 565  :         }
; 566  :         // reset for next interrupt
; 567  :         ::InterruptDone(sysIntr);

  00058	e1a00005	 mov         r0, r5
  0005c	eb000000	 bl          InterruptDone

; 568  :     }

  00060	eafffff0	 b           |$LL4@DssInterru|
  00064		 |$LN3@DssInterru|

; 569  :     return 1;

  00064	e3a00001	 mov         r0, #1
  00068	ea000000	 b           |$LN5@DssInterru|
  0006c		 |$LN18@DssInterru|
  0006c	e51b0018	 ldr         r0, [r11, #-0x18]
  00070		 |$LN5@DssInterru|

; 570  : }

  00070	e24bd014	 sub         sp, r11, #0x14
  00074	e89d6830	 ldmia       sp, {r4, r5, r11, sp, lr}
  00078	e12fff1e	 bx          lr

			 ENDP  ; |?DssInterruptHandler@OMAPDisplayController@@SAKPAX@Z|, OMAPDisplayController::DssInterruptHandler

  0007c		 |$LN8@DssInterru|
  0007c		 |$LN20@DssInterru|

; 561  :         __except (EXCEPTION_EXECUTE_HANDLER)

  0007c	e52de004	 str         lr, [sp, #-4]!
  00080		 |$LN11@DssInterru|
  00080		 |$LN23@DssInterru|
  00080	e3a00001	 mov         r0, #1
  00084		 |$LN10@DssInterru|
  00084	e49df004	 ldr         pc, [sp], #4
  00088		 |$LN24@DssInterru|
  00088		 |$LN22@DssInterru|
	EXPORT	|?InitInterrupts@OMAPDisplayController@@QAAHKK@Z| ; OMAPDisplayController::InitInterrupts
	EXPORT	|??_C@_1CE@FJEPCB@?$AAD?$AAS?$AAS?$AAA?$AAI?$AA_?$AAV?$AAS?$AAY?$AAN?$AAC?$AA_?$AAE?$AAV?$AAE?$AAN?$AAT?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|InterruptInitialize|
	IMPORT	|CreateEventW|

  00000			 AREA	 |.pdata|, PDATA
|$T42333| DCD	|$LN21@InitInterr|
	DCD	0x40005004

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@FJEPCB@?$AAD?$AAS?$AAS?$AAA?$AAI?$AA_?$AAV?$AAS?$AAY?$AAN?$AAC?$AA_?$AAE?$AAV?$AAE?$AAN?$AAT?$AA?$AA@| DCB "D"
	DCB	0x0, "S", 0x0, "S", 0x0, "A", 0x0, "I", 0x0, "_", 0x0, "V"
	DCB	0x0, "S", 0x0, "Y", 0x0, "N", 0x0, "C", 0x0, "_", 0x0, "E"
	DCB	0x0, "V", 0x0, "E", 0x0, "N", 0x0, "T", 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InitInterrupts@OMAPDisplayController@@QAAHKK@Z| PROC ; OMAPDisplayController::InitInterrupts

; 411  : {

  00000		 |$LN21@InitInterr|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d50f0	 stmdb       sp!, {r4 - r7, r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M42330|
  00010	e1a06002	 mov         r6, r2
  00014	e1a04000	 mov         r4, r0

; 412  :     BOOL rc = FALSE;
; 413  : 
; 414  :     // get system interrupt for irq
; 415  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, &irq,
; 416  :         sizeof(irq), &m_dwDssSysIntr, sizeof(m_dwDssSysIntr),
; 417  :         NULL))

  00018	e59f011c	 ldr         r0, [pc, #0x11C]
  0001c	e2843b01	 add         r3, r4, #1, 22
  00020	e3a0e004	 mov         lr, #4
  00024	e3a07000	 mov         r7, #0
  00028	e28330ec	 add         r3, r3, #0xEC
  0002c	e3a02004	 mov         r2, #4
  00030	e28d1024	 add         r1, sp, #0x24
  00034	e3a05000	 mov         r5, #0
  00038	e58d7004	 str         r7, [sp, #4]
  0003c	e58de000	 str         lr, [sp]
  00040	eb000000	 bl          KernelIoControl
  00044	e3500000	 cmp         r0, #0
  00048	0a000033	 beq         |$LN18@InitInterr|

; 418  :     {
; 419  :         DEBUGMSG(ZONE_ERROR,
; 420  :             (TEXT("%S: ERROR: Failed map DSS interrupt(irq=%d)\r\n"), __FUNCTION__,irq));
; 421  :         goto cleanUp;
; 422  :     }
; 423  : 
; 424  :     // create thread event handle
; 425  :     m_hDssIntEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0004c	e3a03000	 mov         r3, #0
  00050	e3a02000	 mov         r2, #0
  00054	e3a01000	 mov         r1, #0
  00058	e3a00000	 mov         r0, #0
  0005c	eb000000	 bl          CreateEventW
  00060	e1b01000	 movs        r1, r0
  00064	e58414e4	 str         r1, [r4, #0x4E4]

; 426  :     if (m_hDssIntEvent == NULL)

  00068	0a00002b	 beq         |$LN18@InitInterr|

; 427  :     {
; 428  :         DEBUGMSG(ZONE_ERROR,
; 429  :             (TEXT("%S: ERROR: Failed to create Interrupt event object!\r\n"), __FUNCTION__));
; 430  :         goto cleanUp;
; 431  :     }
; 432  : 
; 433  :     // register event handle with system interrupt
; 434  :     if (!InterruptInitialize(m_dwDssSysIntr, m_hDssIntEvent, NULL, 0))

  0006c	e59404ec	 ldr         r0, [r4, #0x4EC]
  00070	e3a03000	 mov         r3, #0
  00074	e3a02000	 mov         r2, #0
  00078	eb000000	 bl          InterruptInitialize
  0007c	e3500000	 cmp         r0, #0
  00080	0a000025	 beq         |$LN18@InitInterr|

; 435  :     {
; 436  :         DEBUGMSG(ZONE_ERROR,
; 437  :             (TEXT("%S: ERROR: Failed to initialize system interrupt!\r\n"), __FUNCTION__));
; 438  :         goto cleanUp;
; 439  :     }
; 440  : 
; 441  :     //Create specific interrupt events
; 442  :     m_hVsyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00084	e3a03000	 mov         r3, #0
  00088	e3a02000	 mov         r2, #0
  0008c	e3a01000	 mov         r1, #0
  00090	e3a00000	 mov         r0, #0
  00094	eb000000	 bl          CreateEventW
  00098	e3500000	 cmp         r0, #0
  0009c	e58404f4	 str         r0, [r4, #0x4F4]

; 443  :     if (m_hVsyncEvent == NULL)

  000a0	0a00001d	 beq         |$LN18@InitInterr|

; 444  :     {
; 445  :         DEBUGMSG(ZONE_ERROR,
; 446  :             (TEXT("%S: ERROR: Failed to create Vsync interrupt event object!\r\n"), __FUNCTION__));
; 447  :         goto cleanUp;
; 448  :     }
; 449  : 
; 450  :     //Create specific interrupt events
; 451  :     m_hVsyncEventSGX = CreateEvent(NULL, FALSE, FALSE, VSYNC_EVENT_NAME);

  000a4	e59f308c	 ldr         r3, [pc, #0x8C]
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01000	 mov         r1, #0
  000b0	e3a00000	 mov         r0, #0
  000b4	eb000000	 bl          CreateEventW
  000b8	e3500000	 cmp         r0, #0
  000bc	e58404f8	 str         r0, [r4, #0x4F8]

; 452  :     if (m_hVsyncEventSGX == NULL)

  000c0	0a000015	 beq         |$LN18@InitInterr|

; 453  :     {
; 454  :         DEBUGMSG(ZONE_ERROR,
; 455  :             (TEXT("%S: ERROR: Failed to create Vsync interrupt event object for SGX!\r\n"), __FUNCTION__));
; 456  :         goto cleanUp;
; 457  :     }
; 458  : 
; 459  :     //Create specific interrupt events
; 460  :     m_hScanLineEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  000c4	e3a03000	 mov         r3, #0
  000c8	e3a02000	 mov         r2, #0
  000cc	e3a01000	 mov         r1, #0
  000d0	e3a00000	 mov         r0, #0
  000d4	eb000000	 bl          CreateEventW
  000d8	e3500000	 cmp         r0, #0
  000dc	e5840504	 str         r0, [r4, #0x504]

; 461  :     if (m_hScanLineEvent == NULL)

  000e0	0a00000d	 beq         |$LN18@InitInterr|

; 462  :     {
; 463  :         DEBUGMSG(ZONE_ERROR,
; 464  :             (TEXT("%S: ERROR: Failed to create ScanLine interrupt event object!\r\n"), __FUNCTION__));
; 465  :         goto cleanUp;
; 466  :     }
; 467  : 
; 468  :     // spawn thread
; 469  :     m_hDssIntThread = CreateThread(NULL, 0, DssInterruptHandler, this, 0, NULL);

  000e4	e59f2048	 ldr         r2, [pc, #0x48]
  000e8	e1a03004	 mov         r3, r4
  000ec	e3a01000	 mov         r1, #0
  000f0	e3a00000	 mov         r0, #0
  000f4	e58d7004	 str         r7, [sp, #4]
  000f8	e58d7000	 str         r7, [sp]
  000fc	eb000000	 bl          CreateThread
  00100	e3500000	 cmp         r0, #0
  00104	e58404e8	 str         r0, [r4, #0x4E8]

; 470  :     if (!m_hDssIntThread)

  00108	0a000003	 beq         |$LN18@InitInterr|

; 471  :     {
; 472  :         DEBUGMSG(ZONE_ERROR,
; 473  :             (TEXT("%S: Failed to create interrupt thread\r\n"), __FUNCTION__));
; 474  :         goto cleanUp;
; 475  :     }
; 476  : 
; 477  :     // set thread priority
; 478  :     CeSetThreadPriority(m_hDssIntThread, istPriority);

  0010c	e1a01006	 mov         r1, r6
  00110	eb000000	 bl          CeSetThreadPriority

; 479  : 
; 480  :     rc = TRUE;

  00114	e3a05001	 mov         r5, #1
  00118		 |$cleanUp$37913|

; 481  : 
; 482  : cleanUp:
; 483  :     if (rc == FALSE) UninitInterrupts();

  00118	ea000001	 b           |$LN1@InitInterr|
  0011c		 |$LN18@InitInterr|
  0011c	e1a00004	 mov         r0, r4
  00120	eb000000	 bl          |?UninitInterrupts@OMAPDisplayController@@QAAXXZ|
  00124		 |$LN1@InitInterr|

; 484  :     return rc;
; 485  : }

  00124	e1a00005	 mov         r0, r5
  00128	e28dd008	 add         sp, sp, #8
  0012c	e89d60f0	 ldmia       sp, {r4 - r7, sp, lr}
  00130	e12fff1e	 bx          lr
  00134		 |$LN22@InitInterr|
  00134		 |$LN23@InitInterr|
  00134	00000000	 DCD         |?DssInterruptHandler@OMAPDisplayController@@SAKPAX@Z|
  00138		 |$LN24@InitInterr|
  00138	00000000	 DCD         |??_C@_1CE@FJEPCB@?$AAD?$AAS?$AAS?$AAA?$AAI?$AA_?$AAV?$AAS?$AAY?$AAN?$AAC?$AA_?$AAE?$AAV?$AAE?$AAN?$AAT?$AA?$AA@|
  0013c		 |$LN25@InitInterr|
  0013c	01010098	 DCD         0x1010098
  00140		 |$M42331|

			 ENDP  ; |?InitInterrupts@OMAPDisplayController@@QAAHKK@Z|, OMAPDisplayController::InitInterrupts

	END
