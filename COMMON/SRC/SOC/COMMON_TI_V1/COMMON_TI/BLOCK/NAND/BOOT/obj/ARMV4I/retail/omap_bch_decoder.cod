; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\BLOCK\NAND\omap_bch_decoder.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\block\nand\omap_bch_decoder.c

  00000			 AREA	 |.pdata|, PDATA
|$T583|	DCD	|$LN13@mpy_mod_gf|
	DCD	0x40001801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |mpy_mod_gf| PROC

; 32   : {

  00000		 |$LN13@mpy_mod_gf|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M580|
  00004	e1a05000	 mov         r5, r0

; 33   : 	unsigned int R = 0;
; 34   : 	unsigned int R1 = 0;
; 35   : 	unsigned int k = 0;
; 36   : 
; 37   : 	for (k = 0; k < mm; k++) {

  00008	e3a03c0f	 mov         r3, #0xF, 24
  0000c	e38340ff	 orr         r4, r3, #0xFF
  00010	e3a00000	 mov         r0, #0
  00014	e3a0e000	 mov         lr, #0
  00018	e3a02000	 mov         r2, #0
  0001c		 |$LL6@mpy_mod_gf|

; 38   : 
; 39   : 		R = (R << 1) & 0x1FFE;

  0001c	e0003004	 and         r3, r0, r4
  00020	e1a00083	 mov         r0, r3, lsl #1

; 40   : 		if (R1 == 1)
; 41   : 			R ^= P;
; 42   : 
; 43   : 		if (((a >> (POLY - k)) & 1) == 1)

  00024	e262300c	 rsb         r3, r2, #0xC
  00028	e1a03335	 mov         r3, r5, lsr r3
  0002c	e35e0001	 cmp         lr, #1
  00030	e2033001	 and         r3, r3, #1
  00034	0220001b	 eoreq       r0, r0, #0x1B
  00038	e3530001	 cmp         r3, #1

; 44   : 			R ^= b;

  0003c	00200001	 eoreq       r0, r0, r1

; 45   : 
; 46   : 		if (k < POLY)

  00040	e352000c	 cmp         r2, #0xC

; 47   : 			R1 = (R >> POLY) & 1;

  00044	31a03980	 movcc       r3, r0, lsl #19
  00048	e2822001	 add         r2, r2, #1
  0004c	31a0efa3	 movcc       lr, r3, lsr #31
  00050	e352000d	 cmp         r2, #0xD
  00054	3afffff0	 bcc         |$LL6@mpy_mod_gf|

; 48   : 	}
; 49   : 	return R;
; 50   : }

  00058	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  0005c	e12fff1e	 bx          lr
  00060		 |$M581|

			 ENDP  ; |mpy_mod_gf|


  00000			 AREA	 |.pdata|, PDATA
|$T625|	DCD	|$LN26@chien|
	DCD	0x40009802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |chien| PROC

; 65   : {

  00000		 |$LN26@chien|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd044	 sub         sp, sp, #0x44
  00008		 |$M622|
  00008	e1a08003	 mov         r8, r3
  0000c	e1a04002	 mov         r4, r2
  00010	e1a09001	 mov         r9, r1
  00014	e1b0a000	 movs        r10, r0

; 66   : 	int i, count; /* Number of dectected errors */
; 67   : 	/* Contains accumulation of evaluation at x^i (i:1->8) */
; 68   : 	unsigned int gammas[8] = {0};
; 69   : 	unsigned int alpha;
; 70   : 	unsigned int bit, ecc_bits;
; 71   : 	unsigned int elp_sum;
; 72   : 
; 73   : 	ecc_bits = (select_4_8 == 0) ? 52 : 104;

  00018	03a0e034	 moveq       lr, #0x34

; 74   : 
; 75   : 	/* Start evaluation at Alpha**8192 and decreasing */
; 76   : 	for (i = 0; i < 8; i++)
; 77   : 		gammas[i] = err[i];

  0001c	e28d2024	 add         r2, sp, #0x24
  00020	13a0e068	 movne       lr, #0x68
  00024	e2821020	 add         r1, r2, #0x20
  00028		 |$LN20@chien|
  00028	e4943004	 ldr         r3, [r4], #4
  0002c	e4823004	 str         r3, [r2], #4
  00030	e1520001	 cmp         r2, r1
  00034	1afffffb	 bne         |$LN20@chien|

; 78   : 
; 79   : 	count = 0;

  00038	e59d3030	 ldr         r3, [sp, #0x30]
  0003c	e59d0040	 ldr         r0, [sp, #0x40]
  00040	e59d203c	 ldr         r2, [sp, #0x3C]
  00044	e58d3008	 str         r3, [sp, #8]
  00048	e59d302c	 ldr         r3, [sp, #0x2C]
  0004c	e59d4038	 ldr         r4, [sp, #0x38]
  00050	e59d5034	 ldr         r5, [sp, #0x34]
  00054	e58d3004	 str         r3, [sp, #4]
  00058	e59d3028	 ldr         r3, [sp, #0x28]
  0005c	e1a0108e	 mov         r1, lr, lsl #1
  00060	e58d001c	 str         r0, [sp, #0x1C]
  00064	e58d3000	 str         r3, [sp]
  00068	e59d3024	 ldr         r3, [sp, #0x24]
  0006c	e58d200c	 str         r2, [sp, #0xC]
  00070	e58d4010	 str         r4, [sp, #0x10]
  00074	e58d3018	 str         r3, [sp, #0x18]
  00078	e58d5014	 str         r5, [sp, #0x14]
  0007c	e3a06000	 mov         r6, #0
  00080	e3a07000	 mov         r7, #0
  00084	e1a0b08e	 mov         r11, lr, lsl #1
  00088	e58d1020	 str         r1, [sp, #0x20]
  0008c		 |$LL8@chien|

; 80   : 	for (i = 1; (i <= nn) && (count < err_nums); i++) {

  0008c	e1560009	 cmp         r6, r9
  00090	aa00006d	 bge         |$LN22@chien|

; 81   : 
; 82   : 		/* Result of evaluation at root */
; 83   : 		elp_sum = 1 ^ gammas[0] ^ gammas[1] ^
; 84   : 				gammas[2] ^ gammas[3] ^
; 85   : 				gammas[4] ^ gammas[5] ^
; 86   : 				gammas[6] ^ gammas[7];

  00094	e0203002	 eor         r3, r0, r2
  00098	e59d2008	 ldr         r2, [sp, #8]
  0009c	e0233004	 eor         r3, r3, r4
  000a0	e0233005	 eor         r3, r3, r5
  000a4	e0233002	 eor         r3, r3, r2
  000a8	e59d2004	 ldr         r2, [sp, #4]
  000ac	e59d0018	 ldr         r0, [sp, #0x18]

; 87   : 
; 88   : 		alpha = PPP >> 1;
; 89   : 		gammas[0] = mpy_mod_gf(gammas[0], alpha);

  000b0	e3a04a01	 mov         r4, #1, 20
  000b4	e0233002	 eor         r3, r3, r2
  000b8	e59d2000	 ldr         r2, [sp]
  000bc	e384100d	 orr         r1, r4, #0xD
  000c0	e0233002	 eor         r3, r3, r2
  000c4	e0235000	 eor         r5, r3, r0
  000c8	eb000000	 bl          mpy_mod_gf
  000cc	e58d0018	 str         r0, [sp, #0x18]

; 90   : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-2 */

  000d0	e384000d	 orr         r0, r4, #0xD
  000d4	e384100d	 orr         r1, r4, #0xD
  000d8	eb000000	 bl          mpy_mod_gf
  000dc	e1a04000	 mov         r4, r0

; 91   : 		gammas[1] = mpy_mod_gf(gammas[1], alpha);

  000e0	e59d0000	 ldr         r0, [sp]
  000e4	e1a01004	 mov         r1, r4
  000e8	eb000000	 bl          mpy_mod_gf

; 92   : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-2 */

  000ec	e3a03a01	 mov         r3, #1, 20
  000f0	e58d0000	 str         r0, [sp]
  000f4	e1a00004	 mov         r0, r4
  000f8	e383100d	 orr         r1, r3, #0xD
  000fc	eb000000	 bl          mpy_mod_gf
  00100	e1a04000	 mov         r4, r0

; 93   : 		gammas[2] = mpy_mod_gf(gammas[2], alpha);

  00104	e59d0004	 ldr         r0, [sp, #4]
  00108	e1a01004	 mov         r1, r4
  0010c	eb000000	 bl          mpy_mod_gf

; 94   : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-3 */

  00110	e3a03a01	 mov         r3, #1, 20
  00114	e58d0004	 str         r0, [sp, #4]
  00118	e1a00004	 mov         r0, r4
  0011c	e383100d	 orr         r1, r3, #0xD
  00120	eb000000	 bl          mpy_mod_gf
  00124	e1a04000	 mov         r4, r0

; 95   : 		gammas[3] = mpy_mod_gf(gammas[3], alpha);

  00128	e59d0008	 ldr         r0, [sp, #8]
  0012c	e1a01004	 mov         r1, r4
  00130	eb000000	 bl          mpy_mod_gf

; 96   : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-4 */

  00134	e3a03a01	 mov         r3, #1, 20
  00138	e58d0008	 str         r0, [sp, #8]
  0013c	e1a00004	 mov         r0, r4
  00140	e383100d	 orr         r1, r3, #0xD
  00144	eb000000	 bl          mpy_mod_gf
  00148	e1a04000	 mov         r4, r0

; 97   : 		gammas[4] = mpy_mod_gf(gammas[4], alpha);

  0014c	e59d0014	 ldr         r0, [sp, #0x14]
  00150	e1a01004	 mov         r1, r4
  00154	eb000000	 bl          mpy_mod_gf

; 98   : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-5 */

  00158	e3a03a01	 mov         r3, #1, 20
  0015c	e58d0014	 str         r0, [sp, #0x14]
  00160	e1a00004	 mov         r0, r4
  00164	e383100d	 orr         r1, r3, #0xD
  00168	eb000000	 bl          mpy_mod_gf
  0016c	e1a04000	 mov         r4, r0

; 99   : 		gammas[5] = mpy_mod_gf(gammas[5], alpha);

  00170	e59d0010	 ldr         r0, [sp, #0x10]
  00174	e1a01004	 mov         r1, r4
  00178	eb000000	 bl          mpy_mod_gf

; 100  : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-6 */

  0017c	e3a03a01	 mov         r3, #1, 20
  00180	e58d0010	 str         r0, [sp, #0x10]
  00184	e1a00004	 mov         r0, r4
  00188	e383100d	 orr         r1, r3, #0xD
  0018c	eb000000	 bl          mpy_mod_gf
  00190	e1a04000	 mov         r4, r0

; 101  : 		gammas[6] = mpy_mod_gf(gammas[6], alpha);

  00194	e59d000c	 ldr         r0, [sp, #0xC]
  00198	e1a01004	 mov         r1, r4
  0019c	eb000000	 bl          mpy_mod_gf

; 102  : 		alpha = mpy_mod_gf(alpha, (PPP >> 1));		/* x alphha^-7 */

  001a0	e3a03a01	 mov         r3, #1, 20
  001a4	e58d000c	 str         r0, [sp, #0xC]
  001a8	e1a00004	 mov         r0, r4
  001ac	e383100d	 orr         r1, r3, #0xD
  001b0	eb000000	 bl          mpy_mod_gf
  001b4	e1a01000	 mov         r1, r0

; 103  : 		gammas[7] = mpy_mod_gf(gammas[7], alpha);

  001b8	e59d001c	 ldr         r0, [sp, #0x1C]
  001bc	eb000000	 bl          mpy_mod_gf
  001c0	e58d001c	 str         r0, [sp, #0x1C]

; 104  : 
; 105  : 		if (elp_sum == 0) {

  001c4	e3350001	 teq         r5, #1
  001c8	1a000015	 bne         |$LN7@chien|

; 106  : 			/* calculate location */
; 107  : 			bit = ((i-1) & ~7)|(7-((i-1) & 7));

  001cc	e2073007	 and         r3, r7, #7
  001d0	e2632007	 rsb         r2, r3, #7
  001d4	e3c73007	 bic         r3, r7, #7
  001d8	e1822003	 orr         r2, r2, r3

; 108  : 			if ((select_4_8 == 0) && (i >= 2 * ecc_bits)) {

  001dc	e35a0000	 cmp         r10, #0
  001e0	1a000004	 bne         |$LN4@chien|
  001e4	e2873001	 add         r3, r7, #1
  001e8	e153000b	 cmp         r3, r11
  001ec	3a00000c	 bcc         |$LN7@chien|

; 109  : 				location[count++] = kk_shorten - (bit - 2 * ecc_bits) - 1;

  001f0	e04b3002	 sub         r3, r11, r2
  001f4	ea000006	 b           |$LN23@chien|
  001f8		 |$LN4@chien|

; 110  : 			} else if ((select_4_8 == 1) && (i >= 2 * ecc_bits)) {

  001f8	e35a0001	 cmp         r10, #1
  001fc	1a000008	 bne         |$LN7@chien|
  00200	e59d1020	 ldr         r1, [sp, #0x20]
  00204	e2873001	 add         r3, r7, #1
  00208	e1530001	 cmp         r3, r1
  0020c	3a000004	 bcc         |$LN7@chien|

; 111  : 				location[count++] = kk_shorten - (bit - 2 * ecc_bits) - 1;

  00210	e0413002	 sub         r3, r1, r2
  00214		 |$LN23@chien|
  00214	e2833c0f	 add         r3, r3, #0xF, 24
  00218	e28330ff	 add         r3, r3, #0xFF
  0021c	e4883004	 str         r3, [r8], #4
  00220	e2866001	 add         r6, r6, #1
  00224		 |$LN7@chien|
  00224	e2877001	 add         r7, r7, #1
  00228	e3a01c1f	 mov         r1, #0x1F, 24
  0022c	e2873001	 add         r3, r7, #1
  00230	e38120ff	 orr         r2, r1, #0xFF
  00234	e59d4010	 ldr         r4, [sp, #0x10]
  00238	e59d5014	 ldr         r5, [sp, #0x14]
  0023c	e1530002	 cmp         r3, r2
  00240	e59d200c	 ldr         r2, [sp, #0xC]
  00244	daffff90	 ble         |$LL8@chien|

; 112  : 			}
; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	/* Failure: No. of detected errors != No. or corrected errors */
; 117  : 	if (count != err_nums) {

  00248	e1560009	 cmp         r6, r9
  0024c		 |$LN22@chien|

; 118  : 		count = -1;

  0024c	13e06000	 mvnne       r6, #0

; 119  : 	}
; 120  : 	
; 121  : 	return count;
; 122  : }

  00250	e1a00006	 mov         r0, r6
  00254	e28dd044	 add         sp, sp, #0x44
  00258	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0025c	e12fff1e	 bx          lr
  00260		 |$M623|

			 ENDP  ; |chien|

	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T682|	DCD	|$LN57@berlekamp|
	DCD	0x40009c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |berlekamp| PROC

; 130  : {

  00000		 |$LN57@berlekamp|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd0a8	 sub         sp, sp, #0xA8
  00008		 |$M679|
  00008	e1a09002	 mov         r9, r2
  0000c	e1a0b001	 mov         r11, r1
  00010	e58d901c	 str         r9, [sp, #0x1C]
  00014	e58db004	 str         r11, [sp, #4]
  00018	e1a04000	 mov         r4, r0

; 131  : 	unsigned int loop, iteration;
; 132  : 	unsigned int LL = 0;		/* Detected errors */
; 133  : 	unsigned int d = 0;	/* Distance between Syndromes and ELP[n](z) */
; 134  : 	unsigned int invd = 0;		/* Inverse of d */
; 135  : 	/* Intermediate ELP[n](z).
; 136  : 	 * Final ELP[n](z) is Error Location Polynomial
; 137  : 	 */
; 138  : 	unsigned int gammas[16] = {0};
; 139  : 	/* Intermediate normalized ELP[n](z) : D[n](z) */
; 140  : 	unsigned int D[16] = {0};

  0001c	e3a03000	 mov         r3, #0
  00020	e3a0203c	 mov         r2, #0x3C
  00024	e3a01000	 mov         r1, #0
  00028	e28d002c	 add         r0, sp, #0x2C
  0002c	e58d3028	 str         r3, [sp, #0x28]
  00030	eb000000	 bl          memset

; 141  : 	/* Temporary value that holds an ELP[n](z) coefficient */
; 142  : 	unsigned int next_gamma = 0;
; 143  : 
; 144  : 	int e = 0;
; 145  : 	unsigned int sign = 0;
; 146  : 	unsigned int u = 0;
; 147  : 	unsigned int v = 0;
; 148  : 	unsigned int C1 = 0, C2 = 0;
; 149  : 	unsigned int ss = 0;
; 150  : 	unsigned int tmp_v = 0, tmp_s = 0;
; 151  : 	unsigned int tmp_poly;
; 152  : 
; 153  : 	/*-------------- Step 0 ------------------*/
; 154  : 	for (loop = 0; loop < 16; loop++)
; 155  : 		gammas[loop] = 0;

  00034	e28d3068	 add         r3, sp, #0x68
  00038	e2830040	 add         r0, r3, #0x40
  0003c	e3a02000	 mov         r2, #0
  00040		 |$LN47@berlekamp|
  00040	e4832004	 str         r2, [r3], #4
  00044	e1530000	 cmp         r3, r0
  00048	1afffffc	 bne         |$LN47@berlekamp|

; 156  : 	gammas[0] = 1;
; 157  : 	D[1] = 1;
; 158  : 
; 159  : 	iteration = 0;
; 160  : 	LL = 0;
; 161  : 	while ((iteration < ((select_4_8+1)*2*4)) &&
; 162  : 			(LL <= ((select_4_8+1)*4))) {

  0004c	e2843001	 add         r3, r4, #1
  00050	e1b03183	 movs        r3, r3, lsl #3
  00054	e3a02001	 mov         r2, #1
  00058	e3a01001	 mov         r1, #1
  0005c	e3a07000	 mov         r7, #0
  00060	e3a05000	 mov         r5, #0
  00064	e58d3020	 str         r3, [sp, #0x20]
  00068	e58d2068	 str         r2, [sp, #0x68]
  0006c	e58d102c	 str         r1, [sp, #0x2C]
  00070	e58d700c	 str         r7, [sp, #0xC]
  00074	e58d5008	 str         r5, [sp, #8]
  00078	0a000072	 beq         |$LN22@berlekamp|
  0007c	e2843001	 add         r3, r4, #1
  00080	e3a02c1f	 mov         r2, #0x1F, 24
  00084	e1a03103	 mov         r3, r3, lsl #2
  00088	e38220ff	 orr         r2, r2, #0xFF
  0008c	e58d3018	 str         r3, [sp, #0x18]
  00090	e58d2014	 str         r2, [sp, #0x14]
  00094	e3a09000	 mov         r9, #0
  00098		 |$LL23@berlekamp|
  00098	e1550003	 cmp         r5, r3
  0009c	8a000068	 bhi         |$LN52@berlekamp|

; 163  : 
; 164  : 		d = 0;

  000a0	e3a0a000	 mov         r10, #0
  000a4	e28d4068	 add         r4, sp, #0x68
  000a8	e1a0600b	 mov         r6, r11
  000ac	e2858001	 add         r8, r5, #1
  000b0		 |$LL21@berlekamp|

; 165  : 		/* Step: 0 */
; 166  : 		for (loop = 0; loop <= LL; loop++) {
; 167  : 			tmp_poly = mpy_mod_gf(
; 168  : 					gammas[loop], synd[iteration - loop]);

  000b0	e4161004	 ldr         r1, [r6], #-4
  000b4	e4940004	 ldr         r0, [r4], #4
  000b8	eb000000	 bl          mpy_mod_gf

; 169  : 			d ^= tmp_poly;

  000bc	e020a00a	 eor         r10, r0, r10
  000c0	e2588001	 subs        r8, r8, #1
  000c4	1afffff9	 bne         |$LL21@berlekamp|

; 170  : 		}
; 171  : 
; 172  : 		/* Step 1: 1 cycle only to perform inversion */
; 173  : 		v = d << 1;
; 174  : 		e = -1;
; 175  : 		sign = 1;
; 176  : 		ss = 0x2000;

  000c8	e3a04a02	 mov         r4, #2, 20

; 177  : 		invd = 0;
; 178  : 		u = PPP;

  000cc	e384301b	 orr         r3, r4, #0x1B
  000d0	e58d3024	 str         r3, [sp, #0x24]
  000d4	e3a03001	 mov         r3, #1
  000d8	e3a0e000	 mov         lr, #0
  000dc	e58d3000	 str         r3, [sp]
  000e0	e1a0008a	 mov         r0, r10, lsl #1
  000e4	e3e02000	 mvn         r2, #0
  000e8	e58de010	 str         lr, [sp, #0x10]

; 179  : 		for (loop = 0; (d != 0) && (loop <= (2 * POLY)); loop++) {

  000ec	e3a01000	 mov         r1, #0
  000f0	e35a0000	 cmp         r10, #0
  000f4	0a000022	 beq         |$LN16@berlekamp|

; 181  : 			C2 = C1 & sign;

  000f8	e59d9024	 ldr         r9, [sp, #0x24]

; 249  : 
; 250  : 		D[0] = 0;
; 251  : 
; 252  : 		iteration++;

  000fc	e59d5014	 ldr         r5, [sp, #0x14]
  00100	e1a07003	 mov         r7, r3
  00104		 |$LL18@berlekamp|

; 179  : 		for (loop = 0; (d != 0) && (loop <= (2 * POLY)); loop++) {

  00104	e3510018	 cmp         r1, #0x18
  00108	8a000018	 bhi         |$LN51@berlekamp|

; 180  : 			C1 = (v >> 13) & 1;

  0010c	e1a03900	 mov         r3, r0, lsl #18

; 182  : 
; 183  : 			sign ^= C2 ^ (e == 0);

  00110	e3520000	 cmp         r2, #0
  00114	e1a06fa3	 mov         r6, r3, lsr #31
  00118	03a03001	 moveq       r3, #1
  0011c	e0068007	 and         r8, r6, r7
  00120	13a03000	 movne       r3, #0
  00124	e58d8000	 str         r8, [sp]
  00128	e0233008	 eor         r3, r3, r8

; 184  : 
; 185  : 			tmp_v = v;
; 186  : 			tmp_s = ss;
; 187  : 
; 188  : 			if (C1 == 1) {

  0012c	e3560001	 cmp         r6, #1
  00130	e1a08000	 mov         r8, r0

; 189  : 				v ^= u;

  00134	00200009	 eoreq       r0, r0, r9
  00138	e0237007	 eor         r7, r3, r7

; 190  : 				ss ^= invd;
; 191  : 			}
; 192  : 			v = (v << 1) & 0x3FFF;

  0013c	e0003005	 and         r3, r0, r5
  00140	e1a00083	 mov         r0, r3, lsl #1

; 193  : 			if (C2 == 1) {

  00144	e59d3000	 ldr         r3, [sp]
  00148	e1a0b004	 mov         r11, r4
  0014c	0024400e	 eoreq       r4, r4, lr
  00150	e3530001	 cmp         r3, #1

; 194  : 				u = tmp_v;
; 195  : 				invd = tmp_s;

  00154	01a0e00b	 moveq       lr, r11

; 196  : 				e = -e;

  00158	02622000	 rsbeq       r2, r2, #0

; 197  : 			}
; 198  : 			invd >>= 1;

  0015c	e1a0e0ae	 mov         lr, lr, lsr #1

; 199  : 			e--;

  00160	e2422001	 sub         r2, r2, #1
  00164	01a09008	 moveq       r9, r8
  00168	e2811001	 add         r1, r1, #1
  0016c	eaffffe4	 b           |$LL18@berlekamp|
  00170		 |$LN51@berlekamp|

; 237  : 				/* If update finished */
; 238  : 				LL = iteration - LL + 1;

  00170	e59d5008	 ldr         r5, [sp, #8]

; 249  : 
; 250  : 		D[0] = 0;
; 251  : 
; 252  : 		iteration++;

  00174	e59d700c	 ldr         r7, [sp, #0xC]
  00178	e59db004	 ldr         r11, [sp, #4]
  0017c	e58de010	 str         lr, [sp, #0x10]
  00180	e3a09000	 mov         r9, #0
  00184		 |$LN16@berlekamp|
  00184	e3a04000	 mov         r4, #0
  00188	e35a0000	 cmp         r10, #0
  0018c	0a00001c	 beq         |$LN11@berlekamp|

; 156  : 	gammas[0] = 1;
; 157  : 	D[1] = 1;
; 158  : 
; 159  : 	iteration = 0;
; 160  : 	LL = 0;
; 161  : 	while ((iteration < ((select_4_8+1)*2*4)) &&
; 162  : 			(LL <= ((select_4_8+1)*4))) {

  00190	e2876001	 add         r6, r7, #1
  00194		 |$LL13@berlekamp|

; 200  : 		}
; 201  : 
; 202  : 		for (loop = 0; (d != 0) && (loop <= (iteration + 1)); loop++) {

  00194	e1540006	 cmp         r4, r6
  00198	8a000018	 bhi         |$LN54@berlekamp|
  0019c	e28d3028	 add         r3, sp, #0x28

; 203  : 			/* Step 2
; 204  : 			 * Interleaved with Step 3, if L<(n-k)
; 205  : 			 * invd: Update of ELP[n](z) = ELP[n-1](z) - d.D[n-1](z)
; 206  : 			 */
; 207  : 
; 208  : 			/* Holds value of ELP coefficient until precedent
; 209  : 			 * value does not have to be used anymore
; 210  : 			 */
; 211  : 			tmp_poly = mpy_mod_gf(d, D[loop]);

  001a0	e7b31104	 ldr         r1, [r3, +r4, lsl #2]!
  001a4	e1a0000a	 mov         r0, r10
  001a8	e58d3000	 str         r3, [sp]
  001ac	eb000000	 bl          mpy_mod_gf
  001b0	e28d8068	 add         r8, sp, #0x68

; 212  : 
; 213  : 			next_gamma = gammas[loop] ^ tmp_poly;

  001b4	e7b83104	 ldr         r3, [r8, +r4, lsl #2]!

; 214  : 			if ((2 * LL) < (iteration + 1)) {

  001b8	e1560085	 cmp         r6, r5, lsl #1
  001bc	e023b000	 eor         r11, r3, r0
  001c0	8a000002	 bhi         |$LN8@berlekamp|

; 215  : 				/* Interleaving with Step 3
; 216  : 				 * for parallelized update of ELP(z) and D(z)
; 217  : 				 */
; 218  : 			} else {
; 219  : 				/* Update of ELP(z) only -> stay in Step 2 */
; 220  : 				gammas[loop] = next_gamma;

  001c4	e588b000	 str         r11, [r8]

; 221  : 				if (loop == (iteration + 1)) {

  001c8	e1540006	 cmp         r4, r6
  001cc	0a00000b	 beq         |$LN54@berlekamp|
  001d0		 |$LN8@berlekamp|

; 222  : 					/* to step 4 */
; 223  : 					break;
; 224  : 				}
; 225  : 			}
; 226  : 
; 227  : 			/* Step 3
; 228  : 			 * Always interleaved with Step 2 (case when L<(n-k))
; 229  : 			 * Update of D[n-1](z) = ELP[n-1](z)/d
; 230  : 			 */
; 231  : 			D[loop] = mpy_mod_gf(gammas[loop], invd);

  001d0	e5980000	 ldr         r0, [r8]
  001d4	e59d1010	 ldr         r1, [sp, #0x10]
  001d8	eb000000	 bl          mpy_mod_gf
  001dc	e59d3000	 ldr         r3, [sp]

; 232  : 
; 233  : 			/* Can safely update ELP[n](z) */
; 234  : 			gammas[loop] = next_gamma;
; 235  : 
; 236  : 			if (loop == (iteration + 1)) {

  001e0	e1540006	 cmp         r4, r6
  001e4	e588b000	 str         r11, [r8]
  001e8	e5830000	 str         r0, [r3]
  001ec	12844001	 addne       r4, r4, #1
  001f0	1affffe7	 bne         |$LL13@berlekamp|

; 237  : 				/* If update finished */
; 238  : 				LL = iteration - LL + 1;

  001f4	e0473005	 sub         r3, r7, r5
  001f8	e2835001	 add         r5, r3, #1
  001fc	e58d5008	 str         r5, [sp, #8]
  00200		 |$LN54@berlekamp|

; 249  : 
; 250  : 		D[0] = 0;
; 251  : 
; 252  : 		iteration++;

  00200	e59db004	 ldr         r11, [sp, #4]

; 237  : 				/* If update finished */
; 238  : 				LL = iteration - LL + 1;

  00204		 |$LN11@berlekamp|

; 239  : 				/* to step 4 */
; 240  : 				break;
; 241  : 			}
; 242  : 			/* Else, interleaving to step 2*/
; 243  : 		}
; 244  : 
; 245  : 		/* Step 4: Update D(z): i:0->L */
; 246  : 		/* Final update of D[n](z) = D[n](z).z*/
; 247  : 		for (loop = 0; loop < 15; loop++) /* Left Shift */

  00204	e28d2060	 add         r2, sp, #0x60
  00208	e3a0100f	 mov         r1, #0xF
  0020c		 |$LL6@berlekamp|

; 248  : 			D[15 - loop] = D[14 - loop];

  0020c	e5923000	 ldr         r3, [r2]
  00210	e2511001	 subs        r1, r1, #1
  00214	e5823004	 str         r3, [r2, #4]
  00218	e2422004	 sub         r2, r2, #4
  0021c	1afffffa	 bne         |$LL6@berlekamp|

; 249  : 
; 250  : 		D[0] = 0;
; 251  : 
; 252  : 		iteration++;

  00220	e59d3020	 ldr         r3, [sp, #0x20]
  00224	e2877001	 add         r7, r7, #1
  00228	e28bb004	 add         r11, r11, #4
  0022c	e1570003	 cmp         r7, r3
  00230	e59d3018	 ldr         r3, [sp, #0x18]
  00234	e58d700c	 str         r7, [sp, #0xC]
  00238	e58d9028	 str         r9, [sp, #0x28]
  0023c	e58db004	 str         r11, [sp, #4]
  00240	3affff94	 bcc         |$LL23@berlekamp|
  00244		 |$LN52@berlekamp|

; 130  : {

  00244	e59d901c	 ldr         r9, [sp, #0x1C]
  00248		 |$LN22@berlekamp|

; 253  : 	} /* while */
; 254  : 
; 255  : 	/* Processing finished, copy ELP to final registers : 0->2t-1*/
; 256  : 	for (loop = 0; loop < 8; loop++)
; 257  : 		err[loop] = gammas[loop+1];

  00248	e28d206c	 add         r2, sp, #0x6C
  0024c	e2891020	 add         r1, r9, #0x20
  00250		 |$LN49@berlekamp|
  00250	e4923004	 ldr         r3, [r2], #4
  00254	e4893004	 str         r3, [r9], #4
  00258	e1590001	 cmp         r9, r1
  0025c	1afffffb	 bne         |$LN49@berlekamp|

; 258  : 
; 259  : 	return LL;
; 260  : }

  00260	e1a00005	 mov         r0, r5
  00264	e28dd0a8	 add         sp, sp, #0xA8
  00268	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0026c	e12fff1e	 bx          lr
  00270		 |$M680|

			 ENDP  ; |berlekamp|


  00000			 AREA	 |.pdata|, PDATA
|$T708|	DCD	|$LN32@syndrome|
	DCD	0x40006802
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |syndrome| PROC

; 271  : {

  00000		 |$LN32@syndrome|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M705|
  00008	e1a06001	 mov         r6, r1
  0000c	e58d6000	 str         r6, [sp]
  00010	e1a05002	 mov         r5, r2
  00014	e3500000	 cmp         r0, #0

; 272  : 	unsigned int k, l, t;
; 273  : 	unsigned int alpha_bit, R_bit;
; 274  : 	int ecc_pos, ecc_min;
; 275  : 
; 276  : 	/* 2t-1 = 15 (for t=8) minimal polynomials of the first 15 powers of a
; 277  : 	 * primitive elemmants of GF(m); Even powers minimal polynomials are
; 278  : 	 * duplicate of odd powers' minimal polynomials.
; 279  : 	 * Odd powers of alpha (1 to 15)
; 280  : 	 */
; 281  : 	unsigned int pow_alpha[8] = {0x0002, 0x0008, 0x0020, 0x0080,

  00018	e3a00080	 mov         r0, #0x80

; 282  : 				 0x0200, 0x0800, 0x001B, 0x006C};

  0001c	e3a0ec02	 mov         lr, #2, 24
  00020	e3a04b02	 mov         r4, #2, 22
  00024	e58d0010	 str         r0, [sp, #0x10]
  00028	e58de014	 str         lr, [sp, #0x14]

; 283  : 
; 284  : 
; 285  : 	if (select_4_8 == 0) {
; 286  : 		t = 4;
; 287  : 		ecc_pos = 55; /* bits(52-bits): 55->4 */

  0002c	03a00037	 moveq       r0, #0x37

; 288  : 		ecc_min = 4;

  00030	03a0e004	 moveq       lr, #4
  00034	e3a02008	 mov         r2, #8
  00038	e58d4018	 str         r4, [sp, #0x18]

; 289  : 	} else {
; 290  : 		t = 8;
; 291  : 		ecc_pos = 103; /* bits: 103->0 */

  0003c	13a00067	 movne       r0, #0x67
  00040	03a04004	 moveq       r4, #4

; 292  : 		ecc_min = 0;

  00044	13a0e000	 movne       lr, #0
  00048	e58d2008	 str         r2, [sp, #8]
  0004c	13a04008	 movne       r4, #8

; 293  : 	}
; 294  : 
; 295  : 	/* total numbber of syndrom to be used is 2t */
; 296  : 	/* Step1: calculate the odd syndrome(s) */
; 297  : 	R_bit = ((ecc[ecc_pos/8] >> (7 - ecc_pos%8)) & 1);

  00050	e1b02000	 movs        r2, r0
  00054	e3a03002	 mov         r3, #2
  00058	42822007	 addmi       r2, r2, #7
  0005c	e58d3004	 str         r3, [sp, #4]
  00060	e1a031c2	 mov         r3, r2, asr #3
  00064	e0403183	 sub         r3, r0, r3, lsl #3
  00068	e7d621c2	 ldrb        r2, [r6, +r2, asr #3]
  0006c	e2633007	 rsb         r3, r3, #7
  00070	e20330ff	 and         r3, r3, #0xFF

; 298  : 	ecc_pos--;

  00074	e1a03332	 mov         r3, r2, lsr r3
  00078	e3a01020	 mov         r1, #0x20
  0007c	e3a0701b	 mov         r7, #0x1B
  00080	e3a0806c	 mov         r8, #0x6C
  00084	e58d100c	 str         r1, [sp, #0xC]
  00088	e58d701c	 str         r7, [sp, #0x1C]

; 299  : 	for (k = 0; k < t; k++)

  0008c	e2031001	 and         r1, r3, #1
  00090	e58d8020	 str         r8, [sp, #0x20]
  00094	e2407001	 sub         r7, r0, #1
  00098	e3540000	 cmp         r4, #0
  0009c	0a000004	 beq         |$LN22@syndrome|
  000a0	e1a03005	 mov         r3, r5
  000a4	e1a02004	 mov         r2, r4
  000a8		 |$LL16@syndrome|

; 300  : 		syn[2 * k] = R_bit;

  000a8	e4831008	 str         r1, [r3], #8
  000ac	e2522001	 subs        r2, r2, #1
  000b0	1afffffc	 bne         |$LL16@syndrome|
  000b4		 |$LN22@syndrome|

; 301  : 
; 302  : 	while (ecc_pos >= ecc_min) {

  000b4	e157000e	 cmp         r7, lr
  000b8	ba00002b	 blt         |$LN12@syndrome|
  000bc	e3a03c0f	 mov         r3, #0xF, 24
  000c0	e383b0ff	 orr         r11, r3, #0xFF
  000c4		 |$LL13@syndrome|

; 303  : 		R_bit = ((ecc[ecc_pos/8] >> (7 - ecc_pos%8)) & 1);

  000c4	e1b02007	 movs        r2, r7
  000c8	42822007	 addmi       r2, r2, #7
  000cc	e1a031c2	 mov         r3, r2, asr #3
  000d0	e0473183	 sub         r3, r7, r3, lsl #3
  000d4	e7d621c2	 ldrb        r2, [r6, +r2, asr #3]
  000d8	e2633007	 rsb         r3, r3, #7
  000dc	e20330ff	 and         r3, r3, #0xFF

; 304  : 		ecc_pos--;

  000e0	e1a03332	 mov         r3, r2, lsr r3
  000e4	e2477001	 sub         r7, r7, #1

; 305  : 
; 306  : 		for (k = 0; k < t; k++) {

  000e8	e203a001	 and         r10, r3, #1
  000ec	e3540000	 cmp         r4, #0
  000f0	0a00001b	 beq         |$LN9@syndrome|
  000f4	e3a00001	 mov         r0, #1
  000f8	e28d1004	 add         r1, sp, #4
  000fc	e1a06005	 mov         r6, r5
  00100	e1a09004	 mov         r9, r4
  00104		 |$LL11@syndrome|

; 307  : 			/* Accumulate value of x^i at alpha^(2k+1) */
; 308  : 			if (R_bit == 1)

  00104	e35a0001	 cmp         r10, #1

; 309  : 				syn[2*k] ^= pow_alpha[k];

  00108	05912000	 ldreq       r2, [r1]
  0010c	05963000	 ldreq       r3, [r6]
  00110	00223003	 eoreq       r3, r2, r3
  00114	05863000	 streq       r3, [r6]

; 310  : 
; 311  : 			/* Compute a**(2k+1), using LSFR */
; 312  : 			for (l = 0; l < (2 * k + 1); l++) {

  00118	e3500000	 cmp         r0, #0
  0011c	0a00000a	 beq         |$LN10@syndrome|
  00120	e5912000	 ldr         r2, [r1]
  00124	e1a08000	 mov         r8, r0
  00128		 |$LL7@syndrome|

; 313  : 				alpha_bit = (pow_alpha[k] >> POLY) & 1;

  00128	e1a03982	 mov         r3, r2, lsl #19
  0012c	e1a03fa3	 mov         r3, r3, lsr #31

; 314  : 				pow_alpha[k] = (pow_alpha[k] << 1) & 0x1FFF;

  00130	e002200b	 and         r2, r2, r11

; 315  : 				if (alpha_bit == 1)

  00134	e3530001	 cmp         r3, #1
  00138	e1a02082	 mov         r2, r2, lsl #1

; 316  : 					pow_alpha[k] ^= P;

  0013c	0222201b	 eoreq       r2, r2, #0x1B
  00140	e2588001	 subs        r8, r8, #1
  00144	1afffff7	 bne         |$LL7@syndrome|

; 310  : 
; 311  : 			/* Compute a**(2k+1), using LSFR */
; 312  : 			for (l = 0; l < (2 * k + 1); l++) {

  00148	e5812000	 str         r2, [r1]
  0014c		 |$LN10@syndrome|

; 305  : 
; 306  : 		for (k = 0; k < t; k++) {

  0014c	e2866008	 add         r6, r6, #8
  00150	e2811004	 add         r1, r1, #4
  00154	e2800002	 add         r0, r0, #2
  00158	e2599001	 subs        r9, r9, #1
  0015c	1affffe8	 bne         |$LL11@syndrome|

; 271  : {

  00160	e59d6000	 ldr         r6, [sp]
  00164		 |$LN9@syndrome|

; 301  : 
; 302  : 	while (ecc_pos >= ecc_min) {

  00164	e157000e	 cmp         r7, lr
  00168	aaffffd5	 bge         |$LL13@syndrome|
  0016c		 |$LN12@syndrome|

; 317  : 			}
; 318  : 		}
; 319  : 	}
; 320  : 
; 321  : 	/* Step2: calculate the even syndrome(s)
; 322  : 	 * Compute S(a), where a is an even power of alpha
; 323  : 	 * Evenry even power of primitive element has the same minimal
; 324  : 	 * polynomial as some odd power of elemets.
; 325  : 	 * And based on S(a^2) = S^2(a)
; 326  : 	 */
; 327  : 	for (k = 0; k < t; k++)

  0016c	e3540000	 cmp         r4, #0
  00170	0a000007	 beq         |$LN1@syndrome|
  00174	e1a06005	 mov         r6, r5
  00178		 |$LL3@syndrome|

; 328  : 		syn[2*k+1] = mpy_mod_gf(syn[k], syn[k]);

  00178	e4960004	 ldr         r0, [r6], #4
  0017c	e1a01000	 mov         r1, r0
  00180	eb000000	 bl          mpy_mod_gf
  00184	e5850004	 str         r0, [r5, #4]
  00188	e2855008	 add         r5, r5, #8
  0018c	e2544001	 subs        r4, r4, #1
  00190	1afffff8	 bne         |$LL3@syndrome|
  00194		 |$LN1@syndrome|

; 329  : 
; 330  : }

  00194	e28dd024	 add         sp, sp, #0x24
  00198	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0019c	e12fff1e	 bx          lr
  001a0		 |$M706|

			 ENDP  ; |syndrome|

	EXPORT	|decode_bch|

  00000			 AREA	 |.pdata|, PDATA
|$T721|	DCD	|$LN6@decode_bch|
	DCD	0x40002302
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |decode_bch| PROC

; 346  : {

  00000		 |$LN6@decode_bch|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd060	 sub         sp, sp, #0x60
  00008		 |$M718|
  00008	e1a06002	 mov         r6, r2
  0000c	e1a04001	 mov         r4, r1
  00010	e1a05000	 mov         r5, r0

; 347  : 	int no_of_err;
; 348  : 	unsigned int syn[16] = {0,};	/* 16 Syndromes */

  00014	e3a03000	 mov         r3, #0
  00018	e3a0203c	 mov         r2, #0x3C
  0001c	e3a01000	 mov         r1, #0
  00020	e28d0024	 add         r0, sp, #0x24
  00024	e58d3020	 str         r3, [sp, #0x20]
  00028	eb000000	 bl          memset

; 349  : 	unsigned int err_poly[8] = {0,};

  0002c	e3a03000	 mov         r3, #0
  00030	e3a0201c	 mov         r2, #0x1C
  00034	e3a01000	 mov         r1, #0
  00038	e28d0004	 add         r0, sp, #4
  0003c	e58d3000	 str         r3, [sp]
  00040	eb000000	 bl          memset

; 350  : 	/* Coefficients to the error polynomial
; 351  : 	 * ELP(x) = 1 + err0.x + err1.x^2 + ... + err7.x^8
; 352  : 	 */
; 353  : 
; 354  : 	/* Decoting involes three steps
; 355  : 	 * 1. Compute the syndrom from teh received codeword,
; 356  : 	 * 2. Find the error location polynomial from a set of equations
; 357  : 	 *     derived from the syndrome,
; 358  : 	 * 3. Use the error location polynomial to identify errants bits,
; 359  : 	 *
; 360  : 	 * And correcttion done by bit flips using error locaiton and expected
; 361  : 	 * to be outseide of this implementation.
; 362  : 	 */
; 363  : 	syndrome(select_4_8, ecc, syn);

  00044	e28d2020	 add         r2, sp, #0x20
  00048	e1a01004	 mov         r1, r4
  0004c	e1a00005	 mov         r0, r5
  00050	eb000000	 bl          syndrome

; 364  : 	no_of_err = berlekamp(select_4_8, syn, err_poly);

  00054	e28d2000	 add         r2, sp, #0
  00058	e28d1020	 add         r1, sp, #0x20
  0005c	e1a00005	 mov         r0, r5
  00060	eb000000	 bl          berlekamp

; 365  : 	if (no_of_err <= (4 << select_4_8))

  00064	e3a03004	 mov         r3, #4
  00068	e1500513	 cmp         r0, r3, lsl r5

; 366  : 		no_of_err = chien(select_4_8, no_of_err, err_poly, err_loc);

  0006c	d1a01000	 movle       r1, r0
  00070	d1a00005	 movle       r0, r5
  00074	d1a03006	 movle       r3, r6
  00078	d28d2000	 addle       r2, sp, #0
  0007c	db000000	 blle        chien

; 367  : 
; 368  : 	return no_of_err;
; 369  : }

  00080	e28dd060	 add         sp, sp, #0x60
  00084	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00088	e12fff1e	 bx          lr
  0008c		 |$M719|

			 ENDP  ; |decode_bch|

	END
