; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\BLOCK\NAND\fmd.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.bss|, NOINIT
|s_hNand| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|InitializePointers|

  00000			 AREA	 |.pdata|, PDATA
|$T46541| DCD	|$LN5@Initialize|
	DCD	0x40000a04
; Function compile flags: /Odtp
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\block\nand\fmd.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |InitializePointers| PROC

; 263  : {

  00000		 |$LN5@Initialize|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46538|

; 264  : #ifdef BOOT_MODE
; 265  :     UNREFERENCED_PARAMETER(szContext);
; 266  :     UNREFERENCED_PARAMETER(pDevice);
; 267  : #else
; 268  :     PHYSICAL_ADDRESS pa;
; 269  :     InitializeCriticalSection(&pDevice->cs);
; 270  : 
; 271  :     // Read device parameters
; 272  :     if (GetDeviceRegistryParams(
; 273  :             szContext, pDevice, dimof(g_deviceRegParams), g_deviceRegParams
; 274  :             ) != ERROR_SUCCESS)
; 275  :         {
; 276  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 277  :             L"Failed read FMD registry parameters\r\n"
; 278  :             ));
; 279  :         return FALSE;
; 280  :         }
; 281  : 
; 282  :     pa.QuadPart = pDevice->memBase[0];
; 283  :     pDevice->pGpmcRegs = MmMapIoSpace(pa, pDevice->memLen[0], FALSE);
; 284  :     if (pDevice->pGpmcRegs == NULL)
; 285  :         {
; 286  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 287  :             L"Failed map FMD registers (0x%08x/0x%08x)\r\n",
; 288  :             pDevice->memBase[0], pDevice->memLen[0]
; 289  :             ));
; 290  :         return FALSE;
; 291  :         }
; 292  : 
; 293  :     pa.QuadPart = pDevice->memBase[1];
; 294  :     pDevice->pFifo = (NANDREG*)MmMapIoSpace(pa, pDevice->memLen[1], FALSE);
; 295  :     if (pDevice->pFifo == NULL)
; 296  :         {
; 297  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: FMD_Init: "
; 298  :             L"Failed map FMD registers (0x%08x/0x%08x)\r\n",
; 299  :             pDevice->memBase[0], pDevice->memLen[0]
; 300  :             ));
; 301  :         return FALSE;
; 302  :         }
; 303  : #endif
; 304  :      return TRUE;

  00010	e3a03001	 mov         r3, #1
  00014	e58d3000	 str         r3, [sp]

; 305  : }

  00018	e59d0000	 ldr         r0, [sp]
  0001c	e28dd004	 add         sp, sp, #4
  00020	e89d6000	 ldmia       sp, {sp, lr}
  00024	e12fff1e	 bx          lr
  00028		 |$M46539|

			 ENDP  ; |InitializePointers|

	EXPORT	|NAND_CorrectEccData|
	IMPORT	|ECC_CorrectData|
	IMPORT	|memcmp|

  00008			 AREA	 |.pdata|, PDATA
|$T46548| DCD	|$LN7@NAND_Corre|
	DCD	0x40002804
; Function compile flags: /Odtp

  00028			 AREA	 |.text|, CODE, ARM

  00028		 |NAND_CorrectEccData| PROC

; 866  : {

  00028		 |$LN7@NAND_Corre|
  00028	e1a0c00d	 mov         r12, sp
  0002c	e92d000f	 stmdb       sp!, {r0 - r3}
  00030	e92d5000	 stmdb       sp!, {r12, lr}
  00034	e24dd01c	 sub         sp, sp, #0x1C
  00038		 |$M46545|

; 867  :     BOOL rc = FALSE;

  00038	e3a03000	 mov         r3, #0
  0003c	e58d3008	 str         r3, [sp, #8]

; 868  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  00040	e59d3024	 ldr         r3, [sp, #0x24]
  00044	e58d3004	 str         r3, [sp, #4]

; 869  :     
; 870  :     // this call assumes the array size of pEccOld and pEccNew are of the 
; 871  :     // correct size to hold all the parity bits of the given size    
; 872  :     if (memcmp(pEccOld, pEccNew, pDevice->ECCsize) != 0)

  00048	e59d3004	 ldr         r3, [sp, #4]
  0004c	e2833064	 add         r3, r3, #0x64
  00050	e5932000	 ldr         r2, [r3]
  00054	e59d1034	 ldr         r1, [sp, #0x34]
  00058	e59d0030	 ldr         r0, [sp, #0x30]
  0005c	eb000000	 bl          memcmp
  00060	e58d0014	 str         r0, [sp, #0x14]
  00064	e59d3014	 ldr         r3, [sp, #0x14]
  00068	e3530000	 cmp         r3, #0
  0006c	0a00000d	 beq         |$LN2@NAND_Corre|

; 873  :         {
; 874  :         
; 875  :         // check if data is correctable        
; 876  :         if (ECC_CorrectData(pDevice->pGpmcRegs, pData, size, pEccOld, pEccNew) == FALSE)

  00070	e59d3034	 ldr         r3, [sp, #0x34]
  00074	e58d3000	 str         r3, [sp]
  00078	e59d3030	 ldr         r3, [sp, #0x30]
  0007c	e59d202c	 ldr         r2, [sp, #0x2C]
  00080	e59d1028	 ldr         r1, [sp, #0x28]
  00084	e59d0004	 ldr         r0, [sp, #4]
  00088	e280002c	 add         r0, r0, #0x2C
  0008c	e5900000	 ldr         r0, [r0]
  00090	eb000000	 bl          ECC_CorrectData
  00094	e58d0018	 str         r0, [sp, #0x18]
  00098	e59d3018	 ldr         r3, [sp, #0x18]
  0009c	e3530000	 cmp         r3, #0
  000a0	1a000000	 bne         |$LN1@NAND_Corre|

; 877  :             {
; 878  :             goto cleanUp;

  000a4	ea000001	 b           |$cleanUp$46263|
  000a8		 |$LN1@NAND_Corre|
  000a8		 |$LN2@NAND_Corre|

; 879  :             }
; 880  :         }    
; 881  : 
; 882  :     rc = TRUE;

  000a8	e3a03001	 mov         r3, #1
  000ac	e58d3008	 str         r3, [sp, #8]
  000b0		 |$cleanUp$46263|

; 883  :     
; 884  : cleanUp:
; 885  :     return rc;

  000b0	e59d3008	 ldr         r3, [sp, #8]
  000b4	e58d3010	 str         r3, [sp, #0x10]

; 886  : }

  000b8	e59d0010	 ldr         r0, [sp, #0x10]
  000bc	e28dd01c	 add         sp, sp, #0x1C
  000c0	e89d6000	 ldmia       sp, {sp, lr}
  000c4	e12fff1e	 bx          lr
  000c8		 |$M46546|

			 ENDP  ; |NAND_CorrectEccData|

	EXPORT	|FMD_Init|

  00010			 AREA	 |.pdata|, PDATA
|$T46554| DCD	|$LN6@FMD_Init|
	DCD	0x40001d04
; Function compile flags: /Odtp

  000c8			 AREA	 |.text|, CODE, ARM

  000c8		 |FMD_Init| PROC

; 909  : {

  000c8		 |$LN6@FMD_Init|
  000c8	e1a0c00d	 mov         r12, sp
  000cc	e92d0007	 stmdb       sp!, {r0 - r2}
  000d0	e92d5000	 stmdb       sp!, {r12, lr}
  000d4	e24dd00c	 sub         sp, sp, #0xC
  000d8		 |$M46551|

; 910  :     HANDLE hRet = NULL;

  000d8	e3a03000	 mov         r3, #0
  000dc	e58d3000	 str         r3, [sp]

; 911  : 
; 912  :     // Map NAND registers
; 913  :     s_hNand = NAND_Initialize(szContext, pRegIn, pRegOut);

  000e0	e59d201c	 ldr         r2, [sp, #0x1C]
  000e4	e59d1018	 ldr         r1, [sp, #0x18]
  000e8	e59d0014	 ldr         r0, [sp, #0x14]
  000ec	eb000000	 bl          NAND_Initialize
  000f0	e58d0008	 str         r0, [sp, #8]
  000f4	e59d2008	 ldr         r2, [sp, #8]
  000f8	e59f3038	 ldr         r3, [pc, #0x38]
  000fc	e5832000	 str         r2, [r3]

; 914  :     if (s_hNand == NULL)

  00100	e59f3030	 ldr         r3, [pc, #0x30]
  00104	e5933000	 ldr         r3, [r3]
  00108	e3530000	 cmp         r3, #0
  0010c	1a000000	 bne         |$LN1@FMD_Init|

; 915  :         {
; 916  :         goto cleanUp;

  00110	ea000002	 b           |$cleanUp$46282|
  00114		 |$LN1@FMD_Init|

; 917  :         }
; 918  :         
; 919  :     // We are done
; 920  :     hRet = s_hNand;

  00114	e59f301c	 ldr         r3, [pc, #0x1C]
  00118	e5933000	 ldr         r3, [r3]
  0011c	e58d3000	 str         r3, [sp]
  00120		 |$cleanUp$46282|

; 921  : 
; 922  : cleanUp:
; 923  :     return hRet;

  00120	e59d3000	 ldr         r3, [sp]
  00124	e58d3004	 str         r3, [sp, #4]

; 924  : }

  00128	e59d0004	 ldr         r0, [sp, #4]
  0012c	e28dd00c	 add         sp, sp, #0xC
  00130	e89d6000	 ldmia       sp, {sp, lr}
  00134	e12fff1e	 bx          lr
  00138		 |$LN7@FMD_Init|
  00138		 |$LN8@FMD_Init|
  00138	00000000	 DCD         |s_hNand|
  0013c		 |$M46552|

			 ENDP  ; |FMD_Init|

	EXPORT	|??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DK@CAAJGKFH@?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5?$AAE?$AAC?$AAC?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|ECC_Reset|
	IMPORT	|ECC_Init|
	IMPORT	|BSPGetNandIrqWait|
	IMPORT	|BSPGetNandInfo|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|g_ecctype|
	IMPORT	|OALPAtoVA|
	IMPORT	|SOCGetGPMCAddress|
	IMPORT	|memset|
	IMPORT	|BSPGetNandCS|
	IMPORT	|memcpy|

  00004			 AREA	 |.bss|, NOINIT
|s_Device| %	0x68

  00018			 AREA	 |.pdata|, PDATA
|$T46567| DCD	|$LN15@NAND_Initi|
	DCD	0x40011504

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@| DCB "F"
	DCB	0x0, "M", 0x0, "D", 0x0, " ", 0x0, "d", 0x0, "r", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "u"
	DCB	0x0, "p", 0x0, "p", 0x0, "o", 0x0, "r", 0x0, "t", 0x0, "s"
	DCB	0x0, " ", 0x0, "o", 0x0, "n", 0x0, "l", 0x0, "y", 0x0, " "
	DCB	0x0, "1", 0x0, "6", 0x0, "b", 0x0, "i", 0x0, "t", 0x0, "s"
	DCB	0x0, " ", 0x0, "l", 0x0, "a", 0x0, "r", 0x0, "g", 0x0, "e"
	DCB	0x0, " ", 0x0, "p", 0x0, "a", 0x0, "g", 0x0, "e", 0x0, " "
	DCB	0x0, "(", 0x0, "2", 0x0, "K", 0x0, "B", 0x0, ")", 0x0, " "
	DCB	0x0, "d", 0x0, "e", 0x0, "v", 0x0, "i", 0x0, "c", 0x0, "e"
	DCB	0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "%", 0x0, "s", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ":", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@| DCB "C"
	DCB	0x0, ":", 0x0, "\\", 0x0, "W", 0x0, "I", 0x0, "N", 0x0, "C"
	DCB	0x0, "E", 0x0, "6", 0x0, "0", 0x0, "0", 0x0, "\\", 0x0, "P"
	DCB	0x0, "L", 0x0, "A", 0x0, "T", 0x0, "F", 0x0, "O", 0x0, "R"
	DCB	0x0, "M", 0x0, "\\", 0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M"
	DCB	0x0, "O", 0x0, "N", 0x0, "\\", 0x0, "S", 0x0, "R", 0x0, "C"
	DCB	0x0, "\\", 0x0, "S", 0x0, "O", 0x0, "C", 0x0, "\\", 0x0, "C"
	DCB	0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N", 0x0, "_"
	DCB	0x0, "T", 0x0, "I", 0x0, "_", 0x0, "V", 0x0, "1", 0x0, "\\"
	DCB	0x0, "C", 0x0, "O", 0x0, "M", 0x0, "M", 0x0, "O", 0x0, "N"
	DCB	0x0, "_", 0x0, "T", 0x0, "I", 0x0, "\\", 0x0, "B", 0x0, "L"
	DCB	0x0, "O", 0x0, "C", 0x0, "K", 0x0, "\\", 0x0, "N", 0x0, "A"
	DCB	0x0, "N", 0x0, "D", 0x0, "\\", 0x0, "B", 0x0, "O", 0x0, "O"
	DCB	0x0, "T", 0x0, "\\", 0x0, ".", 0x0, ".", 0x0, "\\", 0x0, "f"
	DCB	0x0, "m", 0x0, "d", 0x0, ".", 0x0, "c", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DK@CAAJGKFH@?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5?$AAE?$AAC?$AAC?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@| DCB "I"
	DCB	0x0, "n", 0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "E", 0x0, "C", 0x0, "C"
	DCB	0x0, " ", 0x0, "t", 0x0, "y", 0x0, "p", 0x0, "e", 0x0, " "
	DCB	0x0, "s", 0x0, "e", 0x0, "t", 0x0, "t", 0x0, "i", 0x0, "n"
	DCB	0x0, "g", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Odtp

  0013c			 AREA	 |.text|, CODE, ARM

  0013c		 |NAND_Initialize| PROC

; 389  : {

  0013c		 |$LN15@NAND_Initi|
  0013c	e1a0c00d	 mov         r12, sp
  00140	e92d0007	 stmdb       sp!, {r0 - r2}
  00144	e92d5000	 stmdb       sp!, {r12, lr}
  00148	e24dd044	 sub         sp, sp, #0x44
  0014c		 |$M46564|

; 390  :     DWORD chipSelect = BSPGetNandCS();

  0014c	eb000000	 bl          BSPGetNandCS
  00150	e58d0020	 str         r0, [sp, #0x20]
  00154	e59d3020	 ldr         r3, [sp, #0x20]
  00158	e58d3008	 str         r3, [sp, #8]

; 391  :     const NAND_INFO *  pBSPNandInfo;
; 392  :     HANDLE hDevice = NULL;

  0015c	e3a03000	 mov         r3, #0
  00160	e58d3004	 str         r3, [sp, #4]

; 393  :     UINT ffPrefetchMode = 0;

  00164	e3a03000	 mov         r3, #0
  00168	e58d3010	 str         r3, [sp, #0x10]

; 394  :     UINT8 manufacturer, device;
; 395  :     NandDevice_t *pDevice = &s_Device;

  0016c	e59f3418	 ldr         r3, [pc, #0x418]
  00170	e58d3000	 str         r3, [sp]

; 396  : #ifndef BOOT_MODE    
; 397  :     DWORD dwKernelRet;
; 398  : #endif
; 399  : 
; 400  :     UNREFERENCED_PARAMETER(pRegOut);
; 401  :     UNREFERENCED_PARAMETER(szContext);
; 402  :     // initialize structure
; 403  :     memset(pDevice, 0, sizeof(NandDevice_t));

  00174	e3a02068	 mov         r2, #0x68
  00178	e3a01000	 mov         r1, #0
  0017c	e59d0000	 ldr         r0, [sp]
  00180	eb000000	 bl          memset

; 404  : 
; 405  : #ifdef BOOT_MODE    
; 406  :     pDevice->pGpmcRegs = (OMAP_GPMC_REGS*)OALPAtoUA(SOCGetGPMCAddress(0));

  00184	e3a00000	 mov         r0, #0
  00188	eb000000	 bl          SOCGetGPMCAddress
  0018c	e58d0024	 str         r0, [sp, #0x24]
  00190	e3a01000	 mov         r1, #0
  00194	e59d0024	 ldr         r0, [sp, #0x24]
  00198	eb000000	 bl          OALPAtoVA
  0019c	e58d0028	 str         r0, [sp, #0x28]
  001a0	e59d3000	 ldr         r3, [sp]
  001a4	e283202c	 add         r2, r3, #0x2C
  001a8	e59d3028	 ldr         r3, [sp, #0x28]
  001ac	e5823000	 str         r3, [r2]

; 407  :     pDevice->pFifo = (NANDREG*)OALPAtoUA(pRegIn->MemBase.Reg[0]);

  001b0	e3a01000	 mov         r1, #0
  001b4	e59d3050	 ldr         r3, [sp, #0x50]
  001b8	e2833e31	 add         r3, r3, #0x31, 28
  001bc	e5930000	 ldr         r0, [r3]
  001c0	eb000000	 bl          OALPAtoVA
  001c4	e58d002c	 str         r0, [sp, #0x2C]
  001c8	e59d3000	 ldr         r3, [sp]
  001cc	e2832028	 add         r2, r3, #0x28
  001d0	e59d302c	 ldr         r3, [sp, #0x2C]
  001d4	e5823000	 str         r3, [r2]

; 408  : 
; 409  :     /* Get ECC mode from BootCfg */
; 410  :     pDevice->ECCtype = g_ecctype;

  001d8	e59d3000	 ldr         r3, [sp]
  001dc	e2832060	 add         r2, r3, #0x60
  001e0	e59f33a0	 ldr         r3, [pc, #0x3A0]
  001e4	e5d33000	 ldrb        r3, [r3]
  001e8	e5823000	 str         r3, [r2]

; 411  :     if((pDevice->ECCtype > BCH8bit) || (pDevice->ECCtype < Hamming1bit))

  001ec	e59d3000	 ldr         r3, [sp]
  001f0	e2833060	 add         r3, r3, #0x60
  001f4	e5933000	 ldr         r3, [r3]
  001f8	e3530002	 cmp         r3, #2
  001fc	ca000004	 bgt         |$LN5@NAND_Initi|
  00200	e59d3000	 ldr         r3, [sp]
  00204	e2833060	 add         r3, r3, #0x60
  00208	e5933000	 ldr         r3, [r3]
  0020c	e3530000	 cmp         r3, #0
  00210	aa000005	 bge         |$LN6@NAND_Initi|
  00214		 |$LN5@NAND_Initi|

; 412  :     	{
; 413  :             pDevice->ECCtype = Hamming1bit;

  00214	e59d3000	 ldr         r3, [sp]
  00218	e2832060	 add         r2, r3, #0x60
  0021c	e3a03000	 mov         r3, #0
  00220	e5823000	 str         r3, [r2]

; 414  :             RETAILMSG(TRUE, (L"Incorrect ECC type setting\r\n"));			

  00224	e59f0358	 ldr         r0, [pc, #0x358]
  00228	eb000000	 bl          NKDbgPrintfW
  0022c		 |$LN6@NAND_Initi|

; 415  :     	}
; 416  : #else    
; 417  :     if (szContext != NULL)
; 418  :         {
; 419  :         if (InitializePointers(szContext, pDevice) == FALSE) goto cleanUp;
; 420  :         }
; 421  :     else
; 422  :         {
; 423  :         PHYSICAL_ADDRESS pa;
; 424  :         
; 425  :         // if there's not context string then use global macros
; 426  : 
; 427  :         pa.QuadPart = pRegIn->MemBase.Reg[0];
; 428  :         pDevice->memLen[0] = pRegIn->MemLen.Reg[0];
; 429  :         pDevice->pGpmcRegs = MmMapIoSpace(pa, pDevice->memLen[0], FALSE);
; 430  :         if (pDevice->pGpmcRegs == NULL) goto cleanUp;
; 431  : 
; 432  :         pa.QuadPart = pRegIn->MemBase.Reg[1];
; 433  :         pDevice->memLen[1] = pRegIn->MemLen.Reg[1];
; 434  :         pDevice->pFifo = MmMapIoSpace(pa, pDevice->memLen[1], FALSE);
; 435  :         if (pDevice->pGpmcRegs == NULL) goto cleanUp;
; 436  : 
; 437  :         }
; 438  : 
; 439  : 
; 440  :         if (!KernelIoControl(IOCTL_HAL_GET_ECC_TYPE,
; 441  :                              NULL, 0, &pDevice->ECCtype, sizeof(DWORD), &dwKernelRet))
; 442  :         {
; 443  :             RETAILMSG( TRUE,(TEXT("Failed to read Ecc type\r\n")));
; 444  :             pDevice->ECCtype = Hamming1bit;
; 445  :         }   
; 446  : 	
; 447  :         RETAILMSG(TRUE, (L"ECC TYPE is %s\r\n", (pDevice->ECCtype==Hamming1bit)? L"Hamming 1 bit" :
; 448  : 			                                                    (pDevice->ECCtype==BCH4bit)? L"BCH 4 bit" : L"BCH 8 bit"));
; 449  : 	
; 450  : #endif
; 451  : 
; 452  :     pDevice->pNandCmd = (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_COMMAND_0) + (0x30 * chipSelect));

  0022c	e59d3000	 ldr         r3, [sp]
  00230	e283302c	 add         r3, r3, #0x2C
  00234	e5933000	 ldr         r3, [r3]
  00238	e283107c	 add         r1, r3, #0x7C
  0023c	e59d2008	 ldr         r2, [sp, #8]
  00240	e3a03030	 mov         r3, #0x30
  00244	e0030392	 mul         r3, r2, r3
  00248	e0812003	 add         r2, r1, r3
  0024c	e59d3000	 ldr         r3, [sp]
  00250	e283301c	 add         r3, r3, #0x1C
  00254	e5832000	 str         r2, [r3]

; 453  :     pDevice->pNandAddress= (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_ADDRESS_0) + (0x30 * chipSelect));

  00258	e59d3000	 ldr         r3, [sp]
  0025c	e283302c	 add         r3, r3, #0x2C
  00260	e5933000	 ldr         r3, [r3]
  00264	e2831080	 add         r1, r3, #0x80
  00268	e59d2008	 ldr         r2, [sp, #8]
  0026c	e3a03030	 mov         r3, #0x30
  00270	e0030392	 mul         r3, r2, r3
  00274	e0812003	 add         r2, r1, r3
  00278	e59d3000	 ldr         r3, [sp]
  0027c	e2833020	 add         r3, r3, #0x20
  00280	e5832000	 str         r2, [r3]

; 454  :     pDevice->pNandData= (NANDREG*)((UINT32)pDevice->pGpmcRegs + offset(OMAP_GPMC_REGS, GPMC_NAND_DATA_0) + (0x30 * chipSelect));

  00284	e59d3000	 ldr         r3, [sp]
  00288	e283302c	 add         r3, r3, #0x2C
  0028c	e5933000	 ldr         r3, [r3]
  00290	e2831084	 add         r1, r3, #0x84
  00294	e59d2008	 ldr         r2, [sp, #8]
  00298	e3a03030	 mov         r3, #0x30
  0029c	e0030392	 mul         r3, r2, r3
  002a0	e0812003	 add         r2, r1, r3
  002a4	e59d3000	 ldr         r3, [sp]
  002a8	e2833024	 add         r3, r3, #0x24
  002ac	e5832000	 str         r2, [r3]

; 455  :     // Enable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 456  :     NAND_Enable(pDevice, TRUE);

  002b0	e3a01001	 mov         r1, #1
  002b4	e59d0000	 ldr         r0, [sp]
  002b8	eb000000	 bl          NAND_Enable

; 457  : 
; 458  :     // Write RESET command
; 459  :     // (a reset aborts any current READ, WRITE (PROGRAM) or ERASE operation)
; 460  :     NAND_SendCommand(pDevice, NAND_CMD_RESET);

  002bc	e3a010ff	 mov         r1, #0xFF
  002c0	e59d0000	 ldr         r0, [sp]
  002c4	eb000000	 bl          NAND_SendCommand
  002c8		 |$LN4@NAND_Initi|

; 461  : 
; 462  :     // Wait for NAND
; 463  :     while ((NAND_GetStatus(pDevice) & NAND_STATUS_READY) == 0);

  002c8	e59d0000	 ldr         r0, [sp]
  002cc	eb000000	 bl          NAND_GetStatus
  002d0	e1a03800	 mov         r3, r0, lsl #16
  002d4	e1a03823	 mov         r3, r3, lsr #16
  002d8	e1cd33b0	 strh        r3, [sp, #0x30]
  002dc	e1dd33b0	 ldrh        r3, [sp, #0x30]
  002e0	e3130040	 tst         r3, #0x40
  002e4	1a000000	 bne         |$LN3@NAND_Initi|
  002e8	eafffff6	 b           |$LN4@NAND_Initi|
  002ec		 |$LN3@NAND_Initi|

; 464  : 
; 465  :     // Send Read ID Command
; 466  :     NAND_SendCommand(pDevice, NAND_CMD_READID);

  002ec	e3a01090	 mov         r1, #0x90
  002f0	e59d0000	 ldr         r0, [sp]
  002f4	eb000000	 bl          NAND_SendCommand

; 467  : 
; 468  :     // Send Address 00h
; 469  :     WRITE_NAND(pDevice->pNandAddress, 0);

  002f8	e59d3000	 ldr         r3, [sp]
  002fc	e2833020	 add         r3, r3, #0x20
  00300	e5932000	 ldr         r2, [r3]
  00304	e3a03000	 mov         r3, #0
  00308	e1c230b0	 strh        r3, [r2]

; 470  : 
; 471  :     // Read the manufacturer ID & device code
; 472  :     manufacturer = (UINT8)READ_NAND(pDevice->pNandData);

  0030c	e59d3000	 ldr         r3, [sp]
  00310	e2833024	 add         r3, r3, #0x24
  00314	e5933000	 ldr         r3, [r3]
  00318	e1d330b0	 ldrh        r3, [r3]
  0031c	e20330ff	 and         r3, r3, #0xFF
  00320	e5cd3014	 strb        r3, [sp, #0x14]

; 473  :     device = (UINT8)READ_NAND(pDevice->pNandData);

  00324	e59d3000	 ldr         r3, [sp]
  00328	e2833024	 add         r3, r3, #0x24
  0032c	e5933000	 ldr         r3, [r3]
  00330	e1d330b0	 ldrh        r3, [r3]
  00334	e20330ff	 and         r3, r3, #0xFF
  00338	e5cd300c	 strb        r3, [sp, #0xC]

; 474  : 
; 475  :  
; 476  :     if ((pBSPNandInfo = BSPGetNandInfo(manufacturer,device))==NULL)

  0033c	e5dd100c	 ldrb        r1, [sp, #0xC]
  00340	e5dd0014	 ldrb        r0, [sp, #0x14]
  00344	eb000000	 bl          BSPGetNandInfo
  00348	e58d0034	 str         r0, [sp, #0x34]
  0034c	e59d3034	 ldr         r3, [sp, #0x34]
  00350	e58d3018	 str         r3, [sp, #0x18]
  00354	e59d3018	 ldr         r3, [sp, #0x18]
  00358	e3530000	 cmp         r3, #0
  0035c	1a000000	 bne         |$LN2@NAND_Initi|

; 477  :     {                
; 478  :         goto cleanUp;

  00360	ea00007e	 b           |$cleanUp$46069|
  00364		 |$LN2@NAND_Initi|

; 479  :     }
; 480  :     if ((pBSPNandInfo->sectorSize != 2048) && (pBSPNandInfo->wordData != 2))

  00364	e59d3018	 ldr         r3, [sp, #0x18]
  00368	e283300c	 add         r3, r3, #0xC
  0036c	e5933000	 ldr         r3, [r3]
  00370	e3530b02	 cmp         r3, #2, 22
  00374	0a00000c	 beq         |$LN1@NAND_Initi|
  00378	e59d3018	 ldr         r3, [sp, #0x18]
  0037c	e2833010	 add         r3, r3, #0x10
  00380	e5933000	 ldr         r3, [r3]
  00384	e3530002	 cmp         r3, #2
  00388	0a000007	 beq         |$LN1@NAND_Initi|

; 481  :     {
; 482  :         ERRORMSG(1,(TEXT("FMD driver supports only 16bits large page (2KB) devices\r\n")));

  0038c	e3a02c01	 mov         r2, #1, 24
  00390	e38220e2	 orr         r2, r2, #0xE2
  00394	e59f11e4	 ldr         r1, [pc, #0x1E4]
  00398	e59f01dc	 ldr         r0, [pc, #0x1DC]
  0039c	eb000000	 bl          NKDbgPrintfW
  003a0	e59f01d0	 ldr         r0, [pc, #0x1D0]
  003a4	eb000000	 bl          NKDbgPrintfW

; 483  :         goto cleanUp;

  003a8	ea00006c	 b           |$cleanUp$46069|
  003ac		 |$LN1@NAND_Initi|

; 484  :     }
; 485  :     pDevice->nandInfo = *pBSPNandInfo;

  003ac	e59d1018	 ldr         r1, [sp, #0x18]
  003b0	e59d3000	 ldr         r3, [sp]
  003b4	e2830044	 add         r0, r3, #0x44
  003b8	e3a02014	 mov         r2, #0x14
  003bc	eb000000	 bl          memcpy

; 486  : 
; 487  :     pDevice->IrqWait = BSPGetNandIrqWait();

  003c0	eb000000	 bl          BSPGetNandIrqWait
  003c4	e58d0038	 str         r0, [sp, #0x38]
  003c8	e59d3000	 ldr         r3, [sp]
  003cc	e283205c	 add         r2, r3, #0x5C
  003d0	e59d3038	 ldr         r3, [sp, #0x38]
  003d4	e5823000	 str         r3, [r2]

; 488  : 
; 489  :     /* ECCCfg: 16bit bus width, cs0, 4 - 512 bytes blocks per page */
; 490  :     pDevice->ECCCfg = (GPMC_ECC_CONFIG_16BIT | (chipSelect << 1) | (0x3<<4)); 

  003d8	e59d3008	 ldr         r3, [sp, #8]
  003dc	e1a03083	 mov         r3, r3, lsl #1
  003e0	e3833080	 orr         r3, r3, #0x80
  003e4	e3832030	 orr         r2, r3, #0x30
  003e8	e59d3000	 ldr         r3, [sp]
  003ec	e2833058	 add         r3, r3, #0x58
  003f0	e5832000	 str         r2, [r3]

; 491  :     pDevice->ECCsize = (pDevice->ECCtype == Hamming1bit ) ? ECC_BYTES_HAMMING : 
; 492  : 		                      (pDevice->ECCtype == BCH4bit ) ? ECC_BYTES_BCH4 : ECC_BYTES_BCH8; 

  003f4	e59d3000	 ldr         r3, [sp]
  003f8	e2833060	 add         r3, r3, #0x60
  003fc	e5933000	 ldr         r3, [r3]
  00400	e3530000	 cmp         r3, #0
  00404	1a000002	 bne         |$LN11@NAND_Initi|
  00408	e3a0300c	 mov         r3, #0xC
  0040c	e58d303c	 str         r3, [sp, #0x3C]
  00410	ea00000b	 b           |$LN12@NAND_Initi|
  00414		 |$LN11@NAND_Initi|
  00414	e59d3000	 ldr         r3, [sp]
  00418	e2833060	 add         r3, r3, #0x60
  0041c	e5933000	 ldr         r3, [r3]
  00420	e3530001	 cmp         r3, #1
  00424	1a000002	 bne         |$LN9@NAND_Initi|
  00428	e3a0301c	 mov         r3, #0x1C
  0042c	e58d3040	 str         r3, [sp, #0x40]
  00430	ea000001	 b           |$LN10@NAND_Initi|
  00434		 |$LN9@NAND_Initi|
  00434	e3a03034	 mov         r3, #0x34
  00438	e58d3040	 str         r3, [sp, #0x40]
  0043c		 |$LN10@NAND_Initi|
  0043c	e59d3040	 ldr         r3, [sp, #0x40]
  00440	e58d303c	 str         r3, [sp, #0x3C]
  00444		 |$LN12@NAND_Initi|
  00444	e59d3000	 ldr         r3, [sp]
  00448	e2832064	 add         r2, r3, #0x64
  0044c	e59d303c	 ldr         r3, [sp, #0x3C]
  00450	e5823000	 str         r3, [r2]

; 493  : 							  
; 494  :     //  Enable and reset ECC engine (workaround for engine giving 0s first time)
; 495  :     ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_READ);

  00454	e3a03000	 mov         r3, #0
  00458	e59d2000	 ldr         r2, [sp]
  0045c	e2822060	 add         r2, r2, #0x60
  00460	e5922000	 ldr         r2, [r2]
  00464	e59d1000	 ldr         r1, [sp]
  00468	e2811058	 add         r1, r1, #0x58
  0046c	e5911000	 ldr         r1, [r1]
  00470	e59d0000	 ldr         r0, [sp]
  00474	e280002c	 add         r0, r0, #0x2C
  00478	e5900000	 ldr         r0, [r0]
  0047c	eb000000	 bl          ECC_Init

; 496  :     ECC_Reset(pDevice->pGpmcRegs);

  00480	e59d3000	 ldr         r3, [sp]
  00484	e283302c	 add         r3, r3, #0x2C
  00488	e5930000	 ldr         r0, [r3]
  0048c	eb000000	 bl          ECC_Reset

; 497  : 
; 498  :     //  Only enable during NAND read/write/erase operations
; 499  :     NAND_Enable(pDevice, FALSE);

  00490	e3a01000	 mov         r1, #0
  00494	e59d0000	 ldr         r0, [sp]
  00498	eb000000	 bl          NAND_Enable

; 500  : 
; 501  :     // configure the prefetch engine
; 502  :     pDevice->prefetchMode = kPrefetchOff;

  0049c	e59d3000	 ldr         r3, [sp]
  004a0	e2832018	 add         r2, r3, #0x18
  004a4	e3a03000	 mov         r3, #0
  004a8	e5823000	 str         r3, [r2]

; 503  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 0);

  004ac	e59d3000	 ldr         r3, [sp]
  004b0	e283302c	 add         r3, r3, #0x2C
  004b4	e5933000	 ldr         r3, [r3]
  004b8	e2832f7b	 add         r2, r3, #0x7B, 30
  004bc	e3a03000	 mov         r3, #0
  004c0	e5823000	 str         r3, [r2]

; 504  : 
; 505  :     // set prefetch mask
; 506  :     ffPrefetchMode = GPMC_PREFETCH_CONFIG_SYNCHROMODE |
; 507  :                      GPMC_PREFETCH_CONFIG_PFPWENROUNDROBIN |
; 508  :                      GPMC_PREFETCH_CONFIG_ENABLEOPTIMIZEDACCESS |
; 509  :                      GPMC_PREFETCH_CONFIG_WAITPINSELECTOR(chipSelect) |
; 510  :                      GPMC_PREFETCH_CONFIG_FIFOTHRESHOLD(FIFO_THRESHOLD) |
; 511  :                      GPMC_PREFETCH_CONFIG_ENGINECSSELECTOR(chipSelect);

  004c4	e59d3008	 ldr         r3, [sp, #8]
  004c8	e1a03203	 mov         r3, r3, lsl #4
  004cc	e2032030	 and         r2, r3, #0x30
  004d0	e3a03522	 mov         r3, #0x22, 10
  004d4	e3833008	 orr         r3, r3, #8
  004d8	e1823003	 orr         r3, r2, r3
  004dc	e3832901	 orr         r2, r3, #1, 18
  004e0	e59d3008	 ldr         r3, [sp, #8]
  004e4	e1a03c03	 mov         r3, r3, lsl #24
  004e8	e2033407	 and         r3, r3, #7, 8
  004ec	e1823003	 orr         r3, r2, r3
  004f0	e58d3010	 str         r3, [sp, #0x10]

; 512  : 
; 513  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, ffPrefetchMode);

  004f4	e59d3000	 ldr         r3, [sp]
  004f8	e283302c	 add         r3, r3, #0x2C
  004fc	e5933000	 ldr         r3, [r3]
  00500	e2832e1e	 add         r2, r3, #0x1E, 28
  00504	e59d3010	 ldr         r3, [sp, #0x10]
  00508	e5823000	 str         r3, [r2]

; 514  : 
; 515  :     // configure prefetch engine
; 516  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG2, 
; 517  :         pBSPNandInfo->sectorSize
; 518  :         );

  0050c	e59d3018	 ldr         r3, [sp, #0x18]
  00510	e283100c	 add         r1, r3, #0xC
  00514	e59d3000	 ldr         r3, [sp]
  00518	e283302c	 add         r3, r3, #0x2C
  0051c	e5933000	 ldr         r3, [r3]
  00520	e2832f79	 add         r2, r3, #0x79, 30
  00524	e5913000	 ldr         r3, [r1]
  00528	e5823000	 str         r3, [r2]

; 519  :         
; 520  :     SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, 
; 521  :         GPMC_PREFETCH_CONFIG_ENABLEENGINE
; 522  :         );

  0052c	e59d3000	 ldr         r3, [sp]
  00530	e283302c	 add         r3, r3, #0x2C
  00534	e5933000	 ldr         r3, [r3]
  00538	e2833e1e	 add         r3, r3, #0x1E, 28
  0053c	e5933000	 ldr         r3, [r3]
  00540	e3832080	 orr         r2, r3, #0x80
  00544	e59d3000	 ldr         r3, [sp]
  00548	e283302c	 add         r3, r3, #0x2C
  0054c	e5933000	 ldr         r3, [r3]
  00550	e2833e1e	 add         r3, r3, #0x1E, 28
  00554	e5832000	 str         r2, [r3]

; 523  : 
; 524  :     // We are done
; 525  :     hDevice = pDevice;

  00558	e59d3000	 ldr         r3, [sp]
  0055c	e58d3004	 str         r3, [sp, #4]
  00560		 |$cleanUp$46069|

; 526  : 
; 527  : cleanUp:
; 528  :     return hDevice;

  00560	e59d3004	 ldr         r3, [sp, #4]
  00564	e58d301c	 str         r3, [sp, #0x1C]

; 529  : }

  00568	e59d001c	 ldr         r0, [sp, #0x1C]
  0056c	e28dd044	 add         sp, sp, #0x44
  00570	e89d6000	 ldmia       sp, {sp, lr}
  00574	e12fff1e	 bx          lr
  00578		 |$LN16@NAND_Initi|
  00578		 |$LN17@NAND_Initi|
  00578	00000000	 DCD         |??_C@_1HG@DCOIKHPB@?$AAF?$AAM?$AAD?$AA?5?$AAd?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?5?$AAs?$AAu?$AAp?$AAp?$AAo?$AAr?$AAt?$AAs?$AA?5?$AAo?$AAn?$AAl?$AAy?$AA?5?$AA1?$AA6?$AAb?$AAi?$AAt?$AAs?$AA?5@|
  0057c		 |$LN18@NAND_Initi|
  0057c	00000000	 DCD         |??_C@_1CI@OHCJFJPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AAl?$AAi?$AAn?$AAe?$AA?5?$AA?$CF?$AAd?$AA?3?$AA?5?$AA?$AA@|
  00580		 |$LN19@NAND_Initi|
  00580	00000000	 DCD         |??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00584		 |$LN20@NAND_Initi|
  00584	00000000	 DCD         |??_C@_1DK@CAAJGKFH@?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5?$AAE?$AAC?$AAC?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AAs?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?$AN?$AA?6?$AA?$AA@|
  00588		 |$LN21@NAND_Initi|
  00588	00000000	 DCD         |g_ecctype|
  0058c		 |$LN22@NAND_Initi|
  0058c	00000000	 DCD         |s_Device|
  00590		 |$M46565|

			 ENDP  ; |NAND_Initialize|


  00020			 AREA	 |.pdata|, PDATA
|$T46580| DCD	|$LN5@NAND_GetSt|
	DCD	0x40001404
; Function compile flags: /Odtp

  00590			 AREA	 |.text|, CODE, ARM

  00590		 |NAND_GetStatus| PROC

; 714  : {

  00590		 |$LN5@NAND_GetSt|
  00590	e1a0c00d	 mov         r12, sp
  00594	e92d0001	 stmdb       sp!, {r0}
  00598	e92d5000	 stmdb       sp!, {r12, lr}
  0059c	e24dd008	 sub         sp, sp, #8
  005a0		 |$M46577|

; 715  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  005a0	e59d3010	 ldr         r3, [sp, #0x10]
  005a4	e58d3000	 str         r3, [sp]

; 716  : 
; 717  :     // request status
; 718  :     WRITE_NAND(pDevice->pNandCmd, NAND_CMD_STATUS);

  005a8	e59d3000	 ldr         r3, [sp]
  005ac	e283301c	 add         r3, r3, #0x1C
  005b0	e5932000	 ldr         r2, [r3]
  005b4	e3a03070	 mov         r3, #0x70
  005b8	e1c230b0	 strh        r3, [r2]

; 719  :     return READ_NAND(pDevice->pNandData);

  005bc	e59d3000	 ldr         r3, [sp]
  005c0	e2833024	 add         r3, r3, #0x24
  005c4	e5933000	 ldr         r3, [r3]
  005c8	e1d330b0	 ldrh        r3, [r3]
  005cc	e1cd30b4	 strh        r3, [sp, #4]

; 720  : }

  005d0	e1dd00b4	 ldrh        r0, [sp, #4]
  005d4	e28dd008	 add         sp, sp, #8
  005d8	e89d6000	 ldmia       sp, {sp, lr}
  005dc	e12fff1e	 bx          lr
  005e0		 |$M46578|

			 ENDP  ; |NAND_GetStatus|


  00028			 AREA	 |.pdata|, PDATA
|$T46586| DCD	|$LN8@NAND_Enabl|
	DCD	0x40004e04
; Function compile flags: /Odtp

  005e0			 AREA	 |.text|, CODE, ARM

  005e0		 |NAND_Enable| PROC

; 745  : {

  005e0		 |$LN8@NAND_Enabl|
  005e0	e1a0c00d	 mov         r12, sp
  005e4	e92d0003	 stmdb       sp!, {r0, r1}
  005e8	e92d5000	 stmdb       sp!, {r12, lr}
  005ec	e24dd008	 sub         sp, sp, #8
  005f0		 |$M46583|

; 746  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  005f0	e59d3010	 ldr         r3, [sp, #0x10]
  005f4	e58d3000	 str         r3, [sp]

; 747  : 
; 748  :     if (pDevice->IrqWait)

  005f8	e59d3000	 ldr         r3, [sp]
  005fc	e283305c	 add         r3, r3, #0x5C
  00600	e5933000	 ldr         r3, [r3]
  00604	e3530000	 cmp         r3, #0
  00608	0a00003c	 beq         |$LN3@NAND_Enabl|

; 749  :     {
; 750  :         if( bEnable )

  0060c	e59d3014	 ldr         r3, [sp, #0x14]
  00610	e3530000	 cmp         r3, #0
  00614	0a00001c	 beq         |$LN2@NAND_Enabl|

; 751  :         {
; 752  :             // Enable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 753  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQENABLE, pDevice->IrqWait);

  00618	e59d3000	 ldr         r3, [sp]
  0061c	e283302c	 add         r3, r3, #0x2C
  00620	e5933000	 ldr         r3, [r3]
  00624	e283201c	 add         r2, r3, #0x1C
  00628	e59d3000	 ldr         r3, [sp]
  0062c	e283305c	 add         r3, r3, #0x5C
  00630	e5922000	 ldr         r2, [r2]
  00634	e5933000	 ldr         r3, [r3]
  00638	e1822003	 orr         r2, r2, r3
  0063c	e59d3000	 ldr         r3, [sp]
  00640	e283302c	 add         r3, r3, #0x2C
  00644	e5933000	 ldr         r3, [r3]
  00648	e283301c	 add         r3, r3, #0x1C
  0064c	e5832000	 str         r2, [r3]

; 754  : 
; 755  :             //  Reset IRQ status
; 756  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQSTATUS, pDevice->IrqWait);

  00650	e59d3000	 ldr         r3, [sp]
  00654	e283302c	 add         r3, r3, #0x2C
  00658	e5933000	 ldr         r3, [r3]
  0065c	e2832018	 add         r2, r3, #0x18
  00660	e59d3000	 ldr         r3, [sp]
  00664	e283305c	 add         r3, r3, #0x5C
  00668	e5922000	 ldr         r2, [r2]
  0066c	e5933000	 ldr         r3, [r3]
  00670	e1822003	 orr         r2, r2, r3
  00674	e59d3000	 ldr         r3, [sp]
  00678	e283302c	 add         r3, r3, #0x2C
  0067c	e5933000	 ldr         r3, [r3]
  00680	e2833018	 add         r3, r3, #0x18
  00684	e5832000	 str         r2, [r3]

; 757  :         }
; 758  :         else

  00688	ea00001c	 b           |$LN1@NAND_Enabl|
  0068c		 |$LN2@NAND_Enabl|

; 759  :         {
; 760  :             //  Reset IRQ status
; 761  :             SETREG32 (&pDevice->pGpmcRegs->GPMC_IRQSTATUS, pDevice->IrqWait);

  0068c	e59d3000	 ldr         r3, [sp]
  00690	e283302c	 add         r3, r3, #0x2C
  00694	e5933000	 ldr         r3, [r3]
  00698	e2832018	 add         r2, r3, #0x18
  0069c	e59d3000	 ldr         r3, [sp]
  006a0	e283305c	 add         r3, r3, #0x5C
  006a4	e5922000	 ldr         r2, [r2]
  006a8	e5933000	 ldr         r3, [r3]
  006ac	e1822003	 orr         r2, r2, r3
  006b0	e59d3000	 ldr         r3, [sp]
  006b4	e283302c	 add         r3, r3, #0x2C
  006b8	e5933000	 ldr         r3, [r3]
  006bc	e2833018	 add         r3, r3, #0x18
  006c0	e5832000	 str         r2, [r3]

; 762  : 
; 763  :             // Disable GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 764  :             CLRREG32 (&pDevice->pGpmcRegs->GPMC_IRQENABLE, pDevice->IrqWait);

  006c4	e59d3000	 ldr         r3, [sp]
  006c8	e283302c	 add         r3, r3, #0x2C
  006cc	e5933000	 ldr         r3, [r3]
  006d0	e283101c	 add         r1, r3, #0x1C
  006d4	e59d3000	 ldr         r3, [sp]
  006d8	e283305c	 add         r3, r3, #0x5C
  006dc	e5933000	 ldr         r3, [r3]
  006e0	e1e02003	 mvn         r2, r3
  006e4	e5913000	 ldr         r3, [r1]
  006e8	e0032002	 and         r2, r3, r2
  006ec	e59d3000	 ldr         r3, [sp]
  006f0	e283302c	 add         r3, r3, #0x2C
  006f4	e5933000	 ldr         r3, [r3]
  006f8	e283301c	 add         r3, r3, #0x1C
  006fc	e5832000	 str         r2, [r3]
  00700		 |$LN1@NAND_Enabl|
  00700		 |$LN3@NAND_Enabl|

; 765  :         }
; 766  :     }
; 767  :     return TRUE;

  00700	e3a03001	 mov         r3, #1
  00704	e58d3004	 str         r3, [sp, #4]

; 768  : }

  00708	e59d0004	 ldr         r0, [sp, #4]
  0070c	e28dd008	 add         sp, sp, #8
  00710	e89d6000	 ldmia       sp, {sp, lr}
  00714	e12fff1e	 bx          lr
  00718		 |$M46584|

			 ENDP  ; |NAND_Enable|


  00030			 AREA	 |.pdata|, PDATA
|$T46592| DCD	|$LN5@NAND_SendC|
	DCD	0x40001304
; Function compile flags: /Odtp

  00718			 AREA	 |.text|, CODE, ARM

  00718		 |NAND_SendCommand| PROC

; 808  : {

  00718		 |$LN5@NAND_SendC|
  00718	e1a0c00d	 mov         r12, sp
  0071c	e92d0003	 stmdb       sp!, {r0, r1}
  00720	e92d5000	 stmdb       sp!, {r12, lr}
  00724	e24dd008	 sub         sp, sp, #8
  00728		 |$M46589|

; 809  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  00728	e59d3010	 ldr         r3, [sp, #0x10]
  0072c	e58d3000	 str         r3, [sp]

; 810  :     WRITE_NAND(pDevice->pNandCmd, cmd);

  00730	e59d3014	 ldr         r3, [sp, #0x14]
  00734	e1a02803	 mov         r2, r3, lsl #16
  00738	e1a02822	 mov         r2, r2, lsr #16
  0073c	e59d3000	 ldr         r3, [sp]
  00740	e283301c	 add         r3, r3, #0x1C
  00744	e5933000	 ldr         r3, [r3]
  00748	e1c320b0	 strh        r2, [r3]

; 811  :     return TRUE;

  0074c	e3a03001	 mov         r3, #1
  00750	e58d3004	 str         r3, [sp, #4]

; 812  : }

  00754	e59d0004	 ldr         r0, [sp, #4]
  00758	e28dd008	 add         sp, sp, #8
  0075c	e89d6000	 ldmia       sp, {sp, lr}
  00760	e12fff1e	 bx          lr
  00764		 |$M46590|

			 ENDP  ; |NAND_SendCommand|

	EXPORT	|WaitForReadyStatus|
	EXPORT	|FMD_Deinit|

  00038			 AREA	 |.pdata|, PDATA
|$T46598| DCD	|$LN6@FMD_Deinit|
	DCD	0x40002b04
; Function compile flags: /Odtp

  00764			 AREA	 |.text|, CODE, ARM

  00764		 |FMD_Deinit| PROC

; 934  : {

  00764		 |$LN6@FMD_Deinit|
  00764	e1a0c00d	 mov         r12, sp
  00768	e92d0001	 stmdb       sp!, {r0}
  0076c	e92d5000	 stmdb       sp!, {r12, lr}
  00770	e24dd008	 sub         sp, sp, #8
  00774		 |$M46595|

; 935  :     BOOL rc = FALSE;

  00774	e3a03000	 mov         r3, #0
  00778	e58d3000	 str         r3, [sp]

; 936  :     if (pContext != s_hNand) goto cleanUp;

  0077c	e59d2010	 ldr         r2, [sp, #0x10]
  00780	e59f3084	 ldr         r3, [pc, #0x84]
  00784	e5933000	 ldr         r3, [r3]
  00788	e1520003	 cmp         r2, r3
  0078c	0a000000	 beq         |$LN1@FMD_Deinit|
  00790	ea000017	 b           |$cleanUp$46288|
  00794		 |$LN1@FMD_Deinit|

; 937  : 
; 938  :     //  Only enable during NAND read/write/erase operations
; 939  :     NAND_Enable(s_hNand, TRUE);

  00794	e3a01001	 mov         r1, #1
  00798	e59f306c	 ldr         r3, [pc, #0x6C]
  0079c	e5930000	 ldr         r0, [r3]
  007a0	eb000000	 bl          NAND_Enable

; 940  : 
; 941  :     // Wait for NAND    
; 942  :     // the next command may not work if you remove this wait on the status, 
; 943  :     // because if the R/B pin is asserted during the reset, its deassertion 
; 944  :     // isn't guaranteed to mean that the device is ready
; 945  :     WaitForReadyStatus(s_hNand);   

  007a4	e59f3060	 ldr         r3, [pc, #0x60]
  007a8	e5930000	 ldr         r0, [r3]
  007ac	eb000000	 bl          WaitForReadyStatus

; 946  : 
; 947  :     // Write RESET command
; 948  :     // (a reset aborts any current READ, WRITE (PROGRAM) or ERASE operation)
; 949  :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  007b0	e3a010ff	 mov         r1, #0xFF
  007b4	e59f3050	 ldr         r3, [pc, #0x50]
  007b8	e5930000	 ldr         r0, [r3]
  007bc	eb000000	 bl          NAND_SendCommand

; 950  : 
; 951  :     // Wait for NAND
; 952  :     WaitForReadyStatus(s_hNand);

  007c0	e59f3044	 ldr         r3, [pc, #0x44]
  007c4	e5930000	 ldr         r0, [r3]
  007c8	eb000000	 bl          WaitForReadyStatus

; 953  : 
; 954  :     // Clear GPMC wait-to-nowait edge detection mechanism on NAND R/B pin
; 955  :     NAND_Enable(s_hNand, FALSE);

  007cc	e3a01000	 mov         r1, #0
  007d0	e59f3034	 ldr         r3, [pc, #0x34]
  007d4	e5930000	 ldr         r0, [r3]
  007d8	eb000000	 bl          NAND_Enable

; 956  : 
; 957  :     // uninitialize and release allocated resources
; 958  :     NAND_Uninitialize(s_hNand);

  007dc	e59f3028	 ldr         r3, [pc, #0x28]
  007e0	e5930000	 ldr         r0, [r3]
  007e4	eb000000	 bl          NAND_Uninitialize

; 959  :     s_hNand = NULL;

  007e8	e59f201c	 ldr         r2, [pc, #0x1C]
  007ec	e3a03000	 mov         r3, #0
  007f0	e5823000	 str         r3, [r2]
  007f4		 |$cleanUp$46288|

; 960  :     
; 961  : cleanUp:
; 962  :     return rc;

  007f4	e59d3000	 ldr         r3, [sp]
  007f8	e58d3004	 str         r3, [sp, #4]

; 963  : }

  007fc	e59d0004	 ldr         r0, [sp, #4]
  00800	e28dd008	 add         sp, sp, #8
  00804	e89d6000	 ldmia       sp, {sp, lr}
  00808	e12fff1e	 bx          lr
  0080c		 |$LN7@FMD_Deinit|
  0080c		 |$LN8@FMD_Deinit|
  0080c	00000000	 DCD         |s_hNand|
  00810		 |$M46596|

			 ENDP  ; |FMD_Deinit|


  00040			 AREA	 |.pdata|, PDATA
|$T46605| DCD	|$LN5@NAND_Unini|
	DCD	0x40000503
; Function compile flags: /Odtp

  00810			 AREA	 |.text|, CODE, ARM

  00810		 |NAND_Uninitialize| PROC

; 364  : {

  00810		 |$LN5@NAND_Unini|
  00810	e1a0c00d	 mov         r12, sp
  00814	e92d0001	 stmdb       sp!, {r0}
  00818	e92d5000	 stmdb       sp!, {r12, lr}
  0081c		 |$M46602|

; 365  : #ifdef BOOT_MODE
; 366  :     UNREFERENCED_PARAMETER(hNand);
; 367  : #else
; 368  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 369  : 
; 370  :     if (pDevice->pGpmcRegs != NULL)
; 371  :         {
; 372  :         MmUnmapIoSpace((void*)pDevice->pGpmcRegs, pDevice->memLen[0]);
; 373  :         }
; 374  : 
; 375  :     if (pDevice->pFifo != NULL)
; 376  :         {
; 377  :         MmUnmapIoSpace((void*)pDevice->pFifo, pDevice->memLen[1]);
; 378  :         }
; 379  : #endif
; 380  : }

  0081c	e89d6000	 ldmia       sp, {sp, lr}
  00820	e12fff1e	 bx          lr
  00824		 |$M46603|

			 ENDP  ; |NAND_Uninitialize|


  00000			 AREA	 |.pdata|, PDATA
|$T46610| DCD	|$LN7@WaitForRea|
	DCD	0x40000e04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitForReadyStatus| PROC

; 897  : {

  00000		 |$LN7@WaitForRea|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46607|
  00010		 |$LN2@WaitForRea|

; 898  :     //  Wait for a Ready status
; 899  :     while ((NAND_GetStatus(hNand) & NAND_STATUS_READY) == 0); 

  00010	e59d000c	 ldr         r0, [sp, #0xC]
  00014	eb000000	 bl          NAND_GetStatus
  00018	e1cd00b0	 strh        r0, [sp]
  0001c	e1dd30b0	 ldrh        r3, [sp]
  00020	e3130040	 tst         r3, #0x40
  00024	1a000000	 bne         |$LN1@WaitForRea|
  00028	eafffff8	 b           |$LN2@WaitForRea|
  0002c		 |$LN1@WaitForRea|

; 900  : }

  0002c	e28dd004	 add         sp, sp, #4
  00030	e89d6000	 ldmia       sp, {sp, lr}
  00034	e12fff1e	 bx          lr
  00038		 |$M46608|

			 ENDP  ; |WaitForReadyStatus|

	EXPORT	|NAND_GetGeometry|
	EXPORT	|FMD_GetInfo|

  00048			 AREA	 |.pdata|, PDATA
|$T46618| DCD	|$LN6@FMD_GetInf|
	DCD	0x40005104
; Function compile flags: /Odtp

  00824			 AREA	 |.text|, CODE, ARM

  00824		 |FMD_GetInfo| PROC

; 975  : {

  00824		 |$LN6@FMD_GetInf|
  00824	e1a0c00d	 mov         r12, sp
  00828	e92d0001	 stmdb       sp!, {r0}
  0082c	e92d5000	 stmdb       sp!, {r12, lr}
  00830	e24dd01c	 sub         sp, sp, #0x1C
  00834		 |$M46615|

; 976  :     BOOL rc = FALSE;

  00834	e3a03000	 mov         r3, #0
  00838	e58d3000	 str         r3, [sp]

; 977  : 
; 978  :     // If we don't support NAND, fail...
; 979  :     if (s_hNand == NULL) goto cleanUp;

  0083c	e59f3120	 ldr         r3, [pc, #0x120]
  00840	e5933000	 ldr         r3, [r3]
  00844	e3530000	 cmp         r3, #0
  00848	1a000000	 bne         |$LN1@FMD_GetInf|
  0084c	ea00003e	 b           |$cleanUp$46296|
  00850		 |$LN1@FMD_GetInf|

; 980  : 
; 981  :     // Memory type is NAND
; 982  :     pFlashInfo->flashType = NAND;

  00850	e59d2024	 ldr         r2, [sp, #0x24]
  00854	e3a03000	 mov         r3, #0
  00858	e5823000	 str         r3, [r2]

; 983  :     pFlashInfo->dwNumBlocks = NAND_GetGeometry(s_hNand)->blocks;

  0085c	e59f3100	 ldr         r3, [pc, #0x100]
  00860	e5930000	 ldr         r0, [r3]
  00864	eb000000	 bl          NAND_GetGeometry
  00868	e58d0008	 str         r0, [sp, #8]
  0086c	e59d3008	 ldr         r3, [sp, #8]
  00870	e2831004	 add         r1, r3, #4
  00874	e59d3024	 ldr         r3, [sp, #0x24]
  00878	e2832004	 add         r2, r3, #4
  0087c	e5913000	 ldr         r3, [r1]
  00880	e5823000	 str         r3, [r2]

; 984  :     pFlashInfo->wSectorsPerBlock = (WORD) NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  00884	e59f30d8	 ldr         r3, [pc, #0xD8]
  00888	e5930000	 ldr         r0, [r3]
  0088c	eb000000	 bl          NAND_GetGeometry
  00890	e58d000c	 str         r0, [sp, #0xC]
  00894	e59d300c	 ldr         r3, [sp, #0xC]
  00898	e2833008	 add         r3, r3, #8
  0089c	e5933000	 ldr         r3, [r3]
  008a0	e1a02803	 mov         r2, r3, lsl #16
  008a4	e1a02822	 mov         r2, r2, lsr #16
  008a8	e59d3024	 ldr         r3, [sp, #0x24]
  008ac	e283300c	 add         r3, r3, #0xC
  008b0	e1c320b0	 strh        r2, [r3]

; 985  :     pFlashInfo->wDataBytesPerSector = (WORD) NAND_GetGeometry(s_hNand)->sectorSize;

  008b4	e59f30a8	 ldr         r3, [pc, #0xA8]
  008b8	e5930000	 ldr         r0, [r3]
  008bc	eb000000	 bl          NAND_GetGeometry
  008c0	e58d0010	 str         r0, [sp, #0x10]
  008c4	e59d3010	 ldr         r3, [sp, #0x10]
  008c8	e283300c	 add         r3, r3, #0xC
  008cc	e5933000	 ldr         r3, [r3]
  008d0	e1a02803	 mov         r2, r3, lsl #16
  008d4	e1a02822	 mov         r2, r2, lsr #16
  008d8	e59d3024	 ldr         r3, [sp, #0x24]
  008dc	e283300e	 add         r3, r3, #0xE
  008e0	e1c320b0	 strh        r2, [r3]

; 986  :     pFlashInfo->dwBytesPerBlock = NAND_GetGeometry(s_hNand)->sectorSize;

  008e4	e59f3078	 ldr         r3, [pc, #0x78]
  008e8	e5930000	 ldr         r0, [r3]
  008ec	eb000000	 bl          NAND_GetGeometry
  008f0	e58d0014	 str         r0, [sp, #0x14]
  008f4	e59d3014	 ldr         r3, [sp, #0x14]
  008f8	e283100c	 add         r1, r3, #0xC
  008fc	e59d3024	 ldr         r3, [sp, #0x24]
  00900	e2832008	 add         r2, r3, #8
  00904	e5913000	 ldr         r3, [r1]
  00908	e5823000	 str         r3, [r2]

; 987  :     pFlashInfo->dwBytesPerBlock *= NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  0090c	e59f3050	 ldr         r3, [pc, #0x50]
  00910	e5930000	 ldr         r0, [r3]
  00914	eb000000	 bl          NAND_GetGeometry
  00918	e58d0018	 str         r0, [sp, #0x18]
  0091c	e59d3024	 ldr         r3, [sp, #0x24]
  00920	e2832008	 add         r2, r3, #8
  00924	e59d3018	 ldr         r3, [sp, #0x18]
  00928	e2833008	 add         r3, r3, #8
  0092c	e5921000	 ldr         r1, [r2]
  00930	e5933000	 ldr         r3, [r3]
  00934	e0020391	 mul         r2, r1, r3
  00938	e59d3024	 ldr         r3, [sp, #0x24]
  0093c	e2833008	 add         r3, r3, #8
  00940	e5832000	 str         r2, [r3]

; 988  : 
; 989  :     // Done
; 990  :     rc = TRUE;

  00944	e3a03001	 mov         r3, #1
  00948	e58d3000	 str         r3, [sp]
  0094c		 |$cleanUp$46296|

; 991  : 
; 992  : cleanUp:
; 993  :     return rc;

  0094c	e59d3000	 ldr         r3, [sp]
  00950	e58d3004	 str         r3, [sp, #4]

; 994  : }

  00954	e59d0004	 ldr         r0, [sp, #4]
  00958	e28dd01c	 add         sp, sp, #0x1C
  0095c	e89d6000	 ldmia       sp, {sp, lr}
  00960	e12fff1e	 bx          lr
  00964		 |$LN7@FMD_GetInf|
  00964		 |$LN8@FMD_GetInf|
  00964	00000000	 DCD         |s_hNand|
  00968		 |$M46616|

			 ENDP  ; |FMD_GetInfo|


  00000			 AREA	 |.pdata|, PDATA
|$T46626| DCD	|$LN5@NAND_GetGe|
	DCD	0x40000b04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetGeometry| PROC

; 324  : {

  00000		 |$LN5@NAND_GetGe|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46623|

; 325  :     return &(((NandDevice_t*)hNand)->nandInfo);

  00010	e59d300c	 ldr         r3, [sp, #0xC]
  00014	e2833044	 add         r3, r3, #0x44
  00018	e58d3000	 str         r3, [sp]

; 326  : }

  0001c	e59d0000	 ldr         r0, [sp]
  00020	e28dd004	 add         sp, sp, #4
  00024	e89d6000	 ldmia       sp, {sp, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M46624|

			 ENDP  ; |NAND_GetGeometry|

	EXPORT	|??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@LEPJIIOK@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|NAND_GetGpmcRegs|
	EXPORT	|FMD_ReadSectorOOB|

  00050			 AREA	 |.pdata|, PDATA
|$T46636| DCD	|$LN9@FMD_ReadSe|
	DCD	0x40007504

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@| DCB "%"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "D", 0x0, "E", 0x0, "B"
	DCB	0x0, "U", 0x0, "G", 0x0, "C", 0x0, "H", 0x0, "K", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "i", 0x0, "n", 0x0, " ", 0x0, "f", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, " ", 0x0, "%", 0x0, "s", 0x0, " "
	DCB	0x0, "a", 0x0, "t", 0x0, " ", 0x0, "l", 0x0, "i", 0x0, "n"
	DCB	0x0, "e", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@LEPJIIOK@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@| DCB "U", 0x0
	DCB	"n", 0x0, "k", 0x0, "n", 0x0, "o", 0x0, "w", 0x0, "n", 0x0
	DCB	0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00968			 AREA	 |.text|, CODE, ARM

  00968		 |FMD_ReadSectorOOB| PROC

; 1007 : {

  00968		 |$LN9@FMD_ReadSe|
  00968	e1a0c00d	 mov         r12, sp
  0096c	e92d0003	 stmdb       sp!, {r0, r1}
  00970	e92d5000	 stmdb       sp!, {r12, lr}
  00974	e24dd024	 sub         sp, sp, #0x24
  00978		 |$M46633|

; 1008 :     BOOL rc = FALSE;

  00978	e3a03000	 mov         r3, #0
  0097c	e58d3004	 str         r3, [sp, #4]

; 1009 :     UINT32 oldIdleMode;
; 1010 :     UINT32 sectorSize;
; 1011 : 
; 1012 :     // Fail if FMD wasn't opened
; 1013 :     if (s_hNand == NULL) goto cleanUp;

  00980	e59f31b0	 ldr         r3, [pc, #0x1B0]
  00984	e5933000	 ldr         r3, [r3]
  00988	e3530000	 cmp         r3, #0
  0098c	1a000000	 bne         |$LN2@FMD_ReadSe|
  00990	ea000049	 b           |$cleanUp$46310|
  00994		 |$LN2@FMD_ReadSe|

; 1014 :     
; 1015 :     NAND_MutexEnter(s_hNand);

  00994	e59f319c	 ldr         r3, [pc, #0x19C]
  00998	e5930000	 ldr         r0, [r3]
  0099c	eb000000	 bl          NAND_MutexEnter

; 1016 : 
; 1017 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1018 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;

  009a0	e59f3190	 ldr         r3, [pc, #0x190]
  009a4	e5930000	 ldr         r0, [r3]
  009a8	eb000000	 bl          NAND_GetGeometry
  009ac	e58d0010	 str         r0, [sp, #0x10]
  009b0	e59d3010	 ldr         r3, [sp, #0x10]
  009b4	e283300c	 add         r3, r3, #0xC
  009b8	e5933000	 ldr         r3, [r3]
  009bc	e58d3000	 str         r3, [sp]

; 1019 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  009c0	e59f3170	 ldr         r3, [pc, #0x170]
  009c4	e5930000	 ldr         r0, [r3]
  009c8	eb000000	 bl          NAND_GetGpmcRegs
  009cc	e58d0014	 str         r0, [sp, #0x14]
  009d0	e59d3014	 ldr         r3, [sp, #0x14]
  009d4	e2833010	 add         r3, r3, #0x10
  009d8	e5933000	 ldr         r3, [r3]
  009dc	e58d3008	 str         r3, [sp, #8]

; 1020 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  009e0	e59f3150	 ldr         r3, [pc, #0x150]
  009e4	e5930000	 ldr         r0, [r3]
  009e8	eb000000	 bl          NAND_GetGpmcRegs
  009ec	e58d0018	 str         r0, [sp, #0x18]
  009f0	e59d3018	 ldr         r3, [sp, #0x18]
  009f4	e2832010	 add         r2, r3, #0x10
  009f8	e3a03008	 mov         r3, #8
  009fc	e5823000	 str         r3, [r2]

; 1021 :     
; 1022 :         {
; 1023 :         //  Only enable during NAND read/write/erase operations
; 1024 :         NAND_Enable(s_hNand, TRUE);

  00a00	e3a01001	 mov         r1, #1
  00a04	e59f312c	 ldr         r3, [pc, #0x12C]
  00a08	e5930000	 ldr         r0, [r3]
  00a0c	eb000000	 bl          NAND_Enable

; 1025 : 
; 1026 :         // Make sure of the NAND status
; 1027 :         WaitForReadyStatus(s_hNand);

  00a10	e59f3120	 ldr         r3, [pc, #0x120]
  00a14	e5930000	 ldr         r0, [r3]
  00a18	eb000000	 bl          WaitForReadyStatus

; 1028 : 
; 1029 :         // Send the command
; 1030 :         NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  00a1c	e3a01000	 mov         r1, #0
  00a20	e59f3110	 ldr         r3, [pc, #0x110]
  00a24	e5930000	 ldr         r0, [r3]
  00a28	eb000000	 bl          NAND_SendCommand

; 1031 : 
; 1032 :         // Send the address
; 1033 :         NAND_Seek(s_hNand, sector, sectorSize);

  00a2c	e59d2000	 ldr         r2, [sp]
  00a30	e59d102c	 ldr         r1, [sp, #0x2C]
  00a34	e59f30fc	 ldr         r3, [pc, #0xFC]
  00a38	e5930000	 ldr         r0, [r3]
  00a3c	eb000000	 bl          NAND_Seek

; 1034 : 
; 1035 :         // Send the command
; 1036 :         NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00a40	e3a01030	 mov         r1, #0x30
  00a44	e59f30ec	 ldr         r3, [pc, #0xEC]
  00a48	e5930000	 ldr         r0, [r3]
  00a4c	eb000000	 bl          NAND_SendCommand

; 1037 : 
; 1038 :         // Wait for the action to finish
; 1039 :         WaitForReadyStatus(s_hNand);

  00a50	e59f30e0	 ldr         r3, [pc, #0xE0]
  00a54	e5930000	 ldr         r0, [r3]
  00a58	eb000000	 bl          WaitForReadyStatus

; 1040 : 
; 1041 :         //Force a read here, else we will read the status again
; 1042 :         NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00a5c	e3a01000	 mov         r1, #0
  00a60	e59f30d0	 ldr         r3, [pc, #0xD0]
  00a64	e5930000	 ldr         r0, [r3]
  00a68	eb000000	 bl          NAND_SendCommand

; 1043 : 
; 1044 :         // read spare area
; 1045 :         NAND_Read(s_hNand, (BYTE*)pBuffer, 64, NULL);

  00a6c	e3a03000	 mov         r3, #0
  00a70	e3a02040	 mov         r2, #0x40
  00a74	e59d1030	 ldr         r1, [sp, #0x30]
  00a78	e59f00b8	 ldr         r0, [pc, #0xB8]
  00a7c	e5900000	 ldr         r0, [r0]
  00a80	eb000000	 bl          NAND_Read

; 1046 :         
; 1047 :         //  Only enable during NAND read/write/erase operations
; 1048 :         NAND_Enable(s_hNand, FALSE);

  00a84	e3a01000	 mov         r1, #0
  00a88	e59f30a8	 ldr         r3, [pc, #0xA8]
  00a8c	e5930000	 ldr         r0, [r3]
  00a90	eb000000	 bl          NAND_Enable

; 1049 : 
; 1050 :         }
; 1051 : 
; 1052 :     //  Change idle mode back
; 1053 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  00a94	e59f309c	 ldr         r3, [pc, #0x9C]
  00a98	e5930000	 ldr         r0, [r3]
  00a9c	eb000000	 bl          NAND_GetGpmcRegs
  00aa0	e58d001c	 str         r0, [sp, #0x1C]
  00aa4	e59d301c	 ldr         r3, [sp, #0x1C]
  00aa8	e2832010	 add         r2, r3, #0x10
  00aac	e59d3008	 ldr         r3, [sp, #8]
  00ab0	e5823000	 str         r3, [r2]

; 1054 :     
; 1055 :     // Done
; 1056 :     rc = TRUE;

  00ab4	e3a03001	 mov         r3, #1
  00ab8	e58d3004	 str         r3, [sp, #4]
  00abc		 |$cleanUp$46310|

; 1057 : 
; 1058 : cleanUp:
; 1059 :     // Release hardware lock
; 1060 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  00abc	e59f3074	 ldr         r3, [pc, #0x74]
  00ac0	e5933000	 ldr         r3, [r3]
  00ac4	e3530000	 cmp         r3, #0
  00ac8	0a000002	 beq         |$LN1@FMD_ReadSe|
  00acc	e59f3064	 ldr         r3, [pc, #0x64]
  00ad0	e5930000	 ldr         r0, [r3]
  00ad4	eb000000	 bl          NAND_MutexExit
  00ad8		 |$LN1@FMD_ReadSe|

; 1061 :     
; 1062 :     ASSERT(rc);

  00ad8	e59d3004	 ldr         r3, [sp, #4]
  00adc	e3530000	 cmp         r3, #0
  00ae0	0a000002	 beq         |$LN5@FMD_ReadSe|
  00ae4	e3a03001	 mov         r3, #1
  00ae8	e58d3020	 str         r3, [sp, #0x20]
  00aec	ea000008	 b           |$LN6@FMD_ReadSe|
  00af0		 |$LN5@FMD_ReadSe|
  00af0	e3a03b01	 mov         r3, #1, 22
  00af4	e3833026	 orr         r3, r3, #0x26
  00af8	e59f2034	 ldr         r2, [pc, #0x34]
  00afc	e59f102c	 ldr         r1, [pc, #0x2C]
  00b00	e59f0024	 ldr         r0, [pc, #0x24]
  00b04	eb000000	 bl          NKDbgPrintfW
  00b08	e6000010	 __debugbreak_ce
  00b0c	e3a03000	 mov         r3, #0
  00b10	e58d3020	 str         r3, [sp, #0x20]
  00b14		 |$LN6@FMD_ReadSe|

; 1063 :     return rc;

  00b14	e59d3004	 ldr         r3, [sp, #4]
  00b18	e58d300c	 str         r3, [sp, #0xC]

; 1064 : }

  00b1c	e59d000c	 ldr         r0, [sp, #0xC]
  00b20	e28dd024	 add         sp, sp, #0x24
  00b24	e89d6000	 ldmia       sp, {sp, lr}
  00b28	e12fff1e	 bx          lr
  00b2c		 |$LN10@FMD_ReadSe|
  00b2c		 |$LN11@FMD_ReadSe|
  00b2c	00000000	 DCD         |??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@|
  00b30		 |$LN12@FMD_ReadSe|
  00b30	00000000	 DCD         |??_C@_1BA@LEPJIIOK@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@|
  00b34		 |$LN13@FMD_ReadSe|
  00b34	00000000	 DCD         |??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  00b38		 |$LN14@FMD_ReadSe|
  00b38	00000000	 DCD         |s_hNand|
  00b3c		 |$M46634|

			 ENDP  ; |FMD_ReadSectorOOB|


  00000			 AREA	 |.pdata|, PDATA
|$T46647| DCD	|$LN5@NAND_GetGp|
	DCD	0x40000c04
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NAND_GetGpmcRegs| PROC

; 313  : {

  00000		 |$LN5@NAND_GetGp|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46644|

; 314  :     return ((NandDevice_t*)hNand)->pGpmcRegs;

  00010	e59d300c	 ldr         r3, [sp, #0xC]
  00014	e283302c	 add         r3, r3, #0x2C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d3000	 str         r3, [sp]

; 315  : }

  00020	e59d0000	 ldr         r0, [sp]
  00024	e28dd004	 add         sp, sp, #4
  00028	e89d6000	 ldmia       sp, {sp, lr}
  0002c	e12fff1e	 bx          lr
  00030		 |$M46645|

			 ENDP  ; |NAND_GetGpmcRegs|

	EXPORT	|SectorAccess|

  00058			 AREA	 |.pdata|, PDATA
|$T46655| DCD	|$LN5@NAND_Seek|
	DCD	0x40001004
; Function compile flags: /Odtp

  00b3c			 AREA	 |.text|, CODE, ARM

  00b3c		 |NAND_Seek| PROC

; 538  : {

  00b3c		 |$LN5@NAND_Seek|
  00b3c	e1a0c00d	 mov         r12, sp
  00b40	e92d0007	 stmdb       sp!, {r0 - r2}
  00b44	e92d5000	 stmdb       sp!, {r12, lr}
  00b48	e24dd008	 sub         sp, sp, #8
  00b4c		 |$M46652|

; 539  :     // seek to address
; 540  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  00b4c	e59d3010	 ldr         r3, [sp, #0x10]
  00b50	e58d3000	 str         r3, [sp]

; 541  :     SectorAccess(pDevice, sector, offset);

  00b54	e59d2018	 ldr         r2, [sp, #0x18]
  00b58	e59d1014	 ldr         r1, [sp, #0x14]
  00b5c	e59d0000	 ldr         r0, [sp]
  00b60	eb000000	 bl          SectorAccess

; 542  :     return TRUE;

  00b64	e3a03001	 mov         r3, #1
  00b68	e58d3004	 str         r3, [sp, #4]

; 543  : }

  00b6c	e59d0004	 ldr         r0, [sp, #4]
  00b70	e28dd008	 add         sp, sp, #8
  00b74	e89d6000	 ldmia       sp, {sp, lr}
  00b78	e12fff1e	 bx          lr
  00b7c		 |$M46653|

			 ENDP  ; |NAND_Seek|

	IMPORT	|__rt_udiv|

  00000			 AREA	 |.pdata|, PDATA
|$T46661| DCD	|$LN5@SectorAcce|
	DCD	0x40003403
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SectorAccess| PROC

; 217  : {

  00000		 |$LN5@SectorAcce|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M46658|

; 218  :     
; 219  :     // Offset is provided to this function in bytes; NAND device requires words
; 220  :     offset = offset / 2;

  0000c	e59d1010	 ldr         r1, [sp, #0x10]
  00010	e3a00002	 mov         r0, #2
  00014	eb000000	 bl          __rt_udiv
  00018	e58d0010	 str         r0, [sp, #0x10]

; 221  :     WRITE_NAND(pDevice->pNandAddress, (offset & 0xFF));

  0001c	e59d3010	 ldr         r3, [sp, #0x10]
  00020	e20330ff	 and         r3, r3, #0xFF
  00024	e1a02803	 mov         r2, r3, lsl #16
  00028	e1a02822	 mov         r2, r2, lsr #16
  0002c	e59d3008	 ldr         r3, [sp, #8]
  00030	e2833020	 add         r3, r3, #0x20
  00034	e5933000	 ldr         r3, [r3]
  00038	e1c320b0	 strh        r2, [r3]

; 222  :     WRITE_NAND(pDevice->pNandAddress, ((offset >> 8) & 0xFF));

  0003c	e59d3010	 ldr         r3, [sp, #0x10]
  00040	e1a03803	 mov         r3, r3, lsl #16
  00044	e1a03c23	 mov         r3, r3, lsr #24
  00048	e1a02803	 mov         r2, r3, lsl #16
  0004c	e1a02822	 mov         r2, r2, lsr #16
  00050	e59d3008	 ldr         r3, [sp, #8]
  00054	e2833020	 add         r3, r3, #0x20
  00058	e5933000	 ldr         r3, [r3]
  0005c	e1c320b0	 strh        r2, [r3]

; 223  :     WRITE_NAND(pDevice->pNandAddress, (sector & 0xFF));

  00060	e59d300c	 ldr         r3, [sp, #0xC]
  00064	e20330ff	 and         r3, r3, #0xFF
  00068	e1a02803	 mov         r2, r3, lsl #16
  0006c	e1a02822	 mov         r2, r2, lsr #16
  00070	e59d3008	 ldr         r3, [sp, #8]
  00074	e2833020	 add         r3, r3, #0x20
  00078	e5933000	 ldr         r3, [r3]
  0007c	e1c320b0	 strh        r2, [r3]

; 224  :     WRITE_NAND(pDevice->pNandAddress, ((sector >> 8) & 0xFF));

  00080	e59d300c	 ldr         r3, [sp, #0xC]
  00084	e1a03803	 mov         r3, r3, lsl #16
  00088	e1a03c23	 mov         r3, r3, lsr #24
  0008c	e1a02803	 mov         r2, r3, lsl #16
  00090	e1a02822	 mov         r2, r2, lsr #16
  00094	e59d3008	 ldr         r3, [sp, #8]
  00098	e2833020	 add         r3, r3, #0x20
  0009c	e5933000	 ldr         r3, [r3]
  000a0	e1c320b0	 strh        r2, [r3]

; 225  :     WRITE_NAND(pDevice->pNandAddress, ((sector >> 16) & 0xFF));

  000a4	e59d300c	 ldr         r3, [sp, #0xC]
  000a8	e1a03403	 mov         r3, r3, lsl #8
  000ac	e1a03c23	 mov         r3, r3, lsr #24
  000b0	e1a02803	 mov         r2, r3, lsl #16
  000b4	e1a02822	 mov         r2, r2, lsr #16
  000b8	e59d3008	 ldr         r3, [sp, #8]
  000bc	e2833020	 add         r3, r3, #0x20
  000c0	e5933000	 ldr         r3, [r3]
  000c4	e1c320b0	 strh        r2, [r3]

; 226  : }

  000c8	e89d6000	 ldmia       sp, {sp, lr}
  000cc	e12fff1e	 bx          lr
  000d0		 |$M46659|

			 ENDP  ; |SectorAccess|

	IMPORT	|ECC_Result|
	IMPORT	|memcpy|

  00060			 AREA	 |.pdata|, PDATA
|$T46669| DCD	|$LN19@NAND_Read|
	DCD	0x40008604
; Function compile flags: /Odtp

  00b7c			 AREA	 |.text|, CODE, ARM

  00b7c		 |NAND_Read| PROC

; 553  : {

  00b7c		 |$LN19@NAND_Read|
  00b7c	e1a0c00d	 mov         r12, sp
  00b80	e92d000f	 stmdb       sp!, {r0 - r3}
  00b84	e92d5000	 stmdb       sp!, {r12, lr}
  00b88	e24dd00c	 sub         sp, sp, #0xC
  00b8c		 |$M46666|

; 554  :     UINT32 fifoLevel;
; 555  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  00b8c	e59d3014	 ldr         r3, [sp, #0x14]
  00b90	e58d3000	 str         r3, [sp]

; 556  : 
; 557  :     // Start ECC if a valid ECC buffer is passed in
; 558  :     if (pEcc != NULL)

  00b94	e59d3020	 ldr         r3, [sp, #0x20]
  00b98	e3530000	 cmp         r3, #0
  00b9c	0a00000a	 beq         |$LN14@NAND_Read|

; 559  :         {
; 560  :         ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_READ);

  00ba0	e3a03000	 mov         r3, #0
  00ba4	e59d2000	 ldr         r2, [sp]
  00ba8	e2822060	 add         r2, r2, #0x60
  00bac	e5922000	 ldr         r2, [r2]
  00bb0	e59d1000	 ldr         r1, [sp]
  00bb4	e2811058	 add         r1, r1, #0x58
  00bb8	e5911000	 ldr         r1, [r1]
  00bbc	e59d0000	 ldr         r0, [sp]
  00bc0	e280002c	 add         r0, r0, #0x2C
  00bc4	e5900000	 ldr         r0, [r0]
  00bc8	eb000000	 bl          ECC_Init
  00bcc		 |$LN14@NAND_Read|

; 561  :         }
; 562  : 
; 563  :     // enable prefetch if it's been properly configured
; 564  :     if (pDevice->prefetchMode == kPrefetchRead )

  00bcc	e59d3000	 ldr         r3, [sp]
  00bd0	e2833018	 add         r3, r3, #0x18
  00bd4	e5933000	 ldr         r3, [r3]
  00bd8	e3530001	 cmp         r3, #1
  00bdc	1a000031	 bne         |$LN13@NAND_Read|

; 565  :         {
; 566  :         SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 
; 567  :             GPMC_PREFETCH_CONTROL_STARTENGINE
; 568  :             );

  00be0	e59d3000	 ldr         r3, [sp]
  00be4	e283302c	 add         r3, r3, #0x2C
  00be8	e5933000	 ldr         r3, [r3]
  00bec	e2833f7b	 add         r3, r3, #0x7B, 30
  00bf0	e5933000	 ldr         r3, [r3]
  00bf4	e3832001	 orr         r2, r3, #1
  00bf8	e59d3000	 ldr         r3, [sp]
  00bfc	e283302c	 add         r3, r3, #0x2C
  00c00	e5933000	 ldr         r3, [r3]
  00c04	e2833f7b	 add         r3, r3, #0x7B, 30
  00c08	e5832000	 str         r2, [r3]
  00c0c		 |$LN12@NAND_Read|

; 569  : 
; 570  :         // start copying data into passed in buffer
; 571  :         while (size > 0)

  00c0c	e59d301c	 ldr         r3, [sp, #0x1C]
  00c10	e3530000	 cmp         r3, #0
  00c14	da00001e	 ble         |$LN11@NAND_Read|

; 572  :             {
; 573  :             // wait for fifo threshold to be reached
; 574  :             fifoLevel = 0;

  00c18	e3a03000	 mov         r3, #0
  00c1c	e58d3004	 str         r3, [sp, #4]
  00c20		 |$LN10@NAND_Read|

; 575  :             while (fifoLevel < FIFO_THRESHOLD)

  00c20	e59d3004	 ldr         r3, [sp, #4]
  00c24	e3530040	 cmp         r3, #0x40
  00c28	2a00000c	 bcs         |$LN9@NAND_Read|

; 576  :                 {
; 577  :                 fifoLevel = INREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_STATUS);

  00c2c	e59d3000	 ldr         r3, [sp]
  00c30	e283302c	 add         r3, r3, #0x2C
  00c34	e5933000	 ldr         r3, [r3]
  00c38	e2833e1f	 add         r3, r3, #0x1F, 28
  00c3c	e5933000	 ldr         r3, [r3]
  00c40	e58d3004	 str         r3, [sp, #4]

; 578  :                 fifoLevel &= GPMC_PREFETCH_STATUS_FIFOMASK;

  00c44	e59d3004	 ldr         r3, [sp, #4]
  00c48	e203347f	 and         r3, r3, #0x7F, 8
  00c4c	e58d3004	 str         r3, [sp, #4]

; 579  :                 fifoLevel >>= GPMC_PREFETCH_STATUS_FIFOSHIFT;

  00c50	e59d3004	 ldr         r3, [sp, #4]
  00c54	e1a03c23	 mov         r3, r3, lsr #24
  00c58	e58d3004	 str         r3, [sp, #4]

; 580  :                 }

  00c5c	eaffffef	 b           |$LN10@NAND_Read|
  00c60		 |$LN9@NAND_Read|

; 581  : 
; 582  :             // copy data to buffer
; 583  :             memcpy(pData, (BYTE*)pDevice->pFifo, FIFO_THRESHOLD);

  00c60	e3a02040	 mov         r2, #0x40
  00c64	e59d3000	 ldr         r3, [sp]
  00c68	e2833028	 add         r3, r3, #0x28
  00c6c	e5931000	 ldr         r1, [r3]
  00c70	e59d0018	 ldr         r0, [sp, #0x18]
  00c74	eb000000	 bl          memcpy

; 584  :             pData += FIFO_THRESHOLD;

  00c78	e59d3018	 ldr         r3, [sp, #0x18]
  00c7c	e2833040	 add         r3, r3, #0x40
  00c80	e58d3018	 str         r3, [sp, #0x18]

; 585  :             size -= FIFO_THRESHOLD;        

  00c84	e59d301c	 ldr         r3, [sp, #0x1C]
  00c88	e2433040	 sub         r3, r3, #0x40
  00c8c	e58d301c	 str         r3, [sp, #0x1C]

; 586  :             }

  00c90	eaffffdd	 b           |$LN12@NAND_Read|
  00c94		 |$LN11@NAND_Read|

; 587  : 
; 588  :         // NOTE:
; 589  :         //  Prefetch engine will automatically stop on the completion
; 590  :         // of data transfer
; 591  :         pDevice->prefetchMode = kPrefetchOff;

  00c94	e59d3000	 ldr         r3, [sp]
  00c98	e2832018	 add         r2, r3, #0x18
  00c9c	e3a03000	 mov         r3, #0
  00ca0	e5823000	 str         r3, [r2]

; 592  :         }
; 593  :     else

  00ca4	ea000024	 b           |$LN8@NAND_Read|
  00ca8		 |$LN13@NAND_Read|
  00ca8		 |$LN7@NAND_Read|

; 594  :         {
; 595  :         // NOTE:
; 596  :         //  Code assumes the entire page is read at once
; 597  :         while (size >= sizeof(NANDREG))

  00ca8	e59d301c	 ldr         r3, [sp, #0x1C]
  00cac	e3530002	 cmp         r3, #2
  00cb0	3a000021	 bcc         |$LN6@NAND_Read|

; 598  :             {
; 599  :             *(NANDREG*)pData = READ_NAND(pDevice->pNandData);

  00cb4	e59d3000	 ldr         r3, [sp]
  00cb8	e2833024	 add         r3, r3, #0x24
  00cbc	e5933000	 ldr         r3, [r3]
  00cc0	e1d320b0	 ldrh        r2, [r3]
  00cc4	e59d3018	 ldr         r3, [sp, #0x18]
  00cc8	e1c320b0	 strh        r2, [r3]

; 600  :             pData += sizeof(NANDREG);

  00ccc	e59d3018	 ldr         r3, [sp, #0x18]
  00cd0	e2833002	 add         r3, r3, #2
  00cd4	e58d3018	 str         r3, [sp, #0x18]

; 601  :             size -= sizeof(NANDREG);

  00cd8	e59d301c	 ldr         r3, [sp, #0x1C]
  00cdc	e2433002	 sub         r3, r3, #2
  00ce0	e58d301c	 str         r3, [sp, #0x1C]

; 602  : 
; 603  : 	     /* workaround for BCH engine when ECC is not put at the end of OOB area.  
; 604  : 		  the checking is based on puting ECC at the BootROM expected location -
; 605  : 		  with 2 bytes offset from the start of the OOB area */
; 606  :             if(pDevice->ECCtype == BCH4bit || pDevice->ECCtype == BCH8bit)

  00ce4	e59d3000	 ldr         r3, [sp]
  00ce8	e2833060	 add         r3, r3, #0x60
  00cec	e5933000	 ldr         r3, [r3]
  00cf0	e3530001	 cmp         r3, #1
  00cf4	0a000004	 beq         |$LN4@NAND_Read|
  00cf8	e59d3000	 ldr         r3, [sp]
  00cfc	e2833060	 add         r3, r3, #0x60
  00d00	e5933000	 ldr         r3, [r3]
  00d04	e3530002	 cmp         r3, #2
  00d08	1a00000a	 bne         |$LN5@NAND_Read|
  00d0c		 |$LN4@NAND_Read|

; 607  :                 if (size == (int)(sizeof(NAND_SPARE_AREA) - ECC_OFFSET - pDevice->ECCsize))

  00d0c	e59d3000	 ldr         r3, [sp]
  00d10	e2833064	 add         r3, r3, #0x64
  00d14	e5933000	 ldr         r3, [r3]
  00d18	e263203e	 rsb         r2, r3, #0x3E
  00d1c	e59d301c	 ldr         r3, [sp, #0x1C]
  00d20	e1530002	 cmp         r3, r2
  00d24	1a000003	 bne         |$LN3@NAND_Read|

; 608  :         	         ECC_Reset(pDevice->pGpmcRegs);  

  00d28	e59d3000	 ldr         r3, [sp]
  00d2c	e283302c	 add         r3, r3, #0x2C
  00d30	e5930000	 ldr         r0, [r3]
  00d34	eb000000	 bl          ECC_Reset
  00d38		 |$LN3@NAND_Read|
  00d38		 |$LN5@NAND_Read|

; 609  :                 }

  00d38	eaffffda	 b           |$LN7@NAND_Read|
  00d3c		 |$LN6@NAND_Read|
  00d3c		 |$LN8@NAND_Read|

; 610  :         }
; 611  : 
; 612  :     // get ECC result
; 613  :     if (pEcc != NULL)

  00d3c	e59d3020	 ldr         r3, [sp, #0x20]
  00d40	e3530000	 cmp         r3, #0
  00d44	0a000008	 beq         |$LN2@NAND_Read|

; 614  :         {
; 615  :         // UNDONE:
; 616  :         //  should pass in sector size???
; 617  :         ECC_Result(pDevice->pGpmcRegs, pEcc, pDevice->ECCsize);

  00d48	e59d3000	 ldr         r3, [sp]
  00d4c	e2833064	 add         r3, r3, #0x64
  00d50	e5932000	 ldr         r2, [r3]
  00d54	e59d1020	 ldr         r1, [sp, #0x20]
  00d58	e59d3000	 ldr         r3, [sp]
  00d5c	e283302c	 add         r3, r3, #0x2C
  00d60	e5930000	 ldr         r0, [r3]
  00d64	eb000000	 bl          ECC_Result

; 618  :         }
; 619  :     else

  00d68	ea000003	 b           |$LN1@NAND_Read|
  00d6c		 |$LN2@NAND_Read|

; 620  :     	{
; 621  :     	ECC_Reset(pDevice->pGpmcRegs);

  00d6c	e59d3000	 ldr         r3, [sp]
  00d70	e283302c	 add         r3, r3, #0x2C
  00d74	e5930000	 ldr         r0, [r3]
  00d78	eb000000	 bl          ECC_Reset
  00d7c		 |$LN1@NAND_Read|

; 622  :     	}
; 623  :     return TRUE;

  00d7c	e3a03001	 mov         r3, #1
  00d80	e58d3008	 str         r3, [sp, #8]

; 624  : }

  00d84	e59d0008	 ldr         r0, [sp, #8]
  00d88	e28dd00c	 add         sp, sp, #0xC
  00d8c	e89d6000	 ldmia       sp, {sp, lr}
  00d90	e12fff1e	 bx          lr
  00d94		 |$M46667|

			 ENDP  ; |NAND_Read|


  00068			 AREA	 |.pdata|, PDATA
|$T46675| DCD	|$LN5@NAND_Mutex|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00d94			 AREA	 |.text|, CODE, ARM

  00d94		 |NAND_MutexEnter| PROC

; 775  : {   

  00d94		 |$LN5@NAND_Mutex|
  00d94	e1a0c00d	 mov         r12, sp
  00d98	e92d0001	 stmdb       sp!, {r0}
  00d9c	e92d5000	 stmdb       sp!, {r12, lr}
  00da0	e24dd004	 sub         sp, sp, #4
  00da4		 |$M46672|

; 776  : #ifdef DEVICE_MODE
; 777  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 778  :     EnterCriticalSection(&pDevice->cs); 
; 779  :     return pDevice->cs.LockCount;
; 780  : #else
; 781  :     UNREFERENCED_PARAMETER(hNand);
; 782  :     return 0;

  00da4	e3a03000	 mov         r3, #0
  00da8	e58d3000	 str         r3, [sp]

; 783  : #endif
; 784  : }

  00dac	e59d0000	 ldr         r0, [sp]
  00db0	e28dd004	 add         sp, sp, #4
  00db4	e89d6000	 ldmia       sp, {sp, lr}
  00db8	e12fff1e	 bx          lr
  00dbc		 |$M46673|

			 ENDP  ; |NAND_MutexEnter|


  00070			 AREA	 |.pdata|, PDATA
|$T46681| DCD	|$LN5@NAND_Mutex@2|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00dbc			 AREA	 |.text|, CODE, ARM

  00dbc		 |NAND_MutexExit| PROC

; 791  : {

  00dbc		 |$LN5@NAND_Mutex@2|
  00dbc	e1a0c00d	 mov         r12, sp
  00dc0	e92d0001	 stmdb       sp!, {r0}
  00dc4	e92d5000	 stmdb       sp!, {r12, lr}
  00dc8	e24dd004	 sub         sp, sp, #4
  00dcc		 |$M46678|

; 792  : #ifdef DEVICE_MODE
; 793  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;
; 794  :     LeaveCriticalSection(&pDevice->cs); 
; 795  :     return pDevice->cs.LockCount;
; 796  : #else
; 797  :     UNREFERENCED_PARAMETER(hNand);
; 798  :     return 0;

  00dcc	e3a03000	 mov         r3, #0
  00dd0	e58d3000	 str         r3, [sp]

; 799  : #endif
; 800  : }

  00dd4	e59d0000	 ldr         r0, [sp]
  00dd8	e28dd004	 add         sp, sp, #4
  00ddc	e89d6000	 ldmia       sp, {sp, lr}
  00de0	e12fff1e	 bx          lr
  00de4		 |$M46679|

			 ENDP  ; |NAND_MutexExit|

	EXPORT	|??_C@_1FO@NIMLMHMI@?$AAN?$AAA?$AAN?$AAD?$AA_?$AAC?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AAE?$AAc?$AAc?$AAD?$AAa?$AAt?$AAa?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAs?$AA?5?$AAF?$AAA?$AAL?$AAS@| [ DATA ] ; `string'
	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|FMD_ReadSector|
	IMPORT	|__security_cookie|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_check_cookie|

  00078			 AREA	 |.pdata|, PDATA
|$T46695| DCD	|$LN25@FMD_ReadSe@2|
	DCD	0xc0012204

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FO@NIMLMHMI@?$AAN?$AAA?$AAN?$AAD?$AA_?$AAC?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AAE?$AAc?$AAc?$AAD?$AAa?$AAt?$AAa?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAs?$AA?5?$AAF?$AAA?$AAL?$AAS@| DCB "N"
	DCB	0x0, "A", 0x0, "N", 0x0, "D", 0x0, "_", 0x0, "C", 0x0, "o"
	DCB	0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c", 0x0, "t", 0x0, "E"
	DCB	0x0, "c", 0x0, "c", 0x0, "D", 0x0, "a", 0x0, "t", 0x0, "a"
	DCB	0x0, " ", 0x0, "r", 0x0, "e", 0x0, "t", 0x0, "u", 0x0, "r"
	DCB	0x0, "n", 0x0, "s", 0x0, " ", 0x0, "F", 0x0, "A", 0x0, "L"
	DCB	0x0, "S", 0x0, "E", 0x0, ",", 0x0, " ", 0x0, "s", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, "o", 0x0, "r", 0x0, "=", 0x0, "%"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.xdata|, DATA
|$T46691| DCD	0xffffffc4
; Function compile flags: /Odtp

  00de4			 AREA	 |.text|, CODE, ARM

  00de4	00000000	 DCD         |__GSHandlerCheck|
  00de8	00000000	 DCD         |$T46691|

  00dec		 |FMD_ReadSector| PROC

; 1079 : {

  00dec		 |$LN25@FMD_ReadSe@2|
  00dec	e1a0c00d	 mov         r12, sp
  00df0	e92d000f	 stmdb       sp!, {r0 - r3}
  00df4	e92d5000	 stmdb       sp!, {r12, lr}
  00df8	e24dd0b0	 sub         sp, sp, #0xB0
  00dfc		 |$M46692|
  00dfc	e59f346c	 ldr         r3, [pc, #0x46C]
  00e00	e5933000	 ldr         r3, [r3]
  00e04	e58d308c	 str         r3, [sp, #0x8C]

; 1080 :     BOOL rc = FALSE;

  00e08	e3a03000	 mov         r3, #0
  00e0c	e58d3008	 str         r3, [sp, #8]

; 1081 :     NAND_SPARE_AREA sa;
; 1082 :     UINT32 oldIdleMode;
; 1083 :     UINT32 sectorSize;
; 1084 :     BYTE rgEcc[ECC_BYTES];
; 1085 : 
; 1086 :     // Fail if FMD wasn't opened
; 1087 :     if (s_hNand == NULL) goto cleanUp;

  00e10	e59f3450	 ldr         r3, [pc, #0x450]
  00e14	e5933000	 ldr         r3, [r3]
  00e18	e3530000	 cmp         r3, #0
  00e1c	1a000000	 bne         |$LN18@FMD_ReadSe@2|
  00e20	ea0000ef	 b           |$cleanUp$46340|
  00e24		 |$LN18@FMD_ReadSe@2|

; 1088 :     
; 1089 :     NAND_MutexEnter(s_hNand);

  00e24	e59f343c	 ldr         r3, [pc, #0x43C]
  00e28	e5930000	 ldr         r0, [r3]
  00e2c	eb000000	 bl          NAND_MutexEnter

; 1090 : 
; 1091 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1092 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;

  00e30	e59f3430	 ldr         r3, [pc, #0x430]
  00e34	e5930000	 ldr         r0, [r3]
  00e38	eb000000	 bl          NAND_GetGeometry
  00e3c	e58d0098	 str         r0, [sp, #0x98]
  00e40	e59d3098	 ldr         r3, [sp, #0x98]
  00e44	e283300c	 add         r3, r3, #0xC
  00e48	e5933000	 ldr         r3, [r3]
  00e4c	e58d3004	 str         r3, [sp, #4]

; 1093 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  00e50	e59f3410	 ldr         r3, [pc, #0x410]
  00e54	e5930000	 ldr         r0, [r3]
  00e58	eb000000	 bl          NAND_GetGpmcRegs
  00e5c	e58d009c	 str         r0, [sp, #0x9C]
  00e60	e59d309c	 ldr         r3, [sp, #0x9C]
  00e64	e2833010	 add         r3, r3, #0x10
  00e68	e5933000	 ldr         r3, [r3]
  00e6c	e58d3080	 str         r3, [sp, #0x80]

; 1094 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  00e70	e59f33f0	 ldr         r3, [pc, #0x3F0]
  00e74	e5930000	 ldr         r0, [r3]
  00e78	eb000000	 bl          NAND_GetGpmcRegs
  00e7c	e58d00a0	 str         r0, [sp, #0xA0]
  00e80	e59d30a0	 ldr         r3, [sp, #0xA0]
  00e84	e2832010	 add         r2, r3, #0x10
  00e88	e3a03008	 mov         r3, #8
  00e8c	e5823000	 str         r3, [r2]
  00e90		 |$LN17@FMD_ReadSe@2|

; 1095 : 	
; 1096 :     while (sectors > 0)

  00e90	e59d30c4	 ldr         r3, [sp, #0xC4]
  00e94	e3530000	 cmp         r3, #0
  00e98	9a0000c7	 bls         |$LN16@FMD_ReadSe@2|

; 1097 :         {
; 1098 :         //  Only enable during NAND read/write/erase operations
; 1099 :         NAND_Enable(s_hNand, TRUE);

  00e9c	e3a01001	 mov         r1, #1
  00ea0	e59f33c0	 ldr         r3, [pc, #0x3C0]
  00ea4	e5930000	 ldr         r0, [r3]
  00ea8	eb000000	 bl          NAND_Enable

; 1100 :         
; 1101 :         // Read sector from A
; 1102 :         if (pBuffer != NULL)

  00eac	e59d30bc	 ldr         r3, [sp, #0xBC]
  00eb0	e3530000	 cmp         r3, #0
  00eb4	0a00002a	 beq         |$LN15@FMD_ReadSe@2|

; 1103 :             {
; 1104 :             // be sure to do this before sending the READ command and not after ! or the
; 1105 :             // status register would remain at status read mode, which would have to be changed
; 1106 :             // before retreiving the data
; 1107 :             WaitForReadyStatus(s_hNand);

  00eb8	e59f33a8	 ldr         r3, [pc, #0x3A8]
  00ebc	e5930000	 ldr         r0, [r3]
  00ec0	eb000000	 bl          WaitForReadyStatus

; 1108 : 
; 1109 : 			
; 1110 :             // configure prefetch engine for input and start it
; 1111 :             NAND_ConfigurePrefetch(s_hNand, NAND_DATA_READ);

  00ec4	e3a01001	 mov         r1, #1
  00ec8	e59f3398	 ldr         r3, [pc, #0x398]
  00ecc	e5930000	 ldr         r0, [r3]
  00ed0	eb000000	 bl          NAND_ConfigurePrefetch

; 1112 :            
; 1113 :             // Send the command
; 1114 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00ed4	e3a01000	 mov         r1, #0
  00ed8	e59f3388	 ldr         r3, [pc, #0x388]
  00edc	e5930000	 ldr         r0, [r3]
  00ee0	eb000000	 bl          NAND_SendCommand

; 1115 : 
; 1116 :             // Send the address
; 1117 :             NAND_Seek(s_hNand, sector, 0);

  00ee4	e3a02000	 mov         r2, #0
  00ee8	e59d10b8	 ldr         r1, [sp, #0xB8]
  00eec	e59f3374	 ldr         r3, [pc, #0x374]
  00ef0	e5930000	 ldr         r0, [r3]
  00ef4	eb000000	 bl          NAND_Seek

; 1118 : 
; 1119 :             // Send the command
; 1120 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00ef8	e3a01030	 mov         r1, #0x30
  00efc	e59f3364	 ldr         r3, [pc, #0x364]
  00f00	e5930000	 ldr         r0, [r3]
  00f04	eb000000	 bl          NAND_SendCommand

; 1121 : 
; 1122 :             // Wait for the action to finish
; 1123 :             WaitForReadyStatus(s_hNand);

  00f08	e59f3358	 ldr         r3, [pc, #0x358]
  00f0c	e5930000	 ldr         r0, [r3]
  00f10	eb000000	 bl          WaitForReadyStatus

; 1124 : 
; 1125 :             //Force a read here, else we will read the status again
; 1126 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00f14	e3a01000	 mov         r1, #0
  00f18	e59f3348	 ldr         r3, [pc, #0x348]
  00f1c	e5930000	 ldr         r0, [r3]
  00f20	eb000000	 bl          NAND_SendCommand

; 1127 : 
; 1128 : 	     // read data
; 1129 :             NAND_Read(s_hNand, pBuffer, sectorSize, rgEcc);

  00f24	e28d300c	 add         r3, sp, #0xC
  00f28	e59d2004	 ldr         r2, [sp, #4]
  00f2c	e59d10bc	 ldr         r1, [sp, #0xBC]
  00f30	e59f0330	 ldr         r0, [pc, #0x330]
  00f34	e5900000	 ldr         r0, [r0]
  00f38	eb000000	 bl          NAND_Read

; 1130 : 			
; 1131 :             // read spare area
; 1132 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00f3c	e3a03000	 mov         r3, #0
  00f40	e3a02040	 mov         r2, #0x40
  00f44	e28d1040	 add         r1, sp, #0x40
  00f48	e59f0318	 ldr         r0, [pc, #0x318]
  00f4c	e5900000	 ldr         r0, [r0]
  00f50	eb000000	 bl          NAND_Read

; 1133 : 
; 1134 :             // Make sure of the NAND status
; 1135 :             WaitForReadyStatus(s_hNand);

  00f54	e59f330c	 ldr         r3, [pc, #0x30C]
  00f58	e5930000	 ldr         r0, [r3]
  00f5c	eb000000	 bl          WaitForReadyStatus

; 1136 :             }
; 1137 :         else

  00f60	ea00001f	 b           |$LN14@FMD_ReadSe@2|
  00f64		 |$LN15@FMD_ReadSe@2|

; 1138 :          {
; 1139 :             // Make sure of the NAND status
; 1140 :             WaitForReadyStatus(s_hNand);

  00f64	e59f32fc	 ldr         r3, [pc, #0x2FC]
  00f68	e5930000	 ldr         r0, [r3]
  00f6c	eb000000	 bl          WaitForReadyStatus

; 1141 :             // Send the command
; 1142 :             NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  00f70	e3a01000	 mov         r1, #0
  00f74	e59f32ec	 ldr         r3, [pc, #0x2EC]
  00f78	e5930000	 ldr         r0, [r3]
  00f7c	eb000000	 bl          NAND_SendCommand

; 1143 :     
; 1144 :             // Send the address
; 1145 :             NAND_Seek(s_hNand, sector, sectorSize);

  00f80	e59d2004	 ldr         r2, [sp, #4]
  00f84	e59d10b8	 ldr         r1, [sp, #0xB8]
  00f88	e59f32d8	 ldr         r3, [pc, #0x2D8]
  00f8c	e5930000	 ldr         r0, [r3]
  00f90	eb000000	 bl          NAND_Seek

; 1146 :     
; 1147 :             // Send the command
; 1148 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  00f94	e3a01030	 mov         r1, #0x30
  00f98	e59f32c8	 ldr         r3, [pc, #0x2C8]
  00f9c	e5930000	 ldr         r0, [r3]
  00fa0	eb000000	 bl          NAND_SendCommand

; 1149 :     
; 1150 :             // Wait for the action to finish
; 1151 :             WaitForReadyStatus(s_hNand);

  00fa4	e59f32bc	 ldr         r3, [pc, #0x2BC]
  00fa8	e5930000	 ldr         r0, [r3]
  00fac	eb000000	 bl          WaitForReadyStatus

; 1152 :             //Force a read here, else we will read the status again
; 1153 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  00fb0	e3a01000	 mov         r1, #0
  00fb4	e59f32ac	 ldr         r3, [pc, #0x2AC]
  00fb8	e5930000	 ldr         r0, [r3]
  00fbc	eb000000	 bl          NAND_SendCommand

; 1154 :     
; 1155 :             // read spare area
; 1156 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  00fc0	e3a03000	 mov         r3, #0
  00fc4	e3a02040	 mov         r2, #0x40
  00fc8	e28d1040	 add         r1, sp, #0x40
  00fcc	e59f0294	 ldr         r0, [pc, #0x294]
  00fd0	e5900000	 ldr         r0, [r0]
  00fd4	eb000000	 bl          NAND_Read

; 1157 : 
; 1158 :             // Make sure of the NAND status
; 1159 :             WaitForReadyStatus(s_hNand);

  00fd8	e59f3288	 ldr         r3, [pc, #0x288]
  00fdc	e5930000	 ldr         r0, [r3]
  00fe0	eb000000	 bl          WaitForReadyStatus
  00fe4		 |$LN14@FMD_ReadSe@2|

; 1160 :     
; 1161 :         }        // Copy sector info
; 1162 :         if (pSectorInfo != NULL)

  00fe4	e59d30c0	 ldr         r3, [sp, #0xC0]
  00fe8	e3530000	 cmp         r3, #0
  00fec	0a00001e	 beq         |$LN13@FMD_ReadSe@2|

; 1163 :             {
; 1164 :             pSectorInfo->bBadBlock    = sa.hwBadBlock[0] & sa.hwBadBlock[1];    // HW bad block check

  00ff0	e5dd3040	 ldrb        r3, [sp, #0x40]
  00ff4	e1a02003	 mov         r2, r3
  00ff8	e5dd3041	 ldrb        r3, [sp, #0x41]
  00ffc	e0021003	 and         r1, r2, r3
  01000	e59d30c0	 ldr         r3, [sp, #0xC0]
  01004	e2832005	 add         r2, r3, #5
  01008	e20130ff	 and         r3, r1, #0xFF
  0100c	e5c23000	 strb        r3, [r2]

; 1165 :             pSectorInfo->bBadBlock    = pSectorInfo->bBadBlock & sa.swBadBlock; // SW bad block flag check

  01010	e59d30c0	 ldr         r3, [sp, #0xC0]
  01014	e2833005	 add         r3, r3, #5
  01018	e5d33000	 ldrb        r3, [r3]
  0101c	e1a02003	 mov         r2, r3
  01020	e5dd307c	 ldrb        r3, [sp, #0x7C]
  01024	e0021003	 and         r1, r2, r3
  01028	e59d30c0	 ldr         r3, [sp, #0xC0]
  0102c	e2832005	 add         r2, r3, #5
  01030	e20130ff	 and         r3, r1, #0xFF
  01034	e5c23000	 strb        r3, [r2]

; 1166 :             pSectorInfo->bOEMReserved = sa.oemReserved;

  01038	e59d30c0	 ldr         r3, [sp, #0xC0]
  0103c	e2832004	 add         r2, r3, #4
  01040	e5dd307d	 ldrb        r3, [sp, #0x7D]
  01044	e5c23000	 strb        r3, [r2]

; 1167 : 
; 1168 :             memcpy(
; 1169 :                 &pSectorInfo->dwReserved1, sa.reserved1,
; 1170 :                 sizeof(pSectorInfo->dwReserved1)
; 1171 :                 );

  01048	e3a02004	 mov         r2, #4
  0104c	e28d1076	 add         r1, sp, #0x76
  01050	e59d00c0	 ldr         r0, [sp, #0xC0]
  01054	eb000000	 bl          memcpy

; 1172 : 
; 1173 :             memcpy(
; 1174 :                 &pSectorInfo->wReserved2, sa.reserved2,
; 1175 :                 sizeof(pSectorInfo->wReserved2)
; 1176 :                 );

  01058	e3a02002	 mov         r2, #2
  0105c	e28d107a	 add         r1, sp, #0x7A
  01060	e59d30c0	 ldr         r3, [sp, #0xC0]
  01064	e2830006	 add         r0, r3, #6
  01068	eb000000	 bl          memcpy
  0106c		 |$LN13@FMD_ReadSe@2|

; 1177 :             }
; 1178 :         
; 1179 :         //  Only enable during NAND read/write/erase operations
; 1180 :         NAND_Enable(s_hNand, FALSE);

  0106c	e3a01000	 mov         r1, #0
  01070	e59f31f0	 ldr         r3, [pc, #0x1F0]
  01074	e5930000	 ldr         r0, [r3]
  01078	eb000000	 bl          NAND_Enable

; 1181 : 
; 1182 :         // perform ecc correction and correct data when possible
; 1183 :         if ((pBuffer != NULL) &&
; 1184 :             (NAND_CorrectEccData(s_hNand, pBuffer, sectorSize, sa.ecc, rgEcc) == FALSE))

  0107c	e59d30bc	 ldr         r3, [sp, #0xBC]
  01080	e3530000	 cmp         r3, #0
  01084	0a00003b	 beq         |$LN12@FMD_ReadSe@2|
  01088	e28d300c	 add         r3, sp, #0xC
  0108c	e58d3000	 str         r3, [sp]
  01090	e28d3042	 add         r3, sp, #0x42
  01094	e59d2004	 ldr         r2, [sp, #4]
  01098	e59d10bc	 ldr         r1, [sp, #0xBC]
  0109c	e59f01c4	 ldr         r0, [pc, #0x1C4]
  010a0	e5900000	 ldr         r0, [r0]
  010a4	eb000000	 bl          NAND_CorrectEccData
  010a8	e58d00a4	 str         r0, [sp, #0xA4]
  010ac	e59d30a4	 ldr         r3, [sp, #0xA4]
  010b0	e3530000	 cmp         r3, #0
  010b4	1a00002f	 bne         |$LN12@FMD_ReadSe@2|

; 1185 :             {
; 1186 :             UINT count;
; 1187 :             UCHAR *pData = pBuffer;

  010b8	e59d30bc	 ldr         r3, [sp, #0xBC]
  010bc	e58d3084	 str         r3, [sp, #0x84]

; 1188 :             DEBUGMSG (ZONE_ERROR, (L"NAND_CorrectEccData returns FALSE, sector=%d\r\n", sector));	

  010c0	e59d10b8	 ldr         r1, [sp, #0xB8]
  010c4	e59f01a0	 ldr         r0, [pc, #0x1A0]
  010c8	eb000000	 bl          NKDbgPrintfW

; 1189 : 
; 1190 :             for (count = 0; count < sizeof(sa); count++)

  010cc	e3a03000	 mov         r3, #0
  010d0	e58d3088	 str         r3, [sp, #0x88]
  010d4	ea000002	 b           |$LN11@FMD_ReadSe@2|
  010d8		 |$LN10@FMD_ReadSe@2|
  010d8	e59d3088	 ldr         r3, [sp, #0x88]
  010dc	e2833001	 add         r3, r3, #1
  010e0	e58d3088	 str         r3, [sp, #0x88]
  010e4		 |$LN11@FMD_ReadSe@2|
  010e4	e59d3088	 ldr         r3, [sp, #0x88]
  010e8	e3530040	 cmp         r3, #0x40
  010ec	2a00000e	 bcs         |$LN9@FMD_ReadSe@2|

; 1191 :                 {
; 1192 :                 // Allow OEMReserved byte to be set to reserved/readonly
; 1193 :                 if (&(((UINT8*)&sa)[count]) == &sa.oemReserved) continue;

  010f0	e28d2040	 add         r2, sp, #0x40
  010f4	e59d3088	 ldr         r3, [sp, #0x88]
  010f8	e0822003	 add         r2, r2, r3
  010fc	e28d307d	 add         r3, sp, #0x7D
  01100	e1520003	 cmp         r2, r3
  01104	1a000000	 bne         |$LN8@FMD_ReadSe@2|
  01108	eafffff2	 b           |$LN10@FMD_ReadSe@2|
  0110c		 |$LN8@FMD_ReadSe@2|

; 1194 :                 if (((UINT8*)&sa)[count] != 0xFF) goto cleanUp;

  0110c	e28d2040	 add         r2, sp, #0x40
  01110	e59d3088	 ldr         r3, [sp, #0x88]
  01114	e0823003	 add         r3, r2, r3
  01118	e5d33000	 ldrb        r3, [r3]
  0111c	e35300ff	 cmp         r3, #0xFF
  01120	0a000000	 beq         |$LN7@FMD_ReadSe@2|
  01124	ea00002e	 b           |$cleanUp$46340|
  01128		 |$LN7@FMD_ReadSe@2|

; 1195 :                 }

  01128	eaffffea	 b           |$LN10@FMD_ReadSe@2|
  0112c		 |$LN9@FMD_ReadSe@2|

; 1196 : 
; 1197 :             for (count = 0; count < sectorSize; count++)

  0112c	e3a03000	 mov         r3, #0
  01130	e58d3088	 str         r3, [sp, #0x88]
  01134	ea000002	 b           |$LN6@FMD_ReadSe@2|
  01138		 |$LN5@FMD_ReadSe@2|
  01138	e59d3088	 ldr         r3, [sp, #0x88]
  0113c	e2833001	 add         r3, r3, #1
  01140	e58d3088	 str         r3, [sp, #0x88]
  01144		 |$LN6@FMD_ReadSe@2|
  01144	e59d2088	 ldr         r2, [sp, #0x88]
  01148	e59d3004	 ldr         r3, [sp, #4]
  0114c	e1520003	 cmp         r2, r3
  01150	2a000008	 bcs         |$LN4@FMD_ReadSe@2|

; 1198 :                 {
; 1199 :                 if (*pData != 0xFF) goto cleanUp;

  01154	e59d3084	 ldr         r3, [sp, #0x84]
  01158	e5d33000	 ldrb        r3, [r3]
  0115c	e35300ff	 cmp         r3, #0xFF
  01160	0a000000	 beq         |$LN3@FMD_ReadSe@2|
  01164	ea00001e	 b           |$cleanUp$46340|
  01168		 |$LN3@FMD_ReadSe@2|

; 1200 :                 ++pData;

  01168	e59d3084	 ldr         r3, [sp, #0x84]
  0116c	e2833001	 add         r3, r3, #1
  01170	e58d3084	 str         r3, [sp, #0x84]

; 1201 :                 }

  01174	eaffffef	 b           |$LN5@FMD_ReadSe@2|
  01178		 |$LN4@FMD_ReadSe@2|
  01178		 |$LN12@FMD_ReadSe@2|

; 1202 :             }
; 1203 :         
; 1204 :         // Move to next sector
; 1205 :         sector++;

  01178	e59d30b8	 ldr         r3, [sp, #0xB8]
  0117c	e2833001	 add         r3, r3, #1
  01180	e58d30b8	 str         r3, [sp, #0xB8]

; 1206 :         if (pBuffer != NULL) pBuffer += sectorSize;

  01184	e59d30bc	 ldr         r3, [sp, #0xBC]
  01188	e3530000	 cmp         r3, #0
  0118c	0a000003	 beq         |$LN2@FMD_ReadSe@2|
  01190	e59d20bc	 ldr         r2, [sp, #0xBC]
  01194	e59d3004	 ldr         r3, [sp, #4]
  01198	e0823003	 add         r3, r2, r3
  0119c	e58d30bc	 str         r3, [sp, #0xBC]
  011a0		 |$LN2@FMD_ReadSe@2|

; 1207 :         pSectorInfo++;

  011a0	e59d30c0	 ldr         r3, [sp, #0xC0]
  011a4	e2833008	 add         r3, r3, #8
  011a8	e58d30c0	 str         r3, [sp, #0xC0]

; 1208 :         sectors--;

  011ac	e59d30c4	 ldr         r3, [sp, #0xC4]
  011b0	e2433001	 sub         r3, r3, #1
  011b4	e58d30c4	 str         r3, [sp, #0xC4]

; 1209 :         }

  011b8	eaffff34	 b           |$LN17@FMD_ReadSe@2|
  011bc		 |$LN16@FMD_ReadSe@2|

; 1210 : 
; 1211 :     //  Change idle mode back
; 1212 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  011bc	e59f30a4	 ldr         r3, [pc, #0xA4]
  011c0	e5930000	 ldr         r0, [r3]
  011c4	eb000000	 bl          NAND_GetGpmcRegs
  011c8	e58d00a8	 str         r0, [sp, #0xA8]
  011cc	e59d30a8	 ldr         r3, [sp, #0xA8]
  011d0	e2832010	 add         r2, r3, #0x10
  011d4	e59d3080	 ldr         r3, [sp, #0x80]
  011d8	e5823000	 str         r3, [r2]

; 1213 :     
; 1214 :     // Done
; 1215 :     rc = TRUE;

  011dc	e3a03001	 mov         r3, #1
  011e0	e58d3008	 str         r3, [sp, #8]
  011e4		 |$cleanUp$46340|

; 1216 : 
; 1217 : cleanUp:
; 1218 :     // Release hardware lock
; 1219 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  011e4	e59f307c	 ldr         r3, [pc, #0x7C]
  011e8	e5933000	 ldr         r3, [r3]
  011ec	e3530000	 cmp         r3, #0
  011f0	0a000002	 beq         |$LN1@FMD_ReadSe@2|
  011f4	e59f306c	 ldr         r3, [pc, #0x6C]
  011f8	e5930000	 ldr         r0, [r3]
  011fc	eb000000	 bl          NAND_MutexExit
  01200		 |$LN1@FMD_ReadSe@2|

; 1220 :     
; 1221 :     ASSERT(rc);

  01200	e59d3008	 ldr         r3, [sp, #8]
  01204	e3530000	 cmp         r3, #0
  01208	0a000002	 beq         |$LN21@FMD_ReadSe@2|
  0120c	e3a03001	 mov         r3, #1
  01210	e58d30ac	 str         r3, [sp, #0xAC]
  01214	ea000008	 b           |$LN22@FMD_ReadSe@2|
  01218		 |$LN21@FMD_ReadSe@2|
  01218	e3a03b01	 mov         r3, #1, 22
  0121c	e38330c5	 orr         r3, r3, #0xC5
  01220	e59f203c	 ldr         r2, [pc, #0x3C]
  01224	e59f1034	 ldr         r1, [pc, #0x34]
  01228	e59f002c	 ldr         r0, [pc, #0x2C]
  0122c	eb000000	 bl          NKDbgPrintfW
  01230	e6000010	 __debugbreak_ce
  01234	e3a03000	 mov         r3, #0
  01238	e58d30ac	 str         r3, [sp, #0xAC]
  0123c		 |$LN22@FMD_ReadSe@2|

; 1222 :     return rc;

  0123c	e59d008c	 ldr         r0, [sp, #0x8C]
  01240	eb000000	 bl          __security_check_cookie
  01244	e59d3008	 ldr         r3, [sp, #8]
  01248	e58d3094	 str         r3, [sp, #0x94]

; 1223 : }

  0124c	e59d0094	 ldr         r0, [sp, #0x94]
  01250	e28dd0b0	 add         sp, sp, #0xB0
  01254	e89d6000	 ldmia       sp, {sp, lr}
  01258	e12fff1e	 bx          lr
  0125c		 |$LN26@FMD_ReadSe@2|
  0125c		 |$LN27@FMD_ReadSe@2|
  0125c	00000000	 DCD         |??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@|
  01260		 |$LN28@FMD_ReadSe@2|
  01260	00000000	 DCD         |??_C@_1BA@LEPJIIOK@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@|
  01264		 |$LN29@FMD_ReadSe@2|
  01264	00000000	 DCD         |??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  01268		 |$LN30@FMD_ReadSe@2|
  01268	00000000	 DCD         |s_hNand|
  0126c		 |$LN31@FMD_ReadSe@2|
  0126c	00000000	 DCD         |??_C@_1FO@NIMLMHMI@?$AAN?$AAA?$AAN?$AAD?$AA_?$AAC?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AAE?$AAc?$AAc?$AAD?$AAa?$AAt?$AAa?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAs?$AA?5?$AAF?$AAA?$AAL?$AAS@|
  01270		 |$LN32@FMD_ReadSe@2|
  01270	00000000	 DCD         |__security_cookie|
  01274		 |$M46693|

			 ENDP  ; |FMD_ReadSector|


  00080			 AREA	 |.pdata|, PDATA
|$T46708| DCD	|$LN7@NAND_Confi|
	DCD	0x40004604
; Function compile flags: /Odtp

  01274			 AREA	 |.text|, CODE, ARM

  01274		 |NAND_ConfigurePrefetch| PROC

; 820  : {

  01274		 |$LN7@NAND_Confi|
  01274	e1a0c00d	 mov         r12, sp
  01278	e92d0003	 stmdb       sp!, {r0, r1}
  0127c	e92d5000	 stmdb       sp!, {r12, lr}
  01280	e24dd014	 sub         sp, sp, #0x14
  01284		 |$M46705|

; 821  :     DWORD chipSelect = BSPGetNandCS();

  01284	eb000000	 bl          BSPGetNandCS
  01288	e58d0010	 str         r0, [sp, #0x10]
  0128c	e59d3010	 ldr         r3, [sp, #0x10]
  01290	e58d3004	 str         r3, [sp, #4]

; 822  :     UINT ffPrefetchMode = 0;

  01294	e3a03000	 mov         r3, #0
  01298	e58d3008	 str         r3, [sp, #8]

; 823  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  0129c	e59d301c	 ldr         r3, [sp, #0x1C]
  012a0	e58d3000	 str         r3, [sp]

; 824  : 
; 825  :     // disable prefetch engine
; 826  :     pDevice->prefetchMode = kPrefetchOff;

  012a4	e59d3000	 ldr         r3, [sp]
  012a8	e2832018	 add         r2, r3, #0x18
  012ac	e3a03000	 mov         r3, #0
  012b0	e5823000	 str         r3, [r2]

; 827  :     
; 828  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 0);

  012b4	e59d3000	 ldr         r3, [sp]
  012b8	e283302c	 add         r3, r3, #0x2C
  012bc	e5933000	 ldr         r3, [r3]
  012c0	e2832f7b	 add         r2, r3, #0x7B, 30
  012c4	e3a03000	 mov         r3, #0
  012c8	e5823000	 str         r3, [r2]

; 829  : 
; 830  :     // set prefetch mask
; 831  :     ffPrefetchMode = GPMC_PREFETCH_CONFIG_PFPWENROUNDROBIN |
; 832  :                      GPMC_PREFETCH_CONFIG_ENABLEOPTIMIZEDACCESS |
; 833  :                      GPMC_PREFETCH_CONFIG_WAITPINSELECTOR(chipSelect) |
; 834  :                      GPMC_PREFETCH_CONFIG_FIFOTHRESHOLD(FIFO_THRESHOLD) |
; 835  :                      GPMC_PREFETCH_CONFIG_ENGINECSSELECTOR(chipSelect);

  012cc	e59d3004	 ldr         r3, [sp, #4]
  012d0	e1a03203	 mov         r3, r3, lsl #4
  012d4	e2033030	 and         r3, r3, #0x30
  012d8	e3833522	 orr         r3, r3, #0x22, 10
  012dc	e3832901	 orr         r2, r3, #1, 18
  012e0	e59d3004	 ldr         r3, [sp, #4]
  012e4	e1a03c03	 mov         r3, r3, lsl #24
  012e8	e2033407	 and         r3, r3, #7, 8
  012ec	e1823003	 orr         r3, r2, r3
  012f0	e58d3008	 str         r3, [sp, #8]

; 836  : 
; 837  :     if (accessType == NAND_DATA_WRITE)

  012f4	e59d3020	 ldr         r3, [sp, #0x20]
  012f8	e3530002	 cmp         r3, #2
  012fc	1a000007	 bne         |$LN2@NAND_Confi|

; 838  :         {
; 839  :         pDevice->prefetchMode = kPrefetchWrite;

  01300	e59d3000	 ldr         r3, [sp]
  01304	e2832018	 add         r2, r3, #0x18
  01308	e3a03002	 mov         r3, #2
  0130c	e5823000	 str         r3, [r2]

; 840  :         ffPrefetchMode |= GPMC_PREFETCH_CONFIG_WRITEPOST;

  01310	e59d3008	 ldr         r3, [sp, #8]
  01314	e3833001	 orr         r3, r3, #1
  01318	e58d3008	 str         r3, [sp, #8]

; 841  :         }
; 842  :     else

  0131c	ea000003	 b           |$LN1@NAND_Confi|
  01320		 |$LN2@NAND_Confi|

; 843  :         {
; 844  :         pDevice->prefetchMode = kPrefetchRead;

  01320	e59d3000	 ldr         r3, [sp]
  01324	e2832018	 add         r2, r3, #0x18
  01328	e3a03001	 mov         r3, #1
  0132c	e5823000	 str         r3, [r2]
  01330		 |$LN1@NAND_Confi|

; 845  :         }
; 846  :         
; 847  :     OUTREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, ffPrefetchMode);

  01330	e59d3000	 ldr         r3, [sp]
  01334	e283302c	 add         r3, r3, #0x2C
  01338	e5933000	 ldr         r3, [r3]
  0133c	e2832e1e	 add         r2, r3, #0x1E, 28
  01340	e59d3008	 ldr         r3, [sp, #8]
  01344	e5823000	 str         r3, [r2]

; 848  : 
; 849  :     SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONFIG1, 
; 850  :         GPMC_PREFETCH_CONFIG_ENABLEENGINE
; 851  :         );

  01348	e59d3000	 ldr         r3, [sp]
  0134c	e283302c	 add         r3, r3, #0x2C
  01350	e5933000	 ldr         r3, [r3]
  01354	e2833e1e	 add         r3, r3, #0x1E, 28
  01358	e5933000	 ldr         r3, [r3]
  0135c	e3832080	 orr         r2, r3, #0x80
  01360	e59d3000	 ldr         r3, [sp]
  01364	e283302c	 add         r3, r3, #0x2C
  01368	e5933000	 ldr         r3, [r3]
  0136c	e2833e1e	 add         r3, r3, #0x1E, 28
  01370	e5832000	 str         r2, [r3]

; 852  : 
; 853  :     return TRUE;

  01374	e3a03001	 mov         r3, #1
  01378	e58d300c	 str         r3, [sp, #0xC]

; 854  : }

  0137c	e59d000c	 ldr         r0, [sp, #0xC]
  01380	e28dd014	 add         sp, sp, #0x14
  01384	e89d6000	 ldmia       sp, {sp, lr}
  01388	e12fff1e	 bx          lr
  0138c		 |$M46706|

			 ENDP  ; |NAND_ConfigurePrefetch|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|FMD_WriteSector|

  00088			 AREA	 |.pdata|, PDATA
|$T46720| DCD	|$LN19@FMD_WriteS|
	DCD	0xc0010904

  00004			 AREA	 |.xdata|, DATA
|$T46716| DCD	0xffffffc0
; Function compile flags: /Odtp

  0138c			 AREA	 |.text|, CODE, ARM

  0138c	00000000	 DCD         |__GSHandlerCheck|
  01390	00000000	 DCD         |$T46716|

  01394		 |FMD_WriteSector| PROC

; 1236 : {

  01394		 |$LN19@FMD_WriteS|
  01394	e1a0c00d	 mov         r12, sp
  01398	e92d000f	 stmdb       sp!, {r0 - r3}
  0139c	e92d5000	 stmdb       sp!, {r12, lr}
  013a0	e24dd080	 sub         sp, sp, #0x80
  013a4		 |$M46717|
  013a4	e59f3408	 ldr         r3, [pc, #0x408]
  013a8	e5933000	 ldr         r3, [r3]
  013ac	e58d3058	 str         r3, [sp, #0x58]

; 1237 :     BOOL rc = FALSE;

  013b0	e3a03000	 mov         r3, #0
  013b4	e58d300c	 str         r3, [sp, #0xC]

; 1238 :     NAND_SPARE_AREA sa;
; 1239 :     UINT32 oldIdleMode;
; 1240 :     UINT32 sectorSize;
; 1241 :     SECTOR_ADDR startSector = sector;

  013b8	e59d3088	 ldr         r3, [sp, #0x88]
  013bc	e58d3004	 str         r3, [sp, #4]

; 1242 :     SECTOR_ADDR endSector = sector + sectors;

  013c0	e59d2088	 ldr         r2, [sp, #0x88]
  013c4	e59d3094	 ldr         r3, [sp, #0x94]
  013c8	e0823003	 add         r3, r2, r3
  013cc	e58d3050	 str         r3, [sp, #0x50]

; 1243 :     NandDevice_t *pDevice = (NandDevice_t*)s_hNand;

  013d0	e59f33d8	 ldr         r3, [pc, #0x3D8]
  013d4	e5933000	 ldr         r3, [r3]
  013d8	e58d3000	 str         r3, [sp]

; 1244 : 
; 1245 :     // Fail if FMD wasn't opened
; 1246 :     if (s_hNand == NULL) goto cleanUp;

  013dc	e59f33cc	 ldr         r3, [pc, #0x3CC]
  013e0	e5933000	 ldr         r3, [r3]
  013e4	e3530000	 cmp         r3, #0
  013e8	1a000000	 bne         |$LN10@FMD_WriteS|
  013ec	ea0000ce	 b           |$cleanUp$46400|
  013f0		 |$LN10@FMD_WriteS|

; 1247 :     
; 1248 :     // Obtain hardware lock
; 1249 :     NAND_MutexEnter(s_hNand);

  013f0	e59f33b8	 ldr         r3, [pc, #0x3B8]
  013f4	e5930000	 ldr         r0, [r3]
  013f8	eb000000	 bl          NAND_MutexEnter

; 1250 : 
; 1251 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1252 :     sectorSize = NAND_GetGeometry(s_hNand)->sectorSize;

  013fc	e59f33ac	 ldr         r3, [pc, #0x3AC]
  01400	e5930000	 ldr         r0, [r3]
  01404	eb000000	 bl          NAND_GetGeometry
  01408	e58d0060	 str         r0, [sp, #0x60]
  0140c	e59d3060	 ldr         r3, [sp, #0x60]
  01410	e283300c	 add         r3, r3, #0xC
  01414	e5933000	 ldr         r3, [r3]
  01418	e58d3008	 str         r3, [sp, #8]

; 1253 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  0141c	e59f338c	 ldr         r3, [pc, #0x38C]
  01420	e5930000	 ldr         r0, [r3]
  01424	eb000000	 bl          NAND_GetGpmcRegs
  01428	e58d0064	 str         r0, [sp, #0x64]
  0142c	e59d3064	 ldr         r3, [sp, #0x64]
  01430	e2833010	 add         r3, r3, #0x10
  01434	e5933000	 ldr         r3, [r3]
  01438	e58d3054	 str         r3, [sp, #0x54]

; 1254 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  0143c	e59f336c	 ldr         r3, [pc, #0x36C]
  01440	e5930000	 ldr         r0, [r3]
  01444	eb000000	 bl          NAND_GetGpmcRegs
  01448	e58d0068	 str         r0, [sp, #0x68]
  0144c	e59d3068	 ldr         r3, [sp, #0x68]
  01450	e2832010	 add         r2, r3, #0x10
  01454	e3a03008	 mov         r3, #8
  01458	e5823000	 str         r3, [r2]

; 1255 : 
; 1256 :     //  Only enable during NAND read/write/erase operations    
; 1257 :     NAND_Enable(s_hNand, TRUE);

  0145c	e3a01001	 mov         r1, #1
  01460	e59f3348	 ldr         r3, [pc, #0x348]
  01464	e5930000	 ldr         r0, [r3]
  01468	eb000000	 bl          NAND_Enable

; 1258 :     NAND_LockBlocks(s_hNand, startSector, endSector, FALSE);

  0146c	e3a03000	 mov         r3, #0
  01470	e59d2050	 ldr         r2, [sp, #0x50]
  01474	e59d1004	 ldr         r1, [sp, #4]
  01478	e59f0330	 ldr         r0, [pc, #0x330]
  0147c	e5900000	 ldr         r0, [r0]
  01480	eb000000	 bl          NAND_LockBlocks
  01484		 |$LN9@FMD_WriteS|

; 1259 :     
; 1260 :     while (sectors > 0)

  01484	e59d3094	 ldr         r3, [sp, #0x94]
  01488	e3530000	 cmp         r3, #0
  0148c	9a00008a	 bls         |$LN8@FMD_WriteS|

; 1261 :         {
; 1262 :         // Clear out spare area struct
; 1263 :         memset(&sa, 0xFF, sizeof(NAND_SPARE_AREA));

  01490	e3a02040	 mov         r2, #0x40
  01494	e3a010ff	 mov         r1, #0xFF
  01498	e28d0010	 add         r0, sp, #0x10
  0149c	eb000000	 bl          memset

; 1264 : 
; 1265 :         // When there is buffer write data
; 1266 :         if (pBuffer != NULL)

  014a0	e59d308c	 ldr         r3, [sp, #0x8C]
  014a4	e3530000	 cmp         r3, #0
  014a8	0a000013	 beq         |$LN7@FMD_WriteS|

; 1267 :             {
; 1268 :             // enable prefetch
; 1269 :             NAND_ConfigurePrefetch(s_hNand, NAND_DATA_WRITE);

  014ac	e3a01002	 mov         r1, #2
  014b0	e59f32f8	 ldr         r3, [pc, #0x2F8]
  014b4	e5930000	 ldr         r0, [r3]
  014b8	eb000000	 bl          NAND_ConfigurePrefetch

; 1270 : 
; 1271 :             // send the write command
; 1272 :             NAND_SendCommand(s_hNand, NAND_CMD_WRITE1);

  014bc	e3a01080	 mov         r1, #0x80
  014c0	e59f32e8	 ldr         r3, [pc, #0x2E8]
  014c4	e5930000	 ldr         r0, [r3]
  014c8	eb000000	 bl          NAND_SendCommand

; 1273 : 
; 1274 :             // send the address to write to
; 1275 :             NAND_Seek(s_hNand, sector, 0);

  014cc	e3a02000	 mov         r2, #0
  014d0	e59d1088	 ldr         r1, [sp, #0x88]
  014d4	e59f32d4	 ldr         r3, [pc, #0x2D4]
  014d8	e5930000	 ldr         r0, [r3]
  014dc	eb000000	 bl          NAND_Seek

; 1276 : 
; 1277 :             // send data to flash
; 1278 :             NAND_Write(s_hNand, pBuffer, sectorSize, sa.ecc);

  014e0	e28d3012	 add         r3, sp, #0x12
  014e4	e59d2008	 ldr         r2, [sp, #8]
  014e8	e59d108c	 ldr         r1, [sp, #0x8C]
  014ec	e59f02bc	 ldr         r0, [pc, #0x2BC]
  014f0	e5900000	 ldr         r0, [r0]
  014f4	eb000000	 bl          NAND_Write

; 1279 : 
; 1280 :             }
; 1281 :         else

  014f8	ea000028	 b           |$LN6@FMD_WriteS|
  014fc		 |$LN7@FMD_WriteS|

; 1282 :             {
; 1283 :             // Send the command
; 1284 :             NAND_SendCommand(s_hNand, NAND_CMD_READ1);

  014fc	e3a01000	 mov         r1, #0
  01500	e59f32a8	 ldr         r3, [pc, #0x2A8]
  01504	e5930000	 ldr         r0, [r3]
  01508	eb000000	 bl          NAND_SendCommand

; 1285 : 
; 1286 :             // Send the address
; 1287 :             NAND_Seek(s_hNand, sector, NAND_GetGeometry(s_hNand)->sectorSize);

  0150c	e59f329c	 ldr         r3, [pc, #0x29C]
  01510	e5930000	 ldr         r0, [r3]
  01514	eb000000	 bl          NAND_GetGeometry
  01518	e58d006c	 str         r0, [sp, #0x6C]
  0151c	e59d306c	 ldr         r3, [sp, #0x6C]
  01520	e283300c	 add         r3, r3, #0xC
  01524	e5932000	 ldr         r2, [r3]
  01528	e59d1088	 ldr         r1, [sp, #0x88]
  0152c	e59f327c	 ldr         r3, [pc, #0x27C]
  01530	e5930000	 ldr         r0, [r3]
  01534	eb000000	 bl          NAND_Seek

; 1288 : 
; 1289 :             // Send the command
; 1290 :             NAND_SendCommand(s_hNand, NAND_CMD_READ2);

  01538	e3a01030	 mov         r1, #0x30
  0153c	e59f326c	 ldr         r3, [pc, #0x26C]
  01540	e5930000	 ldr         r0, [r3]
  01544	eb000000	 bl          NAND_SendCommand

; 1291 : 
; 1292 :             // Wait for the action to finish
; 1293 :             WaitForReadyStatus(s_hNand);

  01548	e59f3260	 ldr         r3, [pc, #0x260]
  0154c	e5930000	 ldr         r0, [r3]
  01550	eb000000	 bl          WaitForReadyStatus

; 1294 : 
; 1295 :             //Force a read here, else we will read the status again
; 1296 :             NAND_SendCommand (s_hNand, NAND_CMD_READ1);

  01554	e3a01000	 mov         r1, #0
  01558	e59f3250	 ldr         r3, [pc, #0x250]
  0155c	e5930000	 ldr         r0, [r3]
  01560	eb000000	 bl          NAND_SendCommand

; 1297 : 
; 1298 :             // read spare area
; 1299 :             NAND_Read(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  01564	e3a03000	 mov         r3, #0
  01568	e3a02040	 mov         r2, #0x40
  0156c	e28d1010	 add         r1, sp, #0x10
  01570	e59f0238	 ldr         r0, [pc, #0x238]
  01574	e5900000	 ldr         r0, [r0]
  01578	eb000000	 bl          NAND_Read

; 1300 : 
; 1301 : 
; 1302 :             // send the write command
; 1303 :             NAND_SendCommand(s_hNand, NAND_CMD_WRITE1);

  0157c	e3a01080	 mov         r1, #0x80
  01580	e59f3228	 ldr         r3, [pc, #0x228]
  01584	e5930000	 ldr         r0, [r3]
  01588	eb000000	 bl          NAND_SendCommand

; 1304 : 
; 1305 :             // send the address to write to
; 1306 :             NAND_Seek(s_hNand, sector, sectorSize);

  0158c	e59d2008	 ldr         r2, [sp, #8]
  01590	e59d1088	 ldr         r1, [sp, #0x88]
  01594	e59f3214	 ldr         r3, [pc, #0x214]
  01598	e5930000	 ldr         r0, [r3]
  0159c	eb000000	 bl          NAND_Seek
  015a0		 |$LN6@FMD_WriteS|

; 1307 : 			
; 1308 :             }
; 1309 : 		
; 1310 :         /* used for test purpose */ 
; 1311 :         if((pSectorInfo != NULL) && (pSectorInfo->bOEMReserved == SKIP_ECC_WRITE_MAGIC_NUMBER) )

  015a0	e59d3090	 ldr         r3, [sp, #0x90]
  015a4	e3530000	 cmp         r3, #0
  015a8	0a000009	 beq         |$LN5@FMD_WriteS|
  015ac	e59d3090	 ldr         r3, [sp, #0x90]
  015b0	e2833004	 add         r3, r3, #4
  015b4	e5d33000	 ldrb        r3, [r3]
  015b8	e353000f	 cmp         r3, #0xF
  015bc	1a000004	 bne         |$LN5@FMD_WriteS|

; 1312 :         {
; 1313 :             /* skip updating ECC */
; 1314 :             ECC_Reset(pDevice->pGpmcRegs);			

  015c0	e59d3000	 ldr         r3, [sp]
  015c4	e283302c	 add         r3, r3, #0x2C
  015c8	e5930000	 ldr         r0, [r3]
  015cc	eb000000	 bl          ECC_Reset

; 1315 : 	     goto  skip_ecc; 	

  015d0	ea000019	 b           |$skip_ecc$46415|
  015d4		 |$LN5@FMD_WriteS|

; 1316 :         }
; 1317 : 
; 1318 :         if (pSectorInfo != NULL)

  015d4	e59d3090	 ldr         r3, [sp, #0x90]
  015d8	e3530000	 cmp         r3, #0
  015dc	0a000010	 beq         |$LN4@FMD_WriteS|

; 1319 :             {
; 1320 :             // Fill in rest of spare area info (we already have ECC from above)
; 1321 :             sa.swBadBlock     = pSectorInfo->bBadBlock;

  015e0	e59d3090	 ldr         r3, [sp, #0x90]
  015e4	e2833005	 add         r3, r3, #5
  015e8	e5d33000	 ldrb        r3, [r3]
  015ec	e5cd304c	 strb        r3, [sp, #0x4C]

; 1322 :             sa.oemReserved  = pSectorInfo->bOEMReserved;

  015f0	e59d3090	 ldr         r3, [sp, #0x90]
  015f4	e2833004	 add         r3, r3, #4
  015f8	e5d33000	 ldrb        r3, [r3]
  015fc	e5cd304d	 strb        r3, [sp, #0x4D]

; 1323 :             memcpy(sa.reserved1, &pSectorInfo->dwReserved1, sizeof(sa.reserved1));

  01600	e3a02004	 mov         r2, #4
  01604	e59d1090	 ldr         r1, [sp, #0x90]
  01608	e28d0046	 add         r0, sp, #0x46
  0160c	eb000000	 bl          memcpy

; 1324 :             memcpy(sa.reserved2, &pSectorInfo->wReserved2, sizeof(sa.reserved2));

  01610	e3a02002	 mov         r2, #2
  01614	e59d3090	 ldr         r3, [sp, #0x90]
  01618	e2831006	 add         r1, r3, #6
  0161c	e28d004a	 add         r0, sp, #0x4A
  01620	eb000000	 bl          memcpy
  01624		 |$LN4@FMD_WriteS|

; 1325 :             }
; 1326 : 
; 1327 :         // write new spare info
; 1328 :         NAND_Write(s_hNand, (BYTE*)&sa, sizeof(sa), NULL);

  01624	e3a03000	 mov         r3, #0
  01628	e3a02040	 mov         r2, #0x40
  0162c	e28d1010	 add         r1, sp, #0x10
  01630	e59f0178	 ldr         r0, [pc, #0x178]
  01634	e5900000	 ldr         r0, [r0]
  01638	eb000000	 bl          NAND_Write
  0163c		 |$skip_ecc$46415|

; 1329 : 
; 1330 : skip_ecc:
; 1331 :         // initiate the data programming process :
; 1332 :         NAND_SendCommand(s_hNand, NAND_CMD_WRITE2);

  0163c	e3a01010	 mov         r1, #0x10
  01640	e59f3168	 ldr         r3, [pc, #0x168]
  01644	e5930000	 ldr         r0, [r3]
  01648	eb000000	 bl          NAND_SendCommand

; 1333 : 
; 1334 :         // wait until completion of the operation :
; 1335 :         WaitForReadyStatus(s_hNand);

  0164c	e59f315c	 ldr         r3, [pc, #0x15C]
  01650	e5930000	 ldr         r0, [r3]
  01654	eb000000	 bl          WaitForReadyStatus

; 1336 : 
; 1337 :         if ((NAND_GetStatus(s_hNand) & NAND_STATUS_ERROR) != 0)

  01658	e59f3150	 ldr         r3, [pc, #0x150]
  0165c	e5930000	 ldr         r0, [r3]
  01660	eb000000	 bl          NAND_GetStatus
  01664	e1cd07b0	 strh        r0, [sp, #0x70]
  01668	e1dd37b0	 ldrh        r3, [sp, #0x70]
  0166c	e3130001	 tst         r3, #1
  01670	0a000000	 beq         |$LN3@FMD_WriteS|

; 1338 :             {
; 1339 :             break;

  01674	ea000010	 b           |$LN8@FMD_WriteS|
  01678		 |$LN3@FMD_WriteS|

; 1340 :             }
; 1341 :         // Move to next sector
; 1342 :         sector++;

  01678	e59d3088	 ldr         r3, [sp, #0x88]
  0167c	e2833001	 add         r3, r3, #1
  01680	e58d3088	 str         r3, [sp, #0x88]

; 1343 :         if (pBuffer != NULL) pBuffer += sectorSize;

  01684	e59d308c	 ldr         r3, [sp, #0x8C]
  01688	e3530000	 cmp         r3, #0
  0168c	0a000003	 beq         |$LN2@FMD_WriteS|
  01690	e59d208c	 ldr         r2, [sp, #0x8C]
  01694	e59d3008	 ldr         r3, [sp, #8]
  01698	e0823003	 add         r3, r2, r3
  0169c	e58d308c	 str         r3, [sp, #0x8C]
  016a0		 |$LN2@FMD_WriteS|

; 1344 :         pSectorInfo++;

  016a0	e59d3090	 ldr         r3, [sp, #0x90]
  016a4	e2833008	 add         r3, r3, #8
  016a8	e58d3090	 str         r3, [sp, #0x90]

; 1345 :         sectors--;

  016ac	e59d3094	 ldr         r3, [sp, #0x94]
  016b0	e2433001	 sub         r3, r3, #1
  016b4	e58d3094	 str         r3, [sp, #0x94]

; 1346 :         }

  016b8	eaffff71	 b           |$LN9@FMD_WriteS|
  016bc		 |$LN8@FMD_WriteS|

; 1347 : 
; 1348 :     //  Only enable during NAND read/write/erase operations    
; 1349 :     NAND_LockBlocks(s_hNand, startSector, endSector, TRUE);

  016bc	e3a03001	 mov         r3, #1
  016c0	e59d2050	 ldr         r2, [sp, #0x50]
  016c4	e59d1004	 ldr         r1, [sp, #4]
  016c8	e59f00e0	 ldr         r0, [pc, #0xE0]
  016cc	e5900000	 ldr         r0, [r0]
  016d0	eb000000	 bl          NAND_LockBlocks

; 1350 :     NAND_Enable(s_hNand, FALSE);

  016d4	e3a01000	 mov         r1, #0
  016d8	e59f30d0	 ldr         r3, [pc, #0xD0]
  016dc	e5930000	 ldr         r0, [r3]
  016e0	eb000000	 bl          NAND_Enable

; 1351 : 
; 1352 :     //  Change idle mode back
; 1353 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  016e4	e59f30c4	 ldr         r3, [pc, #0xC4]
  016e8	e5930000	 ldr         r0, [r3]
  016ec	eb000000	 bl          NAND_GetGpmcRegs
  016f0	e58d0074	 str         r0, [sp, #0x74]
  016f4	e59d3074	 ldr         r3, [sp, #0x74]
  016f8	e2832010	 add         r2, r3, #0x10
  016fc	e59d3054	 ldr         r3, [sp, #0x54]
  01700	e5823000	 str         r3, [r2]

; 1354 : 
; 1355 :     // All is ok, when we read all sectors
; 1356 :     rc = (sectors == 0);

  01704	e59d3094	 ldr         r3, [sp, #0x94]
  01708	e3530000	 cmp         r3, #0
  0170c	1a000002	 bne         |$LN13@FMD_WriteS|
  01710	e3a03001	 mov         r3, #1
  01714	e58d3078	 str         r3, [sp, #0x78]
  01718	ea000001	 b           |$LN14@FMD_WriteS|
  0171c		 |$LN13@FMD_WriteS|
  0171c	e3a03000	 mov         r3, #0
  01720	e58d3078	 str         r3, [sp, #0x78]
  01724		 |$LN14@FMD_WriteS|
  01724	e59d3078	 ldr         r3, [sp, #0x78]
  01728	e58d300c	 str         r3, [sp, #0xC]
  0172c		 |$cleanUp$46400|

; 1357 : 
; 1358 : cleanUp:
; 1359 :     // Release hardware lock
; 1360 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  0172c	e59f307c	 ldr         r3, [pc, #0x7C]
  01730	e5933000	 ldr         r3, [r3]
  01734	e3530000	 cmp         r3, #0
  01738	0a000002	 beq         |$LN1@FMD_WriteS|
  0173c	e59f306c	 ldr         r3, [pc, #0x6C]
  01740	e5930000	 ldr         r0, [r3]
  01744	eb000000	 bl          NAND_MutexExit
  01748		 |$LN1@FMD_WriteS|

; 1361 :     
; 1362 :     ASSERT(rc);

  01748	e59d300c	 ldr         r3, [sp, #0xC]
  0174c	e3530000	 cmp         r3, #0
  01750	0a000002	 beq         |$LN15@FMD_WriteS|
  01754	e3a03001	 mov         r3, #1
  01758	e58d307c	 str         r3, [sp, #0x7C]
  0175c	ea000008	 b           |$LN16@FMD_WriteS|
  01760		 |$LN15@FMD_WriteS|
  01760	e3a03c05	 mov         r3, #5, 24
  01764	e3833052	 orr         r3, r3, #0x52
  01768	e59f203c	 ldr         r2, [pc, #0x3C]
  0176c	e59f1034	 ldr         r1, [pc, #0x34]
  01770	e59f002c	 ldr         r0, [pc, #0x2C]
  01774	eb000000	 bl          NKDbgPrintfW
  01778	e6000010	 __debugbreak_ce
  0177c	e3a03000	 mov         r3, #0
  01780	e58d307c	 str         r3, [sp, #0x7C]
  01784		 |$LN16@FMD_WriteS|

; 1363 :     return rc;

  01784	e59d0058	 ldr         r0, [sp, #0x58]
  01788	eb000000	 bl          __security_check_cookie
  0178c	e59d300c	 ldr         r3, [sp, #0xC]
  01790	e58d305c	 str         r3, [sp, #0x5C]

; 1364 : }

  01794	e59d005c	 ldr         r0, [sp, #0x5C]
  01798	e28dd080	 add         sp, sp, #0x80
  0179c	e89d6000	 ldmia       sp, {sp, lr}
  017a0	e12fff1e	 bx          lr
  017a4		 |$LN20@FMD_WriteS|
  017a4		 |$LN21@FMD_WriteS|
  017a4	00000000	 DCD         |??_C@_1FK@FNONLNGN@?$AA?$CF?$AAs?$AA?3?$AA?5?$AAD?$AAE?$AAB?$AAU?$AAG?$AAC?$AAH?$AAK?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAi?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAa@|
  017a8		 |$LN22@FMD_WriteS|
  017a8	00000000	 DCD         |??_C@_1BA@LEPJIIOK@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@|
  017ac		 |$LN23@FMD_WriteS|
  017ac	00000000	 DCD         |??_C@_1KI@MDFCMHMG@?$AAC?$AA?3?$AA?2?$AAW?$AAI?$AAN?$AAC?$AAE?$AA6?$AA0?$AA0?$AA?2?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA?2?$AAC?$AAO?$AAM?$AAM?$AAO?$AAN?$AA?2?$AAS?$AAR?$AAC?$AA?2@|
  017b0		 |$LN24@FMD_WriteS|
  017b0	00000000	 DCD         |s_hNand|
  017b4		 |$LN25@FMD_WriteS|
  017b4	00000000	 DCD         |__security_cookie|
  017b8		 |$M46718|

			 ENDP  ; |FMD_WriteSector|


  00090			 AREA	 |.pdata|, PDATA
|$T46732| DCD	|$LN8@NAND_LockB|
	DCD	0x40002f04
; Function compile flags: /Odtp

  017b8			 AREA	 |.text|, CODE, ARM

  017b8		 |NAND_LockBlocks| PROC

; 336  : {

  017b8		 |$LN8@NAND_LockB|
  017b8	e1a0c00d	 mov         r12, sp
  017bc	e92d000f	 stmdb       sp!, {r0 - r3}
  017c0	e92d5000	 stmdb       sp!, {r12, lr}
  017c4	e24dd00c	 sub         sp, sp, #0xC
  017c8		 |$M46729|

; 337  :     BOOL rc = FALSE; 

  017c8	e3a03000	 mov         r3, #0
  017cc	e58d3004	 str         r3, [sp, #4]

; 338  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  017d0	e59d3014	 ldr         r3, [sp, #0x14]
  017d4	e58d3000	 str         r3, [sp]

; 339  : 
; 340  :     UNREFERENCED_PARAMETER(blockEnd);
; 341  :     UNREFERENCED_PARAMETER(blockStart);
; 342  : 
; 343  :     if (pDevice == NULL) goto cleanUp;

  017d8	e59d3000	 ldr         r3, [sp]
  017dc	e3530000	 cmp         r3, #0
  017e0	1a000000	 bne         |$LN3@NAND_LockB|
  017e4	ea00001c	 b           |$cleanUp$46010|
  017e8		 |$LN3@NAND_LockB|

; 344  : 
; 345  :     if (bLock)

  017e8	e59d3020	 ldr         r3, [sp, #0x20]
  017ec	e3530000	 cmp         r3, #0
  017f0	0a00000c	 beq         |$LN2@NAND_LockB|

; 346  :         {
; 347  :         CLRREG32(&pDevice->pGpmcRegs->GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT);        

  017f4	e59d3000	 ldr         r3, [sp]
  017f8	e283302c	 add         r3, r3, #0x2C
  017fc	e5933000	 ldr         r3, [r3]
  01800	e2833050	 add         r3, r3, #0x50
  01804	e5932000	 ldr         r2, [r3]
  01808	e3e03010	 mvn         r3, #0x10
  0180c	e0022003	 and         r2, r2, r3
  01810	e59d3000	 ldr         r3, [sp]
  01814	e283302c	 add         r3, r3, #0x2C
  01818	e5933000	 ldr         r3, [r3]
  0181c	e2833050	 add         r3, r3, #0x50
  01820	e5832000	 str         r2, [r3]

; 348  :         }
; 349  :     else

  01824	ea00000a	 b           |$LN1@NAND_LockB|
  01828		 |$LN2@NAND_LockB|

; 350  :         {
; 351  :         SETREG32(&pDevice->pGpmcRegs->GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT);

  01828	e59d3000	 ldr         r3, [sp]
  0182c	e283302c	 add         r3, r3, #0x2C
  01830	e5933000	 ldr         r3, [r3]
  01834	e2833050	 add         r3, r3, #0x50
  01838	e5933000	 ldr         r3, [r3]
  0183c	e3832010	 orr         r2, r3, #0x10
  01840	e59d3000	 ldr         r3, [sp]
  01844	e283302c	 add         r3, r3, #0x2C
  01848	e5933000	 ldr         r3, [r3]
  0184c	e2833050	 add         r3, r3, #0x50
  01850	e5832000	 str         r2, [r3]
  01854		 |$LN1@NAND_LockB|

; 352  :         }
; 353  :     rc = TRUE;

  01854	e3a03001	 mov         r3, #1
  01858	e58d3004	 str         r3, [sp, #4]
  0185c		 |$cleanUp$46010|

; 354  : 
; 355  : cleanUp:
; 356  :     return rc;

  0185c	e59d3004	 ldr         r3, [sp, #4]
  01860	e58d3008	 str         r3, [sp, #8]

; 357  : }

  01864	e59d0008	 ldr         r0, [sp, #8]
  01868	e28dd00c	 add         sp, sp, #0xC
  0186c	e89d6000	 ldmia       sp, {sp, lr}
  01870	e12fff1e	 bx          lr
  01874		 |$M46730|

			 ENDP  ; |NAND_LockBlocks|

	EXPORT	|WaitOnEmptyWriteBufferStatus|

  00098			 AREA	 |.pdata|, PDATA
|$T46738| DCD	|$LN17@NAND_Write|
	DCD	0x40007d04
; Function compile flags: /Odtp

  01874			 AREA	 |.text|, CODE, ARM

  01874		 |NAND_Write| PROC

; 635  : {

  01874		 |$LN17@NAND_Write|
  01874	e1a0c00d	 mov         r12, sp
  01878	e92d000f	 stmdb       sp!, {r0 - r3}
  0187c	e92d5000	 stmdb       sp!, {r12, lr}
  01880	e24dd010	 sub         sp, sp, #0x10
  01884		 |$M46735|

; 636  :     UINT32 fifoLevel;
; 637  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  01884	e59d3018	 ldr         r3, [sp, #0x18]
  01888	e58d3000	 str         r3, [sp]

; 638  : 
; 639  :     // Start ECC if a valid ECC buffer is passed in
; 640  :     if (pEcc != NULL)

  0188c	e59d3024	 ldr         r3, [sp, #0x24]
  01890	e3530000	 cmp         r3, #0
  01894	0a00000a	 beq         |$LN12@NAND_Write|

; 641  :         {
; 642  :         ECC_Init(pDevice->pGpmcRegs, pDevice->ECCCfg, pDevice->ECCtype, NAND_ECC_WRITE);

  01898	e3a03001	 mov         r3, #1
  0189c	e59d2000	 ldr         r2, [sp]
  018a0	e2822060	 add         r2, r2, #0x60
  018a4	e5922000	 ldr         r2, [r2]
  018a8	e59d1000	 ldr         r1, [sp]
  018ac	e2811058	 add         r1, r1, #0x58
  018b0	e5911000	 ldr         r1, [r1]
  018b4	e59d0000	 ldr         r0, [sp]
  018b8	e280002c	 add         r0, r0, #0x2C
  018bc	e5900000	 ldr         r0, [r0]
  018c0	eb000000	 bl          ECC_Init
  018c4		 |$LN12@NAND_Write|

; 643  :         }
; 644  : 
; 645  :     // enable prefetch if it's been properly configured
; 646  :     if (pDevice->prefetchMode == kPrefetchWrite )

  018c4	e59d3000	 ldr         r3, [sp]
  018c8	e2833018	 add         r3, r3, #0x18
  018cc	e5933000	 ldr         r3, [r3]
  018d0	e3530002	 cmp         r3, #2
  018d4	1a000031	 bne         |$LN11@NAND_Write|

; 647  :         {
; 648  :         SETREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_CONTROL, 
; 649  :             GPMC_PREFETCH_CONTROL_STARTENGINE
; 650  :             );

  018d8	e59d3000	 ldr         r3, [sp]
  018dc	e283302c	 add         r3, r3, #0x2C
  018e0	e5933000	 ldr         r3, [r3]
  018e4	e2833f7b	 add         r3, r3, #0x7B, 30
  018e8	e5933000	 ldr         r3, [r3]
  018ec	e3832001	 orr         r2, r3, #1
  018f0	e59d3000	 ldr         r3, [sp]
  018f4	e283302c	 add         r3, r3, #0x2C
  018f8	e5933000	 ldr         r3, [r3]
  018fc	e2833f7b	 add         r3, r3, #0x7B, 30
  01900	e5832000	 str         r2, [r3]
  01904		 |$LN10@NAND_Write|

; 651  :         // start copying data into passed in buffer
; 652  :         while (size > 0)

  01904	e59d3020	 ldr         r3, [sp, #0x20]
  01908	e3530000	 cmp         r3, #0
  0190c	da00001e	 ble         |$LN9@NAND_Write|

; 653  :             {
; 654  :             // copy data to buffer
; 655  :             memcpy((BYTE*)pDevice->pFifo, pData, FIFO_THRESHOLD);

  01910	e3a02040	 mov         r2, #0x40
  01914	e59d101c	 ldr         r1, [sp, #0x1C]
  01918	e59d3000	 ldr         r3, [sp]
  0191c	e2833028	 add         r3, r3, #0x28
  01920	e5930000	 ldr         r0, [r3]
  01924	eb000000	 bl          memcpy

; 656  :             pData += FIFO_THRESHOLD;

  01928	e59d301c	 ldr         r3, [sp, #0x1C]
  0192c	e2833040	 add         r3, r3, #0x40
  01930	e58d301c	 str         r3, [sp, #0x1C]

; 657  :             size -= FIFO_THRESHOLD;  

  01934	e59d3020	 ldr         r3, [sp, #0x20]
  01938	e2433040	 sub         r3, r3, #0x40
  0193c	e58d3020	 str         r3, [sp, #0x20]

; 658  :             
; 659  :             // wait for fifo threshold to be reached
; 660  :             fifoLevel = 0;

  01940	e3a03000	 mov         r3, #0
  01944	e58d3004	 str         r3, [sp, #4]
  01948		 |$LN8@NAND_Write|

; 661  :             while (fifoLevel < FIFO_THRESHOLD)

  01948	e59d3004	 ldr         r3, [sp, #4]
  0194c	e3530040	 cmp         r3, #0x40
  01950	2a00000c	 bcs         |$LN7@NAND_Write|

; 662  :                 {
; 663  :                 fifoLevel = INREG32(&pDevice->pGpmcRegs->GPMC_PREFETCH_STATUS);

  01954	e59d3000	 ldr         r3, [sp]
  01958	e283302c	 add         r3, r3, #0x2C
  0195c	e5933000	 ldr         r3, [r3]
  01960	e2833e1f	 add         r3, r3, #0x1F, 28
  01964	e5933000	 ldr         r3, [r3]
  01968	e58d3004	 str         r3, [sp, #4]

; 664  :                 fifoLevel &= GPMC_PREFETCH_STATUS_FIFOMASK;

  0196c	e59d3004	 ldr         r3, [sp, #4]
  01970	e203347f	 and         r3, r3, #0x7F, 8
  01974	e58d3004	 str         r3, [sp, #4]

; 665  :                 fifoLevel >>= GPMC_PREFETCH_STATUS_FIFOSHIFT;

  01978	e59d3004	 ldr         r3, [sp, #4]
  0197c	e1a03c23	 mov         r3, r3, lsr #24
  01980	e58d3004	 str         r3, [sp, #4]

; 666  :                 }

  01984	eaffffef	 b           |$LN8@NAND_Write|
  01988		 |$LN7@NAND_Write|

; 667  :             }

  01988	eaffffdd	 b           |$LN10@NAND_Write|
  0198c		 |$LN9@NAND_Write|

; 668  : 
; 669  :         // NOTE:
; 670  :         //  Prefetch engine will automatically stop on the completion
; 671  :         // of data transfer
; 672  :         pDevice->prefetchMode = kPrefetchOff;

  0198c	e59d3000	 ldr         r3, [sp]
  01990	e2832018	 add         r2, r3, #0x18
  01994	e3a03000	 mov         r3, #0
  01998	e5823000	 str         r3, [r2]

; 673  :         }
; 674  :     else

  0199c	ea00001b	 b           |$LN6@NAND_Write|
  019a0		 |$LN11@NAND_Write|

; 675  :         {
; 676  :         int writeCount = 0;

  019a0	e3a03000	 mov         r3, #0
  019a4	e58d3008	 str         r3, [sp, #8]
  019a8		 |$LN5@NAND_Write|

; 677  : 		
; 678  :         while (size >= sizeof(NANDREG))

  019a8	e59d3020	 ldr         r3, [sp, #0x20]
  019ac	e3530002	 cmp         r3, #2
  019b0	3a000016	 bcc         |$LN4@NAND_Write|

; 679  :             {
; 680  :             WRITE_NAND(pDevice->pNandData, *(NANDREG*)pData);

  019b4	e59d301c	 ldr         r3, [sp, #0x1C]
  019b8	e1d320b0	 ldrh        r2, [r3]
  019bc	e59d3000	 ldr         r3, [sp]
  019c0	e2833024	 add         r3, r3, #0x24
  019c4	e5933000	 ldr         r3, [r3]
  019c8	e1c320b0	 strh        r2, [r3]

; 681  : 
; 682  :             // Workaround Errata 1.53
; 683  :             // need to check on EMPTYWRITEBUFFERSTATUS on every
; 684  :             // 255 bytes
; 685  :             if (++writeCount >= 255)

  019cc	e59d3008	 ldr         r3, [sp, #8]
  019d0	e2833001	 add         r3, r3, #1
  019d4	e58d3008	 str         r3, [sp, #8]
  019d8	e59d3008	 ldr         r3, [sp, #8]
  019dc	e35300ff	 cmp         r3, #0xFF
  019e0	ba000003	 blt         |$LN3@NAND_Write|

; 686  :                 {
; 687  :                 WaitOnEmptyWriteBufferStatus(pDevice);

  019e4	e59d0000	 ldr         r0, [sp]
  019e8	eb000000	 bl          WaitOnEmptyWriteBufferStatus

; 688  :                 writeCount = 0;

  019ec	e3a03000	 mov         r3, #0
  019f0	e58d3008	 str         r3, [sp, #8]
  019f4		 |$LN3@NAND_Write|

; 689  :                 }
; 690  :             
; 691  :             pData += sizeof(NANDREG);

  019f4	e59d301c	 ldr         r3, [sp, #0x1C]
  019f8	e2833002	 add         r3, r3, #2
  019fc	e58d301c	 str         r3, [sp, #0x1C]

; 692  :             size -= sizeof(NANDREG);

  01a00	e59d3020	 ldr         r3, [sp, #0x20]
  01a04	e2433002	 sub         r3, r3, #2
  01a08	e58d3020	 str         r3, [sp, #0x20]

; 693  :             }

  01a0c	eaffffe5	 b           |$LN5@NAND_Write|
  01a10		 |$LN4@NAND_Write|
  01a10		 |$LN6@NAND_Write|

; 694  : 		
; 695  :         }
; 696  : 
; 697  :     // get ECC result
; 698  :     if (pEcc != NULL)

  01a10	e59d3024	 ldr         r3, [sp, #0x24]
  01a14	e3530000	 cmp         r3, #0
  01a18	0a000008	 beq         |$LN2@NAND_Write|

; 699  :         {
; 700  :         ECC_Result(pDevice->pGpmcRegs, pEcc, pDevice->ECCsize);

  01a1c	e59d3000	 ldr         r3, [sp]
  01a20	e2833064	 add         r3, r3, #0x64
  01a24	e5932000	 ldr         r2, [r3]
  01a28	e59d1024	 ldr         r1, [sp, #0x24]
  01a2c	e59d3000	 ldr         r3, [sp]
  01a30	e283302c	 add         r3, r3, #0x2C
  01a34	e5930000	 ldr         r0, [r3]
  01a38	eb000000	 bl          ECC_Result

; 701  :         }
; 702  :     else

  01a3c	ea000003	 b           |$LN1@NAND_Write|
  01a40		 |$LN2@NAND_Write|

; 703  :     	{
; 704  : 	 ECC_Reset(pDevice->pGpmcRegs);

  01a40	e59d3000	 ldr         r3, [sp]
  01a44	e283302c	 add         r3, r3, #0x2C
  01a48	e5930000	 ldr         r0, [r3]
  01a4c	eb000000	 bl          ECC_Reset
  01a50		 |$LN1@NAND_Write|

; 705  :     	}
; 706  :     return TRUE;

  01a50	e3a03001	 mov         r3, #1
  01a54	e58d300c	 str         r3, [sp, #0xC]

; 707  : }

  01a58	e59d000c	 ldr         r0, [sp, #0xC]
  01a5c	e28dd010	 add         sp, sp, #0x10
  01a60	e89d6000	 ldmia       sp, {sp, lr}
  01a64	e12fff1e	 bx          lr
  01a68		 |$M46736|

			 ENDP  ; |NAND_Write|


  00000			 AREA	 |.pdata|, PDATA
|$T46743| DCD	|$LN8@WaitOnEmpt|
	DCD	0x40001004
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |WaitOnEmptyWriteBufferStatus| PROC

; 249  : {

  00000		 |$LN8@WaitOnEmpt|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46740|
  00010		 |$LN3@WaitOnEmpt|

; 250  :     UINT status;
; 251  :     do
; 252  :     {
; 253  :         status = INREG32(&pDevice->pGpmcRegs->GPMC_STATUS);

  00010	e59d300c	 ldr         r3, [sp, #0xC]
  00014	e283302c	 add         r3, r3, #0x2C
  00018	e5933000	 ldr         r3, [r3]
  0001c	e2833054	 add         r3, r3, #0x54
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3000	 str         r3, [sp]

; 254  :     } while ((status & GPMC_STATUS_EMPTYWRITEBUFFER) == 0);

  00028	e59d3000	 ldr         r3, [sp]
  0002c	e3130001	 tst         r3, #1
  00030	0afffff6	 beq         |$LN3@WaitOnEmpt|

; 255  : }

  00034	e28dd004	 add         sp, sp, #4
  00038	e89d6000	 ldmia       sp, {sp, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$M46741|

			 ENDP  ; |WaitOnEmptyWriteBufferStatus|

	EXPORT	|FMD_EraseBlock|

  000a0			 AREA	 |.pdata|, PDATA
|$T46751| DCD	|$LN8@FMD_EraseB|
	DCD	0x40005d04
; Function compile flags: /Odtp

  01a68			 AREA	 |.text|, CODE, ARM

  01a68		 |FMD_EraseBlock| PROC

; 1376 : {

  01a68		 |$LN8@FMD_EraseB|
  01a68	e1a0c00d	 mov         r12, sp
  01a6c	e92d0001	 stmdb       sp!, {r0}
  01a70	e92d5000	 stmdb       sp!, {r12, lr}
  01a74	e24dd01c	 sub         sp, sp, #0x1C
  01a78		 |$M46748|

; 1377 :     BOOL rc = FALSE;

  01a78	e3a03000	 mov         r3, #0
  01a7c	e58d3000	 str         r3, [sp]

; 1378 :     UINT32 oldIdleMode;
; 1379 : 
; 1380 :     // Check if we know flash geometry
; 1381 :     if (s_hNand == NULL) return rc;

  01a80	e59f3150	 ldr         r3, [pc, #0x150]
  01a84	e5933000	 ldr         r3, [r3]
  01a88	e3530000	 cmp         r3, #0
  01a8c	1a000002	 bne         |$LN3@FMD_EraseB|
  01a90	e59d3000	 ldr         r3, [sp]
  01a94	e58d3008	 str         r3, [sp, #8]
  01a98	ea00004a	 b           |$LN4@FMD_EraseB|
  01a9c		 |$LN3@FMD_EraseB|

; 1382 : 
; 1383 :     // Obtain hardware lock
; 1384 :     NAND_MutexEnter(s_hNand);

  01a9c	e59f3134	 ldr         r3, [pc, #0x134]
  01aa0	e5930000	 ldr         r0, [r3]
  01aa4	eb000000	 bl          NAND_MutexEnter

; 1385 : 
; 1386 :     //  Change idle mode to no-idle to ensure access to GPMC registers
; 1387 :     oldIdleMode = INREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG));

  01aa8	e59f3128	 ldr         r3, [pc, #0x128]
  01aac	e5930000	 ldr         r0, [r3]
  01ab0	eb000000	 bl          NAND_GetGpmcRegs
  01ab4	e58d000c	 str         r0, [sp, #0xC]
  01ab8	e59d300c	 ldr         r3, [sp, #0xC]
  01abc	e2833010	 add         r3, r3, #0x10
  01ac0	e5933000	 ldr         r3, [r3]
  01ac4	e58d3004	 str         r3, [sp, #4]

; 1388 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), SYSCONFIG_NOIDLE);

  01ac8	e59f3108	 ldr         r3, [pc, #0x108]
  01acc	e5930000	 ldr         r0, [r3]
  01ad0	eb000000	 bl          NAND_GetGpmcRegs
  01ad4	e58d0010	 str         r0, [sp, #0x10]
  01ad8	e59d3010	 ldr         r3, [sp, #0x10]
  01adc	e2832010	 add         r2, r3, #0x10
  01ae0	e3a03008	 mov         r3, #8
  01ae4	e5823000	 str         r3, [r2]

; 1389 : 
; 1390 :     //  Only enable during NAND read/write/erase operations    
; 1391 :     NAND_Enable(s_hNand, TRUE);

  01ae8	e3a01001	 mov         r1, #1
  01aec	e59f30e4	 ldr         r3, [pc, #0xE4]
  01af0	e5930000	 ldr         r0, [r3]
  01af4	eb000000	 bl          NAND_Enable

; 1392 :     NAND_LockBlocks(s_hNand, blockId, blockId, FALSE);

  01af8	e3a03000	 mov         r3, #0
  01afc	e59d2024	 ldr         r2, [sp, #0x24]
  01b00	e59d1024	 ldr         r1, [sp, #0x24]
  01b04	e59f00cc	 ldr         r0, [pc, #0xCC]
  01b08	e5900000	 ldr         r0, [r0]
  01b0c	eb000000	 bl          NAND_LockBlocks

; 1393 :     
; 1394 :     // send block id to erase
; 1395 :     NAND_EraseBlock(s_hNand, blockId);

  01b10	e59d1024	 ldr         r1, [sp, #0x24]
  01b14	e59f30bc	 ldr         r3, [pc, #0xBC]
  01b18	e5930000	 ldr         r0, [r3]
  01b1c	eb000000	 bl          NAND_EraseBlock

; 1396 : 
; 1397 :     // wait for completion    
; 1398 :     WaitForReadyStatus(s_hNand);

  01b20	e59f30b0	 ldr         r3, [pc, #0xB0]
  01b24	e5930000	 ldr         r0, [r3]
  01b28	eb000000	 bl          WaitForReadyStatus

; 1399 : 
; 1400 :     //Verify there wasn't any error by checking the NAND status register :
; 1401 :     if ((NAND_GetStatus(s_hNand) & NAND_STATUS_ERROR) != 0)

  01b2c	e59f30a4	 ldr         r3, [pc, #0xA4]
  01b30	e5930000	 ldr         r0, [r3]
  01b34	eb000000	 bl          NAND_GetStatus
  01b38	e1cd01b4	 strh        r0, [sp, #0x14]
  01b3c	e1dd31b4	 ldrh        r3, [sp, #0x14]
  01b40	e3130001	 tst         r3, #1
  01b44	0a000002	 beq         |$LN2@FMD_EraseB|

; 1402 :         {
; 1403 :         rc = FALSE;

  01b48	e3a03000	 mov         r3, #0
  01b4c	e58d3000	 str         r3, [sp]

; 1404 :         goto cleanUp;

  01b50	ea000001	 b           |$cleanUp$46440|
  01b54		 |$LN2@FMD_EraseB|

; 1405 :         }
; 1406 : 
; 1407 :     // Done
; 1408 :     rc = TRUE;

  01b54	e3a03001	 mov         r3, #1
  01b58	e58d3000	 str         r3, [sp]
  01b5c		 |$cleanUp$46440|

; 1409 : 
; 1410 : cleanUp:
; 1411 :     //  Only enable during NAND read/write/erase operations    
; 1412 :     NAND_LockBlocks(s_hNand, blockId, blockId, TRUE);

  01b5c	e3a03001	 mov         r3, #1
  01b60	e59d2024	 ldr         r2, [sp, #0x24]
  01b64	e59d1024	 ldr         r1, [sp, #0x24]
  01b68	e59f0068	 ldr         r0, [pc, #0x68]
  01b6c	e5900000	 ldr         r0, [r0]
  01b70	eb000000	 bl          NAND_LockBlocks

; 1413 :     NAND_Enable(s_hNand, FALSE);

  01b74	e3a01000	 mov         r1, #0
  01b78	e59f3058	 ldr         r3, [pc, #0x58]
  01b7c	e5930000	 ldr         r0, [r3]
  01b80	eb000000	 bl          NAND_Enable

; 1414 :    
; 1415 : 
; 1416 :     //  Change idle mode back
; 1417 :     OUTREG32(&(NAND_GetGpmcRegs(s_hNand)->GPMC_SYSCONFIG), oldIdleMode);

  01b84	e59f304c	 ldr         r3, [pc, #0x4C]
  01b88	e5930000	 ldr         r0, [r3]
  01b8c	eb000000	 bl          NAND_GetGpmcRegs
  01b90	e58d0018	 str         r0, [sp, #0x18]
  01b94	e59d3018	 ldr         r3, [sp, #0x18]
  01b98	e2832010	 add         r2, r3, #0x10
  01b9c	e59d3004	 ldr         r3, [sp, #4]
  01ba0	e5823000	 str         r3, [r2]

; 1418 : 
; 1419 :     // Release hardware lock
; 1420 :     if (s_hNand != NULL) NAND_MutexExit(s_hNand);

  01ba4	e59f302c	 ldr         r3, [pc, #0x2C]
  01ba8	e5933000	 ldr         r3, [r3]
  01bac	e3530000	 cmp         r3, #0
  01bb0	0a000002	 beq         |$LN1@FMD_EraseB|
  01bb4	e59f301c	 ldr         r3, [pc, #0x1C]
  01bb8	e5930000	 ldr         r0, [r3]
  01bbc	eb000000	 bl          NAND_MutexExit
  01bc0		 |$LN1@FMD_EraseB|

; 1421 : 
; 1422 :     return rc;

  01bc0	e59d3000	 ldr         r3, [sp]
  01bc4	e58d3008	 str         r3, [sp, #8]
  01bc8		 |$LN4@FMD_EraseB|

; 1423 : }

  01bc8	e59d0008	 ldr         r0, [sp, #8]
  01bcc	e28dd01c	 add         sp, sp, #0x1C
  01bd0	e89d6000	 ldmia       sp, {sp, lr}
  01bd4	e12fff1e	 bx          lr
  01bd8		 |$LN9@FMD_EraseB|
  01bd8		 |$LN10@FMD_EraseB|
  01bd8	00000000	 DCD         |s_hNand|
  01bdc		 |$M46749|

			 ENDP  ; |FMD_EraseBlock|

	EXPORT	|BlockAccess|

  000a8			 AREA	 |.pdata|, PDATA
|$T46759| DCD	|$LN5@NAND_Erase|
	DCD	0x40001504
; Function compile flags: /Odtp

  01bdc			 AREA	 |.text|, CODE, ARM

  01bdc		 |NAND_EraseBlock| PROC

; 728  : {    

  01bdc		 |$LN5@NAND_Erase|
  01bdc	e1a0c00d	 mov         r12, sp
  01be0	e92d0003	 stmdb       sp!, {r0, r1}
  01be4	e92d5000	 stmdb       sp!, {r12, lr}
  01be8	e24dd008	 sub         sp, sp, #8
  01bec		 |$M46756|

; 729  :     NandDevice_t *pDevice = (NandDevice_t*)hNand;

  01bec	e59d3010	 ldr         r3, [sp, #0x10]
  01bf0	e58d3000	 str         r3, [sp]

; 730  :     
; 731  :     // Calculate the sector number
; 732  :     NAND_SendCommand(hNand, NAND_CMD_ERASE_SETUP);    

  01bf4	e3a01060	 mov         r1, #0x60
  01bf8	e59d0010	 ldr         r0, [sp, #0x10]
  01bfc	eb000000	 bl          NAND_SendCommand

; 733  :     BlockAccess(pDevice, blockId);

  01c00	e59d1014	 ldr         r1, [sp, #0x14]
  01c04	e59d0000	 ldr         r0, [sp]
  01c08	eb000000	 bl          BlockAccess

; 734  :     NAND_SendCommand(hNand, NAND_CMD_ERASE_CONFIRM);

  01c0c	e3a010d0	 mov         r1, #0xD0
  01c10	e59d0010	 ldr         r0, [sp, #0x10]
  01c14	eb000000	 bl          NAND_SendCommand

; 735  :     
; 736  :     return TRUE;

  01c18	e3a03001	 mov         r3, #1
  01c1c	e58d3004	 str         r3, [sp, #4]

; 737  : }

  01c20	e59d0004	 ldr         r0, [sp, #4]
  01c24	e28dd008	 add         sp, sp, #8
  01c28	e89d6000	 ldmia       sp, {sp, lr}
  01c2c	e12fff1e	 bx          lr
  01c30		 |$M46757|

			 ENDP  ; |NAND_EraseBlock|


  00000			 AREA	 |.pdata|, PDATA
|$T46764| DCD	|$LN5@BlockAcces|
	DCD	0x40002503
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BlockAccess| PROC

; 235  : {

  00000		 |$LN5@BlockAcces|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M46761|

; 236  :     blockId *= pDevice->nandInfo.sectorsPerBlock;

  0000c	e59d3008	 ldr         r3, [sp, #8]
  00010	e283304c	 add         r3, r3, #0x4C
  00014	e59d200c	 ldr         r2, [sp, #0xC]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e0030392	 mul         r3, r2, r3
  00020	e58d300c	 str         r3, [sp, #0xC]

; 237  :     WRITE_NAND(pDevice->pNandAddress, (blockId & 0xFF));

  00024	e59d300c	 ldr         r3, [sp, #0xC]
  00028	e20330ff	 and         r3, r3, #0xFF
  0002c	e1a02803	 mov         r2, r3, lsl #16
  00030	e1a02822	 mov         r2, r2, lsr #16
  00034	e59d3008	 ldr         r3, [sp, #8]
  00038	e2833020	 add         r3, r3, #0x20
  0003c	e5933000	 ldr         r3, [r3]
  00040	e1c320b0	 strh        r2, [r3]

; 238  :     WRITE_NAND(pDevice->pNandAddress, ((blockId >> 8) & 0xFF));

  00044	e59d300c	 ldr         r3, [sp, #0xC]
  00048	e1a03803	 mov         r3, r3, lsl #16
  0004c	e1a03c23	 mov         r3, r3, lsr #24
  00050	e1a02803	 mov         r2, r3, lsl #16
  00054	e1a02822	 mov         r2, r2, lsr #16
  00058	e59d3008	 ldr         r3, [sp, #8]
  0005c	e2833020	 add         r3, r3, #0x20
  00060	e5933000	 ldr         r3, [r3]
  00064	e1c320b0	 strh        r2, [r3]

; 239  :     WRITE_NAND(pDevice->pNandAddress, ((blockId >> 16) & 0xFF));

  00068	e59d300c	 ldr         r3, [sp, #0xC]
  0006c	e1a03403	 mov         r3, r3, lsl #8
  00070	e1a03c23	 mov         r3, r3, lsr #24
  00074	e1a02803	 mov         r2, r3, lsl #16
  00078	e1a02822	 mov         r2, r2, lsr #16
  0007c	e59d3008	 ldr         r3, [sp, #8]
  00080	e2833020	 add         r3, r3, #0x20
  00084	e5933000	 ldr         r3, [r3]
  00088	e1c320b0	 strh        r2, [r3]

; 240  : }

  0008c	e89d6000	 ldmia       sp, {sp, lr}
  00090	e12fff1e	 bx          lr
  00094		 |$M46762|

			 ENDP  ; |BlockAccess|

	EXPORT	|FMD_GetBlockStatus|

  000b0			 AREA	 |.pdata|, PDATA
|$T46772| DCD	|$LN11@FMD_GetBlo|
	DCD	0x40003d04
; Function compile flags: /Odtp

  01c30			 AREA	 |.text|, CODE, ARM

  01c30		 |FMD_GetBlockStatus| PROC

; 1431 : {

  01c30		 |$LN11@FMD_GetBlo|
  01c30	e1a0c00d	 mov         r12, sp
  01c34	e92d0001	 stmdb       sp!, {r0}
  01c38	e92d5000	 stmdb       sp!, {r12, lr}
  01c3c	e24dd024	 sub         sp, sp, #0x24
  01c40		 |$M46769|

; 1432 :     DWORD rc = 0;

  01c40	e3a03000	 mov         r3, #0
  01c44	e58d3000	 str         r3, [sp]

; 1433 :     SECTOR_ADDR sector;
; 1434 :     SectorInfo sectorInfo[2];
; 1435 : 
; 1436 : 
; 1437 :     // Check if we know flash geometry
; 1438 :     if (s_hNand == NULL) goto cleanUp;

  01c48	e59f30d0	 ldr         r3, [pc, #0xD0]
  01c4c	e5933000	 ldr         r3, [r3]
  01c50	e3530000	 cmp         r3, #0
  01c54	1a000000	 bne         |$LN6@FMD_GetBlo|
  01c58	ea00002a	 b           |$cleanUp$46453|
  01c5c		 |$LN6@FMD_GetBlo|

; 1439 : 
; 1440 :     // Calculate sector
; 1441 :     sector = blockId * NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  01c5c	e59f30bc	 ldr         r3, [pc, #0xBC]
  01c60	e5930000	 ldr         r0, [r3]
  01c64	eb000000	 bl          NAND_GetGeometry
  01c68	e58d001c	 str         r0, [sp, #0x1C]
  01c6c	e59d301c	 ldr         r3, [sp, #0x1C]
  01c70	e2833008	 add         r3, r3, #8
  01c74	e59d202c	 ldr         r2, [sp, #0x2C]
  01c78	e5933000	 ldr         r3, [r3]
  01c7c	e0030392	 mul         r3, r2, r3
  01c80	e58d3004	 str         r3, [sp, #4]

; 1442 : 
; 1443 :     if (!FMD_ReadSector(sector, NULL, sectorInfo, 2))

  01c84	e3a03002	 mov         r3, #2
  01c88	e28d2008	 add         r2, sp, #8
  01c8c	e3a01000	 mov         r1, #0
  01c90	e59d0004	 ldr         r0, [sp, #4]
  01c94	eb000000	 bl          FMD_ReadSector
  01c98	e58d0020	 str         r0, [sp, #0x20]
  01c9c	e59d3020	 ldr         r3, [sp, #0x20]
  01ca0	e3530000	 cmp         r3, #0
  01ca4	1a000002	 bne         |$LN5@FMD_GetBlo|

; 1444 :         {
; 1445 :         rc = BLOCK_STATUS_UNKNOWN;

  01ca8	e3a03001	 mov         r3, #1
  01cac	e58d3000	 str         r3, [sp]

; 1446 :         goto cleanUp;

  01cb0	ea000014	 b           |$cleanUp$46453|
  01cb4		 |$LN5@FMD_GetBlo|

; 1447 :         }
; 1448 : 
; 1449 :     if ((sectorInfo[0].bBadBlock != 0xFF) || (sectorInfo[1].bBadBlock != 0xFF))

  01cb4	e5dd300d	 ldrb        r3, [sp, #0xD]
  01cb8	e35300ff	 cmp         r3, #0xFF
  01cbc	1a000002	 bne         |$LN3@FMD_GetBlo|
  01cc0	e5dd3015	 ldrb        r3, [sp, #0x15]
  01cc4	e35300ff	 cmp         r3, #0xFF
  01cc8	0a000002	 beq         |$LN4@FMD_GetBlo|
  01ccc		 |$LN3@FMD_GetBlo|

; 1450 :         {
; 1451 :         rc |= BLOCK_STATUS_BAD;

  01ccc	e59d3000	 ldr         r3, [sp]
  01cd0	e3833002	 orr         r3, r3, #2
  01cd4	e58d3000	 str         r3, [sp]
  01cd8		 |$LN4@FMD_GetBlo|

; 1452 :         }
; 1453 : 
; 1454 :     if ((sectorInfo[0].bOEMReserved & OEM_BLOCK_READONLY) == 0)

  01cd8	e5dd300c	 ldrb        r3, [sp, #0xC]
  01cdc	e3130002	 tst         r3, #2
  01ce0	1a000002	 bne         |$LN2@FMD_GetBlo|

; 1455 :         {
; 1456 :         rc |= BLOCK_STATUS_READONLY;

  01ce4	e59d3000	 ldr         r3, [sp]
  01ce8	e3833004	 orr         r3, r3, #4
  01cec	e58d3000	 str         r3, [sp]
  01cf0		 |$LN2@FMD_GetBlo|

; 1457 :         }
; 1458 : 
; 1459 :     if ((sectorInfo[0].bOEMReserved & OEM_BLOCK_RESERVED) == 0)

  01cf0	e5dd300c	 ldrb        r3, [sp, #0xC]
  01cf4	e3130001	 tst         r3, #1
  01cf8	1a000002	 bne         |$LN1@FMD_GetBlo|

; 1460 :         {
; 1461 :         rc |= BLOCK_STATUS_RESERVED;

  01cfc	e59d3000	 ldr         r3, [sp]
  01d00	e3833008	 orr         r3, r3, #8
  01d04	e58d3000	 str         r3, [sp]
  01d08		 |$LN1@FMD_GetBlo|
  01d08		 |$cleanUp$46453|

; 1462 :         }
; 1463 : 
; 1464 : cleanUp:
; 1465 :     return rc;

  01d08	e59d3000	 ldr         r3, [sp]
  01d0c	e58d3018	 str         r3, [sp, #0x18]

; 1466 : }

  01d10	e59d0018	 ldr         r0, [sp, #0x18]
  01d14	e28dd024	 add         sp, sp, #0x24
  01d18	e89d6000	 ldmia       sp, {sp, lr}
  01d1c	e12fff1e	 bx          lr
  01d20		 |$LN12@FMD_GetBlo|
  01d20		 |$LN13@FMD_GetBlo|
  01d20	00000000	 DCD         |s_hNand|
  01d24		 |$M46770|

			 ENDP  ; |FMD_GetBlockStatus|

	EXPORT	|FMD_SetBlockStatus|

  000b8			 AREA	 |.pdata|, PDATA
|$T46784| DCD	|$LN17@FMD_SetBlo|
	DCD	0x40006d04
; Function compile flags: /Odtp

  01d24			 AREA	 |.text|, CODE, ARM

  01d24		 |FMD_SetBlockStatus| PROC

; 1477 : {

  01d24		 |$LN17@FMD_SetBlo|
  01d24	e1a0c00d	 mov         r12, sp
  01d28	e92d0003	 stmdb       sp!, {r0, r1}
  01d2c	e92d5000	 stmdb       sp!, {r12, lr}
  01d30	e24dd030	 sub         sp, sp, #0x30
  01d34		 |$M46781|

; 1478 :     BOOL rc = FALSE;

  01d34	e3a03000	 mov         r3, #0
  01d38	e58d3000	 str         r3, [sp]

; 1479 :     SECTOR_ADDR sector;
; 1480 :     SectorInfo sectorInfo;
; 1481 : 
; 1482 :     // Check if we know flash geometry
; 1483 :     if (s_hNand == NULL) goto cleanUp;

  01d3c	e59f3190	 ldr         r3, [pc, #0x190]
  01d40	e5933000	 ldr         r3, [r3]
  01d44	e3530000	 cmp         r3, #0
  01d48	1a000000	 bne         |$LN8@FMD_SetBlo|
  01d4c	ea00005a	 b           |$cleanUp$46470|
  01d50		 |$LN8@FMD_SetBlo|

; 1484 : 
; 1485 :     // Calculate sector
; 1486 :     sector = blockId * NAND_GetGeometry(s_hNand)->sectorsPerBlock;

  01d50	e59f317c	 ldr         r3, [pc, #0x17C]
  01d54	e5930000	 ldr         r0, [r3]
  01d58	eb000000	 bl          NAND_GetGeometry
  01d5c	e58d0014	 str         r0, [sp, #0x14]
  01d60	e59d3014	 ldr         r3, [sp, #0x14]
  01d64	e2833008	 add         r3, r3, #8
  01d68	e59d2038	 ldr         r2, [sp, #0x38]
  01d6c	e5933000	 ldr         r3, [r3]
  01d70	e0030392	 mul         r3, r2, r3
  01d74	e58d3004	 str         r3, [sp, #4]

; 1487 : 
; 1488 :     if ((status & BLOCK_STATUS_BAD) != 0)

  01d78	e59d303c	 ldr         r3, [sp, #0x3C]
  01d7c	e3130002	 tst         r3, #2
  01d80	0a000015	 beq         |$LN7@FMD_SetBlo|

; 1489 :         {
; 1490 :         // Read the sector info
; 1491 :         if (!FMD_ReadSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  01d84	e3a03001	 mov         r3, #1
  01d88	e28d2008	 add         r2, sp, #8
  01d8c	e3a01000	 mov         r1, #0
  01d90	e59d0004	 ldr         r0, [sp, #4]
  01d94	eb000000	 bl          FMD_ReadSector
  01d98	e58d0018	 str         r0, [sp, #0x18]
  01d9c	e59d3018	 ldr         r3, [sp, #0x18]
  01da0	e3530000	 cmp         r3, #0
  01da4	1a000000	 bne         |$LN6@FMD_SetBlo|
  01da8	ea000043	 b           |$cleanUp$46470|
  01dac		 |$LN6@FMD_SetBlo|

; 1492 : 
; 1493 :         // Set the bad block marker
; 1494 :         sectorInfo.bBadBlock = 0;

  01dac	e3a03000	 mov         r3, #0
  01db0	e5cd300d	 strb        r3, [sp, #0xD]

; 1495 : 
; 1496 :         // Complete the write (no erase, we changed 0xFF -> 0x00)
; 1497 :         if (!FMD_WriteSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  01db4	e3a03001	 mov         r3, #1
  01db8	e28d2008	 add         r2, sp, #8
  01dbc	e3a01000	 mov         r1, #0
  01dc0	e59d0004	 ldr         r0, [sp, #4]
  01dc4	eb000000	 bl          FMD_WriteSector
  01dc8	e58d001c	 str         r0, [sp, #0x1C]
  01dcc	e59d301c	 ldr         r3, [sp, #0x1C]
  01dd0	e3530000	 cmp         r3, #0
  01dd4	1a000000	 bne         |$LN5@FMD_SetBlo|
  01dd8	ea000037	 b           |$cleanUp$46470|
  01ddc		 |$LN5@FMD_SetBlo|
  01ddc		 |$LN7@FMD_SetBlo|

; 1498 :         }
; 1499 : 
; 1500 : #ifdef BOOT_MODE
; 1501 :     if ( ((status & BLOCK_STATUS_READONLY) != 0) || ((status & BLOCK_STATUS_RESERVED) != 0) )

  01ddc	e59d303c	 ldr         r3, [sp, #0x3C]
  01de0	e3130004	 tst         r3, #4
  01de4	1a000002	 bne         |$LN3@FMD_SetBlo|
  01de8	e59d303c	 ldr         r3, [sp, #0x3C]
  01dec	e3130008	 tst         r3, #8
  01df0	0a00002f	 beq         |$LN4@FMD_SetBlo|
  01df4		 |$LN3@FMD_SetBlo|

; 1502 :         {
; 1503 :         // Read the sector info
; 1504 :         if (!FMD_ReadSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  01df4	e3a03001	 mov         r3, #1
  01df8	e28d2008	 add         r2, sp, #8
  01dfc	e3a01000	 mov         r1, #0
  01e00	e59d0004	 ldr         r0, [sp, #4]
  01e04	eb000000	 bl          FMD_ReadSector
  01e08	e58d0020	 str         r0, [sp, #0x20]
  01e0c	e59d3020	 ldr         r3, [sp, #0x20]
  01e10	e3530000	 cmp         r3, #0
  01e14	1a000000	 bne         |$LN2@FMD_SetBlo|
  01e18	ea000027	 b           |$cleanUp$46470|
  01e1c		 |$LN2@FMD_SetBlo|

; 1505 : 
; 1506 :         // Set the OEM field
; 1507 :         sectorInfo.bOEMReserved &= ((status & BLOCK_STATUS_READONLY) != 0) ? ~(OEM_BLOCK_READONLY) : 0xFF;

  01e1c	e59d303c	 ldr         r3, [sp, #0x3C]
  01e20	e3130004	 tst         r3, #4
  01e24	0a000002	 beq         |$LN11@FMD_SetBlo|
  01e28	e3e03002	 mvn         r3, #2
  01e2c	e58d3024	 str         r3, [sp, #0x24]
  01e30	ea000001	 b           |$LN12@FMD_SetBlo|
  01e34		 |$LN11@FMD_SetBlo|
  01e34	e3a030ff	 mov         r3, #0xFF
  01e38	e58d3024	 str         r3, [sp, #0x24]
  01e3c		 |$LN12@FMD_SetBlo|
  01e3c	e5dd300c	 ldrb        r3, [sp, #0xC]
  01e40	e1a02003	 mov         r2, r3
  01e44	e59d3024	 ldr         r3, [sp, #0x24]
  01e48	e0023003	 and         r3, r2, r3
  01e4c	e20330ff	 and         r3, r3, #0xFF
  01e50	e5cd300c	 strb        r3, [sp, #0xC]

; 1508 :         sectorInfo.bOEMReserved &= ((status & BLOCK_STATUS_RESERVED) != 0) ? ~(OEM_BLOCK_RESERVED) : 0xFF;

  01e54	e59d303c	 ldr         r3, [sp, #0x3C]
  01e58	e3130008	 tst         r3, #8
  01e5c	0a000002	 beq         |$LN13@FMD_SetBlo|
  01e60	e3e03001	 mvn         r3, #1
  01e64	e58d3028	 str         r3, [sp, #0x28]
  01e68	ea000001	 b           |$LN14@FMD_SetBlo|
  01e6c		 |$LN13@FMD_SetBlo|
  01e6c	e3a030ff	 mov         r3, #0xFF
  01e70	e58d3028	 str         r3, [sp, #0x28]
  01e74		 |$LN14@FMD_SetBlo|
  01e74	e5dd300c	 ldrb        r3, [sp, #0xC]
  01e78	e1a02003	 mov         r2, r3
  01e7c	e59d3028	 ldr         r3, [sp, #0x28]
  01e80	e0023003	 and         r3, r2, r3
  01e84	e20330ff	 and         r3, r3, #0xFF
  01e88	e5cd300c	 strb        r3, [sp, #0xC]

; 1509 :         
; 1510 :         // Complete the write (no erase, changed bits from 1s to 0s)
; 1511 :         if (!FMD_WriteSector(sector, NULL, &sectorInfo, 1)) goto cleanUp;

  01e8c	e3a03001	 mov         r3, #1
  01e90	e28d2008	 add         r2, sp, #8
  01e94	e3a01000	 mov         r1, #0
  01e98	e59d0004	 ldr         r0, [sp, #4]
  01e9c	eb000000	 bl          FMD_WriteSector
  01ea0	e58d002c	 str         r0, [sp, #0x2C]
  01ea4	e59d302c	 ldr         r3, [sp, #0x2C]
  01ea8	e3530000	 cmp         r3, #0
  01eac	1a000000	 bne         |$LN1@FMD_SetBlo|
  01eb0	ea000001	 b           |$cleanUp$46470|
  01eb4		 |$LN1@FMD_SetBlo|
  01eb4		 |$LN4@FMD_SetBlo|

; 1512 :         }
; 1513 : #endif
; 1514 : 
; 1515 :     rc = TRUE;

  01eb4	e3a03001	 mov         r3, #1
  01eb8	e58d3000	 str         r3, [sp]
  01ebc		 |$cleanUp$46470|

; 1516 : 
; 1517 : cleanUp:
; 1518 :     return rc;

  01ebc	e59d3000	 ldr         r3, [sp]
  01ec0	e58d3010	 str         r3, [sp, #0x10]

; 1519 : }

  01ec4	e59d0010	 ldr         r0, [sp, #0x10]
  01ec8	e28dd030	 add         sp, sp, #0x30
  01ecc	e89d6000	 ldmia       sp, {sp, lr}
  01ed0	e12fff1e	 bx          lr
  01ed4		 |$LN18@FMD_SetBlo|
  01ed4		 |$LN19@FMD_SetBlo|
  01ed4	00000000	 DCD         |s_hNand|
  01ed8		 |$M46782|

			 ENDP  ; |FMD_SetBlockStatus|

	EXPORT	|FMD_PowerUp|

  000c0			 AREA	 |.pdata|, PDATA
|$T46791| DCD	|$LN6@FMD_PowerU|
	DCD	0x40002101
; Function compile flags: /Odtp

  01ed8			 AREA	 |.text|, CODE, ARM

  01ed8		 |FMD_PowerUp| PROC

; 1528 : {

  01ed8		 |$LN6@FMD_PowerU|
  01ed8	e52de004	 str         lr, [sp, #-4]!
  01edc		 |$M46788|

; 1529 :     // exit if FMD wasn't opened
; 1530 :     if (s_hNand == NULL) return;

  01edc	e59f3074	 ldr         r3, [pc, #0x74]
  01ee0	e5933000	 ldr         r3, [r3]
  01ee4	e3530000	 cmp         r3, #0
  01ee8	1a000000	 bne         |$LN1@FMD_PowerU|
  01eec	ea000017	 b           |$LN2@FMD_PowerU|
  01ef0		 |$LN1@FMD_PowerU|

; 1531 :     
; 1532 :     // Obtain hardware lock
; 1533 :     NAND_MutexEnter(s_hNand);

  01ef0	e59f3060	 ldr         r3, [pc, #0x60]
  01ef4	e5930000	 ldr         r0, [r3]
  01ef8	eb000000	 bl          NAND_MutexEnter

; 1534 : 
; 1535 :     //  Only enable during NAND read/write/erase operations
; 1536 :     NAND_Enable(s_hNand, TRUE);

  01efc	e3a01001	 mov         r1, #1
  01f00	e59f3050	 ldr         r3, [pc, #0x50]
  01f04	e5930000	 ldr         r0, [r3]
  01f08	eb000000	 bl          NAND_Enable

; 1537 : 
; 1538 :     // Wait for NAND
; 1539 :     WaitForReadyStatus(s_hNand);   

  01f0c	e59f3044	 ldr         r3, [pc, #0x44]
  01f10	e5930000	 ldr         r0, [r3]
  01f14	eb000000	 bl          WaitForReadyStatus

; 1540 : 
; 1541 :     // Write the reset command
; 1542 :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  01f18	e3a010ff	 mov         r1, #0xFF
  01f1c	e59f3034	 ldr         r3, [pc, #0x34]
  01f20	e5930000	 ldr         r0, [r3]
  01f24	eb000000	 bl          NAND_SendCommand

; 1543 : 
; 1544 :     // Wait for NAND
; 1545 :     WaitForReadyStatus(s_hNand);

  01f28	e59f3028	 ldr         r3, [pc, #0x28]
  01f2c	e5930000	 ldr         r0, [r3]
  01f30	eb000000	 bl          WaitForReadyStatus

; 1546 : 
; 1547 :     //  Only enable during NAND read/write/erase operations
; 1548 :     NAND_Enable(s_hNand, FALSE);

  01f34	e3a01000	 mov         r1, #0
  01f38	e59f3018	 ldr         r3, [pc, #0x18]
  01f3c	e5930000	 ldr         r0, [r3]
  01f40	eb000000	 bl          NAND_Enable

; 1549 : 
; 1550 :     // Release hardware lock
; 1551 :     NAND_MutexExit(s_hNand);

  01f44	e59f300c	 ldr         r3, [pc, #0xC]
  01f48	e5930000	 ldr         r0, [r3]
  01f4c	eb000000	 bl          NAND_MutexExit
  01f50		 |$LN2@FMD_PowerU|

; 1552 : }

  01f50	e49de004	 ldr         lr, [sp], #4
  01f54	e12fff1e	 bx          lr
  01f58		 |$LN7@FMD_PowerU|
  01f58		 |$LN8@FMD_PowerU|
  01f58	00000000	 DCD         |s_hNand|
  01f5c		 |$M46789|

			 ENDP  ; |FMD_PowerUp|

	EXPORT	|FMD_PowerDown|

  000c8			 AREA	 |.pdata|, PDATA
|$T46798| DCD	|$LN6@FMD_PowerD|
	DCD	0x40002101
; Function compile flags: /Odtp

  01f5c			 AREA	 |.text|, CODE, ARM

  01f5c		 |FMD_PowerDown| PROC

; 1561 : {

  01f5c		 |$LN6@FMD_PowerD|
  01f5c	e52de004	 str         lr, [sp, #-4]!
  01f60		 |$M46795|

; 1562 :     // exit if FMD wasn't opened
; 1563 :     if (s_hNand == NULL) return;

  01f60	e59f3074	 ldr         r3, [pc, #0x74]
  01f64	e5933000	 ldr         r3, [r3]
  01f68	e3530000	 cmp         r3, #0
  01f6c	1a000000	 bne         |$LN1@FMD_PowerD|
  01f70	ea000017	 b           |$LN2@FMD_PowerD|
  01f74		 |$LN1@FMD_PowerD|

; 1564 :     
; 1565 :     // Obtain hardware lock
; 1566 :     NAND_MutexEnter(s_hNand);

  01f74	e59f3060	 ldr         r3, [pc, #0x60]
  01f78	e5930000	 ldr         r0, [r3]
  01f7c	eb000000	 bl          NAND_MutexEnter

; 1567 : 
; 1568 :     //  Only enable during NAND read/write/erase operations
; 1569 :     NAND_Enable(s_hNand, TRUE);

  01f80	e3a01001	 mov         r1, #1
  01f84	e59f3050	 ldr         r3, [pc, #0x50]
  01f88	e5930000	 ldr         r0, [r3]
  01f8c	eb000000	 bl          NAND_Enable

; 1570 : 
; 1571 :     // Wait for NAND
; 1572 :     WaitForReadyStatus(s_hNand);   

  01f90	e59f3044	 ldr         r3, [pc, #0x44]
  01f94	e5930000	 ldr         r0, [r3]
  01f98	eb000000	 bl          WaitForReadyStatus

; 1573 : 
; 1574 :     // Write the reset command
; 1575 :     NAND_SendCommand(s_hNand, NAND_CMD_RESET);

  01f9c	e3a010ff	 mov         r1, #0xFF
  01fa0	e59f3034	 ldr         r3, [pc, #0x34]
  01fa4	e5930000	 ldr         r0, [r3]
  01fa8	eb000000	 bl          NAND_SendCommand

; 1576 : 
; 1577 :     // Wait for NAND
; 1578 :     WaitForReadyStatus(s_hNand);

  01fac	e59f3028	 ldr         r3, [pc, #0x28]
  01fb0	e5930000	 ldr         r0, [r3]
  01fb4	eb000000	 bl          WaitForReadyStatus

; 1579 : 
; 1580 :     //  Only enable during NAND read/write/erase operations
; 1581 :     NAND_Enable(s_hNand, FALSE);

  01fb8	e3a01000	 mov         r1, #0
  01fbc	e59f3018	 ldr         r3, [pc, #0x18]
  01fc0	e5930000	 ldr         r0, [r3]
  01fc4	eb000000	 bl          NAND_Enable

; 1582 : 
; 1583 :     // Release hardware lock
; 1584 :     NAND_MutexExit(s_hNand);

  01fc8	e59f300c	 ldr         r3, [pc, #0xC]
  01fcc	e5930000	 ldr         r0, [r3]
  01fd0	eb000000	 bl          NAND_MutexExit
  01fd4		 |$LN2@FMD_PowerD|

; 1585 : }

  01fd4	e49de004	 ldr         lr, [sp], #4
  01fd8	e12fff1e	 bx          lr
  01fdc		 |$LN7@FMD_PowerD|
  01fdc		 |$LN8@FMD_PowerD|
  01fdc	00000000	 DCD         |s_hNand|
  01fe0		 |$M46796|

			 ENDP  ; |FMD_PowerDown|

	EXPORT	|FMD_OEMIoControl|

  000d0			 AREA	 |.pdata|, PDATA
|$T46806| DCD	|$LN5@FMD_OEMIoC|
	DCD	0x40000a04
; Function compile flags: /Odtp

  01fe0			 AREA	 |.text|, CODE, ARM

  01fe0		 |FMD_OEMIoControl| PROC

; 1600 : {

  01fe0		 |$LN5@FMD_OEMIoC|
  01fe0	e1a0c00d	 mov         r12, sp
  01fe4	e92d000f	 stmdb       sp!, {r0 - r3}
  01fe8	e92d5000	 stmdb       sp!, {r12, lr}
  01fec	e24dd004	 sub         sp, sp, #4
  01ff0		 |$M46803|

; 1601 : 
; 1602 :     UNREFERENCED_PARAMETER(code);
; 1603 : 
; 1604 :     UNREFERENCED_PARAMETER(pInBuffer);
; 1605 :     UNREFERENCED_PARAMETER(inSize);
; 1606 :     UNREFERENCED_PARAMETER(pOutBuffer);
; 1607 :     UNREFERENCED_PARAMETER(outSize);
; 1608 :     UNREFERENCED_PARAMETER(pOutSize);
; 1609 :     
; 1610 :     return FALSE;    

  01ff0	e3a03000	 mov         r3, #0
  01ff4	e58d3000	 str         r3, [sp]

; 1611 : }

  01ff8	e59d0000	 ldr         r0, [sp]
  01ffc	e28dd004	 add         sp, sp, #4
  02000	e89d6000	 ldmia       sp, {sp, lr}
  02004	e12fff1e	 bx          lr
  02008		 |$M46804|

			 ENDP  ; |FMD_OEMIoControl|

	END
