; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\OAL\OMAP_GTP_TIMER\PROFILER\profiler.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|g_oalProfilerEnabled| [ DATA ]
	EXPORT	|g_oalPerfTimerIrq| [ DATA ]
	EXPORT	|g_pPerfTimer| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_oalProfilerIncrement|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|g_oalProfilerEnabled| % 0x4
|g_pPerfTimer| % 0x4
|?PreviousValue@?1??OALTimerQueryPerformanceCounter@@9@9| % 0x8 ; `OALTimerQueryPerformanceCounter'::`2'::PreviousValue

  00000			 AREA	 |.data|, DATA
|g_oalPerfTimerIrq| DCD 0xffffffff

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALTimerQueryPerformanceFrequency|

  00010			 AREA	 |.bss|, NOINIT
|s_Frequency| %	0x4
|s_Frequency| %	0x4
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\oal\omap_gtp_timer\profiler\profiler.c

  00000			 AREA	 |.pdata|, PDATA
|$T45768| DCD	|$LN5@OALTimerQu|
	DCD	0x40000900
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerQueryPerformanceFrequency| PROC

; 135  : {    

  00000		 |$LN5@OALTimerQu|
  00000		 |$M45765|
  00000	e1a02000	 mov         r2, r0

; 136  :     pFrequency->QuadPart = s_Frequency;    

  00004	e59f3014	 ldr         r3, [pc, #0x14]
  00008	e3a01000	 mov         r1, #0

; 137  :     return TRUE;

  0000c	e3a00001	 mov         r0, #1
  00010	e5933000	 ldr         r3, [r3]
  00014	e5821004	 str         r1, [r2, #4]
  00018	e5823000	 str         r3, [r2]

; 138  : }

  0001c	e12fff1e	 bx          lr
  00020		 |$LN6@OALTimerQu|
  00020		 |$LN7@OALTimerQu|
  00020	00000000	 DCD         |s_Frequency|
  00024		 |$M45766|

			 ENDP  ; |OALTimerQueryPerformanceFrequency|

	EXPORT	|OALTimerQueryPerformanceCounter|
	IMPORT	|INTERRUPTS_ENABLE|

  00000			 AREA	 |.pdata|, PDATA
|$T45783| DCD	|$LN7@OALTimerQu@2|
	DCD	0x40001301
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerQueryPerformanceCounter| PROC

; 149  : {

  00000		 |$LN7@OALTimerQu@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M45780|
  00004	e1a04000	 mov         r4, r0

; 150  :     static LARGE_INTEGER PreviousValue = {0, 0};
; 151  :     DWORD CurrentValue;
; 152  :     BOOL bInterruptsEnabled;
; 153  :     
; 154  :     bInterruptsEnabled = INTERRUPTS_ENABLE(FALSE);

  00008	e3a00000	 mov         r0, #0
  0000c	eb000000	 bl          INTERRUPTS_ENABLE

; 155  : 
; 156  :     CurrentValue = INREG32(&g_pPerfTimer->TCRR);

  00010	e59f1030	 ldr         r1, [pc, #0x30]
  00014	e5912000	 ldr         r2, [r1]

; 157  :     if (CurrentValue < PreviousValue.LowPart)

  00018	e5913008	 ldr         r3, [r1, #8]
  0001c	e5922028	 ldr         r2, [r2, #0x28]
  00020	e1520003	 cmp         r2, r3

; 158  :     {
; 159  :         // rollover, increment upper 32 bits
; 160  :         PreviousValue.HighPart++;

  00024	e591300c	 ldr         r3, [r1, #0xC]
  00028	32833001	 addcc       r3, r3, #1
  0002c	3581300c	 strcc       r3, [r1, #0xC]

; 161  :     }
; 162  :     PreviousValue.LowPart = CurrentValue;
; 163  :     pCounter->QuadPart = PreviousValue.QuadPart;            
; 164  : 
; 165  :     INTERRUPTS_ENABLE(bInterruptsEnabled);

  00030	e5812008	 str         r2, [r1, #8]
  00034	e884000c	 stmia       r4, {r2, r3}
  00038	eb000000	 bl          INTERRUPTS_ENABLE

; 166  : 
; 167  :     return TRUE;

  0003c	e3a00001	 mov         r0, #1

; 168  : }

  00040	e8bd4010	 ldmia       sp!, {r4, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$LN8@OALTimerQu@2|
  00048		 |$LN9@OALTimerQu@2|
  00048	00000000	 DCD         |g_pPerfTimer|
  0004c		 |$M45781|

			 ENDP  ; |OALTimerQueryPerformanceCounter|

	EXPORT	|OEMProfileTimerEnable|
	IMPORT	|OALIntrEnableIrqs|
	IMPORT	|__rt_udiv64by64|

  00000			 AREA	 |.pdata|, PDATA
|$T45797| DCD	|$LN8@OEMProfile|
	DCD	0x40002501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMProfileTimerEnable| PROC

; 174  : {

  00000		 |$LN8@OEMProfile|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45794|

; 175  :     DWORD tcrr;
; 176  :     UINT64 val;
; 177  :     BOOL enabled;
; 178  :     
; 179  :     
; 180  :     // calculate interrupt intervals   
; 181  :     val = (UINT64) dwUSecInterval * (UINT64)s_Frequency;

  00004	e59f5084	 ldr         r5, [pc, #0x84]
  00008	e3a0393d	 mov         r3, #0x3D, 18

; 182  :     val = val / 1000000;

  0000c	e3832d09	 orr         r2, r3, #9, 26
  00010	e595e000	 ldr         lr, [r5]
  00014	e3a03000	 mov         r3, #0
  00018	e081009e	 umull       r0, r1, lr, r0
  0001c	eb000000	 bl          __rt_udiv64by64
  00020	e59f4064	 ldr         r4, [pc, #0x64]
  00024	e5840000	 str         r0, [r4]

; 183  :     g_oalProfilerIncrement = (UINT32) val;
; 184  : 
; 185  :     // Following code should not be interrupted
; 186  :     enabled = INTERRUPTS_ENABLE(FALSE);

  00028	e3a00000	 mov         r0, #0
  0002c	eb000000	 bl          INTERRUPTS_ENABLE

; 187  :     
; 188  :     // set interrupts at requested intervals
; 189  :     tcrr = INREG32(&g_pPerfTimer->TCRR) + g_oalProfilerIncrement;

  00030	e5951008	 ldr         r1, [r5, #8]
  00034	e5942000	 ldr         r2, [r4]
  00038	e1a04000	 mov         r4, r0
  0003c	e5913028	 ldr         r3, [r1, #0x28]

; 190  :     OUTREG32(&g_pPerfTimer->TMAR, tcrr);

  00040	e0833002	 add         r3, r3, r2
  00044	e5813038	 str         r3, [r1, #0x38]
  00048	e5952008	 ldr         r2, [r5, #8]
  0004c		 |$LL2@OEMProfile|

; 191  :     while ((INREG32(&g_pPerfTimer->TWPS) & GPTIMER_TWPS_TMAR) != 0);

  0004c	e5923034	 ldr         r3, [r2, #0x34]
  00050	e3130010	 tst         r3, #0x10
  00054	1afffffc	 bne         |$LL2@OEMProfile|

; 192  :     
; 193  :     // enable high perf interrupt
; 194  :     g_oalProfilerEnabled = TRUE;

  00058	e3a03001	 mov         r3, #1
  0005c	e5853004	 str         r3, [r5, #4]

; 195  :     SETREG32(&g_pPerfTimer->TCLR, GPTIMER_TCLR_CE);

  00060	e5923024	 ldr         r3, [r2, #0x24]

; 196  : 
; 197  :     // Enable profiling interrupt
; 198  :     OALIntrEnableIrqs(1, &g_oalPerfTimerIrq);

  00064	e59f101c	 ldr         r1, [pc, #0x1C]
  00068	e3a00001	 mov         r0, #1
  0006c	e3833040	 orr         r3, r3, #0x40
  00070	e5823024	 str         r3, [r2, #0x24]
  00074	eb000000	 bl          OALIntrEnableIrqs

; 199  : 
; 200  :     // Enable interrupts
; 201  :     INTERRUPTS_ENABLE(enabled);

  00078	e1a00004	 mov         r0, r4
  0007c	eb000000	 bl          INTERRUPTS_ENABLE

; 202  :     
; 203  : }

  00080	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00084	e12fff1e	 bx          lr
  00088		 |$LN9@OEMProfile|
  00088		 |$LN10@OEMProfile|
  00088	00000000	 DCD         |g_oalPerfTimerIrq|
  0008c		 |$LN11@OEMProfile|
  0008c	00000000	 DCD         |g_oalProfilerIncrement|
  00090		 |$LN12@OEMProfile|
  00090	00000000	 DCD         |s_Frequency|
  00094		 |$M45795|

			 ENDP  ; |OEMProfileTimerEnable|

	EXPORT	|OEMProfileTimerDisable|
	IMPORT	|OALIntrDisableIrqs|

  00000			 AREA	 |.pdata|, PDATA
|$T45809| DCD	|$LN6@OEMProfile@2|
	DCD	0x40001701
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMProfileTimerDisable| PROC

; 208  : {

  00000		 |$LN6@OEMProfile@2|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45806|

; 209  :     BOOL enabled;
; 210  :     
; 211  :     if (g_oalProfilerEnabled == FALSE) return;

  00004	e59f504c	 ldr         r5, [pc, #0x4C]
  00008	e5953000	 ldr         r3, [r5]
  0000c	e3530000	 cmp         r3, #0
  00010	0a00000d	 beq         |$LN2@OEMProfile@2|

; 212  : 
; 213  :     // Following code should not be interrupted
; 214  :     enabled = INTERRUPTS_ENABLE(FALSE);

  00014	e3a00000	 mov         r0, #0
  00018	eb000000	 bl          INTERRUPTS_ENABLE

; 215  : 
; 216  :     // Disable the profile timer interrupt
; 217  :     OALIntrDisableIrqs(1, &g_oalPerfTimerIrq);    

  0001c	e59f1030	 ldr         r1, [pc, #0x30]
  00020	e1a04000	 mov         r4, r0
  00024	e3a00001	 mov         r0, #1
  00028	eb000000	 bl          OALIntrDisableIrqs

; 218  : 
; 219  :     // Reset flag
; 220  :     g_oalProfilerEnabled = FALSE;
; 221  :     CLRREG32(&g_pPerfTimer->TCLR, GPTIMER_TCLR_CE);

  0002c	e5952004	 ldr         r2, [r5, #4]
  00030	e3a03000	 mov         r3, #0
  00034	e5853000	 str         r3, [r5]
  00038	e5923024	 ldr         r3, [r2, #0x24]

; 222  : 
; 223  :     // Enable interrupts
; 224  :     INTERRUPTS_ENABLE(enabled);

  0003c	e1a00004	 mov         r0, r4
  00040	e3c33040	 bic         r3, r3, #0x40
  00044	e5823024	 str         r3, [r2, #0x24]
  00048	eb000000	 bl          INTERRUPTS_ENABLE
  0004c		 |$LN2@OEMProfile@2|

; 225  : }

  0004c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00050	e12fff1e	 bx          lr
  00054		 |$LN7@OEMProfile@2|
  00054		 |$LN8@OEMProfile@2|
  00054	00000000	 DCD         |g_oalPerfTimerIrq|
  00058		 |$LN9@OEMProfile@2|
  00058	00000000	 DCD         |g_oalProfilerEnabled|
  0005c		 |$M45807|

			 ENDP  ; |OEMProfileTimerDisable|

	EXPORT	|OALProfileTimerHit|
	IMPORT	|OALIntrDoneIrqs|
	IMPORT	|ProfilerHit|

  00000			 AREA	 |.pdata|, PDATA
|$T45821| DCD	|$LN5@OALProfile|
	DCD	0x40001401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALProfileTimerHit| PROC

; 233  : {

  00000		 |$LN5@OALProfile|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45818|

; 234  :     UINT32  tcrr;
; 235  : 
; 236  :     //  Call ProfileHit
; 237  :     ProfilerHit(ra);

  00004	eb000000	 bl          ProfilerHit

; 238  : 
; 239  :     // get current time
; 240  :     tcrr = INREG32(&g_pPerfTimer->TCRR);

  00008	e59f403c	 ldr         r4, [pc, #0x3C]

; 241  :     
; 242  :     // clear interrupt
; 243  :     OUTREG32(&g_pPerfTimer->TISR, 
; 244  :         GPTIMER_TISR_MAT | GPTIMER_TISR_OVF | GPTIMER_TISR_TCAR
; 245  :         );
; 246  : 
; 247  :     // setup for next interrupt        
; 248  :     OUTREG32(&g_pPerfTimer->TMAR, tcrr + g_oalProfilerIncrement);

  0000c	e59f2034	 ldr         r2, [pc, #0x34]
  00010	e3a05007	 mov         r5, #7
  00014	e5943000	 ldr         r3, [r4]

; 249  : 
; 250  :     // clear interrupt status
; 251  :     OALIntrDoneIrqs(1, &g_oalPerfTimerIrq);

  00018	e59f1024	 ldr         r1, [pc, #0x24]
  0001c	e3a00001	 mov         r0, #1
  00020	e593e028	 ldr         lr, [r3, #0x28]
  00024	e5835018	 str         r5, [r3, #0x18]
  00028	e5923000	 ldr         r3, [r2]
  0002c	e5942000	 ldr         r2, [r4]
  00030	e083300e	 add         r3, r3, lr
  00034	e5823038	 str         r3, [r2, #0x38]
  00038	eb000000	 bl          OALIntrDoneIrqs

; 252  : }

  0003c	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00040	e12fff1e	 bx          lr
  00044		 |$LN6@OALProfile|
  00044		 |$LN7@OALProfile|
  00044	00000000	 DCD         |g_oalPerfTimerIrq|
  00048		 |$LN8@OALProfile|
  00048	00000000	 DCD         |g_oalProfilerIncrement|
  0004c		 |$LN9@OALProfile|
  0004c	00000000	 DCD         |g_pPerfTimer|
  00050		 |$M45819|

			 ENDP  ; |OALProfileTimerHit|

	EXPORT	|OALPerformanceTimerInit|
	EXPORT	|??_C@_1DC@FFGFMCFN@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAB?$AAu?$AAi?$AAl?$AAd?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@JOODGIBI@?$AA?9?$AA?9?$AA?9?$AAH?$AAi?$AAg?$AAh?$AA?5?$AAP?$AAe?$AAr?$AAf?$AAo?$AAr?$AAm?$AAa?$AAn?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAi?$AAs@| [ DATA ] ; `string'
	IMPORT	|g_pOemGlobal|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|BSPGetGPTPerfHighFreqClock|
	IMPORT	|GetIrqByDevice|
	IMPORT	|OALPAtoVA|
	IMPORT	|GetAddressByDevice|
	IMPORT	|BSPGetGPTPerfDevice|

  00000			 AREA	 |.pdata|, PDATA
|$T45835| DCD	|$LN12@OALPerform|
	DCD	0x40005b01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@FFGFMCFN@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAB?$AAu?$AAi?$AAl?$AAd?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$AN?$AA?6?$AA?$AA@| DCB "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, "P", 0x0, "r", 0x0, "o"
	DCB	0x0, "f", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "B", 0x0, "u", 0x0, "i", 0x0, "l", 0x0, "d", 0x0, "*"
	DCB	0x0, "*", 0x0, "*", 0x0, "*", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@JOODGIBI@?$AA?9?$AA?9?$AA?9?$AAH?$AAi?$AAg?$AAh?$AA?5?$AAP?$AAe?$AAr?$AAf?$AAo?$AAr?$AAm?$AAa?$AAn?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAi?$AAs@| DCB "-"
	DCB	0x0, "-", 0x0, "-", 0x0, "H", 0x0, "i", 0x0, "g", 0x0, "h"
	DCB	0x0, " ", 0x0, "P", 0x0, "e", 0x0, "r", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, "m", 0x0, "a", 0x0, "n", 0x0, "c", 0x0, "e"
	DCB	0x0, " ", 0x0, "F", 0x0, "r", 0x0, "e", 0x0, "q", 0x0, "u"
	DCB	0x0, "e", 0x0, "n", 0x0, "c", 0x0, "y", 0x0, " ", 0x0, "i"
	DCB	0x0, "s", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "h"
	DCB	0x0, "z", 0x0, "-", 0x0, "-", 0x0, "-", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALPerformanceTimerInit| PROC

; 49   : {

  00000		 |$LN12@OALPerform|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M45832|

; 50   :     UINT srcClock;
; 51   :     DWORD tclr = 0;	
; 52   : 
; 53   :     OMAP_DEVICE gptPerfDevice = BSPGetGPTPerfDevice();

  00004	eb000000	 bl          BSPGetGPTPerfDevice
  00008	e1a04000	 mov         r4, r0

; 54   :     if (gptPerfDevice == OMAP_DEVICE_NONE)

  0000c	e3740001	 cmn         r4, #1
  00010	0a00004a	 beq         |$LN1@OALPerform|

; 55   :     {
; 56   :         return;
; 57   :     }
; 58   : 
; 59   :     // map HighResTimer
; 60   :     g_pPerfTimer = OALPAtoUA(GetAddressByDevice(gptPerfDevice));

  00014	eb000000	 bl          GetAddressByDevice
  00018	e3a01000	 mov         r1, #0
  0001c	eb000000	 bl          OALPAtoVA
  00020	e59f5140	 ldr         r5, [pc, #0x140]

; 61   :     g_oalPerfTimerIrq = GetIrqByDevice(gptPerfDevice,NULL);

  00024	e3a01000	 mov         r1, #0
  00028	e5850008	 str         r0, [r5, #8]
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          GetIrqByDevice
  00034	e59f2128	 ldr         r2, [pc, #0x128]
  00038	e1a03000	 mov         r3, r0

; 62   : 
; 63   : 	// Select high frequency source clock and frequency
; 64   :     srcClock = BSPGetGPTPerfHighFreqClock(&s_Frequency);

  0003c	e1a00005	 mov         r0, r5
  00040	e5823000	 str         r3, [r2]
  00044	eb000000	 bl          BSPGetGPTPerfHighFreqClock

; 65   : 	//PrcmDeviceSetSourceClocks(gptPerfDevice,1,&srcClock);
; 66   :     // Enable GPTimer for high perf/monte carlo profiling
; 67   :     EnableDeviceClocks(gptPerfDevice, TRUE);

  00048	e3a01001	 mov         r1, #1
  0004c	e1a00004	 mov         r0, r4
  00050	eb000000	 bl          EnableDeviceClocks

; 68   : 
; 69   : 
; 70   :     // configure performance timer
; 71   :     //---------------------------------------------------
; 72   :     // Soft reset GPTIMER and wait until finished
; 73   :     SETREG32(&g_pPerfTimer->TIOCP, SYSCONFIG_SOFTRESET);

  00054	e5952008	 ldr         r2, [r5, #8]
  00058	e5923010	 ldr         r3, [r2, #0x10]
  0005c	e3833002	 orr         r3, r3, #2
  00060	e5823010	 str         r3, [r2, #0x10]
  00064	e5952008	 ldr         r2, [r5, #8]
  00068		 |$LL4@OALPerform|

; 74   :     while ((INREG32(&g_pPerfTimer->TISTAT) & GPTIMER_TISTAT_RESETDONE) == 0);

  00068	e5923014	 ldr         r3, [r2, #0x14]
  0006c	e3130001	 tst         r3, #1
  00070	0afffffc	 beq         |$LL4@OALPerform|
  00074	e3a03c02	 mov         r3, #2, 24

; 75   :  
; 76   :     // Enable smart idle and autoidle
; 77   :     // Set clock activity - FCLK can be  switched off, 
; 78   :     // L4 interface clock is maintained during wkup.
; 79   :     OUTREG32(&g_pPerfTimer->TIOCP, 
; 80   :         0x200 | SYSCONFIG_SMARTIDLE|SYSCONFIG_ENAWAKEUP|
; 81   :             SYSCONFIG_AUTOIDLE); 

  00078	e3833015	 orr         r3, r3, #0x15
  0007c	e5823010	 str         r3, [r2, #0x10]

; 82   : 
; 83   :     // Select posted mode
; 84   :     SETREG32(&g_pPerfTimer->TSICR, GPTIMER_TSICR_POSTED);

  00080	e5952008	 ldr         r2, [r5, #8]

; 85   : 
; 86   :     // clear match register
; 87   :     OUTREG32(&g_pPerfTimer->TMAR, 0xFFFFFFFF);

  00084	e3e04000	 mvn         r4, #0

; 88   :     
; 89   :     // clear interrupts
; 90   :     OUTREG32(&g_pPerfTimer->TISR, 0x00000000);

  00088	e3a0e000	 mov         lr, #0
  0008c	e5923040	 ldr         r3, [r2, #0x40]

; 91   :     
; 92   :     // enable match interrupt
; 93   :     OUTREG32(&g_pPerfTimer->TIER, GPTIMER_TIER_MATCH);

  00090	e3a01001	 mov         r1, #1

; 94   :     
; 95   :     // enable wakeups
; 96   :     OUTREG32(&g_pPerfTimer->TWER, GPTIMER_TWER_MATCH);
; 97   : 
; 98   :     // Set the load register value.
; 99   :     OUTREG32(&g_pPerfTimer->TLDR, 0x00000000);
; 100  :  
; 101  :     // Trigger a counter reload by writing    
; 102  :     OUTREG32(&g_pPerfTimer->TTGR, 0xFFFFFFFF);
; 103  : 
; 104  : 
; 105  : 
; 106  :     OALMSG(1, (L"****Profiler Build****\r\n"));

  00094	e59f00c4	 ldr         r0, [pc, #0xC4]
  00098	e3833004	 orr         r3, r3, #4
  0009c	e5823040	 str         r3, [r2, #0x40]
  000a0	e5953008	 ldr         r3, [r5, #8]
  000a4	e5834038	 str         r4, [r3, #0x38]
  000a8	e5953008	 ldr         r3, [r5, #8]
  000ac	e583e018	 str         lr, [r3, #0x18]
  000b0	e5953008	 ldr         r3, [r5, #8]
  000b4	e583101c	 str         r1, [r3, #0x1C]
  000b8	e5953008	 ldr         r3, [r5, #8]
  000bc	e5831020	 str         r1, [r3, #0x20]
  000c0	e5953008	 ldr         r3, [r5, #8]
  000c4	e583e02c	 str         lr, [r3, #0x2C]
  000c8	e5953008	 ldr         r3, [r5, #8]
  000cc	e5834030	 str         r4, [r3, #0x30]
  000d0	eb000000	 bl          NKDbgPrintfW

; 107  :     OALMSG(1, (L"---High Performance Frequency is %d hz---\r\n", s_Frequency));

  000d4	e5951000	 ldr         r1, [r5]
  000d8	e59f007c	 ldr         r0, [pc, #0x7C]
  000dc	eb000000	 bl          NKDbgPrintfW

; 108  :     
; 109  :     // build tclr mask
; 110  :     tclr |= GPTIMER_TCLR_AR;
; 111  :     OUTREG32(&g_pPerfTimer->TCLR,  tclr);

  000e0	e5953008	 ldr         r3, [r5, #8]

; 112  :    
; 113  :     // Initialize high resolution timer function pointers
; 114  :     pQueryPerformanceFrequency = OALTimerQueryPerformanceFrequency;

  000e4	e59fe06c	 ldr         lr, [pc, #0x6C]
  000e8	e3a02002	 mov         r2, #2
  000ec	e5832024	 str         r2, [r3, #0x24]
  000f0	e59e2000	 ldr         r2, [lr]
  000f4	e59f3058	 ldr         r3, [pc, #0x58]

; 115  :     pQueryPerformanceCounter = OALTimerQueryPerformanceCounter;    

  000f8	e59f1050	 ldr         r1, [pc, #0x50]

; 116  :     g_pOemGlobal->pfnProfileTimerEnable = OEMProfileTimerEnable;

  000fc	e59f0048	 ldr         r0, [pc, #0x48]
  00100	e5823034	 str         r3, [r2, #0x34]
  00104	e59e3000	 ldr         r3, [lr]

; 117  :     g_pOemGlobal->pfnProfileTimerDisable = OEMProfileTimerDisable;

  00108	e59f2038	 ldr         r2, [pc, #0x38]
  0010c	e5831030	 str         r1, [r3, #0x30]
  00110	e59e3000	 ldr         r3, [lr]
  00114	e58300a0	 str         r0, [r3, #0xA0]
  00118	e59e3000	 ldr         r3, [lr]
  0011c	e58320a4	 str         r2, [r3, #0xA4]

; 118  :     
; 119  : 
; 120  :     //  Start the timer.  Also set for auto reload
; 121  :     SETREG32(&g_pPerfTimer->TCLR, GPTIMER_TCLR_ST);

  00120	e5952008	 ldr         r2, [r5, #8]
  00124	e5923024	 ldr         r3, [r2, #0x24]
  00128	e3833001	 orr         r3, r3, #1
  0012c	e5823024	 str         r3, [r2, #0x24]
  00130	e5952008	 ldr         r2, [r5, #8]
  00134		 |$LL2@OALPerform|

; 122  :     while ((INREG32(&g_pPerfTimer->TWPS) & GPTIMER_TWPS_TCLR) != 0);

  00134	e5923034	 ldr         r3, [r2, #0x34]
  00138	e3130001	 tst         r3, #1
  0013c	1afffffc	 bne         |$LL2@OALPerform|
  00140		 |$LN1@OALPerform|

; 123  :     
; 124  : }

  00140	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00144	e12fff1e	 bx          lr
  00148		 |$LN13@OALPerform|
  00148		 |$LN14@OALPerform|
  00148	00000000	 DCD         |OEMProfileTimerDisable|
  0014c		 |$LN15@OALPerform|
  0014c	00000000	 DCD         |OEMProfileTimerEnable|
  00150		 |$LN16@OALPerform|
  00150	00000000	 DCD         |OALTimerQueryPerformanceCounter|
  00154		 |$LN17@OALPerform|
  00154	00000000	 DCD         |OALTimerQueryPerformanceFrequency|
  00158		 |$LN18@OALPerform|
  00158	00000000	 DCD         |g_pOemGlobal|
  0015c		 |$LN19@OALPerform|
  0015c	00000000	 DCD         |??_C@_1FI@JOODGIBI@?$AA?9?$AA?9?$AA?9?$AAH?$AAi?$AAg?$AAh?$AA?5?$AAP?$AAe?$AAr?$AAf?$AAo?$AAr?$AAm?$AAa?$AAn?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAe?$AAq?$AAu?$AAe?$AAn?$AAc?$AAy?$AA?5?$AAi?$AAs@|
  00160		 |$LN20@OALPerform|
  00160	00000000	 DCD         |??_C@_1DC@FFGFMCFN@?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AAP?$AAr?$AAo?$AAf?$AAi?$AAl?$AAe?$AAr?$AA?5?$AAB?$AAu?$AAi?$AAl?$AAd?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$CK?$AA?$AN?$AA?6?$AA?$AA@|
  00164		 |$LN21@OALPerform|
  00164	00000000	 DCD         |g_oalPerfTimerIrq|
  00168		 |$LN22@OALPerform|
  00168	00000000	 DCD         |s_Frequency|
  0016c		 |$M45833|

			 ENDP  ; |OALPerformanceTimerInit|

	END
