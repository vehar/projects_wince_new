; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\OAL\OMAP_GTP_TIMER\TIMER\timer.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|timer_posted_pending_bit| [ DATA ]
	EXPORT	|g_wakeupLatencyConstraintTickCount| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_TimerDevice|, 0x4

	 COMMON	|g_oalTimerContext|, 0x20

	 COMMON	|g_pTimerRegs|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|?_max@?1??OEMIdle@@9@9| % 0x4				; `OEMIdle'::`2'::_max
|?_count@?1??OEMIdle@@9@9| % 0x4			; `OEMIdle'::`2'::_count

  00000			 AREA	 |.data|, DATA
|timer_posted_pending_bit| DCD 0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	0x4
	DCD	0x8
	DCD	0x0
	DCD	0x10
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x20
	DCD	0x40
	DCD	0x80
	DCD	0x100
	DCD	0x200
|g_wakeupLatencyConstraintTickCount| DCD 0x7fffffff

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|OALTimerGetReg|
	EXPORT	|OALTimerSetReg|
	EXPORT	|OALTimerStart|

  00000			 AREA	 |.pdata|, PDATA
|$T45972| DCD	|$LN10@OALTimerSt|
	DCD	0x40003702
; Function compile flags: /Odtp
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\oal\omap_gtp_timer\timer\timer.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerStart| PROC

; 197  : {

  00000		 |$LN10@OALTimerSt|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M45969|

; 198  :     UINT32 i;
; 199  :     UINT tcrrExit = 0;

  00008	e3a03000	 mov         r3, #0
  0000c	e58d3004	 str         r3, [sp, #4]

; 200  : 
; 201  :     // Enable match interrupt
; 202  :     OALTimerSetReg(&g_pTimerRegs->TIER, GPTIMER_TIER_MATCH);

  00010	e3a01001	 mov         r1, #1
  00014	e59f30bc	 ldr         r3, [pc, #0xBC]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e283001c	 add         r0, r3, #0x1C
  00020	eb000000	 bl          OALTimerSetReg

; 203  : 	
; 204  :     OALTimerSetReg(&g_pTimerRegs->TCLR, OALTimerGetReg(&g_pTimerRegs->TCLR) | GPTIMER_TCLR_ST);

  00024	e59f30ac	 ldr         r3, [pc, #0xAC]
  00028	e5933000	 ldr         r3, [r3]
  0002c	e2830024	 add         r0, r3, #0x24
  00030	eb000000	 bl          OALTimerGetReg
  00034	e58d0008	 str         r0, [sp, #8]
  00038	e59d3008	 ldr         r3, [sp, #8]
  0003c	e3831001	 orr         r1, r3, #1
  00040	e59f3090	 ldr         r3, [pc, #0x90]
  00044	e5933000	 ldr         r3, [r3]
  00048	e2830024	 add         r0, r3, #0x24
  0004c	eb000000	 bl          OALTimerSetReg

; 205  :     for (i = 0; i < 0x100; i++)

  00050	e3a03000	 mov         r3, #0
  00054	e58d3000	 str         r3, [sp]
  00058	ea000002	 b           |$LN5@OALTimerSt|
  0005c		 |$LN4@OALTimerSt|
  0005c	e59d3000	 ldr         r3, [sp]
  00060	e2833001	 add         r3, r3, #1
  00064	e58d3000	 str         r3, [sp]
  00068		 |$LN5@OALTimerSt|
  00068	e59d3000	 ldr         r3, [sp]
  0006c	e3530c01	 cmp         r3, #1, 24
  00070	2a000000	 bcs         |$LN3@OALTimerSt|

; 206  :     {
; 207  :     }

  00074	eafffff8	 b           |$LN4@OALTimerSt|
  00078		 |$LN3@OALTimerSt|

; 208  :     // get current TCRR value: workaround for errata 1.35
; 209  :     OALTimerGetReg(&g_pTimerRegs->TCRR);

  00078	e59f3058	 ldr         r3, [pc, #0x58]
  0007c	e5933000	 ldr         r3, [r3]
  00080	e2830028	 add         r0, r3, #0x28
  00084	eb000000	 bl          OALTimerGetReg

; 210  :     tcrrExit = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00088	e59f3048	 ldr         r3, [pc, #0x48]
  0008c	e5933000	 ldr         r3, [r3]
  00090	e2830028	 add         r0, r3, #0x28
  00094	eb000000	 bl          OALTimerGetReg
  00098	e58d000c	 str         r0, [sp, #0xC]
  0009c	e59d300c	 ldr         r3, [sp, #0xC]
  000a0	e58d3004	 str         r3, [sp, #4]
  000a4		 |$LN2@OALTimerSt|

; 211  :     // ERRATA 1.31 workaround (ES 1.0 only)
; 212  :     // wait for updated TCRR value
; 213  :     while (tcrrExit == (OALTimerGetReg(&g_pTimerRegs->TCRR)));	

  000a4	e59f302c	 ldr         r3, [pc, #0x2C]
  000a8	e5933000	 ldr         r3, [r3]
  000ac	e2830028	 add         r0, r3, #0x28
  000b0	eb000000	 bl          OALTimerGetReg
  000b4	e58d0010	 str         r0, [sp, #0x10]
  000b8	e59d2004	 ldr         r2, [sp, #4]
  000bc	e59d3010	 ldr         r3, [sp, #0x10]
  000c0	e1520003	 cmp         r2, r3
  000c4	1a000000	 bne         |$LN1@OALTimerSt|
  000c8	eafffff5	 b           |$LN2@OALTimerSt|
  000cc		 |$LN1@OALTimerSt|

; 214  : }

  000cc	e28dd014	 add         sp, sp, #0x14
  000d0	e49de004	 ldr         lr, [sp], #4
  000d4	e12fff1e	 bx          lr
  000d8		 |$LN11@OALTimerSt|
  000d8		 |$LN12@OALTimerSt|
  000d8	00000000	 DCD         |g_pTimerRegs|
  000dc		 |$M45970|

			 ENDP  ; |OALTimerStart|

	EXPORT	|??_C@_1EA@BFGMCCBB@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAG?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T45980| DCD	|$LN9@OALTimerGe|
	DCD	0x40002d04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@BFGMCCBB@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAG?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, " ", 0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, "G", 0x0, "e"
	DCB	0x0, "t", 0x0, "R", 0x0, "e", 0x0, "g", 0x0, ":", 0x0, " "
	DCB	0x0, "w", 0x0, "a", 0x0, "i", 0x0, "t", 0x0, " ", 0x0, "t"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerGetReg| PROC

; 154  : {

  00000		 |$LN9@OALTimerGe|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd008	 sub         sp, sp, #8
  00010		 |$M45977|

; 155  :     UINT32 i=0;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 156  : 
; 157  :     if(g_oalTimerContext.Posted)

  00018	e59f3090	 ldr         r3, [pc, #0x90]
  0001c	e5933018	 ldr         r3, [r3, #0x18]
  00020	e3530000	 cmp         r3, #0
  00024	0a000017	 beq         |$LN4@OALTimerGe|
  00028		 |$LN3@OALTimerGe|

; 158  :         while(INREG32(&g_pTimerRegs->TWPS) & timer_posted_pending_bit[((UINT32)addr&0xff)>>2]) 

  00028	e59f307c	 ldr         r3, [pc, #0x7C]
  0002c	e5933000	 ldr         r3, [r3]
  00030	e2830034	 add         r0, r3, #0x34
  00034	e59d3010	 ldr         r3, [sp, #0x10]
  00038	e20330ff	 and         r3, r3, #0xFF
  0003c	e1a01123	 mov         r1, r3, lsr #2
  00040	e3a03004	 mov         r3, #4
  00044	e0020391	 mul         r2, r1, r3
  00048	e59f3058	 ldr         r3, [pc, #0x58]
  0004c	e0833002	 add         r3, r3, r2
  00050	e5902000	 ldr         r2, [r0]
  00054	e5933000	 ldr         r3, [r3]
  00058	e1120003	 tst         r2, r3
  0005c	0a000009	 beq         |$LN2@OALTimerGe|

; 159  : 		if(i++>TIMER_POSTED_TIMEOUT)

  00060	e59d3000	 ldr         r3, [sp]
  00064	e3530ffa	 cmp         r3, #0xFA, 30
  00068	e59d3000	 ldr         r3, [sp]
  0006c	e2833001	 add         r3, r3, #1
  00070	e58d3000	 str         r3, [sp]
  00074	9a000002	 bls         |$LN1@OALTimerGe|

; 160  : 		{
; 161  : 		    RETAILMSG(1, (L"\r\n OALTimerGetReg: wait timeout"));

  00078	e59f0024	 ldr         r0, [pc, #0x24]
  0007c	eb000000	 bl          NKDbgPrintfW

; 162  : 		    break;

  00080	ea000000	 b           |$LN2@OALTimerGe|
  00084		 |$LN1@OALTimerGe|

; 163  : 	       }

  00084	eaffffe7	 b           |$LN3@OALTimerGe|
  00088		 |$LN2@OALTimerGe|
  00088		 |$LN4@OALTimerGe|

; 164  :     
; 165  :     return INREG32(addr);

  00088	e59d3010	 ldr         r3, [sp, #0x10]
  0008c	e5933000	 ldr         r3, [r3]
  00090	e58d3004	 str         r3, [sp, #4]

; 166  :     
; 167  : }

  00094	e59d0004	 ldr         r0, [sp, #4]
  00098	e28dd008	 add         sp, sp, #8
  0009c	e89d6000	 ldmia       sp, {sp, lr}
  000a0	e12fff1e	 bx          lr
  000a4		 |$LN10@OALTimerGe|
  000a4		 |$LN11@OALTimerGe|
  000a4	00000000	 DCD         |??_C@_1EA@BFGMCCBB@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAG?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
  000a8		 |$LN12@OALTimerGe|
  000a8	00000000	 DCD         |timer_posted_pending_bit|
  000ac		 |$LN13@OALTimerGe|
  000ac	00000000	 DCD         |g_pTimerRegs|
  000b0		 |$LN14@OALTimerGe|
  000b0	00000000	 DCD         |g_oalTimerContext|
  000b4		 |$M45978|

			 ENDP  ; |OALTimerGetReg|

	EXPORT	|??_C@_1EA@OPCPFCAE@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAS?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'

  00000			 AREA	 |.pdata|, PDATA
|$T45992| DCD	|$LN9@OALTimerSe|
	DCD	0x40002c04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@OPCPFCAE@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAS?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, " ", 0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "R", 0x0, "e", 0x0, "g", 0x0, ":", 0x0, " "
	DCB	0x0, "w", 0x0, "a", 0x0, "i", 0x0, "t", 0x0, " ", 0x0, "t"
	DCB	0x0, "i", 0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t"
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerSetReg| PROC

; 177  : {

  00000		 |$LN9@OALTimerSe|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0003	 stmdb       sp!, {r0, r1}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M45989|

; 178  :     UINT32 i=0;

  00010	e3a03000	 mov         r3, #0
  00014	e58d3000	 str         r3, [sp]

; 179  : 
; 180  :     if(g_oalTimerContext.Posted)

  00018	e59f308c	 ldr         r3, [pc, #0x8C]
  0001c	e5933018	 ldr         r3, [r3, #0x18]
  00020	e3530000	 cmp         r3, #0
  00024	0a000017	 beq         |$LN4@OALTimerSe|
  00028		 |$LN3@OALTimerSe|

; 181  :         while(INREG32(&g_pTimerRegs->TWPS) & timer_posted_pending_bit[((UINT32)addr&0xff)>>2]) 

  00028	e59f3078	 ldr         r3, [pc, #0x78]
  0002c	e5933000	 ldr         r3, [r3]
  00030	e2830034	 add         r0, r3, #0x34
  00034	e59d300c	 ldr         r3, [sp, #0xC]
  00038	e20330ff	 and         r3, r3, #0xFF
  0003c	e1a01123	 mov         r1, r3, lsr #2
  00040	e3a03004	 mov         r3, #4
  00044	e0020391	 mul         r2, r1, r3
  00048	e59f3054	 ldr         r3, [pc, #0x54]
  0004c	e0833002	 add         r3, r3, r2
  00050	e5902000	 ldr         r2, [r0]
  00054	e5933000	 ldr         r3, [r3]
  00058	e1120003	 tst         r2, r3
  0005c	0a000009	 beq         |$LN2@OALTimerSe|

; 182  : 		if(i++>TIMER_POSTED_TIMEOUT) 

  00060	e59d3000	 ldr         r3, [sp]
  00064	e3530ffa	 cmp         r3, #0xFA, 30
  00068	e59d3000	 ldr         r3, [sp]
  0006c	e2833001	 add         r3, r3, #1
  00070	e58d3000	 str         r3, [sp]
  00074	9a000002	 bls         |$LN1@OALTimerSe|

; 183  : 		{
; 184  : 		    RETAILMSG(1, (L"\r\n OALTimerSetReg: wait timeout"));

  00078	e59f0020	 ldr         r0, [pc, #0x20]
  0007c	eb000000	 bl          NKDbgPrintfW

; 185  : 		    break;

  00080	ea000000	 b           |$LN2@OALTimerSe|
  00084		 |$LN1@OALTimerSe|

; 186  : 	       }

  00084	eaffffe7	 b           |$LN3@OALTimerSe|
  00088		 |$LN2@OALTimerSe|
  00088		 |$LN4@OALTimerSe|

; 187  :     OUTREG32(addr, val);

  00088	e59d2010	 ldr         r2, [sp, #0x10]
  0008c	e59d300c	 ldr         r3, [sp, #0xC]
  00090	e5832000	 str         r2, [r3]

; 188  : }

  00094	e28dd004	 add         sp, sp, #4
  00098	e89d6000	 ldmia       sp, {sp, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN10@OALTimerSe|
  000a0		 |$LN11@OALTimerSe|
  000a0	00000000	 DCD         |??_C@_1EA@OPCPFCAE@?$AA?$AN?$AA?6?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAS?$AAe?$AAt?$AAR?$AAe?$AAg?$AA?3?$AA?5?$AAw?$AAa?$AAi?$AAt?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
  000a4		 |$LN12@OALTimerSe|
  000a4	00000000	 DCD         |timer_posted_pending_bit|
  000a8		 |$LN13@OALTimerSe|
  000a8	00000000	 DCD         |g_pTimerRegs|
  000ac		 |$LN14@OALTimerSe|
  000ac	00000000	 DCD         |g_oalTimerContext|
  000b0		 |$M45990|

			 ENDP  ; |OALTimerSetReg|

	EXPORT	|OALTimerStop|

  00008			 AREA	 |.pdata|, PDATA
|$T46004| DCD	|$LN5@OALTimerSt@2|
	DCD	0x40001202
; Function compile flags: /Odtp

  000dc			 AREA	 |.text|, CODE, ARM

  000dc		 |OALTimerStop| PROC

; 222  : {

  000dc		 |$LN5@OALTimerSt@2|
  000dc	e52de004	 str         lr, [sp, #-4]!
  000e0	e24dd004	 sub         sp, sp, #4
  000e4		 |$M46001|

; 223  :     // stop GPTIMER1
; 224  :     OALTimerSetReg(&g_pTimerRegs->TCLR, OALTimerGetReg(&g_pTimerRegs->TCLR) & ~(GPTIMER_TCLR_ST));

  000e4	e59f3034	 ldr         r3, [pc, #0x34]
  000e8	e5933000	 ldr         r3, [r3]
  000ec	e2830024	 add         r0, r3, #0x24
  000f0	eb000000	 bl          OALTimerGetReg
  000f4	e58d0000	 str         r0, [sp]
  000f8	e59d2000	 ldr         r2, [sp]
  000fc	e3e03001	 mvn         r3, #1
  00100	e0021003	 and         r1, r2, r3
  00104	e59f3014	 ldr         r3, [pc, #0x14]
  00108	e5933000	 ldr         r3, [r3]
  0010c	e2830024	 add         r0, r3, #0x24
  00110	eb000000	 bl          OALTimerSetReg

; 225  : }

  00114	e28dd004	 add         sp, sp, #4
  00118	e49de004	 ldr         lr, [sp], #4
  0011c	e12fff1e	 bx          lr
  00120		 |$LN6@OALTimerSt@2|
  00120		 |$LN7@OALTimerSt@2|
  00120	00000000	 DCD         |g_pTimerRegs|
  00124		 |$M46002|

			 ENDP  ; |OALTimerStop|

	EXPORT	|OALTimerSetCompare|
	EXPORT	|OALTimerGetCount|
	EXPORT	|OALGetTickCount|
	EXPORT	|UpdatePeriod|
	IMPORT	|__rt_udiv64by64|

  00010			 AREA	 |.pdata|, PDATA
|$T46014| DCD	|$LN8@UpdatePeri|
	DCD	0x40004e04
; Function compile flags: /Odtp

  00124			 AREA	 |.text|, CODE, ARM

  00124		 |UpdatePeriod| PROC

; 258  : {

  00124		 |$LN8@UpdatePeri|
  00124	e1a0c00d	 mov         r12, sp
  00128	e92d0001	 stmdb       sp!, {r0}
  0012c	e92d5000	 stmdb       sp!, {r12, lr}
  00130	e24dd034	 sub         sp, sp, #0x34
  00134		 |$M46011|

; 259  :     UINT32 period, match;
; 260  :     INT32 delta;
; 261  :     UINT64 offsetMSec = periodMSec;

  00134	e59d303c	 ldr         r3, [sp, #0x3C]
  00138	e58d3000	 str         r3, [sp]
  0013c	e3a03000	 mov         r3, #0
  00140	e58d3004	 str         r3, [sp, #4]

; 262  :     UINT64 tickCount = OALGetTickCount();

  00144	eb000000	 bl          OALGetTickCount
  00148	e58d0020	 str         r0, [sp, #0x20]
  0014c	e59d3020	 ldr         r3, [sp, #0x20]
  00150	e58d3014	 str         r3, [sp, #0x14]
  00154	e3a03000	 mov         r3, #0
  00158	e58d3018	 str         r3, [sp, #0x18]

; 263  :     INT nDelay;
; 264  : 
; 265  :     // Calculate count difference
; 266  :     period = (UINT32)MSEC_TO_TICK(offsetMSec);

  0015c	e59d2000	 ldr         r2, [sp]
  00160	e59d3004	 ldr         r3, [sp, #4]
  00164	e58d2024	 str         r2, [sp, #0x24]
  00168	e1a01603	 mov         r1, r3, lsl #12
  0016c	e59d3024	 ldr         r3, [sp, #0x24]
  00170	e1a02a23	 mov         r2, r3, lsr #20
  00174	e59d3024	 ldr         r3, [sp, #0x24]
  00178	e1a00603	 mov         r0, r3, lsl #12
  0017c	e1811002	 orr         r1, r1, r2
  00180	e3a0207d	 mov         r2, #0x7D
  00184	e3a03000	 mov         r3, #0
  00188	eb000000	 bl          __rt_udiv64by64
  0018c	e2803001	 add         r3, r0, #1
  00190	e58d3008	 str         r3, [sp, #8]

; 267  : 
; 268  :     nDelay = min(period, DELTA_TIME);

  00194	e59d3008	 ldr         r3, [sp, #8]
  00198	e3530014	 cmp         r3, #0x14
  0019c	2a000002	 bcs         |$LN4@UpdatePeri|
  001a0	e59d3008	 ldr         r3, [sp, #8]
  001a4	e58d3028	 str         r3, [sp, #0x28]
  001a8	ea000001	 b           |$LN5@UpdatePeri|
  001ac		 |$LN4@UpdatePeri|
  001ac	e3a03014	 mov         r3, #0x14
  001b0	e58d3028	 str         r3, [sp, #0x28]
  001b4		 |$LN5@UpdatePeri|
  001b4	e59d3028	 ldr         r3, [sp, #0x28]
  001b8	e58d3010	 str         r3, [sp, #0x10]

; 269  :     // This is compare value
; 270  :     match = ((UINT32)MSEC_TO_TICK(tickCount)) + nDelay;

  001bc	e59d2014	 ldr         r2, [sp, #0x14]
  001c0	e59d3018	 ldr         r3, [sp, #0x18]
  001c4	e58d202c	 str         r2, [sp, #0x2C]
  001c8	e1a01603	 mov         r1, r3, lsl #12
  001cc	e59d302c	 ldr         r3, [sp, #0x2C]
  001d0	e1a02a23	 mov         r2, r3, lsr #20
  001d4	e59d302c	 ldr         r3, [sp, #0x2C]
  001d8	e1a00603	 mov         r0, r3, lsl #12
  001dc	e1811002	 orr         r1, r1, r2
  001e0	e3a0207d	 mov         r2, #0x7D
  001e4	e3a03000	 mov         r3, #0
  001e8	eb000000	 bl          __rt_udiv64by64
  001ec	e2802001	 add         r2, r0, #1
  001f0	e59d3010	 ldr         r3, [sp, #0x10]
  001f4	e0823003	 add         r3, r2, r3
  001f8	e58d300c	 str         r3, [sp, #0xC]

; 271  : 
; 272  :     delta = (INT32)(OALTimerGetCount()+ g_oalTimerContext.margin - match);

  001fc	eb000000	 bl          OALTimerGetCount
  00200	e58d0030	 str         r0, [sp, #0x30]
  00204	e59d2030	 ldr         r2, [sp, #0x30]
  00208	e59f3048	 ldr         r3, [pc, #0x48]
  0020c	e5933004	 ldr         r3, [r3, #4]
  00210	e0822003	 add         r2, r2, r3
  00214	e59d300c	 ldr         r3, [sp, #0xC]
  00218	e0423003	 sub         r3, r2, r3
  0021c	e58d301c	 str         r3, [sp, #0x1C]

; 273  : 
; 274  :     // If we are behind, issue interrupt as soon as possible
; 275  :     if (delta > 0)

  00220	e59d301c	 ldr         r3, [sp, #0x1C]
  00224	e3530000	 cmp         r3, #0
  00228	da000002	 ble         |$LN1@UpdatePeri|

; 276  :     {
; 277  :         match += MSEC_TO_TICK(1);

  0022c	e59d300c	 ldr         r3, [sp, #0xC]
  00230	e2833021	 add         r3, r3, #0x21
  00234	e58d300c	 str         r3, [sp, #0xC]
  00238		 |$LN1@UpdatePeri|

; 278  :     }
; 279  : 
; 280  :     // Save off match value
; 281  :     g_oalTimerContext.match = match;

  00238	e59d200c	 ldr         r2, [sp, #0xC]
  0023c	e59f3014	 ldr         r3, [pc, #0x14]
  00240	e5832014	 str         r2, [r3, #0x14]

; 282  : 
; 283  :     // Set timer match value
; 284  :     OALTimerSetCompare(match);

  00244	e59d000c	 ldr         r0, [sp, #0xC]
  00248	eb000000	 bl          OALTimerSetCompare

; 285  : }

  0024c	e28dd034	 add         sp, sp, #0x34
  00250	e89d6000	 ldmia       sp, {sp, lr}
  00254	e12fff1e	 bx          lr
  00258		 |$LN9@UpdatePeri|
  00258		 |$LN10@UpdatePeri|
  00258	00000000	 DCD         |g_oalTimerContext|
  0025c		 |$M46012|

			 ENDP  ; |UpdatePeriod|


  00000			 AREA	 |.pdata|, PDATA
|$T46021| DCD	|$LN6@OALTimerSe@2|
	DCD	0x40001804
; Function compile flags: /Odtp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALTimerSetCompare| PROC

; 232  : {

  00000		 |$LN6@OALTimerSe@2|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0001	 stmdb       sp!, {r0}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M46018|

; 233  : 
; 234  :     OALTimerSetReg(&g_pTimerRegs->TMAR, compare);

  00010	e59d100c	 ldr         r1, [sp, #0xC]
  00014	e59f3040	 ldr         r3, [pc, #0x40]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e2830038	 add         r0, r3, #0x38
  00020	eb000000	 bl          OALTimerSetReg

; 235  : 
; 236  : 	// We commented out the following line because it causes issues to the overall performance
; 237  : 	// of the system. As the tick timer is clocked at 32 kHz, the TMAR register takes some 
; 238  : 	// time to update and we loose this time waiting for it. The consequence is that we spend
; 239  : 	// more than 5% of the time in this loop where the CPU should actually be idle. Not waiting
; 240  : 	// should not have any consequence as we never actually read its value.
; 241  : 	//
; 242  :     //while ((INREG32(&g_pTimerRegs->TWPS) & GPTIMER_TWPS_TMAR) != 0);
; 243  : 
; 244  :     // make sure we don't set next timer interrupt to the past
; 245  :     //
; 246  :     if (compare < OALTimerGetReg(&g_pTimerRegs->TCRR)) UpdatePeriod(1);

  00024	e59f3030	 ldr         r3, [pc, #0x30]
  00028	e5933000	 ldr         r3, [r3]
  0002c	e2830028	 add         r0, r3, #0x28
  00030	eb000000	 bl          OALTimerGetReg
  00034	e58d0000	 str         r0, [sp]
  00038	e59d200c	 ldr         r2, [sp, #0xC]
  0003c	e59d3000	 ldr         r3, [sp]
  00040	e1520003	 cmp         r2, r3
  00044	2a000001	 bcs         |$LN1@OALTimerSe@2|
  00048	e3a00001	 mov         r0, #1
  0004c	eb000000	 bl          UpdatePeriod
  00050		 |$LN1@OALTimerSe@2|

; 247  : }

  00050	e28dd004	 add         sp, sp, #4
  00054	e89d6000	 ldmia       sp, {sp, lr}
  00058	e12fff1e	 bx          lr
  0005c		 |$LN7@OALTimerSe@2|
  0005c		 |$LN8@OALTimerSe@2|
  0005c	00000000	 DCD         |g_pTimerRegs|
  00060		 |$M46019|

			 ENDP  ; |OALTimerSetCompare|

	EXPORT	|OEMIdle|
	IMPORT	|g_pNKGlobal|
	IMPORT	|PrcmProfilePrevPowerState|
	IMPORT	|PrcmProcessPostMpuWakeup|
	IMPORT	|PrcmCapturePrevPowerState|
	IMPORT	|OALWakeupLatency_PopState|
	IMPORT	|fnOALCPUIdle|
	IMPORT	|g_pCPUInfo|
	IMPORT	|OALWakeupLatency_PushState|
	IMPORT	|OALContextSave|
	IMPORT	|OALWakeupLatency_IsChipOff|
	IMPORT	|OEMWriteDebugLED|
	IMPORT	|OALWakeupLatency_FindStateByMaxDelayInTicks|
	IMPORT	|OALWakeupLatency_GetDelayInTicks|
	IMPORT	|OALWakeupLatency_GetCurrentState|
	IMPORT	|PrcmInitializePrevPowerState|

  00018			 AREA	 |.pdata|, PDATA
|$T46032| DCD	|$LN17@OEMIdle|
	DCD	0x4000ae04
; Function compile flags: /Odtp

  0025c			 AREA	 |.text|, CODE, ARM

  0025c		 |OEMIdle| PROC

; 311  : {

  0025c		 |$LN17@OEMIdle|
  0025c	e1a0c00d	 mov         r12, sp
  00260	e92d0001	 stmdb       sp!, {r0}
  00264	e92d5000	 stmdb       sp!, {r12, lr}
  00268	e24dd050	 sub         sp, sp, #0x50
  0026c		 |$M46029|

; 312  :     static UINT _max = 0;
; 313  :     static UINT _count = 0;
; 314  : 
; 315  :     INT delta;
; 316  :     UINT tcrrTemp;
; 317  :     UINT tcrrEnter, tcrrExit;
; 318  :     UINT idleDelta, newIdleLow;
; 319  :     INT wakeupDelay;
; 320  :     INT maxDelay;
; 321  :     DWORD latencyState;    
; 322  : 
; 323  :     UNREFERENCED_PARAMETER(idleParam);
; 324  : 
; 325  :     PrcmInitializePrevPowerState();

  0026c	eb000000	 bl          PrcmInitializePrevPowerState

; 326  : 
; 327  :     // How far are we from next timer interrupt
; 328  :     // If we are really near to timer interrupt do nothing...
; 329  :     latencyState = OALWakeupLatency_GetCurrentState();

  00270	eb000000	 bl          OALWakeupLatency_GetCurrentState
  00274	e58d0024	 str         r0, [sp, #0x24]
  00278	e59d3024	 ldr         r3, [sp, #0x24]
  0027c	e58d301c	 str         r3, [sp, #0x1C]

; 330  :     tcrrEnter = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00280	e59f3278	 ldr         r3, [pc, #0x278]
  00284	e5933000	 ldr         r3, [r3]
  00288	e2830028	 add         r0, r3, #0x28
  0028c	eb000000	 bl          OALTimerGetReg
  00290	e58d0028	 str         r0, [sp, #0x28]
  00294	e59d3028	 ldr         r3, [sp, #0x28]
  00298	e58d3014	 str         r3, [sp, #0x14]

; 331  :     delta = g_oalTimerContext.match - tcrrEnter;

  0029c	e59f3268	 ldr         r3, [pc, #0x268]
  002a0	e5932014	 ldr         r2, [r3, #0x14]
  002a4	e59d3014	 ldr         r3, [sp, #0x14]
  002a8	e0423003	 sub         r3, r2, r3
  002ac	e58d3018	 str         r3, [sp, #0x18]

; 332  :     if (delta < (INT32)g_oalTimerContext.margin) goto cleanUp;

  002b0	e59d2018	 ldr         r2, [sp, #0x18]
  002b4	e59f3250	 ldr         r3, [pc, #0x250]
  002b8	e5933004	 ldr         r3, [r3, #4]
  002bc	e1520003	 cmp         r2, r3
  002c0	aa000000	 bge         |$LN10@OEMIdle|
  002c4	ea000086	 b           |$cleanUp$45872|
  002c8		 |$LN10@OEMIdle|

; 333  : 
; 334  :     // get latency time...
; 335  :     //
; 336  :     // check if current latency is greater than current requirements
; 337  :     maxDelay = min(delta, g_wakeupLatencyConstraintTickCount);

  002c8	e59d2018	 ldr         r2, [sp, #0x18]
  002cc	e59f323c	 ldr         r3, [pc, #0x23C]
  002d0	e5933000	 ldr         r3, [r3]
  002d4	e1520003	 cmp         r2, r3
  002d8	aa000002	 bge         |$LN13@OEMIdle|
  002dc	e59d3018	 ldr         r3, [sp, #0x18]
  002e0	e58d302c	 str         r3, [sp, #0x2C]
  002e4	ea000002	 b           |$LN14@OEMIdle|
  002e8		 |$LN13@OEMIdle|
  002e8	e59f3220	 ldr         r3, [pc, #0x220]
  002ec	e5933000	 ldr         r3, [r3]
  002f0	e58d302c	 str         r3, [sp, #0x2C]
  002f4		 |$LN14@OEMIdle|
  002f4	e59d302c	 ldr         r3, [sp, #0x2C]
  002f8	e58d3010	 str         r3, [sp, #0x10]

; 338  :     wakeupDelay = OALWakeupLatency_GetDelayInTicks(latencyState);

  002fc	e59d001c	 ldr         r0, [sp, #0x1C]
  00300	eb000000	 bl          OALWakeupLatency_GetDelayInTicks
  00304	e58d0030	 str         r0, [sp, #0x30]
  00308	e59d3030	 ldr         r3, [sp, #0x30]
  0030c	e58d3004	 str         r3, [sp, #4]

; 339  :     if (maxDelay < wakeupDelay)

  00310	e59d2010	 ldr         r2, [sp, #0x10]
  00314	e59d3004	 ldr         r3, [sp, #4]
  00318	e1520003	 cmp         r2, r3
  0031c	aa000009	 bge         |$LN9@OEMIdle|

; 340  :     {
; 341  :         // check if current state meets timing constraint
; 342  :         latencyState = OALWakeupLatency_FindStateByMaxDelayInTicks(maxDelay);

  00320	e59d0010	 ldr         r0, [sp, #0x10]
  00324	eb000000	 bl          OALWakeupLatency_FindStateByMaxDelayInTicks
  00328	e58d0034	 str         r0, [sp, #0x34]
  0032c	e59d3034	 ldr         r3, [sp, #0x34]
  00330	e58d301c	 str         r3, [sp, #0x1C]

; 343  :         wakeupDelay = OALWakeupLatency_GetDelayInTicks(latencyState);

  00334	e59d001c	 ldr         r0, [sp, #0x1C]
  00338	eb000000	 bl          OALWakeupLatency_GetDelayInTicks
  0033c	e58d0038	 str         r0, [sp, #0x38]
  00340	e59d3038	 ldr         r3, [sp, #0x38]
  00344	e58d3004	 str         r3, [sp, #4]
  00348		 |$LN9@OEMIdle|

; 344  :     }
; 345  : 
; 346  :     // check one last time to make sure we aren't going to sleep longer than
; 347  :     if (maxDelay >= wakeupDelay)

  00348	e59d2010	 ldr         r2, [sp, #0x10]
  0034c	e59d3004	 ldr         r3, [sp, #4]
  00350	e1520003	 cmp         r2, r3
  00354	ba00001a	 blt         |$LN8@OEMIdle|

; 348  :     {
; 349  :         //  Indicate in idle
; 350  :         OALLED(LED_IDX_IDLE, 1);

  00358	e3a01001	 mov         r1, #1
  0035c	e3a0001e	 mov         r0, #0x1E
  00360	eb000000	 bl          OEMWriteDebugLED

; 351  :         
; 352  :         if (OALWakeupLatency_IsChipOff(latencyState))

  00364	e59d001c	 ldr         r0, [sp, #0x1C]
  00368	eb000000	 bl          OALWakeupLatency_IsChipOff
  0036c	e58d003c	 str         r0, [sp, #0x3C]
  00370	e59d303c	 ldr         r3, [sp, #0x3C]
  00374	e3530000	 cmp         r3, #0
  00378	0a000005	 beq         |$LN7@OEMIdle|

; 353  :         {
; 354  :             if (!OALContextSave())

  0037c	eb000000	 bl          OALContextSave
  00380	e58d0040	 str         r0, [sp, #0x40]
  00384	e59d3040	 ldr         r3, [sp, #0x40]
  00388	e3530000	 cmp         r3, #0
  0038c	1a000000	 bne         |$LN6@OEMIdle|

; 355  :             {
; 356  :                 // Context Save Failed
; 357  :                 goto cleanUp;

  00390	ea000053	 b           |$cleanUp$45872|
  00394		 |$LN6@OEMIdle|
  00394		 |$LN7@OEMIdle|

; 358  :             }
; 359  :         }
; 360  :         // account for wakeup latency
; 361  :         OALWakeupLatency_PushState(latencyState);

  00394	e59d001c	 ldr         r0, [sp, #0x1C]
  00398	eb000000	 bl          OALWakeupLatency_PushState

; 362  :         g_oalTimerContext.match -= wakeupDelay;

  0039c	e59f3168	 ldr         r3, [pc, #0x168]
  003a0	e5932014	 ldr         r2, [r3, #0x14]
  003a4	e59d3004	 ldr         r3, [sp, #4]
  003a8	e0422003	 sub         r2, r2, r3
  003ac	e59f3158	 ldr         r3, [pc, #0x158]
  003b0	e5832014	 str         r2, [r3, #0x14]

; 363  :         OALTimerSetCompare(g_oalTimerContext.match);

  003b4	e59f3150	 ldr         r3, [pc, #0x150]
  003b8	e5930014	 ldr         r0, [r3, #0x14]
  003bc	eb000000	 bl          OALTimerSetCompare

; 364  :     }
; 365  :     else

  003c0	ea000000	 b           |$LN5@OEMIdle|
  003c4		 |$LN8@OEMIdle|

; 366  :     {
; 367  :         goto cleanUp;

  003c4	ea000046	 b           |$cleanUp$45872|
  003c8		 |$LN5@OEMIdle|

; 368  :     }
; 369  : 
; 370  :     // Move SoC/CPU to idle mode    
; 371  :     fnOALCPUIdle(g_pCPUInfo);

  003c8	e59f3138	 ldr         r3, [pc, #0x138]
  003cc	e5930000	 ldr         r0, [r3]
  003d0	e59f312c	 ldr         r3, [pc, #0x12C]
  003d4	e5933000	 ldr         r3, [r3]
  003d8	e1a0e00f	 mov         lr, pc
  003dc	e12fff13	 bx          r3

; 372  :     
; 373  :     // restore latency state
; 374  :     OALWakeupLatency_PopState();

  003e0	eb000000	 bl          OALWakeupLatency_PopState

; 375  :     
; 376  :     PrcmCapturePrevPowerState();

  003e4	eb000000	 bl          PrcmCapturePrevPowerState

; 377  : 
; 378  :     // get current TCRR value: workaround for errata 1.35
; 379  :     OALTimerGetReg(&g_pTimerRegs->TCRR);

  003e8	e59f3110	 ldr         r3, [pc, #0x110]
  003ec	e5933000	 ldr         r3, [r3]
  003f0	e2830028	 add         r0, r3, #0x28
  003f4	eb000000	 bl          OALTimerGetReg

; 380  :     tcrrExit = OALTimerGetReg(&g_pTimerRegs->TCRR);

  003f8	e59f3100	 ldr         r3, [pc, #0x100]
  003fc	e5933000	 ldr         r3, [r3]
  00400	e2830028	 add         r0, r3, #0x28
  00404	eb000000	 bl          OALTimerGetReg
  00408	e58d0044	 str         r0, [sp, #0x44]
  0040c	e59d3044	 ldr         r3, [sp, #0x44]
  00410	e58d3020	 str         r3, [sp, #0x20]

; 381  : 
; 382  :     PrcmProcessPostMpuWakeup();

  00414	eb000000	 bl          PrcmProcessPostMpuWakeup
  00418		 |$LN4@OEMIdle|

; 383  : 
; 384  :     // ERRATA 1.31 workaround
; 385  :     do
; 386  :     {
; 387  :         tcrrTemp = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00418	e59f30e0	 ldr         r3, [pc, #0xE0]
  0041c	e5933000	 ldr         r3, [r3]
  00420	e2830028	 add         r0, r3, #0x28
  00424	eb000000	 bl          OALTimerGetReg
  00428	e58d0048	 str         r0, [sp, #0x48]
  0042c	e59d3048	 ldr         r3, [sp, #0x48]
  00430	e58d3008	 str         r3, [sp, #8]

; 388  :     }
; 389  :     while (tcrrTemp == tcrrExit);

  00434	e59d2008	 ldr         r2, [sp, #8]
  00438	e59d3020	 ldr         r3, [sp, #0x20]
  0043c	e1520003	 cmp         r2, r3
  00440	0afffff4	 beq         |$LN4@OEMIdle|

; 390  : 
; 391  :     PrcmProfilePrevPowerState(tcrrTemp, wakeupDelay);

  00444	e59d1004	 ldr         r1, [sp, #4]
  00448	e59d0008	 ldr         r0, [sp, #8]
  0044c	eb000000	 bl          PrcmProfilePrevPowerState

; 392  : 
; 393  :     // Update idle counter
; 394  :     idleDelta = OALTimerGetReg(&g_pTimerRegs->TCRR) - tcrrEnter;

  00450	e59f30a8	 ldr         r3, [pc, #0xA8]
  00454	e5933000	 ldr         r3, [r3]
  00458	e2830028	 add         r0, r3, #0x28
  0045c	eb000000	 bl          OALTimerGetReg
  00460	e58d004c	 str         r0, [sp, #0x4C]
  00464	e59d204c	 ldr         r2, [sp, #0x4C]
  00468	e59d3014	 ldr         r3, [sp, #0x14]
  0046c	e0423003	 sub         r3, r2, r3
  00470	e58d3000	 str         r3, [sp]

; 395  :     newIdleLow = curridlelow + idleDelta;

  00474	e59f3080	 ldr         r3, [pc, #0x80]
  00478	e5933000	 ldr         r3, [r3]
  0047c	e28330d0	 add         r3, r3, #0xD0
  00480	e5932000	 ldr         r2, [r3]
  00484	e59d3000	 ldr         r3, [sp]
  00488	e0823003	 add         r3, r2, r3
  0048c	e58d300c	 str         r3, [sp, #0xC]

; 396  :     if (newIdleLow < curridlelow) 

  00490	e59f3064	 ldr         r3, [pc, #0x64]
  00494	e5933000	 ldr         r3, [r3]
  00498	e28330d0	 add         r3, r3, #0xD0
  0049c	e5932000	 ldr         r2, [r3]
  004a0	e59d300c	 ldr         r3, [sp, #0xC]
  004a4	e1530002	 cmp         r3, r2
  004a8	2a000008	 bcs         |$LN1@OEMIdle|

; 397  : 	    curridlehigh++;

  004ac	e59f3048	 ldr         r3, [pc, #0x48]
  004b0	e5933000	 ldr         r3, [r3]
  004b4	e28330d4	 add         r3, r3, #0xD4
  004b8	e5933000	 ldr         r3, [r3]
  004bc	e2832001	 add         r2, r3, #1
  004c0	e59f3034	 ldr         r3, [pc, #0x34]
  004c4	e5933000	 ldr         r3, [r3]
  004c8	e28330d4	 add         r3, r3, #0xD4
  004cc	e5832000	 str         r2, [r3]
  004d0		 |$LN1@OEMIdle|

; 398  :     curridlelow = newIdleLow;

  004d0	e59f3024	 ldr         r3, [pc, #0x24]
  004d4	e5933000	 ldr         r3, [r3]
  004d8	e28320d0	 add         r2, r3, #0xD0
  004dc	e59d300c	 ldr         r3, [sp, #0xC]
  004e0	e5823000	 str         r3, [r2]
  004e4		 |$cleanUp$45872|

; 399  : 
; 400  : cleanUp:
; 401  :     OALLED(LED_IDX_IDLE, 0);

  004e4	e3a01000	 mov         r1, #0
  004e8	e3a0001e	 mov         r0, #0x1E
  004ec	eb000000	 bl          OEMWriteDebugLED

; 402  :     return;    
; 403  : }

  004f0	e28dd050	 add         sp, sp, #0x50
  004f4	e89d6000	 ldmia       sp, {sp, lr}
  004f8	e12fff1e	 bx          lr
  004fc		 |$LN18@OEMIdle|
  004fc		 |$LN19@OEMIdle|
  004fc	00000000	 DCD         |g_pNKGlobal|
  00500		 |$LN20@OEMIdle|
  00500	00000000	 DCD         |g_pTimerRegs|
  00504		 |$LN21@OEMIdle|
  00504	00000000	 DCD         |fnOALCPUIdle|
  00508		 |$LN22@OEMIdle|
  00508	00000000	 DCD         |g_pCPUInfo|
  0050c		 |$LN23@OEMIdle|
  0050c	00000000	 DCD         |g_oalTimerContext|
  00510		 |$LN24@OEMIdle|
  00510	00000000	 DCD         |g_wakeupLatencyConstraintTickCount|
  00514		 |$M46030|

			 ENDP  ; |OEMIdle|

	EXPORT	|??_C@_1DC@BNLGCJKD@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@| [ DATA ] ; `string'
	EXPORT	|OALTimerUpdateRescheduleTime|
	EXPORT	|??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|OALTimerInit|
	IMPORT	|OEMInterruptEnable|
	IMPORT	|OALIntrRequestSysIntr|
	IMPORT	|g_oalTimerIrq|
	IMPORT	|GetIrqByDevice|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|BSPGetSysTimer32KClock|
	IMPORT	|OALPAtoVA|
	IMPORT	|GetAddressByDevice|
	IMPORT	|BSPGetSysTimerDevice|
	IMPORT	|g_pOemGlobal|
	IMPORT	|dwOEMMaxIdlePeriod|
	IMPORT	|dpCurSettings|

  00020			 AREA	 |.pdata|, PDATA
|$T46051| DCD	|$LN14@OALTimerIn|
	DCD	0x4000d804

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@BNLGCJKD@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, "r", 0x0, "c", 0x0, " ", 0x0, "=", 0x0, " "
	DCB	0x0, "%", 0x0, "d", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, "r", 0x0, "u", 0x0, "p", 0x0, "t", 0x0, " "
	DCB	0x0, "e", 0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e"
	DCB	0x0, " ", 0x0, "f", 0x0, "o", 0x0, "r", 0x0, " ", 0x0, "s"
	DCB	0x0, "y", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "m", 0x0, " "
	DCB	0x0, "t", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d"
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, "i", 0x0, "m"
	DCB	0x0, "e", 0x0, "r", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, "%", 0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%"
	DCB	0x0, "d", 0x0, ",", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Odtp

  00514			 AREA	 |.text|, CODE, ARM

  00514		 |OALTimerInit| PROC

; 418  : {

  00514		 |$LN14@OALTimerIn|
  00514	e1a0c00d	 mov         r12, sp
  00518	e92d0007	 stmdb       sp!, {r0 - r2}
  0051c	e92d5000	 stmdb       sp!, {r12, lr}
  00520	e24dd03c	 sub         sp, sp, #0x3C
  00524		 |$M46048|

; 419  :     BOOL rc = FALSE;

  00524	e3a03000	 mov         r3, #0
  00528	e58d3004	 str         r3, [sp, #4]

; 420  :     UINT srcClock;
; 421  :     UINT32 sysIntr;
; 422  : 
; 423  : 	UNREFERENCED_PARAMETER(sysTickMSec);
; 424  : 	UNREFERENCED_PARAMETER(countsPerMSec);
; 425  : 	UNREFERENCED_PARAMETER(countsMargin);
; 426  : 
; 427  :     OALMSG(OAL_TIMER&&OAL_FUNC, (
; 428  :         L"+OALTimerInit(%d, %d, %d)\r\n", sysTickMSec, countsPerMSec,
; 429  :         countsMargin
; 430  :         ));

  0052c	e59f3314	 ldr         r3, [pc, #0x314]
  00530	e5933440	 ldr         r3, [r3, #0x440]
  00534	e3130b02	 tst         r3, #2, 22
  00538	0a00000b	 beq         |$LN6@OALTimerIn|
  0053c	e59f3304	 ldr         r3, [pc, #0x304]
  00540	e5933440	 ldr         r3, [r3, #0x440]
  00544	e3130004	 tst         r3, #4
  00548	0a000007	 beq         |$LN6@OALTimerIn|
  0054c	e59d304c	 ldr         r3, [sp, #0x4C]
  00550	e59d2048	 ldr         r2, [sp, #0x48]
  00554	e59d1044	 ldr         r1, [sp, #0x44]
  00558	e59f0310	 ldr         r0, [pc, #0x310]
  0055c	eb000000	 bl          NKDbgPrintfW
  00560	e3a03001	 mov         r3, #1
  00564	e58d3010	 str         r3, [sp, #0x10]
  00568	ea000001	 b           |$LN7@OALTimerIn|
  0056c		 |$LN6@OALTimerIn|
  0056c	e3a03000	 mov         r3, #0
  00570	e58d3010	 str         r3, [sp, #0x10]
  00574		 |$LN7@OALTimerIn|

; 431  : 
; 432  :     //  Initialize timer state information
; 433  :     g_oalTimerContext.maxPeriodMSec = dwOEMMaxIdlePeriod;   // Maximum period the timer will interrupt on, in mSec

  00574	e59f32f0	 ldr         r3, [pc, #0x2F0]
  00578	e5932000	 ldr         r2, [r3]
  0057c	e59f32c8	 ldr         r3, [pc, #0x2C8]
  00580	e5832000	 str         r2, [r3]

; 434  :     g_oalTimerContext.margin =        DELTA_TIME;           // Time needed to reprogram the timer interrupt

  00584	e59f22c0	 ldr         r2, [pc, #0x2C0]
  00588	e3a03014	 mov         r3, #0x14
  0058c	e5823004	 str         r3, [r2, #4]

; 435  :     g_oalTimerContext.curCounts =     0;

  00590	e59f22b4	 ldr         r2, [pc, #0x2B4]
  00594	e3a03000	 mov         r3, #0
  00598	e5823008	 str         r3, [r2, #8]
  0059c	e59f22a8	 ldr         r2, [pc, #0x2A8]
  005a0	e3a03000	 mov         r3, #0
  005a4	e582300c	 str         r3, [r2, #0xC]

; 436  :     g_oalTimerContext.base =          0;

  005a8	e59f229c	 ldr         r2, [pc, #0x29C]
  005ac	e3a03000	 mov         r3, #0
  005b0	e5823010	 str         r3, [r2, #0x10]

; 437  :     g_oalTimerContext.match =         0xFFFFFFFF;

  005b4	e59f2290	 ldr         r2, [pc, #0x290]
  005b8	e3e03000	 mvn         r3, #0
  005bc	e5823014	 str         r3, [r2, #0x14]

; 438  :     g_oalTimerContext.Posted =       0;

  005c0	e59f2284	 ldr         r2, [pc, #0x284]
  005c4	e3a03000	 mov         r3, #0
  005c8	e5823018	 str         r3, [r2, #0x18]

; 439  : 
; 440  :     // Set idle conversion constant and counters
; 441  :     idleconv     = MSEC_TO_TICK(1);

  005cc	e59f3294	 ldr         r3, [pc, #0x294]
  005d0	e5933000	 ldr         r3, [r3]
  005d4	e28320d8	 add         r2, r3, #0xD8
  005d8	e3a03021	 mov         r3, #0x21
  005dc	e5823000	 str         r3, [r2]

; 442  :     curridlehigh = 0;

  005e0	e59f3280	 ldr         r3, [pc, #0x280]
  005e4	e5933000	 ldr         r3, [r3]
  005e8	e28320d4	 add         r2, r3, #0xD4
  005ec	e3a03000	 mov         r3, #0
  005f0	e5823000	 str         r3, [r2]

; 443  :     curridlelow  = 0;

  005f4	e59f326c	 ldr         r3, [pc, #0x26C]
  005f8	e5933000	 ldr         r3, [r3]
  005fc	e28320d0	 add         r2, r3, #0xD0
  00600	e3a03000	 mov         r3, #0
  00604	e5823000	 str         r3, [r2]

; 444  : 
; 445  :     // Use variable system tick
; 446  :     pOEMUpdateRescheduleTime = OALTimerUpdateRescheduleTime;

  00608	e59f3254	 ldr         r3, [pc, #0x254]
  0060c	e5933000	 ldr         r3, [r3]
  00610	e283204c	 add         r2, r3, #0x4C
  00614	e59f3244	 ldr         r3, [pc, #0x244]
  00618	e5823000	 str         r3, [r2]

; 447  : 
; 448  : // Get virtual addresses for hardware
; 449  :     g_TimerDevice = BSPGetSysTimerDevice();

  0061c	eb000000	 bl          BSPGetSysTimerDevice
  00620	e58d0014	 str         r0, [sp, #0x14]
  00624	e59d2014	 ldr         r2, [sp, #0x14]
  00628	e59f3228	 ldr         r3, [pc, #0x228]
  0062c	e5832000	 str         r2, [r3]

; 450  :     g_pTimerRegs = OALPAtoUA(GetAddressByDevice(g_TimerDevice));

  00630	e59f3220	 ldr         r3, [pc, #0x220]
  00634	e5930000	 ldr         r0, [r3]
  00638	eb000000	 bl          GetAddressByDevice
  0063c	e58d0018	 str         r0, [sp, #0x18]
  00640	e3a01000	 mov         r1, #0
  00644	e59d0018	 ldr         r0, [sp, #0x18]
  00648	eb000000	 bl          OALPAtoVA
  0064c	e58d001c	 str         r0, [sp, #0x1C]
  00650	e59d201c	 ldr         r2, [sp, #0x1C]
  00654	e59f3200	 ldr         r3, [pc, #0x200]
  00658	e5832000	 str         r2, [r3]

; 451  : 	
; 452  : 	// Select 32K frequency source clock
; 453  :     srcClock = BSPGetSysTimer32KClock();

  0065c	eb000000	 bl          BSPGetSysTimer32KClock
  00660	e58d0020	 str         r0, [sp, #0x20]
  00664	e59d3020	 ldr         r3, [sp, #0x20]
  00668	e58d3000	 str         r3, [sp]

; 454  : 	//PrcmDeviceSetSourceClocks(g_TimerDevice,1,&srcClock);
; 455  : 
; 456  :     // enable gptimer
; 457  :     EnableDeviceClocks(g_TimerDevice, TRUE);

  0066c	e3a01001	 mov         r1, #1
  00670	e59f31e0	 ldr         r3, [pc, #0x1E0]
  00674	e5930000	 ldr         r0, [r3]
  00678	eb000000	 bl          EnableDeviceClocks

; 458  : 
; 459  : 
; 460  :     // stop timer
; 461  :     OALTimerSetReg(&g_pTimerRegs->TCLR, 0);

  0067c	e3a01000	 mov         r1, #0
  00680	e59f31d4	 ldr         r3, [pc, #0x1D4]
  00684	e5933000	 ldr         r3, [r3]
  00688	e2830024	 add         r0, r3, #0x24
  0068c	eb000000	 bl          OALTimerSetReg

; 462  : 
; 463  :     // Soft reset GPTIMER
; 464  :     OALTimerSetReg(&g_pTimerRegs->TIOCP, SYSCONFIG_SOFTRESET);

  00690	e3a01002	 mov         r1, #2
  00694	e59f31c0	 ldr         r3, [pc, #0x1C0]
  00698	e5933000	 ldr         r3, [r3]
  0069c	e2830010	 add         r0, r3, #0x10
  006a0	eb000000	 bl          OALTimerSetReg
  006a4		 |$LN3@OALTimerIn|

; 465  : 
; 466  :     // While until done
; 467  :     while ((OALTimerGetReg(&g_pTimerRegs->TISTAT) & GPTIMER_TISTAT_RESETDONE) == 0);

  006a4	e59f31b0	 ldr         r3, [pc, #0x1B0]
  006a8	e5933000	 ldr         r3, [r3]
  006ac	e2830014	 add         r0, r3, #0x14
  006b0	eb000000	 bl          OALTimerGetReg
  006b4	e58d0024	 str         r0, [sp, #0x24]
  006b8	e59d3024	 ldr         r3, [sp, #0x24]
  006bc	e3130001	 tst         r3, #1
  006c0	1a000000	 bne         |$LN2@OALTimerIn|
  006c4	eafffff6	 b           |$LN3@OALTimerIn|
  006c8		 |$LN2@OALTimerIn|

; 468  : 
; 469  :     // Set smart idle
; 470  :     OALTimerSetReg(
; 471  :         &g_pTimerRegs->TIOCP,
; 472  :             SYSCONFIG_SMARTIDLE|SYSCONFIG_ENAWAKEUP|
; 473  :             SYSCONFIG_AUTOIDLE
; 474  :         );

  006c8	e3a01015	 mov         r1, #0x15
  006cc	e59f3188	 ldr         r3, [pc, #0x188]
  006d0	e5933000	 ldr         r3, [r3]
  006d4	e2830010	 add         r0, r3, #0x10
  006d8	eb000000	 bl          OALTimerSetReg

; 475  : 
; 476  :     // Enable posted mode
; 477  :     OALTimerSetReg(&g_pTimerRegs->TSICR, GPTIMER_TSICR_POSTED);

  006dc	e3a01004	 mov         r1, #4
  006e0	e59f3174	 ldr         r3, [pc, #0x174]
  006e4	e5933000	 ldr         r3, [r3]
  006e8	e2830040	 add         r0, r3, #0x40
  006ec	eb000000	 bl          OALTimerSetReg

; 478  :     g_oalTimerContext.Posted =       1;

  006f0	e59f2154	 ldr         r2, [pc, #0x154]
  006f4	e3a03001	 mov         r3, #1
  006f8	e5823018	 str         r3, [r2, #0x18]

; 479  : 
; 480  :     // Set match register to avoid unwanted interrupt
; 481  :     OALTimerSetReg(&g_pTimerRegs->TMAR, 0xFFFFFFFF);

  006fc	e3e01000	 mvn         r1, #0
  00700	e59f3154	 ldr         r3, [pc, #0x154]
  00704	e5933000	 ldr         r3, [r3]
  00708	e2830038	 add         r0, r3, #0x38
  0070c	eb000000	 bl          OALTimerSetReg

; 482  : 
; 483  :     // Enable match interrupt
; 484  :     OALTimerSetReg(&g_pTimerRegs->TIER, GPTIMER_TIER_MATCH);

  00710	e3a01001	 mov         r1, #1
  00714	e59f3140	 ldr         r3, [pc, #0x140]
  00718	e5933000	 ldr         r3, [r3]
  0071c	e283001c	 add         r0, r3, #0x1C
  00720	eb000000	 bl          OALTimerSetReg

; 485  : 
; 486  :     // Enable match wakeup
; 487  :     OALTimerSetReg(&g_pTimerRegs->TWER, GPTIMER_TWER_MATCH);

  00724	e3a01001	 mov         r1, #1
  00728	e59f312c	 ldr         r3, [pc, #0x12C]
  0072c	e5933000	 ldr         r3, [r3]
  00730	e2830020	 add         r0, r3, #0x20
  00734	eb000000	 bl          OALTimerSetReg

; 488  : 
; 489  :     // Enable timer in auto-reload and compare mode
; 490  :     OALTimerSetReg(&g_pTimerRegs->TCLR, GPTIMER_TCLR_CE|GPTIMER_TCLR_AR|GPTIMER_TCLR_ST);

  00738	e3a01043	 mov         r1, #0x43
  0073c	e59f3118	 ldr         r3, [pc, #0x118]
  00740	e5933000	 ldr         r3, [r3]
  00744	e2830024	 add         r0, r3, #0x24
  00748	eb000000	 bl          OALTimerSetReg

; 491  : 
; 492  :     // Wait until write is done
; 493  :     //while ((INREG32(&g_pTimerRegs->TWPS) & GPTIMER_TWPS_TCLR) != 0);
; 494  : 
; 495  :     // Set global variable to tell interrupt module about timer used
; 496  :     g_oalTimerIrq = GetIrqByDevice(g_TimerDevice,NULL);

  0074c	e3a01000	 mov         r1, #0
  00750	e59f3100	 ldr         r3, [pc, #0x100]
  00754	e5930000	 ldr         r0, [r3]
  00758	eb000000	 bl          GetIrqByDevice
  0075c	e58d0028	 str         r0, [sp, #0x28]
  00760	e59d2028	 ldr         r2, [sp, #0x28]
  00764	e59f30e8	 ldr         r3, [pc, #0xE8]
  00768	e5832000	 str         r2, [r3]

; 497  : 
; 498  :     // Request SYSINTR for timer IRQ, it is done to reserve it...
; 499  :     sysIntr = OALIntrRequestSysIntr(1, &g_oalTimerIrq, OAL_INTR_FORCE_STATIC);

  0076c	e3a02004	 mov         r2, #4
  00770	e59f10dc	 ldr         r1, [pc, #0xDC]
  00774	e3a00001	 mov         r0, #1
  00778	eb000000	 bl          OALIntrRequestSysIntr
  0077c	e58d002c	 str         r0, [sp, #0x2C]
  00780	e59d302c	 ldr         r3, [sp, #0x2C]
  00784	e58d3008	 str         r3, [sp, #8]

; 500  : 
; 501  :     // Enable System Tick interrupt
; 502  :     if (!OEMInterruptEnable(sysIntr, NULL, 0))

  00788	e3a02000	 mov         r2, #0
  0078c	e3a01000	 mov         r1, #0
  00790	e59d0008	 ldr         r0, [sp, #8]
  00794	eb000000	 bl          OEMInterruptEnable
  00798	e58d0030	 str         r0, [sp, #0x30]
  0079c	e59d3030	 ldr         r3, [sp, #0x30]
  007a0	e3530000	 cmp         r3, #0
  007a4	1a00000b	 bne         |$LN1@OALTimerIn|

; 503  :         {
; 504  :         OALMSG(OAL_ERROR, (
; 505  :             L"ERROR: OALTimerInit: Interrupt enable for system timer failed"
; 506  :             ));

  007a8	e59f3098	 ldr         r3, [pc, #0x98]
  007ac	e5933440	 ldr         r3, [r3, #0x440]
  007b0	e3130001	 tst         r3, #1
  007b4	0a000004	 beq         |$LN8@OALTimerIn|
  007b8	e59f0090	 ldr         r0, [pc, #0x90]
  007bc	eb000000	 bl          NKDbgPrintfW
  007c0	e3a03001	 mov         r3, #1
  007c4	e58d3034	 str         r3, [sp, #0x34]
  007c8	ea000001	 b           |$LN9@OALTimerIn|
  007cc		 |$LN8@OALTimerIn|
  007cc	e3a03000	 mov         r3, #0
  007d0	e58d3034	 str         r3, [sp, #0x34]
  007d4		 |$LN9@OALTimerIn|

; 507  :         goto cleanUp;

  007d4	ea000004	 b           |$cleanUp$45902|
  007d8		 |$LN1@OALTimerIn|

; 508  :         }
; 509  : 
; 510  :     // Initialize timer to maximum period
; 511  :     UpdatePeriod(g_oalTimerContext.maxPeriodMSec);

  007d8	e59f306c	 ldr         r3, [pc, #0x6C]
  007dc	e5930000	 ldr         r0, [r3]
  007e0	eb000000	 bl          UpdatePeriod

; 512  : 
; 513  :     // Done
; 514  :     rc = TRUE;

  007e4	e3a03001	 mov         r3, #1
  007e8	e58d3004	 str         r3, [sp, #4]
  007ec		 |$cleanUp$45902|

; 515  : 
; 516  : cleanUp:
; 517  :     OALMSG(OAL_TIMER && OAL_FUNC, (L"-OALTimerInit(rc = %d)\r\n", rc));

  007ec	e59f3054	 ldr         r3, [pc, #0x54]
  007f0	e5933440	 ldr         r3, [r3, #0x440]
  007f4	e3130b02	 tst         r3, #2, 22
  007f8	0a000009	 beq         |$LN10@OALTimerIn|
  007fc	e59f3044	 ldr         r3, [pc, #0x44]
  00800	e5933440	 ldr         r3, [r3, #0x440]
  00804	e3130004	 tst         r3, #4
  00808	0a000005	 beq         |$LN10@OALTimerIn|
  0080c	e59d1004	 ldr         r1, [sp, #4]
  00810	e59f002c	 ldr         r0, [pc, #0x2C]
  00814	eb000000	 bl          NKDbgPrintfW
  00818	e3a03001	 mov         r3, #1
  0081c	e58d3038	 str         r3, [sp, #0x38]
  00820	ea000001	 b           |$LN11@OALTimerIn|
  00824		 |$LN10@OALTimerIn|
  00824	e3a03000	 mov         r3, #0
  00828	e58d3038	 str         r3, [sp, #0x38]
  0082c		 |$LN11@OALTimerIn|

; 518  :     return rc;

  0082c	e59d3004	 ldr         r3, [sp, #4]
  00830	e58d300c	 str         r3, [sp, #0xC]

; 519  : }

  00834	e59d000c	 ldr         r0, [sp, #0xC]
  00838	e28dd03c	 add         sp, sp, #0x3C
  0083c	e89d6000	 ldmia       sp, {sp, lr}
  00840	e12fff1e	 bx          lr
  00844		 |$LN15@OALTimerIn|
  00844		 |$LN16@OALTimerIn|
  00844	00000000	 DCD         |??_C@_1DC@BNLGCJKD@?$AA?9?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AAr?$AAc?$AA?5?$AA?$DN?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00848		 |$LN17@OALTimerIn|
  00848	00000000	 DCD         |dpCurSettings|
  0084c		 |$LN18@OALTimerIn|
  0084c	00000000	 DCD         |g_oalTimerContext|
  00850		 |$LN19@OALTimerIn|
  00850	00000000	 DCD         |??_C@_1HM@CJGLDOPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AA?5?$AAe@|
  00854		 |$LN20@OALTimerIn|
  00854	00000000	 DCD         |g_oalTimerIrq|
  00858		 |$LN21@OALTimerIn|
  00858	00000000	 DCD         |g_TimerDevice|
  0085c		 |$LN22@OALTimerIn|
  0085c	00000000	 DCD         |g_pTimerRegs|
  00860		 |$LN23@OALTimerIn|
  00860	00000000	 DCD         |OALTimerUpdateRescheduleTime|
  00864		 |$LN24@OALTimerIn|
  00864	00000000	 DCD         |g_pOemGlobal|
  00868		 |$LN25@OALTimerIn|
  00868	00000000	 DCD         |g_pNKGlobal|
  0086c		 |$LN26@OALTimerIn|
  0086c	00000000	 DCD         |dwOEMMaxIdlePeriod|
  00870		 |$LN27@OALTimerIn|
  00870	00000000	 DCD         |??_C@_1DI@BBHLNDEO@?$AA?$CL?$AAO?$AAA?$AAL?$AAT?$AAi?$AAm?$AAe?$AAr?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?0?$AA?5?$AA?$CF?$AAd?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00874		 |$M46049|

			 ENDP  ; |OALTimerInit|

	EXPORT	|OEMGetTickCount|

  00028			 AREA	 |.pdata|, PDATA
|$T46069| DCD	|$LN11@OALTimerUp|
	DCD	0x40003c04
; Function compile flags: /Odtp

  00874			 AREA	 |.text|, CODE, ARM

  00874		 |OALTimerUpdateRescheduleTime| PROC

; 532  : {

  00874		 |$LN11@OALTimerUp|
  00874	e1a0c00d	 mov         r12, sp
  00878	e92d0001	 stmdb       sp!, {r0}
  0087c	e92d5000	 stmdb       sp!, {r12, lr}
  00880	e24dd014	 sub         sp, sp, #0x14
  00884		 |$M46066|

; 533  :     UINT32 baseMSec, periodMSec;
; 534  :     INT32 delta;
; 535  : 
; 536  :     // Get current system timer counter
; 537  :     baseMSec = CurMSec;

  00884	e59f30d4	 ldr         r3, [pc, #0xD4]
  00888	e5933000	 ldr         r3, [r3]
  0088c	e28330c8	 add         r3, r3, #0xC8
  00890	e5933000	 ldr         r3, [r3]
  00894	e58d3000	 str         r3, [sp]

; 538  : 
; 539  :     // How far we are from next tick
; 540  :     delta = (INT32)(g_oalTimerContext.match - OALTimerGetCount());

  00898	eb000000	 bl          OALTimerGetCount
  0089c	e58d000c	 str         r0, [sp, #0xC]
  008a0	e59f30b4	 ldr         r3, [pc, #0xB4]
  008a4	e5932014	 ldr         r2, [r3, #0x14]
  008a8	e59d300c	 ldr         r3, [sp, #0xC]
  008ac	e0423003	 sub         r3, r2, r3
  008b0	e58d3004	 str         r3, [sp, #4]

; 541  : 
; 542  :     if( delta < 0 )

  008b4	e59d3004	 ldr         r3, [sp, #4]
  008b8	e3530000	 cmp         r3, #0
  008bc	aa000002	 bge         |$LN6@OALTimerUp|

; 543  :     {
; 544  :         UpdatePeriod(0);

  008c0	e3a00000	 mov         r0, #0
  008c4	eb000000	 bl          UpdatePeriod

; 545  :         goto cleanUp;

  008c8	ea000020	 b           |$cleanUp$45913|
  008cc		 |$LN6@OALTimerUp|

; 546  :     }
; 547  : 
; 548  :     // If timer interrupts occurs, or we are within 1 ms of the scheduled
; 549  :     // interrupt, just return - timer ISR will take care of it.
; 550  :     if ((baseMSec != CurMSec) || (delta < MSEC_TO_TICK(1))) goto cleanUp;

  008cc	e59f308c	 ldr         r3, [pc, #0x8C]
  008d0	e5933000	 ldr         r3, [r3]
  008d4	e28330c8	 add         r3, r3, #0xC8
  008d8	e5932000	 ldr         r2, [r3]
  008dc	e59d3000	 ldr         r3, [sp]
  008e0	e1530002	 cmp         r3, r2
  008e4	1a000002	 bne         |$LN4@OALTimerUp|
  008e8	e59d3004	 ldr         r3, [sp, #4]
  008ec	e3530021	 cmp         r3, #0x21
  008f0	aa000000	 bge         |$LN5@OALTimerUp|
  008f4		 |$LN4@OALTimerUp|
  008f4	ea000015	 b           |$cleanUp$45913|
  008f8		 |$LN5@OALTimerUp|

; 551  : 
; 552  :     // Calculate the distance between the new time and the last timer interrupt
; 553  :       periodMSec = timeMSec - OEMGetTickCount();

  008f8	eb000000	 bl          OEMGetTickCount
  008fc	e58d0010	 str         r0, [sp, #0x10]
  00900	e59d201c	 ldr         r2, [sp, #0x1C]
  00904	e59d3010	 ldr         r3, [sp, #0x10]
  00908	e0423003	 sub         r3, r2, r3
  0090c	e58d3008	 str         r3, [sp, #8]

; 554  : 
; 555  : 
; 556  :     // Trying to set reschedule time prior or equal to CurMSec - this could
; 557  :     // happen if a thread is on its way to sleep while preempted before
; 558  :     // getting into the Sleep Queue
; 559  :     if ((INT32)periodMSec < 0)

  00910	e59d3008	 ldr         r3, [sp, #8]
  00914	e3530000	 cmp         r3, #0
  00918	aa000002	 bge         |$LN3@OALTimerUp|

; 560  :         {
; 561  :         periodMSec = 0;

  0091c	e3a03000	 mov         r3, #0
  00920	e58d3008	 str         r3, [sp, #8]
  00924	ea000007	 b           |$LN2@OALTimerUp|
  00928		 |$LN3@OALTimerUp|

; 562  :         }
; 563  :     else if (periodMSec > g_oalTimerContext.maxPeriodMSec)

  00928	e59d2008	 ldr         r2, [sp, #8]
  0092c	e59f3028	 ldr         r3, [pc, #0x28]
  00930	e5933000	 ldr         r3, [r3]
  00934	e1520003	 cmp         r2, r3
  00938	9a000002	 bls         |$LN1@OALTimerUp|

; 564  :         {
; 565  :         periodMSec = g_oalTimerContext.maxPeriodMSec;

  0093c	e59f3018	 ldr         r3, [pc, #0x18]
  00940	e5933000	 ldr         r3, [r3]
  00944	e58d3008	 str         r3, [sp, #8]
  00948		 |$LN1@OALTimerUp|
  00948		 |$LN2@OALTimerUp|

; 566  :         }
; 567  : 
; 568  :     // Now we find new period, so update timer
; 569  :     UpdatePeriod(periodMSec);

  00948	e59d0008	 ldr         r0, [sp, #8]
  0094c	eb000000	 bl          UpdatePeriod
  00950		 |$cleanUp$45913|

; 570  : 
; 571  : cleanUp:
; 572  :     return;
; 573  : }

  00950	e28dd014	 add         sp, sp, #0x14
  00954	e89d6000	 ldmia       sp, {sp, lr}
  00958	e12fff1e	 bx          lr
  0095c		 |$LN12@OALTimerUp|
  0095c		 |$LN13@OALTimerUp|
  0095c	00000000	 DCD         |g_oalTimerContext|
  00960		 |$LN14@OALTimerUp|
  00960	00000000	 DCD         |g_pNKGlobal|
  00964		 |$M46067|

			 ENDP  ; |OALTimerUpdateRescheduleTime|

	EXPORT	|OALTimerIntrHandler|
	IMPORT	|g_oalILT|
	IMPORT	|OALTickTimerIntr|

  00030			 AREA	 |.pdata|, PDATA
|$T46078| DCD	|$LN11@OALTimerIn@2|
	DCD	0x40008e02
; Function compile flags: /Odtp

  00964			 AREA	 |.text|, CODE, ARM

  00964		 |OALTimerIntrHandler| PROC

; 585  : {

  00964		 |$LN11@OALTimerIn@2|
  00964	e52de004	 str         lr, [sp, #-4]!
  00968	e24dd020	 sub         sp, sp, #0x20
  0096c		 |$M46075|

; 586  :     UINT32 count;
; 587  :     INT32 period, delta;
; 588  :     UINT32 sysIntr = SYSINTR_NOP;

  0096c	e3a03000	 mov         r3, #0
  00970	e58d3004	 str         r3, [sp, #4]

; 589  : 
; 590  : 
; 591  : 
; 592  :     // allow bsp to process timer interrupt first
; 593  :     sysIntr = OALTickTimerIntr();

  00974	eb000000	 bl          OALTickTimerIntr
  00978	e58d0014	 str         r0, [sp, #0x14]
  0097c	e59d3014	 ldr         r3, [sp, #0x14]
  00980	e58d3004	 str         r3, [sp, #4]

; 594  :     if (sysIntr != SYSINTR_NOP) return sysIntr;

  00984	e59d3004	 ldr         r3, [sp, #4]
  00988	e3530000	 cmp         r3, #0
  0098c	0a000002	 beq         |$LN6@OALTimerIn@2|
  00990	e59d3004	 ldr         r3, [sp, #4]
  00994	e58d3010	 str         r3, [sp, #0x10]
  00998	ea000077	 b           |$LN7@OALTimerIn@2|
  0099c		 |$LN6@OALTimerIn@2|

; 595  : 
; 596  :     // Clear interrupt
; 597  :     OALTimerSetReg(&g_pTimerRegs->TISR, GPTIMER_TIER_MATCH);

  0099c	e3a01001	 mov         r1, #1
  009a0	e59f31f0	 ldr         r3, [pc, #0x1F0]
  009a4	e5933000	 ldr         r3, [r3]
  009a8	e2830018	 add         r0, r3, #0x18
  009ac	eb000000	 bl          OALTimerSetReg

; 598  : 
; 599  :     // How far from interrupt we are?
; 600  :     count = OALTimerGetCount();

  009b0	eb000000	 bl          OALTimerGetCount
  009b4	e58d0018	 str         r0, [sp, #0x18]
  009b8	e59d3018	 ldr         r3, [sp, #0x18]
  009bc	e58d3000	 str         r3, [sp]

; 601  :     delta = count - g_oalTimerContext.match;

  009c0	e59f31c8	 ldr         r3, [pc, #0x1C8]
  009c4	e5932014	 ldr         r2, [r3, #0x14]
  009c8	e59d3000	 ldr         r3, [sp]
  009cc	e0433002	 sub         r3, r3, r2
  009d0	e58d300c	 str         r3, [sp, #0xC]

; 602  :     
; 603  : 
; 604  :     // If delta is negative, timer fired for some reason
; 605  :     // To be safe, reprogram the timer for minimum delta
; 606  :     if (delta < 0)

  009d4	e59d300c	 ldr         r3, [sp, #0xC]
  009d8	e3530000	 cmp         r3, #0
  009dc	aa000002	 bge         |$LN5@OALTimerIn@2|

; 607  :     {
; 608  :         delta = 0;

  009e0	e3a03000	 mov         r3, #0
  009e4	e58d300c	 str         r3, [sp, #0xC]

; 609  :         goto cleanUp;

  009e8	ea000049	 b           |$cleanUp$45927|
  009ec		 |$LN5@OALTimerIn@2|

; 610  :     }
; 611  : 
; 612  : #ifdef OAL_ILTIMING
; 613  :     if (g_oalILT.active)

  009ec	e59f3198	 ldr         r3, [pc, #0x198]
  009f0	e5933000	 ldr         r3, [r3]
  009f4	e3530000	 cmp         r3, #0
  009f8	0a000002	 beq         |$LN4@OALTimerIn@2|

; 614  :     {
; 615  :         g_oalILT.isrTime1 = delta;

  009fc	e59d200c	 ldr         r2, [sp, #0xC]
  00a00	e59f3184	 ldr         r3, [pc, #0x184]
  00a04	e5832008	 str         r2, [r3, #8]
  00a08		 |$LN4@OALTimerIn@2|

; 616  :     }        
; 617  : #endif
; 618  : 
; 619  :     // Find how long period was
; 620  :     period = count - g_oalTimerContext.base;

  00a08	e59f3180	 ldr         r3, [pc, #0x180]
  00a0c	e5932010	 ldr         r2, [r3, #0x10]
  00a10	e59d3000	 ldr         r3, [sp]
  00a14	e0433002	 sub         r3, r3, r2
  00a18	e58d3008	 str         r3, [sp, #8]

; 621  :     g_oalTimerContext.curCounts += period;    

  00a1c	e59d1008	 ldr         r1, [sp, #8]
  00a20	e59d3008	 ldr         r3, [sp, #8]
  00a24	e1a00fc3	 mov         r0, r3, asr #31
  00a28	e59f3160	 ldr         r3, [pc, #0x160]
  00a2c	e5932008	 ldr         r2, [r3, #8]
  00a30	e59f3158	 ldr         r3, [pc, #0x158]
  00a34	e593300c	 ldr         r3, [r3, #0xC]
  00a38	e0921001	 adds        r1, r2, r1
  00a3c	e0a32000	 adc         r2, r3, r0
  00a40	e59f3148	 ldr         r3, [pc, #0x148]
  00a44	e5831008	 str         r1, [r3, #8]
  00a48	e59f3140	 ldr         r3, [pc, #0x140]
  00a4c	e583200c	 str         r2, [r3, #0xC]

; 622  :     g_oalTimerContext.base += period;

  00a50	e59f3138	 ldr         r3, [pc, #0x138]
  00a54	e5932010	 ldr         r2, [r3, #0x10]
  00a58	e59d3008	 ldr         r3, [sp, #8]
  00a5c	e0822003	 add         r2, r2, r3
  00a60	e59f3128	 ldr         r3, [pc, #0x128]
  00a64	e5832010	 str         r2, [r3, #0x10]

; 623  : 
; 624  :     // Calculate actual CurMSec
; 625  :     CurMSec = (UINT32) TICK_TO_MSEC(g_oalTimerContext.curCounts);

  00a68	e59f3120	 ldr         r3, [pc, #0x120]
  00a6c	e5931008	 ldr         r1, [r3, #8]
  00a70	e59f3118	 ldr         r3, [pc, #0x118]
  00a74	e593200c	 ldr         r2, [r3, #0xC]
  00a78	e58d101c	 str         r1, [sp, #0x1C]
  00a7c	e3a03ffa	 mov         r3, #0xFA, 30
  00a80	e0000392	 mul         r0, r2, r3
  00a84	e59d101c	 ldr         r1, [sp, #0x1C]
  00a88	e3a03ffa	 mov         r3, #0xFA, 30
  00a8c	e0832391	 umull       r2, r3, r1, r3
  00a90	e0803003	 add         r3, r0, r3
  00a94	e1a027a2	 mov         r2, r2, lsr #15
  00a98	e1a03883	 mov         r3, r3, lsl #17
  00a9c	e1832002	 orr         r2, r3, r2
  00aa0	e59f30ec	 ldr         r3, [pc, #0xEC]
  00aa4	e5933000	 ldr         r3, [r3]
  00aa8	e28330c8	 add         r3, r3, #0xC8
  00aac	e5832000	 str         r2, [r3]

; 626  : 
; 627  :     OALLED(LED_IDX_TIMER, CurMSec >> 10);

  00ab0	e59f30dc	 ldr         r3, [pc, #0xDC]
  00ab4	e5933000	 ldr         r3, [r3]
  00ab8	e28330c8	 add         r3, r3, #0xC8
  00abc	e5933000	 ldr         r3, [r3]
  00ac0	e1a01523	 mov         r1, r3, lsr #10
  00ac4	e3a0001f	 mov         r0, #0x1F
  00ac8	eb000000	 bl          OEMWriteDebugLED

; 628  : 
; 629  :     // Reschedule?
; 630  :     delta = dwReschedTime - CurMSec;

  00acc	e59f30c0	 ldr         r3, [pc, #0xC0]
  00ad0	e5933000	 ldr         r3, [r3]
  00ad4	e28320c4	 add         r2, r3, #0xC4
  00ad8	e59f30b4	 ldr         r3, [pc, #0xB4]
  00adc	e5933000	 ldr         r3, [r3]
  00ae0	e28330c8	 add         r3, r3, #0xC8
  00ae4	e5922000	 ldr         r2, [r2]
  00ae8	e5933000	 ldr         r3, [r3]
  00aec	e0423003	 sub         r3, r2, r3
  00af0	e58d300c	 str         r3, [sp, #0xC]

; 631  :     if (delta <= 0)

  00af4	e59d300c	 ldr         r3, [sp, #0xC]
  00af8	e3530000	 cmp         r3, #0
  00afc	ca000004	 bgt         |$LN3@OALTimerIn@2|

; 632  :         {
; 633  :         sysIntr = SYSINTR_RESCHED;

  00b00	e3a03001	 mov         r3, #1
  00b04	e58d3004	 str         r3, [sp, #4]

; 634  :         delta = g_oalTimerContext.maxPeriodMSec;

  00b08	e59f3080	 ldr         r3, [pc, #0x80]
  00b0c	e5933000	 ldr         r3, [r3]
  00b10	e58d300c	 str         r3, [sp, #0xC]
  00b14		 |$LN3@OALTimerIn@2|
  00b14		 |$cleanUp$45927|

; 635  :         }
; 636  : 
; 637  : cleanUp:
; 638  :     // Set new period
; 639  :     UpdatePeriod(delta);

  00b14	e59d000c	 ldr         r0, [sp, #0xC]
  00b18	eb000000	 bl          UpdatePeriod

; 640  : 
; 641  : #ifdef OAL_ILTIMING
; 642  :     if (g_oalILT.active) {

  00b1c	e59f3068	 ldr         r3, [pc, #0x68]
  00b20	e5933000	 ldr         r3, [r3]
  00b24	e3530000	 cmp         r3, #0
  00b28	0a000011	 beq         |$LN2@OALTimerIn@2|

; 643  :         if (--g_oalILT.counter == 0) {

  00b2c	e59f3058	 ldr         r3, [pc, #0x58]
  00b30	e5933014	 ldr         r3, [r3, #0x14]
  00b34	e2432001	 sub         r2, r3, #1
  00b38	e59f304c	 ldr         r3, [pc, #0x4C]
  00b3c	e5832014	 str         r2, [r3, #0x14]
  00b40	e59f3044	 ldr         r3, [pc, #0x44]
  00b44	e5933014	 ldr         r3, [r3, #0x14]
  00b48	e3530000	 cmp         r3, #0
  00b4c	1a000008	 bne         |$LN1@OALTimerIn@2|

; 644  :             sysIntr = SYSINTR_TIMING;

  00b50	e3a0300a	 mov         r3, #0xA
  00b54	e58d3004	 str         r3, [sp, #4]

; 645  :             g_oalILT.counter = g_oalILT.counterSet;

  00b58	e59f302c	 ldr         r3, [pc, #0x2C]
  00b5c	e5932018	 ldr         r2, [r3, #0x18]
  00b60	e59f3024	 ldr         r3, [pc, #0x24]
  00b64	e5832014	 str         r2, [r3, #0x14]

; 646  :             g_oalILT.isrTime2 = 0;

  00b68	e59f201c	 ldr         r2, [pc, #0x1C]
  00b6c	e3a03000	 mov         r3, #0
  00b70	e582300c	 str         r3, [r2, #0xC]
  00b74		 |$LN1@OALTimerIn@2|
  00b74		 |$LN2@OALTimerIn@2|

; 647  :         }
; 648  :     }
; 649  : #endif
; 650  : 
; 651  :     return sysIntr;

  00b74	e59d3004	 ldr         r3, [sp, #4]
  00b78	e58d3010	 str         r3, [sp, #0x10]
  00b7c		 |$LN7@OALTimerIn@2|

; 652  : }

  00b7c	e59d0010	 ldr         r0, [sp, #0x10]
  00b80	e28dd020	 add         sp, sp, #0x20
  00b84	e49de004	 ldr         lr, [sp], #4
  00b88	e12fff1e	 bx          lr
  00b8c		 |$LN12@OALTimerIn@2|
  00b8c		 |$LN13@OALTimerIn@2|
  00b8c	00000000	 DCD         |g_oalILT|
  00b90		 |$LN14@OALTimerIn@2|
  00b90	00000000	 DCD         |g_oalTimerContext|
  00b94		 |$LN15@OALTimerIn@2|
  00b94	00000000	 DCD         |g_pNKGlobal|
  00b98		 |$LN16@OALTimerIn@2|
  00b98	00000000	 DCD         |g_pTimerRegs|
  00b9c		 |$M46076|

			 ENDP  ; |OALTimerIntrHandler|


  00038			 AREA	 |.pdata|, PDATA
|$T46089| DCD	|$LN5@OALTimerGe@2|
	DCD	0x40000e02
; Function compile flags: /Odtp

  00b9c			 AREA	 |.text|, CODE, ARM

  00b9c		 |OALTimerGetCount| PROC

; 660  : {

  00b9c		 |$LN5@OALTimerGe@2|
  00b9c	e52de004	 str         lr, [sp, #-4]!
  00ba0	e24dd008	 sub         sp, sp, #8
  00ba4		 |$M46086|

; 661  :     //  Return the timer value
; 662  :     return OALTimerGetReg(&g_pTimerRegs->TCRR);

  00ba4	e59f3024	 ldr         r3, [pc, #0x24]
  00ba8	e5933000	 ldr         r3, [r3]
  00bac	e2830028	 add         r0, r3, #0x28
  00bb0	eb000000	 bl          OALTimerGetReg
  00bb4	e58d0004	 str         r0, [sp, #4]
  00bb8	e59d3004	 ldr         r3, [sp, #4]
  00bbc	e58d3000	 str         r3, [sp]

; 663  : }

  00bc0	e59d0000	 ldr         r0, [sp]
  00bc4	e28dd008	 add         sp, sp, #8
  00bc8	e49de004	 ldr         lr, [sp], #4
  00bcc	e12fff1e	 bx          lr
  00bd0		 |$LN6@OALTimerGe@2|
  00bd0		 |$LN7@OALTimerGe@2|
  00bd0	00000000	 DCD         |g_pTimerRegs|
  00bd4		 |$M46087|

			 ENDP  ; |OALTimerGetCount|

	EXPORT	|OALTimerCountsSinceSysTick|

  00040			 AREA	 |.pdata|, PDATA
|$T46097| DCD	|$LN5@OALTimerCo|
	DCD	0x40001202
; Function compile flags: /Odtp

  00bd4			 AREA	 |.text|, CODE, ARM

  00bd4		 |OALTimerCountsSinceSysTick| PROC

; 670  : {

  00bd4		 |$LN5@OALTimerCo|
  00bd4	e52de004	 str         lr, [sp, #-4]!
  00bd8	e24dd008	 sub         sp, sp, #8
  00bdc		 |$M46094|

; 671  :     // Return timer ticks since last interrupt
; 672  :     return (INT32)(OALTimerGetReg(&g_pTimerRegs->TCRR) - g_oalTimerContext.base);

  00bdc	e59f3034	 ldr         r3, [pc, #0x34]
  00be0	e5933000	 ldr         r3, [r3]
  00be4	e2830028	 add         r0, r3, #0x28
  00be8	eb000000	 bl          OALTimerGetReg
  00bec	e58d0004	 str         r0, [sp, #4]
  00bf0	e59f301c	 ldr         r3, [pc, #0x1C]
  00bf4	e5932010	 ldr         r2, [r3, #0x10]
  00bf8	e59d3004	 ldr         r3, [sp, #4]
  00bfc	e0433002	 sub         r3, r3, r2
  00c00	e58d3000	 str         r3, [sp]

; 673  : }

  00c04	e59d0000	 ldr         r0, [sp]
  00c08	e28dd008	 add         sp, sp, #8
  00c0c	e49de004	 ldr         lr, [sp], #4
  00c10	e12fff1e	 bx          lr
  00c14		 |$LN6@OALTimerCo|
  00c14		 |$LN7@OALTimerCo|
  00c14	00000000	 DCD         |g_oalTimerContext|
  00c18		 |$LN8@OALTimerCo|
  00c18	00000000	 DCD         |g_pTimerRegs|
  00c1c		 |$M46095|

			 ENDP  ; |OALTimerCountsSinceSysTick|


  00048			 AREA	 |.pdata|, PDATA
|$T46106| DCD	|$LN5@OALGetTick|
	DCD	0x40001d02
; Function compile flags: /Odtp

  00c1c			 AREA	 |.text|, CODE, ARM

  00c1c		 |OALGetTickCount| PROC

; 688  : {

  00c1c		 |$LN5@OALGetTick|
  00c1c	e52de004	 str         lr, [sp, #-4]!
  00c20	e24dd014	 sub         sp, sp, #0x14
  00c24		 |$M46103|

; 689  :     UINT64 tickCount = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00c24	e59f3060	 ldr         r3, [pc, #0x60]
  00c28	e5933000	 ldr         r3, [r3]
  00c2c	e2830028	 add         r0, r3, #0x28
  00c30	eb000000	 bl          OALTimerGetReg
  00c34	e58d000c	 str         r0, [sp, #0xC]
  00c38	e59d300c	 ldr         r3, [sp, #0xC]
  00c3c	e58d3000	 str         r3, [sp]
  00c40	e3a03000	 mov         r3, #0
  00c44	e58d3004	 str         r3, [sp, #4]

; 690  :     //  Returns number of 1 msec ticks
; 691  :     return (UINT32) TICK_TO_MSEC(tickCount);

  00c48	e59d3000	 ldr         r3, [sp]
  00c4c	e59d2004	 ldr         r2, [sp, #4]
  00c50	e58d3010	 str         r3, [sp, #0x10]
  00c54	e3a03ffa	 mov         r3, #0xFA, 30
  00c58	e0000392	 mul         r0, r2, r3
  00c5c	e59d1010	 ldr         r1, [sp, #0x10]
  00c60	e3a03ffa	 mov         r3, #0xFA, 30
  00c64	e0832391	 umull       r2, r3, r1, r3
  00c68	e0803003	 add         r3, r0, r3
  00c6c	e1a027a2	 mov         r2, r2, lsr #15
  00c70	e1a03883	 mov         r3, r3, lsl #17
  00c74	e1833002	 orr         r3, r3, r2
  00c78	e58d3008	 str         r3, [sp, #8]

; 692  : }

  00c7c	e59d0008	 ldr         r0, [sp, #8]
  00c80	e28dd014	 add         sp, sp, #0x14
  00c84	e49de004	 ldr         lr, [sp], #4
  00c88	e12fff1e	 bx          lr
  00c8c		 |$LN6@OALGetTick|
  00c8c		 |$LN7@OALGetTick|
  00c8c	00000000	 DCD         |g_pTimerRegs|
  00c90		 |$M46104|

			 ENDP  ; |OALGetTickCount|


  00050			 AREA	 |.pdata|, PDATA
|$T46114| DCD	|$LN8@OEMGetTick|
	DCD	0x40003f02
; Function compile flags: /Odtp

  00c90			 AREA	 |.text|, CODE, ARM

  00c90		 |OEMGetTickCount| PROC

; 706  : {

  00c90		 |$LN8@OEMGetTick|
  00c90	e52de004	 str         lr, [sp, #-4]!
  00c94	e24dd028	 sub         sp, sp, #0x28
  00c98		 |$M46111|
  00c98		 |$LN3@OEMGetTick|

; 707  :     UINT64 baseCounts;
; 708  :     UINT32 offset;
; 709  : 
; 710  :     // This code adjusts the accuracy of the returned value to the nearest
; 711  :     // MSec when the system tick exceeds 1 ms. The following code checks if
; 712  :     // a system timer interrupt occurred between reading the CurMSec value
; 713  :     // and the call to fetch the HiResTicksSinceSysTick. If so, the value of
; 714  :     // CurMSec and Offset is re-read, with the certainty that a system timer
; 715  :     // interrupt will not occur again.
; 716  :     do
; 717  :         {
; 718  :         baseCounts = g_oalTimerContext.curCounts;

  00c98	e59f30e8	 ldr         r3, [pc, #0xE8]
  00c9c	e5933008	 ldr         r3, [r3, #8]
  00ca0	e58d3000	 str         r3, [sp]
  00ca4	e59f30dc	 ldr         r3, [pc, #0xDC]
  00ca8	e593300c	 ldr         r3, [r3, #0xC]
  00cac	e58d3004	 str         r3, [sp, #4]

; 719  :         offset = OALTimerGetCount() - g_oalTimerContext.base;

  00cb0	eb000000	 bl          OALTimerGetCount
  00cb4	e58d0010	 str         r0, [sp, #0x10]
  00cb8	e59f30c8	 ldr         r3, [pc, #0xC8]
  00cbc	e5932010	 ldr         r2, [r3, #0x10]
  00cc0	e59d3010	 ldr         r3, [sp, #0x10]
  00cc4	e0433002	 sub         r3, r3, r2
  00cc8	e58d3008	 str         r3, [sp, #8]

; 720  :         }
; 721  :     while (baseCounts != g_oalTimerContext.curCounts);

  00ccc	e59f30b4	 ldr         r3, [pc, #0xB4]
  00cd0	e5931008	 ldr         r1, [r3, #8]
  00cd4	e59f30ac	 ldr         r3, [pc, #0xAC]
  00cd8	e593200c	 ldr         r2, [r3, #0xC]
  00cdc	e59d3000	 ldr         r3, [sp]
  00ce0	e58d3014	 str         r3, [sp, #0x14]
  00ce4	e59d3004	 ldr         r3, [sp, #4]
  00ce8	e58d3018	 str         r3, [sp, #0x18]
  00cec	e59d3018	 ldr         r3, [sp, #0x18]
  00cf0	e58d301c	 str         r3, [sp, #0x1C]
  00cf4	e58d2020	 str         r2, [sp, #0x20]
  00cf8	e59d3014	 ldr         r3, [sp, #0x14]
  00cfc	e1530001	 cmp         r3, r1
  00d00	1affffe4	 bne         |$LN3@OEMGetTick|
  00d04	e59d201c	 ldr         r2, [sp, #0x1C]
  00d08	e59d3020	 ldr         r3, [sp, #0x20]
  00d0c	e1520003	 cmp         r2, r3
  00d10	1affffe0	 bne         |$LN3@OEMGetTick|

; 722  : 
; 723  : 
; 724  :    //  Update CurMSec (kernel uses both CurMSec and GetTickCount() at different places) and return msec tick count
; 725  :     CurMSec = (UINT32)TICK_TO_MSEC(baseCounts + offset);

  00d14	e59d1008	 ldr         r1, [sp, #8]
  00d18	e59d3000	 ldr         r3, [sp]
  00d1c	e59d2004	 ldr         r2, [sp, #4]
  00d20	e0933001	 adds        r3, r3, r1
  00d24	e2a22000	 adc         r2, r2, #0
  00d28	e58d3024	 str         r3, [sp, #0x24]
  00d2c	e3a03ffa	 mov         r3, #0xFA, 30
  00d30	e0000392	 mul         r0, r2, r3
  00d34	e59d1024	 ldr         r1, [sp, #0x24]
  00d38	e3a03ffa	 mov         r3, #0xFA, 30
  00d3c	e0832391	 umull       r2, r3, r1, r3
  00d40	e0803003	 add         r3, r0, r3
  00d44	e1a027a2	 mov         r2, r2, lsr #15
  00d48	e1a03883	 mov         r3, r3, lsl #17
  00d4c	e1832002	 orr         r2, r3, r2
  00d50	e59f302c	 ldr         r3, [pc, #0x2C]
  00d54	e5933000	 ldr         r3, [r3]
  00d58	e28330c8	 add         r3, r3, #0xC8
  00d5c	e5832000	 str         r2, [r3]

; 726  : 
; 727  :     return CurMSec;

  00d60	e59f301c	 ldr         r3, [pc, #0x1C]
  00d64	e5933000	 ldr         r3, [r3]
  00d68	e28330c8	 add         r3, r3, #0xC8
  00d6c	e5933000	 ldr         r3, [r3]
  00d70	e58d300c	 str         r3, [sp, #0xC]

; 728  : 
; 729  : }

  00d74	e59d000c	 ldr         r0, [sp, #0xC]
  00d78	e28dd028	 add         sp, sp, #0x28
  00d7c	e49de004	 ldr         lr, [sp], #4
  00d80	e12fff1e	 bx          lr
  00d84		 |$LN9@OEMGetTick|
  00d84		 |$LN10@OEMGetTick|
  00d84	00000000	 DCD         |g_pNKGlobal|
  00d88		 |$LN11@OEMGetTick|
  00d88	00000000	 DCD         |g_oalTimerContext|
  00d8c		 |$M46112|

			 ENDP  ; |OEMGetTickCount|

	END
