; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\COMMON_TI\GPIO\OMAP_GPIO\omap35xx_gpio.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|Omap_Gpio| [ DATA ]

  00000			 AREA	 |.data|, DATA
|Omap_Gpio| DCD	0x0
	DCD	|?OmapGpioInit@@YAHPBGPAPAXPAI@Z|
	DCD	|?OmapGpioPostInit@@YAHPAX@Z|
	DCD	|?OmapGpioDeinit@@YAHPAX@Z|
	DCD	|?OmapGpioSetBit@@YAHPAXI@Z|
	DCD	|?OmapGpioClrBit@@YAHPAXI@Z|
	DCD	|?OmapGpioGetBit@@YAKPAXI@Z|
	DCD	|?OmapGpioSetMode@@YAHPAXII@Z|
	DCD	|?OmapGpioGetMode@@YAKPAXI@Z|
	DCD	|?OmapGpioPullup@@YAHPAXII@Z|
	DCD	|?OmapGpioPulldown@@YAHPAXII@Z|
	DCD	|?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	%	8
	EXPORT	|?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| ; InternalSetGpioBankPowerState
	IMPORT	|EnableDeviceClocks|

  00000			 AREA	 |.pdata|, PDATA
|$T37386| DCD	|$LN8@InternalSe|
	DCD	0x40002f04
; Function compile flags: /Odtp
; File c:\wince600\platform\common\src\soc\common_ti_v1\common_ti\gpio\omap_gpio\omap35xx_gpio.cpp

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z| PROC ; InternalSetGpioBankPowerState

; 197  : {

  00000		 |$LN8@InternalSe|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d0007	 stmdb       sp!, {r0 - r2}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c	e24dd004	 sub         sp, sp, #4
  00010		 |$M37383|

; 198  :     // determine GPIO bank
; 199  :     UINT bank = GPIO_BANK(id);

  00010	e59d3010	 ldr         r3, [sp, #0x10]
  00014	e1a032a3	 mov         r3, r3, lsr #5
  00018	e58d3000	 str         r3, [sp]

; 200  : 
; 201  :     // check if power is enabled by client
; 202  :     if (pDevice->bank[bank].powerEnabled != 0) return;

  0001c	e59d300c	 ldr         r3, [sp, #0xC]
  00020	e283000c	 add         r0, r3, #0xC
  00024	e59d1000	 ldr         r1, [sp]
  00028	e3a03020	 mov         r3, #0x20
  0002c	e0020391	 mul         r2, r1, r3
  00030	e5903000	 ldr         r3, [r0]
  00034	e0833002	 add         r3, r3, r2
  00038	e5933000	 ldr         r3, [r3]
  0003c	e3530000	 cmp         r3, #0
  00040	0a000000	 beq         |$LN3@InternalSe|
  00044	ea000019	 b           |$LN4@InternalSe|
  00048		 |$LN3@InternalSe|

; 203  : 
; 204  :     if (state < D3)

  00048	e59d3014	 ldr         r3, [sp, #0x14]
  0004c	e3530003	 cmp         r3, #3
  00050	aa00000b	 bge         |$LN2@InternalSe|

; 205  :     {
; 206  :         EnableDeviceClocks( pDevice->bank[bank].DeviceID, TRUE );

  00054	e3a01001	 mov         r1, #1
  00058	e59d300c	 ldr         r3, [sp, #0xC]
  0005c	e283e00c	 add         lr, r3, #0xC
  00060	e59d0000	 ldr         r0, [sp]
  00064	e3a03020	 mov         r3, #0x20
  00068	e0020390	 mul         r2, r0, r3
  0006c	e59e3000	 ldr         r3, [lr]
  00070	e0833002	 add         r3, r3, r2
  00074	e283301c	 add         r3, r3, #0x1C
  00078	e5930000	 ldr         r0, [r3]
  0007c	eb000000	 bl          EnableDeviceClocks

; 207  :     }
; 208  :     else

  00080	ea00000a	 b           |$LN1@InternalSe|
  00084		 |$LN2@InternalSe|

; 209  :     {
; 210  : 		EnableDeviceClocks( pDevice->bank[bank].DeviceID, FALSE );

  00084	e3a01000	 mov         r1, #0
  00088	e59d300c	 ldr         r3, [sp, #0xC]
  0008c	e283e00c	 add         lr, r3, #0xC
  00090	e59d0000	 ldr         r0, [sp]
  00094	e3a03020	 mov         r3, #0x20
  00098	e0020390	 mul         r2, r0, r3
  0009c	e59e3000	 ldr         r3, [lr]
  000a0	e0833002	 add         r3, r3, r2
  000a4	e283301c	 add         r3, r3, #0x1C
  000a8	e5930000	 ldr         r0, [r3]
  000ac	eb000000	 bl          EnableDeviceClocks
  000b0		 |$LN1@InternalSe|
  000b0		 |$LN4@InternalSe|

; 211  :     }
; 212  : }

  000b0	e28dd004	 add         sp, sp, #4
  000b4	e89d6000	 ldmia       sp, {sp, lr}
  000b8	e12fff1e	 bx          lr
  000bc		 |$M37384|

			 ENDP  ; |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|, InternalSetGpioBankPowerState

	EXPORT	|??_C@_1CE@FNDIPNHI@?$AA?9?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@BGHMENPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAm?$AAa?$AAp?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1IG@ILLLDEBG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1HK@EBHBEPLH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@NPLPGPH@?$AA?$CL?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAs?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|HalContextUpdateDirtyRegister|
	IMPORT	|MmMapIoSpace|
	IMPORT	|GetAddressByDevice|
	IMPORT	|SOCGetGPIODeviceByBank|
	IMPORT	|memset|
	IMPORT	|OALLocalAlloc|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|

  00008			 AREA	 |.pdata|, PDATA
|$T37402| DCD	|$LN27@OmapGpioIn|
	DCD	0x4000f304

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CE@FNDIPNHI@?$AA?9?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@BGHMENPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAm?$AAa?$AAp?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "m", 0x0, "a", 0x0, "p"
	DCB	0x0, " ", 0x0, "G", 0x0, "I", 0x0, "O", 0x0, "%", 0x0, "d"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r"
	DCB	0x0, "o", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "g", 0x0, "i", 0x0, "s", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1IG@ILLLDEBG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l"
	DCB	0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "G", 0x0, "P", 0x0, "I", 0x0, "O", 0x0, " ", 0x0, "d"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "b", 0x0, "a", 0x0, "n", 0x0, "k", 0x0, " ", 0x0, "s"
	DCB	0x0, "t", 0x0, "r", 0x0, "u", 0x0, "c", 0x0, "t", 0x0, "u"
	DCB	0x0, "r", 0x0, "e", 0x0, "s", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1HK@EBHBEPLH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i", 0x0, "l"
	DCB	0x0, "e", 0x0, "d", 0x0, " ", 0x0, "a", 0x0, "l", 0x0, "l"
	DCB	0x0, "o", 0x0, "c", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "G", 0x0, "P", 0x0, "I", 0x0, "O", 0x0, " ", 0x0, "d"
	DCB	0x0, "r", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "r", 0x0, "u", 0x0, "c", 0x0, "t"
	DCB	0x0, "u", 0x0, "r", 0x0, "e", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@NPLPGPH@?$AA?$CL?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAs?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, "(", 0x0, "%", 0x0, "s", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  000bc			 AREA	 |.text|, CODE, ARM

  000bc		 |?OmapGpioInit@@YAHPBGPAPAXPAI@Z| PROC	; OmapGpioInit

; 227  : {

  000bc		 |$LN27@OmapGpioIn|
  000bc	e1a0c00d	 mov         r12, sp
  000c0	e92d0007	 stmdb       sp!, {r0 - r2}
  000c4	e92d5000	 stmdb       sp!, {r12, lr}
  000c8	e24dd04c	 sub         sp, sp, #0x4C
  000cc		 |$M37399|

; 228  :     BOOL rc = FALSE;

  000cc	e3a03000	 mov         r3, #0
  000d0	e58d3004	 str         r3, [sp, #4]

; 229  :     OmapGpioDevice_t *pDevice = NULL;

  000d4	e3a03000	 mov         r3, #0
  000d8	e58d3000	 str         r3, [sp]

; 230  :     PHYSICAL_ADDRESS pa;
; 231  :     DWORD size;
; 232  :     UINT8 i;
; 233  : 
; 234  : 	UNREFERENCED_PARAMETER(szContext);
; 235  : 
; 236  :     DEBUGMSG(ZONE_FUNCTION, (
; 237  :         L"+OmapGpioInit(%s)\r\n", szContext
; 238  :         ));

  000dc	e59f338c	 ldr         r3, [pc, #0x38C]
  000e0	e5933440	 ldr         r3, [r3, #0x440]
  000e4	e3130004	 tst         r3, #4
  000e8	0a000005	 beq         |$LN15@OmapGpioIn|
  000ec	e59d1054	 ldr         r1, [sp, #0x54]
  000f0	e59f038c	 ldr         r0, [pc, #0x38C]
  000f4	eb000000	 bl          NKDbgPrintfW
  000f8	e3a03001	 mov         r3, #1
  000fc	e58d301c	 str         r3, [sp, #0x1C]
  00100	ea000001	 b           |$LN16@OmapGpioIn|
  00104		 |$LN15@OmapGpioIn|
  00104	e3a03000	 mov         r3, #0
  00108	e58d301c	 str         r3, [sp, #0x1C]
  0010c		 |$LN16@OmapGpioIn|

; 239  : 
; 240  :     // Create device structure
; 241  :     pDevice = (OmapGpioDevice_t *)LocalAlloc(LPTR, sizeof(OmapGpioDevice_t));

  0010c	e3a01010	 mov         r1, #0x10
  00110	e3a00040	 mov         r0, #0x40
  00114	eb000000	 bl          OALLocalAlloc
  00118	e58d0020	 str         r0, [sp, #0x20]
  0011c	e59d3020	 ldr         r3, [sp, #0x20]
  00120	e58d3000	 str         r3, [sp]

; 242  :     if (pDevice == NULL)

  00124	e59d3000	 ldr         r3, [sp]
  00128	e3530000	 cmp         r3, #0
  0012c	1a00000c	 bne         |$LN12@OmapGpioIn|

; 243  :     {
; 244  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 245  :             L"Failed allocate GPIO driver structure\r\n"
; 246  :             ));

  00130	e59f3338	 ldr         r3, [pc, #0x338]
  00134	e5933440	 ldr         r3, [r3, #0x440]
  00138	e3130001	 tst         r3, #1
  0013c	0a000004	 beq         |$LN17@OmapGpioIn|
  00140	e59f0338	 ldr         r0, [pc, #0x338]
  00144	eb000000	 bl          NKDbgPrintfW
  00148	e3a03001	 mov         r3, #1
  0014c	e58d3024	 str         r3, [sp, #0x24]
  00150	ea000001	 b           |$LN18@OmapGpioIn|
  00154		 |$LN17@OmapGpioIn|
  00154	e3a03000	 mov         r3, #0
  00158	e58d3024	 str         r3, [sp, #0x24]
  0015c		 |$LN18@OmapGpioIn|

; 247  :         goto cleanUp;

  0015c	ea0000ac	 b           |$LN11@OmapGpioIn|
  00160	ea0000ab	 b           |$cleanUp$37095|
  00164		 |$LN12@OmapGpioIn|

; 248  :     }
; 249  :     memset(pDevice, 0, sizeof(OmapGpioDevice_t));

  00164	e3a02010	 mov         r2, #0x10
  00168	e3a01000	 mov         r1, #0
  0016c	e59d0000	 ldr         r0, [sp]
  00170	eb000000	 bl          memset

; 250  :     // Set cookie
; 251  :     pDevice->cookie = GPIO_DEVICE_COOKIE;

  00174	e59d2000	 ldr         r2, [sp]
  00178	e59f32fc	 ldr         r3, [pc, #0x2FC]
  0017c	e5823000	 str         r3, [r2]

; 252  :     // Get the number of for this SOC
; 253  :     i=1;

  00180	e3a03001	 mov         r3, #1
  00184	e5cd3008	 strb        r3, [sp, #8]
  00188		 |$LN10@OmapGpioIn|

; 254  :     while (SOCGetGPIODeviceByBank(i++) != OMAP_DEVICE_NONE)

  00188	e5dd3008	 ldrb        r3, [sp, #8]
  0018c	e58d3028	 str         r3, [sp, #0x28]
  00190	e59d0028	 ldr         r0, [sp, #0x28]
  00194	eb000000	 bl          SOCGetGPIODeviceByBank
  00198	e58d002c	 str         r0, [sp, #0x2C]
  0019c	e59d302c	 ldr         r3, [sp, #0x2C]
  001a0	e3730001	 cmn         r3, #1
  001a4	e5dd3008	 ldrb        r3, [sp, #8]
  001a8	e2833001	 add         r3, r3, #1
  001ac	e20330ff	 and         r3, r3, #0xFF
  001b0	e5cd3008	 strb        r3, [sp, #8]
  001b4	0a000007	 beq         |$LN9@OmapGpioIn|

; 255  :     {
; 256  :         pDevice->nbBanks++;

  001b8	e59d3000	 ldr         r3, [sp]
  001bc	e2833004	 add         r3, r3, #4
  001c0	e5933000	 ldr         r3, [r3]
  001c4	e2832001	 add         r2, r3, #1
  001c8	e59d3000	 ldr         r3, [sp]
  001cc	e2833004	 add         r3, r3, #4
  001d0	e5832000	 str         r2, [r3]

; 257  :     }

  001d4	eaffffeb	 b           |$LN10@OmapGpioIn|
  001d8		 |$LN9@OmapGpioIn|

; 258  :     // Allocate the bank structure
; 259  :     pDevice->bank = (OmapGpioBank_t*) LocalAlloc(LPTR,sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  001d8	e59d3000	 ldr         r3, [sp]
  001dc	e2833004	 add         r3, r3, #4
  001e0	e5932000	 ldr         r2, [r3]
  001e4	e3a03020	 mov         r3, #0x20
  001e8	e0010392	 mul         r1, r2, r3
  001ec	e3a00040	 mov         r0, #0x40
  001f0	eb000000	 bl          OALLocalAlloc
  001f4	e58d0030	 str         r0, [sp, #0x30]
  001f8	e59d3000	 ldr         r3, [sp]
  001fc	e283200c	 add         r2, r3, #0xC
  00200	e59d3030	 ldr         r3, [sp, #0x30]
  00204	e5823000	 str         r3, [r2]

; 260  :     if (pDevice->bank == NULL)

  00208	e59d3000	 ldr         r3, [sp]
  0020c	e283300c	 add         r3, r3, #0xC
  00210	e5933000	 ldr         r3, [r3]
  00214	e3530000	 cmp         r3, #0
  00218	1a00000c	 bne         |$LN8@OmapGpioIn|

; 261  :     {
; 262  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 263  :             L"Failed allocate GPIO driver bank structures\r\n"
; 264  :             ));

  0021c	e59f324c	 ldr         r3, [pc, #0x24C]
  00220	e5933440	 ldr         r3, [r3, #0x440]
  00224	e3130001	 tst         r3, #1
  00228	0a000004	 beq         |$LN19@OmapGpioIn|
  0022c	e59f0244	 ldr         r0, [pc, #0x244]
  00230	eb000000	 bl          NKDbgPrintfW
  00234	e3a03001	 mov         r3, #1
  00238	e58d3034	 str         r3, [sp, #0x34]
  0023c	ea000001	 b           |$LN20@OmapGpioIn|
  00240		 |$LN19@OmapGpioIn|
  00240	e3a03000	 mov         r3, #0
  00244	e58d3034	 str         r3, [sp, #0x34]
  00248		 |$LN20@OmapGpioIn|

; 265  :         goto cleanUp;

  00248	ea000071	 b           |$LN7@OmapGpioIn|
  0024c	ea000070	 b           |$cleanUp$37095|
  00250		 |$LN8@OmapGpioIn|

; 266  :     }
; 267  :     memset(pDevice->bank, 0, sizeof(OmapGpioBank_t)*pDevice->nbBanks);

  00250	e59d3000	 ldr         r3, [sp]
  00254	e2833004	 add         r3, r3, #4
  00258	e5931000	 ldr         r1, [r3]
  0025c	e3a03020	 mov         r3, #0x20
  00260	e0020391	 mul         r2, r1, r3
  00264	e3a01000	 mov         r1, #0
  00268	e59d3000	 ldr         r3, [sp]
  0026c	e283300c	 add         r3, r3, #0xC
  00270	e5930000	 ldr         r0, [r3]
  00274	eb000000	 bl          memset

; 268  : 
; 269  :     for (i = 0; i < pDevice->nbBanks; i++)

  00278	e3a03000	 mov         r3, #0
  0027c	e5cd3008	 strb        r3, [sp, #8]
  00280	ea000003	 b           |$LN6@OmapGpioIn|
  00284		 |$LN5@OmapGpioIn|
  00284	e5dd3008	 ldrb        r3, [sp, #8]
  00288	e2833001	 add         r3, r3, #1
  0028c	e20330ff	 and         r3, r3, #0xFF
  00290	e5cd3008	 strb        r3, [sp, #8]
  00294		 |$LN6@OmapGpioIn|
  00294	e5dd2008	 ldrb        r2, [sp, #8]
  00298	e59d3000	 ldr         r3, [sp]
  0029c	e2833004	 add         r3, r3, #4
  002a0	e5933000	 ldr         r3, [r3]
  002a4	e1520003	 cmp         r2, r3
  002a8	2a00004d	 bcs         |$LN4@OmapGpioIn|

; 270  :     {
; 271  :         // Get device clock
; 272  :         pDevice->bank[i].DeviceID = SOCGetGPIODeviceByBank(i+1);

  002ac	e5dd3008	 ldrb        r3, [sp, #8]
  002b0	e2830001	 add         r0, r3, #1
  002b4	eb000000	 bl          SOCGetGPIODeviceByBank
  002b8	e58d0038	 str         r0, [sp, #0x38]
  002bc	e59d3000	 ldr         r3, [sp]
  002c0	e283000c	 add         r0, r3, #0xC
  002c4	e5dd3008	 ldrb        r3, [sp, #8]
  002c8	e1a01003	 mov         r1, r3
  002cc	e3a03020	 mov         r3, #0x20
  002d0	e0020391	 mul         r2, r1, r3
  002d4	e5903000	 ldr         r3, [r0]
  002d8	e0833002	 add         r3, r3, r2
  002dc	e283201c	 add         r2, r3, #0x1C
  002e0	e59d3038	 ldr         r3, [sp, #0x38]
  002e4	e5823000	 str         r3, [r2]

; 273  :         // Map GPIO registers  
; 274  :         pa.QuadPart = GetAddressByDevice(pDevice->bank[i].DeviceID);

  002e8	e59d3000	 ldr         r3, [sp]
  002ec	e283000c	 add         r0, r3, #0xC
  002f0	e5dd3008	 ldrb        r3, [sp, #8]
  002f4	e1a01003	 mov         r1, r3
  002f8	e3a03020	 mov         r3, #0x20
  002fc	e0020391	 mul         r2, r1, r3
  00300	e5903000	 ldr         r3, [r0]
  00304	e0833002	 add         r3, r3, r2
  00308	e283301c	 add         r3, r3, #0x1C
  0030c	e5930000	 ldr         r0, [r3]
  00310	eb000000	 bl          GetAddressByDevice
  00314	e58d003c	 str         r0, [sp, #0x3C]
  00318	e59d303c	 ldr         r3, [sp, #0x3C]
  0031c	e58d3010	 str         r3, [sp, #0x10]
  00320	e3a03000	 mov         r3, #0
  00324	e58d3014	 str         r3, [sp, #0x14]

; 275  :         size = sizeof(OMAP_GPIO_REGS);

  00328	e3a030a0	 mov         r3, #0xA0
  0032c	e58d300c	 str         r3, [sp, #0xC]

; 276  :         pDevice->bank[i].ppGpioRegs = (OMAP_GPIO_REGS*)MmMapIoSpace(pa, size, FALSE);

  00330	e3a03000	 mov         r3, #0
  00334	e59d200c	 ldr         r2, [sp, #0xC]
  00338	e59d0010	 ldr         r0, [sp, #0x10]
  0033c	e59d1014	 ldr         r1, [sp, #0x14]
  00340	eb000000	 bl          MmMapIoSpace
  00344	e58d0040	 str         r0, [sp, #0x40]
  00348	e59d3000	 ldr         r3, [sp]
  0034c	e283000c	 add         r0, r3, #0xC
  00350	e5dd3008	 ldrb        r3, [sp, #8]
  00354	e1a01003	 mov         r1, r3
  00358	e3a03020	 mov         r3, #0x20
  0035c	e0020391	 mul         r2, r1, r3
  00360	e5903000	 ldr         r3, [r0]
  00364	e0833002	 add         r3, r3, r2
  00368	e2832018	 add         r2, r3, #0x18
  0036c	e59d3040	 ldr         r3, [sp, #0x40]
  00370	e5823000	 str         r3, [r2]

; 277  :         if (pDevice->bank[i].ppGpioRegs == NULL)

  00374	e59d3000	 ldr         r3, [sp]
  00378	e283000c	 add         r0, r3, #0xC
  0037c	e5dd3008	 ldrb        r3, [sp, #8]
  00380	e1a01003	 mov         r1, r3
  00384	e3a03020	 mov         r3, #0x20
  00388	e0020391	 mul         r2, r1, r3
  0038c	e5903000	 ldr         r3, [r0]
  00390	e0833002	 add         r3, r3, r2
  00394	e2833018	 add         r3, r3, #0x18
  00398	e5933000	 ldr         r3, [r3]
  0039c	e3530000	 cmp         r3, #0
  003a0	1a00000e	 bne         |$LN3@OmapGpioIn|

; 278  :         {
; 279  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioInit: "
; 280  :                 L"Failed map GIO%d controller registers\r\n",i
; 281  :                 ));

  003a4	e59f30c4	 ldr         r3, [pc, #0xC4]
  003a8	e5933440	 ldr         r3, [r3, #0x440]
  003ac	e3130001	 tst         r3, #1
  003b0	0a000006	 beq         |$LN21@OmapGpioIn|
  003b4	e5dd3008	 ldrb        r3, [sp, #8]
  003b8	e1a01003	 mov         r1, r3
  003bc	e59f00b0	 ldr         r0, [pc, #0xB0]
  003c0	eb000000	 bl          NKDbgPrintfW
  003c4	e3a03001	 mov         r3, #1
  003c8	e58d3044	 str         r3, [sp, #0x44]
  003cc	ea000001	 b           |$LN22@OmapGpioIn|
  003d0		 |$LN21@OmapGpioIn|
  003d0	e3a03000	 mov         r3, #0
  003d4	e58d3044	 str         r3, [sp, #0x44]
  003d8		 |$LN22@OmapGpioIn|

; 282  :             goto cleanUp;

  003d8	ea00000d	 b           |$LN2@OmapGpioIn|
  003dc	ea00000c	 b           |$cleanUp$37095|
  003e0		 |$LN3@OmapGpioIn|

; 283  :         }
; 284  :     }

  003e0	eaffffa7	 b           |$LN5@OmapGpioIn|
  003e4		 |$LN4@OmapGpioIn|

; 285  : 
; 286  :     // indicate gpio registers need to be saved for OFF mode
; 287  :     HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  003e4	e3a00001	 mov         r0, #1
  003e8	eb000000	 bl          HalContextUpdateDirtyRegister

; 288  : 
; 289  :     // Return non-null value
; 290  :     rc = TRUE;

  003ec	e3a03001	 mov         r3, #1
  003f0	e58d3004	 str         r3, [sp, #4]

; 291  :     *phContext = (HANDLE)pDevice;

  003f4	e59d2000	 ldr         r2, [sp]
  003f8	e59d3058	 ldr         r3, [sp, #0x58]
  003fc	e5832000	 str         r2, [r3]

; 292  :     *pGpioCount = pDevice->nbBanks;

  00400	e59d3000	 ldr         r3, [sp]
  00404	e2833004	 add         r3, r3, #4
  00408	e5932000	 ldr         r2, [r3]
  0040c	e59d305c	 ldr         r3, [sp, #0x5C]
  00410	e5832000	 str         r2, [r3]
  00414		 |$LN2@OmapGpioIn|
  00414		 |$LN7@OmapGpioIn|
  00414		 |$LN11@OmapGpioIn|
  00414		 |$cleanUp$37095|

; 293  : 
; 294  : cleanUp:
; 295  :     if (rc == FALSE) OmapGpioDeinit((HANDLE)pDevice);

  00414	e59d3004	 ldr         r3, [sp, #4]
  00418	e3530000	 cmp         r3, #0
  0041c	1a000001	 bne         |$LN1@OmapGpioIn|
  00420	e59d0000	 ldr         r0, [sp]
  00424	eb000000	 bl          |?OmapGpioDeinit@@YAHPAX@Z|
  00428		 |$LN1@OmapGpioIn|

; 296  :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioInit()\r\n"));

  00428	e59f3040	 ldr         r3, [pc, #0x40]
  0042c	e5933440	 ldr         r3, [r3, #0x440]
  00430	e3130004	 tst         r3, #4
  00434	0a000004	 beq         |$LN23@OmapGpioIn|
  00438	e59f002c	 ldr         r0, [pc, #0x2C]
  0043c	eb000000	 bl          NKDbgPrintfW
  00440	e3a03001	 mov         r3, #1
  00444	e58d3048	 str         r3, [sp, #0x48]
  00448	ea000001	 b           |$LN24@OmapGpioIn|
  0044c		 |$LN23@OmapGpioIn|
  0044c	e3a03000	 mov         r3, #0
  00450	e58d3048	 str         r3, [sp, #0x48]
  00454		 |$LN24@OmapGpioIn|

; 297  :     return rc;

  00454	e59d3004	 ldr         r3, [sp, #4]
  00458	e58d3018	 str         r3, [sp, #0x18]

; 298  : }

  0045c	e59d0018	 ldr         r0, [sp, #0x18]
  00460	e28dd04c	 add         sp, sp, #0x4C
  00464	e89d6000	 ldmia       sp, {sp, lr}
  00468	e12fff1e	 bx          lr
  0046c		 |$LN28@OmapGpioIn|
  0046c		 |$LN29@OmapGpioIn|
  0046c	00000000	 DCD         |??_C@_1CE@FNDIPNHI@?$AA?9?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00470		 |$LN30@OmapGpioIn|
  00470	00000000	 DCD         |dpCurSettings|
  00474		 |$LN31@OmapGpioIn|
  00474	00000000	 DCD         |??_C@_1HK@BGHMENPJ@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAm?$AAa?$AAp?$AA?5@|
  00478		 |$LN32@OmapGpioIn|
  00478	00000000	 DCD         |??_C@_1IG@ILLLDEBG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo@|
  0047c		 |$LN33@OmapGpioIn|
  0047c	11223344	 DCD         0x11223344
  00480		 |$LN34@OmapGpioIn|
  00480	00000000	 DCD         |??_C@_1HK@EBHBEPLH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAa?$AAl?$AAl?$AAo@|
  00484		 |$LN35@OmapGpioIn|
  00484	00000000	 DCD         |??_C@_1CI@NPLPGPH@?$AA?$CL?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAI?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CF?$AAs?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00488		 |$M37400|

			 ENDP  ; |?OmapGpioInit@@YAHPBGPAPAXPAI@Z|, OmapGpioInit

	IMPORT	|InitializeCriticalSection|

  00010			 AREA	 |.pdata|, PDATA
|$T37416| DCD	|$LN8@OmapGpioPo|
	DCD	0x40002804
; Function compile flags: /Odtp

  00488			 AREA	 |.text|, CODE, ARM

  00488		 |?OmapGpioPostInit@@YAHPAX@Z| PROC	; OmapGpioPostInit

; 306  : {

  00488		 |$LN8@OmapGpioPo|
  00488	e1a0c00d	 mov         r12, sp
  0048c	e92d0001	 stmdb       sp!, {r0}
  00490	e92d5000	 stmdb       sp!, {r12, lr}
  00494	e24dd00c	 sub         sp, sp, #0xC
  00498		 |$M37413|

; 307  :     UINT8 i;
; 308  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)hContext;

  00498	e59d3014	 ldr         r3, [sp, #0x14]
  0049c	e58d3000	 str         r3, [sp]

; 309  : 
; 310  :     // Initialize critical sections
; 311  :     for (i = 0; i < pDevice->nbBanks; i++)

  004a0	e3a03000	 mov         r3, #0
  004a4	e5cd3004	 strb        r3, [sp, #4]
  004a8	ea000003	 b           |$LN3@OmapGpioPo|
  004ac		 |$LN2@OmapGpioPo|
  004ac	e5dd3004	 ldrb        r3, [sp, #4]
  004b0	e2833001	 add         r3, r3, #1
  004b4	e20330ff	 and         r3, r3, #0xFF
  004b8	e5cd3004	 strb        r3, [sp, #4]
  004bc		 |$LN3@OmapGpioPo|
  004bc	e5dd2004	 ldrb        r2, [sp, #4]
  004c0	e59d3000	 ldr         r3, [sp]
  004c4	e2833004	 add         r3, r3, #4
  004c8	e5933000	 ldr         r3, [r3]
  004cc	e1520003	 cmp         r2, r3
  004d0	2a00000a	 bcs         |$LN1@OmapGpioPo|

; 312  :     {
; 313  :         InitializeCriticalSection(&pDevice->bank[i].pCs);

  004d4	e59d3000	 ldr         r3, [sp]
  004d8	e283000c	 add         r0, r3, #0xC
  004dc	e5dd3004	 ldrb        r3, [sp, #4]
  004e0	e1a01003	 mov         r1, r3
  004e4	e3a03020	 mov         r3, #0x20
  004e8	e0020391	 mul         r2, r1, r3
  004ec	e5903000	 ldr         r3, [r0]
  004f0	e0833002	 add         r3, r3, r2
  004f4	e2830004	 add         r0, r3, #4
  004f8	eb000000	 bl          InitializeCriticalSection

; 314  :     }

  004fc	eaffffea	 b           |$LN2@OmapGpioPo|
  00500		 |$LN1@OmapGpioPo|

; 315  :     pDevice->fPostInit = TRUE;

  00500	e59d3000	 ldr         r3, [sp]
  00504	e2832008	 add         r2, r3, #8
  00508	e3a03001	 mov         r3, #1
  0050c	e5823000	 str         r3, [r2]

; 316  :     return TRUE;

  00510	e3a03001	 mov         r3, #1
  00514	e58d3008	 str         r3, [sp, #8]

; 317  : }

  00518	e59d0008	 ldr         r0, [sp, #8]
  0051c	e28dd00c	 add         sp, sp, #0xC
  00520	e89d6000	 ldmia       sp, {sp, lr}
  00524	e12fff1e	 bx          lr
  00528		 |$M37414|

			 ENDP  ; |?OmapGpioPostInit@@YAHPAX@Z|, OmapGpioPostInit

	EXPORT	|??_C@_1CI@LADCCELG@?$AA?9?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GK@MMGIENMG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@ODGFHIHK@?$AA?$CL?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OALLocalFree|
	IMPORT	|MmUnmapIoSpace|
	IMPORT	|DeleteCriticalSection|

  00018			 AREA	 |.pdata|, PDATA
|$T37428| DCD	|$LN22@OmapGpioDe|
	DCD	0x40008e04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@LADCCELG@?$AA?9?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "(", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GK@MMGIENMG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n"
	DCB	0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, " ", 0x0, "p", 0x0, "a"
	DCB	0x0, "r", 0x0, "a", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e"
	DCB	0x0, "r", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@ODGFHIHK@?$AA?$CL?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "D", 0x0, "e", 0x0, "i", 0x0, "n"
	DCB	0x0, "i", 0x0, "t", 0x0, "(", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "0", 0x0, "8", 0x0, "x", 0x0, ")", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00528			 AREA	 |.text|, CODE, ARM

  00528		 |?OmapGpioDeinit@@YAHPAX@Z| PROC	; OmapGpioDeinit

; 328  : {

  00528		 |$LN22@OmapGpioDe|
  00528	e1a0c00d	 mov         r12, sp
  0052c	e92d0001	 stmdb       sp!, {r0}
  00530	e92d5000	 stmdb       sp!, {r12, lr}
  00534	e24dd020	 sub         sp, sp, #0x20
  00538		 |$M37425|

; 329  :     BOOL rc = FALSE;

  00538	e3a03000	 mov         r3, #0
  0053c	e58d3004	 str         r3, [sp, #4]

; 330  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;

  00540	e59d3028	 ldr         r3, [sp, #0x28]
  00544	e58d3000	 str         r3, [sp]

; 331  :     UINT8 i = 0;

  00548	e3a03000	 mov         r3, #0
  0054c	e5cd3008	 strb        r3, [sp, #8]

; 332  : 
; 333  :     DEBUGMSG(ZONE_FUNCTION, (L"+OmapGpioDeinit(0x%08x)\r\n", context));

  00550	e59f31f8	 ldr         r3, [pc, #0x1F8]
  00554	e5933440	 ldr         r3, [r3, #0x440]
  00558	e3130004	 tst         r3, #4
  0055c	0a000005	 beq         |$LN14@OmapGpioDe|
  00560	e59d1028	 ldr         r1, [sp, #0x28]
  00564	e59f01f0	 ldr         r0, [pc, #0x1F0]
  00568	eb000000	 bl          NKDbgPrintfW
  0056c	e3a03001	 mov         r3, #1
  00570	e58d3014	 str         r3, [sp, #0x14]
  00574	ea000001	 b           |$LN15@OmapGpioDe|
  00578		 |$LN14@OmapGpioDe|
  00578	e3a03000	 mov         r3, #0
  0057c	e58d3014	 str         r3, [sp, #0x14]
  00580		 |$LN15@OmapGpioDe|

; 334  : 
; 335  :     // Check if we get correct context
; 336  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00580	e59d3000	 ldr         r3, [sp]
  00584	e3530000	 cmp         r3, #0
  00588	0a000004	 beq         |$LN10@OmapGpioDe|
  0058c	e59d3000	 ldr         r3, [sp]
  00590	e5932000	 ldr         r2, [r3]
  00594	e59f31bc	 ldr         r3, [pc, #0x1BC]
  00598	e1520003	 cmp         r2, r3
  0059c	0a00000c	 beq         |$LN11@OmapGpioDe|
  005a0		 |$LN10@OmapGpioDe|

; 337  :     {
; 338  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: OmapGpioDeinit: "
; 339  :             L"Incorrect context parameter\r\n"
; 340  :             ));

  005a0	e59f31a8	 ldr         r3, [pc, #0x1A8]
  005a4	e5933440	 ldr         r3, [r3, #0x440]
  005a8	e3130001	 tst         r3, #1
  005ac	0a000004	 beq         |$LN16@OmapGpioDe|
  005b0	e59f019c	 ldr         r0, [pc, #0x19C]
  005b4	eb000000	 bl          NKDbgPrintfW
  005b8	e3a03001	 mov         r3, #1
  005bc	e58d3018	 str         r3, [sp, #0x18]
  005c0	ea000001	 b           |$LN17@OmapGpioDe|
  005c4		 |$LN16@OmapGpioDe|
  005c4	e3a03000	 mov         r3, #0
  005c8	e58d3018	 str         r3, [sp, #0x18]
  005cc		 |$LN17@OmapGpioDe|

; 341  :         goto cleanUp;

  005cc	ea00004d	 b           |$LN9@OmapGpioDe|
  005d0	ea00004c	 b           |$cleanUp$37145|
  005d4		 |$LN11@OmapGpioDe|

; 342  :     }
; 343  : 
; 344  :     // Delete critical sections
; 345  :     if (pDevice->fPostInit)

  005d4	e59d3000	 ldr         r3, [sp]
  005d8	e2833008	 add         r3, r3, #8
  005dc	e5933000	 ldr         r3, [r3]
  005e0	e3530000	 cmp         r3, #0
  005e4	0a000017	 beq         |$LN8@OmapGpioDe|

; 346  :     {
; 347  :         for (i = 0; i < pDevice->nbBanks; i++)

  005e8	e3a03000	 mov         r3, #0
  005ec	e5cd3008	 strb        r3, [sp, #8]
  005f0	ea000003	 b           |$LN7@OmapGpioDe|
  005f4		 |$LN6@OmapGpioDe|
  005f4	e5dd3008	 ldrb        r3, [sp, #8]
  005f8	e2833001	 add         r3, r3, #1
  005fc	e20330ff	 and         r3, r3, #0xFF
  00600	e5cd3008	 strb        r3, [sp, #8]
  00604		 |$LN7@OmapGpioDe|
  00604	e5dd2008	 ldrb        r2, [sp, #8]
  00608	e59d3000	 ldr         r3, [sp]
  0060c	e2833004	 add         r3, r3, #4
  00610	e5933000	 ldr         r3, [r3]
  00614	e1520003	 cmp         r2, r3
  00618	2a00000a	 bcs         |$LN5@OmapGpioDe|

; 348  :             DeleteCriticalSection(&pDevice->bank[i].pCs);

  0061c	e59d3000	 ldr         r3, [sp]
  00620	e283000c	 add         r0, r3, #0xC
  00624	e5dd3008	 ldrb        r3, [sp, #8]
  00628	e1a01003	 mov         r1, r3
  0062c	e3a03020	 mov         r3, #0x20
  00630	e0020391	 mul         r2, r1, r3
  00634	e5903000	 ldr         r3, [r0]
  00638	e0833002	 add         r3, r3, r2
  0063c	e2830004	 add         r0, r3, #4
  00640	eb000000	 bl          DeleteCriticalSection
  00644	eaffffea	 b           |$LN6@OmapGpioDe|
  00648		 |$LN5@OmapGpioDe|
  00648		 |$LN8@OmapGpioDe|

; 349  :     }
; 350  :     // Unmap module registers
; 351  :     for (i = 0 ; i < pDevice->nbBanks; i++)

  00648	e3a03000	 mov         r3, #0
  0064c	e5cd3008	 strb        r3, [sp, #8]
  00650	ea000003	 b           |$LN4@OmapGpioDe|
  00654		 |$LN3@OmapGpioDe|
  00654	e5dd3008	 ldrb        r3, [sp, #8]
  00658	e2833001	 add         r3, r3, #1
  0065c	e20330ff	 and         r3, r3, #0xFF
  00660	e5cd3008	 strb        r3, [sp, #8]
  00664		 |$LN4@OmapGpioDe|
  00664	e5dd2008	 ldrb        r2, [sp, #8]
  00668	e59d3000	 ldr         r3, [sp]
  0066c	e2833004	 add         r3, r3, #4
  00670	e5933000	 ldr         r3, [r3]
  00674	e1520003	 cmp         r2, r3
  00678	2a00001a	 bcs         |$LN2@OmapGpioDe|

; 352  :     {
; 353  :         if (pDevice->bank[i].ppGpioRegs != NULL)

  0067c	e59d3000	 ldr         r3, [sp]
  00680	e283000c	 add         r0, r3, #0xC
  00684	e5dd3008	 ldrb        r3, [sp, #8]
  00688	e1a01003	 mov         r1, r3
  0068c	e3a03020	 mov         r3, #0x20
  00690	e0020391	 mul         r2, r1, r3
  00694	e5903000	 ldr         r3, [r0]
  00698	e0833002	 add         r3, r3, r2
  0069c	e2833018	 add         r3, r3, #0x18
  006a0	e5933000	 ldr         r3, [r3]
  006a4	e3530000	 cmp         r3, #0
  006a8	0a00000d	 beq         |$LN1@OmapGpioDe|

; 354  :         {
; 355  :             DWORD size = sizeof(OMAP_GPIO_REGS);

  006ac	e3a030a0	 mov         r3, #0xA0
  006b0	e58d300c	 str         r3, [sp, #0xC]

; 356  :             MmUnmapIoSpace((VOID*)pDevice->bank[i].ppGpioRegs, size);

  006b4	e59d100c	 ldr         r1, [sp, #0xC]
  006b8	e59d3000	 ldr         r3, [sp]
  006bc	e283e00c	 add         lr, r3, #0xC
  006c0	e5dd3008	 ldrb        r3, [sp, #8]
  006c4	e1a00003	 mov         r0, r3
  006c8	e3a03020	 mov         r3, #0x20
  006cc	e0020390	 mul         r2, r0, r3
  006d0	e59e3000	 ldr         r3, [lr]
  006d4	e0833002	 add         r3, r3, r2
  006d8	e2833018	 add         r3, r3, #0x18
  006dc	e5930000	 ldr         r0, [r3]
  006e0	eb000000	 bl          MmUnmapIoSpace
  006e4		 |$LN1@OmapGpioDe|

; 357  :         }
; 358  :     }

  006e4	eaffffda	 b           |$LN3@OmapGpioDe|
  006e8		 |$LN2@OmapGpioDe|

; 359  :     // Free banks structures    
; 360  :     LocalFree(pDevice->bank);

  006e8	e59d3000	 ldr         r3, [sp]
  006ec	e283300c	 add         r3, r3, #0xC
  006f0	e5930000	 ldr         r0, [r3]
  006f4	eb000000	 bl          OALLocalFree

; 361  : 
; 362  :     // Free device structure
; 363  :     LocalFree(pDevice);

  006f8	e59d0000	 ldr         r0, [sp]
  006fc	eb000000	 bl          OALLocalFree

; 364  : 
; 365  :     // Done
; 366  :     rc = TRUE;

  00700	e3a03001	 mov         r3, #1
  00704	e58d3004	 str         r3, [sp, #4]
  00708		 |$LN9@OmapGpioDe|
  00708		 |$cleanUp$37145|

; 367  : 
; 368  : cleanUp:
; 369  :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioDeinit()\r\n"));

  00708	e59f3040	 ldr         r3, [pc, #0x40]
  0070c	e5933440	 ldr         r3, [r3, #0x440]
  00710	e3130004	 tst         r3, #4
  00714	0a000004	 beq         |$LN18@OmapGpioDe|
  00718	e59f002c	 ldr         r0, [pc, #0x2C]
  0071c	eb000000	 bl          NKDbgPrintfW
  00720	e3a03001	 mov         r3, #1
  00724	e58d301c	 str         r3, [sp, #0x1C]
  00728	ea000001	 b           |$LN19@OmapGpioDe|
  0072c		 |$LN18@OmapGpioDe|
  0072c	e3a03000	 mov         r3, #0
  00730	e58d301c	 str         r3, [sp, #0x1C]
  00734		 |$LN19@OmapGpioDe|

; 370  :     return rc;

  00734	e59d3004	 ldr         r3, [sp, #4]
  00738	e58d3010	 str         r3, [sp, #0x10]

; 371  : }

  0073c	e59d0010	 ldr         r0, [sp, #0x10]
  00740	e28dd020	 add         sp, sp, #0x20
  00744	e89d6000	 ldmia       sp, {sp, lr}
  00748	e12fff1e	 bx          lr
  0074c		 |$LN23@OmapGpioDe|
  0074c		 |$LN24@OmapGpioDe|
  0074c	00000000	 DCD         |??_C@_1CI@LADCCELG@?$AA?9?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00750		 |$LN25@OmapGpioDe|
  00750	00000000	 DCD         |dpCurSettings|
  00754		 |$LN26@OmapGpioDe|
  00754	00000000	 DCD         |??_C@_1GK@MMGIENMG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@|
  00758		 |$LN27@OmapGpioDe|
  00758	11223344	 DCD         0x11223344
  0075c		 |$LN28@OmapGpioDe|
  0075c	00000000	 DCD         |??_C@_1DE@ODGFHIHK@?$AA?$CL?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAD?$AAe?$AAi?$AAn?$AAi?$AAt?$AA?$CI?$AA0?$AAx?$AA?$CF?$AA0?$AA8?$AAx?$AA?$CJ?$AA?$AN?$AA?6?$AA?$AA@|
  00760		 |$M37426|

			 ENDP  ; |?OmapGpioDeinit@@YAHPAX@Z|, OmapGpioDeinit

	EXPORT	|??_C@_1FI@OBNBHIPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAS?$AAe?$AAt?$AAM?$AAo?$AAd?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc@| [ DATA ] ; `string'
	IMPORT	|LeaveCriticalSection|
	IMPORT	|EnterCriticalSection|

  00020			 AREA	 |.pdata|, PDATA
|$T37442| DCD	|$LN25@OmapGpioSe|
	DCD	0x4000e304

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@OBNBHIPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAS?$AAe?$AAt?$AAM?$AAo?$AAd?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "S", 0x0, "e", 0x0, "t", 0x0, "M"
	DCB	0x0, "o", 0x0, "d", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "I"
	DCB	0x0, "n", 0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "x", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00760			 AREA	 |.text|, CODE, ARM

  00760		 |?OmapGpioSetMode@@YAHPAXII@Z| PROC	; OmapGpioSetMode

; 384  : {

  00760		 |$LN25@OmapGpioSe|
  00760	e1a0c00d	 mov         r12, sp
  00764	e92d0007	 stmdb       sp!, {r0 - r2}
  00768	e92d5000	 stmdb       sp!, {r12, lr}
  0076c	e24dd024	 sub         sp, sp, #0x24
  00770		 |$M37439|

; 385  :     BOOL rc = FALSE;

  00770	e3a03000	 mov         r3, #0
  00774	e58d3004	 str         r3, [sp, #4]

; 386  :     UINT bit = GPIO_BIT(id);

  00778	e59d3030	 ldr         r3, [sp, #0x30]
  0077c	e203301f	 and         r3, r3, #0x1F
  00780	e58d300c	 str         r3, [sp, #0xC]

; 387  :     UINT bank = GPIO_BANK(id);

  00784	e59d3030	 ldr         r3, [sp, #0x30]
  00788	e1a032a3	 mov         r3, r3, lsr #5
  0078c	e58d3008	 str         r3, [sp, #8]

; 388  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;

  00790	e59d302c	 ldr         r3, [sp, #0x2C]
  00794	e58d3000	 str         r3, [sp]

; 389  : 
; 390  :     // Check if we get correct context
; 391  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00798	e59d3000	 ldr         r3, [sp]
  0079c	e3530000	 cmp         r3, #0
  007a0	0a000004	 beq         |$LN17@OmapGpioSe|
  007a4	e59d3000	 ldr         r3, [sp]
  007a8	e5932000	 ldr         r2, [r3]
  007ac	e59f3334	 ldr         r3, [pc, #0x334]
  007b0	e1520003	 cmp         r2, r3
  007b4	0a00000c	 beq         |$LN18@OmapGpioSe|
  007b8		 |$LN17@OmapGpioSe|

; 392  :     {
; 393  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioSetMode: "
; 394  :             L"Incorrect context\r\n"
; 395  :             ));

  007b8	e59f3324	 ldr         r3, [pc, #0x324]
  007bc	e5933440	 ldr         r3, [r3, #0x440]
  007c0	e3130001	 tst         r3, #1
  007c4	0a000004	 beq         |$LN21@OmapGpioSe|
  007c8	e59f0310	 ldr         r0, [pc, #0x310]
  007cc	eb000000	 bl          NKDbgPrintfW
  007d0	e3a03001	 mov         r3, #1
  007d4	e58d3020	 str         r3, [sp, #0x20]
  007d8	ea000001	 b           |$LN22@OmapGpioSe|
  007dc		 |$LN21@OmapGpioSe|
  007dc	e3a03000	 mov         r3, #0
  007e0	e58d3020	 str         r3, [sp, #0x20]
  007e4		 |$LN22@OmapGpioSe|

; 396  :         goto cleanUp;

  007e4	ea0000b7	 b           |$LN16@OmapGpioSe|
  007e8	ea0000b6	 b           |$cleanUp$37174|
  007ec		 |$LN18@OmapGpioSe|

; 397  :     }
; 398  : 
; 399  :     if (id < pDevice->nbBanks*32)

  007ec	e59d3000	 ldr         r3, [sp]
  007f0	e2833004	 add         r3, r3, #4
  007f4	e5931000	 ldr         r1, [r3]
  007f8	e3a03020	 mov         r3, #0x20
  007fc	e0020391	 mul         r2, r1, r3
  00800	e59d3030	 ldr         r3, [sp, #0x30]
  00804	e1530002	 cmp         r3, r2
  00808	2a0000ae	 bcs         |$LN15@OmapGpioSe|

; 400  :     {
; 401  :         UINT32 mask = 1 << (bit);

  0080c	e59d200c	 ldr         r2, [sp, #0xC]
  00810	e3a03001	 mov         r3, #1
  00814	e1a03213	 mov         r3, r3, lsl r2
  00818	e58d3014	 str         r3, [sp, #0x14]

; 402  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  0081c	e59d3000	 ldr         r3, [sp]
  00820	e283000c	 add         r0, r3, #0xC
  00824	e59d1008	 ldr         r1, [sp, #8]
  00828	e3a03020	 mov         r3, #0x20
  0082c	e0020391	 mul         r2, r1, r3
  00830	e5903000	 ldr         r3, [r0]
  00834	e0833002	 add         r3, r3, r2
  00838	e2833004	 add         r3, r3, #4
  0083c	e58d3010	 str         r3, [sp, #0x10]

; 403  :         OMAP_GPIO_REGS *pGpio = pDevice->bank[bank].ppGpioRegs;

  00840	e59d3000	 ldr         r3, [sp]
  00844	e283000c	 add         r0, r3, #0xC
  00848	e59d1008	 ldr         r1, [sp, #8]
  0084c	e3a03020	 mov         r3, #0x20
  00850	e0020391	 mul         r2, r1, r3
  00854	e5903000	 ldr         r3, [r0]
  00858	e0833002	 add         r3, r3, r2
  0085c	e2833018	 add         r3, r3, #0x18
  00860	e5933000	 ldr         r3, [r3]
  00864	e58d3018	 str         r3, [sp, #0x18]

; 404  : 
; 405  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00868	e59d3000	 ldr         r3, [sp]
  0086c	e2833008	 add         r3, r3, #8
  00870	e5933000	 ldr         r3, [r3]
  00874	e3530000	 cmp         r3, #0
  00878	0a000001	 beq         |$LN14@OmapGpioSe|
  0087c	e59d0010	 ldr         r0, [sp, #0x10]
  00880	eb000000	 bl          EnterCriticalSection
  00884		 |$LN14@OmapGpioSe|

; 406  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00884	e3a02000	 mov         r2, #0
  00888	e59d1030	 ldr         r1, [sp, #0x30]
  0088c	e59d0000	 ldr         r0, [sp]
  00890	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 407  : 
; 408  :         // set gpio direction
; 409  :         if ((mode & GPIO_DIR_INPUT) != 0)

  00894	e59d3034	 ldr         r3, [sp, #0x34]
  00898	e3130001	 tst         r3, #1
  0089c	0a000008	 beq         |$LN13@OmapGpioSe|

; 410  :         {
; 411  :             SETREG32(&pGpio->OE, mask);

  008a0	e59d3018	 ldr         r3, [sp, #0x18]
  008a4	e2833034	 add         r3, r3, #0x34
  008a8	e5932000	 ldr         r2, [r3]
  008ac	e59d3014	 ldr         r3, [sp, #0x14]
  008b0	e1822003	 orr         r2, r2, r3
  008b4	e59d3018	 ldr         r3, [sp, #0x18]
  008b8	e2833034	 add         r3, r3, #0x34
  008bc	e5832000	 str         r2, [r3]

; 412  :         }
; 413  :         else

  008c0	ea000008	 b           |$LN12@OmapGpioSe|
  008c4		 |$LN13@OmapGpioSe|

; 414  :         {
; 415  :             CLRREG32(&pGpio->OE, mask);

  008c4	e59d3018	 ldr         r3, [sp, #0x18]
  008c8	e2831034	 add         r1, r3, #0x34
  008cc	e59d3014	 ldr         r3, [sp, #0x14]
  008d0	e1e02003	 mvn         r2, r3
  008d4	e5913000	 ldr         r3, [r1]
  008d8	e0032002	 and         r2, r3, r2
  008dc	e59d3018	 ldr         r3, [sp, #0x18]
  008e0	e2833034	 add         r3, r3, #0x34
  008e4	e5832000	 str         r2, [r3]
  008e8		 |$LN12@OmapGpioSe|

; 416  :         }
; 417  : 
; 418  :         // set debounce mode
; 419  :         if ((mode & GPIO_DEBOUNCE_ENABLE) != 0)

  008e8	e59d3034	 ldr         r3, [sp, #0x34]
  008ec	e3130020	 tst         r3, #0x20
  008f0	0a000008	 beq         |$LN11@OmapGpioSe|

; 420  :         {
; 421  :             SETREG32(&pGpio->DEBOUNCENABLE, mask);

  008f4	e59d3018	 ldr         r3, [sp, #0x18]
  008f8	e2833050	 add         r3, r3, #0x50
  008fc	e5932000	 ldr         r2, [r3]
  00900	e59d3014	 ldr         r3, [sp, #0x14]
  00904	e1822003	 orr         r2, r2, r3
  00908	e59d3018	 ldr         r3, [sp, #0x18]
  0090c	e2833050	 add         r3, r3, #0x50
  00910	e5832000	 str         r2, [r3]

; 422  :         }
; 423  :         else

  00914	ea000008	 b           |$LN10@OmapGpioSe|
  00918		 |$LN11@OmapGpioSe|

; 424  :         {
; 425  :             CLRREG32(&pGpio->DEBOUNCENABLE, mask);

  00918	e59d3018	 ldr         r3, [sp, #0x18]
  0091c	e2831050	 add         r1, r3, #0x50
  00920	e59d3014	 ldr         r3, [sp, #0x14]
  00924	e1e02003	 mvn         r2, r3
  00928	e5913000	 ldr         r3, [r1]
  0092c	e0032002	 and         r2, r3, r2
  00930	e59d3018	 ldr         r3, [sp, #0x18]
  00934	e2833050	 add         r3, r3, #0x50
  00938	e5832000	 str         r2, [r3]
  0093c		 |$LN10@OmapGpioSe|

; 426  :         }
; 427  : 
; 428  :         // set edge/level detect mode
; 429  :         if ((mode & GPIO_INT_LOW) != 0)

  0093c	e59d3034	 ldr         r3, [sp, #0x34]
  00940	e3130008	 tst         r3, #8
  00944	0a000008	 beq         |$LN9@OmapGpioSe|

; 430  :         {
; 431  :             SETREG32(&pGpio->LEVELDETECT0, mask);

  00948	e59d3018	 ldr         r3, [sp, #0x18]
  0094c	e2833040	 add         r3, r3, #0x40
  00950	e5932000	 ldr         r2, [r3]
  00954	e59d3014	 ldr         r3, [sp, #0x14]
  00958	e1822003	 orr         r2, r2, r3
  0095c	e59d3018	 ldr         r3, [sp, #0x18]
  00960	e2833040	 add         r3, r3, #0x40
  00964	e5832000	 str         r2, [r3]

; 432  :         }
; 433  :         else

  00968	ea000008	 b           |$LN8@OmapGpioSe|
  0096c		 |$LN9@OmapGpioSe|

; 434  :         {
; 435  :             CLRREG32(&pGpio->LEVELDETECT0, mask);

  0096c	e59d3018	 ldr         r3, [sp, #0x18]
  00970	e2831040	 add         r1, r3, #0x40
  00974	e59d3014	 ldr         r3, [sp, #0x14]
  00978	e1e02003	 mvn         r2, r3
  0097c	e5913000	 ldr         r3, [r1]
  00980	e0032002	 and         r2, r3, r2
  00984	e59d3018	 ldr         r3, [sp, #0x18]
  00988	e2833040	 add         r3, r3, #0x40
  0098c	e5832000	 str         r2, [r3]
  00990		 |$LN8@OmapGpioSe|

; 436  :         }
; 437  : 
; 438  :         if ((mode & GPIO_INT_HIGH) != 0)

  00990	e59d3034	 ldr         r3, [sp, #0x34]
  00994	e3130010	 tst         r3, #0x10
  00998	0a000008	 beq         |$LN7@OmapGpioSe|

; 439  :         {
; 440  :             SETREG32(&pGpio->LEVELDETECT1, mask);

  0099c	e59d3018	 ldr         r3, [sp, #0x18]
  009a0	e2833044	 add         r3, r3, #0x44
  009a4	e5932000	 ldr         r2, [r3]
  009a8	e59d3014	 ldr         r3, [sp, #0x14]
  009ac	e1822003	 orr         r2, r2, r3
  009b0	e59d3018	 ldr         r3, [sp, #0x18]
  009b4	e2833044	 add         r3, r3, #0x44
  009b8	e5832000	 str         r2, [r3]

; 441  :         }
; 442  :         else

  009bc	ea000008	 b           |$LN6@OmapGpioSe|
  009c0		 |$LN7@OmapGpioSe|

; 443  :         {
; 444  :             CLRREG32(&pGpio->LEVELDETECT1, mask);

  009c0	e59d3018	 ldr         r3, [sp, #0x18]
  009c4	e2831044	 add         r1, r3, #0x44
  009c8	e59d3014	 ldr         r3, [sp, #0x14]
  009cc	e1e02003	 mvn         r2, r3
  009d0	e5913000	 ldr         r3, [r1]
  009d4	e0032002	 and         r2, r3, r2
  009d8	e59d3018	 ldr         r3, [sp, #0x18]
  009dc	e2833044	 add         r3, r3, #0x44
  009e0	e5832000	 str         r2, [r3]
  009e4		 |$LN6@OmapGpioSe|

; 445  :         }
; 446  : 
; 447  :         if ((mode & GPIO_INT_LOW_HIGH) != 0)

  009e4	e59d3034	 ldr         r3, [sp, #0x34]
  009e8	e3130002	 tst         r3, #2
  009ec	0a000008	 beq         |$LN5@OmapGpioSe|

; 448  :         {
; 449  :             SETREG32(&pGpio->RISINGDETECT, mask);

  009f0	e59d3018	 ldr         r3, [sp, #0x18]
  009f4	e2833048	 add         r3, r3, #0x48
  009f8	e5932000	 ldr         r2, [r3]
  009fc	e59d3014	 ldr         r3, [sp, #0x14]
  00a00	e1822003	 orr         r2, r2, r3
  00a04	e59d3018	 ldr         r3, [sp, #0x18]
  00a08	e2833048	 add         r3, r3, #0x48
  00a0c	e5832000	 str         r2, [r3]

; 450  :         }
; 451  :         else

  00a10	ea000008	 b           |$LN4@OmapGpioSe|
  00a14		 |$LN5@OmapGpioSe|

; 452  :         {
; 453  :             CLRREG32(&pGpio->RISINGDETECT, mask);

  00a14	e59d3018	 ldr         r3, [sp, #0x18]
  00a18	e2831048	 add         r1, r3, #0x48
  00a1c	e59d3014	 ldr         r3, [sp, #0x14]
  00a20	e1e02003	 mvn         r2, r3
  00a24	e5913000	 ldr         r3, [r1]
  00a28	e0032002	 and         r2, r3, r2
  00a2c	e59d3018	 ldr         r3, [sp, #0x18]
  00a30	e2833048	 add         r3, r3, #0x48
  00a34	e5832000	 str         r2, [r3]
  00a38		 |$LN4@OmapGpioSe|

; 454  :         }
; 455  : 
; 456  :         if ((mode & GPIO_INT_HIGH_LOW) != 0)

  00a38	e59d3034	 ldr         r3, [sp, #0x34]
  00a3c	e3130004	 tst         r3, #4
  00a40	0a000008	 beq         |$LN3@OmapGpioSe|

; 457  :         {
; 458  :             SETREG32(&pGpio->FALLINGDETECT, mask);

  00a44	e59d3018	 ldr         r3, [sp, #0x18]
  00a48	e283304c	 add         r3, r3, #0x4C
  00a4c	e5932000	 ldr         r2, [r3]
  00a50	e59d3014	 ldr         r3, [sp, #0x14]
  00a54	e1822003	 orr         r2, r2, r3
  00a58	e59d3018	 ldr         r3, [sp, #0x18]
  00a5c	e283304c	 add         r3, r3, #0x4C
  00a60	e5832000	 str         r2, [r3]

; 459  :         }
; 460  :         else

  00a64	ea000008	 b           |$LN2@OmapGpioSe|
  00a68		 |$LN3@OmapGpioSe|

; 461  :         {
; 462  :             CLRREG32(&pGpio->FALLINGDETECT, mask);

  00a68	e59d3018	 ldr         r3, [sp, #0x18]
  00a6c	e283104c	 add         r1, r3, #0x4C
  00a70	e59d3014	 ldr         r3, [sp, #0x14]
  00a74	e1e02003	 mvn         r2, r3
  00a78	e5913000	 ldr         r3, [r1]
  00a7c	e0032002	 and         r2, r3, r2
  00a80	e59d3018	 ldr         r3, [sp, #0x18]
  00a84	e283304c	 add         r3, r3, #0x4C
  00a88	e5832000	 str         r2, [r3]
  00a8c		 |$LN2@OmapGpioSe|

; 463  :         }
; 464  : 
; 465  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00a8c	e3a02004	 mov         r2, #4
  00a90	e59d1030	 ldr         r1, [sp, #0x30]
  00a94	e59d0000	 ldr         r0, [sp]
  00a98	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 466  :         if (pDevice->fPostInit)LeaveCriticalSection(pCs);

  00a9c	e59d3000	 ldr         r3, [sp]
  00aa0	e2833008	 add         r3, r3, #8
  00aa4	e5933000	 ldr         r3, [r3]
  00aa8	e3530000	 cmp         r3, #0
  00aac	0a000001	 beq         |$LN1@OmapGpioSe|
  00ab0	e59d0010	 ldr         r0, [sp, #0x10]
  00ab4	eb000000	 bl          LeaveCriticalSection
  00ab8		 |$LN1@OmapGpioSe|

; 467  : 
; 468  :         // indicate gpio registers need to be saved for OFF mode
; 469  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00ab8	e3a00001	 mov         r0, #1
  00abc	eb000000	 bl          HalContextUpdateDirtyRegister

; 470  : 
; 471  :         rc = TRUE;

  00ac0	e3a03001	 mov         r3, #1
  00ac4	e58d3004	 str         r3, [sp, #4]
  00ac8		 |$LN15@OmapGpioSe|
  00ac8		 |$LN16@OmapGpioSe|
  00ac8		 |$cleanUp$37174|

; 472  :     }
; 473  : 
; 474  : cleanUp:
; 475  :     return rc;

  00ac8	e59d3004	 ldr         r3, [sp, #4]
  00acc	e58d301c	 str         r3, [sp, #0x1C]

; 476  : }

  00ad0	e59d001c	 ldr         r0, [sp, #0x1C]
  00ad4	e28dd024	 add         sp, sp, #0x24
  00ad8	e89d6000	 ldmia       sp, {sp, lr}
  00adc	e12fff1e	 bx          lr
  00ae0		 |$LN26@OmapGpioSe|
  00ae0		 |$LN27@OmapGpioSe|
  00ae0	00000000	 DCD         |??_C@_1FI@OBNBHIPM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAS?$AAe?$AAt?$AAM?$AAo?$AAd?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc@|
  00ae4		 |$LN28@OmapGpioSe|
  00ae4	00000000	 DCD         |dpCurSettings|
  00ae8		 |$LN29@OmapGpioSe|
  00ae8	11223344	 DCD         0x11223344
  00aec		 |$M37440|

			 ENDP  ; |?OmapGpioSetMode@@YAHPAXII@Z|, OmapGpioSetMode

	EXPORT	|??_C@_1FI@GGOKKMEH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAG?$AAe?$AAt?$AAM?$AAo?$AAd?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc@| [ DATA ] ; `string'

  00028			 AREA	 |.pdata|, PDATA
|$T37454| DCD	|$LN20@OmapGpioGe|
	DCD	0x40009c04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@GGOKKMEH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAG?$AAe?$AAt?$AAM?$AAo?$AAd?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "G", 0x0, "e", 0x0, "t", 0x0, "M"
	DCB	0x0, "o", 0x0, "d", 0x0, "e", 0x0, ":", 0x0, " ", 0x0, "I"
	DCB	0x0, "n", 0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e"
	DCB	0x0, "c", 0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "x", 0x0, "t", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'
; Function compile flags: /Odtp

  00aec			 AREA	 |.text|, CODE, ARM

  00aec		 |?OmapGpioGetMode@@YAKPAXI@Z| PROC	; OmapGpioGetMode

; 487  : {

  00aec		 |$LN20@OmapGpioGe|
  00aec	e1a0c00d	 mov         r12, sp
  00af0	e92d0003	 stmdb       sp!, {r0, r1}
  00af4	e92d5000	 stmdb       sp!, {r12, lr}
  00af8	e24dd024	 sub         sp, sp, #0x24
  00afc		 |$M37451|

; 488  :     DWORD mode = (DWORD) -1;

  00afc	e3e03000	 mvn         r3, #0
  00b00	e58d3004	 str         r3, [sp, #4]

; 489  :     UINT bit = GPIO_BIT(id);

  00b04	e59d3030	 ldr         r3, [sp, #0x30]
  00b08	e203301f	 and         r3, r3, #0x1F
  00b0c	e58d300c	 str         r3, [sp, #0xC]

; 490  :     UINT bank = GPIO_BANK(id);

  00b10	e59d3030	 ldr         r3, [sp, #0x30]
  00b14	e1a032a3	 mov         r3, r3, lsr #5
  00b18	e58d3008	 str         r3, [sp, #8]

; 491  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;

  00b1c	e59d302c	 ldr         r3, [sp, #0x2C]
  00b20	e58d3000	 str         r3, [sp]

; 492  : 
; 493  :     // Check if we get correct context
; 494  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00b24	e59d3000	 ldr         r3, [sp]
  00b28	e3530000	 cmp         r3, #0
  00b2c	0a000004	 beq         |$LN12@OmapGpioGe|
  00b30	e59d3000	 ldr         r3, [sp]
  00b34	e5932000	 ldr         r2, [r3]
  00b38	e59f3218	 ldr         r3, [pc, #0x218]
  00b3c	e1520003	 cmp         r2, r3
  00b40	0a00000c	 beq         |$LN13@OmapGpioGe|
  00b44		 |$LN12@OmapGpioGe|

; 495  :     {
; 496  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioGetMode: "
; 497  :             L"Incorrect context\r\n"
; 498  :             ));

  00b44	e59f3208	 ldr         r3, [pc, #0x208]
  00b48	e5933440	 ldr         r3, [r3, #0x440]
  00b4c	e3130001	 tst         r3, #1
  00b50	0a000004	 beq         |$LN16@OmapGpioGe|
  00b54	e59f01f4	 ldr         r0, [pc, #0x1F4]
  00b58	eb000000	 bl          NKDbgPrintfW
  00b5c	e3a03001	 mov         r3, #1
  00b60	e58d3020	 str         r3, [sp, #0x20]
  00b64	ea000001	 b           |$LN17@OmapGpioGe|
  00b68		 |$LN16@OmapGpioGe|
  00b68	e3a03000	 mov         r3, #0
  00b6c	e58d3020	 str         r3, [sp, #0x20]
  00b70		 |$LN17@OmapGpioGe|

; 499  :         goto cleanUp;

  00b70	ea000070	 b           |$LN11@OmapGpioGe|
  00b74	ea00006f	 b           |$cleanUp$37244|
  00b78		 |$LN13@OmapGpioGe|

; 500  :     }
; 501  : 
; 502  :     if (id < pDevice->nbBanks*32)

  00b78	e59d3000	 ldr         r3, [sp]
  00b7c	e2833004	 add         r3, r3, #4
  00b80	e5931000	 ldr         r1, [r3]
  00b84	e3a03020	 mov         r3, #0x20
  00b88	e0020391	 mul         r2, r1, r3
  00b8c	e59d3030	 ldr         r3, [sp, #0x30]
  00b90	e1530002	 cmp         r3, r2
  00b94	2a000067	 bcs         |$LN10@OmapGpioGe|

; 503  :     {
; 504  :         mode = 0;

  00b98	e3a03000	 mov         r3, #0
  00b9c	e58d3004	 str         r3, [sp, #4]

; 505  :         OMAP_GPIO_REGS *pGpio = pDevice->bank[bank].ppGpioRegs;

  00ba0	e59d3000	 ldr         r3, [sp]
  00ba4	e283000c	 add         r0, r3, #0xC
  00ba8	e59d1008	 ldr         r1, [sp, #8]
  00bac	e3a03020	 mov         r3, #0x20
  00bb0	e0020391	 mul         r2, r1, r3
  00bb4	e5903000	 ldr         r3, [r0]
  00bb8	e0833002	 add         r3, r3, r2
  00bbc	e2833018	 add         r3, r3, #0x18
  00bc0	e5933000	 ldr         r3, [r3]
  00bc4	e58d3018	 str         r3, [sp, #0x18]

; 506  :         UINT32 mask = 1 << (bit);

  00bc8	e59d200c	 ldr         r2, [sp, #0xC]
  00bcc	e3a03001	 mov         r3, #1
  00bd0	e1a03213	 mov         r3, r3, lsl r2
  00bd4	e58d3014	 str         r3, [sp, #0x14]

; 507  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  00bd8	e59d3000	 ldr         r3, [sp]
  00bdc	e283000c	 add         r0, r3, #0xC
  00be0	e59d1008	 ldr         r1, [sp, #8]
  00be4	e3a03020	 mov         r3, #0x20
  00be8	e0020391	 mul         r2, r1, r3
  00bec	e5903000	 ldr         r3, [r0]
  00bf0	e0833002	 add         r3, r3, r2
  00bf4	e2833004	 add         r3, r3, #4
  00bf8	e58d3010	 str         r3, [sp, #0x10]

; 508  : 
; 509  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00bfc	e59d3000	 ldr         r3, [sp]
  00c00	e2833008	 add         r3, r3, #8
  00c04	e5933000	 ldr         r3, [r3]
  00c08	e3530000	 cmp         r3, #0
  00c0c	0a000001	 beq         |$LN9@OmapGpioGe|
  00c10	e59d0010	 ldr         r0, [sp, #0x10]
  00c14	eb000000	 bl          EnterCriticalSection
  00c18		 |$LN9@OmapGpioGe|

; 510  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00c18	e3a02000	 mov         r2, #0
  00c1c	e59d1030	 ldr         r1, [sp, #0x30]
  00c20	e59d0000	 ldr         r0, [sp]
  00c24	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 511  : 
; 512  :         // get edge mode
; 513  :         if ((INREG32(&pGpio->OE) & mask) != 0)

  00c28	e59d3018	 ldr         r3, [sp, #0x18]
  00c2c	e2833034	 add         r3, r3, #0x34
  00c30	e5932000	 ldr         r2, [r3]
  00c34	e59d3014	 ldr         r3, [sp, #0x14]
  00c38	e1120003	 tst         r2, r3
  00c3c	0a000003	 beq         |$LN8@OmapGpioGe|

; 514  :         {
; 515  :             mode |= GPIO_DIR_INPUT;

  00c40	e59d3004	 ldr         r3, [sp, #4]
  00c44	e3833001	 orr         r3, r3, #1
  00c48	e58d3004	 str         r3, [sp, #4]

; 516  :         }
; 517  :         else

  00c4c	ea000001	 b           |$LN7@OmapGpioGe|
  00c50		 |$LN8@OmapGpioGe|

; 518  :         {
; 519  :             mode |= GPIO_DIR_OUTPUT;

  00c50	e59d3004	 ldr         r3, [sp, #4]
  00c54	e58d3004	 str         r3, [sp, #4]
  00c58		 |$LN7@OmapGpioGe|

; 520  :         }
; 521  : 
; 522  :         // get debounce mode
; 523  :         if ((INREG32(&pGpio->DEBOUNCENABLE) & mask) != 0)

  00c58	e59d3018	 ldr         r3, [sp, #0x18]
  00c5c	e2833050	 add         r3, r3, #0x50
  00c60	e5932000	 ldr         r2, [r3]
  00c64	e59d3014	 ldr         r3, [sp, #0x14]
  00c68	e1120003	 tst         r2, r3
  00c6c	0a000002	 beq         |$LN6@OmapGpioGe|

; 524  :         {
; 525  :             mode |= GPIO_DEBOUNCE_ENABLE;

  00c70	e59d3004	 ldr         r3, [sp, #4]
  00c74	e3833020	 orr         r3, r3, #0x20
  00c78	e58d3004	 str         r3, [sp, #4]
  00c7c		 |$LN6@OmapGpioGe|

; 526  :         }
; 527  : 
; 528  :         // get edge/level detect mode
; 529  :         if ((INREG32(&pGpio->LEVELDETECT0) & mask) != 0)

  00c7c	e59d3018	 ldr         r3, [sp, #0x18]
  00c80	e2833040	 add         r3, r3, #0x40
  00c84	e5932000	 ldr         r2, [r3]
  00c88	e59d3014	 ldr         r3, [sp, #0x14]
  00c8c	e1120003	 tst         r2, r3
  00c90	0a000002	 beq         |$LN5@OmapGpioGe|

; 530  :         {
; 531  :             mode |= GPIO_INT_LOW;

  00c94	e59d3004	 ldr         r3, [sp, #4]
  00c98	e3833008	 orr         r3, r3, #8
  00c9c	e58d3004	 str         r3, [sp, #4]
  00ca0		 |$LN5@OmapGpioGe|

; 532  :         }
; 533  : 
; 534  :         if ((INREG32(&pGpio->LEVELDETECT1) & mask) != 0)

  00ca0	e59d3018	 ldr         r3, [sp, #0x18]
  00ca4	e2833044	 add         r3, r3, #0x44
  00ca8	e5932000	 ldr         r2, [r3]
  00cac	e59d3014	 ldr         r3, [sp, #0x14]
  00cb0	e1120003	 tst         r2, r3
  00cb4	0a000002	 beq         |$LN4@OmapGpioGe|

; 535  :         {
; 536  :             mode |= GPIO_INT_HIGH;

  00cb8	e59d3004	 ldr         r3, [sp, #4]
  00cbc	e3833010	 orr         r3, r3, #0x10
  00cc0	e58d3004	 str         r3, [sp, #4]
  00cc4		 |$LN4@OmapGpioGe|

; 537  :         }
; 538  : 
; 539  :         if ((INREG32(&pGpio->RISINGDETECT) & mask) != 0)

  00cc4	e59d3018	 ldr         r3, [sp, #0x18]
  00cc8	e2833048	 add         r3, r3, #0x48
  00ccc	e5932000	 ldr         r2, [r3]
  00cd0	e59d3014	 ldr         r3, [sp, #0x14]
  00cd4	e1120003	 tst         r2, r3
  00cd8	0a000002	 beq         |$LN3@OmapGpioGe|

; 540  :         {
; 541  :             mode |= GPIO_INT_LOW_HIGH;

  00cdc	e59d3004	 ldr         r3, [sp, #4]
  00ce0	e3833002	 orr         r3, r3, #2
  00ce4	e58d3004	 str         r3, [sp, #4]
  00ce8		 |$LN3@OmapGpioGe|

; 542  :         }
; 543  : 
; 544  :         if ((INREG32(&pGpio->FALLINGDETECT) & mask) != 0)

  00ce8	e59d3018	 ldr         r3, [sp, #0x18]
  00cec	e283304c	 add         r3, r3, #0x4C
  00cf0	e5932000	 ldr         r2, [r3]
  00cf4	e59d3014	 ldr         r3, [sp, #0x14]
  00cf8	e1120003	 tst         r2, r3
  00cfc	0a000002	 beq         |$LN2@OmapGpioGe|

; 545  :         {
; 546  :             mode |= GPIO_INT_HIGH_LOW;

  00d00	e59d3004	 ldr         r3, [sp, #4]
  00d04	e3833004	 orr         r3, r3, #4
  00d08	e58d3004	 str         r3, [sp, #4]
  00d0c		 |$LN2@OmapGpioGe|

; 547  :         }
; 548  : 
; 549  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00d0c	e3a02004	 mov         r2, #4
  00d10	e59d1030	 ldr         r1, [sp, #0x30]
  00d14	e59d0000	 ldr         r0, [sp]
  00d18	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 550  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00d1c	e59d3000	 ldr         r3, [sp]
  00d20	e2833008	 add         r3, r3, #8
  00d24	e5933000	 ldr         r3, [r3]
  00d28	e3530000	 cmp         r3, #0
  00d2c	0a000001	 beq         |$LN1@OmapGpioGe|
  00d30	e59d0010	 ldr         r0, [sp, #0x10]
  00d34	eb000000	 bl          LeaveCriticalSection
  00d38		 |$LN1@OmapGpioGe|
  00d38		 |$LN10@OmapGpioGe|
  00d38		 |$LN11@OmapGpioGe|
  00d38		 |$cleanUp$37244|

; 551  : 
; 552  :     }
; 553  : 
; 554  : cleanUp:
; 555  :     return mode;

  00d38	e59d3004	 ldr         r3, [sp, #4]
  00d3c	e58d301c	 str         r3, [sp, #0x1C]

; 556  : }

  00d40	e59d001c	 ldr         r0, [sp, #0x1C]
  00d44	e28dd024	 add         sp, sp, #0x24
  00d48	e89d6000	 ldmia       sp, {sp, lr}
  00d4c	e12fff1e	 bx          lr
  00d50		 |$LN21@OmapGpioGe|
  00d50		 |$LN22@OmapGpioGe|
  00d50	00000000	 DCD         |??_C@_1FI@GGOKKMEH@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAG?$AAe?$AAt?$AAM?$AAo?$AAd?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc@|
  00d54		 |$LN23@OmapGpioGe|
  00d54	00000000	 DCD         |dpCurSettings|
  00d58		 |$LN24@OmapGpioGe|
  00d58	11223344	 DCD         0x11223344
  00d5c		 |$M37452|

			 ENDP  ; |?OmapGpioGetMode@@YAKPAXI@Z|, OmapGpioGetMode


  00030			 AREA	 |.pdata|, PDATA
|$T37464| DCD	|$LN5@OmapGpioPu|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00d5c			 AREA	 |.text|, CODE, ARM

  00d5c		 |?OmapGpioPullup@@YAHPAXII@Z| PROC	; OmapGpioPullup

; 571  : {

  00d5c		 |$LN5@OmapGpioPu|
  00d5c	e1a0c00d	 mov         r12, sp
  00d60	e92d0007	 stmdb       sp!, {r0 - r2}
  00d64	e92d5000	 stmdb       sp!, {r12, lr}
  00d68	e24dd004	 sub         sp, sp, #4
  00d6c		 |$M37461|

; 572  :     UNREFERENCED_PARAMETER(context);
; 573  :     UNREFERENCED_PARAMETER(id);
; 574  :     UNREFERENCED_PARAMETER(enable);
; 575  :     return TRUE;

  00d6c	e3a03001	 mov         r3, #1
  00d70	e58d3000	 str         r3, [sp]

; 576  : }

  00d74	e59d0000	 ldr         r0, [sp]
  00d78	e28dd004	 add         sp, sp, #4
  00d7c	e89d6000	 ldmia       sp, {sp, lr}
  00d80	e12fff1e	 bx          lr
  00d84		 |$M37462|

			 ENDP  ; |?OmapGpioPullup@@YAHPAXII@Z|, OmapGpioPullup


  00038			 AREA	 |.pdata|, PDATA
|$T37470| DCD	|$LN5@OmapGpioPu@2|
	DCD	0x40000a04
; Function compile flags: /Odtp

  00d84			 AREA	 |.text|, CODE, ARM

  00d84		 |?OmapGpioPulldown@@YAHPAXII@Z| PROC	; OmapGpioPulldown

; 589  : {

  00d84		 |$LN5@OmapGpioPu@2|
  00d84	e1a0c00d	 mov         r12, sp
  00d88	e92d0007	 stmdb       sp!, {r0 - r2}
  00d8c	e92d5000	 stmdb       sp!, {r12, lr}
  00d90	e24dd004	 sub         sp, sp, #4
  00d94		 |$M37467|

; 590  :     UNREFERENCED_PARAMETER(context);
; 591  :     UNREFERENCED_PARAMETER(id);
; 592  :     UNREFERENCED_PARAMETER(enable);
; 593  :     return TRUE;

  00d94	e3a03001	 mov         r3, #1
  00d98	e58d3000	 str         r3, [sp]

; 594  : }

  00d9c	e59d0000	 ldr         r0, [sp]
  00da0	e28dd004	 add         sp, sp, #4
  00da4	e89d6000	 ldmia       sp, {sp, lr}
  00da8	e12fff1e	 bx          lr
  00dac		 |$M37468|

			 ENDP  ; |?OmapGpioPulldown@@YAHPAXII@Z|, OmapGpioPulldown

	EXPORT	|??_C@_1FG@KIGCHHNN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAS?$AAe?$AAt?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| [ DATA ] ; `string'

  00040			 AREA	 |.pdata|, PDATA
|$T37478| DCD	|$LN13@OmapGpioSe@2|
	DCD	0x40006a04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@KIGCHHNN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAS?$AAe?$AAt?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "S", 0x0, "e", 0x0, "t", 0x0, "B"
	DCB	0x0, "i", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n"
	DCB	0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Odtp

  00dac			 AREA	 |.text|, CODE, ARM

  00dac		 |?OmapGpioSetBit@@YAHPAXI@Z| PROC	; OmapGpioSetBit

; 716  : {

  00dac		 |$LN13@OmapGpioSe@2|
  00dac	e1a0c00d	 mov         r12, sp
  00db0	e92d0003	 stmdb       sp!, {r0, r1}
  00db4	e92d5000	 stmdb       sp!, {r12, lr}
  00db8	e24dd020	 sub         sp, sp, #0x20
  00dbc		 |$M37475|

; 717  :     BOOL rc = FALSE;

  00dbc	e3a03000	 mov         r3, #0
  00dc0	e58d3004	 str         r3, [sp, #4]

; 718  :     UINT bit = GPIO_BIT(id);

  00dc4	e59d302c	 ldr         r3, [sp, #0x2C]
  00dc8	e203301f	 and         r3, r3, #0x1F
  00dcc	e58d300c	 str         r3, [sp, #0xC]

; 719  :     UINT bank = GPIO_BANK(id);

  00dd0	e59d302c	 ldr         r3, [sp, #0x2C]
  00dd4	e1a032a3	 mov         r3, r3, lsr #5
  00dd8	e58d3008	 str         r3, [sp, #8]

; 720  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;

  00ddc	e59d3028	 ldr         r3, [sp, #0x28]
  00de0	e58d3000	 str         r3, [sp]

; 721  :     // Check if we get correct context & pin id
; 722  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00de4	e59d3000	 ldr         r3, [sp]
  00de8	e3530000	 cmp         r3, #0
  00dec	0a000004	 beq         |$LN5@OmapGpioSe@2|
  00df0	e59d3000	 ldr         r3, [sp]
  00df4	e5932000	 ldr         r2, [r3]
  00df8	e59f3150	 ldr         r3, [pc, #0x150]
  00dfc	e1520003	 cmp         r2, r3
  00e00	0a00000c	 beq         |$LN6@OmapGpioSe@2|
  00e04		 |$LN5@OmapGpioSe@2|

; 723  :     {
; 724  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioSetBit: Incorrect context\r\n"));

  00e04	e59f3140	 ldr         r3, [pc, #0x140]
  00e08	e5933440	 ldr         r3, [r3, #0x440]
  00e0c	e3130001	 tst         r3, #1
  00e10	0a000004	 beq         |$LN9@OmapGpioSe@2|
  00e14	e59f012c	 ldr         r0, [pc, #0x12C]
  00e18	eb000000	 bl          NKDbgPrintfW
  00e1c	e3a03001	 mov         r3, #1
  00e20	e58d301c	 str         r3, [sp, #0x1C]
  00e24	ea000001	 b           |$LN10@OmapGpioSe@2|
  00e28		 |$LN9@OmapGpioSe@2|
  00e28	e3a03000	 mov         r3, #0
  00e2c	e58d301c	 str         r3, [sp, #0x1C]
  00e30		 |$LN10@OmapGpioSe@2|

; 725  :         goto cleanUp;

  00e30	ea00003e	 b           |$LN4@OmapGpioSe@2|
  00e34	ea00003d	 b           |$cleanUp$37288|
  00e38		 |$LN6@OmapGpioSe@2|

; 726  :     }
; 727  : 
; 728  :     if (id < pDevice->nbBanks*32)

  00e38	e59d3000	 ldr         r3, [sp]
  00e3c	e2833004	 add         r3, r3, #4
  00e40	e5931000	 ldr         r1, [r3]
  00e44	e3a03020	 mov         r3, #0x20
  00e48	e0020391	 mul         r2, r1, r3
  00e4c	e59d302c	 ldr         r3, [sp, #0x2C]
  00e50	e1530002	 cmp         r3, r2
  00e54	2a000035	 bcs         |$LN3@OmapGpioSe@2|

; 729  :     {
; 730  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAOUT;

  00e58	e59d3000	 ldr         r3, [sp]
  00e5c	e283000c	 add         r0, r3, #0xC
  00e60	e59d1008	 ldr         r1, [sp, #8]
  00e64	e3a03020	 mov         r3, #0x20
  00e68	e0020391	 mul         r2, r1, r3
  00e6c	e5903000	 ldr         r3, [r0]
  00e70	e0833002	 add         r3, r3, r2
  00e74	e2833018	 add         r3, r3, #0x18
  00e78	e5933000	 ldr         r3, [r3]
  00e7c	e283303c	 add         r3, r3, #0x3C
  00e80	e58d3010	 str         r3, [sp, #0x10]

; 731  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  00e84	e59d3000	 ldr         r3, [sp]
  00e88	e283000c	 add         r0, r3, #0xC
  00e8c	e59d1008	 ldr         r1, [sp, #8]
  00e90	e3a03020	 mov         r3, #0x20
  00e94	e0020391	 mul         r2, r1, r3
  00e98	e5903000	 ldr         r3, [r0]
  00e9c	e0833002	 add         r3, r3, r2
  00ea0	e2833004	 add         r3, r3, #4
  00ea4	e58d3014	 str         r3, [sp, #0x14]

; 732  : 
; 733  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  00ea8	e59d3000	 ldr         r3, [sp]
  00eac	e2833008	 add         r3, r3, #8
  00eb0	e5933000	 ldr         r3, [r3]
  00eb4	e3530000	 cmp         r3, #0
  00eb8	0a000001	 beq         |$LN2@OmapGpioSe@2|
  00ebc	e59d0014	 ldr         r0, [sp, #0x14]
  00ec0	eb000000	 bl          EnterCriticalSection
  00ec4		 |$LN2@OmapGpioSe@2|

; 734  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  00ec4	e3a02000	 mov         r2, #0
  00ec8	e59d102c	 ldr         r1, [sp, #0x2C]
  00ecc	e59d0000	 ldr         r0, [sp]
  00ed0	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 735  :         SETREG32(p, 1 << (bit));

  00ed4	e59d200c	 ldr         r2, [sp, #0xC]
  00ed8	e3a03001	 mov         r3, #1
  00edc	e1a02213	 mov         r2, r3, lsl r2
  00ee0	e59d3010	 ldr         r3, [sp, #0x10]
  00ee4	e5933000	 ldr         r3, [r3]
  00ee8	e1832002	 orr         r2, r3, r2
  00eec	e59d3010	 ldr         r3, [sp, #0x10]
  00ef0	e5832000	 str         r2, [r3]

; 736  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  00ef4	e3a02004	 mov         r2, #4
  00ef8	e59d102c	 ldr         r1, [sp, #0x2C]
  00efc	e59d0000	 ldr         r0, [sp]
  00f00	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 737  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  00f04	e59d3000	 ldr         r3, [sp]
  00f08	e2833008	 add         r3, r3, #8
  00f0c	e5933000	 ldr         r3, [r3]
  00f10	e3530000	 cmp         r3, #0
  00f14	0a000001	 beq         |$LN1@OmapGpioSe@2|
  00f18	e59d0014	 ldr         r0, [sp, #0x14]
  00f1c	eb000000	 bl          LeaveCriticalSection
  00f20		 |$LN1@OmapGpioSe@2|

; 738  : 
; 739  :         // indicate gpio registers need to be saved for OFF mode
; 740  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  00f20	e3a00001	 mov         r0, #1
  00f24	eb000000	 bl          HalContextUpdateDirtyRegister

; 741  : 
; 742  :         rc = TRUE;

  00f28	e3a03001	 mov         r3, #1
  00f2c	e58d3004	 str         r3, [sp, #4]
  00f30		 |$LN3@OmapGpioSe@2|
  00f30		 |$LN4@OmapGpioSe@2|
  00f30		 |$cleanUp$37288|

; 743  :     }
; 744  : 
; 745  : cleanUp:
; 746  :     return rc;

  00f30	e59d3004	 ldr         r3, [sp, #4]
  00f34	e58d3018	 str         r3, [sp, #0x18]

; 747  : }

  00f38	e59d0018	 ldr         r0, [sp, #0x18]
  00f3c	e28dd020	 add         sp, sp, #0x20
  00f40	e89d6000	 ldmia       sp, {sp, lr}
  00f44	e12fff1e	 bx          lr
  00f48		 |$LN14@OmapGpioSe@2|
  00f48		 |$LN15@OmapGpioSe@2|
  00f48	00000000	 DCD         |??_C@_1FG@KIGCHHNN@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAS?$AAe?$AAt?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@|
  00f4c		 |$LN16@OmapGpioSe@2|
  00f4c	00000000	 DCD         |dpCurSettings|
  00f50		 |$LN17@OmapGpioSe@2|
  00f50	11223344	 DCD         0x11223344
  00f54		 |$M37476|

			 ENDP  ; |?OmapGpioSetBit@@YAHPAXI@Z|, OmapGpioSetBit

	EXPORT	|??_C@_1FG@JBBKGIF@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAC?$AAl?$AAr?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| [ DATA ] ; `string'

  00048			 AREA	 |.pdata|, PDATA
|$T37490| DCD	|$LN13@OmapGpioCl|
	DCD	0x40006b04

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@JBBKGIF@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAC?$AAl?$AAr?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "C", 0x0, "l", 0x0, "r", 0x0, "B"
	DCB	0x0, "i", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n"
	DCB	0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Odtp

  00f54			 AREA	 |.text|, CODE, ARM

  00f54		 |?OmapGpioClrBit@@YAHPAXI@Z| PROC	; OmapGpioClrBit

; 758  : {

  00f54		 |$LN13@OmapGpioCl|
  00f54	e1a0c00d	 mov         r12, sp
  00f58	e92d0003	 stmdb       sp!, {r0, r1}
  00f5c	e92d5000	 stmdb       sp!, {r12, lr}
  00f60	e24dd020	 sub         sp, sp, #0x20
  00f64		 |$M37487|

; 759  :     BOOL rc = FALSE;

  00f64	e3a03000	 mov         r3, #0
  00f68	e58d3004	 str         r3, [sp, #4]

; 760  :     UINT bit = GPIO_BIT(id);

  00f6c	e59d302c	 ldr         r3, [sp, #0x2C]
  00f70	e203301f	 and         r3, r3, #0x1F
  00f74	e58d300c	 str         r3, [sp, #0xC]

; 761  :     UINT bank = GPIO_BANK(id);

  00f78	e59d302c	 ldr         r3, [sp, #0x2C]
  00f7c	e1a032a3	 mov         r3, r3, lsr #5
  00f80	e58d3008	 str         r3, [sp, #8]

; 762  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;

  00f84	e59d3028	 ldr         r3, [sp, #0x28]
  00f88	e58d3000	 str         r3, [sp]

; 763  :     // Check if we get correct context & pin id
; 764  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  00f8c	e59d3000	 ldr         r3, [sp]
  00f90	e3530000	 cmp         r3, #0
  00f94	0a000004	 beq         |$LN5@OmapGpioCl|
  00f98	e59d3000	 ldr         r3, [sp]
  00f9c	e5932000	 ldr         r2, [r3]
  00fa0	e59f3154	 ldr         r3, [pc, #0x154]
  00fa4	e1520003	 cmp         r2, r3
  00fa8	0a00000c	 beq         |$LN6@OmapGpioCl|
  00fac		 |$LN5@OmapGpioCl|

; 765  :     {
; 766  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioClrBit: Incorrect context\r\n"));

  00fac	e59f3144	 ldr         r3, [pc, #0x144]
  00fb0	e5933440	 ldr         r3, [r3, #0x440]
  00fb4	e3130001	 tst         r3, #1
  00fb8	0a000004	 beq         |$LN9@OmapGpioCl|
  00fbc	e59f0130	 ldr         r0, [pc, #0x130]
  00fc0	eb000000	 bl          NKDbgPrintfW
  00fc4	e3a03001	 mov         r3, #1
  00fc8	e58d301c	 str         r3, [sp, #0x1C]
  00fcc	ea000001	 b           |$LN10@OmapGpioCl|
  00fd0		 |$LN9@OmapGpioCl|
  00fd0	e3a03000	 mov         r3, #0
  00fd4	e58d301c	 str         r3, [sp, #0x1C]
  00fd8		 |$LN10@OmapGpioCl|

; 767  :         goto cleanUp;

  00fd8	ea00003f	 b           |$LN4@OmapGpioCl|
  00fdc	ea00003e	 b           |$cleanUp$37311|
  00fe0		 |$LN6@OmapGpioCl|

; 768  :     }
; 769  :     if (id < pDevice->nbBanks*32)

  00fe0	e59d3000	 ldr         r3, [sp]
  00fe4	e2833004	 add         r3, r3, #4
  00fe8	e5931000	 ldr         r1, [r3]
  00fec	e3a03020	 mov         r3, #0x20
  00ff0	e0020391	 mul         r2, r1, r3
  00ff4	e59d302c	 ldr         r3, [sp, #0x2C]
  00ff8	e1530002	 cmp         r3, r2
  00ffc	2a000036	 bcs         |$LN3@OmapGpioCl|

; 770  :     {
; 771  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAOUT;

  01000	e59d3000	 ldr         r3, [sp]
  01004	e283000c	 add         r0, r3, #0xC
  01008	e59d1008	 ldr         r1, [sp, #8]
  0100c	e3a03020	 mov         r3, #0x20
  01010	e0020391	 mul         r2, r1, r3
  01014	e5903000	 ldr         r3, [r0]
  01018	e0833002	 add         r3, r3, r2
  0101c	e2833018	 add         r3, r3, #0x18
  01020	e5933000	 ldr         r3, [r3]
  01024	e283303c	 add         r3, r3, #0x3C
  01028	e58d3010	 str         r3, [sp, #0x10]

; 772  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  0102c	e59d3000	 ldr         r3, [sp]
  01030	e283000c	 add         r0, r3, #0xC
  01034	e59d1008	 ldr         r1, [sp, #8]
  01038	e3a03020	 mov         r3, #0x20
  0103c	e0020391	 mul         r2, r1, r3
  01040	e5903000	 ldr         r3, [r0]
  01044	e0833002	 add         r3, r3, r2
  01048	e2833004	 add         r3, r3, #4
  0104c	e58d3014	 str         r3, [sp, #0x14]

; 773  : 
; 774  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  01050	e59d3000	 ldr         r3, [sp]
  01054	e2833008	 add         r3, r3, #8
  01058	e5933000	 ldr         r3, [r3]
  0105c	e3530000	 cmp         r3, #0
  01060	0a000001	 beq         |$LN2@OmapGpioCl|
  01064	e59d0014	 ldr         r0, [sp, #0x14]
  01068	eb000000	 bl          EnterCriticalSection
  0106c		 |$LN2@OmapGpioCl|

; 775  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  0106c	e3a02000	 mov         r2, #0
  01070	e59d102c	 ldr         r1, [sp, #0x2C]
  01074	e59d0000	 ldr         r0, [sp]
  01078	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 776  :         CLRREG32(p, 1 << (bit));

  0107c	e59d200c	 ldr         r2, [sp, #0xC]
  01080	e3a03001	 mov         r3, #1
  01084	e1a03213	 mov         r3, r3, lsl r2
  01088	e1e02003	 mvn         r2, r3
  0108c	e59d3010	 ldr         r3, [sp, #0x10]
  01090	e5933000	 ldr         r3, [r3]
  01094	e0032002	 and         r2, r3, r2
  01098	e59d3010	 ldr         r3, [sp, #0x10]
  0109c	e5832000	 str         r2, [r3]

; 777  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  010a0	e3a02004	 mov         r2, #4
  010a4	e59d102c	 ldr         r1, [sp, #0x2C]
  010a8	e59d0000	 ldr         r0, [sp]
  010ac	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 778  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  010b0	e59d3000	 ldr         r3, [sp]
  010b4	e2833008	 add         r3, r3, #8
  010b8	e5933000	 ldr         r3, [r3]
  010bc	e3530000	 cmp         r3, #0
  010c0	0a000001	 beq         |$LN1@OmapGpioCl|
  010c4	e59d0014	 ldr         r0, [sp, #0x14]
  010c8	eb000000	 bl          LeaveCriticalSection
  010cc		 |$LN1@OmapGpioCl|

; 779  :         // indicate gpio registers need to be saved for OFF mode
; 780  :         HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);

  010cc	e3a00001	 mov         r0, #1
  010d0	eb000000	 bl          HalContextUpdateDirtyRegister

; 781  :         rc = TRUE;

  010d4	e3a03001	 mov         r3, #1
  010d8	e58d3004	 str         r3, [sp, #4]
  010dc		 |$LN3@OmapGpioCl|
  010dc		 |$LN4@OmapGpioCl|
  010dc		 |$cleanUp$37311|

; 782  :     }
; 783  : cleanUp:
; 784  :     return rc;

  010dc	e59d3004	 ldr         r3, [sp, #4]
  010e0	e58d3018	 str         r3, [sp, #0x18]

; 785  : }

  010e4	e59d0018	 ldr         r0, [sp, #0x18]
  010e8	e28dd020	 add         sp, sp, #0x20
  010ec	e89d6000	 ldmia       sp, {sp, lr}
  010f0	e12fff1e	 bx          lr
  010f4		 |$LN14@OmapGpioCl|
  010f4		 |$LN15@OmapGpioCl|
  010f4	00000000	 DCD         |??_C@_1FG@JBBKGIF@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAC?$AAl?$AAr?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@|
  010f8		 |$LN16@OmapGpioCl|
  010f8	00000000	 DCD         |dpCurSettings|
  010fc		 |$LN17@OmapGpioCl|
  010fc	11223344	 DCD         0x11223344
  01100		 |$M37488|

			 ENDP  ; |?OmapGpioClrBit@@YAHPAXI@Z|, OmapGpioClrBit

	EXPORT	|??_C@_1FG@NMBGADLA@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAG?$AAe?$AAt?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| [ DATA ] ; `string'

  00050			 AREA	 |.pdata|, PDATA
|$T37502| DCD	|$LN13@OmapGpioGe@2|
	DCD	0x40006404

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FG@NMBGADLA@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAG?$AAe?$AAt?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "m", 0x0, "a", 0x0, "p", 0x0, "G", 0x0, "p"
	DCB	0x0, "i", 0x0, "o", 0x0, "G", 0x0, "e", 0x0, "t", 0x0, "B"
	DCB	0x0, "i", 0x0, "t", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n"
	DCB	0x0, "c", 0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c"
	DCB	0x0, "t", 0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Odtp

  01100			 AREA	 |.text|, CODE, ARM

  01100		 |?OmapGpioGetBit@@YAKPAXI@Z| PROC	; OmapGpioGetBit

; 796  : {

  01100		 |$LN13@OmapGpioGe@2|
  01100	e1a0c00d	 mov         r12, sp
  01104	e92d0003	 stmdb       sp!, {r0, r1}
  01108	e92d5000	 stmdb       sp!, {r12, lr}
  0110c	e24dd020	 sub         sp, sp, #0x20
  01110		 |$M37499|

; 797  :     DWORD value = (DWORD) -1;

  01110	e3e03000	 mvn         r3, #0
  01114	e58d3004	 str         r3, [sp, #4]

; 798  :     UINT bit = GPIO_BIT(id);

  01118	e59d302c	 ldr         r3, [sp, #0x2C]
  0111c	e203301f	 and         r3, r3, #0x1F
  01120	e58d300c	 str         r3, [sp, #0xC]

; 799  :     UINT bank = GPIO_BANK(id);

  01124	e59d302c	 ldr         r3, [sp, #0x2C]
  01128	e1a032a3	 mov         r3, r3, lsr #5
  0112c	e58d3008	 str         r3, [sp, #8]

; 800  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;

  01130	e59d3028	 ldr         r3, [sp, #0x28]
  01134	e58d3000	 str         r3, [sp]

; 801  : 
; 802  :     // Check if we get correct context & pin id
; 803  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))

  01138	e59d3000	 ldr         r3, [sp]
  0113c	e3530000	 cmp         r3, #0
  01140	0a000004	 beq         |$LN5@OmapGpioGe@2|
  01144	e59d3000	 ldr         r3, [sp]
  01148	e5932000	 ldr         r2, [r3]
  0114c	e59f3138	 ldr         r3, [pc, #0x138]
  01150	e1520003	 cmp         r2, r3
  01154	0a00000c	 beq         |$LN6@OmapGpioGe@2|
  01158		 |$LN5@OmapGpioGe@2|

; 804  :     {
; 805  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioGetBit: Incorrect context\r\n"));

  01158	e59f3128	 ldr         r3, [pc, #0x128]
  0115c	e5933440	 ldr         r3, [r3, #0x440]
  01160	e3130001	 tst         r3, #1
  01164	0a000004	 beq         |$LN9@OmapGpioGe@2|
  01168	e59f0114	 ldr         r0, [pc, #0x114]
  0116c	eb000000	 bl          NKDbgPrintfW
  01170	e3a03001	 mov         r3, #1
  01174	e58d301c	 str         r3, [sp, #0x1C]
  01178	ea000001	 b           |$LN10@OmapGpioGe@2|
  0117c		 |$LN9@OmapGpioGe@2|
  0117c	e3a03000	 mov         r3, #0
  01180	e58d301c	 str         r3, [sp, #0x1C]
  01184		 |$LN10@OmapGpioGe@2|

; 806  :         goto cleanUp;

  01184	ea000038	 b           |$LN4@OmapGpioGe@2|
  01188	ea000037	 b           |$cleanUp$37335|
  0118c		 |$LN6@OmapGpioGe@2|

; 807  :     }
; 808  : 
; 809  :     if (id < pDevice->nbBanks*32)

  0118c	e59d3000	 ldr         r3, [sp]
  01190	e2833004	 add         r3, r3, #4
  01194	e5931000	 ldr         r1, [r3]
  01198	e3a03020	 mov         r3, #0x20
  0119c	e0020391	 mul         r2, r1, r3
  011a0	e59d302c	 ldr         r3, [sp, #0x2C]
  011a4	e1530002	 cmp         r3, r2
  011a8	2a00002f	 bcs         |$LN3@OmapGpioGe@2|

; 810  :     {
; 811  :         volatile UINT *p = &pDevice->bank[bank].ppGpioRegs->DATAIN;

  011ac	e59d3000	 ldr         r3, [sp]
  011b0	e283000c	 add         r0, r3, #0xC
  011b4	e59d1008	 ldr         r1, [sp, #8]
  011b8	e3a03020	 mov         r3, #0x20
  011bc	e0020391	 mul         r2, r1, r3
  011c0	e5903000	 ldr         r3, [r0]
  011c4	e0833002	 add         r3, r3, r2
  011c8	e2833018	 add         r3, r3, #0x18
  011cc	e5933000	 ldr         r3, [r3]
  011d0	e2833038	 add         r3, r3, #0x38
  011d4	e58d3010	 str         r3, [sp, #0x10]

; 812  :         CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;

  011d8	e59d3000	 ldr         r3, [sp]
  011dc	e283000c	 add         r0, r3, #0xC
  011e0	e59d1008	 ldr         r1, [sp, #8]
  011e4	e3a03020	 mov         r3, #0x20
  011e8	e0020391	 mul         r2, r1, r3
  011ec	e5903000	 ldr         r3, [r0]
  011f0	e0833002	 add         r3, r3, r2
  011f4	e2833004	 add         r3, r3, #4
  011f8	e58d3014	 str         r3, [sp, #0x14]

; 813  :         if (pDevice->fPostInit) EnterCriticalSection(pCs);

  011fc	e59d3000	 ldr         r3, [sp]
  01200	e2833008	 add         r3, r3, #8
  01204	e5933000	 ldr         r3, [r3]
  01208	e3530000	 cmp         r3, #0
  0120c	0a000001	 beq         |$LN2@OmapGpioGe@2|
  01210	e59d0014	 ldr         r0, [sp, #0x14]
  01214	eb000000	 bl          EnterCriticalSection
  01218		 |$LN2@OmapGpioGe@2|

; 814  :         InternalSetGpioBankPowerState(pDevice, id, D0);

  01218	e3a02000	 mov         r2, #0
  0121c	e59d102c	 ldr         r1, [sp, #0x2C]
  01220	e59d0000	 ldr         r0, [sp]
  01224	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 815  :         value = (INREG32(p) >> (bit)) & 0x01;

  01228	e59d3010	 ldr         r3, [sp, #0x10]
  0122c	e5932000	 ldr         r2, [r3]
  01230	e59d300c	 ldr         r3, [sp, #0xC]
  01234	e1a03332	 mov         r3, r2, lsr r3
  01238	e2033001	 and         r3, r3, #1
  0123c	e58d3004	 str         r3, [sp, #4]

; 816  :         InternalSetGpioBankPowerState(pDevice, id, D4);

  01240	e3a02004	 mov         r2, #4
  01244	e59d102c	 ldr         r1, [sp, #0x2C]
  01248	e59d0000	 ldr         r0, [sp]
  0124c	eb000000	 bl          |?InternalSetGpioBankPowerState@@YAXPAUOmapGpioDevice_t@@IW4_CEDEVICE_POWER_STATE@@@Z|

; 817  :         if (pDevice->fPostInit) LeaveCriticalSection(pCs);

  01250	e59d3000	 ldr         r3, [sp]
  01254	e2833008	 add         r3, r3, #8
  01258	e5933000	 ldr         r3, [r3]
  0125c	e3530000	 cmp         r3, #0
  01260	0a000001	 beq         |$LN1@OmapGpioGe@2|
  01264	e59d0014	 ldr         r0, [sp, #0x14]
  01268	eb000000	 bl          LeaveCriticalSection
  0126c		 |$LN1@OmapGpioGe@2|
  0126c		 |$LN3@OmapGpioGe@2|
  0126c		 |$LN4@OmapGpioGe@2|
  0126c		 |$cleanUp$37335|

; 818  :     }
; 819  : 
; 820  : cleanUp:
; 821  :     return value;

  0126c	e59d3004	 ldr         r3, [sp, #4]
  01270	e58d3018	 str         r3, [sp, #0x18]

; 822  : }

  01274	e59d0018	 ldr         r0, [sp, #0x18]
  01278	e28dd020	 add         sp, sp, #0x20
  0127c	e89d6000	 ldmia       sp, {sp, lr}
  01280	e12fff1e	 bx          lr
  01284		 |$LN14@OmapGpioGe@2|
  01284		 |$LN15@OmapGpioGe@2|
  01284	00000000	 DCD         |??_C@_1FG@NMBGADLA@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAm?$AAa?$AAp?$AAG?$AAp?$AAi?$AAo?$AAG?$AAe?$AAt?$AAB?$AAi?$AAt?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt@|
  01288		 |$LN16@OmapGpioGe@2|
  01288	00000000	 DCD         |dpCurSettings|
  0128c		 |$LN17@OmapGpioGe@2|
  0128c	11223344	 DCD         0x11223344
  01290		 |$M37500|

			 ENDP  ; |?OmapGpioGetBit@@YAKPAXI@Z|, OmapGpioGetBit


  00058			 AREA	 |.pdata|, PDATA
|$T37512| DCD	|$LN5@OmapGpioIo|
	DCD	0x40000a04
; Function compile flags: /Odtp

  01290			 AREA	 |.text|, CODE, ARM

  01290		 |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z| PROC ; OmapGpioIoControl

; 840  : {

  01290		 |$LN5@OmapGpioIo|
  01290	e1a0c00d	 mov         r12, sp
  01294	e92d000f	 stmdb       sp!, {r0 - r3}
  01298	e92d5000	 stmdb       sp!, {r12, lr}
  0129c	e24dd004	 sub         sp, sp, #4
  012a0		 |$M37509|

; 841  : #ifdef DEVICE
; 842  :     UINT id;
; 843  :     DWORD value,mode;
; 844  :     DEVICE_IFC_GPIO ifc;
; 845  :     UINT bit;
; 846  :     UINT bank;
; 847  :     BOOL rc = FALSE;
; 848  :     OmapGpioDevice_t *pDevice = (OmapGpioDevice_t*)context;
; 849  : 
; 850  :     UNREFERENCED_PARAMETER(pOutSize);
; 851  : 
; 852  :     DEBUGMSG(ZONE_FUNCTION, (
; 853  :         L"+OmapGpioIOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 854  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 855  :         ));
; 856  : 
; 857  :     // Check if we get correct context
; 858  :     if ((pDevice == NULL) || (pDevice->cookie != GPIO_DEVICE_COOKIE))
; 859  :     {
; 860  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 861  :             L"Incorrect context parameter\r\n"
; 862  :             ));
; 863  :         goto cleanUp;
; 864  :     }
; 865  :     switch (code)
; 866  :     {
; 867  :     case IOCTL_DDK_GET_DRIVER_IFC:
; 868  :         // We can give interface only to our peer in device process
; 869  :         if (GetCurrentProcessId() != (DWORD)GetCallerProcess())
; 870  :         {
; 871  :             DEBUGMSG(ZONE_ERROR, (L"ERROR: GIO_IOControl: "
; 872  :                 L"IOCTL_DDK_GET_DRIVER_IFC can be called only from "
; 873  :                 L"device process (caller process id 0x%08x)\r\n",
; 874  :                 GetCurrentProcessId()
; 875  :                 ));
; 876  :             SetLastError(ERROR_ACCESS_DENIED);
; 877  :             goto cleanUp;
; 878  :         }
; 879  :         if ((pInBuffer == NULL) || (inSize < sizeof(GUID)))
; 880  :         {
; 881  :             SetLastError(ERROR_INVALID_PARAMETER);
; 882  :             break;
; 883  :         }
; 884  :         if (IsEqualGUID(*(GUID*)pInBuffer, DEVICE_IFC_GPIO_GUID))
; 885  :         {
; 886  :             if (pOutSize != NULL) *pOutSize = sizeof(DEVICE_IFC_GPIO);
; 887  :             if ((pOutBuffer == NULL) || (outSize < sizeof(DEVICE_IFC_GPIO)))
; 888  :             {
; 889  :                 SetLastError(ERROR_INVALID_PARAMETER);
; 890  :                 break;
; 891  :             }
; 892  :             ifc.context                 = context;
; 893  :             ifc.pfnSetBit               = OmapGpioSetBit;
; 894  :             ifc.pfnClrBit               = OmapGpioClrBit;
; 895  :             ifc.pfnGetBit               = OmapGpioGetBit;
; 896  :             ifc.pfnSetMode              = OmapGpioSetMode;
; 897  :             ifc.pfnGetMode              = OmapGpioGetMode;
; 898  :             ifc.pfnPullup               = OmapGpioPullup;
; 899  :             ifc.pfnPulldown             = OmapGpioPulldown;
; 900  :             ifc.pfnInterruptInitialize  = OmapGpioInterruptInitialize;
; 901  :             ifc.pfnInterruptMask        = OmapGpioInterruptMask;
; 902  :             ifc.pfnInterruptDisable     = OmapGpioInterruptDisable;
; 903  :             ifc.pfnInterruptDone        = OmapGpioInterruptDone;
; 904  : 			ifc.pfnGetSystemIrq			= OmapGpioGetSystemIrq;
; 905  :             ifc.pfnInterruptWakeUp      = OmapGpioInterruptWakeUp;
; 906  :             ifc.pfnIoControl            = OmapGpioIoControl;
; 907  : 
; 908  :             if (!CeSafeCopyMemory(pOutBuffer, &ifc, sizeof(ifc))) break;
; 909  :             rc = TRUE;
; 910  :             break;
; 911  :         }
; 912  :         SetLastError(ERROR_INVALID_PARAMETER);
; 913  :         break;
; 914  : 
; 915  :     case IOCTL_GPIO_SETBIT:
; 916  :         if (pOutSize != 0) *pOutSize = 0;
; 917  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 918  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)))
; 919  :         {
; 920  :             SetLastError(ERROR_INVALID_PARAMETER);
; 921  :             break;
; 922  :         }
; 923  :         OmapGpioSetBit(context, id);
; 924  :         rc = TRUE;
; 925  :         break;
; 926  : 
; 927  :     case IOCTL_GPIO_CLRBIT:
; 928  :         if (pOutSize != 0) *pOutSize = 0;
; 929  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 930  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)))
; 931  :         {
; 932  :             SetLastError(ERROR_INVALID_PARAMETER);
; 933  :             break;
; 934  :         }
; 935  :         OmapGpioClrBit(context, id);
; 936  :         rc = TRUE;
; 937  :         break;
; 938  : 
; 939  :     case IOCTL_GPIO_GETBIT:
; 940  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 941  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 942  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 943  :             (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 944  :         {
; 945  :             SetLastError(ERROR_INVALID_PARAMETER);
; 946  :             break;
; 947  :         }
; 948  :         value = OmapGpioGetBit(context, id);
; 949  :         if (!CeSafeCopyMemory(pOutBuffer, &value, sizeof(value)))
; 950  :         {
; 951  :             SetLastError(ERROR_INVALID_PARAMETER);
; 952  :             break;
; 953  :         }
; 954  :         rc = TRUE;
; 955  :         break;
; 956  : 
; 957  :     case IOCTL_GPIO_SETMODE:
; 958  :         if (pOutSize != 0) *pOutSize = 0;
; 959  :         if ((pInBuffer == NULL) || (inSize < 2 * sizeof(DWORD)) ||
; 960  :             !CeSafeCopyMemory(
; 961  :             &id, &((DWORD*)pInBuffer)[0], sizeof(DWORD)
; 962  :             ) ||
; 963  :             !CeSafeCopyMemory(
; 964  :             &mode, &((DWORD*)pInBuffer)[1], sizeof(DWORD)
; 965  :             ))
; 966  :         {
; 967  :             SetLastError(ERROR_INVALID_PARAMETER);
; 968  :             break;
; 969  :         }
; 970  :         OmapGpioSetMode(context, id, mode);
; 971  :         rc = TRUE;
; 972  :         break;
; 973  : 
; 974  :     case IOCTL_GPIO_GETMODE:
; 975  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 976  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 977  :             !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 978  :             (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 979  :         {
; 980  :             SetLastError(ERROR_INVALID_PARAMETER);
; 981  :             break;
; 982  :         }
; 983  :         mode = OmapGpioGetMode(context, id);
; 984  :         if (!CeSafeCopyMemory(pOutBuffer, &mode, sizeof(mode)))
; 985  :         {
; 986  :             SetLastError(ERROR_INVALID_PARAMETER);
; 987  :             break;
; 988  :         }
; 989  :         rc = TRUE;
; 990  :         break;
; 991  :         /*
; 992  :         case IOCTL_GPIO_GETIRQ:
; 993  :         if (pOutSize != 0) *pOutSize = sizeof(DWORD);
; 994  :         if ((pInBuffer == NULL) || (inSize < sizeof(DWORD)) ||
; 995  :         !CeSafeCopyMemory(&id, pInBuffer, sizeof(DWORD)) ||
; 996  :         (pOutBuffer == NULL) || (outSize < sizeof(DWORD)))
; 997  :         {
; 998  :         SetLastError(ERROR_INVALID_PARAMETER);
; 999  :         break;
; 1000 :         }
; 1001 :         value = OmapGpioGetSystemIrq(context, id);
; 1002 :         if (!CeSafeCopyMemory(pOutBuffer, &value, sizeof(value)))
; 1003 :         {
; 1004 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1005 :         break;
; 1006 :         }
; 1007 :         rc = TRUE;
; 1008 :         break;
; 1009 : 
; 1010 :         case IOCTL_GPIO_INIT_INTERRUPT:
; 1011 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INIT_INTERRUPT_INFO)))
; 1012 :         {
; 1013 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1014 :         break;
; 1015 :         }
; 1016 :         else
; 1017 :         {
; 1018 :         HANDLE      hLocalEvent         = INVALID_HANDLE_VALUE;
; 1019 :         HANDLE      hCallerHandle       = GetCallerProcess();
; 1020 :         HANDLE      hCurrentProcHandle  = GetCurrentProcess();
; 1021 :         PIOCTL_GPIO_INIT_INTERRUPT_INFO pInitIntrInfo = (PIOCTL_GPIO_INIT_INTERRUPT_INFO)pInBuffer;
; 1022 : 
; 1023 :         if (hCurrentProcHandle != hCallerHandle)
; 1024 :         {
; 1025 :         BOOL    bStatus;
; 1026 : 
; 1027 :         bStatus = DuplicateHandle(hCallerHandle, pInitIntrInfo->hEvent,
; 1028 :         hCurrentProcHandle, &hLocalEvent,
; 1029 :         DUPLICATE_SAME_ACCESS,
; 1030 :         FALSE,
; 1031 :         DUPLICATE_SAME_ACCESS);
; 1032 : 
; 1033 :         if ((bStatus == FALSE) || (hLocalEvent == INVALID_HANDLE_VALUE))
; 1034 :         {
; 1035 :         RETAILMSG(1, (TEXT("GIO_IOControl: IOCTL_GPIO_INIT_INTERRUPT unable to duplicate event handle.\r\n")));
; 1036 :         break;
; 1037 :         }
; 1038 :         }
; 1039 :         else
; 1040 :         {
; 1041 :         hLocalEvent = pInitIntrInfo->hEvent;
; 1042 :         if (hLocalEvent == INVALID_HANDLE_VALUE)
; 1043 :         {
; 1044 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1045 :         break;
; 1046 :         }
; 1047 :         }
; 1048 : 
; 1049 :         rc = InterruptInitialize(pInitIntrInfo->dwSysIntrID, hLocalEvent, NULL, 0);
; 1050 :         CloseHandle(hLocalEvent);
; 1051 :         }
; 1052 :         break;
; 1053 : 
; 1054 :         case IOCTL_GPIO_ACK_INTERRUPT:
; 1055 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INTERRUPT_INFO)))
; 1056 :         {
; 1057 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1058 :         break;
; 1059 :         }
; 1060 :         else
; 1061 :         {
; 1062 :         PIOCTL_GPIO_INTERRUPT_INFO pIntrInfo = (PIOCTL_GPIO_INTERRUPT_INFO)pInBuffer;
; 1063 : 
; 1064 :         rc = OmapGpioInterruptDone(context, pIntrInfo->uGpioID, pIntrInfo->dwSysIntrID);
; 1065 :         }
; 1066 :         break;
; 1067 : 
; 1068 :         case IOCTL_GPIO_DISABLE_INTERRUPT:
; 1069 :         if ((pInBuffer == NULL) || (inSize != sizeof(IOCTL_GPIO_INTERRUPT_INFO)))
; 1070 :         {
; 1071 :         SetLastError(ERROR_INVALID_PARAMETER);
; 1072 :         break;
; 1073 :         }
; 1074 :         else
; 1075 :         {
; 1076 :         PIOCTL_GPIO_INTERRUPT_INFO pIntrInfo = (PIOCTL_GPIO_INTERRUPT_INFO)pInBuffer;
; 1077 : 
; 1078 :         rc = OmapGpioInterruptDisable(context, pIntrInfo->uGpioID, pIntrInfo->dwSysIntrID);
; 1079 :         }
; 1080 :         break;
; 1081 :         }
; 1082 :         */
; 1083 :     case IOCTL_GPIO_SET_POWER_STATE:
; 1084 :         {
; 1085 :             if ((pInBuffer == NULL) || inSize != sizeof(IOCTL_GPIO_POWER_STATE_IN))
; 1086 :             {
; 1087 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1088 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1089 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1090 :                     ));
; 1091 :                 break;
; 1092 :             }
; 1093 : 
; 1094 :             IOCTL_GPIO_POWER_STATE_IN *pPowerIn;
; 1095 :             pPowerIn = (IOCTL_GPIO_POWER_STATE_IN*)pInBuffer;
; 1096 : 
; 1097 :             bank = GPIO_BANK(pPowerIn->gpioId);
; 1098 : 
; 1099 :             CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 1100 :             if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1101 :             SetGpioBankPowerState(pDevice, pPowerIn->gpioId, pPowerIn->state);
; 1102 :             if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1103 :             rc = TRUE;
; 1104 :         }
; 1105 :         break;
; 1106 : 
; 1107 :     case IOCTL_GPIO_GET_POWER_STATE:
; 1108 :         {
; 1109 :             if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 1110 :                 inSize != sizeof(IOCTL_GPIO_POWER_STATE_IN) ||
; 1111 :                 outSize != sizeof(IOCTL_GPIO_GET_POWER_STATE_OUT))
; 1112 :             {
; 1113 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1114 :                 ERRORMSG(ZONE_ERROR, (L"ERROR: OmapGpioIOControl: "
; 1115 :                     L"IOCTL_GPIO_SET_POWER_STATE - Invalid parameter\r\n"
; 1116 :                     ));
; 1117 :                 break;
; 1118 :             }
; 1119 : 
; 1120 :             IOCTL_GPIO_POWER_STATE_IN *pPowerIn;
; 1121 :             IOCTL_GPIO_GET_POWER_STATE_OUT *pPowerOut;
; 1122 : 
; 1123 :             pPowerIn = (IOCTL_GPIO_POWER_STATE_IN*)pInBuffer;
; 1124 :             pPowerOut = (IOCTL_GPIO_GET_POWER_STATE_OUT*)pOutBuffer;
; 1125 : 
; 1126 :             bit = GPIO_BIT(pPowerIn->gpioId);
; 1127 :             bank = GPIO_BANK(pPowerIn->gpioId);
; 1128 : 
; 1129 :             // get power state for gpio
; 1130 :             CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 1131 :             if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1132 :             pPowerOut->gpioState = (pDevice->bank[bank].powerEnabled & (1 << bit)) ? D0 : D4;
; 1133 :             pPowerOut->bankState = (pDevice->bank[bank].powerEnabled) ? D0 : D4;
; 1134 :             if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1135 : 
; 1136 :             rc = TRUE;
; 1137 :         }
; 1138 : 
; 1139 :     case IOCTL_GPIO_SET_DEBOUNCE_TIME:
; 1140 :         {
; 1141 :             if ((pInBuffer == NULL) ||
; 1142 :                 (inSize < sizeof(IOCTL_GPIO_SET_DEBOUNCE_TIME_IN)))
; 1143 :             {
; 1144 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1145 :                 break;
; 1146 :             }
; 1147 : 
; 1148 :             IOCTL_GPIO_SET_DEBOUNCE_TIME_IN *pDebounce;
; 1149 : 
; 1150 :             pDebounce = (IOCTL_GPIO_SET_DEBOUNCE_TIME_IN*)pInBuffer;
; 1151 : 
; 1152 :             if (pDebounce->gpioId < pDevice->nbBanks*32)
; 1153 :             {
; 1154 :                 CRITICAL_SECTION *pCs;
; 1155 :                 bank = GPIO_BANK(pDebounce->gpioId);
; 1156 :                 pCs = &pDevice->bank[bank].pCs;
; 1157 :                 if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1158 :                 InternalSetGpioBankPowerState(pDevice, pDebounce->gpioId, D0);
; 1159 :                 OUTREG32(&pDevice->bank[bank].ppGpioRegs->DEBOUNCINGTIME,
; 1160 :                     pDebounce->debounceTime);
; 1161 :                 InternalSetGpioBankPowerState(pDevice, pDebounce->gpioId, D4);
; 1162 :                 if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1163 : 
; 1164 :                 // indicate gpio registers need to be saved for OFF mode
; 1165 :                 HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);
; 1166 : 
; 1167 :                 rc = TRUE;
; 1168 :             }
; 1169 :         }
; 1170 :         break;
; 1171 : 
; 1172 :     case IOCTL_GPIO_GET_DEBOUNCE_TIME:
; 1173 :         {
; 1174 :             if ((pInBuffer == NULL) || (pOutBuffer == NULL) ||
; 1175 :                 (inSize < sizeof(UINT)) ||
; 1176 :                 (outSize < sizeof(UINT)))
; 1177 :             {
; 1178 :                 SetLastError(ERROR_INVALID_PARAMETER);
; 1179 :                 break;
; 1180 :             }
; 1181 : 
; 1182 :             UINT *pId;
; 1183 :             UINT *pOut;
; 1184 : 
; 1185 :             pId = (UINT*)pInBuffer;
; 1186 :             pOut = (UINT*)pOutBuffer;
; 1187 : 
; 1188 :             if (*pId < pDevice->nbBanks*32)
; 1189 :             {
; 1190 : 
; 1191 :                 bank = GPIO_BANK(*pId);
; 1192 : 
; 1193 :                 CRITICAL_SECTION *pCs = &pDevice->bank[bank].pCs;
; 1194 :                 if (pDevice->fPostInit) EnterCriticalSection(pCs);
; 1195 :                 InternalSetGpioBankPowerState(pDevice, *pId, D0);
; 1196 :                 *pOut = INREG32(&pDevice->bank[bank].ppGpioRegs->DEBOUNCINGTIME);
; 1197 :                 InternalSetGpioBankPowerState(pDevice, *pId, D4);
; 1198 :                 if (pDevice->fPostInit) LeaveCriticalSection(pCs);
; 1199 : 
; 1200 :                 // indicate gpio registers need to be saved for OFF mode
; 1201 :                 HalContextUpdateDirtyRegister(HAL_CONTEXTSAVE_GPIO);
; 1202 : 
; 1203 :                 rc = TRUE;
; 1204 :             }
; 1205 :         }
; 1206 :         break;
; 1207 :     }
; 1208 : 
; 1209 : cleanUp:
; 1210 :     DEBUGMSG(ZONE_FUNCTION, (L"-OmapGpioIOControl(rc = %d)\r\n", rc));
; 1211 :     return rc;
; 1212 : #endif
; 1213 : 
; 1214 : #ifdef OAL
; 1215 :     UNREFERENCED_PARAMETER(context);
; 1216 :     UNREFERENCED_PARAMETER(code);
; 1217 :     UNREFERENCED_PARAMETER(pInBuffer);
; 1218 :     UNREFERENCED_PARAMETER(inSize);
; 1219 :     UNREFERENCED_PARAMETER(pOutBuffer);
; 1220 :     UNREFERENCED_PARAMETER(outSize);
; 1221 :     UNREFERENCED_PARAMETER(pOutSize);        
; 1222 :     return FALSE;

  012a0	e3a03000	 mov         r3, #0
  012a4	e58d3000	 str         r3, [sp]

; 1223 : #endif
; 1224 : }

  012a8	e59d0000	 ldr         r0, [sp]
  012ac	e28dd004	 add         sp, sp, #4
  012b0	e89d6000	 ldmia       sp, {sp, lr}
  012b4	e12fff1e	 bx          lr
  012b8		 |$M37510|

			 ENDP  ; |?OmapGpioIoControl@@YAHPAXIPAEI1IPAK@Z|, OmapGpioIoControl

	EXPORT	|?OmapGpioPowerUp@@YAXPAX@Z|		; OmapGpioPowerUp

  00060			 AREA	 |.pdata|, PDATA
|$T37517| DCD	|$LN5@OmapGpioPo@2|
	DCD	0x40000503
; Function compile flags: /Odtp

  012b8			 AREA	 |.text|, CODE, ARM

  012b8		 |?OmapGpioPowerUp@@YAXPAX@Z| PROC	; OmapGpioPowerUp

; 1236 : {

  012b8		 |$LN5@OmapGpioPo@2|
  012b8	e1a0c00d	 mov         r12, sp
  012bc	e92d0001	 stmdb       sp!, {r0}
  012c0	e92d5000	 stmdb       sp!, {r12, lr}
  012c4		 |$M37514|

; 1237 :     UNREFERENCED_PARAMETER(hContext);
; 1238 : }

  012c4	e89d6000	 ldmia       sp, {sp, lr}
  012c8	e12fff1e	 bx          lr
  012cc		 |$M37515|

			 ENDP  ; |?OmapGpioPowerUp@@YAXPAX@Z|, OmapGpioPowerUp

	EXPORT	|?OmapGpioPowerDown@@YAXPAX@Z|		; OmapGpioPowerDown

  00068			 AREA	 |.pdata|, PDATA
|$T37522| DCD	|$LN5@OmapGpioPo@3|
	DCD	0x40000503
; Function compile flags: /Odtp

  012cc			 AREA	 |.text|, CODE, ARM

  012cc		 |?OmapGpioPowerDown@@YAXPAX@Z| PROC	; OmapGpioPowerDown

; 1250 : {

  012cc		 |$LN5@OmapGpioPo@3|
  012cc	e1a0c00d	 mov         r12, sp
  012d0	e92d0001	 stmdb       sp!, {r0}
  012d4	e92d5000	 stmdb       sp!, {r12, lr}
  012d8		 |$M37519|

; 1251 :     UNREFERENCED_PARAMETER(hContext);
; 1252 : }

  012d8	e89d6000	 ldmia       sp, {sp, lr}
  012dc	e12fff1e	 bx          lr
  012e0		 |$M37520|

			 ENDP  ; |?OmapGpioPowerDown@@YAXPAX@Z|, OmapGpioPowerDown

	END
