; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\COMMON\SRC\SOC\COMMON_TI_V1\TPS659XX\KEYPAD\keypad.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BK@MBPNPOKM@?$AAK?$AAe?$AAy?$AAp?$AAa?$AAd?$AAL?$AAe?$AAd?$AAN?$AAu?$AAm?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@CGBLFBGH@?$AAK?$AAe?$AAy?$AAp?$AAa?$AAd?$AAL?$AAi?$AAg?$AAh?$AAt?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@MAKEJFGC@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAM?$AAa?$AAs?$AAk?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@NNCBJPIE@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAO?$AAf?$AAf?$AAK?$AAe?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@BCDOPOGB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@PCIKFLJA@?$AAC?$AAl?$AAo?$AAc?$AAk?$AAD?$AAi?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|DEVICE_IFC_TWL_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@MBPNPOKM@?$AAK?$AAe?$AAy?$AAp?$AAa?$AAd?$AAL?$AAe?$AAd?$AAN?$AAu?$AAm?$AA?$AA@| DCB "K"
	DCB	0x0, "e", 0x0, "y", 0x0, "p", 0x0, "a", 0x0, "d", 0x0, "L"
	DCB	0x0, "e", 0x0, "d", 0x0, "N", 0x0, "u", 0x0, "m", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CG@CGBLFBGH@?$AAK?$AAe?$AAy?$AAp?$AAa?$AAd?$AAL?$AAi?$AAg?$AAh?$AAt?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@| DCB "K"
	DCB	0x0, "e", 0x0, "y", 0x0, "p", 0x0, "a", 0x0, "d", 0x0, "L"
	DCB	0x0, "i", 0x0, "g", 0x0, "h", 0x0, "t", 0x0, "T", 0x0, "i"
	DCB	0x0, "m", 0x0, "e", 0x0, "o", 0x0, "u", 0x0, "t", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@MAKEJFGC@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAM?$AAa?$AAs?$AAk?$AA?$AA@| DCB "P"
	DCB	0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r", 0x0, "M", 0x0, "a"
	DCB	0x0, "s", 0x0, "k", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@NNCBJPIE@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAO?$AAf?$AAf?$AAK?$AAe?$AAy?$AA?$AA@| DCB "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "O"
	DCB	0x0, "f", 0x0, "f", 0x0, "K", 0x0, "e", 0x0, "y", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| DCB "N"
	DCB	0x0, "e", 0x0, "x", 0x0, "t", 0x0, "R", 0x0, "e", 0x0, "p"
	DCB	0x0, "e", 0x0, "a", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@| DCB "F"
	DCB	0x0, "i", 0x0, "r", 0x0, "s", 0x0, "t", 0x0, "R", 0x0, "e"
	DCB	0x0, "p", 0x0, "e", 0x0, "a", 0x0, "t", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@| DCB "S"
	DCB	0x0, "a", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "P"
	DCB	0x0, "e", 0x0, "r", 0x0, "i", 0x0, "o", 0x0, "d", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@BCDOPOGB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "b", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "c"
	DCB	0x0, "e", 0x0, "C", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "t"
	DCB	0x0, "e", 0x0, "r", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@PCIKFLJA@?$AAC?$AAl?$AAo?$AAc?$AAk?$AAD?$AAi?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@| DCB "C"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, "D", 0x0, "i"
	DCB	0x0, "v", 0x0, "i", 0x0, "d", 0x0, "e", 0x0, "r", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| DCB "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "k", 0x0, "e", 0x0, "y", 0x0, "p", 0x0, "a", 0x0, "d", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0
	%	56
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCD	0x3
|g_iDisplayOrientation| DCD 0xffffffff

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|DEVICE_IFC_TWL_GUID| DCD 0xdef0a04b
	DCW	0xb967
	DCW	0x43db
	DCB	0x95
	DCB	0x9e
	DCB	0xd9
	DCB	0xfc
	DCB	0x62
	DCB	0x25
	DCB	0xcd
	DCB	0xeb
|s_deviceRegParams| DCD |??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0x64
	DCD	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BK@PCIKFLJA@?$AAC?$AAl?$AAo?$AAc?$AAk?$AAD?$AAi?$AAv?$AAi?$AAd?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x5
	DCD	|??_C@_1CA@BCDOPOGB@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10
	DCD	0x4
	DCD	0x4
	DCD	|??_C@_1BK@LFBEMINK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAP?$AAe?$AAr?$AAi?$AAo?$AAd?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x28
	DCD	|??_C@_1BI@DEPDCBKF@?$AAF?$AAi?$AAr?$AAs?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18
	DCD	0x4
	DCD	0x1f4
	DCD	|??_C@_1BG@LIOJCANL@?$AAN?$AAe?$AAx?$AAt?$AAR?$AAe?$AAp?$AAe?$AAa?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x1c
	DCD	0x4
	DCD	0x7d
	DCD	|??_C@_1BK@NNCBJPIE@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAO?$AAf?$AAf?$AAK?$AAe?$AAy?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x40
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1BE@MAKEJFGC@?$AAP?$AAo?$AAw?$AAe?$AAr?$AAM?$AAa?$AAs?$AAk?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x2c
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CG@CGBLFBGH@?$AAK?$AAe?$AAy?$AAp?$AAa?$AAd?$AAL?$AAi?$AAg?$AAh?$AAt?$AAT?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x48
	DCD	0x4
	DCD	0x1388
	DCD	|??_C@_1BK@MBPNPOKM@?$AAK?$AAe?$AAy?$AAp?$AAa?$AAd?$AAL?$AAe?$AAd?$AAN?$AAu?$AAm?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x44
	DCD	0x4
	DCD	0xffffffff
|?ucOrientationDMDO_0VKTable@?1??RemapVKeyToScreenOrientation@@9@9| DCB 0x26 ; `RemapVKeyToScreenOrientation'::`2'::ucOrientationDMDO_0VKTable
	DCB	0x27
	DCB	0x28
	DCB	0x25
|?ucOrientationDMDO_90VKTable@?1??RemapVKeyToScreenOrientation@@9@9| DCB 0x27 ; `RemapVKeyToScreenOrientation'::`2'::ucOrientationDMDO_90VKTable
	DCB	0x28
	DCB	0x25
	DCB	0x26
|?ucOrientationDMDO_180VKTable@?1??RemapVKeyToScreenOrientation@@9@9| DCB 0x28 ; `RemapVKeyToScreenOrientation'::`2'::ucOrientationDMDO_180VKTable
	DCB	0x25
	DCB	0x26
	DCB	0x27
|?ucOrientationDMDO_270VKTable@?1??RemapVKeyToScreenOrientation@@9@9| DCB 0x25 ; `RemapVKeyToScreenOrientation'::`2'::ucOrientationDMDO_270VKTable
	DCB	0x26
	DCB	0x27
	DCB	0x28
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44292| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M44289|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M44290|

			 ENDP  ; |SetEvent|

	EXPORT	|SetPowerState|
	EXPORT	|??_C@_1GK@HKLOGBGD@?$AAW?$AAA?$AAR?$AAN?$AA?3?$AA?5?$AAK?$AAP?$AAD?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAP?$AAo?$AAw?$AAe?$AAr?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\keypad\keypad.c

  00000			 AREA	 |.pdata|, PDATA
|$T44306| DCD	|$LN11@SetPowerSt|
	DCD	0x40001201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GK@HKLOGBGD@?$AAW?$AAA?$AAR?$AAN?$AA?3?$AA?5?$AAK?$AAP?$AAD?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAP?$AAo?$AAw?$AAe?$AAr?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi@| DCB "W"
	DCB	0x0, "A", 0x0, "R", 0x0, "N", 0x0, ":", 0x0, " ", 0x0, "K"
	DCB	0x0, "P", 0x0, "D", 0x0, ":", 0x0, ":", 0x0, "S", 0x0, "e"
	DCB	0x0, "t", 0x0, "P", 0x0, "o", 0x0, "w", 0x0, "e", 0x0, "r"
	DCB	0x0, "S", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, ":"
	DCB	0x0, " ", 0x0, "I", 0x0, "n", 0x0, "v", 0x0, "a", 0x0, "l"
	DCB	0x0, "i", 0x0, "d", 0x0, " ", 0x0, "p", 0x0, "o", 0x0, "w"
	DCB	0x0, "e", 0x0, "r", 0x0, " ", 0x0, "s", 0x0, "t", 0x0, "a"
	DCB	0x0, "t", 0x0, "e", 0x0, " ", 0x0, "(", 0x0, "%", 0x0, "d"
	DCB	0x0, ")", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetPowerState| PROC

; 297  : {

  00000		 |$LN11@SetPowerSt|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44303|
  00004	e3510000	 cmp         r1, #0

; 298  :     BOOL rc = FALSE;

  00008	e3a04000	 mov         r4, #0

; 299  :     
; 300  :     DEBUGMSG(ZONE_FUNCTION, (
; 301  :         L"+SetPowerState(0x%08X, 0x%08x)\r\n", pDevice, power
; 302  :         ));
; 303  : 
; 304  :     switch (power)

  0000c	4a000003	 bmi         |$LN1@SetPowerSt|
  00010	e3510004	 cmp         r1, #4

; 317  :             goto cleanUp;
; 318  :         }
; 319  : 
; 320  :     pDevice->powerState = power;

  00014	d5801030	 strle       r1, [r0, #0x30]

; 321  : 
; 322  :     rc = TRUE;

  00018	d3a04001	 movle       r4, #1
  0001c	da000004	 ble         |$cleanUp$43812|
  00020		 |$LN1@SetPowerSt|

; 305  :         {
; 306  :         case D0:
; 307  :         case D1:
; 308  :         case D2:
; 309  :         case D3:
; 310  :         case D4:
; 311  :             break;
; 312  : 
; 313  :         default:
; 314  :             RETAILMSG(ZONE_WARN, (L"WARN: KPD::SetPowerState: "
; 315  :                 L"Invalid power state (%d)\r\n", power
; 316  :                 ));            

  00020	e59f301c	 ldr         r3, [pc, #0x1C]
  00024	e5933440	 ldr         r3, [r3, #0x440]
  00028	e3130002	 tst         r3, #2
  0002c	159f000c	 ldrne       r0, [pc, #0xC]
  00030	1b000000	 blne        NKDbgPrintfW
  00034		 |$cleanUp$43812|

; 323  :     
; 324  : cleanUp:
; 325  :     DEBUGMSG(ZONE_FUNCTION, (
; 326  :         L"-SetPowerState(0x%08X, 0x%08x)\r\n", pDevice, power
; 327  :         ));
; 328  :         
; 329  :     return rc;
; 330  : }

  00034	e1a00004	 mov         r0, r4
  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN12@SetPowerSt|
  00040		 |$LN13@SetPowerSt|
  00040	00000000	 DCD         |??_C@_1GK@HKLOGBGD@?$AAW?$AAA?$AAR?$AAN?$AA?3?$AA?5?$AAK?$AAP?$AAD?$AA?3?$AA?3?$AAS?$AAe?$AAt?$AAP?$AAo?$AAw?$AAe?$AAr?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi@|
  00044		 |$LN14@SetPowerSt|
  00044	00000000	 DCD         |dpCurSettings|
  00048		 |$M44304|

			 ENDP  ; |SetPowerState|

	EXPORT	|KPD_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|TWLClose|
	IMPORT	|TWLInterruptDisable|
	IMPORT	|TWLInterruptMask|
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44328| DCD	|$LN17@KPD_Deinit|
	DCD	0x40003d01
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\keypad\keypad.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Deinit| PROC

; 490  : {

  00000		 |$LN17@KPD_Deinit|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M44325|
  00004	e1b04000	 movs        r4, r0

; 491  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 492  :     KeypadDevice_t *pDevice = (KeypadDevice_t*)context;
; 493  : 
; 494  : 
; 495  :     DEBUGMSG(ZONE_FUNCTION, (L"+KPD_Deinit(0x%08x)\r\n", context));
; 496  : 
; 497  :     // Check if we get correct context
; 498  :     if ((pDevice == NULL) || (pDevice->cookie != KPD_DEVICE_COOKIE))

  0000c	0a000035	 beq         |$cleanUp$43879|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f30d4	 ldr         r3, [pc, #0xD4]
  00018	e1520003	 cmp         r2, r3
  0001c	1a000031	 bne         |$cleanUp$43879|

; 499  :         {
; 500  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Deinit: "
; 501  :             L"Incorrect context parameter\r\n"
; 502  :             ));
; 503  :         goto cleanUp;
; 504  :         }
; 505  : 
; 506  :     // Signal stop to threads
; 507  :     pDevice->intrThreadExit = TRUE;
; 508  :         
; 509  :     // Close interrupt thread
; 510  :     if (pDevice->hIntrThreadKeypad != NULL)

  00020	e5943024	 ldr         r3, [r4, #0x24]
  00024	e3a02001	 mov         r2, #1
  00028	e5842028	 str         r2, [r4, #0x28]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000007	 beq         |$LN6@KPD_Deinit|

; 511  :         {
; 512  :         // Set event to wake it
; 513  :         SetEvent(pDevice->hIntrEventKeypad);

  00034	e5940020	 ldr         r0, [r4, #0x20]
  00038	e3a01003	 mov         r1, #3
  0003c	eb000000	 bl          EventModify

; 514  :         // Wait until thread exits
; 515  :         WaitForSingleObject(pDevice->hIntrThreadKeypad, INFINITE);

  00040	e5940024	 ldr         r0, [r4, #0x24]
  00044	e3e01000	 mvn         r1, #0
  00048	eb000000	 bl          WaitForSingleObject

; 516  :         // Close handle
; 517  :         CloseHandle(pDevice->hIntrThreadKeypad);

  0004c	e5940024	 ldr         r0, [r4, #0x24]
  00050	eb000000	 bl          CloseHandle
  00054		 |$LN6@KPD_Deinit|

; 518  :         }
; 519  : 
; 520  :     // Close interrupt thread
; 521  :     if( pDevice->hLightThread )

  00054	e5943038	 ldr         r3, [r4, #0x38]
  00058	e3530000	 cmp         r3, #0
  0005c	0a000007	 beq         |$LN5@KPD_Deinit|

; 522  :             {
; 523  :             // Set event to wake it
; 524  :         SetEvent(pDevice->hKeypressEvent);

  00060	e594003c	 ldr         r0, [r4, #0x3C]
  00064	e3a01003	 mov         r1, #3
  00068	eb000000	 bl          EventModify

; 525  :             // Wait until thread exits
; 526  :         WaitForSingleObject(pDevice->hLightThread, INFINITE);

  0006c	e5940038	 ldr         r0, [r4, #0x38]
  00070	e3e01000	 mvn         r1, #0
  00074	eb000000	 bl          WaitForSingleObject

; 527  :             // Close handle
; 528  :         CloseHandle(pDevice->hLightThread);

  00078	e5940038	 ldr         r0, [r4, #0x38]
  0007c	eb000000	 bl          CloseHandle
  00080		 |$LN5@KPD_Deinit|

; 529  :         }
; 530  : 
; 531  : 
; 532  :     // Close TWL driver
; 533  :     if (pDevice->hTWL != NULL)

  00080	e5943034	 ldr         r3, [r4, #0x34]
  00084	e3530000	 cmp         r3, #0
  00088	0a00000b	 beq         |$LN4@KPD_Deinit|

; 534  :         {
; 535  :         TWLInterruptMask(pDevice->hTWL, TWL_INTR_ITKPI, TRUE);

  0008c	e3a05a01	 mov         r5, #1, 20
  00090	e385102a	 orr         r1, r5, #0x2A
  00094	e3a02001	 mov         r2, #1
  00098	e1a00003	 mov         r0, r3
  0009c	eb000000	 bl          TWLInterruptMask

; 536  :         
; 537  :         if (pDevice->hIntrEventKeypad != NULL)

  000a0	e5943020	 ldr         r3, [r4, #0x20]
  000a4	e3530000	 cmp         r3, #0

; 538  :             {
; 539  :             TWLInterruptDisable(pDevice->hTWL, TWL_INTR_ITKPI);

  000a8	15940034	 ldrne       r0, [r4, #0x34]
  000ac	1385102a	 orrne       r1, r5, #0x2A
  000b0	1b000000	 blne        TWLInterruptDisable

; 540  :             }
; 541  :         
; 542  :         TWLClose(pDevice->hTWL);

  000b4	e5940034	 ldr         r0, [r4, #0x34]
  000b8	eb000000	 bl          TWLClose
  000bc		 |$LN4@KPD_Deinit|

; 543  :         }
; 544  : 
; 545  :     // Close interrupt handler
; 546  :     if (pDevice->hIntrEventKeypad != NULL) CloseHandle(pDevice->hIntrEventKeypad);

  000bc	e5943020	 ldr         r3, [r4, #0x20]
  000c0	e3530000	 cmp         r3, #0
  000c4	11a00003	 movne       r0, r3
  000c8	1b000000	 blne        CloseHandle

; 547  :     if (pDevice->hKeypressEvent != NULL) CloseHandle(pDevice->hKeypressEvent);

  000cc	e594303c	 ldr         r3, [r4, #0x3C]
  000d0	e3530000	 cmp         r3, #0
  000d4	11a00003	 movne       r0, r3
  000d8	1b000000	 blne        CloseHandle

; 548  :     // Free device structure
; 549  :     LocalFree(pDevice);

  000dc	e1a00004	 mov         r0, r4
  000e0	eb000000	 bl          LocalFree

; 550  : 
; 551  :     // Done
; 552  :     rc = TRUE;

  000e4	e3a00001	 mov         r0, #1
  000e8		 |$cleanUp$43879|

; 553  : 
; 554  : cleanUp:
; 555  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_Deinit(rc = %d)\r\n", rc));
; 556  :     return rc;
; 557  : }

  000e8	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000ec	e12fff1e	 bx          lr
  000f0		 |$LN18@KPD_Deinit|
  000f0		 |$LN19@KPD_Deinit|
  000f0	6b706444	 DCD         0x6b706444
  000f4		 |$M44326|

			 ENDP  ; |KPD_Deinit|

	EXPORT	|KPD_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T44340| DCD	|$LN5@KPD_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Open| PROC

; 571  : {

  00000		 |$LN5@KPD_Open|
  00000		 |$M44337|

; 572  :     UNREFERENCED_PARAMETER(context);
; 573  :     UNREFERENCED_PARAMETER(accessCode);
; 574  :     UNREFERENCED_PARAMETER(shareMode);
; 575  :     return context;
; 576  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44338|

			 ENDP  ; |KPD_Open|

	EXPORT	|KPD_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T44349| DCD	|$LN5@KPD_Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Close| PROC

; 588  : {

  00000		 |$LN5@KPD_Close|
  00000		 |$M44346|

; 589  :     UNREFERENCED_PARAMETER(context);
; 590  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 591  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M44347|

			 ENDP  ; |KPD_Close|

	EXPORT	|KPD_PowerUp|

  00000			 AREA	 |.pdata|, PDATA
|$T44356| DCD	|$LN5@KPD_PowerU|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_PowerUp| PROC

; 605  : {

  00000		 |$LN5@KPD_PowerU|
  00000		 |$M44353|

; 606  :     UNREFERENCED_PARAMETER(context);
; 607  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M44354|

			 ENDP  ; |KPD_PowerUp|

	EXPORT	|KPD_IOControl|
	EXPORT	|??_C@_1GI@MFFMFLPL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAK?$AAP?$AAD?$AA_?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EA@BHHDBCBL@?$AAK?$AAP?$AAD?$AA?3?$AA?5?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAG?$AAE?$AAT?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@NKFDJLND@?$AAK?$AAP?$AAD?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAD?$AA?$CF?$AAu?$AA?5?$AA?$AN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|__C_specific_handler|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T44430| DCD	|$LN76@KPD_IOCont|
	DCD	0xc0008904

  00000			 AREA	 |.pdata|, PDATA
|$T44432| DCD	|$LN37@KPD_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T44434| DCD	|$LN58@KPD_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T44436| DCD	|$LN51@KPD_IOCont|
	DCD	0x40000301

  00000			 AREA	 |.pdata|, PDATA
|$T44438| DCD	|$LN44@KPD_IOCont|
	DCD	0x40000d01

  00000			 AREA	 |.xdata|, DATA
|$T44428| DCD	0x4
	DCD	|$LN41@KPD_IOCont|
	DCD	|$LN42@KPD_IOCont|
	DCD	|$LN37@KPD_IOCont|
	DCD	|$LN38@KPD_IOCont|
	DCD	|$LN62@KPD_IOCont|
	DCD	|$LN63@KPD_IOCont|
	DCD	|$LN58@KPD_IOCont|
	DCD	|$LN59@KPD_IOCont|
	DCD	|$LN55@KPD_IOCont|
	DCD	|$LN56@KPD_IOCont|
	DCD	|$LN51@KPD_IOCont|
	DCD	|$LN52@KPD_IOCont|
	DCD	|$LN48@KPD_IOCont|
	DCD	|$LN49@KPD_IOCont|
	DCD	|$LN44@KPD_IOCont|
	DCD	|$LN45@KPD_IOCont|

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@MFFMFLPL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAK?$AAP?$AAD?$AA_?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "K", 0x0, "P", 0x0, "D", 0x0, "_", 0x0, "I", 0x0, "O"
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o"
	DCB	0x0, "l", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "c"
	DCB	0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c", 0x0, "t"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "x", 0x0, "t", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "r"
	DCB	0x0, "a", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "e"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@BHHDBCBL@?$AAK?$AAP?$AAD?$AA?3?$AA?5?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAG?$AAE?$AAT?$AA?$AN?$AA?6?$AA?$AA@| DCB "K"
	DCB	0x0, "P", 0x0, "D", 0x0, ":", 0x0, " ", 0x0, "R", 0x0, "e"
	DCB	0x0, "c", 0x0, "e", 0x0, "i", 0x0, "v", 0x0, "e", 0x0, "d"
	DCB	0x0, " ", 0x0, "I", 0x0, "O", 0x0, "C", 0x0, "T", 0x0, "L"
	DCB	0x0, "_", 0x0, "P", 0x0, "O", 0x0, "W", 0x0, "E", 0x0, "R"
	DCB	0x0, "_", 0x0, "G", 0x0, "E", 0x0, "T", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@NKFDJLND@?$AAK?$AAP?$AAD?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAD?$AA?$CF?$AAu?$AA?5?$AA?$AN@| DCB "K"
	DCB	0x0, "P", 0x0, "D", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n"
	DCB	0x0, "v", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "d", 0x0, " "
	DCB	0x0, "s", 0x0, "t", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, " "
	DCB	0x0, "r", 0x0, "e", 0x0, "q", 0x0, "u", 0x0, "e", 0x0, "s"
	DCB	0x0, "t", 0x0, " ", 0x0, "D", 0x0, "%", 0x0, "u", 0x0, " "
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "x", 0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i"
	DCB	0x0, "o", 0x0, "n", 0x0, " ", 0x0, "i", 0x0, "n", 0x0, " "
	DCB	0x0, "i", 0x0, "o", 0x0, "c", 0x0, "t", 0x0, "l", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__C_specific_handler|
  00004	00000000	 DCD         |$T44428|

  00008		 |KPD_IOControl| PROC

; 625  : {

  00008		 |$LN76@KPD_IOCont|
  00008	e1a0c00d	 mov         r12, sp
  0000c	e92d58f0	 stmdb       sp!, {r4 - r7, r11, r12, lr}
  00010	e28db01c	 add         r11, sp, #0x1C
  00014	e24dd008	 sub         sp, sp, #8
  00018		 |$LN74@KPD_IOCont|
  00018	e1b06000	 movs        r6, r0

; 626  :     BOOL rc = FALSE;

  0001c	e3a04000	 mov         r4, #0
  00020	e50b4024	 str         r4, [r11, #-0x24]

; 627  :     KeypadDevice_t *pDevice = (KeypadDevice_t*)context;
; 628  : 
; 629  :     UNREFERENCED_PARAMETER(inSize);
; 630  :     UNREFERENCED_PARAMETER(pInBuffer);
; 631  : 
; 632  :     DEBUGMSG(ZONE_FUNCTION, (
; 633  :         L"+KPD_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 634  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 635  :         ));
; 636  :         
; 637  :     // Check if we get correct context
; 638  :     if ((pDevice == NULL) || (pDevice->cookie != KPD_DEVICE_COOKIE))

  00024	0a000077	 beq         |$LN18@KPD_IOCont|
  00028	e5962000	 ldr         r2, [r6]
  0002c	e59f324c	 ldr         r3, [pc, #0x24C]
  00030	e1520003	 cmp         r2, r3
  00034	1a000073	 bne         |$LN18@KPD_IOCont|
  00038	e3a03832	 mov         r3, #0x32, 16

; 643  :         goto cleanUp;
; 644  :         }
; 645  :     
; 646  :     switch (code)

  0003c	e3833a01	 orr         r3, r3, #1, 20
  00040	e1510003	 cmp         r1, r3
  00044	0a000052	 beq         |$LN15@KPD_IOCont|
  00048	e59f322c	 ldr         r3, [pc, #0x22C]
  0004c	e1510003	 cmp         r1, r3
  00050	0a000038	 beq         |$LN3@KPD_IOCont|
  00054	e59f321c	 ldr         r3, [pc, #0x21C]
  00058	e1510003	 cmp         r1, r3
  0005c	0a000014	 beq         |$LN8@KPD_IOCont|
  00060	e59f320c	 ldr         r3, [pc, #0x20C]
  00064	e1510003	 cmp         r1, r3
  00068	1a00006b	 bne         |$cleanUp$43932|

; 668  :                         }
; 669  :                 }
; 670  :             break;
; 671  : 
; 672  :         // determines whether changing power state is feasible
; 673  :         case IOCTL_POWER_QUERY: 
; 674  :             DEBUGMSG(ZONE_INFO,(L"KPD: Received IOCTL_POWER_QUERY\r\n"));
; 675  :             if (pOutBuffer && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  0006c	e59b2000	 ldr         r2, [r11]
  00070	e3520000	 cmp         r2, #0
  00074	0a000068	 beq         |$cleanUp$43932|
  00078	e59b3004	 ldr         r3, [r11, #4]
  0007c	e3530004	 cmp         r3, #4
  00080	3a000065	 bcc         |$cleanUp$43932|
  00084		 |$LN48@KPD_IOCont|

; 676  :                 {
; 677  :                 // Return a good status on any valid query, since we are 
; 678  :                 // always ready to change power states (if asked for state 
; 679  :                 // we don't support, we move to next highest, eg D3->D4).
; 680  :                 __try 
; 681  :                     {
; 682  :                     CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pOutBuffer;

  00084	e5923000	 ldr         r3, [r2]

; 683  :  
; 684  :                     if (VALID_DX(ReqDx)) 

  00088	e3530004	 cmp         r3, #4

; 685  :                         {
; 686  :                         // This is a valid Dx state so return a good status.
; 687  :                         rc = TRUE;

  0008c	93a04001	 movls       r4, #1
  00090	950b4024	 strls       r4, [r11, #-0x24]
  00094		 |$LN49@KPD_IOCont|

; 688  :                         }
; 689  :  
; 690  :                     DEBUGMSG(ZONE_INFO, (L"KPD: IOCTL_POWER_QUERY %d\r\n"));
; 691  :                     }

  00094	ea000060	 b           |$cleanUp$43932|
  00098		 |$LN45@KPD_IOCont|

; 693  :                     {
; 694  :                     RETAILMSG(ZONE_ERROR, (L"Exception in ioctl\r\n"));

  00098	e59f31c0	 ldr         r3, [pc, #0x1C0]
  0009c	e5933440	 ldr         r3, [r3, #0x440]
  000a0	e3130001	 tst         r3, #1
  000a4	159f01bc	 ldrne       r0, [pc, #0x1BC]
  000a8	1b000000	 blne        NKDbgPrintfW
  000ac	e51b4024	 ldr         r4, [r11, #-0x24]
  000b0	ea000059	 b           |$cleanUp$43932|
  000b4		 |$LN8@KPD_IOCont|

; 695  :                     }
; 696  :                 }
; 697  :             break;
; 698  : 
; 699  :         // requests a change from one device power state to another
; 700  :         case IOCTL_POWER_SET: 
; 701  :             DEBUGMSG(ZONE_INFO,(L"KPD: Received IOCTL_POWER_SET\r\n"));
; 702  :             if (pOutBuffer && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  000b4	e59b5000	 ldr         r5, [r11]
  000b8	e3550000	 cmp         r5, #0
  000bc	0a000056	 beq         |$cleanUp$43932|
  000c0	e59b3004	 ldr         r3, [r11, #4]
  000c4	e3530004	 cmp         r3, #4
  000c8	3a000053	 bcc         |$cleanUp$43932|
  000cc		 |$LN55@KPD_IOCont|

; 703  :                 {
; 704  :                 __try 
; 705  :                     {
; 706  :                     CEDEVICE_POWER_STATE ReqDx = *(PCEDEVICE_POWER_STATE)pOutBuffer;

  000cc	e5957000	 ldr         r7, [r5]

; 707  :  
; 708  :                     if (SetPowerState(pDevice, ReqDx))

  000d0	e1a00006	 mov         r0, r6
  000d4	e1a01007	 mov         r1, r7
  000d8	eb000000	 bl          SetPowerState
  000dc	e3500000	 cmp         r0, #0

; 709  :                         {   
; 710  :                         *(PCEDEVICE_POWER_STATE)pOutBuffer = pDevice->powerState;

  000e0	15963030	 ldrne       r3, [r6, #0x30]

; 711  :                         *pOutSize = sizeof(CEDEVICE_POWER_STATE);

  000e4	159b2008	 ldrne       r2, [r11, #8]
  000e8	13a01004	 movne       r1, #4
  000ec	15853000	 strne       r3, [r5]
  000f0	15821000	 strne       r1, [r2]

; 712  :  
; 713  :                         rc = TRUE;

  000f4	13a04001	 movne       r4, #1
  000f8	150b4024	 strne       r4, [r11, #-0x24]

; 707  :  
; 708  :                     if (SetPowerState(pDevice, ReqDx))

  000fc	1a000005	 bne         |$LN56@KPD_IOCont|

; 714  :                         DEBUGMSG(ZONE_INFO, (L"KPD: "
; 715  :                             L"IOCTL_POWER_SET to D%u \r\n",
; 716  :                             pDevice->powerState
; 717  :                             ));
; 718  :                         }
; 719  :                     else 
; 720  :                         {
; 721  :                         RETAILMSG(ZONE_ERROR, (L"KPD: "
; 722  :                             L"Invalid state request D%u \r\n", ReqDx
; 723  :                             ));

  00100	e59f3158	 ldr         r3, [pc, #0x158]
  00104	e5933440	 ldr         r3, [r3, #0x440]
  00108	e3130001	 tst         r3, #1
  0010c	159f015c	 ldrne       r0, [pc, #0x15C]
  00110	11a01007	 movne       r1, r7
  00114	1b000000	 blne        NKDbgPrintfW
  00118		 |$LN56@KPD_IOCont|

; 724  :                         }
; 725  :                     }

  00118	ea00003f	 b           |$cleanUp$43932|
  0011c		 |$LN52@KPD_IOCont|

; 727  :                     {
; 728  :                     RETAILMSG(ZONE_ERROR, (L"Exception in ioctl\r\n"));

  0011c	e59f313c	 ldr         r3, [pc, #0x13C]
  00120	e5933440	 ldr         r3, [r3, #0x440]
  00124	e3130001	 tst         r3, #1
  00128	159f0138	 ldrne       r0, [pc, #0x138]
  0012c	1b000000	 blne        NKDbgPrintfW
  00130	e51b4024	 ldr         r4, [r11, #-0x24]
  00134	ea000038	 b           |$cleanUp$43932|
  00138		 |$LN3@KPD_IOCont|

; 729  :                     }
; 730  :             }
; 731  :             break;
; 732  : 
; 733  :         // gets the current device power state
; 734  :         case IOCTL_POWER_GET: 
; 735  :             RETAILMSG(ZONE_INFO, (L"KPD: Received IOCTL_POWER_GET\r\n"));

  00138	e59f3120	 ldr         r3, [pc, #0x120]
  0013c	e5933440	 ldr         r3, [r3, #0x440]
  00140	e3130008	 tst         r3, #8
  00144	159f0120	 ldrne       r0, [pc, #0x120]
  00148	1b000000	 blne        NKDbgPrintfW

; 736  :             if (pOutBuffer != NULL && outSize >= sizeof(CEDEVICE_POWER_STATE)) 

  0014c	e59b2000	 ldr         r2, [r11]
  00150	e3520000	 cmp         r2, #0
  00154	0a000030	 beq         |$cleanUp$43932|
  00158	e59b3004	 ldr         r3, [r11, #4]
  0015c	e3530004	 cmp         r3, #4
  00160	3a00002d	 bcc         |$cleanUp$43932|
  00164		 |$LN62@KPD_IOCont|

; 737  :                 {
; 738  :                 __try 
; 739  :                     {
; 740  :                     *(PCEDEVICE_POWER_STATE)pOutBuffer = pDevice->powerState;

  00164	e5963030	 ldr         r3, [r6, #0x30]
  00168	e5823000	 str         r3, [r2]

; 741  :  
; 742  :                     rc = TRUE;

  0016c	e3a04001	 mov         r4, #1
  00170	e50b4024	 str         r4, [r11, #-0x24]
  00174		 |$LN63@KPD_IOCont|

; 743  : 
; 744  :                     DEBUGMSG(ZONE_INFO, (L"KPD: "
; 745  :                             L"IOCTL_POWER_GET to D%u \r\n",
; 746  :                             pDevice->powerState
; 747  :                             ));
; 748  :                     }

  00174	ea000028	 b           |$cleanUp$43932|
  00178		 |$LN59@KPD_IOCont|

; 750  :                     {
; 751  :                     RETAILMSG(ZONE_ERROR, (L"Exception in ioctl\r\n"));

  00178	e59f30e0	 ldr         r3, [pc, #0xE0]
  0017c	e5933440	 ldr         r3, [r3, #0x440]
  00180	e3130001	 tst         r3, #1
  00184	159f00dc	 ldrne       r0, [pc, #0xDC]
  00188	1b000000	 blne        NKDbgPrintfW
  0018c	e51b4024	 ldr         r4, [r11, #-0x24]
  00190	ea000021	 b           |$cleanUp$43932|
  00194		 |$LN15@KPD_IOCont|

; 647  :         {
; 648  :         case IOCTL_POWER_CAPABILITIES: 
; 649  :             DEBUGMSG(ZONE_INFO, (L"KPD: Received IOCTL_POWER_CAPABILITIES\r\n"));
; 650  :             if (pOutBuffer && outSize >= sizeof (POWER_CAPABILITIES) && 
; 651  :                 pOutSize) 

  00194	e59b5000	 ldr         r5, [r11]
  00198	e3550000	 cmp         r5, #0
  0019c	0a00001e	 beq         |$cleanUp$43932|
  001a0	e59b3004	 ldr         r3, [r11, #4]
  001a4	e3530030	 cmp         r3, #0x30
  001a8	3a00001b	 bcc         |$cleanUp$43932|
  001ac	e59b7008	 ldr         r7, [r11, #8]
  001b0	e3570000	 cmp         r7, #0
  001b4	0a000018	 beq         |$cleanUp$43932|
  001b8		 |$LN41@KPD_IOCont|

; 652  :                 {
; 653  :                     __try 
; 654  :                         {
; 655  :                         PPOWER_CAPABILITIES PowerCaps;
; 656  :                         PowerCaps = (PPOWER_CAPABILITIES)pOutBuffer;
; 657  :          
; 658  :                         // Only supports D0 (permanently on) and D4(off.         
; 659  :                         memset(PowerCaps, 0, sizeof(*PowerCaps));

  001b8	e3a02030	 mov         r2, #0x30
  001bc	e3a01000	 mov         r1, #0
  001c0	e1a00005	 mov         r0, r5
  001c4	eb000000	 bl          memset

; 660  :                         PowerCaps->DeviceDx = (UCHAR)pDevice->powerMask;

  001c8	e596302c	 ldr         r3, [r6, #0x2C]

; 661  :                         *pOutSize = sizeof(*PowerCaps);

  001cc	e3a02030	 mov         r2, #0x30
  001d0	e5c53000	 strb        r3, [r5]
  001d4	e5872000	 str         r2, [r7]

; 662  :                         
; 663  :                         rc = TRUE;

  001d8	e3a04001	 mov         r4, #1
  001dc	e50b4024	 str         r4, [r11, #-0x24]
  001e0		 |$LN42@KPD_IOCont|

; 664  :                         }

  001e0	ea00000d	 b           |$cleanUp$43932|
  001e4		 |$LN38@KPD_IOCont|

; 666  :                         {
; 667  :                         RETAILMSG(ZONE_ERROR, (L"exception in ioctl\r\n"));

  001e4	e59f3074	 ldr         r3, [pc, #0x74]
  001e8	e5933440	 ldr         r3, [r3, #0x440]
  001ec	e3130001	 tst         r3, #1
  001f0	159f006c	 ldrne       r0, [pc, #0x6C]
  001f4	1b000000	 blne        NKDbgPrintfW
  001f8	e51b4024	 ldr         r4, [r11, #-0x24]
  001fc	ea000006	 b           |$cleanUp$43932|
  00200		 |$LN73@KPD_IOCont|

; 752  :                     }
; 753  :                 }     
; 754  :             break;
; 755  :         }
; 756  : 
; 757  : cleanUp:
; 758  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_IOControl(rc = %d)\r\n", rc));
; 759  :     return rc;

  00200	e51b4020	 ldr         r4, [r11, #-0x20]
  00204	ea000004	 b           |$cleanUp$43932|
  00208		 |$LN18@KPD_IOCont|

; 639  :         {
; 640  :         RETAILMSG(ZONE_ERROR, (L"ERROR: KPD_IOControl: "
; 641  :             L"Incorrect context parameter\r\n"
; 642  :             ));

  00208	e59f3050	 ldr         r3, [pc, #0x50]
  0020c	e5933440	 ldr         r3, [r3, #0x440]
  00210	e3130001	 tst         r3, #1
  00214	159f0040	 ldrne       r0, [pc, #0x40]
  00218	1b000000	 blne        NKDbgPrintfW
  0021c		 |$cleanUp$43932|

; 760  : }

  0021c	e1a00004	 mov         r0, r4
  00220	e24bd01c	 sub         sp, r11, #0x1C
  00224	e89d68f0	 ldmia       sp, {r4 - r7, r11, sp, lr}
  00228	e12fff1e	 bx          lr

			 ENDP  ; |KPD_IOControl|

  0022c		 |$LN37@KPD_IOCont|
  0022c		 |$LN75@KPD_IOCont|

; 665  :                     __except(EXCEPTION_EXECUTE_HANDLER) 

  0022c	e52de004	 str         lr, [sp, #-4]!
  00230		 |$LN40@KPD_IOCont|
  00230		 |$LN81@KPD_IOCont|
  00230	e3a00001	 mov         r0, #1
  00234		 |$LN39@KPD_IOCont|
  00234	e49df004	 ldr         pc, [sp], #4
  00238		 |$LN82@KPD_IOCont|
  00238		 |$LN58@KPD_IOCont|
  00238		 |$LN77@KPD_IOCont|

; 749  :                 __except(EXCEPTION_EXECUTE_HANDLER) 

  00238	e52de004	 str         lr, [sp, #-4]!
  0023c		 |$LN61@KPD_IOCont|
  0023c		 |$LN83@KPD_IOCont|
  0023c	e3a00001	 mov         r0, #1
  00240		 |$LN60@KPD_IOCont|
  00240	e49df004	 ldr         pc, [sp], #4
  00244		 |$LN84@KPD_IOCont|
  00244		 |$LN51@KPD_IOCont|
  00244		 |$LN78@KPD_IOCont|

; 726  :                 __except(EXCEPTION_EXECUTE_HANDLER) 

  00244	e52de004	 str         lr, [sp, #-4]!
  00248		 |$LN54@KPD_IOCont|
  00248		 |$LN85@KPD_IOCont|
  00248	e3a00001	 mov         r0, #1
  0024c		 |$LN53@KPD_IOCont|
  0024c	e49df004	 ldr         pc, [sp], #4
  00250		 |$LN86@KPD_IOCont|
  00250		 |$LN44@KPD_IOCont|
  00250		 |$LN79@KPD_IOCont|

; 692  :                 __except(EXCEPTION_EXECUTE_HANDLER) 

  00250	e52de004	 str         lr, [sp, #-4]!
  00254		 |$LN47@KPD_IOCont|
  00254		 |$LN87@KPD_IOCont|
  00254	e3a00001	 mov         r0, #1
  00258		 |$LN46@KPD_IOCont|
  00258	e49df004	 ldr         pc, [sp], #4
  0025c		 |$LN89@KPD_IOCont|
  0025c		 |$LN90@KPD_IOCont|
  0025c	00000000	 DCD         |??_C@_1GI@MFFMFLPL@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAK?$AAP?$AAD?$AA_?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5@|
  00260		 |$LN91@KPD_IOCont|
  00260	00000000	 DCD         |dpCurSettings|
  00264		 |$LN92@KPD_IOCont|
  00264	00000000	 DCD         |??_C@_1CK@MHJHMPML@?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  00268		 |$LN93@KPD_IOCont|
  00268	00000000	 DCD         |??_C@_1CK@OBPLBNBH@?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?5?$AAi?$AAn?$AA?5?$AAi?$AAo?$AAc?$AAt?$AAl?$AA?$AN?$AA?6?$AA?$AA@|
  0026c		 |$LN94@KPD_IOCont|
  0026c	00000000	 DCD         |??_C@_1EA@BHHDBCBL@?$AAK?$AAP?$AAD?$AA?3?$AA?5?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AA?5?$AAI?$AAO?$AAC?$AAT?$AAL?$AA_?$AAP?$AAO?$AAW?$AAE?$AAR?$AA_?$AAG?$AAE?$AAT?$AA?$AN?$AA?6?$AA?$AA@|
  00270		 |$LN95@KPD_IOCont|
  00270	00000000	 DCD         |??_C@_1EE@NKFDJLND@?$AAK?$AAP?$AAD?$AA?3?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAD?$AA?$CF?$AAu?$AA?5?$AA?$AN@|
  00274		 |$LN96@KPD_IOCont|
  00274	0032100c	 DCD         0x32100c
  00278		 |$LN97@KPD_IOCont|
  00278	00321008	 DCD         0x321008
  0027c		 |$LN98@KPD_IOCont|
  0027c	00321004	 DCD         0x321004
  00280		 |$LN99@KPD_IOCont|
  00280	6b706444	 DCD         0x6b706444
  00284		 |$LN88@KPD_IOCont|
  00284		 |$LN80@KPD_IOCont|
	IMPORT	|g_keypadVK|

  00000			 AREA	 |.pdata|, PDATA
|$T44482| DCD	|$LN18@PhysicalSt|
	DCD	0x40002b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PhysicalStateToVirtualState| PROC

; 774  : {

  00000		 |$LN18@PhysicalSt|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M44479|
  00008	e58d2000	 str         r2, [sp]
  0000c	e1a0a001	 mov         r10, r1
  00010	e1a09000	 mov         r9, r0

; 775  :     BOOL keyDown = FALSE;
; 776  :     USHORT state;
; 777  :     ULONG ik, ix, row, column;
; 778  :    
; 779  : 
; 780  :     for (row = 0, ik = 0; row < KEYPAD_ROWS; row++)

  00014	e59fb08c	 ldr         r11, [pc, #0x8C]
  00018	e3a08000	 mov         r8, #0
  0001c	e3a05000	 mov         r5, #0
  00020	e3a0e000	 mov         lr, #0
  00024	e3a03001	 mov         r3, #1
  00028	e3a06001	 mov         r6, #1
  0002c		 |$LL9@PhysicalSt|

; 781  :         {
; 782  : 
; 783  :         // Get matrix state        
; 784  :         ix = row;
; 785  :         state = matrix[ix] & 0xFF;

  0002c	e7d57009	 ldrb        r7, [r5, +r9]

; 786  : 
; 787  :         // If no-key is pressed continue with new rows
; 788  :         if (state == 0) 

  00030	e3570000	 cmp         r7, #0

; 789  :             {
; 790  :             ik += KEYPAD_COLUMNS;

  00034	028ee008	 addeq       lr, lr, #8
  00038	0a00000f	 beq         |$LN8@PhysicalSt|

; 791  :             continue;
; 792  :             }
; 793  :         
; 794  :         for (column = 0; column < KEYPAD_COLUMNS; column++, ik++)

  0003c	e3a04000	 mov         r4, #0
  00040		 |$LL5@PhysicalSt|

; 795  :             {
; 796  :             if ((state & (1 << column)) != 0)

  00040	e1170413	 tst         r7, r3, lsl r4
  00044	0a000008	 beq         |$LN4@PhysicalSt|

; 797  :                 {
; 798  :                 // g_keypadVK is defined by the platform
; 799  :                 UINT8 vk = g_keypadVK[ik];

  00048	e7de100b	 ldrb        r1, [lr, +r11]

; 800  :                 vkNewState[vk >> 5] |= 1 << (vk & 0x1F);

  0004c	e1a0000a	 mov         r0, r10

; 801  :                 keyDown = TRUE;

  00050	e3a08001	 mov         r8, #1
  00054	e1a032a1	 mov         r3, r1, lsr #5
  00058	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  0005c	e201301f	 and         r3, r1, #0x1F
  00060	e1823316	 orr         r3, r2, r6, lsl r3
  00064	e5803000	 str         r3, [r0]
  00068	e3a03001	 mov         r3, #1
  0006c		 |$LN4@PhysicalSt|
  0006c	e2844001	 add         r4, r4, #1
  00070	e3540008	 cmp         r4, #8
  00074	e28ee001	 add         lr, lr, #1
  00078	3afffff0	 bcc         |$LL5@PhysicalSt|
  0007c		 |$LN8@PhysicalSt|

; 775  :     BOOL keyDown = FALSE;
; 776  :     USHORT state;
; 777  :     ULONG ik, ix, row, column;
; 778  :    
; 779  : 
; 780  :     for (row = 0, ik = 0; row < KEYPAD_ROWS; row++)

  0007c	e2855001	 add         r5, r5, #1
  00080	e3550008	 cmp         r5, #8
  00084	3affffe8	 bcc         |$LL9@PhysicalSt|

; 802  :                 }
; 803  :             }
; 804  :         }
; 805  : 
; 806  :     if (keyDown && (pKeyDown != NULL)) *pKeyDown = TRUE;

  00088	e59d6000	 ldr         r6, [sp]
  0008c	e3580000	 cmp         r8, #0
  00090	13560000	 cmpne       r6, #0
  00094	13a03001	 movne       r3, #1
  00098	15863000	 strne       r3, [r6]

; 807  : }

  0009c	e28dd004	 add         sp, sp, #4
  000a0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  000a4	e12fff1e	 bx          lr
  000a8		 |$LN19@PhysicalSt|
  000a8		 |$LN20@PhysicalSt|
  000a8	00000000	 DCD         |g_keypadVK|
  000ac		 |$M44480|

			 ENDP  ; |PhysicalStateToVirtualState|

	IMPORT	|g_keypadRemap|

  00000			 AREA	 |.pdata|, PDATA
|$T44529| DCD	|$LN54@VirtualKey|
	DCD	0x4000b602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |VirtualKeyRemap| PROC

; 823  : {

  00000		 |$LN54@VirtualKey|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd010	 sub         sp, sp, #0x10
  00008		 |$M44526|
  00008	e1a04002	 mov         r4, r2
  0000c	e1a02000	 mov         r2, r0
  00010	e1a09001	 mov         r9, r1
  00014	e58d2000	 str         r2, [sp]
  00018	e1a0a003	 mov         r10, r3
  0001c	e58d900c	 str         r9, [sp, #0xC]

; 824  :     BOOL keyDown = FALSE;
; 825  :     int ix;
; 826  :     
; 827  :     for (ix = 0; ix < g_keypadRemap.count; ix++)

  00020	e59f72ac	 ldr         r7, [pc, #0x2AC]
  00024	e3a0b000	 mov         r11, #0
  00028	e3a08000	 mov         r8, #0
  0002c	e1d7e0b0	 ldrh        lr, [r7]
  00030	e58db004	 str         r11, [sp, #4]
  00034	e35e0000	 cmp         lr, #0
  00038	0a0000a2	 beq         |$LN1@VirtualKey|
  0003c	e3a01001	 mov         r1, #1
  00040		 |$LL32@VirtualKey|
  00040	e5973004	 ldr         r3, [r7, #4]

; 828  :         {
; 829  :         const KEYPAD_REMAP_ITEM *pItem = &g_keypadRemap.pItem[ix];
; 830  :         KeypadRemapState_t *pState = &pRemapState[ix];
; 831  :         DWORD state = 0;

  00044	e3a09000	 mov         r9, #0

; 832  :         USHORT down = 0;

  00048	e3a05000	 mov         r5, #0
  0004c	e083618b	 add         r6, r3, r11, lsl #3

; 833  :         UINT8 vk = 0;
; 834  : 
; 835  :         // Count number of keys down & save down/up state
; 836  :         int ik;
; 837  :         for (ik = 0; ik < pItem->keys; ik++)

  00050	e5d60001	 ldrb        r0, [r6, #1]
  00054	e58d6008	 str         r6, [sp, #8]
  00058	e3a0e000	 mov         lr, #0
  0005c	e3500000	 cmp         r0, #0
  00060	da000013	 ble         |$LN27@VirtualKey|
  00064	e5967004	 ldr         r7, [r6, #4]
  00068	e3a06001	 mov         r6, #1
  0006c	e3a0b001	 mov         r11, #1
  00070		 |$LL29@VirtualKey|

; 838  :             {
; 839  :             vk = pItem->pVKeys[ik];

  00070	e7d7100e	 ldrb        r1, [r7, +lr]

; 840  :             if ((vkNewState[vk >> 5] & (1 << (vk & 0x1F))) != 0)

  00074	e1a032a1	 mov         r3, r1, lsr #5
  00078	e79a2103	 ldr         r2, [r10, +r3, lsl #2]
  0007c	e201301f	 and         r3, r1, #0x1F
  00080	e112031b	 tst         r2, r11, lsl r3

; 841  :                 {
; 842  :                 state |= 1 << ik;
; 843  :                 down++;

  00084	12853001	 addne       r3, r5, #1
  00088	11a05803	 movne       r5, r3, lsl #16
  0008c	11899e16	 orrne       r9, r9, r6, lsl lr
  00090	e28ee001	 add         lr, lr, #1
  00094	11a05825	 movne       r5, r5, lsr #16
  00098	e15e0000	 cmp         lr, r0
  0009c	bafffff3	 blt         |$LL29@VirtualKey|
  000a0	e59d6008	 ldr         r6, [sp, #8]

; 926  :             }
; 927  :         // Save key state
; 928  :         pState->state = state;

  000a4	e59db004	 ldr         r11, [sp, #4]
  000a8	e59f7224	 ldr         r7, [pc, #0x224]
  000ac	e59d2000	 ldr         r2, [sp]
  000b0	e3a01001	 mov         r1, #1
  000b4		 |$LN27@VirtualKey|

; 844  :                 }
; 845  :             }
; 846  : 
; 847  :         // Depending on number of keys down
; 848  :         if (down >= pItem->keys && pItem->keys > 1)

  000b4	e1550000	 cmp         r5, r0
  000b8	3a00001f	 bcc         |$LN25@VirtualKey|
  000bc	e3500001	 cmp         r0, #1
  000c0	9a00001d	 bls         |$LN25@VirtualKey|

; 849  :             {
; 850  :             // Clear all mapping keys
; 851  :             for (ik = 0; ik < pItem->keys; ik++)

  000c4	e3a0e000	 mov         lr, #0
  000c8	e3500000	 cmp         r0, #0
  000cc	da00000d	 ble         |$LN22@VirtualKey|
  000d0	e3a07001	 mov         r7, #1
  000d4		 |$LL24@VirtualKey|

; 852  :                 {
; 853  :                 vk = pItem->pVKeys[ik];

  000d4	e5963004	 ldr         r3, [r6, #4]

; 854  :                 vkNewState[vk >> 5] &= ~(1 << (vk & 0x1F));

  000d8	e1a0000a	 mov         r0, r10
  000dc	e7d3100e	 ldrb        r1, [r3, +lr]
  000e0	e28ee001	 add         lr, lr, #1
  000e4	e1a032a1	 mov         r3, r1, lsr #5
  000e8	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  000ec	e201301f	 and         r3, r1, #0x1F
  000f0	e1c23317	 bic         r3, r2, r7, lsl r3
  000f4	e5803000	 str         r3, [r0]
  000f8	e5d63001	 ldrb        r3, [r6, #1]
  000fc	e15e0003	 cmp         lr, r3
  00100	bafffff3	 blt         |$LL24@VirtualKey|
  00104	e59f71c8	 ldr         r7, [pc, #0x1C8]
  00108		 |$LN22@VirtualKey|

; 855  :                 }
; 856  :             // All keys are down set final key
; 857  :             vk = pItem->vkey;

  00108	e5d61000	 ldrb        r1, [r6]

; 858  :             vkNewState[vk >> 5] |= 1 << (vk & 0x1F);

  0010c	e1a0000a	 mov         r0, r10
  00110	e1a032a1	 mov         r3, r1, lsr #5
  00114	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  00118	e201301f	 and         r3, r1, #0x1F
  0011c	e3a01001	 mov         r1, #1
  00120	e1823311	 orr         r3, r2, r1, lsl r3

; 859  :             DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 860  :                 L"Mapped vkey: 0x%x\r\n", vk
; 861  :                 ));
; 862  :             // Clear remap pending flag
; 863  :             pState->pending = FALSE;
; 864  :             // Set remap processing flag
; 865  :             pState->remapped = TRUE;

  00124	e3a01001	 mov         r1, #1
  00128	e5803000	 str         r3, [r0]
  0012c	e3a03000	 mov         r3, #0
  00130	e5843000	 str         r3, [r4]
  00134	e5841004	 str         r1, [r4, #4]
  00138	ea000056	 b           |$LN49@VirtualKey|
  0013c		 |$LN25@VirtualKey|

; 866  :             }
; 867  :         else if ( down > 0 )

  0013c	e3550000	 cmp         r5, #0
  00140	0a000034	 beq         |$LN20@VirtualKey|

; 868  :             {
; 869  :             // If already remapping or remapping is not pending
; 870  :             // or pending time expired
; 871  :             if  ( !pState->remapped &&  
; 872  :                  (!pState->pending || (INT32)( time - pState->time ) < 0 ) )

  00144	e5943004	 ldr         r3, [r4, #4]
  00148	e3530000	 cmp         r3, #0
  0014c	1a000007	 bne         |$LN11@VirtualKey|
  00150	e5943000	 ldr         r3, [r4]
  00154	e3530000	 cmp         r3, #0
  00158	0a000017	 beq         |$LN47@VirtualKey|
  0015c	e5943008	 ldr         r3, [r4, #8]
  00160	e0523003	 subs        r3, r2, r3
  00164	4a000018	 bmi         |$LN17@VirtualKey|

; 888  :                      (pItem->keys == 1 && (INT32)( time - pState->time ) >= 0) )

  00168	e3500001	 cmp         r0, #1
  0016c	1a00004a	 bne         |$LN7@VirtualKey|
  00170		 |$LN11@VirtualKey|

; 889  :                 {
; 890  :                 // This is press and hold key
; 891  :                 DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 892  :                     L"Mapped press and hold vkey: 0x%x\r\n", vk
; 893  :                     ));
; 894  :                     
; 895  :                 // Clear all mapping keys
; 896  :                 for (ik = 0; ik < pItem->keys; ik++)

  00170	e3a0e000	 mov         lr, #0
  00174	e3500000	 cmp         r0, #0
  00178	da00000d	 ble         |$LN8@VirtualKey|
  0017c	e3a07001	 mov         r7, #1
  00180		 |$LL10@VirtualKey|

; 897  :                     {
; 898  :                     vk = pItem->pVKeys[ik];

  00180	e5963004	 ldr         r3, [r6, #4]

; 899  :                     vkNewState[vk >> 5] &= ~( 1 << ( vk & 0x1F ) );

  00184	e1a0000a	 mov         r0, r10
  00188	e7d3100e	 ldrb        r1, [r3, +lr]
  0018c	e28ee001	 add         lr, lr, #1
  00190	e1a032a1	 mov         r3, r1, lsr #5
  00194	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  00198	e201301f	 and         r3, r1, #0x1F
  0019c	e1c23317	 bic         r3, r2, r7, lsl r3
  001a0	e5803000	 str         r3, [r0]
  001a4	e5d63001	 ldrb        r3, [r6, #1]
  001a8	e15e0003	 cmp         lr, r3
  001ac	bafffff3	 blt         |$LL10@VirtualKey|
  001b0	e59f711c	 ldr         r7, [pc, #0x11C]
  001b4		 |$LN8@VirtualKey|

; 900  :                     }
; 901  :                     
; 902  :                 vk = pItem->vkey;
; 903  :                 vkNewState[vk >> 5] |= 1 << (vk & 0x1F);
; 904  :                 keyDown = TRUE;

  001b4	e3a08001	 mov         r8, #1

; 905  :                 pState->pending = FALSE;
; 906  :                 pState->remapped = TRUE;
; 907  :                 }
; 908  :             }
; 909  :         else

  001b8	eaffffd2	 b           |$LN22@VirtualKey|
  001bc		 |$LN47@VirtualKey|

; 873  :                 {                
; 874  :                 // If we are not pending and not already remapping, start
; 875  :                 if (!pState->pending && !pState->remapped)
; 876  :                     {
; 877  :                     pState->pending = TRUE;

  001bc	e5841000	 str         r1, [r4]

; 878  :                     pState->time = time + pItem->delay;

  001c0	e1d630b2	 ldrh        r3, [r6, #2]
  001c4	e0833002	 add         r3, r3, r2
  001c8	e5843008	 str         r3, [r4, #8]
  001cc		 |$LN17@VirtualKey|

; 879  :                     }
; 880  :                 // Clear all mapping keys
; 881  :                 for (ik = 0; ik < pItem->keys; ik++)

  001cc	e5d63001	 ldrb        r3, [r6, #1]
  001d0	e3a0e000	 mov         lr, #0
  001d4	e3530000	 cmp         r3, #0
  001d8	0a00002f	 beq         |$LN7@VirtualKey|
  001dc	e3a07001	 mov         r7, #1
  001e0		 |$LL16@VirtualKey|

; 882  :                     {
; 883  :                     vk = pItem->pVKeys[ik];

  001e0	e5963004	 ldr         r3, [r6, #4]

; 884  :                     vkNewState[vk >> 5] &= ~( 1 << ( vk & 0x1F ) );

  001e4	e1a0000a	 mov         r0, r10
  001e8	e7d3100e	 ldrb        r1, [r3, +lr]
  001ec	e28ee001	 add         lr, lr, #1
  001f0	e1a032a1	 mov         r3, r1, lsr #5
  001f4	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  001f8	e201301f	 and         r3, r1, #0x1F
  001fc	e1c23317	 bic         r3, r2, r7, lsl r3
  00200	e5803000	 str         r3, [r0]
  00204	e5d63001	 ldrb        r3, [r6, #1]
  00208	e15e0003	 cmp         lr, r3
  0020c	bafffff3	 blt         |$LL16@VirtualKey|

; 885  :                     }
; 886  :                 }
; 887  :             else if ( pState->remapped || 

  00210	e59f70bc	 ldr         r7, [pc, #0xBC]
  00214	ea00001e	 b           |$LN50@VirtualKey|
  00218		 |$LN20@VirtualKey|

; 910  :             {            
; 911  :             // All keys are up, if remapping was pending set keys
; 912  :             if ( pState->pending )

  00218	e5943000	 ldr         r3, [r4]
  0021c	e3530000	 cmp         r3, #0
  00220	0a000019	 beq         |$LN48@VirtualKey|

; 913  :                 {            
; 914  :                 for (ik = 0; ik < pItem->keys; ik++)

  00224	e3a0e000	 mov         lr, #0
  00228	e3500000	 cmp         r0, #0
  0022c	da000013	 ble         |$LN3@VirtualKey|
  00230	e3a02001	 mov         r2, #1
  00234	e3a07001	 mov         r7, #1
  00238		 |$LL5@VirtualKey|

; 915  :                     {
; 916  :                     if ( ( pState->state & ( 1 << ik ) ) != 0 )

  00238	e594300c	 ldr         r3, [r4, #0xC]
  0023c	e1130e12	 tst         r3, r2, lsl lr
  00240	0a000009	 beq         |$LN4@VirtualKey|

; 917  :                         {                        
; 918  :                         vk = pItem->pVKeys[ik];

  00244	e5963004	 ldr         r3, [r6, #4]

; 919  :                         vkNewState[vk >> 5] |= 1 << (vk & 0x1F);

  00248	e1a0000a	 mov         r0, r10

; 920  :                         keyDown = TRUE;

  0024c	e3a08001	 mov         r8, #1
  00250	e7d3100e	 ldrb        r1, [r3, +lr]
  00254	e1a032a1	 mov         r3, r1, lsr #5
  00258	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  0025c	e201301f	 and         r3, r1, #0x1F
  00260	e1823317	 orr         r3, r2, r7, lsl r3
  00264	e3a02001	 mov         r2, #1
  00268	e5803000	 str         r3, [r0]
  0026c		 |$LN4@VirtualKey|
  0026c	e5d63001	 ldrb        r3, [r6, #1]
  00270	e28ee001	 add         lr, lr, #1
  00274	e15e0003	 cmp         lr, r3
  00278	baffffee	 blt         |$LL5@VirtualKey|
  0027c	e59f7050	 ldr         r7, [pc, #0x50]
  00280		 |$LN3@VirtualKey|

; 921  :                         }
; 922  :                     }
; 923  :                 pState->pending = FALSE;

  00280	e3a03000	 mov         r3, #0
  00284	e5843000	 str         r3, [r4]
  00288	ea000000	 b           |$LN6@VirtualKey|
  0028c		 |$LN48@VirtualKey|

; 905  :                 pState->pending = FALSE;
; 906  :                 pState->remapped = TRUE;
; 907  :                 }
; 908  :             }
; 909  :         else

  0028c	e3a03000	 mov         r3, #0
  00290		 |$LN6@VirtualKey|

; 924  :                 }
; 925  :             pState->remapped = FALSE;

  00290	e5843004	 str         r3, [r4, #4]
  00294		 |$LN50@VirtualKey|
  00294	e3a01001	 mov         r1, #1
  00298		 |$LN49@VirtualKey|

; 823  : {

  00298	e59d2000	 ldr         r2, [sp]
  0029c		 |$LN7@VirtualKey|

; 926  :             }
; 927  :         // Save key state
; 928  :         pState->state = state;

  0029c	e584900c	 str         r9, [r4, #0xC]
  002a0	e1d730b0	 ldrh        r3, [r7]
  002a4	e28bb001	 add         r11, r11, #1
  002a8	e58db004	 str         r11, [sp, #4]
  002ac	e15b0003	 cmp         r11, r3
  002b0	e2844010	 add         r4, r4, #0x10
  002b4	baffff61	 blt         |$LL32@VirtualKey|

; 929  :         }
; 930  : 
; 931  :     // Set output variable
; 932  :     if (keyDown && (pKeyDown != NULL)) *pKeyDown = TRUE;

  002b8	e59d900c	 ldr         r9, [sp, #0xC]
  002bc	e3580000	 cmp         r8, #0
  002c0	13590000	 cmpne       r9, #0
  002c4	15891000	 strne       r1, [r9]
  002c8		 |$LN1@VirtualKey|

; 933  : }

  002c8	e28dd010	 add         sp, sp, #0x10
  002cc	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  002d0	e12fff1e	 bx          lr
  002d4		 |$LN55@VirtualKey|
  002d4		 |$LN56@VirtualKey|
  002d4	00000000	 DCD         |g_keypadRemap|
  002d8		 |$M44527|

			 ENDP  ; |VirtualKeyRemap|

	EXPORT	|__$ArrayPad$| [ DATA ]
	IMPORT	|ChangeDisplaySettingsEx|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T44550| DCD	|$LN23@RemapVKeyT|
	DCD	0xc0004a02

  00000			 AREA	 |.xdata|, DATA
|$T44546| DCD	0xffffffec
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44546|

  00008		 |RemapVKeyToScreenOrientation| PROC

; 946  : {

  00008		 |$LN23@RemapVKeyT|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd0c8	 sub         sp, sp, #0xC8
  00010		 |$M44547|
  00010	e1a04000	 mov         r4, r0
  00014	e59f3110	 ldr         r3, [pc, #0x110]
  00018	e5933000	 ldr         r3, [r3]
  0001c	e58d30c4	 str         r3, [sp, #0xC4]

; 947  :     // Arrow key translation for rotate 0, 90, 180 and 270. 
; 948  :     static const UCHAR   ucOrientationDMDO_0VKTable[4]   = {VK_TUP,    VK_TRIGHT, VK_TDOWN,  VK_TLEFT };
; 949  :     static const UCHAR   ucOrientationDMDO_90VKTable[4]  = {VK_TRIGHT, VK_TDOWN,  VK_TLEFT,  VK_TUP   };
; 950  :     static const UCHAR   ucOrientationDMDO_180VKTable[4] = {VK_TDOWN,  VK_TLEFT,  VK_TUP,    VK_TRIGHT};
; 951  :     static const UCHAR   ucOrientationDMDO_270VKTable[4] = {VK_LEFT,   VK_TUP,    VK_TRIGHT, VK_TDOWN };
; 952  : 
; 953  :     UCHAR   ucRetVal = ucVKey;
; 954  : 
; 955  :     // if the input key is VK_TUP, VK_TRIGHT, VK_TDOWN, or VK_TLEFT, we might need to translate it
; 956  :     // according to the screen rotation.
; 957  :     if ( (ucVKey == VK_TUP) || (ucVKey == VK_TRIGHT) || (ucVKey == VK_TDOWN) || (ucVKey == VK_TLEFT) )

  00020	e3540026	 cmp         r4, #0x26
  00024	0a000005	 beq         |$LN15@RemapVKeyT|
  00028	e3540027	 cmp         r4, #0x27
  0002c	0a000003	 beq         |$LN15@RemapVKeyT|
  00030	e3540028	 cmp         r4, #0x28
  00034	0a000001	 beq         |$LN15@RemapVKeyT|
  00038	e3540025	 cmp         r4, #0x25
  0003c	1a000032	 bne         |$LN5@RemapVKeyT|
  00040		 |$LN15@RemapVKeyT|

; 958  :     {
; 959  :         int     iVKeyIndex = 0;
; 960  : 
; 961  :         // If we haven't determine the screen orientation, we need to figure it out first.
; 962  :         if (g_iDisplayOrientation == -1) 

  00040	e59f60e0	 ldr         r6, [pc, #0xE0]
  00044	e3a05000	 mov         r5, #0
  00048	e5963000	 ldr         r3, [r6]
  0004c	e3730001	 cmn         r3, #1
  00050	1a000010	 bne         |$LN13@RemapVKeyT|

; 963  :         {
; 964  :             DEVMODE devMode;
; 965  :             
; 966  :             //  Get current screen orientation
; 967  :             devMode.dmSize = sizeof(devMode);

  00054	e3a030c0	 mov         r3, #0xC0

; 968  :             devMode.dmFields = DM_DISPLAYORIENTATION;

  00058	e3a02502	 mov         r2, #2, 10

; 969  :             devMode.dmDisplayOrientation = DMDO_0;

  0005c	e3a01000	 mov         r1, #0

; 970  :             if (ChangeDisplaySettingsEx(NULL, &devMode, NULL, CDS_TEST, NULL) == DISP_CHANGE_SUCCESSFUL)

  00060	e3a00000	 mov         r0, #0
  00064	e1cd34b8	 strh        r3, [sp, #0x48]
  00068	e58d204c	 str         r2, [sp, #0x4C]
  0006c	e58d10c0	 str         r1, [sp, #0xC0]
  00070	e58d0000	 str         r0, [sp]
  00074	e3a03002	 mov         r3, #2
  00078	e3a02000	 mov         r2, #0
  0007c	e28d1004	 add         r1, sp, #4
  00080	e3a00000	 mov         r0, #0
  00084	eb000000	 bl          ChangeDisplaySettingsEx
  00088	e3500000	 cmp         r0, #0

; 971  :             {
; 972  :                 g_iDisplayOrientation = devMode.dmDisplayOrientation;

  0008c	059d30c0	 ldreq       r3, [sp, #0xC0]
  00090	05863000	 streq       r3, [r6]
  00094	15963000	 ldrne       r3, [r6]
  00098		 |$LN13@RemapVKeyT|

; 973  :             }
; 974  :         }
; 975  : 
; 976  :         // translate VK_XXX to index.
; 977  :         switch (ucVKey)

  00098	e3540025	 cmp         r4, #0x25
  0009c	0a00000b	 beq         |$LN7@RemapVKeyT|
  000a0	e3540026	 cmp         r4, #0x26
  000a4	0a000007	 beq         |$LN10@RemapVKeyT|
  000a8	e3540027	 cmp         r4, #0x27
  000ac	0a000003	 beq         |$LN9@RemapVKeyT|
  000b0	e3540028	 cmp         r4, #0x28
  000b4	1a000006	 bne         |$LN11@RemapVKeyT|

; 985  :             case VK_TDOWN:
; 986  :                 iVKeyIndex = 2;

  000b8	e3a05002	 mov         r5, #2

; 987  :                 break;

  000bc	ea000004	 b           |$LN11@RemapVKeyT|
  000c0		 |$LN9@RemapVKeyT|

; 982  :             case VK_TRIGHT:
; 983  :                 iVKeyIndex = 1;

  000c0	e3a05001	 mov         r5, #1

; 984  :                 break;

  000c4	ea000002	 b           |$LN11@RemapVKeyT|
  000c8		 |$LN10@RemapVKeyT|

; 978  :         {
; 979  :             case VK_TUP:
; 980  :                 iVKeyIndex = 0;

  000c8	e3a05000	 mov         r5, #0

; 981  :                 break;

  000cc	ea000000	 b           |$LN11@RemapVKeyT|
  000d0		 |$LN7@RemapVKeyT|

; 988  :             case VK_TLEFT:
; 989  :                 iVKeyIndex = 3;

  000d0	e3a05003	 mov         r5, #3
  000d4		 |$LN11@RemapVKeyT|

; 990  :                 break;
; 991  :         }
; 992  : 
; 993  :         // Transalte VK_XXX according to the screen rotation. No translation is needed
; 994  :         // if the screen is in DMD0 mode or we can't determine the screen orientation. 
; 995  :         switch (g_iDisplayOrientation)

  000d4	e3530001	 cmp         r3, #1
  000d8	0a000009	 beq         |$LN4@RemapVKeyT|
  000dc	e3530002	 cmp         r3, #2
  000e0	0a000004	 beq         |$LN3@RemapVKeyT|
  000e4	e3530004	 cmp         r3, #4
  000e8	1a000007	 bne         |$LN5@RemapVKeyT|

; 1003 :             case DMDO_270:
; 1004 :                 ucRetVal = ucOrientationDMDO_270VKTable[iVKeyIndex];

  000ec	e59f3030	 ldr         r3, [pc, #0x30]
  000f0	e2833008	 add         r3, r3, #8

; 1005 :                 break;

  000f4	ea000003	 b           |$LN20@RemapVKeyT|
  000f8		 |$LN3@RemapVKeyT|

; 999  :                 break;
; 1000 :             case DMDO_180:
; 1001 :                 ucRetVal = ucOrientationDMDO_180VKTable[iVKeyIndex];

  000f8	e59f3024	 ldr         r3, [pc, #0x24]
  000fc	e2833004	 add         r3, r3, #4

; 1002 :                 break;

  00100	ea000000	 b           |$LN20@RemapVKeyT|
  00104		 |$LN4@RemapVKeyT|

; 996  :         {
; 997  :             case DMDO_90:
; 998  :                 ucRetVal = ucOrientationDMDO_90VKTable[iVKeyIndex];

  00104	e59f3018	 ldr         r3, [pc, #0x18]
  00108		 |$LN20@RemapVKeyT|
  00108	e7d54003	 ldrb        r4, [r5, +r3]
  0010c		 |$LN5@RemapVKeyT|

; 1006 :            case DMDO_0:
; 1007 :            default:
; 1008 :                 break;
; 1009 :         }
; 1010 :     }
; 1011 : 
; 1012 :     return ucRetVal;

  0010c	e59d00c4	 ldr         r0, [sp, #0xC4]
  00110	eb000000	 bl          __security_check_cookie

; 1013 : }

  00114	e1a00004	 mov         r0, r4
  00118	e28dd0c8	 add         sp, sp, #0xC8
  0011c	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00120	e12fff1e	 bx          lr
  00124		 |$LN24@RemapVKeyT|
  00124		 |$LN25@RemapVKeyT|
  00124	00000000	 DCD         |?ucOrientationDMDO_90VKTable@?1??RemapVKeyToScreenOrientation@@9@9|
  00128		 |$LN26@RemapVKeyT|
  00128	00000000	 DCD         |g_iDisplayOrientation|
  0012c		 |$LN27@RemapVKeyT|
  0012c	00000000	 DCD         |__security_cookie|
  00130		 |$M44548|

			 ENDP  ; |RemapVKeyToScreenOrientation|

	EXPORT	|KPD_LightThread|
	IMPORT	|NLedSetDevice|
	IMPORT	|CeSetThreadPriority|

  00000			 AREA	 |.pdata|, PDATA
|$T44574| DCD	|$LN16@KPD_LightT|
	DCD	0x40003902
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_LightThread| PROC

; 1229 : {

  00000		 |$LN16@KPD_LightT|
  00000	e92d43f0	 stmdb       sp!, {r4 - r9, lr}
  00004	e24dd01c	 sub         sp, sp, #0x1C
  00008		 |$M44571|
  00008	e1a05000	 mov         r5, r0

; 1230 :     DWORD               rc;
; 1231 :     struct NLED_SETTINGS_INFO  nledInfo;
; 1232 :     KeypadDevice_t     *pDevice = (KeypadDevice_t*)pContext;
; 1233 :     DWORD               keypadLightTimeout = pDevice->KpLightTimeout_ms;
; 1234 :     
; 1235 :     if( !pDevice ) 
; 1236 :         {
; 1237 :         DEBUGMSG(ZONE_ERROR, (L" KPD_LightThread: "
; 1238 :             L"Invalid context passed to thread routine.\r\n"
; 1239 :             ));
; 1240 :         ASSERT( FALSE );
; 1241 :         goto cleanUp;
; 1242 :         }
; 1243 : 
; 1244 :     // Set Thread Priority
; 1245 :     CeSetThreadPriority(pDevice->hLightThread, pDevice->priority256 + 1);

  0000c	e5953004	 ldr         r3, [r5, #4]
  00010	e5950038	 ldr         r0, [r5, #0x38]
  00014	e5954048	 ldr         r4, [r5, #0x48]
  00018	e2831001	 add         r1, r3, #1
  0001c	eb000000	 bl          CeSetThreadPriority

; 1246 : 
; 1247 :     // initialize nled info
; 1248 :     
; 1249 :     // Setting NLED control parameters
; 1250 :     memset(&nledInfo, 0, sizeof(struct NLED_SETTINGS_INFO));

  00020	e3a0201c	 mov         r2, #0x1C
  00024	e3a01000	 mov         r1, #0
  00028	e28d0000	 add         r0, sp, #0
  0002c	eb000000	 bl          memset

; 1251 :     nledInfo.LedNum = pDevice->KpLedNum;

  00030	e5953044	 ldr         r3, [r5, #0x44]

; 1252 :     nledInfo.TotalCycleTime = 0;

  00034	e3a02000	 mov         r2, #0

; 1253 :     nledInfo.OnTime = 0;

  00038	e3a0e000	 mov         lr, #0

; 1254 :     nledInfo.OffTime = 0;

  0003c	e3a06000	 mov         r6, #0

; 1255 :     nledInfo.MetaCycleOn = 1;

  00040	e3a07001	 mov         r7, #1

; 1256 :     nledInfo.MetaCycleOff = 0;

  00044	e3a08000	 mov         r8, #0

; 1257 :     nledInfo.OffOnBlink = 1;

  00048	e3a09001	 mov         r9, #1

; 1258 :     NLedSetDevice(NLED_SETTINGS_INFO_ID, (void*)&nledInfo);

  0004c	e28d1000	 add         r1, sp, #0
  00050	e3a00002	 mov         r0, #2
  00054	e58d3000	 str         r3, [sp]
  00058	e58d2008	 str         r2, [sp, #8]
  0005c	e58de00c	 str         lr, [sp, #0xC]
  00060	e58d6010	 str         r6, [sp, #0x10]
  00064	e58d7014	 str         r7, [sp, #0x14]
  00068	e58d8018	 str         r8, [sp, #0x18]
  0006c	e58d9004	 str         r9, [sp, #4]
  00070	eb000000	 bl          NLedSetDevice

; 1259 :     
; 1260 :     // Loop until we are not stopped
; 1261 :     for(;;)
; 1262 :         {
; 1263 :         rc = WaitForSingleObject(pDevice->hKeypressEvent, keypadLightTimeout);

  00074	e595003c	 ldr         r0, [r5, #0x3C]
  00078	e1a01004	 mov         r1, r4
  0007c	eb000000	 bl          WaitForSingleObject

; 1264 : 
; 1265 :         // check for thread termination
; 1266 :         if (pDevice->intrThreadExit) break;

  00080	e5953028	 ldr         r3, [r5, #0x28]
  00084	e3530000	 cmp         r3, #0
  00088	1a000011	 bne         |$cleanUp$44182|
  0008c	e3a03c01	 mov         r3, #1, 24
  00090	e3836002	 orr         r6, r3, #2
  00094	e3a07000	 mov         r7, #0
  00098	e3a08001	 mov         r8, #1
  0009c		 |$LL4@KPD_LightT|

; 1267 : 
; 1268 :         // check for thread termination
; 1269 :         if (WAIT_TIMEOUT == rc)

  0009c	e1500006	 cmp         r0, r6

; 1270 :             {
; 1271 :             keypadLightTimeout = INFINITE;
; 1272 :             nledInfo.OffOnBlink = 0;
; 1273 :             NLedSetDevice(NLED_SETTINGS_INFO_ID, (void*)&nledInfo);

  000a0	03e04000	 mvneq       r4, #0

; 1274 :             continue;
; 1275 :             }
; 1276 : 
; 1277 :         keypadLightTimeout = pDevice->KpLightTimeout_ms;
; 1278 :         nledInfo.OffOnBlink = 1;
; 1279 :         NLedSetDevice(NLED_SETTINGS_INFO_ID, (void*)&nledInfo);

  000a4	15954048	 ldrne       r4, [r5, #0x48]
  000a8	058d7004	 streq       r7, [sp, #4]
  000ac	e28d1000	 add         r1, sp, #0
  000b0	e3a00002	 mov         r0, #2
  000b4	158d8004	 strne       r8, [sp, #4]
  000b8	eb000000	 bl          NLedSetDevice
  000bc	e595003c	 ldr         r0, [r5, #0x3C]
  000c0	e1a01004	 mov         r1, r4
  000c4	eb000000	 bl          WaitForSingleObject
  000c8	e5953028	 ldr         r3, [r5, #0x28]
  000cc	e3530000	 cmp         r3, #0
  000d0	0afffff1	 beq         |$LL4@KPD_LightT|
  000d4		 |$cleanUp$44182|

; 1280 :         }
; 1281 : 
; 1282 : cleanUp:
; 1283 :     return ERROR_SUCCESS;

  000d4	e3a00000	 mov         r0, #0

; 1284 : }

  000d8	e28dd01c	 add         sp, sp, #0x1C
  000dc	e8bd43f0	 ldmia       sp!, {r4 - r9, lr}
  000e0	e12fff1e	 bx          lr
  000e4		 |$M44572|

			 ENDP  ; |KPD_LightThread|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
	IMPORT	|RegisterDbgZones|

  00000			 AREA	 |.pdata|, PDATA
|$T44585| DCD	|$LN8@DllMain|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 1299 : {

  00000		 |$LN8@DllMain|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M44582|
  00004	e1a04000	 mov         r4, r0

; 1300 :     UNREFERENCED_PARAMETER(pReserved);
; 1301 :     switch (reason)

  00008	e3510001	 cmp         r1, #1
  0000c	1a000003	 bne         |$LN2@DllMain|

; 1302 :         {
; 1303 :         case DLL_PROCESS_ATTACH:
; 1304 :             RETAILREGISTERZONES((HMODULE)hDLL);

  00010	e59f1014	 ldr         r1, [pc, #0x14]
  00014	eb000000	 bl          RegisterDbgZones

; 1305 :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          DisableThreadLibraryCalls
  00020		 |$LN2@DllMain|

; 1306 :             break;
; 1307 :         }
; 1308 :     return TRUE;

  00020	e3a00001	 mov         r0, #1

; 1309 : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@DllMain|
  0002c		 |$LN10@DllMain|
  0002c	00000000	 DCD         |dpCurSettings|
  00030		 |$M44583|

			 ENDP  ; |DllMain|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|SendKeyPadEvent|
	IMPORT	|keybd_event|
	IMPORT	|g_keypadExtraSeq|

  00000			 AREA	 |.pdata|, PDATA
|$T44635| DCD	|$LN35@SendKeyPad|
	DCD	0xc0007c02

  00000			 AREA	 |.xdata|, DATA
|$T44631| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44631|

  00008		 |SendKeyPadEvent| PROC

; 142  : {

  00008		 |$LN35@SendKeyPad|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd0c8	 sub         sp, sp, #0xC8
  00010		 |$M44632|
  00010	e1a09003	 mov         r9, r3
  00014	e1a07002	 mov         r7, r2
  00018	e1a0b001	 mov         r11, r1
  0001c	e1a04000	 mov         r4, r0
  00020	e59f01cc	 ldr         r0, [pc, #0x1CC]
  00024	e5900000	 ldr         r0, [r0]
  00028	e58d00c4	 str         r0, [sp, #0xC4]

; 143  :     USHORT index;
; 144  :     UCHAR vk_extra = 0, order;

  0002c	e3a08000	 mov         r8, #0

; 145  :     
; 146  :     order = KEYPAD_EXTRASEQ_ORDER_NONE; // no extra key needed

  00030	e3a0a0ff	 mov         r10, #0xFF

; 147  :     
; 148  :     // Remap for rotation angle
; 149  :     bVk = RemapVKeyToScreenOrientation(bVk);

  00034	e3540026	 cmp         r4, #0x26
  00038	0a000005	 beq         |$LN25@SendKeyPad|
  0003c	e3540027	 cmp         r4, #0x27
  00040	0a000003	 beq         |$LN25@SendKeyPad|
  00044	e3540028	 cmp         r4, #0x28
  00048	0a000001	 beq         |$LN25@SendKeyPad|
  0004c	e3540025	 cmp         r4, #0x25
  00050	1a000032	 bne         |$LN11@SendKeyPad|
  00054		 |$LN25@SendKeyPad|
  00054	e59f6194	 ldr         r6, [pc, #0x194]
  00058	e3a05000	 mov         r5, #0
  0005c	e5963000	 ldr         r3, [r6]
  00060	e3730001	 cmn         r3, #1
  00064	1a000010	 bne         |$LN23@SendKeyPad|
  00068	e3a030c0	 mov         r3, #0xC0
  0006c	e3a02502	 mov         r2, #2, 10
  00070	e3a01000	 mov         r1, #0
  00074	e3a00000	 mov         r0, #0
  00078	e1cd34b8	 strh        r3, [sp, #0x48]
  0007c	e58d204c	 str         r2, [sp, #0x4C]
  00080	e58d10c0	 str         r1, [sp, #0xC0]
  00084	e58d0000	 str         r0, [sp]
  00088	e3a03002	 mov         r3, #2
  0008c	e3a02000	 mov         r2, #0
  00090	e28d1004	 add         r1, sp, #4
  00094	e3a00000	 mov         r0, #0
  00098	eb000000	 bl          ChangeDisplaySettingsEx
  0009c	e3500000	 cmp         r0, #0
  000a0	059d30c0	 ldreq       r3, [sp, #0xC0]
  000a4	05863000	 streq       r3, [r6]
  000a8	15963000	 ldrne       r3, [r6]
  000ac		 |$LN23@SendKeyPad|
  000ac	e3540025	 cmp         r4, #0x25
  000b0	0a00000b	 beq         |$LN17@SendKeyPad|
  000b4	e3540026	 cmp         r4, #0x26
  000b8	0a000007	 beq         |$LN20@SendKeyPad|
  000bc	e3540027	 cmp         r4, #0x27
  000c0	0a000003	 beq         |$LN19@SendKeyPad|
  000c4	e3540028	 cmp         r4, #0x28
  000c8	1a000006	 bne         |$LN21@SendKeyPad|
  000cc	e3a05002	 mov         r5, #2
  000d0	ea000004	 b           |$LN21@SendKeyPad|
  000d4		 |$LN19@SendKeyPad|
  000d4	e3a05001	 mov         r5, #1
  000d8	ea000002	 b           |$LN21@SendKeyPad|
  000dc		 |$LN20@SendKeyPad|
  000dc	e3a05000	 mov         r5, #0
  000e0	ea000000	 b           |$LN21@SendKeyPad|
  000e4		 |$LN17@SendKeyPad|
  000e4	e3a05003	 mov         r5, #3
  000e8		 |$LN21@SendKeyPad|
  000e8	e3530001	 cmp         r3, #1
  000ec	0a000009	 beq         |$LN14@SendKeyPad|
  000f0	e3530002	 cmp         r3, #2
  000f4	0a000004	 beq         |$LN13@SendKeyPad|
  000f8	e3530004	 cmp         r3, #4
  000fc	1a000007	 bne         |$LN11@SendKeyPad|
  00100	e59f30e4	 ldr         r3, [pc, #0xE4]
  00104	e2833008	 add         r3, r3, #8
  00108	ea000003	 b           |$LN32@SendKeyPad|
  0010c		 |$LN13@SendKeyPad|
  0010c	e59f30d8	 ldr         r3, [pc, #0xD8]
  00110	e2833004	 add         r3, r3, #4
  00114	ea000000	 b           |$LN32@SendKeyPad|
  00118		 |$LN14@SendKeyPad|
  00118	e59f30cc	 ldr         r3, [pc, #0xCC]
  0011c		 |$LN32@SendKeyPad|
  0011c	e7d54003	 ldrb        r4, [r5, +r3]
  00120		 |$LN11@SendKeyPad|

; 150  :     
; 151  :     // Check extra virtual key sequence table
; 152  :     for (index = 0; index < g_keypadExtraSeq.count; index ++)

  00120	e59f10c0	 ldr         r1, [pc, #0xC0]
  00124	e3a02000	 mov         r2, #0
  00128	e1d130b0	 ldrh        r3, [r1]
  0012c	e1b0e003	 movs        lr, r3
  00130	0a00000c	 beq         |$LN6@SendKeyPad|
  00134	e5910004	 ldr         r0, [r1, #4]
  00138	e3a01000	 mov         r1, #0
  0013c		 |$LL8@SendKeyPad|

; 153  :         {
; 154  :         if (g_keypadExtraSeq.pItem[index].vk_orig == bVk)

  0013c	e0822082	 add         r2, r2, r2, lsl #1
  00140	e7f23000	 ldrb        r3, [r2, +r0]!
  00144	e1530004	 cmp         r3, r4

; 155  :             {
; 156  :             vk_extra = g_keypadExtraSeq.pItem[index].vk_extra;

  00148	05d28001	 ldreqb      r8, [r2, #1]

; 157  :             order = g_keypadExtraSeq.pItem[index].order;

  0014c	05d2a002	 ldreqb      r10, [r2, #2]
  00150	e2813001	 add         r3, r1, #1
  00154	e1a02803	 mov         r2, r3, lsl #16
  00158	e1a02822	 mov         r2, r2, lsr #16
  0015c	e1a01002	 mov         r1, r2
  00160	e152000e	 cmp         r2, lr
  00164	3afffff4	 bcc         |$LL8@SendKeyPad|
  00168		 |$LN6@SendKeyPad|

; 158  :             }
; 159  :         }
; 160  :       
; 161  :     // Check to send extra vk first  
; 162  :     if (order == KEYPAD_EXTRASEQ_ORDER_EXTRAFIRST || 
; 163  :         (order == KEYPAD_EXTRASEQ_ORDER_EXTRAORIG && (dwFlags & KEYEVENTF_KEYUP) == 0) )

  00168	e1b0500a	 movs        r5, r10
  0016c	0a000003	 beq         |$LN3@SendKeyPad|
  00170	e3550001	 cmp         r5, #1
  00174	1a000006	 bne         |$LN4@SendKeyPad|
  00178	e3170002	 tst         r7, #2
  0017c	1a000004	 bne         |$LN4@SendKeyPad|
  00180		 |$LN3@SendKeyPad|

; 164  :         {
; 165  :         keybd_event(
; 166  :             vk_extra,
; 167  :             0,
; 168  :             dwFlags | KEYEVENTF_SILENT,
; 169  :             dwExtraInfo);

  00180	e1a03009	 mov         r3, r9
  00184	e3872004	 orr         r2, r7, #4
  00188	e3a01000	 mov         r1, #0
  0018c	e1a00008	 mov         r0, r8
  00190	eb000000	 bl          keybd_event
  00194		 |$LN4@SendKeyPad|

; 170  :         }
; 171  :           
; 172  :     // Send original vk
; 173  :     keybd_event(
; 174  :         bVk,
; 175  :         bScan,
; 176  :         dwFlags,
; 177  :         dwExtraInfo);

  00194	e1a03009	 mov         r3, r9
  00198	e1a02007	 mov         r2, r7
  0019c	e1a0100b	 mov         r1, r11
  001a0	e1a00004	 mov         r0, r4
  001a4	eb000000	 bl          keybd_event

; 178  :       
; 179  :    // Check to send extra key
; 180  :    if (order == KEYPAD_EXTRASEQ_ORDER_ORIGFIRST || 
; 181  :        (order == KEYPAD_EXTRASEQ_ORDER_EXTRAORIG && (dwFlags & KEYEVENTF_KEYUP)))

  001a8	e3550002	 cmp         r5, #2
  001ac	0a000003	 beq         |$LN1@SendKeyPad|
  001b0	e3550001	 cmp         r5, #1
  001b4	1a000006	 bne         |$LN2@SendKeyPad|
  001b8	e3170002	 tst         r7, #2
  001bc	0a000004	 beq         |$LN2@SendKeyPad|
  001c0		 |$LN1@SendKeyPad|

; 182  :        {
; 183  :        keybd_event(
; 184  :            vk_extra,
; 185  :            0,
; 186  :            dwFlags | KEYEVENTF_SILENT,
; 187  :            dwExtraInfo);

  001c0	e1a03009	 mov         r3, r9
  001c4	e3872004	 orr         r2, r7, #4
  001c8	e3a01000	 mov         r1, #0
  001cc	e1a00008	 mov         r0, r8
  001d0	eb000000	 bl          keybd_event
  001d4		 |$LN2@SendKeyPad|
  001d4	e59d00c4	 ldr         r0, [sp, #0xC4]
  001d8	eb000000	 bl          __security_check_cookie

; 188  :        }
; 189  : }

  001dc	e28dd0c8	 add         sp, sp, #0xC8
  001e0	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  001e4	e12fff1e	 bx          lr
  001e8		 |$LN36@SendKeyPad|
  001e8		 |$LN37@SendKeyPad|
  001e8	00000000	 DCD         |g_keypadExtraSeq|
  001ec		 |$LN38@SendKeyPad|
  001ec	00000000	 DCD         |?ucOrientationDMDO_90VKTable@?1??RemapVKeyToScreenOrientation@@9@9|
  001f0		 |$LN39@SendKeyPad|
  001f0	00000000	 DCD         |g_iDisplayOrientation|
  001f4		 |$LN40@SendKeyPad|
  001f4	00000000	 DCD         |__security_cookie|
  001f8		 |$M44633|

			 ENDP  ; |SendKeyPadEvent|

	EXPORT	|PressedReleasedKeys|
	EXPORT	|??_C@_1DO@HFBDPGNP@?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAs?$AAe?$AAd?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAd?$AAK?$AAe?$AAy?$AAs?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA2?$AAX?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|PowerPolicyNotify|

  00000			 AREA	 |.pdata|, PDATA
|$T44661| DCD	|$LN31@PressedRel|
	DCD	0x40004c01

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DO@HFBDPGNP@?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAs?$AAe?$AAd?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAd?$AAK?$AAe?$AAy?$AAs?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA2?$AAX?$AA?$AN?$AA?6?$AA?$AA@| DCB " "
	DCB	0x0, "P", 0x0, "r", 0x0, "e", 0x0, "s", 0x0, "s", 0x0, "e"
	DCB	0x0, "d", 0x0, "R", 0x0, "e", 0x0, "l", 0x0, "e", 0x0, "a"
	DCB	0x0, "s", 0x0, "e", 0x0, "d", 0x0, "K", 0x0, "e", 0x0, "y"
	DCB	0x0, "s", 0x0, ":", 0x0, " ", 0x0, "0", 0x0, "x", 0x0, "%"
	DCB	0x0, "0", 0x0, "2", 0x0, "X", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PressedReleasedKeys| PROC

; 204  : {

  00000		 |$LN31@PressedRel|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004		 |$M44658|
  00004	e1a05002	 mov         r5, r2
  00008	e1a09000	 mov         r9, r0

; 205  :     UINT8 vk;
; 206  :     int ic;
; 207  : 
; 208  :     for (ic = 0, vk = 0; ic < VK_KEYS/DWORD_BITS; ic++)

  0000c	e59fb118	 ldr         r11, [pc, #0x118]
  00010	e3a04000	 mov         r4, #0
  00014	e041a005	 sub         r10, r1, r5
  00018	e3a07008	 mov         r7, #8
  0001c		 |$LL19@PressedRel|

; 209  :         {
; 210  :         DWORD change = vkState[ic] ^ vkNewState[ic];

  0001c	e79a1005	 ldr         r1, [r10, +r5]
  00020	e5953000	 ldr         r3, [r5]
  00024	e0318003	 eors        r8, r1, r3

; 211  :         if (change == 0)
; 212  :             {
; 213  :             vk += DWORD_BITS;

  00028	02843020	 addeq       r3, r4, #0x20
  0002c	020340ff	 andeq       r4, r3, #0xFF
  00030	0a000037	 beq         |$LN18@PressedRel|

; 214  :             }
; 215  :         else
; 216  :             {
; 217  :             DWORD mask;
; 218  :             for (mask = 1; mask != 0; mask <<= 1, vk++)

  00034	e3a06001	 mov         r6, #1
  00038		 |$LL14@PressedRel|

; 219  :                 {
; 220  :                 // Check for change
; 221  :                 if ((change & mask) != 0)

  00038	e1160008	 tst         r6, r8
  0003c	0a000030	 beq         |$LN13@PressedRel|

; 222  :                     {
; 223  :                     if ((vkNewState[ic] & mask) != 0)

  00040	e5953000	 ldr         r3, [r5]
  00044	e1160003	 tst         r6, r3
  00048	0a000007	 beq         |$LN10@PressedRel|

; 224  :                         {
; 225  :                         DEBUGMSG(PressedReleasedKeys, 
; 226  :                             (L" PressedReleasedKeys: Key Down: 0x%x\r\n", vk
; 227  :                             )); 
; 228  :                         // Send key down event
; 229  :                         if (vk != VK_OFF)

  0004c	e35400df	 cmp         r4, #0xDF
  00050	0a00002b	 beq         |$LN13@PressedRel|

; 230  :                             {
; 231  :                             SendKeyPadEvent(vk, 0, 0, 0);

  00054	e3a03000	 mov         r3, #0
  00058	e3a02000	 mov         r2, #0
  0005c	e3a01000	 mov         r1, #0
  00060	e1a00004	 mov         r0, r4
  00064	eb000000	 bl          SendKeyPadEvent

; 232  :                             }
; 233  :                         }
; 234  :                     else

  00068	ea000025	 b           |$LN13@PressedRel|
  0006c		 |$LN10@PressedRel|

; 235  :                         {
; 236  :                         DEBUGMSG(PressedReleasedKeys, 
; 237  :                             (L" PressedReleasedKeys: Key Up: 0x%x\r\n", vk
; 238  :                             ));
; 239  : 
; 240  :                         // Need to send the keydown as well as keyup for
; 241  :                         // device to suspend under cebase.                          
; 242  :                         if (pDevice->bEnableOffKey == TRUE && vk == VK_OFF)

  0006c	e5993040	 ldr         r3, [r9, #0x40]
  00070	e3530001	 cmp         r3, #1
  00074	035400df	 cmpeq       r4, #0xDF

; 243  :                             {
; 244  :                             SendKeyPadEvent(vk, 0, 0, 0);

  00078	03a03000	 moveq       r3, #0
  0007c	03a02000	 moveq       r2, #0
  00080	03a01000	 moveq       r1, #0
  00084	01a00004	 moveq       r0, r4
  00088	0b000000	 bleq        SendKeyPadEvent

; 245  :                             }
; 246  :                         
; 247  :                         // Send key down event
; 248  :                         if (pDevice->bEnableOffKey != FALSE || vk != VK_OFF)

  0008c	e5993040	 ldr         r3, [r9, #0x40]
  00090	e3530000	 cmp         r3, #0
  00094	1a000001	 bne         |$LN5@PressedRel|
  00098	e35400df	 cmp         r4, #0xDF
  0009c	0a000004	 beq         |$LN6@PressedRel|
  000a0		 |$LN5@PressedRel|

; 249  :                             {
; 250  :                             SendKeyPadEvent(vk, 0, KEYEVENTF_KEYUP, 0);

  000a0	e3a03000	 mov         r3, #0
  000a4	e3a02002	 mov         r2, #2
  000a8	e3a01000	 mov         r1, #0
  000ac	e1a00004	 mov         r0, r4
  000b0	eb000000	 bl          SendKeyPadEvent
  000b4		 |$LN6@PressedRel|

; 251  :                             }
; 252  :                         
; 253  :                         // send PowerPolicyNotify notification
; 254  :                         switch (vk)

  000b4	e354005d	 cmp         r4, #0x5D
  000b8	0a00000e	 beq         |$LN1@PressedRel|
  000bc	e3540081	 cmp         r4, #0x81
  000c0	0a000005	 beq         |$LN2@PressedRel|
  000c4	e35400c0	 cmp         r4, #0xC0
  000c8	da00000d	 ble         |$LN13@PressedRel|
  000cc	e35400c6	 cmp         r4, #0xC6
  000d0	da000008	 ble         |$LN1@PressedRel|
  000d4	e35400df	 cmp         r4, #0xDF
  000d8	1a000009	 bne         |$LN13@PressedRel|
  000dc		 |$LN2@PressedRel|

; 255  :                             {
; 256  :                             case VK_TPOWER:
; 257  :                             case VK_OFF:
; 258  :                                 // only disable interrupts if we are about to enter
; 259  :                                 // a suspend state
; 260  :                                 RETAILMSG(ZONE_IST, 
; 261  :                                     (L" PressedReleasedKeys: 0x%02X\r\n", 
; 262  :                                     vk
; 263  :                                     ));

  000dc	e59b3440	 ldr         r3, [r11, #0x440]
  000e0	e3130010	 tst         r3, #0x10
  000e4	159f003c	 ldrne       r0, [pc, #0x3C]
  000e8	11a01004	 movne       r1, r4
  000ec	1b000000	 blne        NKDbgPrintfW

; 264  :                                 PowerPolicyNotify(PPN_SUSPENDKEYPRESSED, 0);

  000f0	e3a00004	 mov         r0, #4

; 265  :                                 break;

  000f4	ea000000	 b           |$LN28@PressedRel|
  000f8		 |$LN1@PressedRel|

; 266  : 
; 267  :                             case VK_APPS:
; 268  :                             case VK_APP1:
; 269  :                             case VK_APP2:
; 270  :                             case VK_APP3:
; 271  :                             case VK_APP4:
; 272  :                             case VK_APP5:
; 273  :                             case VK_APP6:                     
; 274  :                                 PowerPolicyNotify(PPN_APPBUTTONPRESSED, 0);

  000f8	e3a00006	 mov         r0, #6
  000fc		 |$LN28@PressedRel|
  000fc	e3a01000	 mov         r1, #0
  00100	eb000000	 bl          PowerPolicyNotify
  00104		 |$LN13@PressedRel|
  00104	e2843001	 add         r3, r4, #1
  00108	e20340ff	 and         r4, r3, #0xFF
  0010c	e1b06086	 movs        r6, r6, lsl #1
  00110	1affffc8	 bne         |$LL14@PressedRel|
  00114		 |$LN18@PressedRel|

; 205  :     UINT8 vk;
; 206  :     int ic;
; 207  : 
; 208  :     for (ic = 0, vk = 0; ic < VK_KEYS/DWORD_BITS; ic++)

  00114	e2855004	 add         r5, r5, #4
  00118	e2577001	 subs        r7, r7, #1
  0011c	1affffbe	 bne         |$LL19@PressedRel|

; 275  :                                 break;
; 276  :                             }
; 277  :                         
; 278  :                         }
; 279  :                     }
; 280  :                 }
; 281  :             }
; 282  :         }
; 283  : }

  00120	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00124	e12fff1e	 bx          lr
  00128		 |$LN32@PressedRel|
  00128		 |$LN33@PressedRel|
  00128	00000000	 DCD         |??_C@_1DO@HFBDPGNP@?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAs?$AAe?$AAd?$AAR?$AAe?$AAl?$AAe?$AAa?$AAs?$AAe?$AAd?$AAK?$AAe?$AAy?$AAs?$AA?3?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AA2?$AAX?$AA?$AN?$AA?6?$AA?$AA@|
  0012c		 |$LN34@PressedRel|
  0012c	00000000	 DCD         |dpCurSettings|
  00130		 |$M44659|

			 ENDP  ; |PressedReleasedKeys|

	IMPORT	|g_keypadRepeat|

  00000			 AREA	 |.pdata|, PDATA
|$T44692| DCD	|$LN30@AutoRepeat|
	DCD	0x40005e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |AutoRepeat| PROC

; 1028 : {

  00000		 |$LN30@AutoRepeat|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M44689|
  00008	e1a07002	 mov         r7, r2
  0000c	e1a02001	 mov         r2, r1
  00010	e1a06000	 mov         r6, r0
  00014	e58d2004	 str         r2, [sp, #4]
  00018	e1a04003	 mov         r4, r3
  0001c	e58d6000	 str         r6, [sp]

; 1029 :     ULONG ix;
; 1030 : 
; 1031 :     for (ix = 0; ix < g_keypadRepeat.count; ix++)

  00020	e59fa14c	 ldr         r10, [pc, #0x14C]
  00024	e3a08000	 mov         r8, #0
  00028	e1dae0b0	 ldrh        lr, [r10]
  0002c	e35e0000	 cmp         lr, #0
  00030	0a00004c	 beq         |$LN14@AutoRepeat|
  00034	e3a09000	 mov         r9, #0
  00038	e3a00001	 mov         r0, #1
  0003c	e3a01000	 mov         r1, #0
  00040		 |$LL16@AutoRepeat|
  00040	e59ae004	 ldr         lr, [r10, #4]
  00044	e1a05009	 mov         r5, r9

; 1032 :         {
; 1033 :         const KEYPAD_REPEAT_ITEM *pItem = &g_keypadRepeat.pItem[ix];
; 1034 :         KeypadRepeatState_t *pState = &pRepeatState[ix];
; 1035 :         DWORD delay;        
; 1036 :         UINT8 vkBlock;
; 1037 :         UINT8 vk = pItem->vkey;
; 1038 : 
; 1039 :         if ((vkNewState[vk >> 5] & (1 << (vk & 0x1F))) != 0)

  00048	e3a0a001	 mov         r10, #1
  0004c	e7f5b00e	 ldrb        r11, [r5, +lr]!
  00050	e1a0e2ab	 mov         lr, r11, lsr #5
  00054	e792e10e	 ldr         lr, [r2, +lr, lsl #2]
  00058	e20b301f	 and         r3, r11, #0x1F
  0005c	e11e031a	 tst         lr, r10, lsl r3
  00060	0a000037	 beq         |$LN13@AutoRepeat|

; 1040 :             {
; 1041 :             if (!pState->pending)

  00064	e5943000	 ldr         r3, [r4]
  00068	e3530000	 cmp         r3, #0
  0006c	1a000006	 bne         |$LN12@AutoRepeat|

; 1042 :                 {
; 1043 :                 // Key was just pressed
; 1044 :                 delay = pItem->firstDelay;

  00070	e1d530b2	 ldrh        r3, [r5, #2]
  00074	e3530000	 cmp         r3, #0

; 1045 :                 if (delay == 0) delay = pDevice->firstRepeat;

  00078	05963018	 ldreq       r3, [r6, #0x18]

; 1046 :                 pState->time = time + delay;
; 1047 :                 pState->pending = TRUE;

  0007c	e5840000	 str         r0, [r4]
  00080	e0833007	 add         r3, r3, r7
  00084	e5843004	 str         r3, [r4, #4]

; 1048 :                 pState->blocked = FALSE;

  00088	ea00002e	 b           |$LN26@AutoRepeat|
  0008c		 |$LN12@AutoRepeat|

; 1049 :                 }
; 1050 :             else if (((INT32)(time - pState->time)) >= 0)

  0008c	e5943004	 ldr         r3, [r4, #4]
  00090	e0573003	 subs        r3, r7, r3
  00094	4a00002c	 bmi         |$LN15@AutoRepeat|

; 1051 :                 {
; 1052 :                 // Check if any blocking keys are pressed
; 1053 :                 const KEYPAD_REPEAT_BLOCK *pBlock = pItem->pBlock;

  00098	e595300c	 ldr         r3, [r5, #0xC]
  0009c	e3530000	 cmp         r3, #0

; 1054 :                 if (pBlock != 0)

  000a0	0a000013	 beq         |$LN5@AutoRepeat|

; 1055 :                     {
; 1056 :                     int ik;
; 1057 :                     for ( ik = 0; ik < pBlock->count; ik++ )

  000a4	e5d3e000	 ldrb        lr, [r3]
  000a8	e3a00000	 mov         r0, #0
  000ac	e35e0000	 cmp         lr, #0
  000b0	da00000f	 ble         |$LN5@AutoRepeat|
  000b4	e5936004	 ldr         r6, [r3, #4]
  000b8		 |$LL7@AutoRepeat|

; 1058 :                         {
; 1059 :                         vkBlock = pBlock->pVKey[ik];

  000b8	e7d61000	 ldrb        r1, [r6, +r0]

; 1060 :                         if ((vkNewState[vkBlock >> 5] &
; 1061 :                                (1 << (vkBlock & 0x1F))) != 0)

  000bc	e1a032a1	 mov         r3, r1, lsr #5
  000c0	e7922103	 ldr         r2, [r2, +r3, lsl #2]
  000c4	e201301f	 and         r3, r1, #0x1F
  000c8	e3a01001	 mov         r1, #1
  000cc	e1120311	 tst         r2, r1, lsl r3
  000d0	1a000004	 bne         |$LN23@AutoRepeat|
  000d4	e2800001	 add         r0, r0, #1
  000d8	e59d2004	 ldr         r2, [sp, #4]
  000dc	e150000e	 cmp         r0, lr
  000e0	bafffff4	 blt         |$LL7@AutoRepeat|
  000e4	ea000001	 b           |$LN27@AutoRepeat|
  000e8		 |$LN23@AutoRepeat|

; 1062 :                             {
; 1063 :                             pState->blocked = TRUE;

  000e8	e3a03001	 mov         r3, #1
  000ec	e5843008	 str         r3, [r4, #8]
  000f0		 |$LN27@AutoRepeat|

; 1028 : {

  000f0	e59d6000	 ldr         r6, [sp]
  000f4		 |$LN5@AutoRepeat|

; 1064 :                             DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 1065 :                                 L"Block repeat: 0x%x bcause of 0x%x\r\n",
; 1066 :                                 vk, vkBlock
; 1067 :                                 ));
; 1068 :                             break;
; 1069 :                             }
; 1070 :                         }
; 1071 :                     }
; 1072 :                 
; 1073 :                 // Repeat if not blocked
; 1074 :                 if (!pState->blocked)

  000f4	e5943008	 ldr         r3, [r4, #8]
  000f8	e3530000	 cmp         r3, #0
  000fc	1a000007	 bne         |$LN3@AutoRepeat|

; 1075 :                     {
; 1076 :                     DEBUGMSG(ZONE_IST, (L" KPD_IntrThread: "
; 1077 :                         L"Key Repeat: 0x%x\r\n", vk
; 1078 :                         ));
; 1079 :                     SendKeyPadEvent(vk, 0, pItem->silent ? KEYEVENTF_SILENT : 0, 0);

  00100	e5953008	 ldr         r3, [r5, #8]
  00104	e3a01000	 mov         r1, #0
  00108	e1a0000b	 mov         r0, r11
  0010c	e3530000	 cmp         r3, #0
  00110	13a02004	 movne       r2, #4
  00114	03a02000	 moveq       r2, #0
  00118	e3a03000	 mov         r3, #0
  0011c	eb000000	 bl          SendKeyPadEvent
  00120		 |$LN3@AutoRepeat|

; 1080 :                     }
; 1081 :                 // Set time for next repeat
; 1082 :                 delay = pItem->nextDelay;

  00120	e1d530b4	 ldrh        r3, [r5, #4]

; 1083 :                 if (delay == 0) delay = pDevice->nextRepeat;
; 1084 :                 pState->time = time + delay;
; 1085 :                 }
; 1086 :             }
; 1087 :         else

  00124	e59d2004	 ldr         r2, [sp, #4]
  00128	e3a01000	 mov         r1, #0
  0012c	e3530000	 cmp         r3, #0
  00130	0596301c	 ldreq       r3, [r6, #0x1C]
  00134	e3a00001	 mov         r0, #1
  00138	e0833007	 add         r3, r3, r7
  0013c	e5843004	 str         r3, [r4, #4]
  00140	ea000001	 b           |$LN15@AutoRepeat|
  00144		 |$LN13@AutoRepeat|

; 1088 :             {
; 1089 :             pState->pending = FALSE;

  00144	e5841000	 str         r1, [r4]
  00148		 |$LN26@AutoRepeat|

; 1090 :             pState->blocked = FALSE;

  00148	e5841008	 str         r1, [r4, #8]
  0014c		 |$LN15@AutoRepeat|
  0014c	e59fa020	 ldr         r10, [pc, #0x20]
  00150	e2888001	 add         r8, r8, #1
  00154	e2899010	 add         r9, r9, #0x10
  00158	e1da30b0	 ldrh        r3, [r10]
  0015c	e284400c	 add         r4, r4, #0xC
  00160	e1580003	 cmp         r8, r3
  00164	3affffb5	 bcc         |$LL16@AutoRepeat|
  00168		 |$LN14@AutoRepeat|

; 1091 :             }
; 1092 :         }
; 1093 : }

  00168	e28dd008	 add         sp, sp, #8
  0016c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00170	e12fff1e	 bx          lr
  00174		 |$LN31@AutoRepeat|
  00174		 |$LN32@AutoRepeat|
  00174	00000000	 DCD         |g_keypadRepeat|
  00178		 |$M44690|

			 ENDP  ; |AutoRepeat|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|KPD_IntrThread|
	IMPORT	|GetTickCount|
	IMPORT	|TWLReadRegs|
	IMPORT	|LocalAlloc|
	IMPORT	|memcpy|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T44752| DCD	|$LN40@KPD_IntrTh|
	DCD	0xc000a002

  00000			 AREA	 |.xdata|, DATA
|$T44748| DCD	0xffffffd8
; Function compile flags: /Ogspy
; File c:\wince600\platform\common\src\soc\common_ti_v1\tps659xx\keypad\keypad.c

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T44748|

  00008		 |KPD_IntrThread| PROC

; 1102 : {

  00008		 |$LN40@KPD_IntrTh|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd054	 sub         sp, sp, #0x54
  00010		 |$M44749|
  00010	e1a05000	 mov         r5, r0
  00014	e58d5004	 str         r5, [sp, #4]
  00018	e59f3264	 ldr         r3, [pc, #0x264]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3050	 str         r3, [sp, #0x50]

; 1103 :     KeypadDevice_t *pDevice = (KeypadDevice_t*)pContext;
; 1104 :     KeypadRemapState_t *pRemapState = NULL;
; 1105 :     KeypadRepeatState_t *pRepeatState = NULL;
; 1106 :     UINT8 matrix[MATRIX_SIZE];
; 1107 :     DWORD vkState[VK_KEYS/DWORD_BITS];
; 1108 :     DWORD vkNewState[VK_KEYS/DWORD_BITS];
; 1109 :     DWORD timeout;
; 1110 : 
; 1111 :     // Init data
; 1112 :     memset(matrix, 0, sizeof(matrix));

  00024	e3a02008	 mov         r2, #8
  00028	e3a01000	 mov         r1, #0
  0002c	e28d0048	 add         r0, sp, #0x48
  00030	e3a08000	 mov         r8, #0
  00034	e3a07000	 mov         r7, #0
  00038	eb000000	 bl          memset

; 1113 :     memset(vkState, 0, sizeof(vkState));

  0003c	e3a02020	 mov         r2, #0x20
  00040	e3a01000	 mov         r1, #0
  00044	e28d0028	 add         r0, sp, #0x28
  00048	eb000000	 bl          memset

; 1114 :     memset(vkNewState, 0, sizeof(vkNewState));

  0004c	e3a02020	 mov         r2, #0x20
  00050	e3a01000	 mov         r1, #0
  00054	e28d0008	 add         r0, sp, #8
  00058	eb000000	 bl          memset

; 1115 : 
; 1116 :     // Set thread priority
; 1117 :     CeSetThreadPriority(pDevice->hIntrThreadKeypad, pDevice->priority256);

  0005c	e5951004	 ldr         r1, [r5, #4]
  00060	e5950024	 ldr         r0, [r5, #0x24]
  00064	eb000000	 bl          CeSetThreadPriority

; 1118 : 
; 1119 :     // Initialize remap informations
; 1120 :     if (g_keypadRemap.count > 0)

  00068	e59f3210	 ldr         r3, [pc, #0x210]
  0006c	e1d330b0	 ldrh        r3, [r3]
  00070	e3530000	 cmp         r3, #0
  00074	0a000004	 beq         |$LN11@KPD_IntrTh|

; 1121 :         {
; 1122 :         // Allocate state structure for remap, zero initialized
; 1123 :         pRemapState = LocalAlloc(
; 1124 :             LPTR, g_keypadRemap.count * sizeof(KeypadRemapState_t)
; 1125 :             );

  00078	e1a01203	 mov         r1, r3, lsl #4
  0007c	e3a00040	 mov         r0, #0x40
  00080	eb000000	 bl          LocalAlloc
  00084	e1b08000	 movs        r8, r0

; 1126 :         if (pRemapState == NULL)

  00088	0a000074	 beq         |$LN1@KPD_IntrTh|
  0008c		 |$LN11@KPD_IntrTh|

; 1127 :             {
; 1128 :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 1129 :                 L"Failed allocate memory for virtual key remap\r\n"
; 1130 :                 ));
; 1131 :             goto cleanUp;
; 1132 :             }
; 1133 :         }
; 1134 : 
; 1135 :     // Initialize repeat informations
; 1136 :     if (g_keypadRepeat.count > 0)

  0008c	e59f31e8	 ldr         r3, [pc, #0x1E8]
  00090	e1d330b0	 ldrh        r3, [r3]
  00094	e3530000	 cmp         r3, #0
  00098	0a000005	 beq         |$LN9@KPD_IntrTh|

; 1137 :         {
; 1138 :         // Allocate state structure for repeat, zero initialized
; 1139 :         pRepeatState = LocalAlloc(
; 1140 :             LPTR, g_keypadRepeat.count * sizeof(KeypadRepeatState_t)
; 1141 :             );

  0009c	e0833083	 add         r3, r3, r3, lsl #1
  000a0	e1a01103	 mov         r1, r3, lsl #2
  000a4	e3a00040	 mov         r0, #0x40
  000a8	eb000000	 bl          LocalAlloc
  000ac	e1b07000	 movs        r7, r0

; 1142 :         if (pRepeatState == NULL)

  000b0	0a000064	 beq         |$cleanUp$44150|
  000b4		 |$LN9@KPD_IntrTh|

; 1143 :             {
; 1144 :             DEBUGMSG(ZONE_ERROR, (L" KPD_IntrThread: "
; 1145 :                 L"Failed allocate memory for virtual key auto repeat\r\n"
; 1146 :                 ));
; 1147 :             goto cleanUp;
; 1148 :             }
; 1149 :         }
; 1150 : 
; 1151 :     // Set delay to sample period
; 1152 :     timeout = pDevice->samplePeriod;
; 1153 : 
; 1154 :     // Loop until we are not stopped...
; 1155 :     while (!pDevice->intrThreadExit)

  000b4	e5953028	 ldr         r3, [r5, #0x28]
  000b8	e5951014	 ldr         r1, [r5, #0x14]
  000bc	e3530000	 cmp         r3, #0
  000c0	1a000060	 bne         |$cleanUp$44150|
  000c4	e3a040db	 mov         r4, #0xDB
  000c8	e3a02000	 mov         r2, #0
  000cc	e28db048	 add         r11, sp, #0x48
  000d0		 |$LL8@KPD_IntrTh|

; 1156 :         {
; 1157 :         DWORD time;
; 1158 :         BOOL keyDown = FALSE;
; 1159 : 
; 1160 :         // Wait for event
; 1161 :         WaitForSingleObject(pDevice->hIntrEventKeypad, timeout);

  000d0	e5950020	 ldr         r0, [r5, #0x20]
  000d4	e58d2000	 str         r2, [sp]
  000d8	eb000000	 bl          WaitForSingleObject

; 1162 :         if (pDevice->intrThreadExit) break;

  000dc	e5953028	 ldr         r3, [r5, #0x28]
  000e0	e3530000	 cmp         r3, #0
  000e4	1a000057	 bne         |$cleanUp$44150|

; 1163 : 
; 1164 :         // read MATRIX_SIZE amount of rows..
; 1165 :         if (TWLReadRegs(pDevice->hTWL, TWL_LOGADDR_FULL_CODE_7_0, NULL, 0))

  000e8	e5950034	 ldr         r0, [r5, #0x34]
  000ec	e3a03000	 mov         r3, #0
  000f0	e3a02000	 mov         r2, #0
  000f4	e24418fe	 sub         r1, r4, #0xFE, 16
  000f8	eb000000	 bl          TWLReadRegs
  000fc	e3500000	 cmp         r0, #0
  00100	0a000005	 beq         |$LN5@KPD_IntrTh|

; 1166 :             {
; 1167 :             TWLReadRegs(pDevice->hTWL, TWL_LOGADDR_FULL_CODE_7_0, matrix, sizeof(matrix));

  00104	e5950034	 ldr         r0, [r5, #0x34]
  00108	e3a03008	 mov         r3, #8
  0010c	e28d2048	 add         r2, sp, #0x48
  00110	e24418fe	 sub         r1, r4, #0xFE, 16
  00114	eb000000	 bl          TWLReadRegs

; 1168 :             }
; 1169 :         else

  00118	ea000003	 b           |$LN4@KPD_IntrTh|
  0011c		 |$LN5@KPD_IntrTh|

; 1170 :             {
; 1171 :             memset(matrix, 0, sizeof(matrix));

  0011c	e3a02008	 mov         r2, #8
  00120	e3a01000	 mov         r1, #0
  00124	e28d0048	 add         r0, sp, #0x48
  00128	eb000000	 bl          memset
  0012c		 |$LN4@KPD_IntrTh|

; 1172 :             }
; 1173 :        
; 1174 :         // Convert physical state to virtual keys state
; 1175 :         PhysicalStateToVirtualState(matrix, vkNewState, &keyDown);

  0012c	e3a0a000	 mov         r10, #0
  00130	e3a06000	 mov         r6, #0
  00134	e3a0e000	 mov         lr, #0
  00138	e3a05001	 mov         r5, #1
  0013c		 |$LL25@KPD_IntrTh|
  0013c	e7d6900b	 ldrb        r9, [r6, +r11]
  00140	e3590000	 cmp         r9, #0
  00144	028ee008	 addeq       lr, lr, #8
  00148	0a000012	 beq         |$LN24@KPD_IntrTh|
  0014c	e59fb124	 ldr         r11, [pc, #0x124]
  00150	e3a04000	 mov         r4, #0
  00154	e3a03001	 mov         r3, #1
  00158		 |$LL21@KPD_IntrTh|
  00158	e1190413	 tst         r9, r3, lsl r4
  0015c	0a000008	 beq         |$LN20@KPD_IntrTh|
  00160	e7de100b	 ldrb        r1, [lr, +r11]
  00164	e28d0008	 add         r0, sp, #8
  00168	e3a0a001	 mov         r10, #1
  0016c	e1a032a1	 mov         r3, r1, lsr #5
  00170	e7b02103	 ldr         r2, [r0, +r3, lsl #2]!
  00174	e201301f	 and         r3, r1, #0x1F
  00178	e1823315	 orr         r3, r2, r5, lsl r3
  0017c	e5803000	 str         r3, [r0]
  00180	e3a03001	 mov         r3, #1
  00184		 |$LN20@KPD_IntrTh|
  00184	e2844001	 add         r4, r4, #1
  00188	e3540008	 cmp         r4, #8
  0018c	e28ee001	 add         lr, lr, #1
  00190	3afffff0	 bcc         |$LL21@KPD_IntrTh|
  00194	e28db048	 add         r11, sp, #0x48
  00198		 |$LN24@KPD_IntrTh|
  00198	e2866001	 add         r6, r6, #1
  0019c	e3560008	 cmp         r6, #8
  001a0	3affffe5	 bcc         |$LL25@KPD_IntrTh|
  001a4	e35a0000	 cmp         r10, #0
  001a8	13a03001	 movne       r3, #1
  001ac	e59d5004	 ldr         r5, [sp, #4]
  001b0	158d3000	 strne       r3, [sp]

; 1176 : 
; 1177 :         time = GetTickCount();

  001b4	eb000000	 bl          GetTickCount

; 1178 : 
; 1179 :         // Remap multi virtual keys to final virtual key
; 1180 :         VirtualKeyRemap(time, &keyDown, pRemapState, vkNewState);

  001b8	e28d3008	 add         r3, sp, #8
  001bc	e1a02008	 mov         r2, r8
  001c0	e28d1000	 add         r1, sp, #0
  001c4	e1a04000	 mov         r4, r0
  001c8	eb000000	 bl          VirtualKeyRemap

; 1181 :         PressedReleasedKeys(pDevice, vkState, vkNewState);

  001cc	e28d2008	 add         r2, sp, #8
  001d0	e28d1028	 add         r1, sp, #0x28
  001d4	e1a00005	 mov         r0, r5
  001d8	eb000000	 bl          PressedReleasedKeys

; 1182 :         AutoRepeat(pDevice, vkNewState, time, pRepeatState);

  001dc	e1a03007	 mov         r3, r7
  001e0	e1a02004	 mov         r2, r4
  001e4	e28d1008	 add         r1, sp, #8
  001e8	e1a00005	 mov         r0, r5
  001ec	eb000000	 bl          AutoRepeat

; 1183 : 
; 1184 :         if( pDevice->hKeypressEvent != NULL )

  001f0	e595303c	 ldr         r3, [r5, #0x3C]
  001f4	e3530000	 cmp         r3, #0

; 1185 :             {
; 1186 :             // Signal keypad light thread
; 1187 :             SetEvent(pDevice->hKeypressEvent);

  001f8	13a01003	 movne       r1, #3
  001fc	11a00003	 movne       r0, r3
  00200	1b000000	 blne        EventModify

; 1188 :             }
; 1189 : 
; 1190 :         //--------------------------------------------------------------
; 1191 :         // Prepare for next run
; 1192 :         //--------------------------------------------------------------
; 1193 : 
; 1194 :         // New state become old
; 1195 :         memcpy(vkState, vkNewState, sizeof(vkState));

  00204	e28d0028	 add         r0, sp, #0x28
  00208	e28d1008	 add         r1, sp, #8
  0020c	e3a02020	 mov         r2, #0x20
  00210	eb000000	 bl          memcpy

; 1196 :         // Get new state for virtual key table
; 1197 :         memset(vkNewState, 0, sizeof(vkNewState));

  00214	e3a02020	 mov         r2, #0x20
  00218	e3a01000	 mov         r1, #0
  0021c	e28d0008	 add         r0, sp, #8
  00220	eb000000	 bl          memset

; 1198 : 
; 1199 :         // Set timeout period depending on data state
; 1200 :         timeout = keyDown ? pDevice->samplePeriod : INFINITE;

  00224	e59d3000	 ldr         r3, [sp]
  00228	e3a040db	 mov         r4, #0xDB
  0022c	e3a02000	 mov         r2, #0
  00230	e3530000	 cmp         r3, #0
  00234	e5953028	 ldr         r3, [r5, #0x28]
  00238	15951014	 ldrne       r1, [r5, #0x14]
  0023c	03e01000	 mvneq       r1, #0
  00240	e3530000	 cmp         r3, #0
  00244	0affffa1	 beq         |$LL8@KPD_IntrTh|
  00248		 |$cleanUp$44150|

; 1201 : 
; 1202 :         // Interrupt is done
; 1203 :         }
; 1204 : 
; 1205 : cleanUp:
; 1206 :     if ( pRemapState != NULL )

  00248	e3580000	 cmp         r8, #0

; 1207 :         {
; 1208 :         LocalFree(pRemapState);

  0024c	11a00008	 movne       r0, r8
  00250	1b000000	 blne        LocalFree

; 1209 :         }
; 1210 : 
; 1211 :     if ( pRepeatState != NULL )

  00254	e3570000	 cmp         r7, #0

; 1212 :         {
; 1213 :         LocalFree(pRepeatState);

  00258	11a00007	 movne       r0, r7
  0025c	1b000000	 blne        LocalFree
  00260		 |$LN1@KPD_IntrTh|

; 1214 :         }
; 1215 : 
; 1216 :     return ERROR_SUCCESS;

  00260	e59d0050	 ldr         r0, [sp, #0x50]
  00264	eb000000	 bl          __security_check_cookie
  00268	e3a00000	 mov         r0, #0

; 1217 : }

  0026c	e28dd054	 add         sp, sp, #0x54
  00270	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00274	e12fff1e	 bx          lr
  00278		 |$LN41@KPD_IntrTh|
  00278		 |$LN42@KPD_IntrTh|
  00278	00000000	 DCD         |g_keypadVK|
  0027c		 |$LN43@KPD_IntrTh|
  0027c	00000000	 DCD         |g_keypadRepeat|
  00280		 |$LN44@KPD_IntrTh|
  00280	00000000	 DCD         |g_keypadRemap|
  00284		 |$LN45@KPD_IntrTh|
  00284	00000000	 DCD         |__security_cookie|
  00288		 |$M44750|

			 ENDP  ; |KPD_IntrThread|

	EXPORT	|KPD_Init|
	IMPORT	|CreateThread|
	IMPORT	|TWLWakeEnable|
	IMPORT	|TWLInterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|TWLWriteRegs|
	IMPORT	|TWLOpen|
	IMPORT	|GetDeviceRegistryParams|

  00000			 AREA	 |.pdata|, PDATA
|$T44771| DCD	|$LN18@KPD_Init|
	DCD	0x40007502
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |KPD_Init| PROC

; 343  : {

  00000		 |$LN18@KPD_Init|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M44768|
  00008	e1a06000	 mov         r6, r0

; 344  :     DWORD rc = (DWORD)NULL;
; 345  :     KeypadDevice_t *pDevice = NULL;
; 346  :     UINT8 regval;
; 347  : 
; 348  :     UNREFERENCED_PARAMETER(pBusContext);
; 349  : 
; 350  :     DEBUGMSG(ZONE_FUNCTION, (
; 351  :         L"+KPD_Init(%s, 0x%08x)\r\n", szContext, pBusContext
; 352  :         ));
; 353  : 
; 354  :     // Create device structure
; 355  :     pDevice = (KeypadDevice_t *)LocalAlloc(LPTR, sizeof(KeypadDevice_t));

  0000c	e3a0104c	 mov         r1, #0x4C
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a05000	 mov         r5, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 356  :     if (pDevice == NULL)

  00020	0a000061	 beq         |$LN15@KPD_Init|

; 357  :         {
; 358  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 359  :             L"Failed allocate KDP driver structure\r\n"
; 360  :             ));
; 361  :         goto cleanUp;
; 362  :         }
; 363  : 
; 364  :     memset(pDevice, 0, sizeof(KeypadDevice_t));

  00024	e3a0204c	 mov         r2, #0x4C
  00028	e3a01000	 mov         r1, #0
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          memset

; 365  : 
; 366  :     // Set cookie & initialize critical section
; 367  :     pDevice->cookie = KPD_DEVICE_COOKIE;

  00034	e59f1194	 ldr         r1, [pc, #0x194]

; 368  :     
; 369  :     // Read device parameters
; 370  :     if (GetDeviceRegistryParams(
; 371  :             szContext, pDevice, dimof(s_deviceRegParams), s_deviceRegParams)
; 372  :             != ERROR_SUCCESS)

  00038	e59f318c	 ldr         r3, [pc, #0x18C]
  0003c	e3a0200b	 mov         r2, #0xB
  00040	e5841000	 str         r1, [r4]
  00044	e1a01004	 mov         r1, r4
  00048	e1a00006	 mov         r0, r6
  0004c	eb000000	 bl          GetDeviceRegistryParams
  00050	e3500000	 cmp         r0, #0
  00054	1a000054	 bne         |$LN15@KPD_Init|

; 373  :         {
; 374  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 375  :             L"Failed read KPD driver registry parameters\r\n"
; 376  :             ));
; 377  :         goto cleanUp;
; 378  :         }
; 379  : 
; 380  :     // Open parent bus
; 381  :     pDevice->hTWL = TWLOpen();

  00058	eb000000	 bl          TWLOpen
  0005c	e3500000	 cmp         r0, #0
  00060	e5840034	 str         r0, [r4, #0x34]

; 382  :     if (pDevice->hTWL == NULL)

  00064	0a000050	 beq         |$LN15@KPD_Init|

; 383  :         {
; 384  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 385  :             L"Failed open TWL bus driver\r\n"
; 386  :             ));
; 387  :         goto cleanUp;
; 388  :         }
; 389  : 
; 390  :     // Set debounce delay and enable hardware mode
; 391  :     regval = TWL_KBD_CTRL_KBD_ON | TWL_KBD_CTRL_NRESET | TWL_KBD_CTRL_NSOFT_MODE;

  00068	e3a03043	 mov         r3, #0x43
  0006c	e5cd3008	 strb        r3, [sp, #8]

; 392  :     TWLWriteRegs(pDevice->hTWL, TWL_KEYP_CTRL_REG, &regval, sizeof(regval));

  00070	e5940034	 ldr         r0, [r4, #0x34]
  00074	e3a06802	 mov         r6, #2, 16
  00078	e3a03001	 mov         r3, #1
  0007c	e28d2008	 add         r2, sp, #8
  00080	e38610d2	 orr         r1, r6, #0xD2
  00084	eb000000	 bl          TWLWriteRegs

; 393  :     regval = 0x07 << 5;

  00088	e3a030e0	 mov         r3, #0xE0
  0008c	e5cd3008	 strb        r3, [sp, #8]

; 394  :     TWLWriteRegs(pDevice->hTWL, TWL_LK_PTV_REG, &regval, sizeof(regval));

  00090	e5940034	 ldr         r0, [r4, #0x34]
  00094	e3a03001	 mov         r3, #1
  00098	e28d2008	 add         r2, sp, #8
  0009c	e38610d5	 orr         r1, r6, #0xD5
  000a0	eb000000	 bl          TWLWriteRegs

; 395  :     regval = (UINT8)pDevice->debounceCount & 0x3F;

  000a4	e5941010	 ldr         r1, [r4, #0x10]

; 396  :     TWLWriteRegs(pDevice->hTWL, TWL_KEY_DEB_REG, &regval, sizeof(regval));

  000a8	e3a03001	 mov         r3, #1
  000ac	e28d2008	 add         r2, sp, #8
  000b0	e201103f	 and         r1, r1, #0x3F
  000b4	e5cd1008	 strb        r1, [sp, #8]
  000b8	e5940034	 ldr         r0, [r4, #0x34]
  000bc	e38610d3	 orr         r1, r6, #0xD3
  000c0	eb000000	 bl          TWLWriteRegs

; 397  :   
; 398  :     // Create interrupt event
; 399  :     pDevice->hIntrEventKeypad = CreateEvent(NULL, FALSE, FALSE, NULL);

  000c4	e3a03000	 mov         r3, #0
  000c8	e3a02000	 mov         r2, #0
  000cc	e3a01000	 mov         r1, #0
  000d0	e3a00000	 mov         r0, #0
  000d4	eb000000	 bl          CreateEventW
  000d8	e1b02000	 movs        r2, r0
  000dc	e5842020	 str         r2, [r4, #0x20]

; 400  :     if (pDevice->hIntrEventKeypad == NULL)

  000e0	0a000031	 beq         |$LN15@KPD_Init|

; 401  :         {
; 402  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: KPD_Init: "
; 403  :             L"Failed create keypad interrupt event\r\n"
; 404  :             ));
; 405  :         goto cleanUp;
; 406  :         }
; 407  : 
; 408  :     // Associate event with TWL KP interrupt
; 409  :     if (!TWLInterruptInitialize(pDevice->hTWL, TWL_INTR_ITKPI, pDevice->hIntrEventKeypad))

  000e4	e5940034	 ldr         r0, [r4, #0x34]
  000e8	e3a06a01	 mov         r6, #1, 20
  000ec	e386102a	 orr         r1, r6, #0x2A
  000f0	eb000000	 bl          TWLInterruptInitialize
  000f4	e3500000	 cmp         r0, #0
  000f8	0a00002b	 beq         |$LN15@KPD_Init|

; 410  :         {
; 411  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 412  :             L"Failed associate event with TWL KBD interrupt\r\n"
; 413  :             ));
; 414  :         goto cleanUp;
; 415  :         }
; 416  : 
; 417  :     // Enable KP event
; 418  :     if (!TWLInterruptMask(pDevice->hTWL, TWL_INTR_ITKPI, FALSE))

  000fc	e5940034	 ldr         r0, [r4, #0x34]
  00100	e3a02000	 mov         r2, #0
  00104	e386102a	 orr         r1, r6, #0x2A
  00108	eb000000	 bl          TWLInterruptMask

; 419  :         {
; 420  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 421  :             L"Failed associate event with TWL KBD interrupt\r\n"
; 422  :             ));
; 423  :         }
; 424  :         
; 425  :     // register to be wake-up enabled
; 426  :     if (pDevice->enableWake != 0)

  0010c	e5943008	 ldr         r3, [r4, #8]
  00110	e3530000	 cmp         r3, #0

; 427  :         {
; 428  :         TWLWakeEnable(pDevice->hTWL, TWL_INTR_ITKPI, TRUE);

  00114	15940034	 ldrne       r0, [r4, #0x34]
  00118	13a02001	 movne       r2, #1
  0011c	1386102a	 orrne       r1, r6, #0x2A
  00120	1b000000	 blne        TWLWakeEnable

; 429  :         }
; 430  : 
; 431  :     // Start keypad interrupt service thread
; 432  :     pDevice->hIntrThreadKeypad = CreateThread(
; 433  :         NULL, 0, KPD_IntrThread, pDevice, 0,NULL
; 434  :         );

  00124	e59f209c	 ldr         r2, [pc, #0x9C]
  00128	e3a06000	 mov         r6, #0
  0012c	e1a03004	 mov         r3, r4
  00130	e3a01000	 mov         r1, #0
  00134	e3a00000	 mov         r0, #0
  00138	e58d6004	 str         r6, [sp, #4]
  0013c	e58d6000	 str         r6, [sp]
  00140	eb000000	 bl          CreateThread
  00144	e3500000	 cmp         r0, #0
  00148	e5840024	 str         r0, [r4, #0x24]

; 435  :     if (!pDevice->hIntrThreadKeypad)

  0014c	0a000016	 beq         |$LN15@KPD_Init|

; 436  :         {
; 437  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 438  :             L"Failed create keypad interrupt thread\r\n"
; 439  :             ));
; 440  :         goto cleanUp;
; 441  :         }
; 442  : 
; 443  :     if( pDevice->KpLedNum != -1)

  00150	e5943044	 ldr         r3, [r4, #0x44]
  00154	e3730001	 cmn         r3, #1
  00158	0a000011	 beq         |$LN2@KPD_Init|

; 444  :         {
; 445  :         // Create keypress notification event
; 446  :         pDevice->hKeypressEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  0015c	e3a03000	 mov         r3, #0
  00160	e3a02000	 mov         r2, #0
  00164	e3a01000	 mov         r1, #0
  00168	e3a00000	 mov         r0, #0
  0016c	eb000000	 bl          CreateEventW
  00170	e3500000	 cmp         r0, #0
  00174	e584003c	 str         r0, [r4, #0x3C]

; 447  :         if ( pDevice->hKeypressEvent == NULL )

  00178	0a00000b	 beq         |$LN15@KPD_Init|

; 448  :             {
; 449  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 450  :                 L"Failed to create keypress event\r\n"
; 451  :                 ));
; 452  :             goto cleanUp;
; 453  :             }
; 454  :     
; 455  :         // Start interrupt service thread
; 456  :         pDevice->hLightThread = CreateThread(
; 457  :             NULL, 0, KPD_LightThread, pDevice, 0,NULL
; 458  :             );

  0017c	e59f2040	 ldr         r2, [pc, #0x40]
  00180	e1a03004	 mov         r3, r4
  00184	e3a01000	 mov         r1, #0
  00188	e3a00000	 mov         r0, #0
  0018c	e58d6004	 str         r6, [sp, #4]
  00190	e58d6000	 str         r6, [sp]
  00194	eb000000	 bl          CreateThread
  00198	e3500000	 cmp         r0, #0
  0019c	e5840038	 str         r0, [r4, #0x38]

; 459  :         if (!pDevice->hLightThread)

  001a0	0a000001	 beq         |$LN15@KPD_Init|
  001a4		 |$LN2@KPD_Init|

; 460  :         {
; 461  :             DEBUGMSG (ZONE_ERROR, (L"ERROR: KPD_Init: "
; 462  :                 L"Failed to create keypad light thread\r\n"
; 463  :                 ));
; 464  :             goto cleanUp;
; 465  :             }
; 466  :         }
; 467  : 
; 468  :     // Return non-null value
; 469  :     rc = (DWORD)pDevice;

  001a4	e1a05004	 mov         r5, r4
  001a8		 |$cleanUp$43832|

; 470  : 
; 471  : cleanUp:
; 472  :     if (rc == 0)

  001a8	ea000001	 b           |$LN1@KPD_Init|
  001ac		 |$LN15@KPD_Init|

; 473  :         {
; 474  :         KPD_Deinit((DWORD)pDevice);

  001ac	e1a00004	 mov         r0, r4
  001b0	eb000000	 bl          KPD_Deinit
  001b4		 |$LN1@KPD_Init|

; 475  :         }
; 476  :     DEBUGMSG(ZONE_FUNCTION, (L"-KPD_Init(rc = %d\r\n", rc));
; 477  :     return rc;
; 478  : }

  001b4	e1a00005	 mov         r0, r5
  001b8	e28dd00c	 add         sp, sp, #0xC
  001bc	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  001c0	e12fff1e	 bx          lr
  001c4		 |$LN19@KPD_Init|
  001c4		 |$LN20@KPD_Init|
  001c4	00000000	 DCD         |KPD_LightThread|
  001c8		 |$LN21@KPD_Init|
  001c8	00000000	 DCD         |KPD_IntrThread|
  001cc		 |$LN22@KPD_Init|
  001cc	00000000	 DCD         |s_deviceRegParams|
  001d0		 |$LN23@KPD_Init|
  001d0	6b706444	 DCD         0x6b706444
  001d4		 |$M44769|

			 ENDP  ; |KPD_Init|

	END
