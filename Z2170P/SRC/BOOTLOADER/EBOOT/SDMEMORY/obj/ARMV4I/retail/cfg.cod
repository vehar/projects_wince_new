; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\EBOOT\SDMEMORY\cfg.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "


  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
	EXPORT	|BLReadBootCfg|
; File c:\wince600\platform\z2170p\src\bootloader\eboot\sdmemory\cfg.c

  00000			 AREA	 |.pdata|, PDATA
|$T46815| DCD	|$LN5@BLReadBoot|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLReadBootCfg| PROC

; 26   : {

  00000		 |$LN5@BLReadBoot|
  00000		 |$M46812|

; 27   :     BOOL rc = FALSE;
; 28   : #ifndef BSP_NO_NAND_IN_SDBOOT
; 29   :     HANDLE hFMD;
; 30   :     PCI_REG_INFO regInfo;
; 31   :     FlashInfo flashInfo;
; 32   :     SectorInfo sectorInfo;
; 33   :     SECTOR_ADDR sector;
; 34   :     BLOCK_ID block;
; 35   :     UINT32 count, offset;
; 36   :     UINT8 buffer[2048];
; 37   :     
; 38   : 
; 39   :     // EBOOT configuration is placed in last sector of EBOOT image
; 40   :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 41   :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 42   :     if (hFMD == NULL)
; 43   :         {
; 44   :         OALMSG(OAL_ERROR, (L"ERROR: FMD_Init call failed!\r\n"));
; 45   :         goto cleanUp;
; 46   :         }
; 47   : 
; 48   :     // Get flash info
; 49   :     if (!FMD_GetInfo(&flashInfo))
; 50   :         {
; 51   :         OALMSG(OAL_ERROR, (L"ERROR: FMD_GetInfo call failed!\r\n"));
; 52   :         goto cleanUp;
; 53   :         }
; 54   : 
; 55   :     // We can support only flash with sector size < 2048 bytes
; 56   :     if (flashInfo.wDataBytesPerSector > sizeof(buffer))
; 57   :         {
; 58   :         OALMSG(OAL_ERROR, (L"ERROR: "
; 59   :             L"Flash sector size %d bytes bigger than supported %d bytes\r\n",
; 60   :             flashInfo.wDataBytesPerSector, sizeof(buffer)    
; 61   :             ));
; 62   :         goto cleanUp;
; 63   :         }
; 64   : 
; 65   :     // Configuration is located in last sector of EBOOT image
; 66   :     offset = IMAGE_XLDR_BOOTSEC_NAND_SIZE + IMAGE_EBOOT_BOOTSEC_NAND_SIZE;
; 67   :     
; 68   :     // Start from beginning
; 69   :     block  = 0;
; 70   :     sector = 0;
; 71   : 
; 72   :     // Skip X-Loader & EBOOT code & bad blocks
; 73   :     // Note that we also check the last eboot block in order to ensure it is good
; 74   :     count = 0;
; 75   :     while ((count < offset) && (block < flashInfo.dwNumBlocks))
; 76   :         {
; 77   :         if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) == 0)
; 78   :             {
; 79   :             count += flashInfo.dwBytesPerBlock;
; 80   :             }
; 81   :         block++;
; 82   :         }
; 83   : 
; 84   :     // We've incremented past the last eboot block in order to check it too
; 85   :     // Back up now, the previous block is the last one containing eboot and is good
; 86   :     block--;
; 87   : 
; 88   :     //  Compute sector within the block where config lies
; 89   :     sector = block * flashInfo.wSectorsPerBlock;
; 90   :     sector += flashInfo.wSectorsPerBlock - 1;
; 91   : 
; 92   :     // Read sector to buffer
; 93   :     if (!FMD_ReadSector(sector, buffer, &sectorInfo, 1)) {
; 94   :         OALMSG(OAL_ERROR, (L"ERROR: EBOOT!BLReadBootCfg: "
; 95   :             L"Flash sector %d read failed\r\n", sector
; 96   :         ));
; 97   :             goto cleanUp;
; 98   :     }
; 99   : 
; 100  :     // Copy data to BOOT_CFG structure
; 101  :     memcpy(pBootCfg, buffer, sizeof(BOOT_CFG));        
; 102  : 
; 103  :     // Done    
; 104  :     rc = TRUE;
; 105  : 
; 106  : cleanUp:
; 107  :     if (hFMD != NULL) FMD_Deinit(hFMD);
; 108  : #else
; 109  :     UNREFERENCED_PARAMETER(pBootCfg);
; 110  : #endif
; 111  :     return rc;

  00000	e3a00000	 mov         r0, #0

; 112  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46813|

			 ENDP  ; |BLReadBootCfg|

	EXPORT	|BLWriteBootCfg|

  00000			 AREA	 |.pdata|, PDATA
|$T46824| DCD	|$LN5@BLWriteBoo|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLWriteBootCfg| PROC

; 117  : {

  00000		 |$LN5@BLWriteBoo|
  00000		 |$M46821|

; 118  :     BOOL rc = FALSE;
; 119  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 120  :     HANDLE hFMD;
; 121  :     PCI_REG_INFO regInfo;
; 122  :     FlashInfo flashInfo;
; 123  :     SectorInfo sectorInfo;
; 124  :     SECTOR_ADDR sector;
; 125  :     BLOCK_ID block;
; 126  :     UINT32 count, offset, length;
; 127  :     UINT8 buffer[2048];
; 128  :     UINT8 *pEBOOT;
; 129  :     
; 130  : 
; 131  :     // EBOOT configuration is placed in last sector of image
; 132  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 133  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 134  :     if (hFMD == NULL)
; 135  :         {
; 136  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_Init call failed!\r\n"));
; 137  :         goto cleanUp;
; 138  :         }
; 139  : 
; 140  :     // Get flash info
; 141  :     if (!FMD_GetInfo(&flashInfo))
; 142  :         {
; 143  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_GetInfo call failed!\r\n"));
; 144  :         goto cleanUp;
; 145  :         }
; 146  : 
; 147  :     // We can support only flash with sector size which fit to our buffer
; 148  :     if (flashInfo.wDataBytesPerSector > sizeof(buffer))
; 149  :         {
; 150  :         OALMSG(OAL_ERROR, (L"ERROR: "
; 151  :             L"Flash sector size %d bytes bigger that supported %d bytes\r\n",
; 152  :             flashInfo.wDataBytesPerSector, sizeof(buffer)    
; 153  :             ));
; 154  :         goto cleanUp;
; 155  :         }
; 156  : 
; 157  :     // Configuration is located in last sector of last EBOOT block
; 158  :     offset = IMAGE_XLDR_BOOTSEC_NAND_SIZE + IMAGE_EBOOT_BOOTSEC_NAND_SIZE;
; 159  :     
; 160  :     // Skip X-Loader & EBOOT code & bad blocks
; 161  :     // Note that we also check the last eboot block in order to ensure it is good
; 162  :     block  = 0;
; 163  :     count = 0;
; 164  :     while ((count < offset) && (block < flashInfo.dwNumBlocks))
; 165  :         {
; 166  :         if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) == 0)
; 167  :             {
; 168  :             count += flashInfo.dwBytesPerBlock;
; 169  :             }
; 170  :         block++;
; 171  :         }
; 172  : 
; 173  :     // We've incremented past the last eboot block in order to check it too
; 174  :     // Back up now, the previous block is the last one containing eboot and is good
; 175  :     block--;
; 176  : 
; 177  :     // Need to copy off the block contents to RAM (minus the config sector)
; 178  :     pEBOOT = (UINT8*)IMAGE_WINCE_CODE_CA;
; 179  :     length = flashInfo.dwBytesPerBlock - flashInfo.wDataBytesPerSector;
; 180  : 
; 181  :     memset((VOID*)pEBOOT, 0xFF, flashInfo.dwBytesPerBlock);
; 182  :     sector = block * flashInfo.wSectorsPerBlock;
; 183  :     offset = 0;
; 184  : 
; 185  :     while (offset < length) 
; 186  :     {
; 187  :         // When block read fail, there isn't what we can do more
; 188  :         if (!FMD_ReadSector(sector, pEBOOT + offset, &sectorInfo, 1)) {
; 189  :                 OALMSG(OAL_ERROR, (L"\r\nERROR: EBOOT!BLWriteBootCfg: "
; 190  :                     L"Failed read sector %d from flash\r\n", sector
; 191  :                 ));
; 192  :             goto cleanUp;
; 193  :             }
; 194  : 
; 195  :         // Move to next sector
; 196  :         sector++;
; 197  :         offset += flashInfo.wDataBytesPerSector;
; 198  :     }
; 199  : 
; 200  : 
; 201  :     //  Copy the config info into last sector of saved block in RAM
; 202  :     memcpy(pEBOOT + offset, pBootCfg, sizeof(BOOT_CFG)); 
; 203  : 
; 204  : 
; 205  :     // Erase block
; 206  :     if (!FMD_EraseBlock(block))
; 207  :         {
; 208  :         OALMSG(OAL_ERROR, (L"ERROR: EBOOT!BLWriteBootCfg: "
; 209  :             L"Flash block %d erase failed\r\n", block
; 210  :             ));
; 211  :         goto cleanUp;
; 212  :         }
; 213  : 
; 214  : 
; 215  :     // Write contents of the save block + config sector back to flash
; 216  :     pEBOOT = (UINT8*)IMAGE_WINCE_CODE_CA;
; 217  :     length = flashInfo.dwBytesPerBlock;
; 218  : 
; 219  :     sector = block * flashInfo.wSectorsPerBlock;
; 220  :     offset = 0;
; 221  :     while (offset < length)
; 222  :     {
; 223  :         // Prepare sector info
; 224  :         memset(&sectorInfo, 0xFF, sizeof(sectorInfo));
; 225  :         sectorInfo.bOEMReserved &= ~(OEM_BLOCK_READONLY|OEM_BLOCK_RESERVED);
; 226  :         sectorInfo.dwReserved1 = 0;
; 227  :         sectorInfo.wReserved2 = 0;
; 228  : 
; 229  :         // Write sector        
; 230  :         if (!FMD_WriteSector(sector, pEBOOT + offset, &sectorInfo, 1))
; 231  :             {
; 232  :             OALMSG(OAL_ERROR, (L"ERROR: EBOOT!BLWriteBootCfg: "
; 233  :                 L"Flash sector %d write failed\r\n", sector
; 234  :                 ));
; 235  :             goto cleanUp;
; 236  :             }
; 237  : 
; 238  :         // Move to next sector
; 239  :         sector++;
; 240  :         offset += flashInfo.wDataBytesPerSector;
; 241  :     }
; 242  : 
; 243  :     // Done    
; 244  :     rc = TRUE;
; 245  : 
; 246  : cleanUp:
; 247  :     if (hFMD != NULL) FMD_Deinit(hFMD);
; 248  : #else
; 249  :     UNREFERENCED_PARAMETER(pBootCfg);
; 250  : #endif
; 251  :     return rc;

  00000	e3a00000	 mov         r0, #0

; 252  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46822|

			 ENDP  ; |BLWriteBootCfg|

	EXPORT	|BLReserveBootBlocks|

  00000			 AREA	 |.pdata|, PDATA
|$T46833| DCD	|$LN5@BLReserveB|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLReserveBootBlocks| PROC

; 257  : {

  00000		 |$LN5@BLReserveB|
  00000		 |$M46830|

; 258  : #ifndef BSP_NO_NAND_IN_SDBOOT
; 259  :     BOOL rc = FALSE;
; 260  :     HANDLE hFMD;
; 261  :     PCI_REG_INFO regInfo;
; 262  :     FlashInfo flashInfo;
; 263  :     UINT32 size;
; 264  :     BLOCK_ID firstblock, lastblock;
; 265  :     //UINT32 status;
; 266  :     
; 267  :     UNREFERENCED_PARAMETER(pBootCfg);
; 268  : 
; 269  :     // Automatically mark the bootloader blocks as read-only/reserved
; 270  :     regInfo.MemBase.Reg[0] = g_ulFlashBase;
; 271  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 272  :     if (hFMD == NULL)
; 273  : 	{
; 274  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_Init call failed!\r\n"));
; 275  :         goto cleanUp;
; 276  : 	}
; 277  : 
; 278  :     // Get flash info
; 279  :     if (!FMD_GetInfo(&flashInfo))
; 280  : 	{
; 281  :         OALMSG(OAL_ERROR, (L"ERROR: FMD_GetInfo call failed!\r\n"));
; 282  :         goto cleanUp;
; 283  : 	}
; 284  : 
; 285  :     //  Loop thru the bootloader blocks to ensure they are marked reserved
; 286  :     firstblock = 0;
; 287  :     size = IMAGE_BOOTLOADER_NAND_SIZE;
; 288  :     lastblock = ((size -1) / flashInfo.dwBytesPerBlock) + 1;
; 289  : 	OALLog(L"IMAGE_BOOTLOADER_NAND_SIZE = 0x%x\r\n", IMAGE_BOOTLOADER_NAND_SIZE);
; 290  : 	OALLog(L"dwBytesPerBlock = 0x%x\r\n", flashInfo.dwBytesPerBlock);
; 291  :     OALLog(L"Checking bootloader blocks are marked as reserved (Num = %d)\r\n", lastblock-firstblock);
; 292  : 
; 293  :     while (firstblock < lastblock)
; 294  : 	{
; 295  : 
; 296  :         // If block is bad, we have to offset it
; 297  :         status = FMD_GetBlockStatus(firstblock);
; 298  : 
; 299  :         // Skip bad blocks
; 300  :         if ((status & BLOCK_STATUS_BAD) != 0) 
; 301  :             {
; 302  :             OALLog(L" Skip bad block %d\r\n", firstblock);
; 303  :             // blocks marked bad would not have been written either, so don't include this 
; 304  :             // in the count of blocks that are reserved.
; 305  :             firstblock++;
; 306  :             lastblock++;
; 307  :             continue;
; 308  :             }
; 309  : 
; 310  :         // Skip already reserved blocks
; 311  :         if ((status & BLOCK_STATUS_RESERVED) != 0) 
; 312  :             {
; 313  :             firstblock++;
; 314  :             continue;
; 315  :             }
; 316  : 
; 317  :         // Mark block as read-only & reserved
; 318  :         if (!FMD_SetBlockStatus(firstblock, BLOCK_STATUS_READONLY|BLOCK_STATUS_RESERVED)) 
; 319  :             {
; 320  :             OALLog(L" Oops, can't mark block %d - as reserved\r\n", firstblock);
; 321  :             }
; 322  : 
; 323  :         firstblock++;
; 324  :         OALLog(L".");
; 325  : 	}
; 326  : 
; 327  :     // Done    
; 328  :     rc = TRUE;
; 329  : 
; 330  :     OALLog(L"\r\n");
; 331  : 
; 332  : cleanUp:
; 333  :     if (hFMD != NULL) FMD_Deinit(hFMD);
; 334  :     return rc;
; 335  : #else
; 336  :     UNREFERENCED_PARAMETER(pBootCfg);
; 337  :     // Nothing to do...
; 338  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 339  : 
; 340  : #endif
; 341  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46831|

			 ENDP  ; |BLReserveBootBlocks|

	EXPORT	|BLShowLogo|
	IMPORT	|ShowSDLogo|

  00000			 AREA	 |.pdata|, PDATA
|$T46842| DCD	|$LN5@BLShowLogo|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BLShowLogo| PROC

; 346  : {

  00000		 |$LN5@BLShowLogo|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46839|

; 347  : 	//  Show the bootloader splashscreen if present on the SDCard
; 348  : 	//if (!ShowSDLogo())			 //Ray 13-08-30 
; 349  : 	//{
; 350  : 		ShowSDLogo();

  00004	eb000000	 bl          ShowSDLogo

; 351  : 		//ShowLogo((UINT32)-1, 0);
; 352  :     //}  
; 353  : 	
; 354  : 	return TRUE;

  00008	e3a00001	 mov         r0, #1

; 355  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M46840|

			 ENDP  ; |BLShowLogo|

	END
