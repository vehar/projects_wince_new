; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\Z2170P\SRC\BOOTLOADER\XLDR\main.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|pTOC| [ DATA ]
	EXPORT	|dwOEMHighSecurity| [ DATA ]
	EXPORT	|dwEbootECCtype| [ DATA ]
	EXPORT	|g_ecctype| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|gCPU_family|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|g_ecctype| %	0x1

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|pTOC|	DCD	0xffffffff
|dwOEMHighSecurity| DCD 0x2
|dwEbootECCtype| DCD 0xffffffff
	EXPORT	|XLDRWriteHexString|
	IMPORT	|OEMWriteDebugByte|
; File c:\wince600\platform\z2170p\src\bootloader\xldr\main.c

  00000			 AREA	 |.pdata|, PDATA
|$T47848| DCD	|$LN10@XLDRWriteH|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XLDRWriteHexString| PROC

; 112  : {

  00000		 |$LN10@XLDRWriteH|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47845|
  00004	e1b04001	 movs        r4, r1
  00008	e1a05000	 mov         r5, r0

; 113  : 	while (len--) 

  0000c	0a000004	 beq         |$LN6@XLDRWriteH|
  00010		 |$LL2@XLDRWriteH|

; 114  : 	{
; 115  : 		OEMWriteDebugByte((UINT8)*string++);

  00010	e4d50001	 ldrb        r0, [r5], #1
  00014	e2444001	 sub         r4, r4, #1
  00018	eb000000	 bl          OEMWriteDebugByte
  0001c	e3540000	 cmp         r4, #0
  00020	1afffffa	 bne         |$LL2@XLDRWriteH|
  00024		 |$LN6@XLDRWriteH|

; 116  : 	}
; 117  : }

  00024	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M47846|

			 ENDP  ; |XLDRWriteHexString|

	EXPORT	|XLDRWriteCharString|

  00000			 AREA	 |.pdata|, PDATA
|$T47859| DCD	|$LN10@XLDRWriteC|
	DCD	0x40000b01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XLDRWriteCharString| PROC

; 126  : {

  00000		 |$LN10@XLDRWriteC|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M47856|
  00004	e1a04000	 mov         r4, r0

; 127  :     while (*string != '\0') OEMWriteDebugByte((UINT8)*string++);

  00008	e5d43000	 ldrb        r3, [r4]
  0000c	ea000002	 b           |$LN7@XLDRWriteC|
  00010		 |$LL2@XLDRWriteC|
  00010	e1a00003	 mov         r0, r3
  00014	eb000000	 bl          OEMWriteDebugByte
  00018	e5f43001	 ldrb        r3, [r4, #1]!
  0001c		 |$LN7@XLDRWriteC|
  0001c	e3530000	 cmp         r3, #0
  00020	1afffffa	 bne         |$LL2@XLDRWriteC|

; 128  : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$M47857|

			 ENDP  ; |XLDRWriteCharString|

	EXPORT	|XLDRReadCharMaxTime|
	IMPORT	|OEMReadDebugByte|

  00000			 AREA	 |.pdata|, PDATA
|$T47874| DCD	|$LN13@XLDRReadCh|
	DCD	0x40001201
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XLDRReadCharMaxTime| PROC

; 139  : {

  00000		 |$LN13@XLDRReadCh|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47871|
  00004	e1a06000	 mov         r6, r0

; 140  : 	INT c;
; 141  : 	UINT32 reads = num_sec * XLDR_READS_PER_SEC;

  00008	e0813081	 add         r3, r1, r1, lsl #1
  0000c	e0615983	 rsb         r5, r1, r3, lsl #19
  00010	e3a04000	 mov         r4, #0
  00014		 |$LL7@XLDRReadCh|

; 142  : 
; 143  : 	do
; 144  : 	{
; 145  : 	    c = OEMReadDebugByte();

  00014	eb000000	 bl          OEMReadDebugByte

; 146  :         if (c == OEM_DEBUG_READ_NODATA)

  00018	e3700001	 cmn         r0, #1
  0001c	1a000002	 bne         |$LN4@XLDRReadCh|

; 161  :             break;
; 162  :         }
; 163  : 
; 164  : 	}
; 165  : 	while (--reads);

  00020	e2555001	 subs        r5, r5, #1
  00024	1afffffa	 bne         |$LL7@XLDRReadCh|
  00028	ea000003	 b           |$LN5@XLDRReadCh|
  0002c		 |$LN4@XLDRReadCh|

; 147  :         {
; 148  :             /* continue to read */
; 149  : 			c=0;
; 150  :         }
; 151  :         else if (c == OEM_DEBUG_COM_ERROR) 

  0002c	e3700002	 cmn         r0, #2

; 152  :         {
; 153  : 			c=-1;

  00030	03e04000	 mvneq       r4, #0

; 154  :             break;
; 155  :         }
; 156  :         else
; 157  :         {
; 158  :             /* received one byte */
; 159  : 			*uc = (UINT8)c;
; 160  : 			c = 1;

  00034	13a04001	 movne       r4, #1
  00038	15c60000	 strneb      r0, [r6]
  0003c		 |$LN5@XLDRReadCh|

; 166  : 
; 167  : 	return (c);
; 168  : }

  0003c	e1a00004	 mov         r0, r4
  00040	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00044	e12fff1e	 bx          lr
  00048		 |$M47872|

			 ENDP  ; |XLDRReadCharMaxTime|

	EXPORT	|XLDRWriteChar|

  00000			 AREA	 |.pdata|, PDATA
|$T47882| DCD	|$LN5@XLDRWriteC@2|
	DCD	0x40000401
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |XLDRWriteChar| PROC

; 177  : {

  00000		 |$LN5@XLDRWriteC@2|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47879|

; 178  : 	OEMWriteDebugByte(c);

  00004	eb000000	 bl          OEMWriteDebugByte

; 179  : }

  00008	e49de004	 ldr         lr, [sp], #4
  0000c	e12fff1e	 bx          lr
  00010		 |$M47880|

			 ENDP  ; |XLDRWriteChar|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|XLDRPrintUint8|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T47916| DCD	|$LN25@XLDRPrintU|
	DCD	0xc0004602

  00000			 AREA	 |.xdata|, DATA
|$T47912| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T47912|

  00008		 |XLDRPrintUint8| PROC

; 188  : {

  00008		 |$LN25@XLDRPrintU|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd01c	 sub         sp, sp, #0x1C
  00010		 |$M47913|
  00010	e1a06002	 mov         r6, r2
  00014	e1b05001	 movs        r5, r1
  00018	e1a07000	 mov         r7, r0
  0001c	e59f30f8	 ldr         r3, [pc, #0xF8]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3018	 str         r3, [sp, #0x18]

; 189  : 	INT i, j;
; 190  : 	UINT8 msg_buff[24];
; 191  : 	UINT8 c;
; 192  : 	UINT32 n = 0;
; 193  : 
; 194  : 	while (n++ < num_of_times)

  00028	0a000036	 beq         |$LN21@XLDRPrintU|
  0002c	e3a02030	 mov         r2, #0x30
  00030	e3a01078	 mov         r1, #0x78
  00034	e28db000	 add         r11, sp, #0
  00038	e28de000	 add         lr, sp, #0
  0003c	e28d9000	 add         r9, sp, #0
  00040	e28da000	 add         r10, sp, #0
  00044	e28d8000	 add         r8, sp, #0
  00048	e28d4000	 add         r4, sp, #0
  0004c		 |$LL9@XLDRPrintU|

; 195  : 	{
; 196  : 		j=0;
; 197  : 		msg_buff[j++]='0';

  0004c	e5cd2000	 strb        r2, [sp]

; 198  : 		msg_buff[j++]='x';

  00050	e5cd1001	 strb        r1, [sp, #1]
  00054	e3a02002	 mov         r2, #2
  00058	e3a01004	 mov         r1, #4
  0005c	e3a00000	 mov         r0, #0
  00060	e3a040f0	 mov         r4, #0xF0
  00064		 |$LL7@XLDRPrintU|

; 199  : 
; 200  : 		for(i=0; i<2; i++)
; 201  : 		{
; 202  : 			// grab a half byte and move it to the far right
; 203  : 		    c = (UINT8)(((ui8 & (0xf0 >> i*4)) >> 4*(1-i)));

  00064	e0073054	 and         r3, r7, r4, asr r0

; 204  : 			if ((0 <= c) && (c <= 9))
; 205  : 			{
; 206  : 				msg_buff[j++] = c + '0';
; 207  : 			}
; 208  : 			else
; 209  : 			{
; 210  : 				msg_buff[j++] = (c - 10) + 'A';

  00068	e2800004	 add         r0, r0, #4
  0006c	e1a03133	 mov         r3, r3, lsr r1
  00070	e2411004	 sub         r1, r1, #4
  00074	e20330ff	 and         r3, r3, #0xFF
  00078	e3530009	 cmp         r3, #9
  0007c	92833030	 addls       r3, r3, #0x30
  00080	97c2300b	 strlsb      r3, [r2, +r11]
  00084	82833037	 addhi       r3, r3, #0x37
  00088	87c2300e	 strhib      r3, [r2, +lr]
  0008c	e2822001	 add         r2, r2, #1
  00090	e3710004	 cmn         r1, #4
  00094	cafffff2	 bgt         |$LL7@XLDRPrintU|

; 211  : 			}
; 212  : 		}
; 213  : 
; 214  : 		if (end_cr_lf)

  00098	e3560000	 cmp         r6, #0

; 215  : 		{
; 216  : 			msg_buff[j++]='\r';

  0009c	13a0300d	 movne       r3, #0xD
  000a0	17c23009	 strneb      r3, [r2, +r9]
  000a4	12823001	 addne       r3, r2, #1

; 217  : 			msg_buff[j++]='\n';

  000a8	13a0200a	 movne       r2, #0xA
  000ac	17c3200a	 strneb      r2, [r3, +r10]
  000b0	12833001	 addne       r3, r3, #1

; 218  : 		}
; 219  : 		else
; 220  : 		{
; 221  : 			msg_buff[j++]=' '; /* end with a space */

  000b4	03a03020	 moveq       r3, #0x20
  000b8	07c23008	 streqb      r3, [r2, +r8]
  000bc	02823001	 addeq       r3, r2, #1

; 222  : 		}
; 223  : 		msg_buff[j++]='\0';

  000c0	e3a02000	 mov         r2, #0
  000c4	e28d4000	 add         r4, sp, #0
  000c8	e7c32004	 strb        r2, [r3, +r4]

; 224  : 
; 225  :         XLDRWriteCharString(&(msg_buff[0]));

  000cc	e5dd3000	 ldrb        r3, [sp]
  000d0	e28d4000	 add         r4, sp, #0
  000d4	e3530000	 cmp         r3, #0
  000d8	0a000005	 beq         |$LN12@XLDRPrintU|
  000dc		 |$LL13@XLDRPrintU|
  000dc	e1a00003	 mov         r0, r3
  000e0	eb000000	 bl          OEMWriteDebugByte
  000e4	e5f43001	 ldrb        r3, [r4, #1]!
  000e8	e3530000	 cmp         r3, #0
  000ec	1afffffa	 bne         |$LL13@XLDRPrintU|
  000f0	e28de000	 add         lr, sp, #0
  000f4		 |$LN12@XLDRPrintU|
  000f4	e2555001	 subs        r5, r5, #1
  000f8	e28d4000	 add         r4, sp, #0
  000fc	e3a02030	 mov         r2, #0x30
  00100	e3a01078	 mov         r1, #0x78
  00104	1affffd0	 bne         |$LL9@XLDRPrintU|
  00108		 |$LN21@XLDRPrintU|

; 188  : {

  00108	e59d0018	 ldr         r0, [sp, #0x18]
  0010c	eb000000	 bl          __security_check_cookie

; 226  : 	}
; 227  : }

  00110	e28dd01c	 add         sp, sp, #0x1C
  00114	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00118	e12fff1e	 bx          lr
  0011c		 |$LN26@XLDRPrintU|
  0011c		 |$LN27@XLDRPrintU|
  0011c	00000000	 DCD         |__security_cookie|
  00120		 |$M47914|

			 ENDP  ; |XLDRPrintUint8|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|XLDRPrintUlong|

  00000			 AREA	 |.pdata|, PDATA
|$T47952| DCD	|$LN26@XLDRPrintU@2|
	DCD	0xc0004602

  00000			 AREA	 |.xdata|, DATA
|$T47948| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T47948|

  00008		 |XLDRPrintUlong| PROC

; 236  : {

  00008		 |$LN26@XLDRPrintU@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd01c	 sub         sp, sp, #0x1C
  00010		 |$M47949|
  00010	e1a06002	 mov         r6, r2
  00014	e1b05001	 movs        r5, r1
  00018	e1a08000	 mov         r8, r0
  0001c	e59f30f8	 ldr         r3, [pc, #0xF8]
  00020	e5933000	 ldr         r3, [r3]
  00024	e58d3018	 str         r3, [sp, #0x18]

; 237  : 	INT i, j;
; 238  : 	UINT32 n;
; 239  : 	UINT8 msg_buff[24];
; 240  : 	UINT8 c;
; 241  : 
; 242  : 	n = 0;
; 243  : 	while (n++ < num_of_times)

  00028	0a000036	 beq         |$LN21@XLDRPrintU@2|
  0002c	e3a02030	 mov         r2, #0x30
  00030	e3a01078	 mov         r1, #0x78
  00034	e28db000	 add         r11, sp, #0
  00038	e28d4000	 add         r4, sp, #0
  0003c	e28d9000	 add         r9, sp, #0
  00040	e28da000	 add         r10, sp, #0
  00044	e28d7000	 add         r7, sp, #0
  00048		 |$LL9@XLDRPrintU@2|

; 244  : 	{
; 245  : 		j=0;
; 246  : 		msg_buff[j++]='0';
; 247  : 		msg_buff[j++]='x';

  00048	e5cd1001	 strb        r1, [sp, #1]
  0004c	e3a01002	 mov         r1, #2
  00050	e5cd2000	 strb        r2, [sp]

; 248  : 
; 249  : 		for(i=0; i<8; i++)

  00054	e3a0e000	 mov         lr, #0
  00058	e3a00000	 mov         r0, #0
  0005c	e3a0720f	 mov         r7, #0xF, 4
  00060		 |$LL7@XLDRPrintU@2|

; 250  : 		{
; 251  : 			// get a half byte and move it to the far right
; 252  : 		    c = (UINT8)(((ulong_to_write & (0xf0000000 >> i*4)) >> 4*(7-i)));

  00060	e26e3007	 rsb         r3, lr, #7
  00064	e0082037	 and         r2, r8, r7, lsr r0
  00068	e1a03103	 mov         r3, r3, lsl #2
  0006c	e1a03332	 mov         r3, r2, lsr r3

; 253  : 			if ((0 <= c) && (c <= 9))
; 254  : 			{
; 255  : 				msg_buff[j++] = c + '0';
; 256  : 			}
; 257  : 			else
; 258  : 			{
; 259  : 				msg_buff[j++] = (c - 10) + 'A';

  00070	e2800004	 add         r0, r0, #4
  00074	e20330ff	 and         r3, r3, #0xFF
  00078	e3530009	 cmp         r3, #9
  0007c	92833030	 addls       r3, r3, #0x30
  00080	97c1300b	 strlsb      r3, [r1, +r11]
  00084	82833037	 addhi       r3, r3, #0x37
  00088	87c13004	 strhib      r3, [r1, +r4]
  0008c	e2811001	 add         r1, r1, #1
  00090	e3500020	 cmp         r0, #0x20
  00094	e28ee001	 add         lr, lr, #1
  00098	bafffff0	 blt         |$LL7@XLDRPrintU@2|

; 260  : 			}
; 261  : 		}
; 262  : 
; 263  : 		if (end_cr_lf)

  0009c	e3560000	 cmp         r6, #0

; 264  : 		{
; 265  : 			msg_buff[j++]='\r';

  000a0	13a0300d	 movne       r3, #0xD
  000a4	17c13009	 strneb      r3, [r1, +r9]
  000a8	12813001	 addne       r3, r1, #1

; 266  : 			msg_buff[j++]='\n';

  000ac	13a0200a	 movne       r2, #0xA
  000b0	17c3200a	 strneb      r2, [r3, +r10]
  000b4	12833001	 addne       r3, r3, #1

; 267  : 		}
; 268  : 		else
; 269  : 		{
; 270  : 			msg_buff[j++]=' '; /* end with a space */

  000b8	03a03020	 moveq       r3, #0x20
  000bc	e28d7000	 add         r7, sp, #0
  000c0	07c13007	 streqb      r3, [r1, +r7]
  000c4	02813001	 addeq       r3, r1, #1

; 271  : 		}
; 272  : 		msg_buff[j++]='\0';

  000c8	e3a01000	 mov         r1, #0
  000cc	e28d2000	 add         r2, sp, #0
  000d0	e7c31002	 strb        r1, [r3, +r2]

; 273  : 
; 274  :         XLDRWriteCharString(&(msg_buff[0]));

  000d4	e5dd3000	 ldrb        r3, [sp]
  000d8	e28d4000	 add         r4, sp, #0
  000dc	ea000002	 b           |$LN23@XLDRPrintU@2|
  000e0		 |$LL13@XLDRPrintU@2|
  000e0	e1a00003	 mov         r0, r3
  000e4	eb000000	 bl          OEMWriteDebugByte
  000e8	e5f43001	 ldrb        r3, [r4, #1]!
  000ec		 |$LN23@XLDRPrintU@2|
  000ec	e3530000	 cmp         r3, #0
  000f0	1afffffa	 bne         |$LL13@XLDRPrintU@2|
  000f4	e2555001	 subs        r5, r5, #1
  000f8	e28d4000	 add         r4, sp, #0
  000fc	e3a02030	 mov         r2, #0x30
  00100	e3a01078	 mov         r1, #0x78
  00104	1affffcf	 bne         |$LL9@XLDRPrintU@2|
  00108		 |$LN21@XLDRPrintU@2|

; 236  : {

  00108	e59d0018	 ldr         r0, [sp, #0x18]
  0010c	eb000000	 bl          __security_check_cookie

; 275  : 	}
; 276  : }

  00110	e28dd01c	 add         sp, sp, #0x1C
  00114	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00118	e12fff1e	 bx          lr
  0011c		 |$LN27@XLDRPrintU@2|
  0011c		 |$LN28@XLDRPrintU@2|
  0011c	00000000	 DCD         |__security_cookie|
  00120		 |$M47950|

			 ENDP  ; |XLDRPrintUlong|

	EXPORT	|BSPGpioInit|
	IMPORT	|BSPInsertGpioDevice|
	IMPORT	|Omap_Gpio|

  00000			 AREA	 |.pdata|, PDATA
|$T47962| DCD	|$LN5@BSPGpioIni|
	DCD	0x40000801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BSPGpioInit| PROC

; 280  : {

  00000		 |$LN5@BSPGpioIni|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47959|

; 281  :    BSPInsertGpioDevice(0,&Omap_Gpio,NULL);

  00004	e59f1010	 ldr         r1, [pc, #0x10]
  00008	e3a02000	 mov         r2, #0
  0000c	e3a00000	 mov         r0, #0
  00010	eb000000	 bl          BSPInsertGpioDevice

; 282  : }

  00014	e49de004	 ldr         lr, [sp], #4
  00018	e12fff1e	 bx          lr
  0001c		 |$LN6@BSPGpioIni|
  0001c		 |$LN7@BSPGpioIni|
  0001c	00000000	 DCD         |Omap_Gpio|
  00020		 |$M47960|

			 ENDP  ; |BSPGpioInit|

	EXPORT	|OALPAtoVA|

  00000			 AREA	 |.pdata|, PDATA
|$T47974| DCD	|$LN5@OALPAtoVA|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALPAtoVA| PROC

; 731  : {

  00000		 |$LN5@OALPAtoVA|
  00000		 |$M47971|

; 732  :     UNREFERENCED_PARAMETER(cached);
; 733  :     return (VOID*)address;
; 734  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M47972|

			 ENDP  ; |OALPAtoVA|

	EXPORT	|OALVAtoPA|

  00000			 AREA	 |.pdata|, PDATA
|$T47984| DCD	|$LN5@OALVAtoPA|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALVAtoPA| PROC

; 742  : {

  00000		 |$LN5@OALVAtoPA|
  00000		 |$M47981|

; 743  :     return (UINT32)pVA;
; 744  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M47982|

			 ENDP  ; |OALVAtoPA|


  00000			 AREA	 |.pdata|, PDATA
|$T48011| DCD	|$LN23@SetupCopyS|
	DCD	0x40002801
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetupCopySection| PROC

; 757  : {

  00000		 |$LN23@SetupCopyS|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M48008|
  00004	e1a01000	 mov         r1, r0

; 758  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 759  :     UINT32 loop, count;
; 760  :     COPYentry *pCopyEntry;
; 761  :     UINT8 *pSrc, *pDst;
; 762  : 
; 763  :     if (pTableOfContents == (ROMHDR *const) -1) goto cleanUp;

  0000c	e3710001	 cmn         r1, #1
  00010	0a000020	 beq         |$cleanUp$47749|

; 764  : 
; 765  :     for (loop = 0; loop < pTableOfContents->ulCopyEntries; loop++)

  00014	e5913020	 ldr         r3, [r1, #0x20]
  00018	e3a0e000	 mov         lr, #0
  0001c	e3530000	 cmp         r3, #0
  00020	9a00001b	 bls         |$LN5@SetupCopyS|
  00024	e3a04000	 mov         r4, #0
  00028	e3a07000	 mov         r7, #0
  0002c		 |$LL7@SetupCopyS|
  0002c	e5913024	 ldr         r3, [r1, #0x24]
  00030	e0845003	 add         r5, r4, r3

; 766  :         {
; 767  :         pCopyEntry = (COPYentry *)(pTableOfContents->ulCopyOffset + loop*sizeof(COPYentry));
; 768  : 
; 769  :         count = pCopyEntry->ulCopyLen;

  00034	e5953008	 ldr         r3, [r5, #8]

; 770  :         pDst = (UINT8*)pCopyEntry->ulDest;

  00038	e5950004	 ldr         r0, [r5, #4]

; 771  :         pSrc = (UINT8*)pCopyEntry->ulSource;

  0003c	e5952000	 ldr         r2, [r5]
  00040	e1b06003	 movs        r6, r3

; 772  :         while (count-- > 0)

  00044	0a000003	 beq         |$LN14@SetupCopyS|
  00048		 |$LL4@SetupCopyS|

; 773  :             *pDst++ = *pSrc++;

  00048	e4d23001	 ldrb        r3, [r2], #1
  0004c	e2566001	 subs        r6, r6, #1
  00050	e4c03001	 strb        r3, [r0], #1
  00054	1afffffb	 bne         |$LL4@SetupCopyS|
  00058		 |$LN14@SetupCopyS|

; 774  :         count = pCopyEntry->ulDestLen - pCopyEntry->ulCopyLen;

  00058	e595200c	 ldr         r2, [r5, #0xC]
  0005c	e5953008	 ldr         r3, [r5, #8]
  00060	e0523003	 subs        r3, r2, r3

; 775  :         while (count-- > 0)

  00064	0a000005	 beq         |$LN2@SetupCopyS|
  00068	e3530000	 cmp         r3, #0
  0006c	0a000003	 beq         |$LN2@SetupCopyS|

; 774  :         count = pCopyEntry->ulDestLen - pCopyEntry->ulCopyLen;

  00070	e0803003	 add         r3, r0, r3
  00074		 |$LN19@SetupCopyS|
  00074	e4c07001	 strb        r7, [r0], #1
  00078	e1500003	 cmp         r0, r3
  0007c	1afffffc	 bne         |$LN19@SetupCopyS|
  00080		 |$LN2@SetupCopyS|

; 764  : 
; 765  :     for (loop = 0; loop < pTableOfContents->ulCopyEntries; loop++)

  00080	e5913020	 ldr         r3, [r1, #0x20]
  00084	e28ee001	 add         lr, lr, #1
  00088	e2844010	 add         r4, r4, #0x10
  0008c	e15e0003	 cmp         lr, r3
  00090	3affffe5	 bcc         |$LL7@SetupCopyS|
  00094		 |$LN5@SetupCopyS|

; 776  :             *pDst++ = 0;
; 777  :         }
; 778  : 
; 779  :     rc = TRUE;

  00094	e3a00001	 mov         r0, #1
  00098		 |$cleanUp$47749|

; 780  : 
; 781  : cleanUp:
; 782  :     return rc;
; 783  : }

  00098	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$M48009|

			 ENDP  ; |SetupCopySection|

	EXPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T48018| DCD	|$LN5@NKDbgPrint|
	DCD	0x40000503
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NKDbgPrintfW| PROC

; 791  : {

  00000		 |$LN5@NKDbgPrint|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M48015|

; 792  :     //  Stubbed out to shrink XLDR binary size
; 793  :     UNREFERENCED_PARAMETER(pszFormat);
; 794  : }

  0000c	e89d6000	 ldmia       sp, {sp, lr}
  00010	e12fff1e	 bx          lr
  00014		 |$M48016|

			 ENDP  ; |NKDbgPrintfW|

	EXPORT	|NKvDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T48025| DCD	|$LN5@NKvDbgPrin|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |NKvDbgPrintfW| PROC

; 802  : {

  00000		 |$LN5@NKvDbgPrin|
  00000		 |$M48022|

; 803  :     //  Stubbed out to shrink XLDR binary size
; 804  :     UNREFERENCED_PARAMETER(pszFormat);
; 805  :     UNREFERENCED_PARAMETER(pArgList);
; 806  : 
; 807  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M48023|

			 ENDP  ; |NKvDbgPrintfW|

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|XLDRMain|
	EXPORT	|??_C@_1BC@MABDLOIF@?$AA?$AN?$AA?6?$AAH?$AAA?$AAL?$AAT?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@FNBIBCAH@?$AA?$AN?$AA?6?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@FAKMAHKG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAt?$AAe?$AAn?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@JCBNJGDH@?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AAr?$AAx?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@HEGKNIDF@?$AAp?$AAk?$AAt?$AAs?$AA?5?$AAr?$AAx?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@DCKOCMFB@?$AAa?$AAc?$AAk?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@CEPKECJN@?$AAn?$AAa?$AAk?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@DNEDGKLA@?$AAc?$AAa?$AAn?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@MBABNMMG@?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BK@BAIMCFMI@?$AAc?$AAh?$AAk?$AAs?$AAu?$AAm?$AA?5?$AAe?$AAr?$AAr?$AAs?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BE@KGIAHABA@?$AAd?$AAu?$AAp?$AA?5?$AAp?$AAk?$AAt?$AAs?$AA?5?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@MBOCIIDG@?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BO@KNPOGIOP@?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@IIHIGBCF@?$AA?$AN?$AA?6?$AAD?$AAN?$AAL?$AAD?$AA?5?$AAT?$AAI?$AAE?$AAV?$AAM?$AA3?$AA5?$AA3?$AA0?$AA?9?$AAn?$AAa?$AAn?$AAd?$AA?4?$AAr?$AAa?$AAw?$AA?5?$AAI?$AAm?$AAa?$AAg?$AAe?$AA?$AN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CO@MAFCCJBC@?$AA?$AN?$AA?6?$AAF?$AAM?$AAD?$AA_?$AAG?$AAe?$AAt?$AAI?$AAn?$AAf?$AAo?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@HOAHMIF@?$AA?$AN?$AA?6?$AAF?$AAM?$AAD?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CC@DJCPIFGO@?$AAV?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AA0?$AA?4?$AA0?$AA?4?$AA1?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|OEMDeinitDebugSerial|
	IMPORT	|XGetStats|
	IMPORT	|FMD_WriteSector|
	IMPORT	|FMD_EraseBlock|
	IMPORT	|FMD_GetBlockStatus|
	IMPORT	|FMD_Deinit|
	IMPORT	|XReceive|
	IMPORT	|FMD_GetInfo|
	IMPORT	|FMD_Init|
	IMPORT	|GPIOSetMode|
	IMPORT	|GPIOClrBit|
	IMPORT	|GPIOOpen|
	IMPORT	|GPIOInit|
	IMPORT	|OEMWriteDebugString|
	IMPORT	|OEMInitDebugSerial|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|BSPGetDebugUARTConfig|
	IMPORT	|PlatformSetup|
	IMPORT	|Get_CPUVersion|
	IMPORT	|EnableCache_GP|
	IMPORT	|OALLocalAllocInit|

  00001			 AREA	 |.bss|, NOINIT
|?allocationPool@?1??XLDRMain@@9@9| % 0x200		; `XLDRMain'::`2'::allocationPool
|?allocationPool@?1??XLDRMain@@9@9| % 0x200		; `XLDRMain'::`2'::allocationPool

  00000			 AREA	 |.pdata|, PDATA
|$T48109| DCD	|$LN81@XLDRMain|
	DCD	0xc0012d02

  00000			 AREA	 |.xdata|, DATA
|$T48105| DCD	0xffffffd8

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@MABDLOIF@?$AA?$AN?$AA?6?$AAH?$AAA?$AAL?$AAT?$AA?$AN?$AA?6?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "H", 0x0, "A", 0x0, "L", 0x0, "T", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@FNBIBCAH@?$AA?$AN?$AA?6?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "R", 0x0, "e", 0x0, "c", 0x0, "e", 0x0, "i"
	DCB	0x0, "v", 0x0, "e", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "t"
	DCB	0x0, "u", 0x0, "r", 0x0, "n", 0x0, " ", 0x0, "c", 0x0, "o"
	DCB	0x0, "d", 0x0, "e", 0x0, " ", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@FAKMAHKG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAt?$AAe?$AAn?$AA?5?$AA?$AA@| DCB "b"
	DCB	0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k", 0x0, "s", 0x0, " "
	DCB	0x0, "w", 0x0, "r", 0x0, "i", 0x0, "t", 0x0, "t", 0x0, "e"
	DCB	0x0, "n", 0x0, " ", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@JCBNJGDH@?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AAr?$AAx?$AA?5?$AA?$AA@| DCB "b"
	DCB	0x0, "y", 0x0, "t", 0x0, "e", 0x0, "s", 0x0, " ", 0x0, "r"
	DCB	0x0, "x", 0x0, " ", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@HEGKNIDF@?$AAp?$AAk?$AAt?$AAs?$AA?5?$AAr?$AAx?$AA?5?$AA?$AA@| DCB "p"
	DCB	0x0, "k", 0x0, "t", 0x0, "s", 0x0, " ", 0x0, "r", 0x0, "x"
	DCB	0x0, " ", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@DCKOCMFB@?$AAa?$AAc?$AAk?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| DCB "a"
	DCB	0x0, "c", 0x0, "k", 0x0, "s", 0x0, " ", 0x0, "s", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, " ", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@CEPKECJN@?$AAn?$AAa?$AAk?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| DCB "n"
	DCB	0x0, "a", 0x0, "k", 0x0, "s", 0x0, " ", 0x0, "s", 0x0, "e"
	DCB	0x0, "n", 0x0, "t", 0x0, " ", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@DNEDGKLA@?$AAc?$AAa?$AAn?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| DCB "c"
	DCB	0x0, "a", 0x0, "n", 0x0, " ", 0x0, "s", 0x0, "e", 0x0, "n"
	DCB	0x0, "t", 0x0, " ", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@MBABNMMG@?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@| DCB "o"
	DCB	0x0, "t", 0x0, "h", 0x0, "e", 0x0, "r", 0x0, "s", 0x0, " "
	DCB	0x0, "s", 0x0, "e", 0x0, "n", 0x0, "t", 0x0, " ", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BK@BAIMCFMI@?$AAc?$AAh?$AAk?$AAs?$AAu?$AAm?$AA?5?$AAe?$AAr?$AAr?$AAs?$AA?5?$AA?$AA@| DCB "c"
	DCB	0x0, "h", 0x0, "k", 0x0, "s", 0x0, "u", 0x0, "m", 0x0, " "
	DCB	0x0, "e", 0x0, "r", 0x0, "r", 0x0, "s", 0x0, " ", 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BE@KGIAHABA@?$AAd?$AAu?$AAp?$AA?5?$AAp?$AAk?$AAt?$AAs?$AA?5?$AA?$AA@| DCB "d"
	DCB	0x0, "u", 0x0, "p", 0x0, " ", 0x0, "p", 0x0, "k", 0x0, "t"
	DCB	0x0, "s", 0x0, " ", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@MBOCIIDG@?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AN?$AA?6?$AA?$AA@| DCB "E"
	DCB	0x0, "r", 0x0, "a", 0x0, "s", 0x0, "e", 0x0, " ", 0x0, "F"
	DCB	0x0, "A", 0x0, "I", 0x0, "L", 0x0, "E", 0x0, "D", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@KNPOGIOP@?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AN?$AA?6?$AA?$AA@| DCB "W"
	DCB	0x0, "r", 0x0, "i", 0x0, "t", 0x0, "e", 0x0, " ", 0x0, "F"
	DCB	0x0, "A", 0x0, "I", 0x0, "L", 0x0, "E", 0x0, "D", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@IIHIGBCF@?$AA?$AN?$AA?6?$AAD?$AAN?$AAL?$AAD?$AA?5?$AAT?$AAI?$AAE?$AAV?$AAM?$AA3?$AA5?$AA3?$AA0?$AA?9?$AAn?$AAa?$AAn?$AAd?$AA?4?$AAr?$AAa?$AAw?$AA?5?$AAI?$AAm?$AAa?$AAg?$AAe?$AA?$AN@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "D", 0x0, "N", 0x0, "L", 0x0, "D", 0x0, " "
	DCB	0x0, "T", 0x0, "I", 0x0, "E", 0x0, "V", 0x0, "M", 0x0, "3"
	DCB	0x0, "5", 0x0, "3", 0x0, "0", 0x0, "-", 0x0, "n", 0x0, "a"
	DCB	0x0, "n", 0x0, "d", 0x0, ".", 0x0, "r", 0x0, "a", 0x0, "w"
	DCB	0x0, " ", 0x0, "I", 0x0, "m", 0x0, "a", 0x0, "g", 0x0, "e"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CO@MAFCCJBC@?$AA?$AN?$AA?6?$AAF?$AAM?$AAD?$AA_?$AAG?$AAe?$AAt?$AAI?$AAn?$AAf?$AAo?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "F", 0x0, "M", 0x0, "D", 0x0, "_", 0x0, "G"
	DCB	0x0, "e", 0x0, "t", 0x0, "I", 0x0, "n", 0x0, "f", 0x0, "o"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e"
	DCB	0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CI@HOAHMIF@?$AA?$AN?$AA?6?$AAF?$AAM?$AAD?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB 0xd
	DCB	0x0, 0xa, 0x0, "F", 0x0, "M", 0x0, "D", 0x0, "_", 0x0, "I"
	DCB	0x0, "n", 0x0, "i", 0x0, "t", 0x0, " ", 0x0, "f", 0x0, "a"
	DCB	0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CC@DJCPIFGO@?$AAV?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AA0?$AA?4?$AA0?$AA?4?$AA1?$AA?$AN?$AA?6?$AA?$AA@| DCB "V"
	DCB	0x0, "e", 0x0, "r", 0x0, "s", 0x0, "i", 0x0, "o", 0x0, "n"
	DCB	0x0, ":", 0x0, " ", 0x0, "0", 0x0, ".", 0x0, "0", 0x0, "."
	DCB	0x0, "1", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T48105|

  00008		 |XLDRMain| PROC

; 289  : {

  00008		 |$LN81@XLDRMain|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24ddff3	 sub         sp, sp, #0xF3, 30
  00010		 |$M48106|
  00010	e59f34a0	 ldr         r3, [pc, #0x4A0]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d33c8	 str         r3, [sp, #0x3C8]

; 290  : #ifdef FMD_NAND // UART, SD, NAND
; 291  :     HANDLE hFMD;
; 292  :     PCI_REG_INFO regInfo;
; 293  :     FlashInfo flashInfo;
; 294  :     UINT32 size;  
; 295  : #endif
; 296  : 
; 297  : #ifdef MEMORY_BOOT // NAND
; 298  :     UINT32 count;
; 299  :     SECTOR_ADDR ix;
; 300  : #endif
; 301  : 
; 302  : #ifdef UART_BOOT // UART
; 303  :     UINT32 dnld_size, offset;
; 304  : 
; 305  :     INT image_block_cnt, nand_blocks_to_write;
; 306  :     INT xret;
; 307  : 
; 308  :     INT xblock_cnt = 0;
; 309  :     INT xack_cnt = 0;
; 310  :     INT xnak_cnt = 0;
; 311  :     INT xcan_cnt = 0;
; 312  :     INT xothers_cnt = 0;
; 313  : 
; 314  :     INT checksum_error_cnt = 0;
; 315  :     INT dup_pkt_cnt = 0;
; 316  : #endif
; 317  : 
; 318  :     SECTOR_ADDR sector;
; 319  :     BLOCK_ID block;
; 320  :     UINT8 *pImage;
; 321  :     SectorInfo sectorInfo;
; 322  : 
; 323  :     HANDLE hGpio;
; 324  :     static UCHAR allocationPool[512];
; 325  :     LPCWSTR ProcessorName   = L"3530";
; 326  : 
; 327  :     // Setup global variables
; 328  :     if (!SetupCopySection(pTOC))

  0001c	e59fa490	 ldr         r10, [pc, #0x490]
  00020	e3a05000	 mov         r5, #0
  00024	e3a06000	 mov         r6, #0
  00028	e59ae000	 ldr         lr, [r10]
  0002c	e3a03000	 mov         r3, #0
  00030	e3a02000	 mov         r2, #0
  00034	e3a01000	 mov         r1, #0
  00038	e3a00000	 mov         r0, #0
  0003c	e3a04000	 mov         r4, #0
  00040	e37e0001	 cmn         lr, #1
  00044	e58d502c	 str         r5, [sp, #0x2C]
  00048	e58d6024	 str         r6, [sp, #0x24]
  0004c	e58d3020	 str         r3, [sp, #0x20]
  00050	e58d2028	 str         r2, [sp, #0x28]
  00054	e58d1014	 str         r1, [sp, #0x14]
  00058	e58d0018	 str         r0, [sp, #0x18]
  0005c	e58d401c	 str         r4, [sp, #0x1C]
  00060	0a000044	 beq         |$cleanUp$47656|
  00064	e59e3020	 ldr         r3, [lr, #0x20]
  00068	e3a04000	 mov         r4, #0
  0006c	e3530000	 cmp         r3, #0
  00070	9a00001b	 bls         |$LN37@XLDRMain|
  00074	e3a05000	 mov         r5, #0
  00078	e3a07000	 mov         r7, #0
  0007c		 |$LL39@XLDRMain|
  0007c	e59e3024	 ldr         r3, [lr, #0x24]
  00080	e0830005	 add         r0, r3, r5
  00084	e5903008	 ldr         r3, [r0, #8]
  00088	e5901004	 ldr         r1, [r0, #4]
  0008c	e5902000	 ldr         r2, [r0]
  00090	e1b06003	 movs        r6, r3
  00094	0a000003	 beq         |$LN57@XLDRMain|
  00098		 |$LL36@XLDRMain|
  00098	e4d23001	 ldrb        r3, [r2], #1
  0009c	e2566001	 subs        r6, r6, #1
  000a0	e4c13001	 strb        r3, [r1], #1
  000a4	1afffffb	 bne         |$LL36@XLDRMain|
  000a8		 |$LN57@XLDRMain|
  000a8	e590200c	 ldr         r2, [r0, #0xC]
  000ac	e5903008	 ldr         r3, [r0, #8]
  000b0	e0523003	 subs        r3, r2, r3
  000b4	0a000005	 beq         |$LN34@XLDRMain|
  000b8	e3530000	 cmp         r3, #0
  000bc	0a000003	 beq         |$LN34@XLDRMain|
  000c0	e0813003	 add         r3, r1, r3
  000c4		 |$LN72@XLDRMain|
  000c4	e4c17001	 strb        r7, [r1], #1
  000c8	e1510003	 cmp         r1, r3
  000cc	1afffffc	 bne         |$LN72@XLDRMain|
  000d0		 |$LN34@XLDRMain|
  000d0	e59e3020	 ldr         r3, [lr, #0x20]
  000d4	e2844001	 add         r4, r4, #1
  000d8	e2855010	 add         r5, r5, #0x10
  000dc	e1540003	 cmp         r4, r3
  000e0	3affffe5	 bcc         |$LL39@XLDRMain|
  000e4		 |$LN37@XLDRMain|

; 329  :         goto cleanUp;
; 330  : 
; 331  :     OALLocalAllocInit(allocationPool,sizeof(allocationPool));

  000e4	e59f63ac	 ldr         r6, [pc, #0x3AC]
  000e8	e3a01c02	 mov         r1, #2, 24
  000ec		 |$cleanUp$48038|
  000ec	e1a00006	 mov         r0, r6
  000f0	eb000000	 bl          OALLocalAllocInit

; 332  : 
; 333  : /*
; 334  :     //  Enable cache based on device type
; 335  :     if( dwOEMHighSecurity == OEM_HIGH_SECURITY_HS )
; 336  :     {
; 337  :         EnableCache_HS();
; 338  :     }
; 339  :     else
; 340  :     {
; 341  :         EnableCache_GP();
; 342  :     }
; 343  : */
; 344  :     EnableCache_GP();

  000f4	eb000000	 bl          EnableCache_GP

; 345  : 
; 346  :     gCPU_family = CPU_FAMILY(Get_CPUVersion());

  000f8	eb000000	 bl          Get_CPUVersion
  000fc	e59f23ac	 ldr         r2, [pc, #0x3AC]
  00100	e1a03800	 mov         r3, r0, lsl #16
  00104	e1a03c23	 mov         r3, r3, lsr #24
  00108	e5823000	 str         r3, [r2]

; 347  : 	
; 348  :     if( gCPU_family == CPU_FAMILY_DM37XX)
; 349  :     {
; 350  :         ProcessorName = L"37XX";
; 351  :     }
; 352  :     
; 353  :     PlatformSetup();

  0010c	eb000000	 bl          PlatformSetup

; 354  : 
; 355  :     // Initialize debug serial output
; 356  :     XLDRMSGINIT;

  00110	eb000000	 bl          BSPGetDebugUARTConfig
  00114	e5900000	 ldr         r0, [r0]
  00118	e3a01001	 mov         r1, #1
  0011c	eb000000	 bl          EnableDeviceClocks
  00120	eb000000	 bl          OEMInitDebugSerial

; 357  : 
; 358  :     // Print information...
; 359  : #ifdef FMD_ONENAND // X
; 360  : #ifdef MEMORY_BOOT
; 361  :     XLDRMSG(
; 362  :         TEXT("\r\nTexas Instruments Windows CE OneNAND X-Loader for EVM "));
; 363  :     XLDRMSG( (UINT16 *)ProcessorName);
; 364  :     XLDRMSG( 
; 365  :         TEXT("\r\n")
; 366  :         TEXT("Built ") TEXT(__DATE__) TEXT(" at ") TEXT(__TIME__) TEXT("\r\n")
; 367  :         );
; 368  : #endif
; 369  : #endif
; 370  : #ifdef FMD_NAND 
; 371  : #ifdef MEMORY_BOOT
; 372  :     XLDRMSG( TEXT("\r\nZEBEX Windows CE NAND X-Loader for Z-2170P - Brian"));    
; 373  :     XLDRMSG( TEXT("\r\n") TEXT("Built ") TEXT(__DATE__) TEXT(" at ") TEXT(__TIME__) TEXT(" ("));
; 374  : 	XLDRMSG( (UINT16 *)ProcessorName);
; 375  : 	XLDRMSG( TEXT(")\r\n"));
; 376  : #endif
; 377  : #endif
; 378  : 
; 379  : #ifdef MEMORY_BOOT // NAND
; 380  :     XLDRMSG( TEXT("Version: ") BSP_XLDR_NAND_VERSION_STRING TEXT("\r\n") );
; 381  : #else
; 382  : 	XLDRMSG( TEXT("Version: ") BSP_XLDR_SD_VERSION_STRING TEXT("\r\n") );

  00124	e59f0380	 ldr         r0, [pc, #0x380]
  00128	eb000000	 bl          OEMWriteDebugString

; 383  : #endif
; 384  :     GPIOInit();

  0012c	eb000000	 bl          GPIOInit

; 385  :     hGpio = GPIOOpen();

  00130	eb000000	 bl          GPIOOpen

; 386  : 
; 387  : //#ifdef BSP_Z2000
; 388  :     GPIOClrBit(hGpio,BL_EN_SET_GPIO);

  00134	e3a0103d	 mov         r1, #0x3D
  00138	e1a04000	 mov         r4, r0
  0013c	eb000000	 bl          GPIOClrBit

; 389  :     GPIOSetMode(hGpio,BL_EN_SET_GPIO,GPIO_DIR_OUTPUT);

  00140	e3a02000	 mov         r2, #0
  00144	e3a0103d	 mov         r1, #0x3D
  00148	e1a00004	 mov         r0, r4
  0014c	eb000000	 bl          GPIOSetMode

; 390  : //#endif
; 391  :     
; 392  : #ifdef FMD_ONENAND // X
; 393  :     // Open FMD to access ONENAND
; 394  :     regInfo.MemBase.Reg[0] = BSP_ONENAND_REGS_PA;
; 395  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 396  :     if (hFMD == NULL)
; 397  :     {
; 398  :         XLDRMSG(L"\r\nFMD_Init failed\r\n");
; 399  :         goto cleanUp;
; 400  :     }
; 401  : 
; 402  :     //  Set ONENAND XLDR bootsector size
; 403  :     size = IMAGE_XLDR_BOOTSEC_ONENAND_SIZE;
; 404  : #endif
; 405  : #ifdef FMD_NAND // UART, SD, NAND
; 406  :     // Open FMD to access NAND
; 407  :     regInfo.MemBase.Reg[0] = BSP_NAND_REGS_PA;

  00150	e3a03302	 mov         r3, #2, 6

; 408  :     hFMD = FMD_Init(NULL, &regInfo, NULL);

  00154	e3a02000	 mov         r2, #0
  00158	e28d1048	 add         r1, sp, #0x48
  0015c	e3a00000	 mov         r0, #0
  00160	e58d3358	 str         r3, [sp, #0x358]
  00164	eb000000	 bl          FMD_Init
  00168	e1b0b000	 movs        r11, r0

; 409  :     if (hFMD == NULL)

  0016c	1a000004	 bne         |$LN28@XLDRMain|

; 410  :     {
; 411  :         XLDRMSG(L"\r\nFMD_Init failed\r\n");

  00170	e59f0330	 ldr         r0, [pc, #0x330]
  00174		 |$LN78@XLDRMain|
  00174	eb000000	 bl          OEMWriteDebugString
  00178		 |$cleanUp$47656|

; 649  : 
; 650  : 	// Done.
; 651  : 	return;
; 652  : #endif  /* UART_DNLD_RAW_TO_NAND */
; 653  : #endif  /* UART_DNLD_EBOOT_TO_RAM || UART_DNLD_RAW_TO_NAND */
; 654  : 
; 655  : #ifdef UART_BOOT_READ_SECTOR
; 656  :     // Set address where to place data read
; 657  :     pImage = (UINT8*)IMAGE_STARTUP_IMAGE_PA;
; 658  : 
; 659  : 	sector = 0;
; 660  :     if (!FMD_ReadSector(sector, pImage, &sectorInfo, 1))
; 661  :     {
; 662  :         for(;;) XLDRMSG(L"read failed\r\n");
; 663  :     }            
; 664  : 
; 665  :     //print the first 16 bytes to debug port 
; 666  :     pImage = (UINT8*)IMAGE_STARTUP_IMAGE_PA;
; 667  : 
; 668  : 	for(;;)
; 669  : 	{
; 670  : 	    XLDRPrintUint8(sectorInfo.bOEMReserved, 1, 0);
; 671  : 	    XLDRPrintUint8(sectorInfo.bBadBlock, 1, 0);
; 672  : 
; 673  : 		for (ix = 0; ix<16; ix++)
; 674  : 		{
; 675  : 		    XLDRPrintUint8(*(pImage+ix), 1, 0);
; 676  : 		}
; 677  :    	    XLDRMSG(L"\r\n");
; 678  : 	}
; 679  : #endif /* UART_BOOT_READ_SECTOR */
; 680  : 
; 681  : #ifdef UART_BOOT_WRITE_SECTOR
; 682  : 
; 683  : 	if (!FMD_EraseBlock(0))
; 684  : 	{
; 685  : 		while(1) XLDRMSG(L"Erase FAILED\r\n");
; 686  : 	}
; 687  : 
; 688  : 	// Set address where to place image
; 689  :     pImage = (UINT8*)IMAGE_STARTUP_IMAGE_PA;
; 690  : 
; 691  : 	for (uc = 0; uc<16; uc++)
; 692  : 		*(pImage+uc) = uc+'A';
; 693  : 
; 694  : 	sector = 0;
; 695  : 
; 696  :    	memset(&sectorInfo, 0xFF, sizeof(sectorInfo));
; 697  :     sectorInfo.bOEMReserved &= ~(OEM_BLOCK_READONLY|OEM_BLOCK_RESERVED);
; 698  : 	sectorInfo.dwReserved1 = 0;
; 699  : 	sectorInfo.wReserved2 = 0;
; 700  :     
; 701  :     // Write 1 sector
; 702  :     if (!FMD_WriteSector(sector, pImage, &sectorInfo, 1))
; 703  : 	{
; 704  : 		while(1) XLDRMSG(L"Write FAILED\r\n");
; 705  : 		goto cleanUp;
; 706  : 	}
; 707  : 
; 708  : 	XLDRPrintUint8('z', 10000, 1);
; 709  : 	XLDRMSG(L"That many times printed\r\n");
; 710  : 
; 711  : 	// Wait for serial port
; 712  :     XLDRMSGDEINIT;
; 713  : 
; 714  : 	// Done.
; 715  : 	return;
; 716  : #endif /* UART_BOOT_WRITE_SECTOR */
; 717  : 
; 718  : #endif  /* UART_BOOT */
; 719  :     
; 720  : cleanUp:
; 721  :     XLDRMSG(L"\r\nHALT\r\n");

  00178	e59f0324	 ldr         r0, [pc, #0x324]
  0017c	eb000000	 bl          OEMWriteDebugString
  00180		 |$LL2@XLDRMain|

; 722  :     for(;;);

  00180	eafffffe	 b           |$LL2@XLDRMain|
  00184		 |$LN28@XLDRMain|

; 412  :         goto cleanUp;
; 413  :     }
; 414  : 
; 415  :     //  Set NAND XLDR bootsector size
; 416  :     size = IMAGE_XLDR_BOOTSEC_NAND_SIZE;
; 417  : #endif
; 418  : 
; 419  :     // Get flash info
; 420  :     if (!FMD_GetInfo(&flashInfo))

  00184	e28d0038	 add         r0, sp, #0x38
  00188	eb000000	 bl          FMD_GetInfo
  0018c	e3500000	 cmp         r0, #0

; 421  :     {
; 422  :         XLDRMSG(L"\r\nFMD_GetInfo failed\r\n");

  00190	059f0308	 ldreq       r0, [pc, #0x308]
  00194	0afffff6	 beq         |$LN78@XLDRMain|

; 423  :         goto cleanUp;
; 424  :     }
; 425  : 
; 426  : #ifdef MEMORY_BOOT
; 427  :     // Start from NAND start
; 428  :     block  = 0;
; 429  :     sector = 0;
; 430  : 
; 431  :     // First skip XLDR boot region.
; 432  : 
; 433  :     // NOTE - The bootrom will load the xldr from the first good block starting
; 434  :     // at zero.  If an uncorrectable ECC error is encountered it will try the next
; 435  :     // good block.  The last block attempted is the fourth physical block.  The first
; 436  :     // block is guaranteed good when shipped from the factory, for the first 1000
; 437  :     // erase/program cycles.
; 438  : 
; 439  :     // Our programming algorithm will place four copies of the xldr into the first
; 440  :     // four *good* blocks.  If one or more of the first four physical blocks is marked
; 441  :     // bad, the XLDR boot region will include the fifth physical block or beyond.  This
; 442  :     // would result in a wasted block containing a copy of the XLDR that will never be
; 443  :     // loaded by the bootrom, but it simplifies the flash management algorithms.
; 444  :     count = 0;
; 445  :     while (count < size)
; 446  : 	{
; 447  :         if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) == 0)
; 448  :             count += flashInfo.dwBytesPerBlock;
; 449  :         block++;
; 450  :         sector += flashInfo.wSectorsPerBlock;
; 451  : 	}
; 452  :     // get ECC type for EBOOT from FIXUP value
; 453  :     g_ecctype = (UCHAR)dwEbootECCtype;
; 454  : 	
; 455  :     FMD_Deinit(hFMD); 
; 456  :     hFMD = FMD_Init(NULL, &regInfo, NULL);
; 457  : 
; 458  :     // Set address where to place image
; 459  :     pImage = (UINT8*)IMAGE_STARTUP_IMAGE_PA;
; 460  : 
; 461  :     // Read image to memory
; 462  :     count = 0;
; 463  :     while ((count < IMAGE_STARTUP_IMAGE_SIZE) && (block < flashInfo.dwNumBlocks))
; 464  : 	{
; 465  :         // Skip bad blocks
; 466  :         if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) != 0)
; 467  :             {
; 468  :             block++;
; 469  :             sector += flashInfo.wSectorsPerBlock;
; 470  :             XLDRMSG(L"#");
; 471  :             continue;
; 472  :             }
; 473  : 
; 474  :         // Read sectors in block
; 475  :         ix = 0;
; 476  :         while ((ix++ < flashInfo.wSectorsPerBlock) &&
; 477  :                 (count < IMAGE_STARTUP_IMAGE_SIZE))
; 478  :             {
; 479  :             // If a read fails, there is nothing we can do about it
; 480  :             if (!FMD_ReadSector(sector, pImage, &sectorInfo, 1))
; 481  :                 {
; 482  :                 XLDRMSG(L"$");
; 483  :                 }
; 484  : 
; 485  :             // Move to next sector
; 486  :             sector++;
; 487  :             pImage += flashInfo.wDataBytesPerSector;
; 488  :             count += flashInfo.wDataBytesPerSector;
; 489  :             }
; 490  : 
; 491  :         XLDRMSG(L".");
; 492  : 
; 493  :         // Move to next block
; 494  :         block++;
; 495  : 	}
; 496  : 
; 497  :     XLDRMSG(L"\r\nJumping to bootloader\r\n");
; 498  : 
; 499  :     // Wait for serial port
; 500  :     XLDRMSGDEINIT;
; 501  : 
; 502  :     // Jump to image
; 503  :     JumpTo((VOID*)IMAGE_STARTUP_IMAGE_PA);
; 504  : #endif  /* MEMORY_BOOT */
; 505  : #ifdef UART_BOOT
; 506  : 
; 507  : #if defined(UART_DNLD_EBOOT_TO_RAM) || defined(UART_DNLD_RAW_TO_NAND)
; 508  : 
; 509  : #ifdef UART_DNLD_EBOOT_TO_RAM // X
; 510  :     XLDRMSG(L"\r\nDNLD EBOOTND.nb0 Image\r\n");
; 511  : #endif
; 512  : 
; 513  : #ifdef UART_DNLD_RAW_TO_NAND // UART
; 514  :     XLDRMSG(L"\r\nDNLD TIEVM3530-nand.raw Image\r\n");

  00198	e59f02fc	 ldr         r0, [pc, #0x2FC]
  0019c	eb000000	 bl          OEMWriteDebugString
  001a0	e3a03707	 mov         r3, #7, 14

; 515  : #endif
; 516  : 
; 517  :     // Set address where to place download image
; 518  :     pImage = (UINT8*)IMAGE_STARTUP_IMAGE_PA; // 0x87E00000
; 519  : 
; 520  : 	xret = XReceive(pImage, IMAGE_XLDR_BOOTSEC_NAND_SIZE+IMAGE_EBOOT_CODE_SIZE+IMAGE_BOOTLOADER_BITMAP_SIZE+8, &dnld_size);

  001a4	e3831008	 orr         r1, r3, #8
  001a8	e3e03d0f	 mvn         r3, #0xF, 26
  001ac	e1a08a83	 mov         r8, r3, lsl #21
  001b0	e1a00008	 mov         r0, r8
  001b4	e28d2030	 add         r2, sp, #0x30
  001b8	eb000000	 bl          XReceive
  001bc	e1b03000	 movs        r3, r0
  001c0	e58d3034	 str         r3, [sp, #0x34]

; 521  : 	if(xret < 0)

  001c4	4affffeb	 bmi         |$cleanUp$47656|

; 522  : 	{
; 523  : 		goto cleanUp;
; 524  : 	}
; 525  : 
; 526  : #ifdef UART_DNLD_EBOOT_TO_RAM // X
; 527  :     XLDRMSG(L"\r\nJumping to bootloader EBOOT\r\n");
; 528  : 
; 529  : 	// Wait for serial port
; 530  :     XLDRMSGDEINIT;
; 531  : 
; 532  : 	// Jump to image
; 533  : 	JumpTo((VOID*)IMAGE_STARTUP_IMAGE_PA);
; 534  : #endif  /* UART_DNLD_EBOOT_TO_RAM */
; 535  : 
; 536  : #ifdef UART_DNLD_RAW_TO_NAND
; 537  : 	// How many nand blocks to write
; 538  : 	if (dnld_size < flashInfo.dwBytesPerBlock)

  001c8	e59d2030	 ldr         r2, [sp, #0x30]
  001cc	e59d1040	 ldr         r1, [sp, #0x40]
  001d0	e1520001	 cmp         r2, r1

; 539  : 	{
; 540  : 		nand_blocks_to_write=0;
; 541  : 	}
; 542  : 	else

  001d4	3affffe7	 bcc         |$cleanUp$47656|

; 543  : 	{
; 544  : 		for(nand_blocks_to_write=0; nand_blocks_to_write <= NAND_MAX_BLOCKS_TO_WRITE; nand_blocks_to_write++)

  001d8	e3a05000	 mov         r5, #0
  001dc	e3a03000	 mov         r3, #0
  001e0		 |$LL23@XLDRMain|

; 545  : 		{
; 546  : 			if ((nand_blocks_to_write * flashInfo.dwBytesPerBlock) >= dnld_size)

  001e0	e1530002	 cmp         r3, r2
  001e4	2a000003	 bcs         |$LN54@XLDRMain|
  001e8	e2855001	 add         r5, r5, #1
  001ec	e355000f	 cmp         r5, #0xF
  001f0	e0833001	 add         r3, r3, r1
  001f4	dafffff9	 ble         |$LL23@XLDRMain|
  001f8		 |$LN54@XLDRMain|

; 547  : 			{
; 548  : 				break;
; 549  : 			}
; 550  : 		}
; 551  : 	}
; 552  : 
; 553  : 	if ((nand_blocks_to_write == 0) || (nand_blocks_to_write > NAND_MAX_BLOCKS_TO_WRITE))

  001f8	e3550000	 cmp         r5, #0
  001fc	0affffdd	 beq         |$cleanUp$47656|
  00200	e355000f	 cmp         r5, #0xF
  00204	caffffdb	 bgt         |$cleanUp$47656|

; 554  : 	{
; 555  : 		goto cleanUp;
; 556  : 	}
; 557  : 
; 558  :     // Set address to where to copy from
; 559  :     pImage = (UINT8*)IMAGE_STARTUP_IMAGE_PA; // 0x87E00000
; 560  : 
; 561  : 	// Write dnld image, starting from first good block (4 xldr block and 2 eboot block)
; 562  : 	block = 0;

  00208	e3a04000	 mov         r4, #0

; 563  :     image_block_cnt = 0;

  0020c	e3a07000	 mov         r7, #0

; 564  : 
; 565  : 	while (image_block_cnt < nand_blocks_to_write)

  00210	e3550000	 cmp         r5, #0
  00214	da000045	 ble         |$LN16@XLDRMain|
  00218		 |$LL17@XLDRMain|

; 566  : 	{
; 567  : 
; 568  : 		/* writing Eboot: need to change ECC mode*/ 
; 569  : 		if(image_block_cnt == 4)

  00218	e3570004	 cmp         r7, #4
  0021c	1a000008	 bne         |$LN49@XLDRMain|

; 570  : 		{
; 571  : 			// get EBOOT ECC type from FIXUP value
; 572  : 			g_ecctype = (UCHAR)dwEbootECCtype;

  00220	e59a3008	 ldr         r3, [r10, #8]

; 573  :                  
; 574  : 			FMD_Deinit(hFMD); 

  00224	e1a0000b	 mov         r0, r11
  00228	e5c63200	 strb        r3, [r6, #0x200]
  0022c	eb000000	 bl          FMD_Deinit

; 575  : 			hFMD = FMD_Init(NULL, &regInfo, NULL);

  00230	e3a02000	 mov         r2, #0
  00234	e28d1048	 add         r1, sp, #0x48
  00238	e3a00000	 mov         r0, #0
  0023c	eb000000	 bl          FMD_Init
  00240	e1a0b000	 mov         r11, r0
  00244		 |$LN49@XLDRMain|

; 576  : 		}
; 577  : 		// Skip to a good block
; 578  :         while (block < flashInfo.dwNumBlocks)

  00244	e59d303c	 ldr         r3, [sp, #0x3C]
  00248	e1540003	 cmp         r4, r3
  0024c	2affffc9	 bcs         |$cleanUp$47656|
  00250		 |$LL14@XLDRMain|

; 579  :         {
; 580  :             if ((FMD_GetBlockStatus(block) & BLOCK_STATUS_BAD) == 0)

  00250	e1a00004	 mov         r0, r4
  00254	eb000000	 bl          FMD_GetBlockStatus
  00258	e59d303c	 ldr         r3, [sp, #0x3C]
  0025c	e3100002	 tst         r0, #2
  00260	0a000002	 beq         |$LN55@XLDRMain|

; 581  :     		{
; 582  :     			// A good block
; 583  :     			break;
; 584  :     		}
; 585  :             block++;

  00264	e2844001	 add         r4, r4, #1
  00268	e1540003	 cmp         r4, r3
  0026c	3afffff7	 bcc         |$LL14@XLDRMain|
  00270		 |$LN55@XLDRMain|

; 586  :         }
; 587  :     
; 588  :     	if (block >= flashInfo.dwNumBlocks)

  00270	e1540003	 cmp         r4, r3
  00274	2affffbf	 bcs         |$cleanUp$47656|

; 589  :     	{
; 590  :     		// No good block found!!
; 591  :     		goto cleanUp;
; 592  :     	}
; 593  : 
; 594  : 		// Erase block first
; 595  : 		if (!FMD_EraseBlock(block))

  00278	e1a00004	 mov         r0, r4
  0027c	eb000000	 bl          FMD_EraseBlock
  00280	e3500000	 cmp         r0, #0
  00284	0a000026	 beq         |$LL9@XLDRMain|

; 598  : 		}
; 599  : 
; 600  : 		// Calculate starting sector id of the good block
; 601  :     	sector = block * flashInfo.wSectorsPerBlock;

  00288	e1dd34b4	 ldrh        r3, [sp, #0x44]

; 602  : 		offset = 0;
; 603  : 
; 604  : 		// Copy sectors in block
; 605  : 		while (offset < flashInfo.dwBytesPerBlock)

  0028c	e59d2040	 ldr         r2, [sp, #0x40]
  00290	e3a06000	 mov         r6, #0
  00294	e0090493	 mul         r9, r3, r4
  00298	e3520000	 cmp         r2, #0
  0029c	0a000016	 beq         |$LN6@XLDRMain|
  002a0		 |$LL7@XLDRMain|

; 606  : 		{
; 607  :         	memset(&sectorInfo, 0xFF, sizeof(sectorInfo));

  002a0	e3e03000	 mvn         r3, #0
  002a4	e58d300c	 str         r3, [sp, #0xC]
  002a8	e58d3010	 str         r3, [sp, #0x10]

; 608  : 	        sectorInfo.bOEMReserved &= ~(OEM_BLOCK_READONLY|OEM_BLOCK_RESERVED);

  002ac	e5dd3010	 ldrb        r3, [sp, #0x10]

; 609  : 			sectorInfo.dwReserved1 = 0;
; 610  : 			sectorInfo.wReserved2 = 0;
; 611  :     
; 612  :     		// Write 1 sector
; 613  :     		if (!FMD_WriteSector(sector, pImage + offset, &sectorInfo, 1))

  002b0	e3a0e000	 mov         lr, #0
  002b4	e58de00c	 str         lr, [sp, #0xC]
  002b8	e20330fc	 and         r3, r3, #0xFC
  002bc	e5cd3010	 strb        r3, [sp, #0x10]
  002c0	e3a0e000	 mov         lr, #0
  002c4	e3a03001	 mov         r3, #1
  002c8	e28d200c	 add         r2, sp, #0xC
  002cc	e0861008	 add         r1, r6, r8
  002d0	e1a00009	 mov         r0, r9
  002d4	e1cde1b2	 strh        lr, [sp, #0x12]
  002d8	eb000000	 bl          FMD_WriteSector
  002dc	e3500000	 cmp         r0, #0
  002e0	0a00000c	 beq         |$LL4@XLDRMain|

; 616  : 				goto cleanUp;
; 617  : 			}
; 618  : 
; 619  : 			// Next sector
; 620  : 			sector++;
; 621  : 			offset += flashInfo.wDataBytesPerSector;

  002e4	e1dd34b6	 ldrh        r3, [sp, #0x46]
  002e8	e59d2040	 ldr         r2, [sp, #0x40]
  002ec	e2899001	 add         r9, r9, #1
  002f0	e0866003	 add         r6, r6, r3
  002f4	e1560002	 cmp         r6, r2
  002f8	3affffe8	 bcc         |$LL7@XLDRMain|
  002fc		 |$LN6@XLDRMain|

; 622  : 		}
; 623  :     
; 624  : 		// Written 1 block
; 625  : 		++image_block_cnt;

  002fc	e2877001	 add         r7, r7, #1
  00300	e1570005	 cmp         r7, r5

; 626  : 
; 627  : 		// Start from next block id and next block of data
; 628  : 		++block;

  00304	e2844001	 add         r4, r4, #1

; 629  : 		pImage += offset;

  00308	e0888006	 add         r8, r8, r6
  0030c	aa000007	 bge         |$LN16@XLDRMain|
  00310	e59f6180	 ldr         r6, [pc, #0x180]
  00314	eaffffbf	 b           |$LL17@XLDRMain|
  00318		 |$LL4@XLDRMain|

; 614  : 			{
; 615  : 				for(;;) XLDRMSG(L"Write FAILED\r\n");

  00318	e59f0174	 ldr         r0, [pc, #0x174]
  0031c	eb000000	 bl          OEMWriteDebugString
  00320	eafffffc	 b           |$LL4@XLDRMain|
  00324		 |$LL9@XLDRMain|

; 596  : 		{
; 597  : 			for(;;) XLDRMSG(L"Erase FAILED\r\n");

  00324	e59f0164	 ldr         r0, [pc, #0x164]
  00328	eb000000	 bl          OEMWriteDebugString
  0032c	eafffffc	 b           |$LL9@XLDRMain|
  00330		 |$LN16@XLDRMain|

; 630  : 	}
; 631  : 
; 632  : 	XGetStats ( &xblock_cnt, &xack_cnt, &xnak_cnt,
; 633  : 		        &xcan_cnt, &xothers_cnt, &checksum_error_cnt, 
; 634  : 				&dup_pkt_cnt);

  00330	e28d301c	 add         r3, sp, #0x1C
  00334	e28d2018	 add         r2, sp, #0x18
  00338	e28d1014	 add         r1, sp, #0x14
  0033c	e58d3008	 str         r3, [sp, #8]
  00340	e58d2004	 str         r2, [sp, #4]
  00344	e58d1000	 str         r1, [sp]
  00348	e28d3028	 add         r3, sp, #0x28
  0034c	e28d2020	 add         r2, sp, #0x20
  00350	e28d1024	 add         r1, sp, #0x24
  00354	e28d002c	 add         r0, sp, #0x2C
  00358	eb000000	 bl          XGetStats

; 635  : 
; 636  : 	XLDRMSG(L"\r\nReceive return code "); XLDRPrintUint8((UINT8)xret, 1, 1);

  0035c	e59f0128	 ldr         r0, [pc, #0x128]
  00360	eb000000	 bl          OEMWriteDebugString
  00364	e59d3034	 ldr         r3, [sp, #0x34]
  00368	e3a02001	 mov         r2, #1
  0036c	e3a01001	 mov         r1, #1
  00370	e20300ff	 and         r0, r3, #0xFF
  00374	eb000000	 bl          XLDRPrintUint8

; 637  : 	XLDRMSG(L"blocks written ");          XLDRPrintUint8((UINT8)image_block_cnt, 1, 1);

  00378	e59f0108	 ldr         r0, [pc, #0x108]
  0037c	eb000000	 bl          OEMWriteDebugString
  00380	e3a02001	 mov         r2, #1
  00384	e3a01001	 mov         r1, #1
  00388	e20700ff	 and         r0, r7, #0xFF
  0038c	eb000000	 bl          XLDRPrintUint8

; 638  : 	XLDRMSG(L"bytes rx ");                XLDRPrintUlong((UINT32)dnld_size, 1, 1);

  00390	e59f00ec	 ldr         r0, [pc, #0xEC]
  00394	eb000000	 bl          OEMWriteDebugString
  00398	e59d0030	 ldr         r0, [sp, #0x30]
  0039c	e3a02001	 mov         r2, #1
  003a0	e3a01001	 mov         r1, #1
  003a4	eb000000	 bl          XLDRPrintUlong

; 639  : 	XLDRMSG(L"pkts rx ");                 XLDRPrintUlong((UINT32)xblock_cnt, 1, 1);

  003a8	e59f00d0	 ldr         r0, [pc, #0xD0]
  003ac	eb000000	 bl          OEMWriteDebugString
  003b0	e59d002c	 ldr         r0, [sp, #0x2C]
  003b4	e3a02001	 mov         r2, #1
  003b8	e3a01001	 mov         r1, #1
  003bc	eb000000	 bl          XLDRPrintUlong

; 640  : 	XLDRMSG(L"acks sent ");               XLDRPrintUlong((UINT32)xack_cnt, 1, 1);

  003c0	e59f00b4	 ldr         r0, [pc, #0xB4]
  003c4	eb000000	 bl          OEMWriteDebugString
  003c8	e59d0024	 ldr         r0, [sp, #0x24]
  003cc	e3a02001	 mov         r2, #1
  003d0	e3a01001	 mov         r1, #1
  003d4	eb000000	 bl          XLDRPrintUlong

; 641  : 	XLDRMSG(L"naks sent ");               XLDRPrintUlong((UINT32)xnak_cnt, 1, 1);

  003d8	e59f0098	 ldr         r0, [pc, #0x98]
  003dc	eb000000	 bl          OEMWriteDebugString
  003e0	e59d0020	 ldr         r0, [sp, #0x20]
  003e4	e3a02001	 mov         r2, #1
  003e8	e3a01001	 mov         r1, #1
  003ec	eb000000	 bl          XLDRPrintUlong

; 642  : 	XLDRMSG(L"can sent ");                XLDRPrintUlong((UINT32)xcan_cnt, 1, 1);

  003f0	e59f007c	 ldr         r0, [pc, #0x7C]
  003f4	eb000000	 bl          OEMWriteDebugString
  003f8	e59d0028	 ldr         r0, [sp, #0x28]
  003fc	e3a02001	 mov         r2, #1
  00400	e3a01001	 mov         r1, #1
  00404	eb000000	 bl          XLDRPrintUlong

; 643  : 	XLDRMSG(L"others sent ");             XLDRPrintUlong((UINT32)xothers_cnt, 1, 1);

  00408	e59f0060	 ldr         r0, [pc, #0x60]
  0040c	eb000000	 bl          OEMWriteDebugString
  00410	e59d0014	 ldr         r0, [sp, #0x14]
  00414	e3a02001	 mov         r2, #1
  00418	e3a01001	 mov         r1, #1
  0041c	eb000000	 bl          XLDRPrintUlong

; 644  : 	XLDRMSG(L"chksum errs ");             XLDRPrintUlong((UINT32)checksum_error_cnt, 1, 1);

  00420	e59f0044	 ldr         r0, [pc, #0x44]
  00424	eb000000	 bl          OEMWriteDebugString
  00428	e59d0018	 ldr         r0, [sp, #0x18]
  0042c	e3a02001	 mov         r2, #1
  00430	e3a01001	 mov         r1, #1
  00434	eb000000	 bl          XLDRPrintUlong

; 645  : 	XLDRMSG(L"dup pkts ");                XLDRPrintUlong((UINT32)dup_pkt_cnt, 1, 1);

  00438	e59f0028	 ldr         r0, [pc, #0x28]
  0043c	eb000000	 bl          OEMWriteDebugString
  00440	e59d001c	 ldr         r0, [sp, #0x1C]
  00444	e3a02001	 mov         r2, #1
  00448	e3a01001	 mov         r1, #1
  0044c	eb000000	 bl          XLDRPrintUlong

; 646  : 
; 647  : 	// Wait for serial port
; 648  :     XLDRMSGDEINIT;

  00450	eb000000	 bl          OEMDeinitDebugSerial
  00454	e59d03c8	 ldr         r0, [sp, #0x3C8]
  00458	eb000000	 bl          __security_check_cookie

; 723  : }

  0045c	e28ddff3	 add         sp, sp, #0xF3, 30
  00460	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00464	e12fff1e	 bx          lr
  00468		 |$LN82@XLDRMain|
  00468		 |$LN83@XLDRMain|
  00468	00000000	 DCD         |??_C@_1BE@KGIAHABA@?$AAd?$AAu?$AAp?$AA?5?$AAp?$AAk?$AAt?$AAs?$AA?5?$AA?$AA@|
  0046c		 |$LN84@XLDRMain|
  0046c	00000000	 DCD         |??_C@_1BK@BAIMCFMI@?$AAc?$AAh?$AAk?$AAs?$AAu?$AAm?$AA?5?$AAe?$AAr?$AAr?$AAs?$AA?5?$AA?$AA@|
  00470		 |$LN85@XLDRMain|
  00470	00000000	 DCD         |??_C@_1BK@MBABNMMG@?$AAo?$AAt?$AAh?$AAe?$AAr?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@|
  00474		 |$LN86@XLDRMain|
  00474	00000000	 DCD         |??_C@_1BE@DNEDGKLA@?$AAc?$AAa?$AAn?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@|
  00478		 |$LN87@XLDRMain|
  00478	00000000	 DCD         |??_C@_1BG@CEPKECJN@?$AAn?$AAa?$AAk?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@|
  0047c		 |$LN88@XLDRMain|
  0047c	00000000	 DCD         |??_C@_1BG@DCKOCMFB@?$AAa?$AAc?$AAk?$AAs?$AA?5?$AAs?$AAe?$AAn?$AAt?$AA?5?$AA?$AA@|
  00480		 |$LN89@XLDRMain|
  00480	00000000	 DCD         |??_C@_1BC@HEGKNIDF@?$AAp?$AAk?$AAt?$AAs?$AA?5?$AAr?$AAx?$AA?5?$AA?$AA@|
  00484		 |$LN90@XLDRMain|
  00484	00000000	 DCD         |??_C@_1BE@JCBNJGDH@?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?5?$AAr?$AAx?$AA?5?$AA?$AA@|
  00488		 |$LN91@XLDRMain|
  00488	00000000	 DCD         |??_C@_1CA@FAKMAHKG@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAt?$AAe?$AAn?$AA?5?$AA?$AA@|
  0048c		 |$LN92@XLDRMain|
  0048c	00000000	 DCD         |??_C@_1CO@FNBIBCAH@?$AA?$AN?$AA?6?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?5?$AAc?$AAo?$AAd?$AAe?$AA?5?$AA?$AA@|
  00490		 |$LN93@XLDRMain|
  00490	00000000	 DCD         |??_C@_1BO@MBOCIIDG@?$AAE?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AN?$AA?6?$AA?$AA@|
  00494		 |$LN94@XLDRMain|
  00494	00000000	 DCD         |??_C@_1BO@KNPOGIOP@?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAF?$AAA?$AAI?$AAL?$AAE?$AAD?$AA?$AN?$AA?6?$AA?$AA@|
  00498		 |$LN95@XLDRMain|
  00498	00000000	 DCD         |?allocationPool@?1??XLDRMain@@9@9|
  0049c		 |$LN96@XLDRMain|
  0049c	00000000	 DCD         |??_C@_1EE@IIHIGBCF@?$AA?$AN?$AA?6?$AAD?$AAN?$AAL?$AAD?$AA?5?$AAT?$AAI?$AAE?$AAV?$AAM?$AA3?$AA5?$AA3?$AA0?$AA?9?$AAn?$AAa?$AAn?$AAd?$AA?4?$AAr?$AAa?$AAw?$AA?5?$AAI?$AAm?$AAa?$AAg?$AAe?$AA?$AN@|
  004a0		 |$LN97@XLDRMain|
  004a0	00000000	 DCD         |??_C@_1CO@MAFCCJBC@?$AA?$AN?$AA?6?$AAF?$AAM?$AAD?$AA_?$AAG?$AAe?$AAt?$AAI?$AAn?$AAf?$AAo?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  004a4		 |$LN98@XLDRMain|
  004a4	00000000	 DCD         |??_C@_1BC@MABDLOIF@?$AA?$AN?$AA?6?$AAH?$AAA?$AAL?$AAT?$AA?$AN?$AA?6?$AA?$AA@|
  004a8		 |$LN99@XLDRMain|
  004a8	00000000	 DCD         |??_C@_1CI@HOAHMIF@?$AA?$AN?$AA?6?$AAF?$AAM?$AAD?$AA_?$AAI?$AAn?$AAi?$AAt?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  004ac		 |$LN100@XLDRMain|
  004ac	00000000	 DCD         |??_C@_1CC@DJCPIFGO@?$AAV?$AAe?$AAr?$AAs?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AA0?$AA?4?$AA0?$AA?4?$AA1?$AA?$AN?$AA?6?$AA?$AA@|
  004b0		 |$LN101@XLDRMain|
  004b0	00000000	 DCD         |gCPU_family|
  004b4		 |$LN102@XLDRMain|
  004b4	00000000	 DCD         |pTOC|
  004b8		 |$LN103@XLDRMain|
  004b8	00000000	 DCD         |__security_cookie|
  004bc		 |$M48107|

			 ENDP  ; |XLDRMain|

	END
