; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\EVM_OMAP3530\SRC\DRIVERS\TOUCH\touchscreen.cpp
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BI@OMDEANNH@?$AAS?$AAP?$AAI?$AAB?$AAa?$AAu?$AAd?$AAr?$AAa?$AAt?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CM@FGLBKGFE@?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAs?$AAD?$AAr?$AAo?$AAp?$AAp?$AAe?$AAd?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@PJOGJEE@?$AAS?$AAP?$AAI?$AAA?$AAd?$AAd?$AAr?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@GCCHEIII@?$AAS?$AAP?$AAI?$AAB?$AAu?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@ENFPPIBL@?$AAP?$AAe?$AAn?$AAU?$AAp?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAM?$AAS?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@NAGANOEM@?$AAP?$AAe?$AAn?$AAG?$AAP?$AAI?$AAO?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@KHEAEOIK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAR?$AAa?$AAt?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DE@CLFJDOFC@?$AA?2?$AAH?$AAA?$AAR?$AAD?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAM?$AAA?$AAP?$AA?2?$AAT?$AAO?$AAU?$AAC?$AAH?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|gIntrTouchChanged| [ DATA ]
	EXPORT	|gIntrTouch| [ DATA ]
	EXPORT	|MIN_CAL_COUNT| [ DATA ]

  00000			 AREA	 |.bss|, NOINIT
|gIntrTouchChanged| % 0x4
|gIntrTouch| %	0x4

  00000			 AREA	 |.rdata|, DATA, READONLY
|s_deviceRegParams| DCD |??_C@_1BG@KHEAEOIK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAR?$AAa?$AAt?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0xc8
	DCD	|??_C@_1BA@NAGANOEM@?$AAP?$AAe?$AAn?$AAG?$AAP?$AAI?$AAO?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0xc
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CA@ENFPPIBL@?$AAP?$AAe?$AAn?$AAU?$AAp?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAM?$AAS?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x10
	DCD	0x4
	DCD	0x28
	DCD	|??_C@_1O@GCCHEIII@?$AAS?$AAP?$AAI?$AAB?$AAu?$AAs?$AA?$AA@|
	DCD	0x1
	DCD	0x1
	DCD	0x1c
	DCD	0xc
	DCD	0x0
	DCD	|??_C@_1BA@PJOGJEE@?$AAS?$AAP?$AAI?$AAA?$AAd?$AAd?$AAr?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x14
	DCD	0x4
	DCD	0x0
	DCD	|??_C@_1CM@FGLBKGFE@?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAs?$AAD?$AAr?$AAo?$AAp?$AAp?$AAe?$AAd?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BI@OMDEANNH@?$AAS?$AAP?$AAI?$AAB?$AAa?$AAu?$AAd?$AAr?$AAa?$AAt?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x18
	DCD	0x4
	DCD	0x5
|MIN_CAL_COUNT| DCD 0x14

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@OMDEANNH@?$AAS?$AAP?$AAI?$AAB?$AAa?$AAu?$AAd?$AAr?$AAa?$AAt?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "P", 0x0, "I", 0x0, "B", 0x0, "a", 0x0, "u", 0x0, "d"
	DCB	0x0, "r", 0x0, "a", 0x0, "t", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@FGLBKGFE@?$AAI?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAs?$AAD?$AAr?$AAo?$AAp?$AAp?$AAe?$AAd?$AA?$AA@| DCB "I"
	DCB	0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i", 0x0, "a", 0x0, "l"
	DCB	0x0, "S", 0x0, "a", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e"
	DCB	0x0, "s", 0x0, "D", 0x0, "r", 0x0, "o", 0x0, "p", 0x0, "p"
	DCB	0x0, "e", 0x0, "d", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@PJOGJEE@?$AAS?$AAP?$AAI?$AAA?$AAd?$AAd?$AAr?$AA?$AA@| DCB "S", 0x0
	DCB	"P", 0x0, "I", 0x0, "A", 0x0, "d", 0x0, "d", 0x0, "r", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@GCCHEIII@?$AAS?$AAP?$AAI?$AAB?$AAu?$AAs?$AA?$AA@| DCB "S", 0x0, "P"
	DCB	0x0, "I", 0x0, "B", 0x0, "u", 0x0, "s", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@ENFPPIBL@?$AAP?$AAe?$AAn?$AAU?$AAp?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAM?$AAS?$AA?$AA@| DCB "P"
	DCB	0x0, "e", 0x0, "n", 0x0, "U", 0x0, "p", 0x0, "D", 0x0, "e"
	DCB	0x0, "b", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "e"
	DCB	0x0, "M", 0x0, "S", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@NAGANOEM@?$AAP?$AAe?$AAn?$AAG?$AAP?$AAI?$AAO?$AA?$AA@| DCB "P", 0x0
	DCB	"e", 0x0, "n", 0x0, "G", 0x0, "P", 0x0, "I", 0x0, "O", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@KHEAEOIK@?$AAS?$AAa?$AAm?$AAp?$AAl?$AAe?$AAR?$AAa?$AAt?$AAe?$AA?$AA@| DCB "S"
	DCB	0x0, "a", 0x0, "m", 0x0, "p", 0x0, "l", 0x0, "e", 0x0, "R"
	DCB	0x0, "a", 0x0, "t", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.data|, DATA
|s_szRegistryPath| DCD |??_C@_1DE@CLFJDOFC@?$AA?2?$AAH?$AAA?$AAR?$AAD?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAM?$AAA?$AAP?$AA?2?$AAT?$AAO?$AAU?$AAC?$AAH?$AA?$AA@|
|s_TouchDevice| DCD 0x0
	DCD	0xc8
	DCD	0x0
	DCD	0x0
	DCD	0x0
	%	36

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DE@CLFJDOFC@?$AA?2?$AAH?$AAA?$AAR?$AAD?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAM?$AAA?$AAP?$AA?2?$AAT?$AAO?$AAU?$AAC?$AAH?$AA?$AA@| DCB "\\"
	DCB	0x0, "H", 0x0, "A", 0x0, "R", 0x0, "D", 0x0, "W", 0x0, "A"
	DCB	0x0, "R", 0x0, "E", 0x0, "\\", 0x0, "D", 0x0, "E", 0x0, "V"
	DCB	0x0, "I", 0x0, "C", 0x0, "E", 0x0, "M", 0x0, "A", 0x0, "P"
	DCB	0x0, "\\", 0x0, "T", 0x0, "O", 0x0, "U", 0x0, "C", 0x0, "H"
	DCB	0x0, 0x0, 0x0				; `string'
	EXPORT	|TouchDriverCalibrationPointGet|
	IMPORT	|SetLastError|
; File c:\wince600\platform\evm_omap3530\src\drivers\touch\touchscreen.cpp

  00000			 AREA	 |.pdata|, PDATA
|$T36789| DCD	|$LN16@TouchDrive|
	DCD	0x40003601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |TouchDriverCalibrationPointGet| PROC

; 170  : {

  00000		 |$LN16@TouchDrive|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004		 |$M36786|

; 171  :     BOOL rc = FALSE;
; 172  : 
; 173  :     INT32 cDisplayWidth  = pTCP->cDisplayWidth;

  00004	e5907004	 ldr         r7, [r0, #4]

; 174  :     INT32 cDisplayHeight = pTCP->cDisplayHeight;
; 175  : 
; 176  :     int CalibrationRadiusX = cDisplayWidth / 20;

  00008	e59f30c4	 ldr         r3, [pc, #0xC4]
  0000c	e5908008	 ldr         r8, [r0, #8]

; 177  :     int CalibrationRadiusY = cDisplayHeight / 20;
; 178  : 
; 179  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("TouchDriverCalibrationPointGet+\r\n")));    
; 180  :     
; 181  :     // Check which of the 5 calibration point is requested.
; 182  :     switch ( pTCP->PointNumber )

  00010	e5905000	 ldr         r5, [r0]
  00014	e0c2e397	 smull       lr, r2, r7, r3
  00018	e0c14398	 smull       r4, r1, r8, r3
  0001c	e1a031c2	 mov         r3, r2, asr #3
  00020	e1a021c1	 mov         r2, r1, asr #3
  00024	e0822fa2	 add         r2, r2, r2, lsr #31
  00028	e0833fa3	 add         r3, r3, r3, lsr #31
  0002c	e3a06000	 mov         r6, #0
  00030	e3550000	 cmp         r5, #0
  00034	0a00001c	 beq         |$LN6@TouchDrive|
  00038	e3550001	 cmp         r5, #1
  0003c	0a000017	 beq         |$LN5@TouchDrive|
  00040	e3550002	 cmp         r5, #2
  00044	0a000012	 beq         |$LN4@TouchDrive|
  00048	e3550003	 cmp         r5, #3
  0004c	0a00000d	 beq         |$LN3@TouchDrive|
  00050	e3550004	 cmp         r5, #4
  00054	0a000008	 beq         |$LN2@TouchDrive|

; 213  : 
; 214  :         default:
; 215  :             pTCP->CalibrationX = cDisplayWidth / 2;

  00058	e0873fa7	 add         r3, r7, r7, lsr #31

; 216  :             pTCP->CalibrationY = cDisplayHeight / 2;

  0005c	e0882fa8	 add         r2, r8, r8, lsr #31
  00060	e1a030c3	 mov         r3, r3, asr #1
  00064	e1a020c2	 mov         r2, r2, asr #1
  00068	e580300c	 str         r3, [r0, #0xC]
  0006c	e5802010	 str         r2, [r0, #0x10]

; 217  : 
; 218  :             SetLastError( ERROR_INVALID_PARAMETER );

  00070	e3a00057	 mov         r0, #0x57
  00074	eb000000	 bl          SetLastError

; 219  :             break;

  00078	ea000012	 b           |$LN7@TouchDrive|
  0007c		 |$LN2@TouchDrive|

; 207  : 
; 208  :         case 4:
; 209  :             pTCP->CalibrationX = cDisplayWidth - ( CalibrationRadiusX * 2 );

  0007c	e0473083	 sub         r3, r7, r3, lsl #1

; 210  :             pTCP->CalibrationY = CalibrationRadiusY * 2;

  00080	e1a02082	 mov         r2, r2, lsl #1

; 211  :             rc = TRUE;
; 212  :             break;

  00084	ea00000c	 b           |$LN11@TouchDrive|
  00088		 |$LN3@TouchDrive|

; 198  :             pTCP->CalibrationY = cDisplayHeight - ( CalibrationRadiusY * 2 );
; 199  :             rc = TRUE;
; 200  :             break;
; 201  : 
; 202  :         case 3:
; 203  :             pTCP->CalibrationX = cDisplayWidth - ( CalibrationRadiusX * 2 );

  00088	e0473083	 sub         r3, r7, r3, lsl #1

; 204  :             pTCP->CalibrationY = cDisplayHeight - ( CalibrationRadiusY * 2 );

  0008c	e0482082	 sub         r2, r8, r2, lsl #1

; 205  :             rc = TRUE;
; 206  :             break;

  00090	ea000009	 b           |$LN11@TouchDrive|
  00094		 |$LN4@TouchDrive|

; 192  :             pTCP->CalibrationY = CalibrationRadiusY * 2;
; 193  :             rc = TRUE;
; 194  :             break;
; 195  : 
; 196  :         case 2:
; 197  :             pTCP->CalibrationX = CalibrationRadiusX * 2;

  00094	e1a03083	 mov         r3, r3, lsl #1

; 204  :             pTCP->CalibrationY = cDisplayHeight - ( CalibrationRadiusY * 2 );

  00098	e0482082	 sub         r2, r8, r2, lsl #1

; 205  :             rc = TRUE;
; 206  :             break;

  0009c	ea000006	 b           |$LN11@TouchDrive|
  000a0		 |$LN5@TouchDrive|

; 188  :             break;
; 189  : 
; 190  :         case 1:
; 191  :             pTCP->CalibrationX = CalibrationRadiusX * 2;

  000a0	e1a03083	 mov         r3, r3, lsl #1

; 210  :             pTCP->CalibrationY = CalibrationRadiusY * 2;

  000a4	e1a02082	 mov         r2, r2, lsl #1

; 211  :             rc = TRUE;
; 212  :             break;

  000a8	ea000003	 b           |$LN11@TouchDrive|
  000ac		 |$LN6@TouchDrive|

; 183  :         {
; 184  :         case 0:
; 185  :             pTCP->CalibrationX = cDisplayWidth / 2;

  000ac	e0873fa7	 add         r3, r7, r7, lsr #31

; 186  :             pTCP->CalibrationY = cDisplayHeight / 2;

  000b0	e0882fa8	 add         r2, r8, r8, lsr #31
  000b4	e1a030c3	 mov         r3, r3, asr #1
  000b8	e1a020c2	 mov         r2, r2, asr #1
  000bc		 |$LN11@TouchDrive|
  000bc	e580300c	 str         r3, [r0, #0xC]
  000c0	e5802010	 str         r2, [r0, #0x10]

; 187  :             rc = TRUE;

  000c4	e3a06001	 mov         r6, #1
  000c8		 |$LN7@TouchDrive|

; 220  :         }
; 221  : 
; 222  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("cDisplayWidth        : %4X\r\n"), cDisplayWidth     ));
; 223  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("cDisplayHeight       : %4X\r\n"), cDisplayHeight    ));
; 224  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("CalibrationRadiusX   : %4d\r\n"), CalibrationRadiusX));
; 225  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("CalibrationRadiusY   : %4d\r\n"), CalibrationRadiusY));
; 226  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("pTCP -> PointNumber  : %4d\r\n"), pTCP->PointNumber));
; 227  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("pTCP -> CalibrationX : %4d\r\n"), pTCP->CalibrationX));
; 228  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("pTCP -> CalibrationY : %4d\r\n"), pTCP->CalibrationY));
; 229  : 
; 230  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("TouchDriverCalibrationPointGet-\r\n")));    
; 231  :     return ( rc );
; 232  : }

  000c8	e1a00006	 mov         r0, r6
  000cc	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  000d0	e12fff1e	 bx          lr
  000d4		 |$LN17@TouchDrive|
  000d4		 |$LN18@TouchDrive|
  000d4	66666667	 DCD         0x66666667
  000d8		 |$M36787|

			 ENDP  ; |TouchDriverCalibrationPointGet|

	EXPORT	|DdsiTouchPanelGetDeviceCaps|

  00000			 AREA	 |.pdata|, PDATA
|$T36805| DCD	|$LN15@DdsiTouchP|
	DCD	0x40002101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelGetDeviceCaps| PROC

; 245  : {

  00000		 |$LN15@DdsiTouchP|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36802|
  00004	e3510000	 cmp         r1, #0

; 246  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelGetDeviceCaps+\r\n")));
; 247  :  
; 248  :     BOOL rc = FALSE;

  00008	e3a04000	 mov         r4, #0

; 249  :     if ( lpOutput == NULL )
; 250  :         {
; 251  :         DEBUGMSG(ZONE_ERROR, (TEXT("TouchPanelGetDeviceCaps: Invalid parameter.\r\n")));
; 252  :         SetLastError( ERROR_INVALID_PARAMETER );
; 253  :         }
; 254  :     else

  0000c	0a000005	 beq         |$LN12@DdsiTouchP|

; 255  :         {
; 256  :         TPDC_SAMPLE_RATE *pTSR = (TPDC_SAMPLE_RATE*)lpOutput;
; 257  :         TPDC_CALIBRATION_POINT_COUNT *pTCPC = (TPDC_CALIBRATION_POINT_COUNT*)lpOutput;
; 258  : 
; 259  :         // Check which of the device capabilities are requested.
; 260  :         switch ( iIndex )

  00010	e3500000	 cmp         r0, #0
  00014	0a00000f	 beq         |$LN4@DdsiTouchP|
  00018	e3500001	 cmp         r0, #1
  0001c	0a000008	 beq         |$LN3@DdsiTouchP|
  00020	e3500002	 cmp         r0, #2
  00024	0a000002	 beq         |$LN2@DdsiTouchP|
  00028		 |$LN12@DdsiTouchP|

; 286  : 
; 287  :             default:
; 288  :                 DEBUGMSG( ZONE_ERROR, 
; 289  :                            (TEXT("TouchPanelGetDeviceCaps: Invalid parameter.\r\n")));
; 290  :                 SetLastError(ERROR_INVALID_PARAMETER);

  00028	e3a00057	 mov         r0, #0x57
  0002c	eb000000	 bl          SetLastError

; 291  :                 break;

  00030	ea00000f	 b           |$LN5@DdsiTouchP|
  00034		 |$LN2@DdsiTouchP|

; 280  : 
; 281  :             // Return the x and y coordinates of the requested calibration point.
; 282  :             // The index of the calibration point is set in lpOutput->PointNumber.
; 283  :             case TPDC_CALIBRATION_POINT_ID:
; 284  :                 rc = TouchDriverCalibrationPointGet( (TPDC_CALIBRATION_POINT*)lpOutput );

  00034	e1a00001	 mov         r0, r1
  00038	eb000000	 bl          TouchDriverCalibrationPointGet
  0003c	e1a04000	 mov         r4, r0

; 285  :                 break;

  00040	ea00000b	 b           |$LN5@DdsiTouchP|
  00044		 |$LN3@DdsiTouchP|

; 270  :                 break;
; 271  : 
; 272  :             // Return the number of calibration points used to calibrate the touch screen.
; 273  :             case TPDC_CALIBRATION_POINT_COUNT_ID:
; 274  : 
; 275  :                 pTCPC->flags              = 0;

  00044	e3a03000	 mov         r3, #0

; 276  :                 pTCPC->cCalibrationPoints = 5;

  00048	e3a02005	 mov         r2, #5
  0004c	e5813000	 str         r3, [r1]
  00050	e5812004	 str         r2, [r1, #4]

; 277  : 
; 278  :                 rc = TRUE;
; 279  :                 break;

  00054	ea000005	 b           |$LN11@DdsiTouchP|
  00058		 |$LN4@DdsiTouchP|

; 261  :             {
; 262  :             // Return the sample rate.
; 263  :             case TPDC_SAMPLE_RATE_ID:
; 264  : 
; 265  :                 pTSR->SamplesPerSecondLow      = TOUCHPANEL_SAMPLE_RATE_LOW;
; 266  :                 pTSR->SamplesPerSecondHigh     = TOUCHPANEL_SAMPLE_RATE_HIGH;
; 267  :                 pTSR->CurrentSampleRateSetting = s_TouchDevice.nSampleRate;

  00058	e59f3020	 ldr         r3, [pc, #0x20]
  0005c	e3a020c8	 mov         r2, #0xC8
  00060	e5812000	 str         r2, [r1]
  00064	e5812004	 str         r2, [r1, #4]
  00068	e5933004	 ldr         r3, [r3, #4]

; 268  : 
; 269  :                 rc = TRUE;

  0006c	e5813008	 str         r3, [r1, #8]
  00070		 |$LN11@DdsiTouchP|
  00070	e3a04001	 mov         r4, #1
  00074		 |$LN5@DdsiTouchP|

; 292  :         }
; 293  :     }
; 294  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelGetDeviceCaps-\r\n")));
; 295  : 
; 296  :     return ( rc );
; 297  : }

  00074	e1a00004	 mov         r0, r4
  00078	e8bd4010	 ldmia       sp!, {r4, lr}
  0007c	e12fff1e	 bx          lr
  00080		 |$LN16@DdsiTouchP|
  00080		 |$LN17@DdsiTouchP|
  00080	00000000	 DCD         |s_TouchDevice|
  00084		 |$M36803|

			 ENDP  ; |DdsiTouchPanelGetDeviceCaps|

	EXPORT	|DdsiTouchPanelSetMode|

  00000			 AREA	 |.pdata|, PDATA
|$T36818| DCD	|$LN9@DdsiTouchP@2|
	DCD	0x40000f01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelSetMode| PROC

; 313  : {

  00000		 |$LN9@DdsiTouchP@2|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36815|
  00004	e3500000	 cmp         r0, #0

; 314  :     BOOL rc = FALSE;

  00008	e3a04000	 mov         r4, #0

; 315  : 
; 316  :     UNREFERENCED_PARAMETER(lpInput);
; 317  : 
; 318  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelSetMode+\r\n")));
; 319  :     
; 320  :     switch ( iIndex )

  0000c	4a000005	 bmi         |$LN1@DdsiTouchP@2|
  00010	e3500001	 cmp         r0, #1
  00014	ca000003	 bgt         |$LN1@DdsiTouchP@2|

; 321  :         {
; 322  :         case TPSM_SAMPLERATE_LOW_ID:
; 323  :         case TPSM_SAMPLERATE_HIGH_ID:
; 324  :             SetLastError( ERROR_SUCCESS );

  00018	e3a00000	 mov         r0, #0
  0001c	eb000000	 bl          SetLastError

; 325  :             rc = TRUE;

  00020	e3a04001	 mov         r4, #1

; 326  :             break;

  00024	ea000001	 b           |$LN3@DdsiTouchP@2|
  00028		 |$LN1@DdsiTouchP@2|

; 327  : 
; 328  :         default:
; 329  :             DEBUGMSG( ZONE_ERROR, 
; 330  :                        (TEXT("DdsiTouchPanelSetMode: Invalid parameter.\r\n")));
; 331  :             SetLastError( ERROR_INVALID_PARAMETER );

  00028	e3a00057	 mov         r0, #0x57
  0002c	eb000000	 bl          SetLastError
  00030		 |$LN3@DdsiTouchP@2|

; 332  :             break;
; 333  :         }
; 334  : 
; 335  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelSetMode-\r\n")));
; 336  : 
; 337  :     return rc;
; 338  : }

  00030	e1a00004	 mov         r0, r4
  00034	e8bd4010	 ldmia       sp!, {r4, lr}
  00038	e12fff1e	 bx          lr
  0003c		 |$M36816|

			 ENDP  ; |DdsiTouchPanelSetMode|

	EXPORT	|DdsiTouchPanelAttach|

  00000			 AREA	 |.pdata|, PDATA
|$T36827| DCD	|$LN5@DdsiTouchP@3|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelAttach| PROC

; 436  : {

  00000		 |$LN5@DdsiTouchP@3|
  00000		 |$M36824|

; 437  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelAttach+\r\n")));
; 438  : 
; 439  :     // Increment the number of process attach calls.
; 440  :     s_TouchDevice.nProcessAttached++;

  00000	e59f200c	 ldr         r2, [pc, #0xC]
  00004	e5923028	 ldr         r3, [r2, #0x28]
  00008	e2830001	 add         r0, r3, #1
  0000c	e5820028	 str         r0, [r2, #0x28]

; 441  : 
; 442  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelAttach-\r\n")));
; 443  :         
; 444  :     // Return the number.
; 445  :     return ( s_TouchDevice.nProcessAttached );
; 446  : }

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@DdsiTouchP@3|
  00014		 |$LN7@DdsiTouchP@3|
  00014	00000000	 DCD         |s_TouchDevice|
  00018		 |$M36825|

			 ENDP  ; |DdsiTouchPanelAttach|

	EXPORT	|DdsiTouchPanelDetach|

  00000			 AREA	 |.pdata|, PDATA
|$T36838| DCD	|$LN5@DdsiTouchP@4|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelDetach| PROC

; 455  : {

  00000		 |$LN5@DdsiTouchP@4|
  00000		 |$M36835|

; 456  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelDetach+\r\n")));
; 457  :     
; 458  :     // Decrement the number of process attach calls.
; 459  :     s_TouchDevice.nProcessAttached--;

  00000	e59f200c	 ldr         r2, [pc, #0xC]
  00004	e5923028	 ldr         r3, [r2, #0x28]
  00008	e2430001	 sub         r0, r3, #1
  0000c	e5820028	 str         r0, [r2, #0x28]

; 460  : 
; 461  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelDetach\r\n")));
; 462  :     
; 463  :     // Return the number.
; 464  :     return ( s_TouchDevice.nProcessAttached );
; 465  : }

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@DdsiTouchP@4|
  00014		 |$LN7@DdsiTouchP@4|
  00014	00000000	 DCD         |s_TouchDevice|
  00018		 |$M36836|

			 ENDP  ; |DdsiTouchPanelDetach|

	EXPORT	|DdsiTouchPanelPowerHandler|
	IMPORT	|InterruptMask|

  00000			 AREA	 |.pdata|, PDATA
|$T36848| DCD	|$LN6@DdsiTouchP@5|
	DCD	0x40000901
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelPowerHandler| PROC

; 601  : {

  00000		 |$LN6@DdsiTouchP@5|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36845|
  00004	e1a01000	 mov         r1, r0

; 602  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelPowerHandler+\r\n")));
; 603  : 
; 604  :     if (gIntrTouch != SYSINTR_NOP)

  00008	e59f3010	 ldr         r3, [pc, #0x10]
  0000c	e5930000	 ldr         r0, [r3]
  00010	e3500000	 cmp         r0, #0

; 605  :         InterruptMask(gIntrTouch, bOff);

  00014	1b000000	 blne        InterruptMask

; 606  : 
; 607  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelPowerHandler+\r\n")));
; 608  : }

  00018	e49de004	 ldr         lr, [sp], #4
  0001c	e12fff1e	 bx          lr
  00020		 |$LN7@DdsiTouchP@5|
  00020		 |$LN8@DdsiTouchP@5|
  00020	00000000	 DCD         |gIntrTouch|
  00024		 |$M36846|

			 ENDP  ; |DdsiTouchPanelPowerHandler|

	EXPORT	|?PddDeinitializeHardware@@YAXXZ|	; PddDeinitializeHardware
	IMPORT	|GPIOClose|
	IMPORT	|SPIClose|

  00000			 AREA	 |.pdata|, PDATA
|$T36857| DCD	|$LN7@PddDeiniti|
	DCD	0x40001101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PddDeinitializeHardware@@YAXXZ| PROC	; PddDeinitializeHardware

; 724  : {

  00000		 |$LN7@PddDeiniti|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M36854|

; 725  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("PddDeinitializeHardware+\r\n")));    
; 726  : 
; 727  :     // Close SPI device
; 728  :     if (s_TouchDevice.hSPI != NULL)

  00004	e59f4034	 ldr         r4, [pc, #0x34]
  00008	e5940030	 ldr         r0, [r4, #0x30]
  0000c	e3500000	 cmp         r0, #0
  00010	0a000002	 beq         |$LN2@PddDeiniti|

; 729  :         {
; 730  :             SPIClose(s_TouchDevice.hSPI);

  00014	eb000000	 bl          SPIClose

; 731  :             s_TouchDevice.hSPI = NULL;

  00018	e3a03000	 mov         r3, #0
  0001c	e5843030	 str         r3, [r4, #0x30]
  00020		 |$LN2@PddDeiniti|

; 732  :         }
; 733  : 
; 734  :     // Close GPIO device
; 735  :     if (s_TouchDevice.hGPIO != NULL)

  00020	e594002c	 ldr         r0, [r4, #0x2C]
  00024	e3500000	 cmp         r0, #0
  00028	0a000002	 beq         |$LN1@PddDeiniti|

; 736  :         {
; 737  :             GPIOClose(s_TouchDevice.hGPIO);

  0002c	eb000000	 bl          GPIOClose

; 738  :             s_TouchDevice.hGPIO = NULL;

  00030	e3a03000	 mov         r3, #0
  00034	e584302c	 str         r3, [r4, #0x2C]
  00038		 |$LN1@PddDeiniti|

; 739  :         }
; 740  : 
; 741  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("PddDeinitializeHardware-\r\n")));    
; 742  : }

  00038	e8bd4010	 ldmia       sp!, {r4, lr}
  0003c	e12fff1e	 bx          lr
  00040		 |$LN8@PddDeiniti|
  00040		 |$LN9@PddDeiniti|
  00040	00000000	 DCD         |s_TouchDevice|
  00044		 |$M36855|

			 ENDP  ; |?PddDeinitializeHardware@@YAXXZ|, PddDeinitializeHardware

	EXPORT	|?PddGetTouchIntPinState@@YAHXZ|	; PddGetTouchIntPinState
	IMPORT	|GPIOGetBit|

  00000			 AREA	 |.pdata|, PDATA
|$T36870| DCD	|$LN7@PddGetTouc|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PddGetTouchIntPinState@@YAHXZ| PROC	; PddGetTouchIntPinState

; 751  : {

  00000		 |$LN7@PddGetTouc|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M36867|

; 752  :     //  Return state of pen down
; 753  :    return( GPIOGetBit(s_TouchDevice.hGPIO, s_TouchDevice.nPenGPIO) == 0 );

  00004	e59f3020	 ldr         r3, [pc, #0x20]
  00008	e593100c	 ldr         r1, [r3, #0xC]
  0000c	e593002c	 ldr         r0, [r3, #0x2C]
  00010	eb000000	 bl          GPIOGetBit
  00014	e3500000	 cmp         r0, #0
  00018	03a00001	 moveq       r0, #1

; 754  : }

  0001c	049de004	 ldreq       lr, [sp], #4

; 752  :     //  Return state of pen down
; 753  :    return( GPIOGetBit(s_TouchDevice.hGPIO, s_TouchDevice.nPenGPIO) == 0 );

  00020	13a00000	 movne       r0, #0

; 754  : }

  00024	149de004	 ldrne       lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$LN8@PddGetTouc|
  0002c		 |$LN9@PddGetTouc|
  0002c	00000000	 DCD         |s_TouchDevice|
  00030		 |$M36868|

			 ENDP  ; |?PddGetTouchIntPinState@@YAHXZ|, PddGetTouchIntPinState

	EXPORT	|?PddGetControllerData@@YAXIPAI@Z|	; PddGetControllerData
	IMPORT	|SPIWriteRead|

  00000			 AREA	 |.pdata|, PDATA
|$T36880| DCD	|$LN5@PddGetCont|
	DCD	0x40000c03
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PddGetControllerData@@YAXIPAI@Z| PROC ; PddGetControllerData

; 761  : {

  00000		 |$LN5@PddGetCont|
  00000	e1a0c00d	 mov         r12, sp
  00004	e92d000f	 stmdb       sp!, {r0 - r3}
  00008	e92d5000	 stmdb       sp!, {r12, lr}
  0000c		 |$M36877|
  0000c	e1a03001	 mov         r3, r1

; 762  :     SPIWriteRead(s_TouchDevice.hSPI, 3, &control, read_data);

  00010	e59f0014	 ldr         r0, [pc, #0x14]
  00014	e28d2008	 add         r2, sp, #8
  00018	e3a01003	 mov         r1, #3
  0001c	e5900030	 ldr         r0, [r0, #0x30]
  00020	eb000000	 bl          SPIWriteRead

; 763  : }

  00024	e89d6000	 ldmia       sp, {sp, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN6@PddGetCont|
  0002c		 |$LN7@PddGetCont|
  0002c	00000000	 DCD         |s_TouchDevice|
  00030		 |$M36878|

			 ENDP  ; |?PddGetControllerData@@YAXIPAI@Z|, PddGetControllerData

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|?PddGetTouchData@@YAHPAI0@Z|		; PddGetTouchData
	IMPORT	|Sleep|
	IMPORT	|__GSHandlerCheck|
	IMPORT	|__security_cookie|
	IMPORT	|__security_check_cookie|

  00000			 AREA	 |.pdata|, PDATA
|$T36949| DCD	|$LN49@PddGetTouc@2|
	DCD	0xc0008202

  00000			 AREA	 |.xdata|, DATA
|$T36945| DCD	0xffffffd8
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T36945|

  00008		 |?PddGetTouchData@@YAHPAI0@Z| PROC	; PddGetTouchData

; 774  : {

  00008		 |$LN49@PddGetTouc@2|
  00008	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  0000c	e24dd014	 sub         sp, sp, #0x14
  00010		 |$M36946|
  00010	e1a09001	 mov         r9, r1
  00014	e1a0a000	 mov         r10, r0
  00018	e59f31ec	 ldr         r3, [pc, #0x1EC]
  0001c	e5933000	 ldr         r3, [r3]
  00020	e58d3010	 str         r3, [sp, #0x10]

; 775  :     UINT32 tempdata = 0;
; 776  :     UINT16 p;
; 777  : 	UINT16 window[MAX_PTS];
; 778  :     UINT32 sum, pxAvg, pyAvg;
; 779  : 	UINT32 variance;
; 780  :     int i;
; 781  : 	int index;
; 782  : 
; 783  :     DEBUGMSG(ZONE_FUNCTION, ( TEXT("PddGetTouchData+\r\n" )) );
; 784  : 
; 785  : 	// Enable ADC
; 786  : 	PddGetControllerData(POWER_MASK, &tempdata);

  00024	e59f81dc	 ldr         r8, [pc, #0x1DC]
  00028	e3a0e000	 mov         lr, #0
  0002c	e3a04801	 mov         r4, #1, 16
  00030	e5980030	 ldr         r0, [r8, #0x30]
  00034	e28d3004	 add         r3, sp, #4
  00038	e28d2000	 add         r2, sp, #0
  0003c	e3a01003	 mov         r1, #3
  00040	e58de004	 str         lr, [sp, #4]
  00044	e58d4000	 str         r4, [sp]
  00048	eb000000	 bl          SPIWriteRead

; 787  : 
; 788  : 	// Get initial X values
; 789  : 	sum = 0;

  0004c	e3a05000	 mov         r5, #0

; 790  : 	for (i = 0; i < MAX_PTS; i++)
; 791  : 	{
; 792  : 		// Ask TSC for the X value
; 793  : 		PddGetControllerData(COMMAND_XPOS, &tempdata);
; 794  : 		p = (UINT16)(tempdata >> 3) & 0xFFF;
; 795  : 
; 796  : 		// Add the value to our array and update the sum
; 797  : 		window[i] = p;

  00050	e28d4008	 add         r4, sp, #8
  00054	e3a06004	 mov         r6, #4
  00058	e3a0760d	 mov         r7, #0xD, 12
  0005c		 |$LL21@PddGetTouc@2|
  0005c	e5980030	 ldr         r0, [r8, #0x30]
  00060	e28d3004	 add         r3, sp, #4
  00064	e28d2000	 add         r2, sp, #0
  00068	e3a01003	 mov         r1, #3
  0006c	e58d7000	 str         r7, [sp]
  00070	eb000000	 bl          SPIWriteRead
  00074	e59d3004	 ldr         r3, [sp, #4]
  00078	e2566001	 subs        r6, r6, #1
  0007c	e1a03883	 mov         r3, r3, lsl #17
  00080	e1a03a23	 mov         r3, r3, lsr #20
  00084	e0c430b2	 strh        r3, [r4], #2

; 798  : 		sum += p;

  00088	e0855003	 add         r5, r5, r3
  0008c	1afffff2	 bne         |$LL21@PddGetTouc@2|

; 799  : 	}
; 800  : 
; 801  : 	// Loop until we get a satisfying X value
; 802  : 	index = 0;

  00090	e3a04000	 mov         r4, #0
  00094	e3a0b60d	 mov         r11, #0xD, 12
  00098	e28d6008	 add         r6, sp, #8
  0009c		 |$LL18@PddGetTouc@2|

; 803  : 	for (;;)
; 804  : 	{
; 805  : 		// Calculate X average
; 806  : 		pxAvg = sum / MAX_PTS;

  0009c	e1a07125	 mov         r7, r5, lsr #2

; 807  : 
; 808  : 		// Calculate X variance (actually the variance multiplied by MAX_PTS)
; 809  : 		variance = 0;

  000a0	e3a02000	 mov         r2, #0
  000a4	e28d1008	 add         r1, sp, #8
  000a8	e3a00004	 mov         r0, #4
  000ac		 |$LL16@PddGetTouc@2|

; 810  : 		for (i = 0; i < MAX_PTS; i++)
; 811  : 			variance += (window[i] - pxAvg) * (window[i] - pxAvg);

  000ac	e0d130b2	 ldrh        r3, [r1], #2
  000b0	e2500001	 subs        r0, r0, #1
  000b4	e0433007	 sub         r3, r3, r7
  000b8	e0222393	 mla         r2, r3, r3, r2
  000bc	1afffffa	 bne         |$LL16@PddGetTouc@2|

; 812  : 				
; 813  : 		// Check if X variance is good enough
; 814  : 		if (variance < ALLOWED_X_STANDARD_DEVIATION * ALLOWED_X_STANDARD_DEVIATION * MAX_PTS)

  000c0	e3520d09	 cmp         r2, #9, 26
  000c4	3a000011	 bcc         |$LN41@PddGetTouc@2|

; 815  : 			break;
; 816  : 
; 817  : 		// Reset index if needed
; 818  : 		if (index == MAX_PTS)
; 819  : 			index = 0;
; 820  : 
; 821  : 		// Ask TSC for a new X value
; 822  : 		PddGetControllerData(COMMAND_XPOS, &tempdata);

  000c8	e5980030	 ldr         r0, [r8, #0x30]
  000cc	e3540004	 cmp         r4, #4
  000d0	e28d3004	 add         r3, sp, #4
  000d4	e28d2000	 add         r2, sp, #0
  000d8	e3a01003	 mov         r1, #3
  000dc	03a04000	 moveq       r4, #0
  000e0	e58db000	 str         r11, [sp]
  000e4	eb000000	 bl          SPIWriteRead

; 823  : 		p = (UINT16)(tempdata >> 3) & 0xFFF;

  000e8	e59d3004	 ldr         r3, [sp, #4]

; 824  : 
; 825  : 		// Update the sum and add the value to our array
; 826  : 		sum -= window[index];

  000ec	e0860084	 add         r0, r6, r4, lsl #1
  000f0	e1d010b0	 ldrh        r1, [r0]
  000f4	e1a03883	 mov         r3, r3, lsl #17
  000f8	e1a02a23	 mov         r2, r3, lsr #20
  000fc	e0453001	 sub         r3, r5, r1

; 827  : 		window[index++] = p;
; 828  : 		sum += p;

  00100	e0835002	 add         r5, r3, r2
  00104	e1c020b0	 strh        r2, [r0]
  00108	e2844001	 add         r4, r4, #1

; 829  : 	}

  0010c	eaffffe2	 b           |$LL18@PddGetTouc@2|
  00110		 |$LN41@PddGetTouc@2|

; 830  : 
; 831  : 	// Get initial Y values
; 832  : 	sum = 0;

  00110	e3a06000	 mov         r6, #0
  00114	e28d4008	 add         r4, sp, #8
  00118	e3a05004	 mov         r5, #4
  0011c	e3a0b609	 mov         r11, #9, 12
  00120		 |$LL11@PddGetTouc@2|

; 833  : 	for (i = 0; i < MAX_PTS; i++)
; 834  : 	{
; 835  : 		// Ask TSC for the Y value
; 836  : 		PddGetControllerData(COMMAND_YPOS, &tempdata);

  00120	e5980030	 ldr         r0, [r8, #0x30]
  00124	e28d3004	 add         r3, sp, #4
  00128	e28d2000	 add         r2, sp, #0
  0012c	e3a01003	 mov         r1, #3
  00130	e58db000	 str         r11, [sp]
  00134	eb000000	 bl          SPIWriteRead

; 837  : 		p = (UINT16)(tempdata >> 3) & 0xFFF;

  00138	e59d3004	 ldr         r3, [sp, #4]
  0013c	e2555001	 subs        r5, r5, #1
  00140	e1a03883	 mov         r3, r3, lsl #17
  00144	e1a03a23	 mov         r3, r3, lsr #20

; 838  : 
; 839  : 		// Add the value to our array and update the sum
; 840  : 		window[i] = p;

  00148	e0c430b2	 strh        r3, [r4], #2

; 841  : 		sum += p;

  0014c	e0866003	 add         r6, r6, r3
  00150	1afffff2	 bne         |$LL11@PddGetTouc@2|

; 842  : 	}
; 843  : 
; 844  : 	// Loop until we get a satisfying Y value
; 845  : 	index = 0;

  00154	e3a04000	 mov         r4, #0
  00158	e3a0b609	 mov         r11, #9, 12
  0015c	e28d5008	 add         r5, sp, #8
  00160		 |$LL8@PddGetTouc@2|

; 846  : 	for (;;)
; 847  : 	{
; 848  : 		// Calculate Y average
; 849  : 		pyAvg = sum / MAX_PTS;

  00160	e1a02126	 mov         r2, r6, lsr #2

; 850  : 
; 851  : 		// Calculate Y variance (actually the variance multiplied by MAX_PTS)
; 852  : 		variance = 0;

  00164	e3a01000	 mov         r1, #0
  00168	e28d0008	 add         r0, sp, #8
  0016c	e3a0e004	 mov         lr, #4
  00170		 |$LL6@PddGetTouc@2|

; 853  : 		for (i = 0; i < MAX_PTS; i++)
; 854  : 			variance += (window[i] - pyAvg) * (window[i] - pyAvg);

  00170	e0d030b2	 ldrh        r3, [r0], #2
  00174	e25ee001	 subs        lr, lr, #1
  00178	e0433002	 sub         r3, r3, r2
  0017c	e0211393	 mla         r1, r3, r3, r1
  00180	1afffffa	 bne         |$LL6@PddGetTouc@2|

; 855  : 				
; 856  : 		// Check if Y variance is good enough
; 857  : 		if (variance < ALLOWED_Y_STANDARD_DEVIATION * ALLOWED_Y_STANDARD_DEVIATION * MAX_PTS)

  00184	e3510d09	 cmp         r1, #9, 26
  00188	3a000011	 bcc         |$LN42@PddGetTouc@2|

; 858  : 			break;
; 859  : 
; 860  : 		// Reset index if needed
; 861  : 		if (index == MAX_PTS)
; 862  : 			index = 0;
; 863  : 
; 864  : 		// Ask TSC for a new Y value
; 865  : 		PddGetControllerData(COMMAND_YPOS, &tempdata);

  0018c	e5980030	 ldr         r0, [r8, #0x30]
  00190	e3540004	 cmp         r4, #4
  00194	e28d3004	 add         r3, sp, #4
  00198	e28d2000	 add         r2, sp, #0
  0019c	e3a01003	 mov         r1, #3
  001a0	03a04000	 moveq       r4, #0
  001a4	e58db000	 str         r11, [sp]
  001a8	eb000000	 bl          SPIWriteRead

; 866  : 		p = (UINT16)(tempdata >> 3) & 0xFFF;

  001ac	e59d3004	 ldr         r3, [sp, #4]

; 867  : 
; 868  : 		// Update the sum and add the value to our array
; 869  : 		sum -= window[index];

  001b0	e0850084	 add         r0, r5, r4, lsl #1
  001b4	e1d010b0	 ldrh        r1, [r0]
  001b8	e1a03883	 mov         r3, r3, lsl #17
  001bc	e1a02a23	 mov         r2, r3, lsr #20
  001c0	e0463001	 sub         r3, r6, r1

; 870  : 		window[index++] = p;
; 871  : 		sum += p;

  001c4	e0836002	 add         r6, r3, r2
  001c8	e1c020b0	 strh        r2, [r0]
  001cc	e2844001	 add         r4, r4, #1

; 872  :     }

  001d0	eaffffe2	 b           |$LL8@PddGetTouc@2|
  001d4		 |$LN42@PddGetTouc@2|

; 873  : 
; 874  :     *xpos = pxAvg;

  001d4	e58a7000	 str         r7, [r10]

; 875  :     *ypos = pyAvg;

  001d8	e5892000	 str         r2, [r9]

; 876  :     
; 877  :     // Possibly Pen Up, give pen status detection a chance to debounce
; 878  :     if(pyAvg == 0 && s_TouchDevice.nPenUpDebounceMS) 

  001dc	e3520000	 cmp         r2, #0
  001e0	1a000002	 bne         |$LN1@PddGetTouc@2|
  001e4	e5980010	 ldr         r0, [r8, #0x10]
  001e8	e3500000	 cmp         r0, #0

; 879  :         Sleep(s_TouchDevice.nPenUpDebounceMS);

  001ec	1b000000	 blne        Sleep
  001f0		 |$LN1@PddGetTouc@2|

; 880  : 
; 881  :     DEBUGMSG(ZONE_FUNCTION, ( TEXT("PddGetTouchData-\r\n" )) );
; 882  : 
; 883  :     return TRUE;

  001f0	e59d0010	 ldr         r0, [sp, #0x10]
  001f4	eb000000	 bl          __security_check_cookie
  001f8	e3a00001	 mov         r0, #1

; 884  : }

  001fc	e28dd014	 add         sp, sp, #0x14
  00200	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00204	e12fff1e	 bx          lr
  00208		 |$LN50@PddGetTouc@2|
  00208		 |$LN51@PddGetTouc@2|
  00208	00000000	 DCD         |s_TouchDevice|
  0020c		 |$LN52@PddGetTouc@2|
  0020c	00000000	 DCD         |__security_cookie|
  00210		 |$M36947|

			 ENDP  ; |?PddGetTouchData@@YAHPAI0@Z|, PddGetTouchData

	EXPORT	|__$ArrayPad$| [ DATA ]
	EXPORT	|??_C@_1GI@JJECIELC@?$AAt?$AAo?$AAu?$AAc?$AAh?$AAp?$AA?3?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1FI@LNOAEKNM@?$AAt?$AAo?$AAu?$AAc?$AAh?$AAp?$AA?3?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CM@DKJPPKPA@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?1?$AAG?$AAw?$AAe?$AAA?$AAp?$AAi?$AAS?$AAe?$AAt?$AAR?$AAe?$AAa?$AAd?$AAy?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CA@BNLIHNAH@?$AAC?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@PPKDPGKC@?$AAH?$AAA?$AAR?$AAD?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAM?$AAA?$AAP?$AA?2?$AAT?$AAO?$AAU?$AAC?$AAH?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|
	IMPORT	|TouchCalibrate|
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|
	IMPORT	|OpenEventW|
	IMPORT	|RegCloseKey|
	IMPORT	|RegQueryValueExW|
	IMPORT	|RegOpenKeyExW|

  00000			 AREA	 |.pdata|, PDATA
|$T36972| DCD	|$LN16@Calibratio|
	DCD	0xc0005f02

  00000			 AREA	 |.xdata|, DATA
|$T36968| DCD	0xffffffec

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@JJECIELC@?$AAt?$AAo?$AAu?$AAc?$AAh?$AAp?$AA?3?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa@| DCB "t"
	DCB	0x0, "o", 0x0, "u", 0x0, "c", 0x0, "h", 0x0, "p", 0x0, ":"
	DCB	0x0, " ", 0x0, "c", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "b"
	DCB	0x0, "r", 0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n"
	DCB	0x0, ":", 0x0, " ", 0x0, "n", 0x0, "e", 0x0, "w", 0x0, " "
	DCB	0x0, "c", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "b", 0x0, "r"
	DCB	0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, " "
	DCB	0x0, "d", 0x0, "a", 0x0, "t", 0x0, "a", 0x0, " ", 0x0, "i"
	DCB	0x0, "s", 0x0, " ", 0x0, """", 0x0, "%", 0x0, "s", 0x0, """"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1FI@LNOAEKNM@?$AAt?$AAo?$AAu?$AAc?$AAh?$AAp?$AA?3?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5@| DCB "t"
	DCB	0x0, "o", 0x0, "u", 0x0, "c", 0x0, "h", 0x0, "p", 0x0, ":"
	DCB	0x0, " ", 0x0, "c", 0x0, "a", 0x0, "l", 0x0, "i", 0x0, "b"
	DCB	0x0, "r", 0x0, "a", 0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n"
	DCB	0x0, ":", 0x0, " ", 0x0, "C", 0x0, "a", 0x0, "n", 0x0, "'"
	DCB	0x0, "t", 0x0, " ", 0x0, "f", 0x0, "i", 0x0, "n", 0x0, "d"
	DCB	0x0, " ", 0x0, "[", 0x0, "H", 0x0, "K", 0x0, "L", 0x0, "M"
	DCB	0x0, "/", 0x0, "%", 0x0, "s", 0x0, "]", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CM@DKJPPKPA@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?1?$AAG?$AAw?$AAe?$AAA?$AAp?$AAi?$AAS?$AAe?$AAt?$AAR?$AAe?$AAa?$AAd?$AAy?$AA?$AA@| DCB "S"
	DCB	0x0, "Y", 0x0, "S", 0x0, "T", 0x0, "E", 0x0, "M", 0x0, "/"
	DCB	0x0, "G", 0x0, "w", 0x0, "e", 0x0, "A", 0x0, "p", 0x0, "i"
	DCB	0x0, "S", 0x0, "e", 0x0, "t", 0x0, "R", 0x0, "e", 0x0, "a"
	DCB	0x0, "d", 0x0, "y", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1CA@BNLIHNAH@?$AAC?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@| DCB "C"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "b", 0x0, "r", 0x0, "a"
	DCB	0x0, "t", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, "D", 0x0, "a"
	DCB	0x0, "t", 0x0, "a", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DC@PPKDPGKC@?$AAH?$AAA?$AAR?$AAD?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAM?$AAA?$AAP?$AA?2?$AAT?$AAO?$AAU?$AAC?$AAH?$AA?$AA@| DCB "H"
	DCB	0x0, "A", 0x0, "R", 0x0, "D", 0x0, "W", 0x0, "A", 0x0, "R"
	DCB	0x0, "E", 0x0, "\\", 0x0, "D", 0x0, "E", 0x0, "V", 0x0, "I"
	DCB	0x0, "C", 0x0, "E", 0x0, "M", 0x0, "A", 0x0, "P", 0x0, "\\"
	DCB	0x0, "T", 0x0, "O", 0x0, "U", 0x0, "C", 0x0, "H", 0x0, 0x0
	DCB	0x0					; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000	00000000	 DCD         |__GSHandlerCheck|
  00004	00000000	 DCD         |$T36968|

  00008		 |?CalibrationThread@@YAKXZ| PROC	; CalibrationThread

; 892  : {

  00008		 |$LN16@Calibratio|
  00008	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  0000c	e24dd0e0	 sub         sp, sp, #0xE0
  00010		 |$M36969|
  00010	e59f3168	 ldr         r3, [pc, #0x168]
  00014	e5933000	 ldr         r3, [r3]
  00018	e58d30dc	 str         r3, [sp, #0xDC]

; 893  :     HKEY hKey;
; 894  :     DWORD dwType;
; 895  :     LONG lResult;
; 896  :     HANDLE hAPIs;
; 897  : 
; 898  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("CalibrationThread+\r\n")));    
; 899  : 
; 900  :     // try to open [HKLM\hardware\devicemap\touch] key
; 901  :     if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, RK_HARDWARE_DEVICEMAP_TOUCH, 0, KEY_ALL_ACCESS, &hKey))

  0001c	e59f1150	 ldr         r1, [pc, #0x150]
  00020	e3a0680f	 mov         r6, #0xF, 16
  00024	e28de008	 add         lr, sp, #8
  00028	e386303f	 orr         r3, r6, #0x3F
  0002c	e3a02000	 mov         r2, #0
  00030	e3a0010a	 mov         r0, #0xA, 2
  00034	e58de000	 str         lr, [sp]
  00038	eb000000	 bl          RegOpenKeyExW
  0003c	e3500000	 cmp         r0, #0
  00040	0a000003	 beq         |$LN5@Calibratio|
  00044		 |$LN13@Calibratio|

; 902  :     {
; 903  :         DEBUGMSG(ZONE_CALIBRATE, (TEXT("touchp: calibration: Can't find [HKLM/%s]\r\n"), RK_HARDWARE_DEVICEMAP_TOUCH));
; 904  :         return 0;

  00044	e59d00dc	 ldr         r0, [sp, #0xDC]
  00048	eb000000	 bl          __security_check_cookie
  0004c	e3a00000	 mov         r0, #0
  00050	ea000042	 b           |$LN6@Calibratio|
  00054		 |$LN5@Calibratio|

; 905  :     }
; 906  : 
; 907  :     // check for calibration data (query the type of data only)
; 908  :     lResult = RegQueryValueEx(hKey, RV_CALIBRATION_DATA, 0, &dwType, NULL, NULL);

  00054	e59d0008	 ldr         r0, [sp, #8]
  00058	e59f1110	 ldr         r1, [pc, #0x110]
  0005c	e3a05000	 mov         r5, #0
  00060	e28d300c	 add         r3, sp, #0xC
  00064	e3a02000	 mov         r2, #0
  00068	e58d5004	 str         r5, [sp, #4]
  0006c	e58d5000	 str         r5, [sp]
  00070	eb000000	 bl          RegQueryValueExW
  00074	e1a04000	 mov         r4, r0

; 909  :     RegCloseKey(hKey);

  00078	e59d0008	 ldr         r0, [sp, #8]
  0007c	eb000000	 bl          RegCloseKey

; 910  :     if (lResult == ERROR_SUCCESS)

  00080	e3540000	 cmp         r4, #0

; 911  :     {
; 912  :         // registry contains calibration data, return
; 913  :         return 1;

  00084	0a000032	 beq         |$LN12@Calibratio|

; 914  :     }
; 915  : 
; 916  :     hAPIs = OpenEvent(EVENT_ALL_ACCESS, FALSE, TEXT("SYSTEM/GweApiSetReady"));

  00088	e59f20ec	 ldr         r2, [pc, #0xEC]
  0008c	e3a0381f	 mov         r3, #0x1F, 16
  00090	e3830003	 orr         r0, r3, #3
  00094	e3a01000	 mov         r1, #0
  00098	eb000000	 bl          OpenEventW
  0009c	e1b04000	 movs        r4, r0

; 917  :     if (hAPIs)

  000a0	0a000004	 beq         |$LN3@Calibratio|

; 918  :     {
; 919  :         WaitForSingleObject(hAPIs, INFINITE);

  000a4	e3e01000	 mvn         r1, #0
  000a8	e1a00004	 mov         r0, r4
  000ac	eb000000	 bl          WaitForSingleObject

; 920  :         CloseHandle(hAPIs);

  000b0	e1a00004	 mov         r0, r4
  000b4	eb000000	 bl          CloseHandle
  000b8		 |$LN3@Calibratio|

; 921  :     }
; 922  : 
; 923  :     // Perform calibration
; 924  :     TouchCalibrate();

  000b8	eb000000	 bl          TouchCalibrate

; 925  : 
; 926  :     // try to open [HKLM\hardware\devicemap\touch] key
; 927  :     if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, RK_HARDWARE_DEVICEMAP_TOUCH, 0, KEY_ALL_ACCESS, &hKey))

  000bc	e59f10b0	 ldr         r1, [pc, #0xB0]
  000c0	e28d3008	 add         r3, sp, #8
  000c4	e58d3000	 str         r3, [sp]
  000c8	e386303f	 orr         r3, r6, #0x3F
  000cc	e3a02000	 mov         r2, #0
  000d0	e3a0010a	 mov         r0, #0xA, 2
  000d4	eb000000	 bl          RegOpenKeyExW
  000d8	e3500000	 cmp         r0, #0
  000dc	0a000003	 beq         |$LN2@Calibratio|

; 928  :     {
; 929  :         RETAILMSG(1, (TEXT("touchp: calibration: Can't find [HKLM/%s]\r\n"), RK_HARDWARE_DEVICEMAP_TOUCH));

  000e0	e59f0090	 ldr         r0, [pc, #0x90]
  000e4	e59f1088	 ldr         r1, [pc, #0x88]
  000e8	eb000000	 bl          NKDbgPrintfW

; 930  :         return 0;

  000ec	eaffffd4	 b           |$LN13@Calibratio|
  000f0		 |$LN2@Calibratio|

; 931  :     }
; 932  : 
; 933  :     // display new calibration data
; 934  :     lResult = RegQueryValueEx(hKey, RV_CALIBRATION_DATA, 0, &dwType, NULL, NULL);

  000f0	e59d0008	 ldr         r0, [sp, #8]
  000f4	e59f1074	 ldr         r1, [pc, #0x74]
  000f8	e28d300c	 add         r3, sp, #0xC
  000fc	e3a02000	 mov         r2, #0
  00100	e58d5004	 str         r5, [sp, #4]
  00104	e58d5000	 str         r5, [sp]
  00108	eb000000	 bl          RegQueryValueExW
  0010c	e3500000	 cmp         r0, #0

; 935  :     if (lResult == ERROR_SUCCESS)

  00110	1a00000d	 bne         |$LN11@Calibratio|

; 936  :     {
; 937  :         TCHAR szCalibrationData[100];
; 938  :         DWORD Size = sizeof(szCalibrationData);
; 939  : 
; 940  :         RegQueryValueEx(hKey, RV_CALIBRATION_DATA, 0, &dwType, (BYTE *) szCalibrationData, (DWORD *) &Size);

  00114	e59d0008	 ldr         r0, [sp, #8]
  00118	e59f1050	 ldr         r1, [pc, #0x50]
  0011c	e3a050c8	 mov         r5, #0xC8
  00120	e28de010	 add         lr, sp, #0x10
  00124	e28d4014	 add         r4, sp, #0x14
  00128	e28d300c	 add         r3, sp, #0xC
  0012c	e3a02000	 mov         r2, #0
  00130	e58d5010	 str         r5, [sp, #0x10]
  00134	e58de004	 str         lr, [sp, #4]
  00138	e58d4000	 str         r4, [sp]
  0013c	eb000000	 bl          RegQueryValueExW

; 941  :         RETAILMSG(1, (TEXT("touchp: calibration: new calibration data is \"%s\"\r\n"), szCalibrationData));

  00140	e59f0024	 ldr         r0, [pc, #0x24]
  00144	e28d1014	 add         r1, sp, #0x14
  00148	eb000000	 bl          NKDbgPrintfW
  0014c		 |$LN11@Calibratio|

; 942  :     }
; 943  :     RegCloseKey(hKey);

  0014c	e59d0008	 ldr         r0, [sp, #8]
  00150	eb000000	 bl          RegCloseKey
  00154		 |$LN12@Calibratio|

; 944  :     
; 945  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("CalibrationThread-\r\n")));    
; 946  : 
; 947  :     return 1;

  00154	e59d00dc	 ldr         r0, [sp, #0xDC]
  00158	eb000000	 bl          __security_check_cookie
  0015c	e3a00001	 mov         r0, #1
  00160		 |$LN6@Calibratio|

; 948  : }

  00160	e28dd0e0	 add         sp, sp, #0xE0
  00164	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  00168	e12fff1e	 bx          lr
  0016c		 |$LN17@Calibratio|
  0016c		 |$LN18@Calibratio|
  0016c	00000000	 DCD         |??_C@_1GI@JJECIELC@?$AAt?$AAo?$AAu?$AAc?$AAh?$AAp?$AA?3?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAn?$AAe?$AAw?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa@|
  00170		 |$LN19@Calibratio|
  00170	00000000	 DCD         |??_C@_1CA@BNLIHNAH@?$AAC?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AAD?$AAa?$AAt?$AAa?$AA?$AA@|
  00174		 |$LN20@Calibratio|
  00174	00000000	 DCD         |??_C@_1DC@PPKDPGKC@?$AAH?$AAA?$AAR?$AAD?$AAW?$AAA?$AAR?$AAE?$AA?2?$AAD?$AAE?$AAV?$AAI?$AAC?$AAE?$AAM?$AAA?$AAP?$AA?2?$AAT?$AAO?$AAU?$AAC?$AAH?$AA?$AA@|
  00178		 |$LN21@Calibratio|
  00178	00000000	 DCD         |??_C@_1FI@LNOAEKNM@?$AAt?$AAo?$AAu?$AAc?$AAh?$AAp?$AA?3?$AA?5?$AAc?$AAa?$AAl?$AAi?$AAb?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?3?$AA?5?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAf?$AAi?$AAn?$AAd?$AA?5@|
  0017c		 |$LN22@Calibratio|
  0017c	00000000	 DCD         |??_C@_1CM@DKJPPKPA@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?1?$AAG?$AAw?$AAe?$AAA?$AAp?$AAi?$AAS?$AAe?$AAt?$AAR?$AAe?$AAa?$AAd?$AAy?$AA?$AA@|
  00180		 |$LN23@Calibratio|
  00180	00000000	 DCD         |__security_cookie|
  00184		 |$M36970|

			 ENDP  ; |?CalibrationThread@@YAKXZ|, CalibrationThread

	EXPORT	|?StartCalibrationThread@@YAXXZ|	; StartCalibrationThread
	IMPORT	|CreateThread|

  00000			 AREA	 |.pdata|, PDATA
|$T36988| DCD	|$LN5@StartCalib|
	DCD	0x40000f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?StartCalibrationThread@@YAXXZ| PROC	; StartCalibrationThread

; 951  : {

  00000		 |$LN5@StartCalib|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M36985|

; 952  :     HANDLE hThread;
; 953  :     
; 954  :     hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CalibrationThread, NULL, 0, NULL);

  00008	e59f2028	 ldr         r2, [pc, #0x28]
  0000c	e3a0e000	 mov         lr, #0
  00010	e3a03000	 mov         r3, #0
  00014	e3a01000	 mov         r1, #0
  00018	e3a00000	 mov         r0, #0
  0001c	e58de004	 str         lr, [sp, #4]
  00020	e58de000	 str         lr, [sp]
  00024	eb000000	 bl          CreateThread

; 955  :     // We don't need the handle, close it here
; 956  :     CloseHandle(hThread);

  00028	eb000000	 bl          CloseHandle

; 957  : }

  0002c	e28dd008	 add         sp, sp, #8
  00030	e49de004	 ldr         lr, [sp], #4
  00034	e12fff1e	 bx          lr
  00038		 |$LN6@StartCalib|
  00038		 |$LN7@StartCalib|
  00038	00000000	 DCD         |?CalibrationThread@@YAKXZ|
  0003c		 |$M36986|

			 ENDP  ; |?StartCalibrationThread@@YAXXZ|, StartCalibrationThread

	EXPORT	|DdsiTouchPanelDisable|
	IMPORT	|KernelIoControl|

  00000			 AREA	 |.pdata|, PDATA
|$T36997| DCD	|$LN6@DdsiTouchP@6|
	DCD	0x40001602
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelDisable| PROC

; 405  : {

  00000		 |$LN6@DdsiTouchP@6|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M36994|

; 406  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelDisable+\r\n")));
; 407  : 
; 408  :     // Close pen event and kill thread.
; 409  :     PddDeinitializeHardware();

  00008	eb000000	 bl          |?PddDeinitializeHardware@@YAXXZ|

; 410  :         
; 411  :     // Release interrupt
; 412  :     if (gIntrTouch != 0) 

  0000c	e59f1040	 ldr         r1, [pc, #0x40]
  00010	e5913000	 ldr         r3, [r1]
  00014	e3530000	 cmp         r3, #0

; 413  :         {
; 414  :         KernelIoControl(
; 415  :             IOCTL_HAL_RELEASE_SYSINTR, 
; 416  :             &gIntrTouch, 
; 417  :             sizeof(gIntrTouch), 
; 418  :             NULL, 
; 419  :             0, 
; 420  :             NULL
; 421  :             );

  00018	159f0030	 ldrne       r0, [pc, #0x30]
  0001c	13a0e000	 movne       lr, #0
  00020	13a03000	 movne       r3, #0
  00024	13a02004	 movne       r2, #4
  00028	158de004	 strne       lr, [sp, #4]
  0002c	158de000	 strne       lr, [sp]
  00030	1b000000	 blne        KernelIoControl

; 422  :         }
; 423  : 
; 424  :     s_TouchDevice.bInitialized = FALSE;

  00034	e59f3010	 ldr         r3, [pc, #0x10]
  00038	e3a02000	 mov         r2, #0
  0003c	e5832000	 str         r2, [r3]

; 425  : 
; 426  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelDisable-\r\n")));
; 427  : }

  00040	e28dd008	 add         sp, sp, #8
  00044	e49de004	 ldr         lr, [sp], #4
  00048	e12fff1e	 bx          lr
  0004c		 |$LN7@DdsiTouchP@6|
  0004c		 |$LN8@DdsiTouchP@6|
  0004c	00000000	 DCD         |s_TouchDevice|
  00050		 |$LN9@DdsiTouchP@6|
  00050	010100d8	 DCD         0x10100d8
  00054		 |$LN10@DdsiTouchP@6|
  00054	00000000	 DCD         |gIntrTouch|
  00058		 |$M36995|

			 ENDP  ; |DdsiTouchPanelDisable|

	EXPORT	|DdsiTouchPanelGetPoint|
	IMPORT	|InterruptDone|
	IMPORT	|gdwTouchIstTimeout|
	IMPORT	|__rt_udiv|

  00000			 AREA	 |.bss|, NOINIT
|?usSavedFilteredY@?1??DdsiTouchPanelGetPoint@@9@4GA| % 0x2 ; `DdsiTouchPanelGetPoint'::`2'::usSavedFilteredY

  00000			 AREA	 |.bss|, NOINIT
|?usSavedFilteredX@?1??DdsiTouchPanelGetPoint@@9@4GA| % 0x2 ; `DdsiTouchPanelGetPoint'::`2'::usSavedFilteredX

  00000			 AREA	 |.bss|, NOINIT
|?usLastFilteredX@?1??DdsiTouchPanelGetPoint@@9@4GA| % 0x2 ; `DdsiTouchPanelGetPoint'::`2'::usLastFilteredX

  00000			 AREA	 |.bss|, NOINIT
|?usLastFilteredY@?1??DdsiTouchPanelGetPoint@@9@4GA| % 0x2 ; `DdsiTouchPanelGetPoint'::`2'::usLastFilteredY

  00000			 AREA	 |.bss|, NOINIT
|?bPrevReportedPenDown@?1??DdsiTouchPanelGetPoint@@9@4HA| % 0x4 ; `DdsiTouchPanelGetPoint'::`2'::bPrevReportedPenDown

  00000			 AREA	 |.bss|, NOINIT
|?DelayedSampleCount@?1??DdsiTouchPanelGetPoint@@9@4KA| % 0x4 ; `DdsiTouchPanelGetPoint'::`2'::DelayedSampleCount

  00000			 AREA	 |.pdata|, PDATA
|$T37034| DCD	|$LN26@DdsiTouchP@7|
	DCD	0x40006e02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelGetPoint| PROC

; 478  : {

  00000		 |$LN26@DdsiTouchP@7|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd014	 sub         sp, sp, #0x14
  00008		 |$M37031|
  00008	e1a03000	 mov         r3, r0
  0000c	e58d3010	 str         r3, [sp, #0x10]
  00010	e58d200c	 str         r2, [sp, #0xC]
  00014	e58d1008	 str         r1, [sp, #8]

; 479  :     // MDD needs us to hold on to last valid sample and previous pen state.
; 480  :     static USHORT usLastFilteredX       = 0;    // This holds the previous X sample
; 481  :     static USHORT usLastFilteredY       = 0;    // This holds the previous Y sample
; 482  :     static USHORT usSavedFilteredX      = 0;    // This holds the last reported X sample
; 483  :     static USHORT usSavedFilteredY      = 0;    // This holds the last reported Y sample
; 484  :     static BOOL bPrevReportedPenDown    = FALSE;
; 485  :     static DWORD DelayedSampleCount     = 0;
; 486  :     
; 487  :     BOOL bReportedPenDown               = FALSE; // This indicates if we are reporting pen down to the mdd  
; 488  :     BOOL bActualPenDown                 = FALSE; // This indicates if the pen is actually down, whether we report or not
; 489  :     UINT32 xpos = 0;
; 490  :     UINT32 ypos = 0;
; 491  : 
; 492  :     DEBUGMSG(ZONE_FUNCTION&&ZONE_SAMPLES, (TEXT("DdsiTouchPanelGetPoint+\r\n")));
; 493  : 
; 494  :     // By default, any sample returned will be ignored.
; 495  :     *pTipStateFlags = TouchSampleIgnore;
; 496  : 
; 497  :     // Check if pen data are available If so, get the data.
; 498  :     // Note that we always return data from the previous sample to avoid returning data nearest
; 499  :     // the point where the pen is going up.  Data during light touches is not accurate and should
; 500  :     // normally be rejected.  Without the ability to do pressure measurement, we are limited to 
; 501  :     // rejecting points near the beginning and end of the pen down period.
; 502  :     bActualPenDown = PddGetTouchIntPinState();

  00018	e59f6194	 ldr         r6, [pc, #0x194]
  0001c	e3a02010	 mov         r2, #0x10
  00020	e5832000	 str         r2, [r3]
  00024	e596100c	 ldr         r1, [r6, #0xC]
  00028	e596002c	 ldr         r0, [r6, #0x2C]
  0002c	e3a04000	 mov         r4, #0
  00030	e3a05000	 mov         r5, #0
  00034	e3a0b000	 mov         r11, #0
  00038	e58d4000	 str         r4, [sp]
  0003c	e58d5004	 str         r5, [sp, #4]
  00040	eb000000	 bl          GPIOGetBit
  00044	e59f7164	 ldr         r7, [pc, #0x164]
  00048	e59fa15c	 ldr         r10, [pc, #0x15C]
  0004c	e59f8154	 ldr         r8, [pc, #0x154]
  00050	e59f914c	 ldr         r9, [pc, #0x14C]
  00054	e3500000	 cmp         r0, #0

; 503  :     if (bActualPenDown == TRUE)

  00058	1a000024	 bne         |$LN23@DdsiTouchP@7|

; 504  :     {
; 505  :         PddGetTouchData(&xpos, &ypos);

  0005c	e28d1004	 add         r1, sp, #4
  00060	e28d0000	 add         r0, sp, #0
  00064	eb000000	 bl          |?PddGetTouchData@@YAHPAI0@Z|

; 506  :         
; 507  :         // Check if pen is still down to validate the data.
; 508  :         bActualPenDown = PddGetTouchIntPinState();

  00068	e596100c	 ldr         r1, [r6, #0xC]
  0006c	e596002c	 ldr         r0, [r6, #0x2C]
  00070	eb000000	 bl          GPIOGetBit
  00074	e3500000	 cmp         r0, #0
  00078	1a00001a	 bne         |$LN18@DdsiTouchP@7|

; 510  :         {
; 511  :             if (DelayedSampleCount > s_TouchDevice.nInitialSamplesDropped)

  0007c	e5972000	 ldr         r2, [r7]
  00080	e5963008	 ldr         r3, [r6, #8]
  00084	e3a0e001	 mov         lr, #1
  00088	e1520003	 cmp         r2, r3
  0008c	9a000010	 bls         |$LN7@DdsiTouchP@7|

; 525  :     {
; 526  :         // Return the valid pen data.  Note that this data was actually obtained on the
; 527  :         // previous sample
; 528  :         *pUncalX = usLastFilteredX;

  00090	e1d900b0	 ldrh        r0, [r9]

; 529  :         *pUncalY = usLastFilteredY;
; 530  :         
; 531  :         // Save the data that we returned.  
; 532  :         // This will also be returned on penup to help avoid returning data obtained during
; 533  :         // a light press
; 534  :         usSavedFilteredX = usLastFilteredX;
; 535  :         usSavedFilteredY = usLastFilteredY;

  00094	e59d4008	 ldr         r4, [sp, #8]
  00098	e1d810b0	 ldrh        r1, [r8]
  0009c	e59f30fc	 ldr         r3, [pc, #0xFC]
  000a0	e5840000	 str         r0, [r4]
  000a4	e59d400c	 ldr         r4, [sp, #0xC]
  000a8	e59f20ec	 ldr         r2, [pc, #0xEC]

; 536  :         
; 537  :         DEBUGMSG(ZONE_SAMPLES, ( TEXT( "X(0x%X) Y(0x%X)\r\n" ), *pUncalX, *pUncalY ) );
; 538  :         
; 539  :         // Store reported pen state.
; 540  :         *pTipStateFlags = TouchSampleDownFlag | TouchSampleValidFlag;

  000ac	e3a05003	 mov         r5, #3
  000b0	e5841000	 str         r1, [r4]
  000b4	e59d4010	 ldr         r4, [sp, #0x10]
  000b8	e3a0b001	 mov         r11, #1

; 541  :     }
; 542  :     else    // Otherwise, assume pen is up.

  000bc	e1c300b0	 strh        r0, [r3]
  000c0	e5845000	 str         r5, [r4]
  000c4	e59d4000	 ldr         r4, [sp]
  000c8	e59d5004	 ldr         r5, [sp, #4]
  000cc	e1c210b0	 strh        r1, [r2]
  000d0	ea000015	 b           |$LN3@DdsiTouchP@7|
  000d4		 |$LN7@DdsiTouchP@7|

; 512  :             {
; 513  :                 // Indicate pen down so we can return valid data.
; 514  :                 bReportedPenDown = TRUE;
; 515  :             }
; 516  :             else
; 517  :             {
; 518  :                 DelayedSampleCount++;

  000d4	e2823001	 add         r3, r2, #1

; 519  :             }
; 520  :         }
; 521  :     }
; 522  : 
; 523  :     // Check if we have valid data to report to the MDD.
; 524  :     if (bReportedPenDown)

  000d8	e59d4000	 ldr         r4, [sp]
  000dc	e59d5004	 ldr         r5, [sp, #4]
  000e0	e5873000	 str         r3, [r7]
  000e4	ea000002	 b           |$LN5@DdsiTouchP@7|

; 506  :         
; 507  :         // Check if pen is still down to validate the data.
; 508  :         bActualPenDown = PddGetTouchIntPinState();

  000e8		 |$LN18@DdsiTouchP@7|

; 509  :         if (bActualPenDown == TRUE)

  000e8	e59d4000	 ldr         r4, [sp]
  000ec	e59d5004	 ldr         r5, [sp, #4]
  000f0		 |$LN23@DdsiTouchP@7|
  000f0	e3a0e000	 mov         lr, #0
  000f4		 |$LN5@DdsiTouchP@7|

; 543  :     {
; 544  :         // Check if previously down and valid.
; 545  :         if ( bPrevReportedPenDown )

  000f4	e59a3000	 ldr         r3, [r10]
  000f8	e3530000	 cmp         r3, #0
  000fc	0a00000a	 beq         |$LN3@DdsiTouchP@7|

; 546  :         {
; 547  :             DEBUGMSG(ZONE_TIPSTATE, ( TEXT( "Pen Up!\r\n" ) ) );
; 548  : 
; 549  :             // Use the last valid sample. MDD needs an up with valid data.
; 550  :             *pUncalX = usSavedFilteredX;

  00100	e59f3098	 ldr         r3, [pc, #0x98]

; 551  :             *pUncalY = usSavedFilteredY;

  00104	e59f2090	 ldr         r2, [pc, #0x90]

; 552  :             *pTipStateFlags = TouchSampleValidFlag;

  00108	e3a00001	 mov         r0, #1
  0010c	e1d310b0	 ldrh        r1, [r3]
  00110	e1d230b0	 ldrh        r3, [r2]
  00114	e59d2008	 ldr         r2, [sp, #8]
  00118	e5821000	 str         r1, [r2]
  0011c	e59d200c	 ldr         r2, [sp, #0xC]
  00120	e5823000	 str         r3, [r2]
  00124	e59d3010	 ldr         r3, [sp, #0x10]
  00128	e5830000	 str         r0, [r3]
  0012c		 |$LN3@DdsiTouchP@7|

; 553  :         }
; 554  :         DEBUGMSG(ZONE_SAMPLES, ( TEXT( "Point: (%d,%d)\r\n" ), *pUncalX, *pUncalY ) );
; 555  :     }
; 556  :         
; 557  :     // Save current reported pen state.
; 558  :     bPrevReportedPenDown = bReportedPenDown;

  0012c	e58ab000	 str         r11, [r10]

; 559  : 
; 560  :     // Set up interrupt/timer for next sample
; 561  :     if (bActualPenDown)

  00130	e35e0000	 cmp         lr, #0
  00134	0a000007	 beq         |$LN2@DdsiTouchP@7|

; 562  :     {
; 563  :         // Pen down so set MDD timeout for polling mode.
; 564  :         gdwTouchIstTimeout = 1000 / s_TouchDevice.nSampleRate;

  00138	e5960004	 ldr         r0, [r6, #4]
  0013c	e3a01ffa	 mov         r1, #0xFA, 30
  00140	eb000000	 bl          __rt_udiv
  00144	e59f3048	 ldr         r3, [pc, #0x48]

; 565  :         // Save point measured during this sample so it can be reported on the next sample
; 566  :         usLastFilteredX = (USHORT) xpos;

  00148	e1c940b0	 strh        r4, [r9]

; 567  :         usLastFilteredY = (USHORT) ypos;

  0014c	e1c850b0	 strh        r5, [r8]
  00150	e5830000	 str         r0, [r3]

; 568  :     }
; 569  :     else

  00154	ea00000b	 b           |$LN1@DdsiTouchP@7|
  00158		 |$LN2@DdsiTouchP@7|

; 570  :     {
; 571  :         // Reset the delayed sample counter
; 572  :         DelayedSampleCount = 0;
; 573  :         usLastFilteredX = 0;
; 574  :         usLastFilteredY = 0;
; 575  :         
; 576  :         // Pen up so set MDD timeout for interrupt mode.
; 577  :         gdwTouchIstTimeout = INFINITE;
; 578  : 
; 579  :         // Set the proper state for the next interrupt.
; 580  :         InterruptDone( gIntrTouch );

  00158	e59f3038	 ldr         r3, [pc, #0x38]
  0015c	e59f2030	 ldr         r2, [pc, #0x30]
  00160	e3a04000	 mov         r4, #0
  00164	e5930000	 ldr         r0, [r3]
  00168	e3a03000	 mov         r3, #0
  0016c	e3a01000	 mov         r1, #0
  00170	e3e0e000	 mvn         lr, #0
  00174	e1c930b0	 strh        r3, [r9]
  00178	e5874000	 str         r4, [r7]
  0017c	e1c810b0	 strh        r1, [r8]
  00180	e582e000	 str         lr, [r2]
  00184	eb000000	 bl          InterruptDone
  00188		 |$LN1@DdsiTouchP@7|

; 581  :     }
; 582  : 
; 583  :     DEBUGMSG(ZONE_FUNCTION&&ZONE_SAMPLES, (TEXT("DdsiTouchPanelGetPoint+\r\n")));
; 584  :     
; 585  :     return;
; 586  : }

  00188	e28dd014	 add         sp, sp, #0x14
  0018c	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00190	e12fff1e	 bx          lr
  00194		 |$LN27@DdsiTouchP@7|
  00194		 |$LN28@DdsiTouchP@7|
  00194	00000000	 DCD         |gdwTouchIstTimeout|
  00198		 |$LN29@DdsiTouchP@7|
  00198	00000000	 DCD         |gIntrTouch|
  0019c		 |$LN30@DdsiTouchP@7|
  0019c	00000000	 DCD         |?usSavedFilteredY@?1??DdsiTouchPanelGetPoint@@9@4GA|
  001a0		 |$LN31@DdsiTouchP@7|
  001a0	00000000	 DCD         |?usSavedFilteredX@?1??DdsiTouchPanelGetPoint@@9@4GA|
  001a4		 |$LN32@DdsiTouchP@7|
  001a4	00000000	 DCD         |?usLastFilteredX@?1??DdsiTouchPanelGetPoint@@9@4GA|
  001a8		 |$LN33@DdsiTouchP@7|
  001a8	00000000	 DCD         |?usLastFilteredY@?1??DdsiTouchPanelGetPoint@@9@4GA|
  001ac		 |$LN34@DdsiTouchP@7|
  001ac	00000000	 DCD         |?bPrevReportedPenDown@?1??DdsiTouchPanelGetPoint@@9@4HA|
  001b0		 |$LN35@DdsiTouchP@7|
  001b0	00000000	 DCD         |?DelayedSampleCount@?1??DdsiTouchPanelGetPoint@@9@4KA|
  001b4		 |$LN36@DdsiTouchP@7|
  001b4	00000000	 DCD         |s_TouchDevice|
  001b8		 |$M37032|

			 ENDP  ; |DdsiTouchPanelGetPoint|

	EXPORT	|?PddInitializeHardware@@YAHXZ|		; PddInitializeHardware
	IMPORT	|SPIConfigure|
	IMPORT	|SPIOpen|
	IMPORT	|GPIOIoControl|
	IMPORT	|GPIOSetMode|
	IMPORT	|GPIOOpen|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|IsDVIMode|

  00000			 AREA	 |.pdata|, PDATA
|$T37062| DCD	|$LN18@PddInitial|
	DCD	0x40004b02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |?PddInitializeHardware@@YAHXZ| PROC	; PddInitializeHardware

; 619  : {

  00000		 |$LN18@PddInitial|
  00000	e92d41f0	 stmdb       sp!, {r4 - r8, lr}
  00004	e24dd024	 sub         sp, sp, #0x24
  00008		 |$M37059|

; 620  :     BOOL   rc = FALSE; 

  00008	e3a05000	 mov         r5, #0

; 621  :     DWORD  config;
; 622  :     UINT32 spiBuffer;
; 623  :     UINT32 xPos, yPos; 
; 624  :     
; 625  :     if (IsDVIMode())

  0000c	eb000000	 bl          IsDVIMode
  00010	e3500000	 cmp         r0, #0

; 626  :         return FALSE;

  00014	13a05000	 movne       r5, #0
  00018	1a00003c	 bne         |$LN1@PddInitial|

; 627  : 
; 628  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("PddInitializeHardware+\r\n")));
; 629  : 
; 630  :     // Read parameters from registry
; 631  :     if (GetDeviceRegistryParams(
; 632  :             s_szRegistryPath, 
; 633  :             &s_TouchDevice, 
; 634  :             dimof(s_deviceRegParams), 
; 635  :             s_deviceRegParams) != ERROR_SUCCESS)

  0001c	e59f4104	 ldr         r4, [pc, #0x104]
  00020	e59f30fc	 ldr         r3, [pc, #0xFC]
  00024	e3a02007	 mov         r2, #7
  00028	e5940000	 ldr         r0, [r4]
  0002c	e2841004	 add         r1, r4, #4
  00030	eb000000	 bl          GetDeviceRegistryParams
  00034	e3500000	 cmp         r0, #0
  00038	1a000033	 bne         |$LN15@PddInitial|

; 636  :         {
; 637  :         DEBUGMSG(ZONE_ERROR, (TEXT("ERROR: PddInitializeHardware: Error reading from Registry.\r\n")));
; 638  :         goto cleanup;
; 639  :         }
; 640  : 
; 641  :     // Open GPIO driver
; 642  :     s_TouchDevice.hGPIO = GPIOOpen();

  0003c	eb000000	 bl          GPIOOpen
  00040	e3500000	 cmp         r0, #0
  00044	e5840030	 str         r0, [r4, #0x30]

; 643  :     if (s_TouchDevice.hGPIO == NULL) 

  00048	0a00002f	 beq         |$LN15@PddInitial|

; 644  :         {
; 645  :         DEBUGMSG(ZONE_ERROR, (TEXT("ERROR: PddInitializeHardware: Failed open GPIO device driver\r\n")));
; 646  :         goto cleanup;
; 647  :         }
; 648  : 
; 649  :     // Setup nPENIRQ for input mode, falling edge detect, debounce enable
; 650  :     GPIOSetMode(s_TouchDevice.hGPIO, s_TouchDevice.nPenGPIO, GPIO_DIR_INPUT|GPIO_INT_HIGH_LOW|GPIO_DEBOUNCE_ENABLE);

  0004c	e5941010	 ldr         r1, [r4, #0x10]
  00050	e3a02025	 mov         r2, #0x25
  00054	eb000000	 bl          GPIOSetMode

; 651  :    
; 652  :     // Set debounce time on GPIO
; 653  :     IOCTL_GPIO_SET_DEBOUNCE_TIME_IN debounce;
; 654  :     
; 655  :     debounce.gpioId = s_TouchDevice.nPenGPIO;

  00058	e594e010	 ldr         lr, [r4, #0x10]

; 656  :     debounce.debounceTime = 10;   
; 657  : 
; 658  :     GPIOIoControl(s_TouchDevice.hGPIO, s_TouchDevice.nPenGPIO,
; 659  :                   IOCTL_GPIO_SET_DEBOUNCE_TIME, (UCHAR*)&debounce, sizeof(debounce), NULL, 0, NULL);

  0005c	e59f20bc	 ldr         r2, [pc, #0xBC]
  00060	e5940030	 ldr         r0, [r4, #0x30]
  00064	e3a0600a	 mov         r6, #0xA
  00068	e3a08008	 mov         r8, #8
  0006c	e3a07000	 mov         r7, #0
  00070	e1a0100e	 mov         r1, lr
  00074	e28d301c	 add         r3, sp, #0x1C
  00078	e58de01c	 str         lr, [sp, #0x1C]
  0007c	e58d6020	 str         r6, [sp, #0x20]
  00080	e58d700c	 str         r7, [sp, #0xC]
  00084	e58d7008	 str         r7, [sp, #8]
  00088	e58d7004	 str         r7, [sp, #4]
  0008c	e58d8000	 str         r8, [sp]
  00090	eb000000	 bl          GPIOIoControl

; 660  :     
; 661  :     // Open SPI driver
; 662  :     s_TouchDevice.hSPI = SPIOpen(s_TouchDevice.wzSPIBus);

  00094	e2843004	 add         r3, r4, #4
  00098	e283001c	 add         r0, r3, #0x1C
  0009c	eb000000	 bl          SPIOpen
  000a0	e3500000	 cmp         r0, #0
  000a4	e5840034	 str         r0, [r4, #0x34]

; 663  :     if (s_TouchDevice.hSPI == NULL) 

  000a8	0a000017	 beq         |$LN15@PddInitial|

; 664  :         {
; 665  :         DEBUGMSG(ZONE_ERROR, (TEXT("ERROR: PddInitializeHardware: Failed open SPI device driver\r\n")));
; 666  :         goto cleanup;
; 667  :         }
; 668  :  
; 669  :     //  Settings for Touchscreen device
; 670  :     //
; 671  :     //      Tx/Rx
; 672  :     //      Tx enable on data line 0
; 673  :     //
; 674  :     
; 675  :     // Raising clock rate can make the touch screen sample unstable, although the rate is in the nominal range.
; 676  : 
; 677  :     config =    MCSPI_PHA_ODD_EDGES |
; 678  :                 MCSPI_POL_ACTIVEHIGH |
; 679  :                 MCSPI_CHCONF_CLKD(s_TouchDevice.nSPIBaudrate) |
; 680  :                 MCSPI_CSPOLARITY_ACTIVELOW |
; 681  :                 MCSPI_CHCONF_WL(24) |
; 682  :                 MCSPI_CHCONF_TRM_TXRX |
; 683  :                 MCSPI_CHCONF_DPE0;

  000ac	e594301c	 ldr         r3, [r4, #0x1C]
  000b0	e3a02c42	 mov         r2, #0x42, 24
  000b4	e38220f0	 orr         r2, r2, #0xF0
  000b8	e203300f	 and         r3, r3, #0xF

; 684  : 
; 685  :     // Configure SPI channel
; 686  :     if (!SPIConfigure(s_TouchDevice.hSPI, s_TouchDevice.nSPIAddr, config))

  000bc	e5941018	 ldr         r1, [r4, #0x18]
  000c0	e1833002	 orr         r3, r3, r2
  000c4	e1a02103	 mov         r2, r3, lsl #2
  000c8	eb000000	 bl          SPIConfigure
  000cc	e3500000	 cmp         r0, #0
  000d0	0a00000d	 beq         |$LN15@PddInitial|

; 687  :         {
; 688  :         DEBUGMSG(ZONE_ERROR, (TEXT("ERROR: PddInitializeHardware: Failed configure SPI device driver\r\n")));
; 689  :         goto cleanup;
; 690  :         }
; 691  : 
; 692  :     // Enable the touchscreen
; 693  :     spiBuffer = COMMAND_EN_TOUCH;
; 694  :     if (!SPIWriteRead(s_TouchDevice.hSPI, sizeof(UINT32), &spiBuffer, &spiBuffer)) {

  000d4	e5940034	 ldr         r0, [r4, #0x34]
  000d8	e3a0e502	 mov         lr, #2, 10
  000dc	e28d3010	 add         r3, sp, #0x10
  000e0	e28d2010	 add         r2, sp, #0x10
  000e4	e3a01004	 mov         r1, #4
  000e8	e58de010	 str         lr, [sp, #0x10]
  000ec	eb000000	 bl          SPIWriteRead
  000f0	e3500000	 cmp         r0, #0
  000f4	0a000004	 beq         |$LN15@PddInitial|

; 695  :         DEBUGMSG(ZONE_ERROR, (TEXT("ERROR: PddInitializeHardware: failed to enable touchpad on spi bus\r\n")));
; 696  :         goto cleanup;
; 697  :         }
; 698  : 
; 699  :     // Grab a point from touchscreen
; 700  :     PddGetTouchData( &xPos, &yPos );

  000f8	e28d1014	 add         r1, sp, #0x14
  000fc	e28d0018	 add         r0, sp, #0x18
  00100	eb000000	 bl          |?PddGetTouchData@@YAHPAI0@Z|

; 701  :     
; 702  :     // Done    
; 703  :     rc = TRUE;

  00104	e3a05001	 mov         r5, #1
  00108		 |$cleanup$36590|

; 704  : 
; 705  : cleanup:
; 706  : 
; 707  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("PddInitializeHardware-\r\n")));    
; 708  :     if( rc == FALSE )

  00108	ea000000	 b           |$LN1@PddInitial|
  0010c		 |$LN15@PddInitial|

; 709  :         {
; 710  :         PddDeinitializeHardware();

  0010c	eb000000	 bl          |?PddDeinitializeHardware@@YAXXZ|
  00110		 |$LN1@PddInitial|

; 711  :         }
; 712  : 
; 713  :     return rc;
; 714  : }

  00110	e1a00005	 mov         r0, r5
  00114	e28dd024	 add         sp, sp, #0x24
  00118	e8bd41f0	 ldmia       sp!, {r4 - r8, lr}
  0011c	e12fff1e	 bx          lr
  00120		 |$LN19@PddInitial|
  00120		 |$LN20@PddInitial|
  00120	00220c24	 DCD         0x220c24
  00124		 |$LN21@PddInitial|
  00124	00000000	 DCD         |s_deviceRegParams|
  00128		 |$LN22@PddInitial|
  00128	00000000	 DCD         |s_szRegistryPath|
  0012c		 |$M37060|

			 ENDP  ; |?PddInitializeHardware@@YAHXZ|, PddInitializeHardware

	EXPORT	|DdsiTouchPanelEnable|
	IMPORT	|GPIOGetSystemIrq|

  00000			 AREA	 |.pdata|, PDATA
|$T37077| DCD	|$LN12@DdsiTouchP@8|
	DCD	0x40002f02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DdsiTouchPanelEnable| PROC

; 347  : {

  00000		 |$LN12@DdsiTouchP@8|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M37074|

; 348  :     BOOL rc = FALSE;
; 349  : 
; 350  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelEnable+\r\n")));
; 351  :     
; 352  :     // Initialize once only
; 353  :     if (s_TouchDevice.bInitialized)

  00008	e59f50a8	 ldr         r5, [pc, #0xA8]
  0000c	e3a04000	 mov         r4, #0
  00010	e5953000	 ldr         r3, [r5]
  00014	e3530000	 cmp         r3, #0

; 354  :         {
; 355  :         rc = TRUE;

  00018	1a00001e	 bne         |$LN9@DdsiTouchP@8|

; 356  :         goto cleanup;
; 357  :         }
; 358  : 
; 359  :     // Initialize HW
; 360  :     if (!PddInitializeHardware())

  0001c	eb000000	 bl          |?PddInitializeHardware@@YAHXZ|
  00020	e3500000	 cmp         r0, #0
  00024	0a00001c	 beq         |$cleanup$36513|

; 361  : 	{
; 362  : 		DEBUGMSG(
; 363  : 			ZONE_ERROR, 
; 364  : 			(TEXT("ERROR: TOUCH: Failed to initialize touch PDD.\r\n"))
; 365  : 			);
; 366  : 		goto cleanup;
; 367  : 	}
; 368  : 
; 369  : 	// get Logical interrupt # from GPIO manager
; 370  : 	DWORD dwLogIntr = GPIOGetSystemIrq(s_TouchDevice.hGPIO,s_TouchDevice.nPenGPIO);

  00028	e595100c	 ldr         r1, [r5, #0xC]
  0002c	e595002c	 ldr         r0, [r5, #0x2C]
  00030	eb000000	 bl          GPIOGetSystemIrq

; 371  : 
; 372  :     //Get a valid sysintr for this interrupt
; 373  :     if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR,&dwLogIntr,sizeof(dwLogIntr),&gIntrTouch,sizeof(gIntrTouch),NULL))

  00034	e59f3070	 ldr         r3, [pc, #0x70]
  00038	e1a0e000	 mov         lr, r0
  0003c	e59f0070	 ldr         r0, [pc, #0x70]
  00040	e3a06004	 mov         r6, #4
  00044	e3a07000	 mov         r7, #0
  00048	e3a02004	 mov         r2, #4
  0004c	e28d1008	 add         r1, sp, #8
  00050	e58de008	 str         lr, [sp, #8]
  00054	e58d7004	 str         r7, [sp, #4]
  00058	e58d6000	 str         r6, [sp]
  0005c	eb000000	 bl          KernelIoControl
  00060	e3500000	 cmp         r0, #0
  00064	0a00000c	 beq         |$cleanup$36513|

; 374  :     {
; 375  :         goto cleanup;
; 376  :     }
; 377  : 
; 378  : 	// Set the interrupt as a wake-up source
; 379  : 	KernelIoControl(IOCTL_HAL_ENABLE_WAKE, &gIntrTouch,
; 380  : 			sizeof(gIntrTouch), NULL, 0, NULL);

  00068	e59f0040	 ldr         r0, [pc, #0x40]
  0006c	e59f1038	 ldr         r1, [pc, #0x38]
  00070	e3a03000	 mov         r3, #0
  00074	e3a02004	 mov         r2, #4
  00078	e58d7004	 str         r7, [sp, #4]
  0007c	e58d7000	 str         r7, [sp]
  00080	eb000000	 bl          KernelIoControl

; 381  : 
; 382  : 	// assign to global IRQ used by MDD
; 383  : 	s_TouchDevice.nPenIRQ = dwLogIntr;

  00084	e59d3008	 ldr         r3, [sp, #8]
  00088	e5853034	 str         r3, [r5, #0x34]

; 384  : 
; 385  : 	// Create a calibration thread. This thread will check to see if calibration is needed.
; 386  : 	StartCalibrationThread();

  0008c	eb000000	 bl          |?StartCalibrationThread@@YAXXZ|

; 387  : 
; 388  :     //Done
; 389  :     s_TouchDevice.bInitialized = TRUE;

  00090	e3a03001	 mov         r3, #1
  00094	e5853000	 str         r3, [r5]
  00098		 |$LN9@DdsiTouchP@8|

; 390  :     rc = TRUE;

  00098	e3a04001	 mov         r4, #1
  0009c		 |$cleanup$36513|

; 391  :     
; 392  : cleanup:
; 393  :     DEBUGMSG(ZONE_FUNCTION, (TEXT("DdsiTouchPanelEnable-\r\n")));
; 394  :     return rc;
; 395  : }

  0009c	e1a00004	 mov         r0, r4
  000a0	e28dd00c	 add         sp, sp, #0xC
  000a4	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  000a8	e12fff1e	 bx          lr
  000ac		 |$LN13@DdsiTouchP@8|
  000ac		 |$LN14@DdsiTouchP@8|
  000ac	00000000	 DCD         |gIntrTouch|
  000b0		 |$LN15@DdsiTouchP@8|
  000b0	010100a0	 DCD         0x10100a0
  000b4		 |$LN16@DdsiTouchP@8|
  000b4	01010098	 DCD         0x1010098
  000b8		 |$LN17@DdsiTouchP@8|
  000b8	00000000	 DCD         |s_TouchDevice|
  000bc		 |$M37075|

			 ENDP  ; |DdsiTouchPanelEnable|

	END
