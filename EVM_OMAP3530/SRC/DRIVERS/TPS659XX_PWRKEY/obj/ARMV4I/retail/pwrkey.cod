; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\EVM_OMAP3530\SRC\DRIVERS\TPS659XX_PWRKEY\pwrkey.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|??_C@_1BO@KEFBCMN@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AAM?$AAs?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|DEVICE_IFC_TWL_GUID| [ DATA ]
	EXPORT	|dpCurSettings| [ DATA ]

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BO@KEFBCMN@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AAM?$AAs?$AA?$AA@| DCB "D"
	DCB	0x0, "e", 0x0, "b", 0x0, "o", 0x0, "u", 0x0, "n", 0x0, "c"
	DCB	0x0, "e", 0x0, "T", 0x0, "i", 0x0, "m", 0x0, "e", 0x0, "M"
	DCB	0x0, "s", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@| DCB "E"
	DCB	0x0, "n", 0x0, "a", 0x0, "b", 0x0, "l", 0x0, "e", 0x0, "W"
	DCB	0x0, "a", 0x0, "k", 0x0, "e", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@| DCB "P"
	DCB	0x0, "r", 0x0, "i", 0x0, "o", 0x0, "r", 0x0, "i", 0x0, "t"
	DCB	0x0, "y", 0x0, "2", 0x0, "5", 0x0, "6", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.data|, DATA
|dpCurSettings| DCB "p", 0x0, "w", 0x0, "r", 0x0, "k", 0x0, "e", 0x0, "y", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"E", 0x0, "r", 0x0, "r", 0x0, "o", 0x0, "r", 0x0, "s", 0x0
	DCB	0x0, 0x0
	%	50
	DCB	"W", 0x0, "a", 0x0, "r", 0x0, "n", 0x0, "i", 0x0, "n", 0x0
	DCB	"g", 0x0, "s", 0x0, 0x0, 0x0
	%	46
	DCB	"F", 0x0, "u", 0x0, "n", 0x0, "c", 0x0, "t", 0x0, "i", 0x0
	DCB	"o", 0x0, "n", 0x0, 0x0, 0x0
	%	46
	DCB	"I", 0x0, "n", 0x0, "f", 0x0, "o", 0x0, 0x0, 0x0
	%	54
	DCB	"I", 0x0, "S", 0x0, "T", 0x0, 0x0, 0x0
	%	56
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCB	"U", 0x0, "n", 0x0, "d", 0x0, "e", 0x0, "f", 0x0, "i", 0x0
	DCB	"n", 0x0, "e", 0x0, "d", 0x0, 0x0, 0x0
	%	44
	DCD	0x3

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|DEVICE_IFC_TWL_GUID| DCD 0xdef0a04b
	DCW	0xb967
	DCW	0x43db
	DCB	0x95
	DCB	0x9e
	DCB	0xd9
	DCB	0xfc
	DCB	0x62
	DCB	0x25
	DCB	0xcd
	DCB	0xeb
|s_deviceRegParams| DCD |??_C@_1BI@BHLBGEOK@?$AAP?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA2?$AA5?$AA6?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x4
	DCD	0x4
	DCD	0x64
	DCD	|??_C@_1BG@GJAODHJH@?$AAE?$AAn?$AAa?$AAb?$AAl?$AAe?$AAW?$AAa?$AAk?$AAe?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0x8
	DCD	0x4
	DCD	0x1
	DCD	|??_C@_1BO@KEFBCMN@?$AAD?$AAe?$AAb?$AAo?$AAu?$AAn?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe?$AAM?$AAs?$AA?$AA@|
	DCD	0x1
	DCD	0x0
	DCD	0xc
	DCD	0x4
	DCD	0x19
	EXPORT	|SetEvent|
	IMPORT	|EventModify|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46091| DCD	|$LN5@SetEvent|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |SetEvent| PROC

; 235  : _inline BOOL SetEvent(HANDLE h) {

  00000		 |$LN5@SetEvent|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46088|

; 236  : 	return EventModify(h,EVENT_SET);

  00004	e3a01003	 mov         r1, #3
  00008	eb000000	 bl          EventModify

; 237  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M46089|

			 ENDP  ; |SetEvent|

	EXPORT	|PKD_Deinit|
	IMPORT	|LocalFree|
	IMPORT	|TWLClose|
	IMPORT	|TWLInterruptDisable|
	IMPORT	|CloseHandle|
	IMPORT	|WaitForSingleObject|

  00000			 AREA	 |.pdata|, PDATA
|$T46106| DCD	|$LN13@PKD_Deinit|
	DCD	0x40002901
; Function compile flags: /Ogspy
; File c:\wince600\platform\evm_omap3530\src\drivers\tps659xx_pwrkey\pwrkey.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_Deinit| PROC

; 251  : {

  00000		 |$LN13@PKD_Deinit|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46103|
  00004	e1b04000	 movs        r4, r0

; 252  :     BOOL rc = FALSE;

  00008	e3a00000	 mov         r0, #0

; 253  :     PwrkeyDevice_t *pDevice = (PwrkeyDevice_t*)context;
; 254  : 
; 255  :     DEBUGMSG(ZONE_FUNCTION, (L"+PKD_Deinit(0x%08x)\r\n", context));
; 256  : 
; 257  :     // Check if we get correct context
; 258  :     if ((pDevice == NULL) || (pDevice->Cookie != PKD_DEVICE_COOKIE))

  0000c	0a000021	 beq         |$cleanUp$45926|
  00010	e5942000	 ldr         r2, [r4]
  00014	e59f3084	 ldr         r3, [pc, #0x84]
  00018	e1520003	 cmp         r2, r3
  0001c	1a00001d	 bne         |$cleanUp$45926|

; 259  :     {
; 260  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: PKD_Deinit: Incorrect context parameter\r\n"));
; 261  :         goto cleanUp;
; 262  :     }
; 263  : 
; 264  :     // Signal stop to threads
; 265  :     pDevice->bIntrThreadExit = TRUE;
; 266  :         
; 267  :     // Close interrupt thread
; 268  :     if (pDevice->hIntrThread != NULL)

  00020	e5943014	 ldr         r3, [r4, #0x14]
  00024	e3a02001	 mov         r2, #1
  00028	e584201c	 str         r2, [r4, #0x1C]
  0002c	e3530000	 cmp         r3, #0
  00030	0a000007	 beq         |$LN4@PKD_Deinit|

; 269  :     {
; 270  :         // Set event to wake it
; 271  :         SetEvent(pDevice->hIntrEvent);

  00034	e5940010	 ldr         r0, [r4, #0x10]
  00038	e3a01003	 mov         r1, #3
  0003c	eb000000	 bl          EventModify

; 272  :         // Wait until thread exits
; 273  :         WaitForSingleObject(pDevice->hIntrThread, INFINITE);

  00040	e5940014	 ldr         r0, [r4, #0x14]
  00044	e3e01000	 mvn         r1, #0
  00048	eb000000	 bl          WaitForSingleObject

; 274  :         // Close handle
; 275  :         CloseHandle(pDevice->hIntrThread);

  0004c	e5940014	 ldr         r0, [r4, #0x14]
  00050	eb000000	 bl          CloseHandle
  00054		 |$LN4@PKD_Deinit|

; 276  :     }
; 277  : 
; 278  :     if (pDevice->hTWL)

  00054	e5943018	 ldr         r3, [r4, #0x18]
  00058	e1b00003	 movs        r0, r3
  0005c	0a00000a	 beq         |$LN3@PKD_Deinit|

; 279  :     {
; 280  :         // Disable interrupt
; 281  :         if (pDevice->hIntrEvent != NULL)

  00060	e5943010	 ldr         r3, [r4, #0x10]
  00064	e3530000	 cmp         r3, #0
  00068	0a000005	 beq         |$LN1@PKD_Deinit|

; 282  :         {
; 283  :             TWLInterruptDisable(pDevice->hTWL, TWL_INTR_PWRON);

  0006c	e3a01a05	 mov         r1, #5, 20
  00070	eb000000	 bl          TWLInterruptDisable

; 284  :         }
; 285  : 
; 286  :         // Close interrupt handle
; 287  :         if (pDevice->hIntrEvent != NULL) 

  00074	e5943010	 ldr         r3, [r4, #0x10]
  00078	e3530000	 cmp         r3, #0

; 288  :             CloseHandle(pDevice->hIntrEvent);

  0007c	11a00003	 movne       r0, r3
  00080	1b000000	 blne        CloseHandle
  00084		 |$LN1@PKD_Deinit|

; 289  :     
; 290  :         // close T2 driver
; 291  :         TWLClose(pDevice->hTWL);

  00084	e5940018	 ldr         r0, [r4, #0x18]
  00088	eb000000	 bl          TWLClose
  0008c		 |$LN3@PKD_Deinit|

; 292  :     }
; 293  :     
; 294  :     // Free device structure
; 295  :     LocalFree(pDevice);

  0008c	e1a00004	 mov         r0, r4
  00090	eb000000	 bl          LocalFree

; 296  : 
; 297  :     // Done
; 298  :     rc = TRUE;

  00094	e3a00001	 mov         r0, #1
  00098		 |$cleanUp$45926|

; 299  : 
; 300  : cleanUp:
; 301  :     DEBUGMSG(ZONE_FUNCTION, (L"-PKD_Deinit(rc = %d)\r\n", rc));
; 302  :     return rc;
; 303  : }

  00098	e8bd4010	 ldmia       sp!, {r4, lr}
  0009c	e12fff1e	 bx          lr
  000a0		 |$LN14@PKD_Deinit|
  000a0		 |$LN15@PKD_Deinit|
  000a0	4b504747	 DCD         0x4b504747
  000a4		 |$M46104|

			 ENDP  ; |PKD_Deinit|

	EXPORT	|PKD_Open|

  00000			 AREA	 |.pdata|, PDATA
|$T46118| DCD	|$LN5@PKD_Open|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_Open| PROC

; 317  : {

  00000		 |$LN5@PKD_Open|
  00000		 |$M46115|

; 318  :     UNREFERENCED_PARAMETER(context);
; 319  :     UNREFERENCED_PARAMETER(accessCode);
; 320  :     UNREFERENCED_PARAMETER(shareMode);
; 321  :     return context;
; 322  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M46116|

			 ENDP  ; |PKD_Open|

	EXPORT	|PKD_Close|

  00000			 AREA	 |.pdata|, PDATA
|$T46127| DCD	|$LN5@PKD_Close|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_Close| PROC

; 334  : {

  00000		 |$LN5@PKD_Close|
  00000		 |$M46124|

; 335  :     UNREFERENCED_PARAMETER(context);
; 336  :     return TRUE;

  00000	e3a00001	 mov         r0, #1

; 337  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M46125|

			 ENDP  ; |PKD_Close|

	EXPORT	|PKD_PowerUp|
; File c:\wince600\public\common\sdk\inc\kfuncs.h

  00000			 AREA	 |.pdata|, PDATA
|$T46139| DCD	|$LN8@PKD_PowerU|
	DCD	0x40000a01
; Function compile flags: /Ogspy
; File c:\wince600\platform\evm_omap3530\src\drivers\tps659xx_pwrkey\pwrkey.c

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_PowerUp| PROC

; 351  : {

  00000		 |$LN8@PKD_PowerU|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46136|

; 352  :     PwrkeyDevice_t *pDevice = (PwrkeyDevice_t*)context;
; 353  : 
; 354  :     pDevice->bWakeFromSuspend = TRUE;
; 355  :     if (pDevice->hIntrEvent)

  00004	e5903010	 ldr         r3, [r0, #0x10]
  00008	e3a02001	 mov         r2, #1
  0000c	e5802028	 str         r2, [r0, #0x28]
  00010	e3530000	 cmp         r3, #0

; 356  :         SetEvent(pDevice->hIntrEvent);

  00014	13a01003	 movne       r1, #3
  00018	11a00003	 movne       r0, r3
  0001c	1b000000	 blne        EventModify

; 357  : }

  00020	e49de004	 ldr         lr, [sp], #4
  00024	e12fff1e	 bx          lr
  00028		 |$M46137|

			 ENDP  ; |PKD_PowerUp|

	EXPORT	|PKD_PowerDown|

  00000			 AREA	 |.pdata|, PDATA
|$T46146| DCD	|$LN5@PKD_PowerD|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_PowerDown| PROC

; 369  : {

  00000		 |$LN5@PKD_PowerD|
  00000		 |$M46143|

; 370  :     UNREFERENCED_PARAMETER(context);
; 371  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M46144|

			 ENDP  ; |PKD_PowerDown|

	EXPORT	|PKD_IOControl|
	EXPORT	|??_C@_1GI@PCNHODEI@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAK?$AAD?$AA_?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5@| [ DATA ] ; `string'
	IMPORT	|NKDbgPrintfW|

  00000			 AREA	 |.pdata|, PDATA
|$T46158| DCD	|$LN9@PKD_IOCont|
	DCD	0x40001201

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@PCNHODEI@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAK?$AAD?$AA_?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "P", 0x0, "K", 0x0, "D", 0x0, "_", 0x0, "I", 0x0, "O"
	DCB	0x0, "C", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "r", 0x0, "o"
	DCB	0x0, "l", 0x0, ":", 0x0, " ", 0x0, "I", 0x0, "n", 0x0, "c"
	DCB	0x0, "o", 0x0, "r", 0x0, "r", 0x0, "e", 0x0, "c", 0x0, "t"
	DCB	0x0, " ", 0x0, "c", 0x0, "o", 0x0, "n", 0x0, "t", 0x0, "e"
	DCB	0x0, "x", 0x0, "t", 0x0, " ", 0x0, "p", 0x0, "a", 0x0, "r"
	DCB	0x0, "a", 0x0, "m", 0x0, "e", 0x0, "t", 0x0, "e", 0x0, "r"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_IOControl| PROC

; 389  : {

  00000		 |$LN9@PKD_IOCont|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M46155|
  00004	e3500000	 cmp         r0, #0

; 390  :     BOOL rc = FALSE;
; 391  :     PwrkeyDevice_t *pDevice = (PwrkeyDevice_t*)context;
; 392  : 
; 393  :     UNREFERENCED_PARAMETER(outSize);
; 394  :     UNREFERENCED_PARAMETER(pOutSize);
; 395  :     UNREFERENCED_PARAMETER(pOutBuffer);
; 396  :     UNREFERENCED_PARAMETER(inSize);
; 397  :     UNREFERENCED_PARAMETER(pInBuffer);
; 398  :     UNREFERENCED_PARAMETER(code);
; 399  : 
; 400  :     DEBUGMSG(ZONE_FUNCTION, (
; 401  :         L"+PKD_IOControl(0x%08x, 0x%08x, 0x%08x, %d, 0x%08x, %d, 0x%08x)\r\n",
; 402  :         context, code, pInBuffer, inSize, pOutBuffer, outSize, pOutSize
; 403  :         ));
; 404  :         
; 405  :     // Check if we get correct context
; 406  :     if ((pDevice == NULL) || (pDevice->Cookie != PKD_DEVICE_COOKIE))

  00008	0a000003	 beq         |$LN1@PKD_IOCont|
  0000c	e5902000	 ldr         r2, [r0]
  00010	e59f302c	 ldr         r3, [pc, #0x2C]
  00014	e1520003	 cmp         r2, r3
  00018	0a000004	 beq         |$cleanUp$45982|
  0001c		 |$LN1@PKD_IOCont|

; 407  :     {
; 408  :         RETAILMSG(ZONE_ERROR, (L"ERROR: PKD_IOControl: Incorrect context parameter\r\n"));

  0001c	e59f301c	 ldr         r3, [pc, #0x1C]
  00020	e5933440	 ldr         r3, [r3, #0x440]
  00024	e3130001	 tst         r3, #1
  00028	159f000c	 ldrne       r0, [pc, #0xC]
  0002c	1b000000	 blne        NKDbgPrintfW
  00030		 |$cleanUp$45982|

; 409  :         goto cleanUp;
; 410  :     }
; 411  :     
; 412  : cleanUp:
; 413  :     DEBUGMSG(ZONE_FUNCTION, (L"-PKD_IOControl(rc = %d)\r\n", rc));
; 414  :     return rc;

  00030	e3a00000	 mov         r0, #0

; 415  : }

  00034	e49de004	 ldr         lr, [sp], #4
  00038	e12fff1e	 bx          lr
  0003c		 |$LN10@PKD_IOCont|
  0003c		 |$LN11@PKD_IOCont|
  0003c	00000000	 DCD         |??_C@_1GI@PCNHODEI@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAP?$AAK?$AAD?$AA_?$AAI?$AAO?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl?$AA?3?$AA?5?$AAI?$AAn?$AAc?$AAo?$AAr?$AAr?$AAe?$AAc?$AAt?$AA?5@|
  00040		 |$LN12@PKD_IOCont|
  00040	00000000	 DCD         |dpCurSettings|
  00044		 |$LN13@PKD_IOCont|
  00044	4b504747	 DCD         0x4b504747
  00048		 |$M46156|

			 ENDP  ; |PKD_IOControl|

	EXPORT	|PKD_IntrThread|
	IMPORT	|SetSystemPowerState|
	IMPORT	|Sleep|
	IMPORT	|TWLWriteRegs|
	IMPORT	|TWLReadRegs|

  00000			 AREA	 |.pdata|, PDATA
|$T46181| DCD	|$LN29@PKD_IntrTh|
	DCD	0x40006002
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_IntrThread| PROC

; 427  : {

  00000		 |$LN29@PKD_IntrTh|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd004	 sub         sp, sp, #4
  00008		 |$M46178|
  00008	e1a04000	 mov         r4, r0

; 428  :     PwrkeyDevice_t *pDevice = (PwrkeyDevice_t*)pContext;
; 429  :     DWORD WaitResult;
; 430  :     DWORD CurrentDebounceTimeMs = WAIT_FOR_PWRKEY_INTERRUPT;
; 431  :     BYTE data;
; 432  :     
; 433  :     DEBUGMSG(ZONE_IST, (L"+PKD_IntrThread\r\n"));
; 434  : 
; 435  :     // Loop until we are stopped...
; 436  :     while (!pDevice->bIntrThreadExit)

  0000c	e594301c	 ldr         r3, [r4, #0x1C]
  00010	e3a06002	 mov         r6, #2
  00014	e3530000	 cmp         r3, #0
  00018	1a000054	 bne         |$LN26@PKD_IntrTh|
  0001c	e3a03c01	 mov         r3, #1, 24
  00020	e3837002	 orr         r7, r3, #2
  00024	e3a0b803	 mov         r11, #3, 16
  00028	e3a08000	 mov         r8, #0
  0002c	e3a09001	 mov         r9, #1
  00030	e3a0a002	 mov         r10, #2
  00034		 |$LL19@PKD_IntrTh|

; 437  :     {
; 438  :         switch (pDevice->PwrkeyIntrThreadState)

  00034	e594302c	 ldr         r3, [r4, #0x2C]
  00038	e3530000	 cmp         r3, #0
  0003c	0a000005	 beq         |$LN15@PKD_IntrTh|
  00040	e3530001	 cmp         r3, #1
  00044	0a000003	 beq         |$LN15@PKD_IntrTh|
  00048	e3530002	 cmp         r3, #2
  0004c	1a000002	 bne         |$LN16@PKD_IntrTh|

; 443  :                 break;
; 444  : 
; 445  :             case WAIT_FOR_PWRKEY_DEBOUNCE:
; 446  :                 DEBUGMSG(ZONE_IST, (L"+PKD_IntrThread WAIT_FOR_PWRKEY_DEBOUNCE\r\n"));
; 447  :                 CurrentDebounceTimeMs = pDevice->DebounceTimeMs;
; 448  :                 break;
; 449  : 
; 450  :             case WAIT_FOR_PWRKEY_INTERRUPT:
; 451  :                 DEBUGMSG(ZONE_IST, (L"+PKD_IntrThread WAIT_FOR_PWRKEY_INTERRUPT\r\n"));
; 452  :                 CurrentDebounceTimeMs = INFINITE;

  00050	e3e06000	 mvn         r6, #0

; 453  :                 break;

  00054	ea000000	 b           |$LN16@PKD_IntrTh|
  00058		 |$LN15@PKD_IntrTh|

; 439  :         {
; 440  :             case WAIT_FOR_PWRKEY_IDLE:
; 441  :                 DEBUGMSG(ZONE_IST, (L"+PKD_IntrThread WAIT_FOR_PWRKEY_IDLE\r\n"));
; 442  :                 CurrentDebounceTimeMs = pDevice->DebounceTimeMs;

  00058	e594600c	 ldr         r6, [r4, #0xC]
  0005c		 |$LN16@PKD_IntrTh|

; 454  :         }
; 455  : 
; 456  :         // Wait for pwrkey interrupt
; 457  :         WaitResult = WaitForSingleObject(pDevice->hIntrEvent, CurrentDebounceTimeMs);

  0005c	e5940010	 ldr         r0, [r4, #0x10]
  00060	e1a01006	 mov         r1, r6
  00064	eb000000	 bl          WaitForSingleObject
  00068	e1a05000	 mov         r5, r0

; 458  : 
; 459  :         if (WaitResult == WAIT_FAILED)

  0006c	e3750001	 cmn         r5, #1
  00070	0a00003e	 beq         |$LN26@PKD_IntrTh|

; 460  :             break;
; 461  : 
; 462  :         if (pDevice->bIntrThreadExit) 

  00074	e594301c	 ldr         r3, [r4, #0x1C]
  00078	e3530000	 cmp         r3, #0
  0007c	1a00003b	 bne         |$LN26@PKD_IntrTh|

; 463  :             break;
; 464  : 
; 465  :         if (WaitResult == WAIT_OBJECT_0)

  00080	e3550000	 cmp         r5, #0
  00084	1a000019	 bne         |$LN10@PKD_IntrTh|

; 466  :         {
; 467  :             TWLReadRegs(pDevice->hTWL, TWL_PWR_ISR1, &data, 1);

  00088	e5940018	 ldr         r0, [r4, #0x18]
  0008c	e3a03001	 mov         r3, #1
  00090	e28d2000	 add         r2, sp, #0
  00094	e38b102e	 orr         r1, r11, #0x2E
  00098	eb000000	 bl          TWLReadRegs

; 468  :             // only clear the PWRON bit
; 469  :             data &= 0x1;

  0009c	e5dd3000	 ldrb        r3, [sp]

; 470  :             TWLWriteRegs(pDevice->hTWL, TWL_PWR_ISR1, &data, 1);

  000a0	e5940018	 ldr         r0, [r4, #0x18]
  000a4	e28d2000	 add         r2, sp, #0
  000a8	e2033001	 and         r3, r3, #1
  000ac	e5cd3000	 strb        r3, [sp]
  000b0	e3a03001	 mov         r3, #1
  000b4	e38b102e	 orr         r1, r11, #0x2E
  000b8	eb000000	 bl          TWLWriteRegs

; 471  : 
; 472  :             // repeat in case both edges were detected
; 473  :             TWLReadRegs(pDevice->hTWL, TWL_PWR_ISR1, &data, 1);

  000bc	e5940018	 ldr         r0, [r4, #0x18]
  000c0	e3a03001	 mov         r3, #1
  000c4	e28d2000	 add         r2, sp, #0
  000c8	e38b102e	 orr         r1, r11, #0x2E
  000cc	eb000000	 bl          TWLReadRegs

; 474  :             // only clear the PWRON bit
; 475  :             data &= 0x1;

  000d0	e5dd3000	 ldrb        r3, [sp]

; 476  :             TWLWriteRegs(pDevice->hTWL, TWL_PWR_ISR1, &data, 1);

  000d4	e5940018	 ldr         r0, [r4, #0x18]
  000d8	e28d2000	 add         r2, sp, #0
  000dc	e2033001	 and         r3, r3, #1
  000e0	e5cd3000	 strb        r3, [sp]
  000e4	e3a03001	 mov         r3, #1
  000e8	e38b102e	 orr         r1, r11, #0x2E
  000ec	eb000000	 bl          TWLWriteRegs
  000f0		 |$LN10@PKD_IntrTh|

; 477  :         }
; 478  : 
; 479  :         // special case - suspend by someone else, resume using pwron key
; 480  :         if (pDevice->bWakeFromSuspend)

  000f0	e5943028	 ldr         r3, [r4, #0x28]
  000f4	e3530000	 cmp         r3, #0
  000f8	0a000004	 beq         |$LN9@PKD_IntrTh|

; 481  :         {
; 482  :             pDevice->PwrkeyIntrThreadState = WAIT_FOR_PWRKEY_IDLE;
; 483  :             pDevice->bWakeFromSuspend = FALSE;
; 484  :             // allow some time for user to release PWRON key
; 485  :             Sleep(500);

  000fc	e3a00f7d	 mov         r0, #0x7D, 30
  00100	e584802c	 str         r8, [r4, #0x2C]
  00104	e5848028	 str         r8, [r4, #0x28]
  00108	eb000000	 bl          Sleep

; 486  :             DEBUGMSG(ZONE_IST, (L"+PKD_IntrThread resume detected\r\n"));
; 487  :             continue;

  0010c	ea000014	 b           |$LN5@PKD_IntrTh|
  00110		 |$LN9@PKD_IntrTh|

; 488  :         }
; 489  :         
; 490  :         DEBUGMSG(ZONE_IST, (L"+PKD_IntrThread %s\r\n", WaitResult == WAIT_OBJECT_0 ? L"interrupt" : L"timeout"));
; 491  : 
; 492  :         switch (pDevice->PwrkeyIntrThreadState)

  00110	e594302c	 ldr         r3, [r4, #0x2C]
  00114	e3530000	 cmp         r3, #0
  00118	0a00000f	 beq         |$LN6@PKD_IntrTh|
  0011c	e3530001	 cmp         r3, #1
  00120	0a000005	 beq         |$LN4@PKD_IntrTh|
  00124	e3530002	 cmp         r3, #2
  00128	1a00000d	 bne         |$LN5@PKD_IntrTh|

; 509  : 
; 510  :             case WAIT_FOR_PWRKEY_INTERRUPT:
; 511  :                 if (WaitResult == WAIT_OBJECT_0)

  0012c	e3550000	 cmp         r5, #0
  00130	1a00000b	 bne         |$LN5@PKD_IntrTh|

; 512  :                     pDevice->PwrkeyIntrThreadState = WAIT_FOR_PWRKEY_DEBOUNCE;

  00134	e584902c	 str         r9, [r4, #0x2C]

; 513  :                 break;

  00138	ea000009	 b           |$LN5@PKD_IntrTh|
  0013c		 |$LN4@PKD_IntrTh|

; 497  :                 break;
; 498  : 
; 499  :             case WAIT_FOR_PWRKEY_DEBOUNCE:
; 500  :                 if (WaitResult == WAIT_TIMEOUT)

  0013c	e1550007	 cmp         r5, r7
  00140	1a000007	 bne         |$LN5@PKD_IntrTh|

; 501  :                 {
; 502  :                     // suspend system
; 503  :                     SetSystemPowerState(NULL, POWER_STATE_SUSPEND, POWER_FORCE);

  00144	e3a02a01	 mov         r2, #1, 20
  00148	e3a01602	 mov         r1, #2, 12
  0014c	e3a00000	 mov         r0, #0
  00150	eb000000	 bl          SetSystemPowerState

; 504  :                     
; 505  :                     // back from suspend, wait for pwrkey idle
; 506  :                     pDevice->PwrkeyIntrThreadState = WAIT_FOR_PWRKEY_IDLE;

  00154	e584802c	 str         r8, [r4, #0x2C]

; 507  :                 }
; 508  :                 break;

  00158	ea000001	 b           |$LN5@PKD_IntrTh|
  0015c		 |$LN6@PKD_IntrTh|

; 493  :         {
; 494  :             case WAIT_FOR_PWRKEY_IDLE:
; 495  :                 if (WaitResult == WAIT_TIMEOUT)

  0015c	e1550007	 cmp         r5, r7

; 496  :                     pDevice->PwrkeyIntrThreadState = WAIT_FOR_PWRKEY_INTERRUPT;

  00160	0584a02c	 streq       r10, [r4, #0x2C]
  00164		 |$LN5@PKD_IntrTh|
  00164	e594301c	 ldr         r3, [r4, #0x1C]
  00168	e3530000	 cmp         r3, #0
  0016c	0affffb0	 beq         |$LL19@PKD_IntrTh|
  00170		 |$LN26@PKD_IntrTh|

; 514  :         }
; 515  :     }
; 516  : 
; 517  :     DEBUGMSG(ZONE_IST, (L"-PKD_IntrThread\r\n"));
; 518  :     return ERROR_SUCCESS;

  00170	e3a00000	 mov         r0, #0

; 519  : }

  00174	e28dd004	 add         sp, sp, #4
  00178	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  0017c	e12fff1e	 bx          lr
  00180		 |$M46179|

			 ENDP  ; |PKD_IntrThread|

	EXPORT	|DllMain|
	IMPORT	|DisableThreadLibraryCalls|
	IMPORT	|RegisterDbgZones|

  00000			 AREA	 |.pdata|, PDATA
|$T46192| DCD	|$LN8@DllMain|
	DCD	0x40000c01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |DllMain| PROC

; 534  : {

  00000		 |$LN8@DllMain|
  00000	e92d4010	 stmdb       sp!, {r4, lr}
  00004		 |$M46189|
  00004	e1a04000	 mov         r4, r0

; 535  :     UNREFERENCED_PARAMETER(pReserved);
; 536  :     switch (reason)

  00008	e3510001	 cmp         r1, #1
  0000c	1a000003	 bne         |$LN2@DllMain|

; 537  :         {
; 538  :         case DLL_PROCESS_ATTACH:
; 539  :             RETAILREGISTERZONES((HMODULE)hDLL);

  00010	e59f1014	 ldr         r1, [pc, #0x14]
  00014	eb000000	 bl          RegisterDbgZones

; 540  :             DisableThreadLibraryCalls((HMODULE)hDLL);

  00018	e1a00004	 mov         r0, r4
  0001c	eb000000	 bl          DisableThreadLibraryCalls
  00020		 |$LN2@DllMain|

; 541  :             break;
; 542  :         }
; 543  :     return TRUE;

  00020	e3a00001	 mov         r0, #1

; 544  : }

  00024	e8bd4010	 ldmia       sp!, {r4, lr}
  00028	e12fff1e	 bx          lr
  0002c		 |$LN9@DllMain|
  0002c		 |$LN10@DllMain|
  0002c	00000000	 DCD         |dpCurSettings|
  00030		 |$M46190|

			 ENDP  ; |DllMain|

	EXPORT	|PKD_Init|
	IMPORT	|CeSetThreadPriority|
	IMPORT	|CreateThread|
	IMPORT	|TWLWakeEnable|
	IMPORT	|TWLInterruptMask|
	IMPORT	|TWLInterruptInitialize|
	IMPORT	|CreateEventW|
	IMPORT	|TWLOpen|
	IMPORT	|GetDeviceRegistryParams|
	IMPORT	|LocalAlloc|
	IMPORT	|memset|

  00000			 AREA	 |.pdata|, PDATA
|$T46208| DCD	|$LN15@PKD_Init|
	DCD	0x40005c02
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |PKD_Init| PROC

; 132  : {

  00000		 |$LN15@PKD_Init|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004	e24dd00c	 sub         sp, sp, #0xC
  00008		 |$M46205|
  00008	e1a06000	 mov         r6, r0

; 133  :     DWORD rc = (DWORD)NULL;
; 134  :     PwrkeyDevice_t *pDevice = NULL;
; 135  :     BYTE data;
; 136  :     
; 137  :     UNREFERENCED_PARAMETER(pBusContext);
; 138  : 
; 139  :     DEBUGMSG(ZONE_FUNCTION, (L"+PKD_Init(%s, 0x%08x)\r\n", szContext, pBusContext));
; 140  : 
; 141  :     // Create device structure
; 142  :     pDevice = (PwrkeyDevice_t *)LocalAlloc(LPTR, sizeof(PwrkeyDevice_t));

  0000c	e3a01030	 mov         r1, #0x30
  00010	e3a00040	 mov         r0, #0x40
  00014	e3a05000	 mov         r5, #0
  00018	eb000000	 bl          LocalAlloc
  0001c	e1b04000	 movs        r4, r0

; 143  :     if (pDevice == NULL)

  00020	0a000049	 beq         |$LN12@PKD_Init|

; 144  :     {
; 145  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: PKD_Init: Failed allocate KDP driver structure\r\n"));
; 146  :         goto cleanUp;
; 147  :     }
; 148  : 
; 149  :     memset(pDevice, 0, sizeof(PwrkeyDevice_t));

  00024	e3a02030	 mov         r2, #0x30
  00028	e3a01000	 mov         r1, #0
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          memset

; 150  : 
; 151  :     // Set Cookie
; 152  :     pDevice->Cookie = PKD_DEVICE_COOKIE;

  00034	e59f2130	 ldr         r2, [pc, #0x130]

; 153  :     pDevice->PwrkeyIntrThreadState = WAIT_FOR_PWRKEY_IDLE;
; 154  : 
; 155  :     // Read device parameters
; 156  :     if (GetDeviceRegistryParams(szContext, pDevice, dimof(s_deviceRegParams), s_deviceRegParams) != ERROR_SUCCESS)

  00038	e59f3128	 ldr         r3, [pc, #0x128]
  0003c	e3a07000	 mov         r7, #0
  00040	e5842000	 str         r2, [r4]
  00044	e3a02003	 mov         r2, #3
  00048	e1a01004	 mov         r1, r4
  0004c	e1a00006	 mov         r0, r6
  00050	e584702c	 str         r7, [r4, #0x2C]
  00054	eb000000	 bl          GetDeviceRegistryParams
  00058	e3500000	 cmp         r0, #0
  0005c	1a00003a	 bne         |$LN12@PKD_Init|

; 157  :     {
; 158  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: PKD_Init: Failed read KPG driver registry parameters\r\n"));
; 159  :         goto cleanUp;
; 160  :     }
; 161  : 
; 162  :     // Open T2 driver
; 163  :     pDevice->hTWL = TWLOpen();

  00060	eb000000	 bl          TWLOpen
  00064	e3500000	 cmp         r0, #0
  00068	e5840018	 str         r0, [r4, #0x18]

; 164  :     if (pDevice->hTWL == NULL)

  0006c	0a000036	 beq         |$LN12@PKD_Init|

; 165  :     {
; 166  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: PKD_Init: Failed open TWL bus driver\r\n"));
; 167  :         goto cleanUp;
; 168  :     }
; 169  : 
; 170  :     // Create interrupt event
; 171  :     pDevice->hIntrEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  00070	e3a03000	 mov         r3, #0
  00074	e3a02000	 mov         r2, #0
  00078	e3a01000	 mov         r1, #0
  0007c	e3a00000	 mov         r0, #0
  00080	eb000000	 bl          CreateEventW
  00084	e1b02000	 movs        r2, r0
  00088	e5842010	 str         r2, [r4, #0x10]

; 172  :     if (pDevice->hIntrEvent == NULL)

  0008c	0a00002e	 beq         |$LN12@PKD_Init|

; 173  :     {
; 174  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: PKD_Init: Failed create interrupt event\r\n"));
; 175  :         goto cleanUp;
; 176  :     }
; 177  : 
; 178  : /*
; 179  :     // register for pwron key interrupts
; 180  :     if (!TWLSetIntrEvent(pDevice->hTWL, TWL_INTR_PWRON, pDevice->hIntrEvent))
; 181  :     {
; 182  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: Failed to associate event with TWL PWRON interrupt\r\n"));
; 183  :         goto cleanUp;
; 184  :     }
; 185  : 
; 186  :     if (!TWLIntrEnable(pDevice->hTWL, TWL_INTR_PWRON))
; 187  :     {
; 188  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: Failed to enable TWL PWRON interrupt\r\n"));
; 189  :         goto cleanUp;
; 190  :     }
; 191  : */
; 192  : 
; 193  :     // initialize interrupt
; 194  :     if (!TWLInterruptInitialize(pDevice->hTWL, TWL_INTR_PWRON, pDevice->hIntrEvent))

  00090	e5940018	 ldr         r0, [r4, #0x18]
  00094	e3a01a05	 mov         r1, #5, 20
  00098	eb000000	 bl          TWLInterruptInitialize
  0009c	e3500000	 cmp         r0, #0
  000a0	0a000029	 beq         |$LN12@PKD_Init|

; 195  :     {
; 196  :         DEBUGMSG(ZONE_ERROR, (L"ERROR: PWB_Init Failed associate event with TWL PWRON interrupt\r\n"));
; 197  :         goto cleanUp;
; 198  :     }
; 199  : 
; 200  :     // enable interrupt
; 201  :     if (!TWLInterruptMask(pDevice->hTWL, TWL_INTR_PWRON, FALSE))

  000a4	e5940018	 ldr         r0, [r4, #0x18]
  000a8	e3a02000	 mov         r2, #0
  000ac	e3a01a05	 mov         r1, #5, 20
  000b0	eb000000	 bl          TWLInterruptMask
  000b4	e3500000	 cmp         r0, #0
  000b8	0a000023	 beq         |$LN12@PKD_Init|

; 202  :     {
; 203  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: PWB_Init: Failed enable event with TWL PWRON interrupt\r\n"));
; 204  :         goto cleanUp;
; 205  :     }
; 206  : 
; 207  :     // configure PWRON key edge detect for rising only
; 208  :     TWLReadRegs(pDevice->hTWL, TWL_PWR_EDR1, &data, 1);

  000bc	e5940018	 ldr         r0, [r4, #0x18]
  000c0	e3a06803	 mov         r6, #3, 16
  000c4	e3861033	 orr         r1, r6, #0x33
  000c8	e3a03001	 mov         r3, #1
  000cc	e28d2008	 add         r2, sp, #8
  000d0	eb000000	 bl          TWLReadRegs

; 209  :     data &= 0xfe;

  000d4	e5dd1008	 ldrb        r1, [sp, #8]

; 210  :     data |= 0x02;
; 211  :     TWLWriteRegs(pDevice->hTWL, TWL_PWR_EDR1, &data, 1);

  000d8	e3a03001	 mov         r3, #1
  000dc	e28d2008	 add         r2, sp, #8
  000e0	e20110fc	 and         r1, r1, #0xFC
  000e4	e3811002	 orr         r1, r1, #2
  000e8	e5cd1008	 strb        r1, [sp, #8]
  000ec	e5940018	 ldr         r0, [r4, #0x18]
  000f0	e3861033	 orr         r1, r6, #0x33
  000f4	eb000000	 bl          TWLWriteRegs

; 212  : 
; 213  :     // register to be wake-up enabled
; 214  :     if (pDevice->enableWake != 0)

  000f8	e5943008	 ldr         r3, [r4, #8]
  000fc	e3530000	 cmp         r3, #0

; 215  :         TWLWakeEnable(pDevice->hTWL, TWL_INTR_PWRON, TRUE);        

  00100	15940018	 ldrne       r0, [r4, #0x18]
  00104	13a02001	 movne       r2, #1
  00108	13a01a05	 movne       r1, #5, 20
  0010c	1b000000	 blne        TWLWakeEnable

; 216  : 
; 217  :     // Start interrupt service thread
; 218  :     pDevice->bIntrThreadExit = FALSE;
; 219  :     pDevice->hIntrThread = CreateThread(NULL, 0, PKD_IntrThread, pDevice, 0, NULL);

  00110	e59f204c	 ldr         r2, [pc, #0x4C]
  00114	e1a03004	 mov         r3, r4
  00118	e3a01000	 mov         r1, #0
  0011c	e3a00000	 mov         r0, #0
  00120	e584701c	 str         r7, [r4, #0x1C]
  00124	e58d7004	 str         r7, [sp, #4]
  00128	e58d7000	 str         r7, [sp]
  0012c	eb000000	 bl          CreateThread
  00130	e3500000	 cmp         r0, #0
  00134	e5840014	 str         r0, [r4, #0x14]

; 220  :     if (!pDevice->hIntrThread)

  00138	0a000003	 beq         |$LN12@PKD_Init|

; 221  :     {
; 222  :         DEBUGMSG (ZONE_ERROR, (L"ERROR: PKD_Init: Failed create interrupt thread\r\n"));
; 223  :         goto cleanUp;
; 224  :     }
; 225  :     
; 226  :     // Set thread priority
; 227  :     CeSetThreadPriority(pDevice->hIntrThread, pDevice->priority256);

  0013c	e5941004	 ldr         r1, [r4, #4]
  00140	eb000000	 bl          CeSetThreadPriority

; 228  : 
; 229  :     // Return non-null value
; 230  :     rc = (DWORD)pDevice;

  00144	e1a05004	 mov         r5, r4
  00148		 |$cleanUp$45890|

; 231  : 
; 232  : cleanUp:
; 233  :     if (rc == 0)

  00148	ea000001	 b           |$LN1@PKD_Init|
  0014c		 |$LN12@PKD_Init|

; 234  :     {
; 235  :         PKD_Deinit((DWORD)pDevice);

  0014c	e1a00004	 mov         r0, r4
  00150	eb000000	 bl          PKD_Deinit
  00154		 |$LN1@PKD_Init|

; 236  :     }
; 237  :     DEBUGMSG(ZONE_FUNCTION, (L"-PKD_Init(rc = %d\r\n", rc));
; 238  :     return rc;
; 239  : }

  00154	e1a00005	 mov         r0, r5
  00158	e28dd00c	 add         sp, sp, #0xC
  0015c	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00160	e12fff1e	 bx          lr
  00164		 |$LN16@PKD_Init|
  00164		 |$LN17@PKD_Init|
  00164	00000000	 DCD         |PKD_IntrThread|
  00168		 |$LN18@PKD_Init|
  00168	00000000	 DCD         |s_deviceRegParams|
  0016c		 |$LN19@PKD_Init|
  0016c	4b504747	 DCD         0x4b504747
  00170		 |$M46206|

			 ENDP  ; |PKD_Init|

	END
