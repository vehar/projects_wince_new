; Listing generated by Microsoft (R) Optimizing Compiler Version 14.01.60511.01 

	TTL	C:\WINCE600\PLATFORM\EVM_OMAP3530\SRC\OAL\OALLIB\init.c
	CODE32

  00000			 AREA	 |.drectve|, DRECTVE
	DCB	"-defaultlib:LIBCMT "
	DCB	"-defaultlib:OLDNAMES "

	EXPORT	|dwOEMDrWatsonSize| [ DATA ]
	EXPORT	|dwOEMHighSecurity| [ DATA ]
	EXPORT	|dwBank1Enabled| [ DATA ]
	EXPORT	|dwCMemDSPEnabled| [ DATA ]
	EXPORT	|dwDSP720pEnabled| [ DATA ]
	EXPORT	|g_dwCpuRevision| [ DATA ]
	EXPORT	|dwOEMSRAMStartOffset| [ DATA ]
	EXPORT	|dwOEMPRCMCLKSSetupTime| [ DATA ]
	EXPORT	|dwOEMMPUContextRestore| [ DATA ]
	EXPORT	|dwOEMMaxIdlePeriod| [ DATA ]
	EXPORT	|g_oalRetailMsgEnable| [ DATA ]
	EXPORT	|g_ResumeRTC| [ DATA ]

  00000			 AREA	 |.data|, DATA
	 COMMON	|g_oalKitlEnabled|, 0x4

	 COMMON	|gDevice_prefix|, 0x4

	 COMMON	|g_dwCpuFamily|, 0x4


  00000			 AREA	 |.bss|, NOINIT
|g_oalRetailMsgEnable| % 0x4
|g_ResumeRTC| %	0x4

  00000			 AREA	 |.data|, DATA
|g_dwCpuRevision| DCD 0xffffffff
|dwOEMSRAMStartOffset| DCD 0x8000
|dwOEMMaxIdlePeriod| DCD 0x3e8

  00000			 AREA	 |.rdata|, DATA, READONLY
|EdbgVendorIds| DCW 0x0
	DCW	0x0
	DCD	0x4033
	DCB	0x1
	DCB	"AD", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x4005
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x1050
	DCW	0x940
	DCD	0x2078
	DCB	0x1
	DCB	"LS", 0x0
	DCW	0x10ec
	DCW	0x8029
	DCD	0xc0f0
	DCB	0x1
	DCB	"KS", 0x0
	DCW	0x10ec
	DCW	0x8129
	DCD	0x0
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0x900b
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xd0c9
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x10ec
	DCW	0x8139
	DCD	0xe04c
	DCB	0x4
	DCB	"RT", 0x0
	DCW	0x1186
	DCW	0x1300
	DCD	0x50ba
	DCB	0x4
	DCB	"DL", 0x0
	DCW	0x100b
	DCW	0x20
	DCD	0xa0cc
	DCB	0x5
	DCB	"NG", 0x0
	DCW	0x10b7
	DCW	0x9050
	DCD	0x6008
	DCB	0x6
	DCB	"3C", 0x0
	DCW	0x10b7
	DCW	0x9200
	DCD	0x476
	DCB	0x6
	DCB	"3C", 0x0
|dwOEMDrWatsonSize| DCD 0x4b000
|dwOEMHighSecurity| DCD 0x2
|dwBank1Enabled| DCD 0xffffffff
|dwCMemDSPEnabled| DCD 0xffffffff
|dwDSP720pEnabled| DCD 0xffffffff
|dwOEMPRCMCLKSSetupTime| DCD 0x140
|dwOEMMPUContextRestore| DCD 0x80001000
	%	4
|?gpioPads@?1??OEMInit@@9@9| DCW 0x520			; `OEMInit'::`2'::gpioPads
	%	2
	DCD	0x20
	DCW	0x51b
	%	2
	DCD	0x20
	DCW	0xd0
	%	2
	DCD	0x21
	DCW	0xd1
	%	2
	DCD	0x21
	DCW	0xd8
	%	2
	DCD	0x21
	DCW	0x50
	%	2
	DCD	0x20
	DCW	0x4c
	%	2
	DCD	0x20
	DCW	0xaf
	%	2
	DCD	0x20
	DCW	0xffff
	%	2
	DCD	0x0
|?gpioPads_37xx@?1??OEMInit@@9@9| DCW 0xd0		; `OEMInit'::`2'::gpioPads_37xx
	%	2
	DCD	0x21
	DCW	0xd1
	%	2
	DCD	0x21
	DCW	0xd8
	%	2
	DCD	0x21
	DCW	0x50
	%	2
	DCD	0x20
	DCW	0x4c
	%	2
	DCD	0x20
	DCW	0xaf
	%	2
	DCD	0x20
	DCW	0xffff
	%	2
	DCD	0x0
	IMPORT	|SOCSetPadConfig|
; File c:\wince600\platform\evm_omap3530\src\inc\bsp_padcfg.h

  00000			 AREA	 |.pdata|, PDATA
|$T47555| DCD	|$LN9@ConfigureP|
	DCD	0x40001601
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |ConfigurePadArray| PROC

; 616  : {

  00000		 |$LN9@ConfigureP|
  00000	e92d40f0	 stmdb       sp!, {r4 - r7, lr}
  00004		 |$M47552|
  00004	e1a04000	 mov         r4, r0

; 617  :     int i=0;
; 618  :     while (padArray[i].padID != (UINT16) -1)

  00008	e1d420b0	 ldrh        r2, [r4]
  0000c	e3a03cff	 mov         r3, #0xFF, 24
  00010	e38350ff	 orr         r5, r3, #0xFF
  00014	e1520005	 cmp         r2, r5
  00018	e3a06000	 mov         r6, #0
  0001c	0a00000b	 beq         |$LN1@ConfigureP|
  00020	e3a01c7f	 mov         r1, #0x7F, 24
  00024	e38170ff	 orr         r7, r1, #0xFF
  00028	e1a03004	 mov         r3, r4
  0002c		 |$LL2@ConfigureP|

; 619  :     {
; 620  :         SOCSetPadConfig(padArray[i].padID,(UINT16) padArray[i].Cfg);

  0002c	e5933004	 ldr         r3, [r3, #4]
  00030	e1a00002	 mov         r0, r2
  00034	e0031007	 and         r1, r3, r7
  00038	eb000000	 bl          SOCSetPadConfig

; 621  :         i++;

  0003c	e2866001	 add         r6, r6, #1
  00040	e0843186	 add         r3, r4, r6, lsl #3
  00044	e1d320b0	 ldrh        r2, [r3]
  00048	e1520005	 cmp         r2, r5
  0004c	1afffff6	 bne         |$LL2@ConfigureP|
  00050		 |$LN1@ConfigureP|

; 622  :     }
; 623  : }

  00050	e8bd40f0	 ldmia       sp!, {r4 - r7, lr}
  00054	e12fff1e	 bx          lr
  00058		 |$M47553|

			 ENDP  ; |ConfigurePadArray|

	IMPORT	|g_dwMeasuredSysClkFreq|
	IMPORT	|OALStall|
	IMPORT	|OALTimerGetReg|
	IMPORT	|g_pTimerRegs|
	IMPORT	|EnableDeviceClocks|
	IMPORT	|OALPAtoVA|
	IMPORT	|GetAddressByDevice|
	IMPORT	|BSPGetGPTPerfDevice|
	IMPORT	|__rt_sdiv64by64|
; File c:\wince600\platform\evm_omap3530\src\oal\oallib\init.c

  00000			 AREA	 |.pdata|, PDATA
|$T47575| DCD	|$LN19@OALCalibra|
	DCD	0x40004501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALCalibrateSysClk| PROC

; 503  : {

  00000		 |$LN19@OALCalibra|
  00000	e92d47f0	 stmdb       sp!, {r4 - r10, lr}
  00004		 |$M47572|

; 504  :     DWORD dw32k_prev,dw32k, dw32k_diff;
; 505  :     DWORD dwSysk_prev,dwSysk, dwSys_diff;
; 506  :     DWORD dwOld;
; 507  :     OMAP_DEVICE gptPerfDevice = BSPGetGPTPerfDevice();

  00004	eb000000	 bl          BSPGetGPTPerfDevice
  00008	e1a0a000	 mov         r10, r0

; 508  :     OMAP_GPTIMER_REGS   *pPerfTimer = OALPAtoUA(GetAddressByDevice(gptPerfDevice));

  0000c	eb000000	 bl          GetAddressByDevice
  00010	e3a01000	 mov         r1, #0
  00014	eb000000	 bl          OALPAtoVA
  00018	e1a04000	 mov         r4, r0

; 509  :     EnableDeviceClocks(gptPerfDevice, TRUE);

  0001c	e1a0000a	 mov         r0, r10
  00020	e3a01001	 mov         r1, #1
  00024	eb000000	 bl          EnableDeviceClocks

; 510  : 
; 511  :     // configure performance timer
; 512  :     //---------------------------------------------------
; 513  :     // Soft reset GPTIMER and wait until finished
; 514  :     SETREG32(&pPerfTimer->TIOCP, SYSCONFIG_SOFTRESET);

  00028	e5943010	 ldr         r3, [r4, #0x10]
  0002c	e3833002	 orr         r3, r3, #2
  00030	e5843010	 str         r3, [r4, #0x10]
  00034		 |$LL10@OALCalibra|

; 515  :     while ((INREG32(&pPerfTimer->TISTAT) & GPTIMER_TISTAT_RESETDONE) == 0);

  00034	e5943014	 ldr         r3, [r4, #0x14]
  00038	e3130001	 tst         r3, #1
  0003c	0afffffc	 beq         |$LL10@OALCalibra|
  00040	e3a03c02	 mov         r3, #2, 24

; 516  :  
; 517  :     // Enable smart idle and autoidle
; 518  :     // Set clock activity - FCLK can be  switched off, 
; 519  :     // L4 interface clock is maintained during wkup.
; 520  :     OUTREG32(&pPerfTimer->TIOCP, 
; 521  :         0x200 | SYSCONFIG_SMARTIDLE|SYSCONFIG_ENAWAKEUP|
; 522  :             SYSCONFIG_AUTOIDLE);

  00044	e3833015	 orr         r3, r3, #0x15
  00048	e5843010	 str         r3, [r4, #0x10]

; 523  :     // clear interrupts
; 524  :     OUTREG32(&pPerfTimer->TISR, 0x00000000);

  0004c	e3a03000	 mov         r3, #0
  00050	e5843018	 str         r3, [r4, #0x18]

; 525  : 
; 526  :     //  Start the timer.  Also set for auto reload
; 527  :     SETREG32(&pPerfTimer->TCLR, GPTIMER_TCLR_ST);

  00054	e5943024	 ldr         r3, [r4, #0x24]
  00058	e3833001	 orr         r3, r3, #1
  0005c	e5843024	 str         r3, [r4, #0x24]
  00060		 |$LL8@OALCalibra|

; 528  :     while ((INREG32(&pPerfTimer->TWPS) & GPTIMER_TWPS_TCLR) != 0);

  00060	e5943034	 ldr         r3, [r4, #0x34]
  00064	e3130001	 tst         r3, #1
  00068	1afffffc	 bne         |$LL8@OALCalibra|

; 529  :     
; 530  : #if SHOW_SYS_CLOCK_VARIATION
; 531  :     int i;
; 532  :     for (i=0; i<100;i++)
; 533  :     {
; 534  : #endif
; 535  : 
; 536  :     dwOld = OALTimerGetReg(&g_pTimerRegs->TCRR);

  0006c	e59f509c	 ldr         r5, [pc, #0x9C]
  00070	e5953000	 ldr         r3, [r5]
  00074	e2830028	 add         r0, r3, #0x28
  00078	eb000000	 bl          OALTimerGetReg
  0007c	e1a06000	 mov         r6, r0
  00080		 |$LL6@OALCalibra|

; 537  :     do 
; 538  :     {
; 539  :         dwSysk_prev = INREG32(&pPerfTimer->TCRR); 
; 540  :         dw32k_prev = OALTimerGetReg(&g_pTimerRegs->TCRR);

  00080	e5953000	 ldr         r3, [r5]
  00084	e5949028	 ldr         r9, [r4, #0x28]
  00088	e2830028	 add         r0, r3, #0x28
  0008c	eb000000	 bl          OALTimerGetReg
  00090	e1a07000	 mov         r7, r0

; 541  :     } while (dw32k_prev == dwOld);

  00094	e1570006	 cmp         r7, r6
  00098	0afffff8	 beq         |$LL6@OALCalibra|
  0009c	e3a03b61	 mov         r3, #0x61, 22

; 542  : 
; 543  :     OALStall(100000);

  000a0	e3830e2a	 orr         r0, r3, #0x2A, 28
  000a4	eb000000	 bl          OALStall

; 544  : 
; 545  :     dwOld = OALTimerGetReg(&g_pTimerRegs->TCRR);

  000a8	e5953000	 ldr         r3, [r5]
  000ac	e2830028	 add         r0, r3, #0x28
  000b0	eb000000	 bl          OALTimerGetReg
  000b4	e1a06000	 mov         r6, r0
  000b8		 |$LL3@OALCalibra|

; 546  :     do
; 547  :     {
; 548  :         dwSysk = INREG32(&pPerfTimer->TCRR);
; 549  :         dw32k = OALTimerGetReg(&g_pTimerRegs->TCRR);

  000b8	e5953000	 ldr         r3, [r5]
  000bc	e5948028	 ldr         r8, [r4, #0x28]
  000c0	e2830028	 add         r0, r3, #0x28
  000c4	eb000000	 bl          OALTimerGetReg
  000c8	e1a02000	 mov         r2, r0

; 550  :     } while (dw32k == dwOld);

  000cc	e1520006	 cmp         r2, r6
  000d0	0afffff8	 beq         |$LL3@OALCalibra|

; 551  : 
; 552  :     dw32k_diff = dw32k - dw32k_prev;
; 553  :     dwSys_diff = dwSysk - dwSysk_prev;

  000d4	e0483009	 sub         r3, r8, r9

; 554  :     
; 555  :     g_dwMeasuredSysClkFreq =  (DWORD) (((INT64)dwSys_diff * 32768) / ((INT64)dw32k_diff)) ;

  000d8	e1a00783	 mov         r0, r3, lsl #15
  000dc	e1a018a3	 mov         r1, r3, lsr #17
  000e0	e3a03000	 mov         r3, #0
  000e4	e0422007	 sub         r2, r2, r7
  000e8	eb000000	 bl          __rt_sdiv64by64
  000ec	e59f3018	 ldr         r3, [pc, #0x18]
  000f0	e1a02001	 mov         r2, r1

; 556  : 
; 557  :     DEBUGMSG(1,(L"SysClock calibrate Frequency = %d\r\n", g_dwMeasuredSysClkFreq));    
; 558  : 
; 559  : #if SHOW_SYS_CLOCK_VARIATION
; 560  :     }
; 561  : #endif
; 562  : 
; 563  :     EnableDeviceClocks(gptPerfDevice, FALSE);

  000f4	e3a01000	 mov         r1, #0
  000f8	e5830000	 str         r0, [r3]
  000fc	e1a0000a	 mov         r0, r10
  00100	eb000000	 bl          EnableDeviceClocks

; 564  : 
; 565  : }

  00104	e8bd47f0	 ldmia       sp!, {r4 - r10, lr}
  00108	e12fff1e	 bx          lr
  0010c		 |$LN20@OALCalibra|
  0010c		 |$LN21@OALCalibra|
  0010c	00000000	 DCD         |g_dwMeasuredSysClkFreq|
  00110		 |$LN22@OALCalibra|
  00110	00000000	 DCD         |g_pTimerRegs|
  00114		 |$M47573|

			 ENDP  ; |OALCalibrateSysClk|

	EXPORT	|OALMux_UpdateOnDeviceStateChange|

  00000			 AREA	 |.pdata|, PDATA
|$T47587| DCD	|$LN5@OALMux_Upd|
	DCD	0x40000200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALMux_UpdateOnDeviceStateChange| PROC

; 577  : {

  00000		 |$LN5@OALMux_Upd|
  00000		 |$M47584|

; 578  :     UNREFERENCED_PARAMETER(devId);
; 579  :     UNREFERENCED_PARAMETER(oldState);
; 580  :     UNREFERENCED_PARAMETER(newState);
; 581  :     UNREFERENCED_PARAMETER(bPreStateChange);
; 582  :     return (DWORD) -1;

  00000	e3e00000	 mvn         r0, #0

; 583  : }

  00004	e12fff1e	 bx          lr
  00008		 |$M47585|

			 ENDP  ; |OALMux_UpdateOnDeviceStateChange|

	EXPORT	|OALMux_InitMuxTable|

  00000			 AREA	 |.pdata|, PDATA
|$T47594| DCD	|$LN5@OALMux_Ini|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALMux_InitMuxTable| PROC

; 587  : {

  00000		 |$LN5@OALMux_Ini|
  00000		 |$M47591|

; 588  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M47592|

			 ENDP  ; |OALMux_InitMuxTable|

	EXPORT	|EnableDebugSerialClock|

  00000			 AREA	 |.pdata|, PDATA
|$T47607| DCD	|$LN19@EnableDebu|
	DCD	0x40003200
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |EnableDebugSerialClock| PROC

; 591  : {  

  00000		 |$LN19@EnableDebu|
  00000		 |$M47604|
  00000	e3a03312	 mov         r3, #0x12, 6

; 592  : #define OMAP_PRCM_PER_CM_REGS_PA            0x48005000
; 593  : 
; 594  :     OMAP_CM_REGS* pCmRegs;
; 595  :     
; 596  :     pCmRegs = (OMAP_CM_REGS*) (OMAP_PRCM_CORE_CM_REGS_PA);

  00004	e3831c4a	 orr         r1, r3, #0x4A, 24

; 597  :    
; 598  :     switch(uart_id)

  00008	e350000a	 cmp         r0, #0xA
  0000c	0a00001d	 beq         |$LN9@EnableDebu|
  00010	e350000b	 cmp         r0, #0xB
  00014	0a00000f	 beq         |$LN6@EnableDebu|
  00018	e350003d	 cmp         r0, #0x3D
  0001c	1a000024	 bne         |$LN7@EnableDebu|
  00020	e3a03312	 mov         r3, #0x12, 6

; 610  :             break;
; 611  : 
; 612  :         case OMAP_DEVICE_UART3:
; 613  :                 pCmRegs = (OMAP_CM_REGS*) (OMAP_PRCM_PER_CM_REGS_PA);

  00024	e3832a05	 orr         r2, r3, #5, 20

; 614  :                 SETREG32(&pCmRegs->CM_FCLKEN_xxx, CM_CLKEN_UART3);

  00028	e5923000	 ldr         r3, [r2]

; 615  :                 SETREG32(&pCmRegs->CM_ICLKEN_xxx, CM_CLKEN_UART3);

  0002c	e59f1090	 ldr         r1, [pc, #0x90]
  00030	e3833b02	 orr         r3, r3, #2, 22
  00034	e5823000	 str         r3, [r2]
  00038	e5913000	 ldr         r3, [r1]
  0003c	e59f207c	 ldr         r2, [pc, #0x7C]
  00040	e3833b02	 orr         r3, r3, #2, 22
  00044	e5813000	 str         r3, [r1]
  00048		 |$LL2@EnableDebu|

; 616  :                 while (INREG32(&pCmRegs->CM_IDLEST1_xxx) & CM_IDLEST_ST_UART3);

  00048	e5923000	 ldr         r3, [r2]
  0004c	e3130b02	 tst         r3, #2, 22
  00050	1afffffc	 bne         |$LL2@EnableDebu|

; 617  :             break;	
; 618  :     	}
; 619  : }

  00054	e12fff1e	 bx          lr
  00058		 |$LN6@EnableDebu|

; 604  :             break;
; 605  : 
; 606  :         case OMAP_DEVICE_UART2:
; 607  :                 SETREG32(&pCmRegs->CM_FCLKEN1_xxx, CM_CLKEN_UART2);

  00058	e5913000	 ldr         r3, [r1]

; 608  :                 SETREG32(&pCmRegs->CM_ICLKEN1_xxx, CM_CLKEN_UART2);

  0005c	e59f0058	 ldr         r0, [pc, #0x58]
  00060	e59f2050	 ldr         r2, [pc, #0x50]
  00064	e3833901	 orr         r3, r3, #1, 18
  00068	e5813000	 str         r3, [r1]
  0006c	e5903000	 ldr         r3, [r0]
  00070	e3833901	 orr         r3, r3, #1, 18
  00074	e5803000	 str         r3, [r0]
  00078		 |$LL5@EnableDebu|

; 609  :                 while (INREG32(&pCmRegs->CM_IDLEST1_xxx) & CM_IDLEST_ST_UART2);

  00078	e5923000	 ldr         r3, [r2]
  0007c	e3130901	 tst         r3, #1, 18
  00080	1afffffc	 bne         |$LL5@EnableDebu|

; 617  :             break;	
; 618  :     	}
; 619  : }

  00084	e12fff1e	 bx          lr
  00088		 |$LN9@EnableDebu|

; 599  :     	{
; 600  :         case OMAP_DEVICE_UART1:
; 601  :                 SETREG32(&pCmRegs->CM_FCLKEN1_xxx, CM_CLKEN_UART1);

  00088	e5913000	 ldr         r3, [r1]

; 602  :                 SETREG32(&pCmRegs->CM_ICLKEN1_xxx, CM_CLKEN_UART1);

  0008c	e59f0028	 ldr         r0, [pc, #0x28]
  00090	e59f2020	 ldr         r2, [pc, #0x20]
  00094	e3833a02	 orr         r3, r3, #2, 20
  00098	e5813000	 str         r3, [r1]
  0009c	e5903000	 ldr         r3, [r0]
  000a0	e3833a02	 orr         r3, r3, #2, 20
  000a4	e5803000	 str         r3, [r0]
  000a8		 |$LL8@EnableDebu|

; 603  :                 while (INREG32(&pCmRegs->CM_IDLEST1_xxx) & CM_IDLEST_ST_UART1);

  000a8	e5923000	 ldr         r3, [r2]
  000ac	e3130a02	 tst         r3, #2, 20
  000b0	1afffffc	 bne         |$LL8@EnableDebu|
  000b4		 |$LN7@EnableDebu|

; 617  :             break;	
; 618  :     	}
; 619  : }

  000b4	e12fff1e	 bx          lr
  000b8		 |$LN20@EnableDebu|
  000b8		 |$LN21@EnableDebu|
  000b8	48004a20	 DCD         0x48004a20
  000bc		 |$LN22@EnableDebu|
  000bc	48004a10	 DCD         0x48004a10
  000c0		 |$LN23@EnableDebu|
  000c0	48005020	 DCD         0x48005020
  000c4		 |$LN24@EnableDebu|
  000c4	48005010	 DCD         0x48005010
  000c8		 |$M47605|

			 ENDP  ; |EnableDebugSerialClock|

	EXPORT	|BSPGpioInit|
	IMPORT	|BSPInsertGpioDevice|
	IMPORT	|Omap_Gpio|
	IMPORT	|Tps659xx_Gpio|

  00000			 AREA	 |.pdata|, PDATA
|$T47619| DCD	|$LN5@BSPGpioIni|
	DCD	0x40000d01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |BSPGpioInit| PROC

; 628  : {

  00000		 |$LN5@BSPGpioIni|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47616|

; 629  :    BSPInsertGpioDevice(0,&Omap_Gpio,NULL);

  00004	e59f1024	 ldr         r1, [pc, #0x24]
  00008	e3a02000	 mov         r2, #0
  0000c	e3a00000	 mov         r0, #0
  00010	eb000000	 bl          BSPInsertGpioDevice

; 630  :    BSPInsertGpioDevice(TRITON_GPIO_PINID_START,&Tps659xx_Gpio,NULL);

  00014	e59f1010	 ldr         r1, [pc, #0x10]
  00018	e3a02000	 mov         r2, #0
  0001c	e3a00c01	 mov         r0, #1, 24
  00020	eb000000	 bl          BSPInsertGpioDevice

; 631  : }

  00024	e49de004	 ldr         lr, [sp], #4
  00028	e12fff1e	 bx          lr
  0002c		 |$LN6@BSPGpioIni|
  0002c		 |$LN7@BSPGpioIni|
  0002c	00000000	 DCD         |Tps659xx_Gpio|
  00030		 |$LN8@BSPGpioIni|
  00030	00000000	 DCD         |Omap_Gpio|
  00034		 |$M47617|

			 ENDP  ; |BSPGpioInit|

	EXPORT	|MmUnmapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T47629| DCD	|$LN5@MmUnmapIoS|
	DCD	0x40000100
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MmUnmapIoSpace| PROC

; 637  : {

  00000		 |$LN5@MmUnmapIoS|
  00000		 |$M47626|

; 638  :     UNREFERENCED_PARAMETER(BaseAddress);
; 639  :     UNREFERENCED_PARAMETER(NumberOfBytes);
; 640  : }

  00000	e12fff1e	 bx          lr
  00004		 |$M47627|

			 ENDP  ; |MmUnmapIoSpace|

	EXPORT	|MmMapIoSpace|

  00000			 AREA	 |.pdata|, PDATA
|$T47640| DCD	|$LN5@MmMapIoSpa|
	DCD	0x40000501
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |MmMapIoSpace| PROC

; 647  : {

  00000		 |$LN5@MmMapIoSpa|
  00000	e52de004	 str         lr, [sp, #-4]!
  00004		 |$M47637|

; 648  :     UNREFERENCED_PARAMETER(NumberOfBytes);
; 649  :     return OALPAtoVA(PhysicalAddress.LowPart,CacheEnable);

  00004	e1a01003	 mov         r1, r3
  00008	eb000000	 bl          OALPAtoVA

; 650  : }

  0000c	e49de004	 ldr         lr, [sp], #4
  00010	e12fff1e	 bx          lr
  00014		 |$M47638|

			 ENDP  ; |MmMapIoSpace|

	EXPORT	|HalContextUpdateDirtyRegister|
	IMPORT	|g_ffContextSaveMask|

  00000			 AREA	 |.pdata|, PDATA
|$T47648| DCD	|$LN5@HalContext|
	DCD	0x40000600
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |HalContextUpdateDirtyRegister| PROC

; 655  : {

  00000		 |$LN5@HalContext|
  00000		 |$M47645|

; 656  :     g_ffContextSaveMask |= ffRegister;

  00000	e59f200c	 ldr         r2, [pc, #0xC]
  00004	e5923000	 ldr         r3, [r2]
  00008	e1833000	 orr         r3, r3, r0
  0000c	e5823000	 str         r3, [r2]

; 657  : }

  00010	e12fff1e	 bx          lr
  00014		 |$LN6@HalContext|
  00014		 |$LN7@HalContext|
  00014	00000000	 DCD         |g_ffContextSaveMask|
  00018		 |$M47646|

			 ENDP  ; |HalContextUpdateDirtyRegister|

	IMPORT	|GPIOClose|
	IMPORT	|GPIOSetMode|
	IMPORT	|GPIOClrBit|
	IMPORT	|GPIOOpen|

  00000			 AREA	 |.pdata|, PDATA
|$T47658| DCD	|$LN5@OALGPIOSet|
	DCD	0x40003101
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OALGPIOSetDefaultValues| PROC

; 660  : {

  00000		 |$LN5@OALGPIOSet|
  00000	e92d4030	 stmdb       sp!, {r4, r5, lr}
  00004		 |$M47655|

; 661  :     HANDLE hGPIO = GPIOOpen();

  00004	eb000000	 bl          GPIOOpen

; 662  : #ifdef BSP_EVM2
; 663  : 
; 664  :     // make TPS659XX MSECURE pin low
; 665  :     GPIOClrBit(hGPIO,TPS659XX_MSECURE_GPIO);            

  00008	e3a01040	 mov         r1, #0x40
  0000c	e1a04000	 mov         r4, r0
  00010	eb000000	 bl          GPIOClrBit

; 666  :     GPIOSetMode(hGPIO, TPS659XX_MSECURE_GPIO,GPIO_DIR_OUTPUT);

  00014	e3a02000	 mov         r2, #0
  00018	e3a01040	 mov         r1, #0x40
  0001c	e1a00004	 mov         r0, r4
  00020	eb000000	 bl          GPIOSetMode

; 667  : 
; 668  :     // configure new EVM2 control signals
; 669  :     // unmute audio AUDIO_MUTE (T2_GPIO6 = 0)
; 670  :     GPIOClrBit(hGPIO,AUDIO_MUTE_GPIO);            

  00024	e3a05c01	 mov         r5, #1, 24
  00028	e3851006	 orr         r1, r5, #6
  0002c	e1a00004	 mov         r0, r4
  00030	eb000000	 bl          GPIOClrBit

; 671  :     GPIOSetMode(hGPIO, AUDIO_MUTE_GPIO,GPIO_DIR_OUTPUT);

  00034	e3a02000	 mov         r2, #0
  00038	e3851006	 orr         r1, r5, #6
  0003c	e1a00004	 mov         r0, r4
  00040	eb000000	 bl          GPIOSetMode

; 672  : 
; 673  :     // turn on nFULL_MODEM_EN (GPIO_55 = 0)
; 674  :     GPIOClrBit(hGPIO,nFULL_MODEM_EN_GPIO);            

  00044	e3a01037	 mov         r1, #0x37
  00048	e1a00004	 mov         r0, r4
  0004c	eb000000	 bl          GPIOClrBit

; 675  :     GPIOSetMode(hGPIO, nFULL_MODEM_EN_GPIO,GPIO_DIR_OUTPUT);

  00050	e3a02000	 mov         r2, #0
  00054	e3a01037	 mov         r1, #0x37
  00058	e1a00004	 mov         r0, r4
  0005c	eb000000	 bl          GPIOSetMode

; 676  : 
; 677  :     // route USB2 signals to transceiver (GPIO_61 = 0)
; 678  :     GPIOClrBit(hGPIO,USB2_ROUTE_SELECT_GPIO);            

  00060	e3a0103d	 mov         r1, #0x3D
  00064	e1a00004	 mov         r0, r4
  00068	eb000000	 bl          GPIOClrBit

; 679  :     GPIOSetMode(hGPIO, USB2_ROUTE_SELECT_GPIO,GPIO_DIR_OUTPUT);

  0006c	e3a02000	 mov         r2, #0
  00070	e3a0103d	 mov         r1, #0x3D
  00074	e1a00004	 mov         r0, r4
  00078	eb000000	 bl          GPIOSetMode

; 680  : 
; 681  :     // maintain TVP in reset state (to reduce power consumption)
; 682  :     GPIOClrBit(hGPIO, VIDEO_CAPTURE_RESET);

  0007c	e3a01062	 mov         r1, #0x62
  00080	e1a00004	 mov         r0, r4
  00084	eb000000	 bl          GPIOClrBit

; 683  :     GPIOSetMode(hGPIO, VIDEO_CAPTURE_RESET, GPIO_DIR_OUTPUT);

  00088	e3a02000	 mov         r2, #0
  0008c	e3a01062	 mov         r1, #0x62
  00090	e1a00004	 mov         r0, r4
  00094	eb000000	 bl          GPIOSetMode

; 684  : 
; 685  :     // enable new EVM2 control signals (T2_GPIO2 = 0)    
; 686  :     GPIOClrBit(hGPIO,NEW_EVM2_CTRL_GPIO);            

  00098	e3851002	 orr         r1, r5, #2
  0009c	e1a00004	 mov         r0, r4
  000a0	eb000000	 bl          GPIOClrBit

; 687  :     GPIOSetMode(hGPIO, NEW_EVM2_CTRL_GPIO,GPIO_DIR_OUTPUT);

  000a4	e3a02000	 mov         r2, #0
  000a8	e3851002	 orr         r1, r5, #2
  000ac	e1a00004	 mov         r0, r4
  000b0	eb000000	 bl          GPIOSetMode

; 688  : #endif
; 689  :     GPIOClose(hGPIO);

  000b4	e1a00004	 mov         r0, r4
  000b8	eb000000	 bl          GPIOClose

; 690  : }

  000bc	e8bd4030	 ldmia       sp!, {r4, r5, lr}
  000c0	e12fff1e	 bx          lr
  000c4		 |$M47656|

			 ENDP  ; |OALGPIOSetDefaultValues|


  00000			 AREA	 |.pdata|, PDATA
|$T47670| DCD	|$LN9@OEMEnumExt|
	DCD	0x40003e01
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMEnumExtensionDRAM| PROC

; 693  : {

  00000		 |$LN9@OEMEnumExt|
  00000	e92d4070	 stmdb       sp!, {r4 - r6, lr}
  00004		 |$M47667|
  00004	e3510000	 cmp         r1, #0
  00008	e1a0e000	 mov         lr, r0

; 694  :     DWORD cSections = 0;

  0000c	e3a00000	 mov         r0, #0

; 695  :     // If BANK1 is enabled, give it the OS
; 696  :     if ((cSections < cMemSections) && (dwBank1Enabled == 1))

  00010	0a000035	 beq         |$LN1@OEMEnumExt|
  00014	e59f40d8	 ldr         r4, [pc, #0xD8]
  00018	e3a06000	 mov         r6, #0
  0001c	e5943000	 ldr         r3, [r4]
  00020	e3530001	 cmp         r3, #1
  00024	03a03489	 moveq       r3, #0x89, 8

; 697  :     {
; 698  :         pMemSections[cSections].dwFlags = 0;
; 699  :         pMemSections[cSections].dwStart = IMAGE_WINCE_RAM_BANK1_CA;

  00028	0383360a	 orreq       r3, r3, #0xA, 12

; 700  :         pMemSections[cSections].dwLen = IMAGE_WINCE_RAM_BANK1_SIZE;

  0002c	03a02666	 moveq       r2, #0x66, 12

; 701  :         cSections++;

  00030	03a00001	 moveq       r0, #1
  00034	058e3004	 streq       r3, [lr, #4]
  00038	058e6000	 streq       r6, [lr]
  0003c	058e2008	 streq       r2, [lr, #8]

; 702  :     }
; 703  :     // If DSP 720p region is not used for the DSP, give it to the OS
; 704  :     if ((cSections < cMemSections) && (dwBank1Enabled == 1) && (dwDSP720pEnabled != 1))

  00040	e1500001	 cmp         r0, r1
  00044	2a000028	 bcs         |$LN1@OEMEnumExt|
  00048	e5943000	 ldr         r3, [r4]
  0004c	e3530001	 cmp         r3, #1
  00050	1a00000b	 bne         |$LN3@OEMEnumExt|
  00054	e5943008	 ldr         r3, [r4, #8]
  00058	e3530001	 cmp         r3, #1
  0005c	0a000008	 beq         |$LN3@OEMEnumExt|

; 705  :     {
; 706  :         pMemSections[cSections].dwFlags = 0;

  00060	e0803080	 add         r3, r0, r0, lsl #1
  00064	e1a0200e	 mov         r2, lr
  00068	e7a26103	 str         r6, [r2, +r3, lsl #2]!
  0006c	e3a03485	 mov         r3, #0x85, 8

; 707  :         pMemSections[cSections].dwStart = IMAGE_DSP_720P_CA;

  00070	e3833502	 orr         r3, r3, #2, 10

; 708  :         pMemSections[cSections].dwLen = IMAGE_DSP_720P_SIZE;

  00074	e3a0561a	 mov         r5, #0x1A, 12
  00078	e5823004	 str         r3, [r2, #4]
  0007c	e5825008	 str         r5, [r2, #8]

; 709  :         cSections++;

  00080	e2800001	 add         r0, r0, #1
  00084		 |$LN3@OEMEnumExt|

; 710  :     }
; 711  :     // If CMEM region is not used for the DSP, give it to the OS
; 712  :     if ((cSections < cMemSections) && (dwCMemDSPEnabled != 1))

  00084	e1500001	 cmp         r0, r1
  00088	2a000017	 bcs         |$LN1@OEMEnumExt|
  0008c	e5943004	 ldr         r3, [r4, #4]
  00090	e3530001	 cmp         r3, #1
  00094	0a000008	 beq         |$LN2@OEMEnumExt|

; 713  :     {
; 714  :         pMemSections[cSections].dwFlags = 0;

  00098	e0803080	 add         r3, r0, r0, lsl #1
  0009c	e1a0200e	 mov         r2, lr
  000a0	e7a26103	 str         r6, [r2, +r3, lsl #2]!
  000a4	e3a03321	 mov         r3, #0x21, 6

; 715  :         pMemSections[cSections].dwStart = IMAGE_CMEM_CA;

  000a8	e3833502	 orr         r3, r3, #2, 10

; 716  :         pMemSections[cSections].dwLen = IMAGE_CMEM_SIZE;

  000ac	e3a05401	 mov         r5, #1, 8
  000b0	e5823004	 str         r3, [r2, #4]
  000b4	e5825008	 str         r5, [r2, #8]

; 717  :         cSections++;

  000b8	e2800001	 add         r0, r0, #1
  000bc		 |$LN2@OEMEnumExt|

; 718  :     }
; 719  :     // If DSP region is not used for the DSP, give it to the OS
; 720  :     if ((cSections < cMemSections) && (dwCMemDSPEnabled != 1))

  000bc	e1500001	 cmp         r0, r1
  000c0	2a000009	 bcs         |$LN1@OEMEnumExt|
  000c4	e5943004	 ldr         r3, [r4, #4]
  000c8	e3530001	 cmp         r3, #1

; 721  :     {
; 722  :         pMemSections[cSections].dwFlags = 0;

  000cc	10803080	 addne       r3, r0, r0, lsl #1
  000d0	17ae6103	 strne       r6, [lr, +r3, lsl #2]!
  000d4	13a03487	 movne       r3, #0x87, 8

; 723  :         pMemSections[cSections].dwStart = IMAGE_DSP_CA;

  000d8	13833602	 orrne       r3, r3, #2, 12

; 724  :         pMemSections[cSections].dwLen = IMAGE_DSP_SIZE;

  000dc	13a0260e	 movne       r2, #0xE, 12
  000e0	158e3004	 strne       r3, [lr, #4]
  000e4	158e2008	 strne       r2, [lr, #8]

; 725  :         cSections++;

  000e8	12800001	 addne       r0, r0, #1
  000ec		 |$LN1@OEMEnumExt|

; 726  :     }    
; 727  :     
; 728  :     return cSections;
; 729  : }

  000ec	e8bd4070	 ldmia       sp!, {r4 - r6, lr}
  000f0	e12fff1e	 bx          lr
  000f4		 |$LN10@OEMEnumExt|
  000f4		 |$LN11@OEMEnumExt|
  000f4	00000000	 DCD         |dwBank1Enabled|
  000f8		 |$M47668|

			 ENDP  ; |OEMEnumExtensionDRAM|

	EXPORT	|OEMInit|
	EXPORT	|??_C@_1BG@OFOAIMMC@?$AA?9?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GC@DDKEAEKM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAf?$AAa?$AAm?$AAi?$AAl?$AAy?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EO@POAKKMOD@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAG@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@PJJENIL@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA3?$AA?$AN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@MDDDENBF@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA2?$AA?$AN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@ENLMEKPG@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA1?$AA?$AN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EE@LCPCELLP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAG?$AAP?$AAM?$AAC?$AA?$AN@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GI@LGFJGPEK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1GE@OIDINFAG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa@| [ DATA ] ; `string'
	EXPORT	|??_C@_1EA@GGPFFMPF@?$AAO?$AAA?$AAL?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAL?$AA2?$AA?5?$AAA?$AAu?$AAx?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DI@EKICDEND@?$AAO?$AAA?$AAL?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAr?$AAe?$AAv?$AAi?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?3?$AA?$CF?$AAs?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_17EIAJIHBF@?$AAE?$AAV?$AAM?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1M@KGLOAAMK@?$AAO?$AAM?$AAA?$AAP?$AA3?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_04BPMAMLNJ@EVM?9?$AA@| [ DATA ]	; `string'
	EXPORT	|??_C@_1EA@KPKHFCLF@?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAF?$AAa?$AAm?$AAi?$AAl?$AAy?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@KEKEAPD@?$AAE?$AAV?$AAM?$AA3?$AA5?$AA3?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@CPMDPFBC@?$AAO?$AAM?$AAA?$AAP?$AA3?$AA5?$AA3?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_08DGJGOJCE@EVM3530?9?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BA@EIGPEHIO@?$AAE?$AAV?$AAM?$AA3?$AA7?$AA3?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@KGJEKGDB@?$AAD?$AAM?$AA3?$AA7?$AA3?$AA0?$AA?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_08EMFGLKEE@EVM3730?9?$AA@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@JHBBNGEC@?$AA?$CL?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| [ DATA ] ; `string'
	IMPORT	|NKForceCleanBoot|
	IMPORT	|g_oalIoCtlClockSpeed|
	IMPORT	|Get_CPUMaxSpeed|
	IMPORT	|OEMDeinitDebugSerial|
	IMPORT	|OALArgsQuery|
	IMPORT	|KITLIoctl|
	IMPORT	|OALPerformanceTimerInit|
	IMPORT	|OALSRAMFnInit|
	IMPORT	|GPIOInit|
	IMPORT	|RequestAndConfigurePadArray|
	IMPORT	|RequestDevicePads|
	IMPORT	|BSPGetDevicePadInfo|
	IMPORT	|OALTimerInit|
	IMPORT	|OALIntrInit|
	IMPORT	|OALVFPInitialize|
	IMPORT	|OALPowerInit|
	IMPORT	|BSPGetAllPadsInfo|
	IMPORT	|OALPadCfgInit|
	IMPORT	|EnableUnalignedAccess|
	IMPORT	|OALCacheGlobalsInit|
	IMPORT	|OALSetMemoryAttributes|
	IMPORT	|OALIsProcessorFeaturePresent|
	IMPORT	|g_pOemGlobal|
	IMPORT	|OALGetL2Aux|
	IMPORT	|g_oalIoCtlProcessorName|
	IMPORT	|g_oalIoCtlPlatformType|
	IMPORT	|g_oalIoCtlPlatformName|
	IMPORT	|Get_CPUVersion|
	IMPORT	|OALLocalAllocInit|
	IMPORT	|NKDbgPrintfW|
	IMPORT	|dpCurSettings|
	IMPORT	|OALLogSetZones|

  00008			 AREA	 |.bss|, NOINIT
|?allocationPool@?1??OEMInit@@9@9| % 0x800		; `OEMInit'::`2'::allocationPool
|?allocationPool@?1??OEMInit@@9@9| % 0x800		; `OEMInit'::`2'::allocationPool

  00000			 AREA	 |.pdata|, PDATA
|$T47716| DCD	|$LN59@OEMInit|
	DCD	0x40010102

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@OFOAIMMC@?$AA?9?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "-"
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GC@DDKEAEKM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAf?$AAa?$AAm?$AAi?$AAl?$AAy?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "P", 0x0, "U"
	DCB	0x0, " ", 0x0, "f", 0x0, "a", 0x0, "m", 0x0, "i", 0x0, "l"
	DCB	0x0, "y", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, " ", 0x0, "i"
	DCB	0x0, "s", 0x0, " ", 0x0, "n", 0x0, "o", 0x0, "t", 0x0, " "
	DCB	0x0, "s", 0x0, "u", 0x0, "p", 0x0, "p", 0x0, "o", 0x0, "r"
	DCB	0x0, "t", 0x0, "e", 0x0, "d", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0
	DCB	0x0					; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EO@POAKKMOD@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAG@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "p"
	DCB	0x0, "a", 0x0, "d", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "t", 0x0, "h", 0x0, "e", 0x0, " "
	DCB	0x0, "G", 0x0, "P", 0x0, "I", 0x0, "O", 0x0, "s", 0x0, 0xd
	DCB	0x0, 0xa, 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@PJJENIL@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA3?$AA?$AN@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "p"
	DCB	0x0, "a", 0x0, "d", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "I", 0x0, "2", 0x0, "C", 0x0, "3"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@MDDDENBF@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA2?$AA?$AN@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "p"
	DCB	0x0, "a", 0x0, "d", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "I", 0x0, "2", 0x0, "C", 0x0, "2"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@ENLMEKPG@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA1?$AA?$AN@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "p"
	DCB	0x0, "a", 0x0, "d", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "I", 0x0, "2", 0x0, "C", 0x0, "1"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EE@LCPCELLP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAG?$AAP?$AAM?$AAC?$AA?$AN@| DCB "F"
	DCB	0x0, "a", 0x0, "i", 0x0, "l", 0x0, "e", 0x0, "d", 0x0, " "
	DCB	0x0, "t", 0x0, "o", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "q"
	DCB	0x0, "u", 0x0, "e", 0x0, "s", 0x0, "t", 0x0, " ", 0x0, "p"
	DCB	0x0, "a", 0x0, "d", 0x0, "s", 0x0, " ", 0x0, "f", 0x0, "o"
	DCB	0x0, "r", 0x0, " ", 0x0, "G", 0x0, "P", 0x0, "M", 0x0, "C"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GI@LGFJGPEK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, ":", 0x0, " ", 0x0, "F", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, " "
	DCB	0x0, "s", 0x0, "y", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "m"
	DCB	0x0, " ", 0x0, "c", 0x0, "l", 0x0, "o", 0x0, "c", 0x0, "k"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1GE@OIDINFAG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa@| DCB "E"
	DCB	0x0, "R", 0x0, "R", 0x0, "O", 0x0, "R", 0x0, ":", 0x0, " "
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, ":", 0x0, " ", 0x0, "f", 0x0, "a", 0x0, "i"
	DCB	0x0, "l", 0x0, "e", 0x0, "d", 0x0, " ", 0x0, "t", 0x0, "o"
	DCB	0x0, " ", 0x0, "i", 0x0, "n", 0x0, "i", 0x0, "t", 0x0, "i"
	DCB	0x0, "a", 0x0, "l", 0x0, "i", 0x0, "z", 0x0, "e", 0x0, " "
	DCB	0x0, "i", 0x0, "n", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, "r"
	DCB	0x0, "u", 0x0, "p", 0x0, "t", 0x0, "s", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@GGPFFMPF@?$AAO?$AAA?$AAL?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAL?$AA2?$AA?5?$AAA?$AAu?$AAx?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@| DCB "O"
	DCB	0x0, "A", 0x0, "L", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "P"
	DCB	0x0, "U", 0x0, " ", 0x0, "L", 0x0, "2", 0x0, " ", 0x0, "A"
	DCB	0x0, "u", 0x0, "x", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "g"
	DCB	0x0, "i", 0x0, "s", 0x0, "t", 0x0, "e", 0x0, "r", 0x0, " "
	DCB	0x0, "0", 0x0, "x", 0x0, "%", 0x0, "x", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1DI@EKICDEND@?$AAO?$AAA?$AAL?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAr?$AAe?$AAv?$AAi?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?3?$AA?$CF?$AAs?$AA?$AN?$AA?6?$AA?$AA@| DCB "O"
	DCB	0x0, "A", 0x0, "L", 0x0, ":", 0x0, " ", 0x0, "C", 0x0, "P"
	DCB	0x0, "U", 0x0, " ", 0x0, "r", 0x0, "e", 0x0, "v", 0x0, "i"
	DCB	0x0, "s", 0x0, "i", 0x0, "o", 0x0, "n", 0x0, " ", 0x0, "0"
	DCB	0x0, "x", 0x0, "%", 0x0, "x", 0x0, ":", 0x0, "%", 0x0, "s"
	DCB	0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_17EIAJIHBF@?$AAE?$AAV?$AAM?$AA?$AA@| DCB "E", 0x0, "V", 0x0, "M", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1M@KGLOAAMK@?$AAO?$AAM?$AAA?$AAP?$AA3?$AA?$AA@| DCB "O", 0x0, "M", 0x0
	DCB	"A", 0x0, "P", 0x0, "3", 0x0, 0x0, 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_04BPMAMLNJ@EVM?9?$AA@| DCB "EVM-", 0x0		; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1EA@KPKHFCLF@?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAF?$AAa?$AAm?$AAi?$AAl?$AAy?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@| DCB "O"
	DCB	0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "i", 0x0, "t"
	DCB	0x0, ":", 0x0, " ", 0x0, "u", 0x0, "n", 0x0, "k", 0x0, "n"
	DCB	0x0, "o", 0x0, "w", 0x0, " ", 0x0, "C", 0x0, "P", 0x0, "U"
	DCB	0x0, " ", 0x0, "F", 0x0, "a", 0x0, "m", 0x0, "i", 0x0, "l"
	DCB	0x0, "y", 0x0, " ", 0x0, "%", 0x0, "d", 0x0, 0xd, 0x0, 0xa
	DCB	0x0, 0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@KEKEAPD@?$AAE?$AAV?$AAM?$AA3?$AA5?$AA3?$AA0?$AA?$AA@| DCB "E", 0x0
	DCB	"V", 0x0, "M", 0x0, "3", 0x0, "5", 0x0, "3", 0x0, "0", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BC@CPMDPFBC@?$AAO?$AAM?$AAA?$AAP?$AA3?$AA5?$AA3?$AA0?$AA?$AA@| DCB "O"
	DCB	0x0, "M", 0x0, "A", 0x0, "P", 0x0, "3", 0x0, "5", 0x0, "3"
	DCB	0x0, "0", 0x0, 0x0, 0x0			; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_08DGJGOJCE@EVM3530?9?$AA@| DCB "EVM3530-", 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BA@EIGPEHIO@?$AAE?$AAV?$AAM?$AA3?$AA7?$AA3?$AA0?$AA?$AA@| DCB "E", 0x0
	DCB	"V", 0x0, "M", 0x0, "3", 0x0, "7", 0x0, "3", 0x0, "0", 0x0
	DCB	0x0, 0x0				; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1O@KGJEKGDB@?$AAD?$AAM?$AA3?$AA7?$AA3?$AA0?$AA?$AA@| DCB "D", 0x0, "M"
	DCB	0x0, "3", 0x0, "7", 0x0, "3", 0x0, "0", 0x0, 0x0, 0x0 ; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_08EMFGLKEE@EVM3730?9?$AA@| DCB "EVM3730-", 0x0	; `string'

  00000			 AREA	 |.rdata|, DATA, READONLY
|??_C@_1BG@JHBBNGEC@?$AA?$CL?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@| DCB "+"
	DCB	0x0, "O", 0x0, "E", 0x0, "M", 0x0, "I", 0x0, "n", 0x0, "i"
	DCB	0x0, "t", 0x0, 0xd, 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'
; Function compile flags: /Ogspy

  00000			 AREA	 |.text|, CODE, ARM

  00000		 |OEMInit| PROC

; 198  : {    

  00000		 |$LN59@OEMInit|
  00000	e92d4ff0	 stmdb       sp!, {r4 - r11, lr}
  00004	e24dd008	 sub         sp, sp, #8
  00008		 |$M47713|

; 199  :     BOOL           *pColdBoot;
; 200  :     BOOL           *pRetailMsgEnable;
; 201  :     UINT32         CpuRevision;	
; 202  :     static const PAD_INFO gpioPads[] = {GPIO_PADS END_OF_PAD_ARRAY};
; 203  :     static const PAD_INFO gpioPads_37xx[] = {GPIO_PADS_37XX END_OF_PAD_ARRAY};	
; 204  :     static UCHAR allocationPool[2048];
; 205  : 
; 206  : 
; 207  :     //----------------------------------------------------------------------
; 208  :     // Initialize OAL log zones
; 209  :     //----------------------------------------------------------------------
; 210  : 
; 211  :     OALLogSetZones( //(0xFFFF & ~((1<<OAL_LOG_CACHE)|(1<<OAL_LOG_INTR)))|
; 212  :     //           (1<<OAL_LOG_VERBOSE)  |
; 213  :     //           (1<<OAL_LOG_INFO)     |
; 214  :                (1<<OAL_LOG_ERROR)    |
; 215  :                (1<<OAL_LOG_WARN)     
; 216  :     //           (1<<OAL_LOG_IOCTL)    |
; 217  :     //           (1<<OAL_LOG_FUNC)     |
; 218  :     //           (1<<OAL_LOG_INTR)     |    
; 219  :                );

  00008	e3a00003	 mov         r0, #3
  0000c	eb000000	 bl          OALLogSetZones

; 220  :     OALMSG(OAL_FUNC, (L"+OEMInit\r\n"));

  00010	e59f63e8	 ldr         r6, [pc, #0x3E8]
  00014	e5963440	 ldr         r3, [r6, #0x440]
  00018	e3130004	 tst         r3, #4
  0001c	159f03d8	 ldrne       r0, [pc, #0x3D8]
  00020	1b000000	 blne        NKDbgPrintfW

; 221  : 
; 222  :     //----------------------------------------------------------------------
; 223  :     // Initialize the OAL memory allocation system (TI code)
; 224  :     //----------------------------------------------------------------------
; 225  :     OALLocalAllocInit(allocationPool,sizeof(allocationPool));

  00024	e59fa3cc	 ldr         r10, [pc, #0x3CC]
  00028	e3a01b02	 mov         r1, #2, 22
  0002c	e1a0000a	 mov         r0, r10
  00030	eb000000	 bl          OALLocalAllocInit

; 226  : 
; 227  :     //----------------------------------------------------------------------
; 228  :     // Determion CPU revison
; 229  :     //----------------------------------------------------------------------
; 230  :     CpuRevision = Get_CPUVersion();

  00034	eb000000	 bl          Get_CPUVersion

; 231  :     g_dwCpuRevision = CpuRevision & CPU_REVISION_MASK;
; 232  :     g_dwCpuFamily = (CpuRevision >> CPU_FAMILY_SHIFT) & CPU_REVISION_MASK;

  00038	e59f43b4	 ldr         r4, [pc, #0x3B4]
  0003c	e59fb3ac	 ldr         r11, [pc, #0x3AC]
  00040	e1a03800	 mov         r3, r0, lsl #16
  00044	e1a01c23	 mov         r1, r3, lsr #24
  00048	e20090ff	 and         r9, r0, #0xFF
  0004c	e58b1000	 str         r1, [r11]

; 233  :     /* save CPU family names */
; 234  :     if(g_dwCpuFamily == CPU_FAMILY_DM37XX)

  00050	e3510001	 cmp         r1, #1
  00054	e5849000	 str         r9, [r4]
  00058	1a000009	 bne         |$LN20@OEMInit|

; 235  :     {
; 236  :         g_oalIoCtlPlatformType = L"EVM3730";

  0005c	e59fe388	 ldr         lr, [pc, #0x388]

; 237  :         g_oalIoCtlPlatformName = L"EVM3730";
; 238  :         g_oalIoCtlProcessorName   = L"DM3730";	  

  00060	e59f7380	 ldr         r7, [pc, #0x380]

; 239  :         gDevice_prefix = "EVM3730-";

  00064	e59f2378	 ldr         r2, [pc, #0x378]
  00068		 |$LN56@OEMInit|
  00068	e59f0358	 ldr         r0, [pc, #0x358]
  0006c	e59f1358	 ldr         r1, [pc, #0x358]
  00070	e59f3348	 ldr         r3, [pc, #0x348]
  00074	e580e000	 str         lr, [r0]
  00078	e581e000	 str         lr, [r1]
  0007c	e5832000	 str         r2, [r3]
  00080	ea000013	 b           |$LN52@OEMInit|
  00084		 |$LN20@OEMInit|

; 240  :     }
; 241  :     else if (g_dwCpuFamily == CPU_FAMILY_OMAP35XX) 

  00084	e3510000	 cmp         r1, #0

; 242  :     {
; 243  :         g_oalIoCtlPlatformType = L"EVM3530";

  00088	059fe350	 ldreq       lr, [pc, #0x350]

; 244  :         g_oalIoCtlPlatformName = L"EVM3530";		
; 245  :         g_oalIoCtlProcessorName   = L"OMAP3530";	

  0008c	059f7348	 ldreq       r7, [pc, #0x348]

; 246  :         gDevice_prefix = "EVM3530-";

  00090	059f2340	 ldreq       r2, [pc, #0x340]
  00094	0afffff3	 beq         |$LN56@OEMInit|
  00098	e5963440	 ldr         r3, [r6, #0x440]

; 247  :     }
; 248  :     else
; 249  :     {
; 250  :         OALMSG(OAL_ERROR, (L"OEMInit: unknow CPU Family %d\r\n", g_dwCpuFamily));

  0009c	e3130001	 tst         r3, #1
  000a0	0a000002	 beq         |$LN25@OEMInit|
  000a4	e59f0328	 ldr         r0, [pc, #0x328]
  000a8	eb000000	 bl          NKDbgPrintfW
  000ac	e5949000	 ldr         r9, [r4]
  000b0		 |$LN25@OEMInit|

; 251  :         g_oalIoCtlPlatformType = L"EVM";

  000b0	e59f5318	 ldr         r5, [pc, #0x318]
  000b4	e59fe310	 ldr         lr, [pc, #0x310]

; 252  :         g_oalIoCtlPlatformName = L"EVM";		

  000b8	e59f4308	 ldr         r4, [pc, #0x308]

; 253  :         g_oalIoCtlProcessorName   = L"OMAP3";	
; 254  :         gDevice_prefix = "EVM-";

  000bc	e59f0300	 ldr         r0, [pc, #0x300]
  000c0	e59f32f8	 ldr         r3, [pc, #0x2F8]
  000c4	e59f72f0	 ldr         r7, [pc, #0x2F0]
  000c8	e58e5000	 str         r5, [lr]
  000cc	e5845000	 str         r5, [r4]
  000d0	e5830000	 str         r0, [r3]
  000d4		 |$LN52@OEMInit|
  000d4	e5963440	 ldr         r3, [r6, #0x440]
  000d8	e59f82d8	 ldr         r8, [pc, #0x2D8]

; 255  : 		
; 256  :     }
; 257  :     OALMSG(OAL_ERROR, (L"OAL: CPU revision 0x%x:%s\r\n", g_dwCpuRevision, g_oalIoCtlProcessorName));

  000dc	e3130001	 tst         r3, #1
  000e0	159f02cc	 ldrne       r0, [pc, #0x2CC]
  000e4	11a02007	 movne       r2, r7
  000e8	11a01009	 movne       r1, r9
  000ec	e5887000	 str         r7, [r8]
  000f0	1b000000	 blne        NKDbgPrintfW

; 258  : 
; 259  :     OALMSG(1, (L"OAL: CPU L2 Aux register 0x%x\r\n", OALGetL2Aux()));

  000f4	eb000000	 bl          OALGetL2Aux
  000f8	e1a01000	 mov         r1, r0
  000fc	e59f02ac	 ldr         r0, [pc, #0x2AC]
  00100	eb000000	 bl          NKDbgPrintfW

; 260  :     //----------------------------------------------------------------------
; 261  :     // Update platform specific variables
; 262  :     //----------------------------------------------------------------------
; 263  : 
; 264  :     //----------------------------------------------------------------------
; 265  :     // Update kernel variables
; 266  :     //----------------------------------------------------------------------
; 267  : 
; 268  :     dwNKDrWatsonSize = dwOEMDrWatsonSize;

  00104	e59f52a0	 ldr         r5, [pc, #0x2A0]
  00108	e59f4298	 ldr         r4, [pc, #0x298]
  0010c	e3a01c27	 mov         r1, #0x27, 24
  00110	e5952000	 ldr         r2, [r5]
  00114	e5943000	 ldr         r3, [r4]

; 269  : 
; 270  :     // Alarm has resolution 10 seconds (actually has 1 second resolution, 
; 271  : 	// but setting alarm too close to suspend will cause problems).
; 272  :     dwNKAlarmResolutionMSec = 10000;

  00118	e3811010	 orr         r1, r1, #0x10

; 273  : 
; 274  :     // Set extension functions
; 275  :     pOEMIsProcessorFeaturePresent = OALIsProcessorFeaturePresent;

  0011c	e59f0280	 ldr         r0, [pc, #0x280]
  00120	e58320a8	 str         r2, [r3, #0xA8]
  00124	e5943000	 ldr         r3, [r4]

; 276  :     pfnOEMSetMemoryAttributes     = OALSetMemoryAttributes;

  00128	e59f2270	 ldr         r2, [pc, #0x270]

; 277  :     g_pOemGlobal->pfnEnumExtensionDRAM = OEMEnumExtensionDRAM;

  0012c	e59fe268	 ldr         lr, [pc, #0x268]
  00130	e58310e4	 str         r1, [r3, #0xE4]
  00134	e5943000	 ldr         r3, [r4]
  00138	e58300c0	 str         r0, [r3, #0xC0]
  0013c	e5943000	 ldr         r3, [r4]
  00140	e58320bc	 str         r2, [r3, #0xBC]
  00144	e5943000	 ldr         r3, [r4]
  00148	e583e05c	 str         lr, [r3, #0x5C]

; 278  :     
; 279  :     //----------------------------------------------------------------------
; 280  :     // Windows Mobile backward compatibility issue...
; 281  :     //----------------------------------------------------------------------
; 282  : /*
; 283  :     switch (dwOEMTargetProject)
; 284  :         {
; 285  :         case OEM_TARGET_PROJECT_SMARTFON:
; 286  :         case OEM_TARGET_PROJECT_WPC:
; 287  :             CEProcessorType = PROCESSOR_STRONGARM;
; 288  :             break;
; 289  :         }
; 290  : */
; 291  :     //----------------------------------------------------------------------
; 292  :     // Initialize cache globals
; 293  :     //----------------------------------------------------------------------
; 294  : 
; 295  :     OALCacheGlobalsInit();

  0014c	eb000000	 bl          OALCacheGlobalsInit

; 296  : 
; 297  :     EnableUnalignedAccess();

  00150	eb000000	 bl          EnableUnalignedAccess

; 298  :     
; 299  :     #ifdef DEBUG
; 300  :         OALMSG(1, (L"CPU CP15 Control Register = 0x%x\r\n", GetCp15ControlRegister()));
; 301  :         OALMSG(1, (L"CPU CP15 Auxiliary Control Register = 0x%x\r\n", GetCp15AuxiliaryControlRegister()));
; 302  :     #endif
; 303  :     //----------------------------------------------------------------------
; 304  :     // Initialize PAD cfg
; 305  :     //----------------------------------------------------------------------
; 306  :     OALPadCfgInit();

  00154	eb000000	 bl          OALPadCfgInit

; 307  : 	
; 308  :     //----------------------------------------------------------------------
; 309  :     // configure pin mux
; 310  :     //----------------------------------------------------------------------
; 311  :     ConfigurePadArray(BSPGetAllPadsInfo());

  00158	eb000000	 bl          BSPGetAllPadsInfo
  0015c	eb000000	 bl          ConfigurePadArray

; 312  :     //----------------------------------------------------------------------
; 313  :     // Initialize Power Domains
; 314  :     //----------------------------------------------------------------------
; 315  :     
; 316  :     OALPowerInit();

  00160	eb000000	 bl          OALPowerInit

; 317  : 
; 318  :     //----------------------------------------------------------------------
; 319  :     // Initialize Vector Floating Point co-processor
; 320  :     //----------------------------------------------------------------------
; 321  : 
; 322  :     OALVFPInitialize(g_pOemGlobal);

  00164	e5940000	 ldr         r0, [r4]
  00168	eb000000	 bl          OALVFPInitialize

; 323  : 
; 324  :     //----------------------------------------------------------------------
; 325  :     // Initialize interrupt
; 326  :     //----------------------------------------------------------------------
; 327  : 
; 328  :     if (!OALIntrInit())

  0016c	eb000000	 bl          OALIntrInit
  00170	e3500000	 cmp         r0, #0
  00174	1a000005	 bne         |$LN16@OEMInit|

; 329  :         {
; 330  :         OALMSG(OAL_ERROR, (
; 331  :             L"ERROR: OEMInit: failed to initialize interrupts\r\n"
; 332  :             ));

  00178	e5963440	 ldr         r3, [r6, #0x440]
  0017c	e3130001	 tst         r3, #1
  00180	0a000072	 beq         |$cleanUp$47313|
  00184	e59f020c	 ldr         r0, [pc, #0x20C]
  00188	eb000000	 bl          NKDbgPrintfW

; 333  :         goto cleanUp;

  0018c	ea00006f	 b           |$cleanUp$47313|
  00190		 |$LN16@OEMInit|

; 334  :         }
; 335  : 
; 336  :     //----------------------------------------------------------------------
; 337  :     // Initialize system clock
; 338  :     //----------------------------------------------------------------------
; 339  : 
; 340  :     if (!OALTimerInit(1, 0, 0))

  00190	e3a02000	 mov         r2, #0
  00194	e3a01000	 mov         r1, #0
  00198	e3a00001	 mov         r0, #1
  0019c	eb000000	 bl          OALTimerInit
  001a0	e3500000	 cmp         r0, #0
  001a4	1a000005	 bne         |$LN15@OEMInit|
  001a8	e5963440	 ldr         r3, [r6, #0x440]

; 341  :         {
; 342  :         OALMSG(OAL_ERROR, (
; 343  :             L"ERROR: OEMInit: Failed to initialize system clock\r\n"
; 344  :             ));

  001ac	e3130001	 tst         r3, #1
  001b0	0a000066	 beq         |$cleanUp$47313|
  001b4	e59f01d8	 ldr         r0, [pc, #0x1D8]
  001b8	eb000000	 bl          NKDbgPrintfW
  001bc	ea000063	 b           |$cleanUp$47313|
  001c0		 |$LN15@OEMInit|

; 345  :         goto cleanUp;
; 346  :         }
; 347  : 
; 348  :     // Configure the pads for the DSS (to keep the splashscreen active)
; 349  :     // do not request it, it may make the DSS driver fail to load (because it will not ba able to request its pads)
; 350  :     ConfigurePadArray(BSPGetDevicePadInfo(OMAP_DEVICE_DSS));

  001c0	e3a0003f	 mov         r0, #0x3F
  001c4	eb000000	 bl          BSPGetDevicePadInfo
  001c8	eb000000	 bl          ConfigurePadArray

; 351  :     //same thing for the UART3 (used for our OAL serial output
; 352  :     ConfigurePadArray(BSPGetDevicePadInfo(OMAP_DEVICE_UART3));

  001cc	e3a0003d	 mov         r0, #0x3D
  001d0	eb000000	 bl          BSPGetDevicePadInfo
  001d4	eb000000	 bl          ConfigurePadArray

; 353  :     ConfigurePadArray(BSPGetDevicePadInfo(OMAP_DEVICE_HSOTGUSB));

  001d8	e3a00003	 mov         r0, #3
  001dc	eb000000	 bl          BSPGetDevicePadInfo
  001e0	eb000000	 bl          ConfigurePadArray

; 354  : 
; 355  :     //all other pads are to be requested (GPMC is never reserved by drivers, I2C is handled by the kernel)
; 356  :     // GPIOs reservation may be split on per-GPIO basis and moved into the drivers that needs the GPIO. TBD
; 357  :     if (!RequestDevicePads(OMAP_DEVICE_GPMC)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for GPMC\r\n")));

  001e4	e3a00053	 mov         r0, #0x53
  001e8	eb000000	 bl          RequestDevicePads
  001ec	e3500000	 cmp         r0, #0
  001f0	1a000003	 bne         |$LN33@OEMInit|
  001f4	e5963440	 ldr         r3, [r6, #0x440]
  001f8	e3130001	 tst         r3, #1
  001fc	159f018c	 ldrne       r0, [pc, #0x18C]
  00200	1b000000	 blne        NKDbgPrintfW
  00204		 |$LN33@OEMInit|

; 358  :     if (!RequestDevicePads(OMAP_DEVICE_I2C1)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for I2C1\r\n")));

  00204	e3a0000c	 mov         r0, #0xC
  00208	eb000000	 bl          RequestDevicePads
  0020c	e3500000	 cmp         r0, #0
  00210	1a000003	 bne         |$LN35@OEMInit|
  00214	e5963440	 ldr         r3, [r6, #0x440]
  00218	e3130001	 tst         r3, #1
  0021c	159f0168	 ldrne       r0, [pc, #0x168]
  00220	1b000000	 blne        NKDbgPrintfW
  00224		 |$LN35@OEMInit|

; 359  :     if (!RequestDevicePads(OMAP_DEVICE_I2C2)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for I2C2\r\n")));

  00224	e3a0000d	 mov         r0, #0xD
  00228	eb000000	 bl          RequestDevicePads
  0022c	e3500000	 cmp         r0, #0
  00230	1a000003	 bne         |$LN37@OEMInit|
  00234	e5963440	 ldr         r3, [r6, #0x440]
  00238	e3130001	 tst         r3, #1
  0023c	159f0144	 ldrne       r0, [pc, #0x144]
  00240	1b000000	 blne        NKDbgPrintfW
  00244		 |$LN37@OEMInit|

; 360  :     if (!RequestDevicePads(OMAP_DEVICE_I2C3)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for I2C3\r\n")));

  00244	e3a0000e	 mov         r0, #0xE
  00248	eb000000	 bl          RequestDevicePads
  0024c	e3500000	 cmp         r0, #0
  00250	1a000003	 bne         |$LN49@OEMInit|
  00254	e5963440	 ldr         r3, [r6, #0x440]
  00258	e3130001	 tst         r3, #1
  0025c	159f0120	 ldrne       r0, [pc, #0x120]
  00260	1b000000	 blne        NKDbgPrintfW
  00264		 |$LN49@OEMInit|

; 361  :     if(g_dwCpuFamily == CPU_FAMILY_DM37XX)

  00264	e59b1000	 ldr         r1, [r11]
  00268	e3510001	 cmp         r1, #1

; 362  :     {
; 363  :         if (!RequestAndConfigurePadArray(gpioPads_37xx)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for the GPIOs\r\n")));

  0026c	02850068	 addeq       r0, r5, #0x68
  00270	0a000002	 beq         |$LN54@OEMInit|

; 364  :     }
; 365  :     else if(g_dwCpuFamily == CPU_FAMILY_OMAP35XX)

  00274	e3510000	 cmp         r1, #0
  00278	1a000009	 bne         |$LN7@OEMInit|

; 366  :     {
; 367  :         if (!RequestAndConfigurePadArray(gpioPads)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for the GPIOs\r\n")));

  0027c	e2850020	 add         r0, r5, #0x20
  00280		 |$LN54@OEMInit|
  00280	eb000000	 bl          RequestAndConfigurePadArray
  00284	e3500000	 cmp         r0, #0
  00288	1a000009	 bne         |$LN45@OEMInit|
  0028c	e5963440	 ldr         r3, [r6, #0x440]
  00290	e3130001	 tst         r3, #1
  00294	0a000006	 beq         |$LN45@OEMInit|
  00298	e59f00e0	 ldr         r0, [pc, #0xE0]
  0029c	eb000000	 bl          NKDbgPrintfW

; 368  :     }
; 369  :     else

  002a0	ea000003	 b           |$LN45@OEMInit|
  002a4		 |$LN7@OEMInit|

; 360  :     if (!RequestDevicePads(OMAP_DEVICE_I2C3)) OALMSG(OAL_ERROR, (TEXT("Failed to request pads for I2C3\r\n")));

  002a4	e5963440	 ldr         r3, [r6, #0x440]

; 370  :     {
; 371  :         OALMSG(OAL_ERROR, (
; 372  :             L"ERROR: OEMInit: CPU family %d is not supported\r\n", g_dwCpuFamily
; 373  :             ));

  002a8	e3130001	 tst         r3, #1
  002ac	159f00c8	 ldrne       r0, [pc, #0xC8]
  002b0	1b000000	 blne        NKDbgPrintfW
  002b4		 |$LN45@OEMInit|

; 374  :     }
; 375  : 
; 376  :     GPIOInit();

  002b4	eb000000	 bl          GPIOInit

; 377  : 
; 378  :     //----------------------------------------------------------------------
; 379  :     // Set GPIOs default values (like the buffers' OE)
; 380  :     //----------------------------------------------------------------------
; 381  :     OALGPIOSetDefaultValues();

  002b8	eb000000	 bl          OALGPIOSetDefaultValues

; 382  : 
; 383  :     //----------------------------------------------------------------------
; 384  :     // Initialize SRAM Functions
; 385  :     //----------------------------------------------------------------------
; 386  :     OALSRAMFnInit();

  002bc	eb000000	 bl          OALSRAMFnInit

; 387  :     
; 388  :     //----------------------------------------------------------------------
; 389  :     // kSYS_CLK calibration
; 390  :     // Now compute the real kSYS_CLK clock value. 
; 391  :     //----------------------------------------------------------------------
; 392  :     OALCalibrateSysClk();

  002c0	eb000000	 bl          OALCalibrateSysClk

; 393  : 
; 394  :     //----------------------------------------------------------------------
; 395  :     // Initialize high performance counter and profiling function pointers
; 396  :     //----------------------------------------------------------------------
; 397  :     OALPerformanceTimerInit();

  002c4	eb000000	 bl          OALPerformanceTimerInit

; 398  : 
; 399  : #ifdef TEST_TPS65023
; 400  :     { // Temporary : test of the TPS65023 interface
; 401  :         HANDLE hTwl;
; 402  :         HANDLE hI2CADC;
; 403  :         UINT16 mvMeasured=0;
; 404  :         volatile int debug=1;
; 405  :         UINT32 mv,mv1,mv4,mv5;
; 406  :         hI2CADC = I2COpen(OMAP_DEVICE_I2C1);
; 407  :         I2CSetSlaveAddress(hI2CADC,0x41);
; 408  :         I2CSetSubAddressMode(hI2CADC,I2C_SUBADDRESS_MODE_0);
; 409  :         hTwl = TWLOpen();
; 410  :         RETAILMSG(1,(TEXT("triton ID 0x%x \r\n"),TWLReadIDCode(hTwl)));
; 411  :         TWLGetVoltage(VDCDC1,&mv1);
; 412  :         TWLGetVoltage(VLDO1,&mv4);
; 413  :         TWLGetVoltage(VLDO2,&mv5);
; 414  :         RETAILMSG(1,(TEXT("vdcdc1 %d \r\n"),mv1));
; 415  :         RETAILMSG(1,(TEXT("ldo1 %d \r\n"),mv4));
; 416  :         RETAILMSG(1,(TEXT("ldo2 %d \r\n"),mv5));
; 417  : 
; 418  :         while(debug)
; 419  :         {
; 420  :             for (mv=1200;mv<1400;mv+=25)
; 421  :             {
; 422  :                 TWLSetVoltage(VDCDC1,mv);
; 423  :                 TWLGetVoltage(VDCDC1,&mv1);
; 424  :                 //I2CRead(hI2CADC,0,&mvMeasured,2);// Not working because some resistor are not placed
; 425  :                 RETAILMSG(1,(TEXT("vdcdc1 %d 0x%x \r\n"),mv1,mvMeasured));
; 426  :                 OALStall(1000);
; 427  :             }
; 428  :             for (mv=1400;mv>=1200;mv-=25)
; 429  :             {
; 430  :                 TWLSetVoltage(VDCDC1,mv);
; 431  :                 TWLGetVoltage(VDCDC1,&mv1);
; 432  :                 //I2CRead(hI2CADC,0,&mvMeasured,2);// Not working because some resistor are not placed
; 433  :                 RETAILMSG(1,(TEXT("vdcdc1 %d 0x%x \r\n"),mv1,mvMeasured));
; 434  :                 OALStall(1000);
; 435  :             }
; 436  :         }
; 437  :     }
; 438  : #endif
; 439  : 
; 440  :     //----------------------------------------------------------------------
; 441  :     // Initialize KITL
; 442  :     //----------------------------------------------------------------------
; 443  : 
; 444  :     g_oalKitlEnabled = KITLIoctl(IOCTL_KITL_STARTUP, NULL, 0, NULL, 0, NULL);

  002c8	e59f00a8	 ldr         r0, [pc, #0xA8]
  002cc	e3a0e000	 mov         lr, #0
  002d0	e3a03000	 mov         r3, #0
  002d4	e3a02000	 mov         r2, #0
  002d8	e3a01000	 mov         r1, #0
  002dc	e58de004	 str         lr, [sp, #4]
  002e0	e58de000	 str         lr, [sp]
  002e4	eb000000	 bl          KITLIoctl
  002e8	e59f2084	 ldr         r2, [pc, #0x84]
  002ec	e1a03000	 mov         r3, r0

; 445  : 
; 446  :     //----------------------------------------------------------------------
; 447  :     // Initialize the watchdog
; 448  :     //----------------------------------------------------------------------
; 449  : #ifdef BSP_OMAP_WATCHDOG
; 450  :     OALWatchdogInit(BSP_WATCHDOG_PERIOD_MILLISECONDS,BSP_WATCHDOG_THREAD_PRIORITY);
; 451  : #endif
; 452  : 
; 453  :     //----------------------------------------------------------------------
; 454  :     // Check for retail messages enabled
; 455  :     //----------------------------------------------------------------------
; 456  : 
; 457  :     pRetailMsgEnable = OALArgsQuery(OAL_ARGS_QUERY_OALFLAGS);

  002f0	e3a00044	 mov         r0, #0x44
  002f4	e5823000	 str         r3, [r2]
  002f8	eb000000	 bl          OALArgsQuery
  002fc	e3500000	 cmp         r0, #0

; 458  :     if (pRetailMsgEnable && (*pRetailMsgEnable & OAL_ARGS_OALFLAGS_RETAILMSG_ENABLE))

  00300	15903000	 ldrne       r3, [r0]
  00304	13130001	 tstne       r3, #1

; 459  :         g_oalRetailMsgEnable = TRUE;

  00308	13a03001	 movne       r3, #1
  0030c	158a3800	 strne       r3, [r10, #0x800]
  00310	059a3800	 ldreq       r3, [r10, #0x800]

; 460  : 
; 461  :     //----------------------------------------------------------------------
; 462  :     // Deinitialize serial debug
; 463  :     //----------------------------------------------------------------------
; 464  : 
; 465  :     if (!g_oalRetailMsgEnable)

  00314	e3530000	 cmp         r3, #0

; 466  :         OEMDeinitDebugSerial();

  00318	0b000000	 bleq        OEMDeinitDebugSerial

; 467  : 
; 468  : // not available under CE6
; 469  : #if (_WINCEOSVER >= 700)
; 470  :     //----------------------------------------------------------------------
; 471  :     // Make Page Tables walk L2 cacheable. There are 2 new fields in OEMGLOBAL
; 472  :     // that we need to update:
; 473  :     // dwTTBRCacheBits - the bits to set for TTBR to change page table walk
; 474  :     //                   to be L2 cacheable. (Cortex-A8 TRM, section 3.2.31)
; 475  :     //                   Set this to be "Outer Write-Back, Write-Allocate".
; 476  :     // dwPageTableCacheBits - bits to indicate cacheability to access Level
; 477  :     //                   L2 page table. We need to set it to "inner no cache,
; 478  :     //                   outer write-back, write-allocate. i.e.
; 479  :     //                      TEX = 0b101, and C=B=0.
; 480  :     //                   (ARM1176 TRM, section 6.11.2, figure 6.7, small (4k) page)
; 481  :     //----------------------------------------------------------------------
; 482  :     g_pOemGlobal->dwTTBRCacheBits = 0x8;            // TTBR RGN set to 0b01 - outer write back, write-allocate
; 483  :     g_pOemGlobal->dwPageTableCacheBits = 0x140;     // Page table cacheability uses 1BB/AA format, where AA = 0b00 (inner non-cached)
; 484  : #endif
; 485  : 
; 486  :     g_oalIoCtlClockSpeed = Get_CPUMaxSpeed(g_dwCpuFamily); //get MPU clock rate

  0031c	e59b0000	 ldr         r0, [r11]
  00320	eb000000	 bl          Get_CPUMaxSpeed
  00324	e59f2044	 ldr         r2, [pc, #0x44]
  00328	e1a03000	 mov         r3, r0

; 487  : 
; 488  :     //----------------------------------------------------------------------
; 489  :     // Check for a clean boot of device
; 490  :     //----------------------------------------------------------------------
; 491  :     pColdBoot = OALArgsQuery(OAL_ARGS_QUERY_COLDBOOT);

  0032c	e3a00040	 mov         r0, #0x40
  00330	e5823000	 str         r3, [r2]
  00334	eb000000	 bl          OALArgsQuery
  00338	e3500000	 cmp         r0, #0

; 492  :     if ((pColdBoot == NULL)|| ((pColdBoot != NULL) && *pColdBoot))

  0033c	0a000002	 beq         |$LN1@OEMInit|
  00340	e5903000	 ldr         r3, [r0]
  00344	e3530000	 cmp         r3, #0
  00348	0a000000	 beq         |$cleanUp$47313|
  0034c		 |$LN1@OEMInit|

; 493  :         NKForceCleanBoot();

  0034c	eb000000	 bl          NKForceCleanBoot
  00350		 |$cleanUp$47313|

; 329  :         {
; 330  :         OALMSG(OAL_ERROR, (
; 331  :             L"ERROR: OEMInit: failed to initialize interrupts\r\n"
; 332  :             ));

  00350	e5963440	 ldr         r3, [r6, #0x440]

; 494  :     
; 495  : cleanUp:
; 496  :     OALMSG(OAL_FUNC, (L"-OEMInit\r\n"));

  00354	e3130004	 tst         r3, #4
  00358	159f000c	 ldrne       r0, [pc, #0xC]
  0035c	1b000000	 blne        NKDbgPrintfW

; 497  : }

  00360	e28dd008	 add         sp, sp, #8
  00364	e8bd4ff0	 ldmia       sp!, {r4 - r11, lr}
  00368	e12fff1e	 bx          lr
  0036c		 |$LN60@OEMInit|
  0036c		 |$LN61@OEMInit|
  0036c	00000000	 DCD         |??_C@_1BG@OFOAIMMC@?$AA?9?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  00370		 |$LN62@OEMInit|
  00370	00000000	 DCD         |g_oalIoCtlClockSpeed|
  00374		 |$LN63@OEMInit|
  00374	00000000	 DCD         |g_oalKitlEnabled|
  00378		 |$LN64@OEMInit|
  00378	01010138	 DCD         0x1010138
  0037c		 |$LN65@OEMInit|
  0037c	00000000	 DCD         |??_C@_1GC@DDKEAEKM@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAf?$AAa?$AAm?$AAi?$AAl?$AAy?$AA?5?$AA?$CF?$AAd?$AA?5?$AAi?$AAs@|
  00380		 |$LN66@OEMInit|
  00380	00000000	 DCD         |??_C@_1EO@POAKKMOD@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAt?$AAh?$AAe?$AA?5?$AAG@|
  00384		 |$LN67@OEMInit|
  00384	00000000	 DCD         |??_C@_1EE@PJJENIL@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA3?$AA?$AN@|
  00388		 |$LN68@OEMInit|
  00388	00000000	 DCD         |??_C@_1EE@MDDDENBF@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA2?$AA?$AN@|
  0038c		 |$LN69@OEMInit|
  0038c	00000000	 DCD         |??_C@_1EE@ENLMEKPG@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAI?$AA2?$AAC?$AA1?$AA?$AN@|
  00390		 |$LN70@OEMInit|
  00390	00000000	 DCD         |??_C@_1EE@LCPCELLP@?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAr?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AA?5?$AAp?$AAa?$AAd?$AAs?$AA?5?$AAf?$AAo?$AAr?$AA?5?$AAG?$AAP?$AAM?$AAC?$AA?$AN@|
  00394		 |$LN71@OEMInit|
  00394	00000000	 DCD         |??_C@_1GI@LGFJGPEK@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAF?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa@|
  00398		 |$LN72@OEMInit|
  00398	00000000	 DCD         |??_C@_1GE@OIDINFAG@?$AAE?$AAR?$AAR?$AAO?$AAR?$AA?3?$AA?5?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAf?$AAa?$AAi?$AAl?$AAe?$AAd?$AA?5?$AAt?$AAo?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa@|
  0039c		 |$LN73@OEMInit|
  0039c	00000000	 DCD         |OEMEnumExtensionDRAM|
  003a0		 |$LN74@OEMInit|
  003a0	00000000	 DCD         |OALSetMemoryAttributes|
  003a4		 |$LN75@OEMInit|
  003a4	00000000	 DCD         |OALIsProcessorFeaturePresent|
  003a8		 |$LN76@OEMInit|
  003a8	00000000	 DCD         |g_pOemGlobal|
  003ac		 |$LN77@OEMInit|
  003ac	00000000	 DCD         |dwOEMDrWatsonSize|
  003b0		 |$LN78@OEMInit|
  003b0	00000000	 DCD         |??_C@_1EA@GGPFFMPF@?$AAO?$AAA?$AAL?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAL?$AA2?$AA?5?$AAA?$AAu?$AAx?$AA?5?$AAr?$AAe?$AAg?$AAi?$AAs?$AAt?$AAe?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AN?$AA?6?$AA?$AA@|
  003b4		 |$LN79@OEMInit|
  003b4	00000000	 DCD         |??_C@_1DI@EKICDEND@?$AAO?$AAA?$AAL?$AA?3?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAr?$AAe?$AAv?$AAi?$AAs?$AAi?$AAo?$AAn?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?3?$AA?$CF?$AAs?$AA?$AN?$AA?6?$AA?$AA@|
  003b8		 |$LN80@OEMInit|
  003b8	00000000	 DCD         |g_oalIoCtlProcessorName|
  003bc		 |$LN81@OEMInit|
  003bc	00000000	 DCD         |??_C@_1M@KGLOAAMK@?$AAO?$AAM?$AAA?$AAP?$AA3?$AA?$AA@|
  003c0		 |$LN82@OEMInit|
  003c0	00000000	 DCD         |gDevice_prefix|
  003c4		 |$LN83@OEMInit|
  003c4	00000000	 DCD         |??_C@_04BPMAMLNJ@EVM?9?$AA@|
  003c8		 |$LN84@OEMInit|
  003c8	00000000	 DCD         |g_oalIoCtlPlatformName|
  003cc		 |$LN85@OEMInit|
  003cc	00000000	 DCD         |g_oalIoCtlPlatformType|
  003d0		 |$LN86@OEMInit|
  003d0	00000000	 DCD         |??_C@_17EIAJIHBF@?$AAE?$AAV?$AAM?$AA?$AA@|
  003d4		 |$LN87@OEMInit|
  003d4	00000000	 DCD         |??_C@_1EA@KPKHFCLF@?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?3?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AA?5?$AAC?$AAP?$AAU?$AA?5?$AAF?$AAa?$AAm?$AAi?$AAl?$AAy?$AA?5?$AA?$CF?$AAd?$AA?$AN?$AA?6?$AA?$AA@|
  003d8		 |$LN88@OEMInit|
  003d8	00000000	 DCD         |??_C@_08DGJGOJCE@EVM3530?9?$AA@|
  003dc		 |$LN89@OEMInit|
  003dc	00000000	 DCD         |??_C@_1BC@CPMDPFBC@?$AAO?$AAM?$AAA?$AAP?$AA3?$AA5?$AA3?$AA0?$AA?$AA@|
  003e0		 |$LN90@OEMInit|
  003e0	00000000	 DCD         |??_C@_1BA@KEKEAPD@?$AAE?$AAV?$AAM?$AA3?$AA5?$AA3?$AA0?$AA?$AA@|
  003e4		 |$LN91@OEMInit|
  003e4	00000000	 DCD         |??_C@_08EMFGLKEE@EVM3730?9?$AA@|
  003e8		 |$LN92@OEMInit|
  003e8	00000000	 DCD         |??_C@_1O@KGJEKGDB@?$AAD?$AAM?$AA3?$AA7?$AA3?$AA0?$AA?$AA@|
  003ec		 |$LN93@OEMInit|
  003ec	00000000	 DCD         |??_C@_1BA@EIGPEHIO@?$AAE?$AAV?$AAM?$AA3?$AA7?$AA3?$AA0?$AA?$AA@|
  003f0		 |$LN94@OEMInit|
  003f0	00000000	 DCD         |g_dwCpuFamily|
  003f4		 |$LN95@OEMInit|
  003f4	00000000	 DCD         |g_dwCpuRevision|
  003f8		 |$LN96@OEMInit|
  003f8	00000000	 DCD         |?allocationPool@?1??OEMInit@@9@9|
  003fc		 |$LN97@OEMInit|
  003fc	00000000	 DCD         |??_C@_1BG@JHBBNGEC@?$AA?$CL?$AAO?$AAE?$AAM?$AAI?$AAn?$AAi?$AAt?$AA?$AN?$AA?6?$AA?$AA@|
  00400		 |$LN98@OEMInit|
  00400	00000000	 DCD         |dpCurSettings|
  00404		 |$M47714|

			 ENDP  ; |OEMInit|

	END
